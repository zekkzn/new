#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: DBDUIViewInterfaces

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "DBDUIViewInterfaces_structs.hpp"
#include "DBDSharedTypes_structs.hpp"
#include "NewsAndMessagesCommon_structs.hpp"
#include "RemoteContentCache_structs.hpp"
#include "UMG_structs.hpp"
#include "Engine_classes.hpp"


namespace SDK
{

// Class DBDUIViewInterfaces.AddonViewInterface
// 0x0000 (0x0030 - 0x0030)
class IAddonViewInterface final : public IInterface
{
public:
	void ClearData();
	void SetData(const struct FAddonViewData& BaseLoadoutPartViewData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AddonViewInterface">();
	}
	static class IAddonViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IAddonViewInterface>();
	}
};
static_assert(alignof(IAddonViewInterface) == 0x000008, "Wrong alignment on IAddonViewInterface");
static_assert(sizeof(IAddonViewInterface) == 0x000030, "Wrong size on IAddonViewInterface");

// Class DBDUIViewInterfaces.StoreCharactersSelectionViewInterface
// 0x0000 (0x0030 - 0x0030)
class IStoreCharactersSelectionViewInterface final : public IInterface
{
public:
	void SetData(const struct FStoreCharactersSelectionViewData& Data);
	void SetKillerPower(class UMenuPowerViewData* KillerPowerViewData);
	void SetPerksData(EPlayerRole Role, const TArray<class UMenuPerkViewData*>& Perks);
	void UpdateSelectedCharacter(const int32 SelectedCharacterIndex, const bool ScrollToSelection);

	TScriptInterface<class ISearchBarViewInterface> GetSearchBarViewInterface() const;
	TScriptInterface<class IStoreCharactersFilterViewInterface> GetStoreCharactersFilterInterface() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StoreCharactersSelectionViewInterface">();
	}
	static class IStoreCharactersSelectionViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IStoreCharactersSelectionViewInterface>();
	}
};
static_assert(alignof(IStoreCharactersSelectionViewInterface) == 0x000008, "Wrong alignment on IStoreCharactersSelectionViewInterface");
static_assert(sizeof(IStoreCharactersSelectionViewInterface) == 0x000030, "Wrong size on IStoreCharactersSelectionViewInterface");

// Class DBDUIViewInterfaces.AlertsViewInterface
// 0x0000 (0x0030 - 0x0030)
class IAlertsViewInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AlertsViewInterface">();
	}
	static class IAlertsViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IAlertsViewInterface>();
	}
};
static_assert(alignof(IAlertsViewInterface) == 0x000008, "Wrong alignment on IAlertsViewInterface");
static_assert(sizeof(IAlertsViewInterface) == 0x000030, "Wrong size on IAlertsViewInterface");

// Class DBDUIViewInterfaces.AnimationPreviewViewInterface
// 0x0000 (0x0030 - 0x0030)
class IAnimationPreviewViewInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimationPreviewViewInterface">();
	}
	static class IAnimationPreviewViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IAnimationPreviewViewInterface>();
	}
};
static_assert(alignof(IAnimationPreviewViewInterface) == 0x000008, "Wrong alignment on IAnimationPreviewViewInterface");
static_assert(sizeof(IAnimationPreviewViewInterface) == 0x000030, "Wrong size on IAnimationPreviewViewInterface");

// Class DBDUIViewInterfaces.GlobalProcessingIconViewInterface
// 0x0000 (0x0030 - 0x0030)
class IGlobalProcessingIconViewInterface final : public IInterface
{
public:
	void SetGlobalLoadingIconVisibility(bool IsVisible);
	void SetGlobalSavingIconVisibility(bool IsVisible);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GlobalProcessingIconViewInterface">();
	}
	static class IGlobalProcessingIconViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGlobalProcessingIconViewInterface>();
	}
};
static_assert(alignof(IGlobalProcessingIconViewInterface) == 0x000008, "Wrong alignment on IGlobalProcessingIconViewInterface");
static_assert(sizeof(IGlobalProcessingIconViewInterface) == 0x000030, "Wrong size on IGlobalProcessingIconViewInterface");

// Class DBDUIViewInterfaces.KillerStatusData
// 0x0000 (0x0030 - 0x0030)
class UKillerStatusData : public UObject
{
public:
	bool IsEqual(const class UKillerStatusData* Other) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerStatusData">();
	}
	static class UKillerStatusData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillerStatusData>();
	}
};
static_assert(alignof(UKillerStatusData) == 0x000008, "Wrong alignment on UKillerStatusData");
static_assert(sizeof(UKillerStatusData) == 0x000030, "Wrong size on UKillerStatusData");

// Class DBDUIViewInterfaces.NightmareStatusData
// 0x0010 (0x0040 - 0x0030)
class UNightmareStatusData final : public UKillerStatusData
{
public:
	ESleepingUIState                              SleepingState;                                     // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SleepingProgress;                                  // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SleepProtectionRemainingDuration;                  // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NightmareStatusData">();
	}
	static class UNightmareStatusData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNightmareStatusData>();
	}
};
static_assert(alignof(UNightmareStatusData) == 0x000008, "Wrong alignment on UNightmareStatusData");
static_assert(sizeof(UNightmareStatusData) == 0x000040, "Wrong size on UNightmareStatusData");
static_assert(offsetof(UNightmareStatusData, SleepingState) == 0x000030, "Member 'UNightmareStatusData::SleepingState' has a wrong offset!");
static_assert(offsetof(UNightmareStatusData, SleepingProgress) == 0x000034, "Member 'UNightmareStatusData::SleepingProgress' has a wrong offset!");
static_assert(offsetof(UNightmareStatusData, SleepProtectionRemainingDuration) == 0x000038, "Member 'UNightmareStatusData::SleepProtectionRemainingDuration' has a wrong offset!");

// Class DBDUIViewInterfaces.AntiCampSelfUnhookMeterViewInterface
// 0x0000 (0x0030 - 0x0030)
class IAntiCampSelfUnhookMeterViewInterface final : public IInterface
{
public:
	void SetProgress(const float Progress);
	void SetState(const EAntiCampSelfUnhookMeterState NewState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AntiCampSelfUnhookMeterViewInterface">();
	}
	static class IAntiCampSelfUnhookMeterViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IAntiCampSelfUnhookMeterViewInterface>();
	}
};
static_assert(alignof(IAntiCampSelfUnhookMeterViewInterface) == 0x000008, "Wrong alignment on IAntiCampSelfUnhookMeterViewInterface");
static_assert(sizeof(IAntiCampSelfUnhookMeterViewInterface) == 0x000030, "Wrong size on IAntiCampSelfUnhookMeterViewInterface");

// Class DBDUIViewInterfaces.ArchiveCompendiumViewInterface
// 0x0000 (0x0030 - 0x0030)
class IArchiveCompendiumViewInterface final : public IInterface
{
public:
	void SetPastTomesViewData(const TArray<struct FCompendiumButtonData>& PastStoryButtonData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArchiveCompendiumViewInterface">();
	}
	static class IArchiveCompendiumViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IArchiveCompendiumViewInterface>();
	}
};
static_assert(alignof(IArchiveCompendiumViewInterface) == 0x000008, "Wrong alignment on IArchiveCompendiumViewInterface");
static_assert(sizeof(IArchiveCompendiumViewInterface) == 0x000030, "Wrong size on IArchiveCompendiumViewInterface");

// Class DBDUIViewInterfaces.K30StatusData
// 0x0008 (0x0038 - 0x0030)
class UK30StatusData final : public UKillerStatusData
{
public:
	float                                         HuntRemainingPercentage;                           // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsHuntingSurvivor;                                 // 0x0034(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K30StatusData">();
	}
	static class UK30StatusData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK30StatusData>();
	}
};
static_assert(alignof(UK30StatusData) == 0x000008, "Wrong alignment on UK30StatusData");
static_assert(sizeof(UK30StatusData) == 0x000038, "Wrong size on UK30StatusData");
static_assert(offsetof(UK30StatusData, HuntRemainingPercentage) == 0x000030, "Member 'UK30StatusData::HuntRemainingPercentage' has a wrong offset!");
static_assert(offsetof(UK30StatusData, IsHuntingSurvivor) == 0x000034, "Member 'UK30StatusData::IsHuntingSurvivor' has a wrong offset!");

// Class DBDUIViewInterfaces.ArchiveEditorViewInterface
// 0x0000 (0x0030 - 0x0030)
class IArchiveEditorViewInterface final : public IInterface
{
public:
	void DisplayEditorSaving(const class FString& Path);
	void InitEditor();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArchiveEditorViewInterface">();
	}
	static class IArchiveEditorViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IArchiveEditorViewInterface>();
	}
};
static_assert(alignof(IArchiveEditorViewInterface) == 0x000008, "Wrong alignment on IArchiveEditorViewInterface");
static_assert(sizeof(IArchiveEditorViewInterface) == 0x000030, "Wrong size on IArchiveEditorViewInterface");

// Class DBDUIViewInterfaces.ArchiveImageViewerViewInterface
// 0x0000 (0x0030 - 0x0030)
class IArchiveImageViewerViewInterface final : public IInterface
{
public:
	void SetTextVisibility(bool Visible);
	void SetVoiceOverAutoplay(bool VoiceOverAutoplay);
	void SetVoiceOverPlaying(bool VoiceOverPlaying);
	void UpdateContent(const struct FArchivesVignetteEntryViewData& Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArchiveImageViewerViewInterface">();
	}
	static class IArchiveImageViewerViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IArchiveImageViewerViewInterface>();
	}
};
static_assert(alignof(IArchiveImageViewerViewInterface) == 0x000008, "Wrong alignment on IArchiveImageViewerViewInterface");
static_assert(sizeof(IArchiveImageViewerViewInterface) == 0x000030, "Wrong size on IArchiveImageViewerViewInterface");

// Class DBDUIViewInterfaces.K24StatusData
// 0x0008 (0x0038 - 0x0030)
class UK24StatusData final : public UKillerStatusData
{
public:
	bool                                          IsContaminated;                                    // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K24StatusData">();
	}
	static class UK24StatusData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK24StatusData>();
	}
};
static_assert(alignof(UK24StatusData) == 0x000008, "Wrong alignment on UK24StatusData");
static_assert(sizeof(UK24StatusData) == 0x000038, "Wrong size on UK24StatusData");
static_assert(offsetof(UK24StatusData, IsContaminated) == 0x000030, "Member 'UK24StatusData::IsContaminated' has a wrong offset!");

// Class DBDUIViewInterfaces.ArchiveJournalViewInterface
// 0x0000 (0x0030 - 0x0030)
class IArchiveJournalViewInterface final : public IInterface
{
public:
	void OnImageViewerVoiceOverAutoplay(bool Autoplay);
	void OnImageViewerVoiceOverPlayed();
	void SetArrowButtonEnabled(const bool IsEnabled);
	void SetCinematicButtonsEnabled(bool Enabled);
	void SetEntryData(const struct FArchivesVignetteEntryViewData& EntryViewData);
	void SetVignetteData(const struct FArchivesVignetteViewData& VignetteViewData);
	void SetVignetteInputsEnabled(bool Enabled);
	void SetVignetteList(const TArray<struct FArchivesVignetteViewData>& VignetteDataList);
	void SetVoiceOverAutoplay(bool VoiceOverAutoplay);
	void SetVoiceOverPlaying(bool VoiceOverPlaying);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArchiveJournalViewInterface">();
	}
	static class IArchiveJournalViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IArchiveJournalViewInterface>();
	}
};
static_assert(alignof(IArchiveJournalViewInterface) == 0x000008, "Wrong alignment on IArchiveJournalViewInterface");
static_assert(sizeof(IArchiveJournalViewInterface) == 0x000030, "Wrong size on IArchiveJournalViewInterface");

// Class DBDUIViewInterfaces.ArchiveLevelProgressionViewInterface
// 0x0000 (0x0030 - 0x0030)
class IArchiveLevelProgressionViewInterface final : public IInterface
{
public:
	void GoToNextLevel(int32 LevelIndex);
	void PlayRewardsAnimation();
	void SetActiveLevel(int32 LevelIndex, bool PerformAction);
	void SetLevelSelectorEnabled(const bool Enabled);
	void SetLevelSelectorVisibility(bool IsVisible);
	void SetRewardsContainerVisibility(bool IsVisible);
	void SetTomeLevelsData(const TArray<class UArchiveStoryLevelViewData*>& LevelsData, int32 SelectedLevel);
	void SetTomeRewardsData(const TArray<struct FRewardWrapperViewData>& RewardsData, bool AreLocked);
	void UpdateLevelStatus(int32 Level, EArchivesStoryLevelStatus Status);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArchiveLevelProgressionViewInterface">();
	}
	static class IArchiveLevelProgressionViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IArchiveLevelProgressionViewInterface>();
	}
};
static_assert(alignof(IArchiveLevelProgressionViewInterface) == 0x000008, "Wrong alignment on IArchiveLevelProgressionViewInterface");
static_assert(sizeof(IArchiveLevelProgressionViewInterface) == 0x000030, "Wrong size on IArchiveLevelProgressionViewInterface");

// Class DBDUIViewInterfaces.BasePopupViewData
// 0x0040 (0x0070 - 0x0030)
class UBasePopupViewData : public UObject
{
public:
	EPopupPriority                                Priority;                                          // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Title;                                             // 0x0038(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   Message;                                           // 0x0050(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          DisplayBackgroundOverlay;                          // 0x0068(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BasePopupViewData">();
	}
	static class UBasePopupViewData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBasePopupViewData>();
	}
};
static_assert(alignof(UBasePopupViewData) == 0x000008, "Wrong alignment on UBasePopupViewData");
static_assert(sizeof(UBasePopupViewData) == 0x000070, "Wrong size on UBasePopupViewData");
static_assert(offsetof(UBasePopupViewData, Priority) == 0x000030, "Member 'UBasePopupViewData::Priority' has a wrong offset!");
static_assert(offsetof(UBasePopupViewData, Title) == 0x000038, "Member 'UBasePopupViewData::Title' has a wrong offset!");
static_assert(offsetof(UBasePopupViewData, Message) == 0x000050, "Member 'UBasePopupViewData::Message' has a wrong offset!");
static_assert(offsetof(UBasePopupViewData, DisplayBackgroundOverlay) == 0x000068, "Member 'UBasePopupViewData::DisplayBackgroundOverlay' has a wrong offset!");

// Class DBDUIViewInterfaces.GenericPopupViewData
// 0x0180 (0x01F0 - 0x0070)
class UGenericPopupViewData : public UBasePopupViewData
{
public:
	struct FPopupButtonViewData                   ProgressionData;                                   // 0x0070(0x0080)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FPopupButtonViewData                   RegressionData;                                    // 0x00F0(0x0080)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FPopupButtonViewData                   AlternativeData;                                   // 0x0170(0x0080)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GenericPopupViewData">();
	}
	static class UGenericPopupViewData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGenericPopupViewData>();
	}
};
static_assert(alignof(UGenericPopupViewData) == 0x000010, "Wrong alignment on UGenericPopupViewData");
static_assert(sizeof(UGenericPopupViewData) == 0x0001F0, "Wrong size on UGenericPopupViewData");
static_assert(offsetof(UGenericPopupViewData, ProgressionData) == 0x000070, "Member 'UGenericPopupViewData::ProgressionData' has a wrong offset!");
static_assert(offsetof(UGenericPopupViewData, RegressionData) == 0x0000F0, "Member 'UGenericPopupViewData::RegressionData' has a wrong offset!");
static_assert(offsetof(UGenericPopupViewData, AlternativeData) == 0x000170, "Member 'UGenericPopupViewData::AlternativeData' has a wrong offset!");

// Class DBDUIViewInterfaces.GenericTextInputPopupViewData
// 0x00E0 (0x02D0 - 0x01F0)
class UGenericTextInputPopupViewData final : public UGenericPopupViewData
{
public:
	class FString                                 InputDefaultText;                                  // 0x01F0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AllowCopyPaste;                                    // 0x0200(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_201[0xCF];                                     // 0x0201(0x00CF)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GenericTextInputPopupViewData">();
	}
	static class UGenericTextInputPopupViewData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGenericTextInputPopupViewData>();
	}
};
static_assert(alignof(UGenericTextInputPopupViewData) == 0x000010, "Wrong alignment on UGenericTextInputPopupViewData");
static_assert(sizeof(UGenericTextInputPopupViewData) == 0x0002D0, "Wrong size on UGenericTextInputPopupViewData");
static_assert(offsetof(UGenericTextInputPopupViewData, InputDefaultText) == 0x0001F0, "Member 'UGenericTextInputPopupViewData::InputDefaultText' has a wrong offset!");
static_assert(offsetof(UGenericTextInputPopupViewData, AllowCopyPaste) == 0x000200, "Member 'UGenericTextInputPopupViewData::AllowCopyPaste' has a wrong offset!");

// Class DBDUIViewInterfaces.TwinsStatusData
// 0x0008 (0x0038 - 0x0030)
class UTwinsStatusData final : public UKillerStatusData
{
public:
	bool                                          TwinsActive;                                       // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TwinsStatusData">();
	}
	static class UTwinsStatusData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTwinsStatusData>();
	}
};
static_assert(alignof(UTwinsStatusData) == 0x000008, "Wrong alignment on UTwinsStatusData");
static_assert(sizeof(UTwinsStatusData) == 0x000038, "Wrong size on UTwinsStatusData");
static_assert(offsetof(UTwinsStatusData, TwinsActive) == 0x000030, "Member 'UTwinsStatusData::TwinsActive' has a wrong offset!");

// Class DBDUIViewInterfaces.ArchiveStoryLevelViewData
// 0x0010 (0x0040 - 0x0030)
class UArchiveStoryLevelViewData final : public UObject
{
public:
	int32                                         Level;                                             // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EArchivesStoryLevelStatus                     Status;                                            // 0x0034(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              StartDate;                                         // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArchiveStoryLevelViewData">();
	}
	static class UArchiveStoryLevelViewData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UArchiveStoryLevelViewData>();
	}
};
static_assert(alignof(UArchiveStoryLevelViewData) == 0x000008, "Wrong alignment on UArchiveStoryLevelViewData");
static_assert(sizeof(UArchiveStoryLevelViewData) == 0x000040, "Wrong size on UArchiveStoryLevelViewData");
static_assert(offsetof(UArchiveStoryLevelViewData, Level) == 0x000030, "Member 'UArchiveStoryLevelViewData::Level' has a wrong offset!");
static_assert(offsetof(UArchiveStoryLevelViewData, Status) == 0x000034, "Member 'UArchiveStoryLevelViewData::Status' has a wrong offset!");
static_assert(offsetof(UArchiveStoryLevelViewData, StartDate) == 0x000038, "Member 'UArchiveStoryLevelViewData::StartDate' has a wrong offset!");

// Class DBDUIViewInterfaces.ArchiveMenuViewInterface
// 0x0000 (0x0030 - 0x0030)
class IArchiveMenuViewInterface final : public IInterface
{
public:
	void ClearChallengeReminderData(EPlayerRole Role);
	void CloseSlotSelector();
	void HideUI();
	void Init();
	void SetChallengeReminderData(const struct FArchiveChallengeReminderViewData& Data, EPlayerRole Role, bool NeedsAnimation, const struct FVector2D& AnimationOriginalPosition);
	void SetChallengeReminderVisibility(bool IsVisible);
	void SetControllerElementsEnabled(bool Enabled);
	void SetDisplayStandAreaEnabled(bool Enabled);
	void SetEventLabel(const class FString& EventLabel);
	void SetInfoButtonEnabled(bool IsEnabled);
	void SetInfoButtonVisible(bool IsVisible);
	void SetMenuState(EArchiveMenuState MenuState);
	void SetQuestNodeHoverEffect(EPlayerRole Role, bool IsHovered);
	void SetRemainingTime(const class FString& RemainingTime, bool IsMoreThanWarningThreshold, EArchiveMenuState MenuState);
	void SetRemainingTimeVisible(bool IsVisible);
	void SetReminderSlotsEnabled(bool Enabled);
	void SetRiftPackButtonEnabled(bool IsEnabled);
	void SetSubtitle(const class FText& Subtitle);
	void SetSubtitleVisible(bool IsVisible);
	void SetTabEnabled(int32 Key, bool Enabled);
	void SetTabsData(const TArray<struct FTabWidgetData>& TabsData, int32 SelectedKey);
	void SetTabSelected(int32 Key);
	void SetTabsInputsEnabled(bool Enabled);
	void SetTitle(const class FText& Title);
	void ShowSlotSelector(const struct FArchiveNodeViewData& Data);
	void ShowUI();
	void UpdateBackgroundSkin(const int32 Key, const struct FArchiveTomeSkinData& Data);

	TScriptInterface<class IArchiveCompendiumViewInterface> GetArchiveCompendiumInterface() const;
	TScriptInterface<class IArchiveRiftViewInterface> GetArchiveRiftInterface() const;
	TScriptInterface<class IArchiveTomeViewInterface> GetArchiveTomeInterface() const;
	TScriptInterface<class IDisplayStandViewInterface> GetDisplayStandViewInterface() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArchiveMenuViewInterface">();
	}
	static class IArchiveMenuViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IArchiveMenuViewInterface>();
	}
};
static_assert(alignof(IArchiveMenuViewInterface) == 0x000008, "Wrong alignment on IArchiveMenuViewInterface");
static_assert(sizeof(IArchiveMenuViewInterface) == 0x000030, "Wrong size on IArchiveMenuViewInterface");

// Class DBDUIViewInterfaces.K28StatusData
// 0x0008 (0x0038 - 0x0030)
class UK28StatusData final : public UKillerStatusData
{
public:
	float                                         DayNightCycleProgressPercentage;                   // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsDaytime;                                         // 0x0034(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsTransitioningToNighttime;                        // 0x0035(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsNighttime;                                       // 0x0036(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsTransitioningToDaytime;                          // 0x0037(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K28StatusData">();
	}
	static class UK28StatusData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK28StatusData>();
	}
};
static_assert(alignof(UK28StatusData) == 0x000008, "Wrong alignment on UK28StatusData");
static_assert(sizeof(UK28StatusData) == 0x000038, "Wrong size on UK28StatusData");
static_assert(offsetof(UK28StatusData, DayNightCycleProgressPercentage) == 0x000030, "Member 'UK28StatusData::DayNightCycleProgressPercentage' has a wrong offset!");
static_assert(offsetof(UK28StatusData, IsDaytime) == 0x000034, "Member 'UK28StatusData::IsDaytime' has a wrong offset!");
static_assert(offsetof(UK28StatusData, IsTransitioningToNighttime) == 0x000035, "Member 'UK28StatusData::IsTransitioningToNighttime' has a wrong offset!");
static_assert(offsetof(UK28StatusData, IsNighttime) == 0x000036, "Member 'UK28StatusData::IsNighttime' has a wrong offset!");
static_assert(offsetof(UK28StatusData, IsTransitioningToDaytime) == 0x000037, "Member 'UK28StatusData::IsTransitioningToDaytime' has a wrong offset!");

// Class DBDUIViewInterfaces.ProcessingPopupViewData
// 0x0000 (0x0070 - 0x0070)
class UProcessingPopupViewData final : public UBasePopupViewData
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProcessingPopupViewData">();
	}
	static class UProcessingPopupViewData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProcessingPopupViewData>();
	}
};
static_assert(alignof(UProcessingPopupViewData) == 0x000008, "Wrong alignment on UProcessingPopupViewData");
static_assert(sizeof(UProcessingPopupViewData) == 0x000070, "Wrong size on UProcessingPopupViewData");

// Class DBDUIViewInterfaces.ArchivePassPurchasePopupViewData
// 0x00B0 (0x02A0 - 0x01F0)
class UArchivePassPurchasePopupViewData final : public UGenericPopupViewData
{
public:
	class FText                                   AvailabilityDates;                                 // 0x01F0(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         Quantity;                                          // 0x0208(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20C[0x4];                                      // 0x020C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UTexture2D>              ImageTexture;                                      // 0x0210(0x0038)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPriceTagViewData                      PriceTagViewData;                                  // 0x0248(0x0050)(BlueprintVisible, Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_298[0x8];                                      // 0x0298(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArchivePassPurchasePopupViewData">();
	}
	static class UArchivePassPurchasePopupViewData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UArchivePassPurchasePopupViewData>();
	}
};
static_assert(alignof(UArchivePassPurchasePopupViewData) == 0x000010, "Wrong alignment on UArchivePassPurchasePopupViewData");
static_assert(sizeof(UArchivePassPurchasePopupViewData) == 0x0002A0, "Wrong size on UArchivePassPurchasePopupViewData");
static_assert(offsetof(UArchivePassPurchasePopupViewData, AvailabilityDates) == 0x0001F0, "Member 'UArchivePassPurchasePopupViewData::AvailabilityDates' has a wrong offset!");
static_assert(offsetof(UArchivePassPurchasePopupViewData, Quantity) == 0x000208, "Member 'UArchivePassPurchasePopupViewData::Quantity' has a wrong offset!");
static_assert(offsetof(UArchivePassPurchasePopupViewData, ImageTexture) == 0x000210, "Member 'UArchivePassPurchasePopupViewData::ImageTexture' has a wrong offset!");
static_assert(offsetof(UArchivePassPurchasePopupViewData, PriceTagViewData) == 0x000248, "Member 'UArchivePassPurchasePopupViewData::PriceTagViewData' has a wrong offset!");

// Class DBDUIViewInterfaces.ArchivePassPurchasePopupViewInterface
// 0x0000 (0x0030 - 0x0030)
class IArchivePassPurchasePopupViewInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArchivePassPurchasePopupViewInterface">();
	}
	static class IArchivePassPurchasePopupViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IArchivePassPurchasePopupViewInterface>();
	}
};
static_assert(alignof(IArchivePassPurchasePopupViewInterface) == 0x000008, "Wrong alignment on IArchivePassPurchasePopupViewInterface");
static_assert(sizeof(IArchivePassPurchasePopupViewInterface) == 0x000030, "Wrong size on IArchivePassPurchasePopupViewInterface");

// Class DBDUIViewInterfaces.K32StatusData
// 0x0008 (0x0038 - 0x0030)
class UK32StatusData final : public UKillerStatusData
{
public:
	bool                                          IsAssimilated;                                     // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K32StatusData">();
	}
	static class UK32StatusData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK32StatusData>();
	}
};
static_assert(alignof(UK32StatusData) == 0x000008, "Wrong alignment on UK32StatusData");
static_assert(sizeof(UK32StatusData) == 0x000038, "Wrong size on UK32StatusData");
static_assert(offsetof(UK32StatusData, IsAssimilated) == 0x000030, "Member 'UK32StatusData::IsAssimilated' has a wrong offset!");

// Class DBDUIViewInterfaces.ArchiveQuestMapViewInterface
// 0x0000 (0x0030 - 0x0030)
class IArchiveQuestMapViewInterface final : public IInterface
{
public:
	void Reset();
	void SetLoadingSpinner(bool IsLoading);
	void SetQuestMapData(const TArray<struct FArchiveNodeGraphViewData>& NodeDataList, const TArray<struct FArchiveMapPathViewData>& PathDataList, bool NeedsCascadeAppear);
	void UpdateQuestMapData(const TArray<struct FArchiveNodeGraphViewData>& NodeDataList, const TArray<struct FArchiveMapPathViewData>& PathDataList);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArchiveQuestMapViewInterface">();
	}
	static class IArchiveQuestMapViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IArchiveQuestMapViewInterface>();
	}
};
static_assert(alignof(IArchiveQuestMapViewInterface) == 0x000008, "Wrong alignment on IArchiveQuestMapViewInterface");
static_assert(sizeof(IArchiveQuestMapViewInterface) == 0x000030, "Wrong size on IArchiveQuestMapViewInterface");

// Class DBDUIViewInterfaces.ArchiveRiftViewInterface
// 0x0000 (0x0030 - 0x0030)
class IArchiveRiftViewInterface final : public IInterface
{
public:
	void PlayUnlockingAnimation(const struct FArchivesRiftUnlockSequenceData& Data);
	void SetData(const struct FArchivesRiftGenericViewData& Data);
	void SetImagePreviewAreaData(const struct FCustomizationItemPreviewAreaViewData& ViewData);
	void SetMatchmakingSoftlockState(bool IsInMatchmakingSoftlock);
	void SetOutfitPreviewButtonVisible(const bool IsVisible);
	void SetRewardTiersData(const TArray<struct FArchiveRiftTierRewardsViewData>& RiftTiersData);
	void SetRiftFragmentTooltipViewData(const struct FCurrencyProgressionTooltipViewData& RiftFragmentTooltipViewData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArchiveRiftViewInterface">();
	}
	static class IArchiveRiftViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IArchiveRiftViewInterface>();
	}
};
static_assert(alignof(IArchiveRiftViewInterface) == 0x000008, "Wrong alignment on IArchiveRiftViewInterface");
static_assert(sizeof(IArchiveRiftViewInterface) == 0x000030, "Wrong size on IArchiveRiftViewInterface");

// Class DBDUIViewInterfaces.K26StatusData
// 0x0008 (0x0038 - 0x0030)
class UK26StatusData final : public UKillerStatusData
{
public:
	bool                                          IsCrowAttached;                                    // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K26StatusData">();
	}
	static class UK26StatusData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK26StatusData>();
	}
};
static_assert(alignof(UK26StatusData) == 0x000008, "Wrong alignment on UK26StatusData");
static_assert(sizeof(UK26StatusData) == 0x000038, "Wrong size on UK26StatusData");
static_assert(offsetof(UK26StatusData, IsCrowAttached) == 0x000030, "Member 'UK26StatusData::IsCrowAttached' has a wrong offset!");

// Class DBDUIViewInterfaces.ArchiveTierPurchasePopupViewData
// 0x00B0 (0x02A0 - 0x01F0)
class UArchiveTierPurchasePopupViewData final : public UGenericPopupViewData
{
public:
	TSoftObjectPtr<class UTexture2D>              ImageTexture;                                      // 0x01F0(0x0038)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxTiers;                                          // 0x0228(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentTier;                                       // 0x022C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Quantity;                                          // 0x0230(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UnitPrice;                                         // 0x0234(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentWalletAmount;                               // 0x0238(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FirstBonusTier;                                    // 0x023C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LastBonusTier;                                     // 0x0240(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsBonusTier;                                       // 0x0244(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_245[0x3];                                      // 0x0245(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPriceTagViewData                      PriceTagViewData;                                  // 0x0248(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         Pad_298[0x8];                                      // 0x0298(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArchiveTierPurchasePopupViewData">();
	}
	static class UArchiveTierPurchasePopupViewData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UArchiveTierPurchasePopupViewData>();
	}
};
static_assert(alignof(UArchiveTierPurchasePopupViewData) == 0x000010, "Wrong alignment on UArchiveTierPurchasePopupViewData");
static_assert(sizeof(UArchiveTierPurchasePopupViewData) == 0x0002A0, "Wrong size on UArchiveTierPurchasePopupViewData");
static_assert(offsetof(UArchiveTierPurchasePopupViewData, ImageTexture) == 0x0001F0, "Member 'UArchiveTierPurchasePopupViewData::ImageTexture' has a wrong offset!");
static_assert(offsetof(UArchiveTierPurchasePopupViewData, MaxTiers) == 0x000228, "Member 'UArchiveTierPurchasePopupViewData::MaxTiers' has a wrong offset!");
static_assert(offsetof(UArchiveTierPurchasePopupViewData, CurrentTier) == 0x00022C, "Member 'UArchiveTierPurchasePopupViewData::CurrentTier' has a wrong offset!");
static_assert(offsetof(UArchiveTierPurchasePopupViewData, Quantity) == 0x000230, "Member 'UArchiveTierPurchasePopupViewData::Quantity' has a wrong offset!");
static_assert(offsetof(UArchiveTierPurchasePopupViewData, UnitPrice) == 0x000234, "Member 'UArchiveTierPurchasePopupViewData::UnitPrice' has a wrong offset!");
static_assert(offsetof(UArchiveTierPurchasePopupViewData, CurrentWalletAmount) == 0x000238, "Member 'UArchiveTierPurchasePopupViewData::CurrentWalletAmount' has a wrong offset!");
static_assert(offsetof(UArchiveTierPurchasePopupViewData, FirstBonusTier) == 0x00023C, "Member 'UArchiveTierPurchasePopupViewData::FirstBonusTier' has a wrong offset!");
static_assert(offsetof(UArchiveTierPurchasePopupViewData, LastBonusTier) == 0x000240, "Member 'UArchiveTierPurchasePopupViewData::LastBonusTier' has a wrong offset!");
static_assert(offsetof(UArchiveTierPurchasePopupViewData, IsBonusTier) == 0x000244, "Member 'UArchiveTierPurchasePopupViewData::IsBonusTier' has a wrong offset!");
static_assert(offsetof(UArchiveTierPurchasePopupViewData, PriceTagViewData) == 0x000248, "Member 'UArchiveTierPurchasePopupViewData::PriceTagViewData' has a wrong offset!");

// Class DBDUIViewInterfaces.ArchiveTierPurchasePopupViewInterface
// 0x0000 (0x0030 - 0x0030)
class IArchiveTierPurchasePopupViewInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArchiveTierPurchasePopupViewInterface">();
	}
	static class IArchiveTierPurchasePopupViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IArchiveTierPurchasePopupViewInterface>();
	}
};
static_assert(alignof(IArchiveTierPurchasePopupViewInterface) == 0x000008, "Wrong alignment on IArchiveTierPurchasePopupViewInterface");
static_assert(sizeof(IArchiveTierPurchasePopupViewInterface) == 0x000030, "Wrong size on IArchiveTierPurchasePopupViewInterface");

// Class DBDUIViewInterfaces.PowerBundleViewInterface
// 0x0000 (0x0030 - 0x0030)
class IPowerBundleViewInterface final : public IInterface
{
public:
	void ClearData();
	void SetData(const struct FPowerBundleViewData& PowerBundleViewData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PowerBundleViewInterface">();
	}
	static class IPowerBundleViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPowerBundleViewInterface>();
	}
};
static_assert(alignof(IPowerBundleViewInterface) == 0x000008, "Wrong alignment on IPowerBundleViewInterface");
static_assert(sizeof(IPowerBundleViewInterface) == 0x000030, "Wrong size on IPowerBundleViewInterface");

// Class DBDUIViewInterfaces.ArchiveTomeViewInterface
// 0x0000 (0x0030 - 0x0030)
class IArchiveTomeViewInterface final : public IInterface
{
public:
	void SetMenuState(EArchiveTomeMenuState MenuState);
	void SetNotificationVisibility(int32 Key, bool HasNotification);
	void SetSideNavTabsData(const TArray<struct FTabWidgetData>& TabsData, int32 SelectedKey);
	void SetSideNavTabsEnabled(int32 Key, bool IsEnabled);
	void SetSideNavTabsVisibility(int32 Key, bool IsVisible);
	void SetUiTakeoverActive(bool IsActive);
	void ToggleEditor(bool IsEnabled);
	void UpdateBackgroundSkin(int32 Key, class UMaterialInterface* SkinMaterail);

	struct FEditorInterfaces GetArchiveEditorInterface() const;
	TScriptInterface<class IArchiveJournalViewInterface> GetArchiveJournalInterface() const;
	TScriptInterface<class IArchiveLevelProgressionViewInterface> GetArchiveLevelProgressionInterface() const;
	TScriptInterface<class IArchiveQuestMapViewInterface> GetArchiveQuestMapInterface() const;
	const EArchiveTomeMenuState GetMenuState() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArchiveTomeViewInterface">();
	}
	static class IArchiveTomeViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IArchiveTomeViewInterface>();
	}
};
static_assert(alignof(IArchiveTomeViewInterface) == 0x000008, "Wrong alignment on IArchiveTomeViewInterface");
static_assert(sizeof(IArchiveTomeViewInterface) == 0x000030, "Wrong size on IArchiveTomeViewInterface");

// Class DBDUIViewInterfaces.AuricCellsViewInterface
// 0x0000 (0x0030 - 0x0030)
class IAuricCellsViewInterface final : public IInterface
{
public:
	void SetData(const struct FAuricCellsViewData& ViewData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AuricCellsViewInterface">();
	}
	static class IAuricCellsViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IAuricCellsViewInterface>();
	}
};
static_assert(alignof(IAuricCellsViewInterface) == 0x000008, "Wrong alignment on IAuricCellsViewInterface");
static_assert(sizeof(IAuricCellsViewInterface) == 0x000030, "Wrong size on IAuricCellsViewInterface");

// Class DBDUIViewInterfaces.ReportFeedbackPopupViewInterface
// 0x0000 (0x0030 - 0x0030)
class IReportFeedbackPopupViewInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReportFeedbackPopupViewInterface">();
	}
	static class IReportFeedbackPopupViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IReportFeedbackPopupViewInterface>();
	}
};
static_assert(alignof(IReportFeedbackPopupViewInterface) == 0x000008, "Wrong alignment on IReportFeedbackPopupViewInterface");
static_assert(sizeof(IReportFeedbackPopupViewInterface) == 0x000030, "Wrong size on IReportFeedbackPopupViewInterface");

// Class DBDUIViewInterfaces.BasePopupViewInterface
// 0x0000 (0x0030 - 0x0030)
class IBasePopupViewInterface final : public IInterface
{
public:
	void Enter(class UBasePopupViewData* Data);
	void Leave();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BasePopupViewInterface">();
	}
	static class IBasePopupViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IBasePopupViewInterface>();
	}
};
static_assert(alignof(IBasePopupViewInterface) == 0x000008, "Wrong alignment on IBasePopupViewInterface");
static_assert(sizeof(IBasePopupViewInterface) == 0x000030, "Wrong size on IBasePopupViewInterface");

// Class DBDUIViewInterfaces.ChallengesMenuChallengeSetViewInterface
// 0x0000 (0x0030 - 0x0030)
class IChallengesMenuChallengeSetViewInterface final : public IInterface
{
public:
	void SetEventVisuals(const class FString& EventFrameLabel);
	void SetTabEnabled(const int32 Key, const bool Enabled);
	void SetTabsData(const TArray<struct FTabWidgetData>& TabsData, const int32 SelectedKey);
	void SetTabSelected(const int32 Key);

	TScriptInterface<class IChallengesMenuRewardTrackViewInterface> GetRewardTrackInterface() const;
	TScriptInterface<class IChallengesMenuRitualsViewInterface> GetRitualsInterface() const;
	TScriptInterface<class IChallengesMenuStoreViewInterface> GetStoreInterface() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChallengesMenuChallengeSetViewInterface">();
	}
	static class IChallengesMenuChallengeSetViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IChallengesMenuChallengeSetViewInterface>();
	}
};
static_assert(alignof(IChallengesMenuChallengeSetViewInterface) == 0x000008, "Wrong alignment on IChallengesMenuChallengeSetViewInterface");
static_assert(sizeof(IChallengesMenuChallengeSetViewInterface) == 0x000030, "Wrong size on IChallengesMenuChallengeSetViewInterface");

// Class DBDUIViewInterfaces.ProfileMenuCustomizationViewInterface
// 0x0000 (0x0030 - 0x0030)
class IProfileMenuCustomizationViewInterface final : public IInterface
{
public:
	void Deinit();
	void DeselectItem();
	void EnableInputs(const bool Enable);
	void Init(ECustomizationCategory CustomizationCategory, ESortingOption SortingOption);
	void SetEquipButtonText(const bool CanEquip, const bool IsEquipped);
	void SetItemsData(const TArray<class UStoreCustomizationItemViewData*>& CustomizationRewardsData, const int32 SelectedIndex);
	void SetPreviewAreaData(const struct FCustomizationItemPreviewAreaViewData& ViewData, const bool NoCustomizationEquipped);
	void SetSelectedItem(const int32 SelectedIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProfileMenuCustomizationViewInterface">();
	}
	static class IProfileMenuCustomizationViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IProfileMenuCustomizationViewInterface>();
	}
};
static_assert(alignof(IProfileMenuCustomizationViewInterface) == 0x000008, "Wrong alignment on IProfileMenuCustomizationViewInterface");
static_assert(sizeof(IProfileMenuCustomizationViewInterface) == 0x000030, "Wrong size on IProfileMenuCustomizationViewInterface");

// Class DBDUIViewInterfaces.ChallengesMenuRewardTrackViewInterface
// 0x0000 (0x0030 - 0x0030)
class IChallengesMenuRewardTrackViewInterface final : public IInterface
{
public:
	void SetEventVisuals(const class FString& EventFrameLabel);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChallengesMenuRewardTrackViewInterface">();
	}
	static class IChallengesMenuRewardTrackViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IChallengesMenuRewardTrackViewInterface>();
	}
};
static_assert(alignof(IChallengesMenuRewardTrackViewInterface) == 0x000008, "Wrong alignment on IChallengesMenuRewardTrackViewInterface");
static_assert(sizeof(IChallengesMenuRewardTrackViewInterface) == 0x000030, "Wrong size on IChallengesMenuRewardTrackViewInterface");

// Class DBDUIViewInterfaces.ChallengesMenuRitualsViewInterface
// 0x0000 (0x0030 - 0x0030)
class IChallengesMenuRitualsViewInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChallengesMenuRitualsViewInterface">();
	}
	static class IChallengesMenuRitualsViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IChallengesMenuRitualsViewInterface>();
	}
};
static_assert(alignof(IChallengesMenuRitualsViewInterface) == 0x000008, "Wrong alignment on IChallengesMenuRitualsViewInterface");
static_assert(sizeof(IChallengesMenuRitualsViewInterface) == 0x000030, "Wrong size on IChallengesMenuRitualsViewInterface");

// Class DBDUIViewInterfaces.K36StatusData
// 0x0018 (0x0048 - 0x0030)
class UK36StatusData final : public UKillerStatusData
{
public:
	bool                                          HasBracers;                                        // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasBoots;                                          // 0x0031(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasAssimilatedEyeArtifact;                         // 0x0032(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanUseEyeArtifactPower;                            // 0x0033(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasAssimilatedHandArtifact;                        // 0x0034(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanUseHandArtifactPower;                           // 0x0035(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShouldSeeBootsCounterSpell;                        // 0x0036(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShouldSeeBracersCounterSpell;                      // 0x0037(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsInjured;                                         // 0x0038(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AreMagicItemsVFXsHidden;                           // 0x0039(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x2];                                       // 0x003A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         BootsCounterID;                                    // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BracersCounterID;                                  // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DisableMagicItemProgressionPercentage;             // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K36StatusData">();
	}
	static class UK36StatusData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK36StatusData>();
	}
};
static_assert(alignof(UK36StatusData) == 0x000008, "Wrong alignment on UK36StatusData");
static_assert(sizeof(UK36StatusData) == 0x000048, "Wrong size on UK36StatusData");
static_assert(offsetof(UK36StatusData, HasBracers) == 0x000030, "Member 'UK36StatusData::HasBracers' has a wrong offset!");
static_assert(offsetof(UK36StatusData, HasBoots) == 0x000031, "Member 'UK36StatusData::HasBoots' has a wrong offset!");
static_assert(offsetof(UK36StatusData, HasAssimilatedEyeArtifact) == 0x000032, "Member 'UK36StatusData::HasAssimilatedEyeArtifact' has a wrong offset!");
static_assert(offsetof(UK36StatusData, CanUseEyeArtifactPower) == 0x000033, "Member 'UK36StatusData::CanUseEyeArtifactPower' has a wrong offset!");
static_assert(offsetof(UK36StatusData, HasAssimilatedHandArtifact) == 0x000034, "Member 'UK36StatusData::HasAssimilatedHandArtifact' has a wrong offset!");
static_assert(offsetof(UK36StatusData, CanUseHandArtifactPower) == 0x000035, "Member 'UK36StatusData::CanUseHandArtifactPower' has a wrong offset!");
static_assert(offsetof(UK36StatusData, ShouldSeeBootsCounterSpell) == 0x000036, "Member 'UK36StatusData::ShouldSeeBootsCounterSpell' has a wrong offset!");
static_assert(offsetof(UK36StatusData, ShouldSeeBracersCounterSpell) == 0x000037, "Member 'UK36StatusData::ShouldSeeBracersCounterSpell' has a wrong offset!");
static_assert(offsetof(UK36StatusData, IsInjured) == 0x000038, "Member 'UK36StatusData::IsInjured' has a wrong offset!");
static_assert(offsetof(UK36StatusData, AreMagicItemsVFXsHidden) == 0x000039, "Member 'UK36StatusData::AreMagicItemsVFXsHidden' has a wrong offset!");
static_assert(offsetof(UK36StatusData, BootsCounterID) == 0x00003C, "Member 'UK36StatusData::BootsCounterID' has a wrong offset!");
static_assert(offsetof(UK36StatusData, BracersCounterID) == 0x000040, "Member 'UK36StatusData::BracersCounterID' has a wrong offset!");
static_assert(offsetof(UK36StatusData, DisableMagicItemProgressionPercentage) == 0x000044, "Member 'UK36StatusData::DisableMagicItemProgressionPercentage' has a wrong offset!");

// Class DBDUIViewInterfaces.ChallengesMenuStoreViewInterface
// 0x0000 (0x0030 - 0x0030)
class IChallengesMenuStoreViewInterface final : public IInterface
{
public:
	void Deinit();
	void DeselectReward();
	void EnableStoreButton(const bool Enable);
	void Init();
	void SetItemsData(const TArray<class UStoreCustomizationItemViewData*>& CustomizationRewardsData, const int32 SelectedIndex);
	void SetPreviewAreaData(const struct FCustomizationItemPreviewAreaViewData& ViewData);
	void SetSelectedReward(const int32 SelectedIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChallengesMenuStoreViewInterface">();
	}
	static class IChallengesMenuStoreViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IChallengesMenuStoreViewInterface>();
	}
};
static_assert(alignof(IChallengesMenuStoreViewInterface) == 0x000008, "Wrong alignment on IChallengesMenuStoreViewInterface");
static_assert(sizeof(IChallengesMenuStoreViewInterface) == 0x000030, "Wrong size on IChallengesMenuStoreViewInterface");

// Class DBDUIViewInterfaces.ChallengesMenuViewInterface
// 0x0000 (0x0030 - 0x0030)
class IChallengesMenuViewInterface final : public IInterface
{
public:
	TScriptInterface<class IChallengesMenuChallengeSetViewInterface> AddChallengeSet(const struct FChallengeSetViewData& ViewData);
	void SetEventVisuals(const class FString& EventFrameLabel);
	void SetIsFocused(const bool IsFocused);
	void SetSubtitle(const class FText& Subtitle);
	void SetTabEnabled(const int32 Key, const bool Enabled);
	void SetTabsData(const TArray<struct FTabWidgetData>& TabsData, const int32 SelectedKey);
	void SetTabSelected(const int32 Key);
	void SetTitle(const class FText& Title);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChallengesMenuViewInterface">();
	}
	static class IChallengesMenuViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IChallengesMenuViewInterface>();
	}
};
static_assert(alignof(IChallengesMenuViewInterface) == 0x000008, "Wrong alignment on IChallengesMenuViewInterface");
static_assert(sizeof(IChallengesMenuViewInterface) == 0x000030, "Wrong size on IChallengesMenuViewInterface");

// Class DBDUIViewInterfaces.LoadoutMenuViewData
// 0x0130 (0x0160 - 0x0030)
class ULoadoutMenuViewData final : public UObject
{
public:
	TSoftObjectPtr<class UTexture2D>              LoadoutIcon;                                       // 0x0030(0x0038)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ItemId;                                            // 0x0068(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DisplayName;                                       // 0x0078(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   ParentDisplayName;                                 // 0x0090(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   ParentTypeDisplayName;                             // 0x00A8(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          IsParentAvailable;                                 // 0x00C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C1[0x7];                                       // 0x00C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Description;                                       // 0x00C8(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	EInventoryItemType                            ItemType;                                          // 0x00E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemRarity                                   Rarity;                                            // 0x00E1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStatusEffectType                             StatusEffectType;                                  // 0x00E2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E3[0x1];                                       // 0x00E3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Level;                                             // 0x00E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Subtitle;                                          // 0x00E8(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         StackCount;                                        // 0x0100(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemAvailability                             Availability;                                      // 0x0104(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsTeachablePerk;                                   // 0x0105(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsSlasherPerk;                                     // 0x0106(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsSlasher;                                         // 0x0107(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsLocked;                                          // 0x0108(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsKillSwitch;                                      // 0x0109(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10A[0x6];                                      // 0x010A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   EventName;                                         // 0x0110(0x0018)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPublic)
	class FString                                 EventID;                                           // 0x0128(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsPastEvent;                                       // 0x0138(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_139[0x7];                                      // 0x0139(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 EventBannerLabel;                                  // 0x0140(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CharacterClass;                                    // 0x0150(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoadoutMenuViewData">();
	}
	static class ULoadoutMenuViewData* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoadoutMenuViewData>();
	}
};
static_assert(alignof(ULoadoutMenuViewData) == 0x000008, "Wrong alignment on ULoadoutMenuViewData");
static_assert(sizeof(ULoadoutMenuViewData) == 0x000160, "Wrong size on ULoadoutMenuViewData");
static_assert(offsetof(ULoadoutMenuViewData, LoadoutIcon) == 0x000030, "Member 'ULoadoutMenuViewData::LoadoutIcon' has a wrong offset!");
static_assert(offsetof(ULoadoutMenuViewData, ItemId) == 0x000068, "Member 'ULoadoutMenuViewData::ItemId' has a wrong offset!");
static_assert(offsetof(ULoadoutMenuViewData, DisplayName) == 0x000078, "Member 'ULoadoutMenuViewData::DisplayName' has a wrong offset!");
static_assert(offsetof(ULoadoutMenuViewData, ParentDisplayName) == 0x000090, "Member 'ULoadoutMenuViewData::ParentDisplayName' has a wrong offset!");
static_assert(offsetof(ULoadoutMenuViewData, ParentTypeDisplayName) == 0x0000A8, "Member 'ULoadoutMenuViewData::ParentTypeDisplayName' has a wrong offset!");
static_assert(offsetof(ULoadoutMenuViewData, IsParentAvailable) == 0x0000C0, "Member 'ULoadoutMenuViewData::IsParentAvailable' has a wrong offset!");
static_assert(offsetof(ULoadoutMenuViewData, Description) == 0x0000C8, "Member 'ULoadoutMenuViewData::Description' has a wrong offset!");
static_assert(offsetof(ULoadoutMenuViewData, ItemType) == 0x0000E0, "Member 'ULoadoutMenuViewData::ItemType' has a wrong offset!");
static_assert(offsetof(ULoadoutMenuViewData, Rarity) == 0x0000E1, "Member 'ULoadoutMenuViewData::Rarity' has a wrong offset!");
static_assert(offsetof(ULoadoutMenuViewData, StatusEffectType) == 0x0000E2, "Member 'ULoadoutMenuViewData::StatusEffectType' has a wrong offset!");
static_assert(offsetof(ULoadoutMenuViewData, Level) == 0x0000E4, "Member 'ULoadoutMenuViewData::Level' has a wrong offset!");
static_assert(offsetof(ULoadoutMenuViewData, Subtitle) == 0x0000E8, "Member 'ULoadoutMenuViewData::Subtitle' has a wrong offset!");
static_assert(offsetof(ULoadoutMenuViewData, StackCount) == 0x000100, "Member 'ULoadoutMenuViewData::StackCount' has a wrong offset!");
static_assert(offsetof(ULoadoutMenuViewData, Availability) == 0x000104, "Member 'ULoadoutMenuViewData::Availability' has a wrong offset!");
static_assert(offsetof(ULoadoutMenuViewData, IsTeachablePerk) == 0x000105, "Member 'ULoadoutMenuViewData::IsTeachablePerk' has a wrong offset!");
static_assert(offsetof(ULoadoutMenuViewData, IsSlasherPerk) == 0x000106, "Member 'ULoadoutMenuViewData::IsSlasherPerk' has a wrong offset!");
static_assert(offsetof(ULoadoutMenuViewData, IsSlasher) == 0x000107, "Member 'ULoadoutMenuViewData::IsSlasher' has a wrong offset!");
static_assert(offsetof(ULoadoutMenuViewData, IsLocked) == 0x000108, "Member 'ULoadoutMenuViewData::IsLocked' has a wrong offset!");
static_assert(offsetof(ULoadoutMenuViewData, IsKillSwitch) == 0x000109, "Member 'ULoadoutMenuViewData::IsKillSwitch' has a wrong offset!");
static_assert(offsetof(ULoadoutMenuViewData, EventName) == 0x000110, "Member 'ULoadoutMenuViewData::EventName' has a wrong offset!");
static_assert(offsetof(ULoadoutMenuViewData, EventID) == 0x000128, "Member 'ULoadoutMenuViewData::EventID' has a wrong offset!");
static_assert(offsetof(ULoadoutMenuViewData, IsPastEvent) == 0x000138, "Member 'ULoadoutMenuViewData::IsPastEvent' has a wrong offset!");
static_assert(offsetof(ULoadoutMenuViewData, EventBannerLabel) == 0x000140, "Member 'ULoadoutMenuViewData::EventBannerLabel' has a wrong offset!");
static_assert(offsetof(ULoadoutMenuViewData, CharacterClass) == 0x000150, "Member 'ULoadoutMenuViewData::CharacterClass' has a wrong offset!");

// Class DBDUIViewInterfaces.ChallengeTrackerContainerViewInterface
// 0x0000 (0x0030 - 0x0030)
class IChallengeTrackerContainerViewInterface final : public IInterface
{
public:
	void Deinitialize();
	void InitWidgetData(const TArray<struct FChallengeTrackerViewData>& ViewData);
	void UpdateChallenges(const TArray<struct FChallengeTrackerViewData>& ViewData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChallengeTrackerContainerViewInterface">();
	}
	static class IChallengeTrackerContainerViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IChallengeTrackerContainerViewInterface>();
	}
};
static_assert(alignof(IChallengeTrackerContainerViewInterface) == 0x000008, "Wrong alignment on IChallengeTrackerContainerViewInterface");
static_assert(sizeof(IChallengeTrackerContainerViewInterface) == 0x000030, "Wrong size on IChallengeTrackerContainerViewInterface");

// Class DBDUIViewInterfaces.ChallengeTrackerViewInterface
// 0x0000 (0x0030 - 0x0030)
class IChallengeTrackerViewInterface final : public IInterface
{
public:
	void CloseWidget();
	void InitWidgetData(const struct FChallengeTrackerViewData& ViewData);
	void OpenWidget();
	void SetWidgetProgression(const struct FArchiveNodeObjectiveViewData& ProgressionData);
	void SetWidgetVisuals(const struct FChallengeTrackerSkinData& SkinData);
	void UpdateWidgetProgression(const struct FArchiveNodeObjectiveViewData& ProgressionData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChallengeTrackerViewInterface">();
	}
	static class IChallengeTrackerViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IChallengeTrackerViewInterface>();
	}
};
static_assert(alignof(IChallengeTrackerViewInterface) == 0x000008, "Wrong alignment on IChallengeTrackerViewInterface");
static_assert(sizeof(IChallengeTrackerViewInterface) == 0x000030, "Wrong size on IChallengeTrackerViewInterface");

// Class DBDUIViewInterfaces.ScreenIndicatorsContainerViewInterface
// 0x0000 (0x0030 - 0x0030)
class IScreenIndicatorsContainerViewInterface final : public IInterface
{
public:
	void RemoveDirectionIndicator(const class FString& ID);
	void ShowDirectionIndicator(const struct FScreenIndicatorViewData& Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScreenIndicatorsContainerViewInterface">();
	}
	static class IScreenIndicatorsContainerViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IScreenIndicatorsContainerViewInterface>();
	}
};
static_assert(alignof(IScreenIndicatorsContainerViewInterface) == 0x000008, "Wrong alignment on IScreenIndicatorsContainerViewInterface");
static_assert(sizeof(IScreenIndicatorsContainerViewInterface) == 0x000030, "Wrong size on IScreenIndicatorsContainerViewInterface");

// Class DBDUIViewInterfaces.CinematicViewInterface
// 0x0000 (0x0030 - 0x0030)
class ICinematicViewInterface final : public IInterface
{
public:
	void FadeInAnimation(const float FadeInDuration, const float Delay);
	void FadeOutAnimation(const float FadeOutDuration, const float Delay);
	class UBinkMediaPlayer* GetBinkVideoPlayer();
	void SetSize(const struct FVector2D& Size);
	void SetSkipInputSwitcherEnabled(bool IsEnabled);
	void SetSkipInputSwitcherVisibility(bool IsVisible);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CinematicViewInterface">();
	}
	static class ICinematicViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ICinematicViewInterface>();
	}
};
static_assert(alignof(ICinematicViewInterface) == 0x000008, "Wrong alignment on ICinematicViewInterface");
static_assert(sizeof(ICinematicViewInterface) == 0x000030, "Wrong size on ICinematicViewInterface");

// Class DBDUIViewInterfaces.CommonUIDelegates
// 0x0000 (0x0030 - 0x0030)
class UCommonUIDelegates final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommonUIDelegates">();
	}
	static class UCommonUIDelegates* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommonUIDelegates>();
	}
};
static_assert(alignof(UCommonUIDelegates) == 0x000008, "Wrong alignment on UCommonUIDelegates");
static_assert(sizeof(UCommonUIDelegates) == 0x000030, "Wrong size on UCommonUIDelegates");

// Class DBDUIViewInterfaces.LobbyViewInterface
// 0x0000 (0x0030 - 0x0030)
class ILobbyViewInterface final : public IInterface
{
public:
	void SetButtonBetaFeatureVisibility(bool IsVisible);
	void SetMenuState(const ELobbyMenuState State);
	void UpdateBackButtonState(const bool IsEnabled, const class FText& Label);

	TScriptInterface<class ILobbyCharactersViewInterface> GetLobbyCharactersInterface() const;
	TScriptInterface<class ILobbyPlayerListViewInterface> GetPlayerListInterface() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LobbyViewInterface">();
	}
	static class ILobbyViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ILobbyViewInterface>();
	}
};
static_assert(alignof(ILobbyViewInterface) == 0x000008, "Wrong alignment on ILobbyViewInterface");
static_assert(sizeof(ILobbyViewInterface) == 0x000030, "Wrong size on ILobbyViewInterface");

// Class DBDUIViewInterfaces.CompetenceContainerViewInterface
// 0x0000 (0x0030 - 0x0030)
class ICompetenceContainerViewInterface final : public IInterface
{
public:
	TScriptInterface<class IPerkViewInterface> GetPerkInterface(int32 Param_Index);
	TScriptInterface<class ISkillViewInterface> GetSkillInterface(int32 Param_Index);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CompetenceContainerViewInterface">();
	}
	static class ICompetenceContainerViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ICompetenceContainerViewInterface>();
	}
};
static_assert(alignof(ICompetenceContainerViewInterface) == 0x000008, "Wrong alignment on ICompetenceContainerViewInterface");
static_assert(sizeof(ICompetenceContainerViewInterface) == 0x000030, "Wrong size on ICompetenceContainerViewInterface");

// Class DBDUIViewInterfaces.CoreBaseViewInterface
// 0x0000 (0x0030 - 0x0030)
class ICoreBaseViewInterface final : public IInterface
{
public:
	TArray<TScriptInterface<class ILockedFeatureElementViewInterface>> GetLockedFeatureElements();
	void OnStartAsyncOperation();
	void OnStopAsyncOperation();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CoreBaseViewInterface">();
	}
	static class ICoreBaseViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ICoreBaseViewInterface>();
	}
};
static_assert(alignof(ICoreBaseViewInterface) == 0x000008, "Wrong alignment on ICoreBaseViewInterface");
static_assert(sizeof(ICoreBaseViewInterface) == 0x000030, "Wrong size on ICoreBaseViewInterface");

// Class DBDUIViewInterfaces.LightSensitivityViewInterface
// 0x0000 (0x0030 - 0x0030)
class ILightSensitivityViewInterface final : public IInterface
{
public:
	void StartFadeOut();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LightSensitivityViewInterface">();
	}
	static class ILightSensitivityViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ILightSensitivityViewInterface>();
	}
};
static_assert(alignof(ILightSensitivityViewInterface) == 0x000008, "Wrong alignment on ILightSensitivityViewInterface");
static_assert(sizeof(ILightSensitivityViewInterface) == 0x000030, "Wrong size on ILightSensitivityViewInterface");

// Class DBDUIViewInterfaces.CreditsViewInterface
// 0x0000 (0x0030 - 0x0030)
class ICreditsViewInterface final : public IInterface
{
public:
	void ScrollToEnd();
	void ScrollToName(const class FString& Param_Name, float Delay);
	void SetText(const class FText& Text);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CreditsViewInterface">();
	}
	static class ICreditsViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ICreditsViewInterface>();
	}
};
static_assert(alignof(ICreditsViewInterface) == 0x000008, "Wrong alignment on ICreditsViewInterface");
static_assert(sizeof(ICreditsViewInterface) == 0x000030, "Wrong size on ICreditsViewInterface");

// Class DBDUIViewInterfaces.CurrencyConversionPopupViewData
// 0x0030 (0x0220 - 0x01F0)
class UCurrencyConversionPopupViewData final : public UGenericPopupViewData
{
public:
	class FText                                   EventName;                                         // 0x01F0(0x0018)(BlueprintVisible, Transient, NativeAccessSpecifierPublic)
	ECurrencyType                                 FromCurrencyType;                                  // 0x0208(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_209[0x3];                                      // 0x0209(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         FromCurrencyAmount;                                // 0x020C(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECurrencyType                                 ToCurrencyType;                                    // 0x0210(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_211[0x3];                                      // 0x0211(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ToCurrencyAmount;                                  // 0x0214(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_218[0x8];                                      // 0x0218(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CurrencyConversionPopupViewData">();
	}
	static class UCurrencyConversionPopupViewData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCurrencyConversionPopupViewData>();
	}
};
static_assert(alignof(UCurrencyConversionPopupViewData) == 0x000010, "Wrong alignment on UCurrencyConversionPopupViewData");
static_assert(sizeof(UCurrencyConversionPopupViewData) == 0x000220, "Wrong size on UCurrencyConversionPopupViewData");
static_assert(offsetof(UCurrencyConversionPopupViewData, EventName) == 0x0001F0, "Member 'UCurrencyConversionPopupViewData::EventName' has a wrong offset!");
static_assert(offsetof(UCurrencyConversionPopupViewData, FromCurrencyType) == 0x000208, "Member 'UCurrencyConversionPopupViewData::FromCurrencyType' has a wrong offset!");
static_assert(offsetof(UCurrencyConversionPopupViewData, FromCurrencyAmount) == 0x00020C, "Member 'UCurrencyConversionPopupViewData::FromCurrencyAmount' has a wrong offset!");
static_assert(offsetof(UCurrencyConversionPopupViewData, ToCurrencyType) == 0x000210, "Member 'UCurrencyConversionPopupViewData::ToCurrencyType' has a wrong offset!");
static_assert(offsetof(UCurrencyConversionPopupViewData, ToCurrencyAmount) == 0x000214, "Member 'UCurrencyConversionPopupViewData::ToCurrencyAmount' has a wrong offset!");

// Class DBDUIViewInterfaces.RewardPopupViewInterface
// 0x0000 (0x0030 - 0x0030)
class IRewardPopupViewInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RewardPopupViewInterface">();
	}
	static class IRewardPopupViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IRewardPopupViewInterface>();
	}
};
static_assert(alignof(IRewardPopupViewInterface) == 0x000008, "Wrong alignment on IRewardPopupViewInterface");
static_assert(sizeof(IRewardPopupViewInterface) == 0x000030, "Wrong size on IRewardPopupViewInterface");

// Class DBDUIViewInterfaces.CurrencyConversionPopupViewInterface
// 0x0000 (0x0030 - 0x0030)
class ICurrencyConversionPopupViewInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CurrencyConversionPopupViewInterface">();
	}
	static class ICurrencyConversionPopupViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ICurrencyConversionPopupViewInterface>();
	}
};
static_assert(alignof(ICurrencyConversionPopupViewInterface) == 0x000008, "Wrong alignment on ICurrencyConversionPopupViewInterface");
static_assert(sizeof(ICurrencyConversionPopupViewInterface) == 0x000030, "Wrong size on ICurrencyConversionPopupViewInterface");

// Class DBDUIViewInterfaces.CustomizationRewardOutfitPartsViewData
// 0x0010 (0x0040 - 0x0030)
class UCustomizationRewardOutfitPartsViewData final : public UObject
{
public:
	TArray<struct FCustomizationRewardViewData>   OutfitParts;                                       // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomizationRewardOutfitPartsViewData">();
	}
	static class UCustomizationRewardOutfitPartsViewData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomizationRewardOutfitPartsViewData>();
	}
};
static_assert(alignof(UCustomizationRewardOutfitPartsViewData) == 0x000008, "Wrong alignment on UCustomizationRewardOutfitPartsViewData");
static_assert(sizeof(UCustomizationRewardOutfitPartsViewData) == 0x000040, "Wrong size on UCustomizationRewardOutfitPartsViewData");
static_assert(offsetof(UCustomizationRewardOutfitPartsViewData, OutfitParts) == 0x000030, "Member 'UCustomizationRewardOutfitPartsViewData::OutfitParts' has a wrong offset!");

// Class DBDUIViewInterfaces.SkillUnlockedNotificationViewInterface
// 0x0000 (0x0030 - 0x0030)
class ISkillUnlockedNotificationViewInterface final : public IInterface
{
public:
	void Hide();
	void Show(const struct FSkillUnlockedNotificationViewData& SkillUnlockedNotificationData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SkillUnlockedNotificationViewInterface">();
	}
	static class ISkillUnlockedNotificationViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ISkillUnlockedNotificationViewInterface>();
	}
};
static_assert(alignof(ISkillUnlockedNotificationViewInterface) == 0x000008, "Wrong alignment on ISkillUnlockedNotificationViewInterface");
static_assert(sizeof(ISkillUnlockedNotificationViewInterface) == 0x000030, "Wrong size on ISkillUnlockedNotificationViewInterface");

// Class DBDUIViewInterfaces.DailyRitualsPopupViewInterface
// 0x0000 (0x0030 - 0x0030)
class IDailyRitualsPopupViewInterface final : public IInterface
{
public:
	void SetAllDailyRitualTilesVisible();
	void SetCanRemoveDailyRitual(const bool CanRemoveDailyRitual);
	void SetDailyRitualsData(const TArray<struct FDailyRitualViewData>& DailyRitualsData, bool IsAfterTrial);
	void SetIsOnboardingRitualsExperimentActive(bool IsOnboardingRitualsExperimentActive);
	void StartAnim();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DailyRitualsPopupViewInterface">();
	}
	static class IDailyRitualsPopupViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IDailyRitualsPopupViewInterface>();
	}
};
static_assert(alignof(IDailyRitualsPopupViewInterface) == 0x000008, "Wrong alignment on IDailyRitualsPopupViewInterface");
static_assert(sizeof(IDailyRitualsPopupViewInterface) == 0x000030, "Wrong size on IDailyRitualsPopupViewInterface");

// Class DBDUIViewInterfaces.DisplayStandViewInterface
// 0x0000 (0x0030 - 0x0030)
class IDisplayStandViewInterface final : public IInterface
{
public:
	void SetViewData(const struct FDisplayStandViewData& ViewData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DisplayStandViewInterface">();
	}
	static class IDisplayStandViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IDisplayStandViewInterface>();
	}
};
static_assert(alignof(IDisplayStandViewInterface) == 0x000008, "Wrong alignment on IDisplayStandViewInterface");
static_assert(sizeof(IDisplayStandViewInterface) == 0x000030, "Wrong size on IDisplayStandViewInterface");

// Class DBDUIViewInterfaces.SeasonEndRankRewardsPopupViewData
// 0x0030 (0x0220 - 0x01F0)
class USeasonEndRankRewardsPopupViewData final : public UGenericPopupViewData
{
public:
	int32                                         OldKillerRank;                                     // 0x01F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OldSurvivorRank;                                   // 0x01F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FRewardWrapperViewData>         SurvivorRewards;                                   // 0x01F8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FRewardWrapperViewData>         KillerRewards;                                     // 0x0208(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_218[0x8];                                      // 0x0218(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SeasonEndRankRewardsPopupViewData">();
	}
	static class USeasonEndRankRewardsPopupViewData* GetDefaultObj()
	{
		return GetDefaultObjImpl<USeasonEndRankRewardsPopupViewData>();
	}
};
static_assert(alignof(USeasonEndRankRewardsPopupViewData) == 0x000010, "Wrong alignment on USeasonEndRankRewardsPopupViewData");
static_assert(sizeof(USeasonEndRankRewardsPopupViewData) == 0x000220, "Wrong size on USeasonEndRankRewardsPopupViewData");
static_assert(offsetof(USeasonEndRankRewardsPopupViewData, OldKillerRank) == 0x0001F0, "Member 'USeasonEndRankRewardsPopupViewData::OldKillerRank' has a wrong offset!");
static_assert(offsetof(USeasonEndRankRewardsPopupViewData, OldSurvivorRank) == 0x0001F4, "Member 'USeasonEndRankRewardsPopupViewData::OldSurvivorRank' has a wrong offset!");
static_assert(offsetof(USeasonEndRankRewardsPopupViewData, SurvivorRewards) == 0x0001F8, "Member 'USeasonEndRankRewardsPopupViewData::SurvivorRewards' has a wrong offset!");
static_assert(offsetof(USeasonEndRankRewardsPopupViewData, KillerRewards) == 0x000208, "Member 'USeasonEndRankRewardsPopupViewData::KillerRewards' has a wrong offset!");

// Class DBDUIViewInterfaces.EffectCardViewInterface
// 0x0000 (0x0030 - 0x0030)
class IEffectCardViewInterface final : public IInterface
{
public:
	void SetData(const struct FEffectCardViewData& EffectCardData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EffectCardViewInterface">();
	}
	static class IEffectCardViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IEffectCardViewInterface>();
	}
};
static_assert(alignof(IEffectCardViewInterface) == 0x000008, "Wrong alignment on IEffectCardViewInterface");
static_assert(sizeof(IEffectCardViewInterface) == 0x000030, "Wrong size on IEffectCardViewInterface");

// Class DBDUIViewInterfaces.EndGameCollapseBarViewInterface
// 0x0000 (0x0030 - 0x0030)
class IEndGameCollapseBarViewInterface final : public IInterface
{
public:
	void InitEndGameScenario();
	void SetEndGameScenarioProgressionMode(const bool IsSlowMode);
	void SetEndGameScenarioProgressionValue(const float Amount, bool ForceUpdate);
	void StartEndGameScenario();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndGameCollapseBarViewInterface">();
	}
	static class IEndGameCollapseBarViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IEndGameCollapseBarViewInterface>();
	}
};
static_assert(alignof(IEndGameCollapseBarViewInterface) == 0x000008, "Wrong alignment on IEndGameCollapseBarViewInterface");
static_assert(sizeof(IEndGameCollapseBarViewInterface) == 0x000030, "Wrong size on IEndGameCollapseBarViewInterface");

// Class DBDUIViewInterfaces.GrantedRewardPopupViewData
// 0x0028 (0x0058 - 0x0030)
class UGrantedRewardPopupViewData : public UObject
{
public:
	ERewardPopupType                              Type;                                              // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   TitleText;                                         // 0x0038(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Transient, EditConst, ExposeOnSpawn, NativeAccessSpecifierPublic)
	EItemRarity                                   Rarity;                                            // 0x0050(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsVisceral;                                        // 0x0051(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_52[0x6];                                       // 0x0052(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GrantedRewardPopupViewData">();
	}
	static class UGrantedRewardPopupViewData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGrantedRewardPopupViewData>();
	}
};
static_assert(alignof(UGrantedRewardPopupViewData) == 0x000008, "Wrong alignment on UGrantedRewardPopupViewData");
static_assert(sizeof(UGrantedRewardPopupViewData) == 0x000058, "Wrong size on UGrantedRewardPopupViewData");
static_assert(offsetof(UGrantedRewardPopupViewData, Type) == 0x000030, "Member 'UGrantedRewardPopupViewData::Type' has a wrong offset!");
static_assert(offsetof(UGrantedRewardPopupViewData, TitleText) == 0x000038, "Member 'UGrantedRewardPopupViewData::TitleText' has a wrong offset!");
static_assert(offsetof(UGrantedRewardPopupViewData, Rarity) == 0x000050, "Member 'UGrantedRewardPopupViewData::Rarity' has a wrong offset!");
static_assert(offsetof(UGrantedRewardPopupViewData, IsVisceral) == 0x000051, "Member 'UGrantedRewardPopupViewData::IsVisceral' has a wrong offset!");

// Class DBDUIViewInterfaces.PackRewardPopupViewData
// 0x00E8 (0x0140 - 0x0058)
class UPackRewardPopupViewData final : public UGrantedRewardPopupViewData
{
public:
	class FName                                   ID;                                                // 0x0058(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   PackName;                                          // 0x0068(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Transient, EditConst, ExposeOnSpawn, NativeAccessSpecifierPublic)
	struct FSoftRemoteContentCacheObjectPtr       RemoteImagePtr;                                    // 0x0080(0x0070)(BlueprintVisible, BlueprintReadOnly, Transient, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              TexturePtr;                                        // 0x00F0(0x0038)(BlueprintVisible, BlueprintReadOnly, Transient, ExposeOnSpawn, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseCompositionForPackImage;                        // 0x0128(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_129[0x3];                                      // 0x0129(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PackImageCompositionNumberOfItems;                 // 0x012C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UStorePackContentData*>          SortedContent;                                     // 0x0130(0x0010)(BlueprintVisible, ZeroConstructor, Transient, ExposeOnSpawn, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PackRewardPopupViewData">();
	}
	static class UPackRewardPopupViewData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPackRewardPopupViewData>();
	}
};
static_assert(alignof(UPackRewardPopupViewData) == 0x000008, "Wrong alignment on UPackRewardPopupViewData");
static_assert(sizeof(UPackRewardPopupViewData) == 0x000140, "Wrong size on UPackRewardPopupViewData");
static_assert(offsetof(UPackRewardPopupViewData, ID) == 0x000058, "Member 'UPackRewardPopupViewData::ID' has a wrong offset!");
static_assert(offsetof(UPackRewardPopupViewData, PackName) == 0x000068, "Member 'UPackRewardPopupViewData::PackName' has a wrong offset!");
static_assert(offsetof(UPackRewardPopupViewData, RemoteImagePtr) == 0x000080, "Member 'UPackRewardPopupViewData::RemoteImagePtr' has a wrong offset!");
static_assert(offsetof(UPackRewardPopupViewData, TexturePtr) == 0x0000F0, "Member 'UPackRewardPopupViewData::TexturePtr' has a wrong offset!");
static_assert(offsetof(UPackRewardPopupViewData, UseCompositionForPackImage) == 0x000128, "Member 'UPackRewardPopupViewData::UseCompositionForPackImage' has a wrong offset!");
static_assert(offsetof(UPackRewardPopupViewData, PackImageCompositionNumberOfItems) == 0x00012C, "Member 'UPackRewardPopupViewData::PackImageCompositionNumberOfItems' has a wrong offset!");
static_assert(offsetof(UPackRewardPopupViewData, SortedContent) == 0x000130, "Member 'UPackRewardPopupViewData::SortedContent' has a wrong offset!");

// Class DBDUIViewInterfaces.EquippedItemViewInterface
// 0x0000 (0x0030 - 0x0030)
class IEquippedItemViewInterface final : public IInterface
{
public:
	void ClearData(bool FullClear);
	bool GetIsEquippedItemVisible();
	void SetActiveState(bool IsActive);
	void SetData(const struct FItemBundleViewData& ItemBundleData);
	void SetFakeItem(bool IsHoldingFakeItem, const TSoftObjectPtr<class UTexture2D>& FakeItemIcon, const struct FKey& InputKey, int32 Count);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EquippedItemViewInterface">();
	}
	static class IEquippedItemViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IEquippedItemViewInterface>();
	}
};
static_assert(alignof(IEquippedItemViewInterface) == 0x000008, "Wrong alignment on IEquippedItemViewInterface");
static_assert(sizeof(IEquippedItemViewInterface) == 0x000030, "Wrong size on IEquippedItemViewInterface");

// Class DBDUIViewInterfaces.EquippedPowerViewInterface
// 0x0000 (0x0030 - 0x0030)
class IEquippedPowerViewInterface final : public IInterface
{
public:
	void ClearData();
	void SetActiveState(bool IsActive);
	void SetCarryingMode(const bool IsCarrying, const struct FPowerViewData& CarryingViewData);
	void SetData(const struct FPowerBundleViewData& PowerBundleData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EquippedPowerViewInterface">();
	}
	static class IEquippedPowerViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IEquippedPowerViewInterface>();
	}
};
static_assert(alignof(IEquippedPowerViewInterface) == 0x000008, "Wrong alignment on IEquippedPowerViewInterface");
static_assert(sizeof(IEquippedPowerViewInterface) == 0x000030, "Wrong size on IEquippedPowerViewInterface");

// Class DBDUIViewInterfaces.ShrineOfSecretsViewInterface
// 0x0000 (0x0030 - 0x0030)
class IShrineOfSecretsViewInterface final : public IInterface
{
public:
	void SetData(const struct FShrineOfSecretsViewData& ShrineOfSecretsViewData);
	void UpdateItemsFromPurchase(const struct FShrineOfSecretsViewData& ShrineOfSecretsViewData, const struct FShrineOfSecretsItemViewData& PurchasedItem);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShrineOfSecretsViewInterface">();
	}
	static class IShrineOfSecretsViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IShrineOfSecretsViewInterface>();
	}
};
static_assert(alignof(IShrineOfSecretsViewInterface) == 0x000008, "Wrong alignment on IShrineOfSecretsViewInterface");
static_assert(sizeof(IShrineOfSecretsViewInterface) == 0x000030, "Wrong size on IShrineOfSecretsViewInterface");

// Class DBDUIViewInterfaces.EventCollectionViewInterface
// 0x0000 (0x0030 - 0x0030)
class IEventCollectionViewInterface final : public IInterface
{
public:
	void Deinit();
	void DeselectReward();
	void DisableInstructionArchivesButton();
	void DisableInstructionCurrencyButton();
	void DisableInstructionInputs();
	void DisableInstructionStoreButton();
	void Init(const struct FEventEntryPopupSkinUIData& SkinData);
	void SetInstructionWidgetData(const struct FCustomizationItemOriginViewData& ViewData);
	void SetItemsData(const TArray<class UStoreCustomizationItemViewData*>& CustomizationRewardsData, const int32 SelectedIndex);
	void SetPreviewAreaData(const struct FCustomizationItemPreviewAreaViewData& ViewData);
	void SetSelectedReward(const int32 SelectedIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventCollectionViewInterface">();
	}
	static class IEventCollectionViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IEventCollectionViewInterface>();
	}
};
static_assert(alignof(IEventCollectionViewInterface) == 0x000008, "Wrong alignment on IEventCollectionViewInterface");
static_assert(sizeof(IEventCollectionViewInterface) == 0x000030, "Wrong size on IEventCollectionViewInterface");

// Class DBDUIViewInterfaces.EventDetailsViewInterface
// 0x0000 (0x0030 - 0x0030)
class IEventDetailsViewInterface final : public IInterface
{
public:
	void Deinit();
	void Init(const struct FDetailsTabViewData& ViewData, const struct FEventEntryPopupSkinUIData& SkinData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventDetailsViewInterface">();
	}
	static class IEventDetailsViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IEventDetailsViewInterface>();
	}
};
static_assert(alignof(IEventDetailsViewInterface) == 0x000008, "Wrong alignment on IEventDetailsViewInterface");
static_assert(sizeof(IEventDetailsViewInterface) == 0x000030, "Wrong size on IEventDetailsViewInterface");

// Class DBDUIViewInterfaces.StoreItemViewData
// 0x0178 (0x01A8 - 0x0030)
class UStoreItemViewData : public UObject
{
public:
	class FText                                   DisplayName;                                       // 0x0030(0x0018)(Edit, BlueprintVisible, Transient, ExposeOnSpawn, NativeAccessSpecifierPublic)
	TArray<struct FPriceTagViewData>              PriceTagData;                                      // 0x0048(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Transient, ExposeOnSpawn, NativeAccessSpecifierPublic)
	bool                                          IsInStore;                                         // 0x0058(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsNewInStore;                                      // 0x0059(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsTutorialItem;                                    // 0x005A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5B[0x5];                                       // 0x005B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerFlagViewData                     LimitedTimeFlag;                                   // 0x0060(0x0030)(Edit, BlueprintVisible, Transient, ExposeOnSpawn, NativeAccessSpecifierPublic)
	struct FTimerFlagViewData                     DiscountTimeFlag;                                  // 0x0090(0x0030)(Edit, BlueprintVisible, Transient, ExposeOnSpawn, NativeAccessSpecifierPublic)
	struct FSpecialEventInfoViewData              EventInfo;                                         // 0x00C0(0x0060)(Edit, BlueprintVisible, Transient, ExposeOnSpawn, NativeAccessSpecifierPublic)
	class FString                                 ChapterPackId;                                     // 0x0120(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Transient, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 HeritagePackId;                                    // 0x0130(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Transient, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           SpecialPackIds;                                    // 0x0140(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Transient, ExposeOnSpawn, NativeAccessSpecifierPublic)
	class FString                                 RiftArchiveId;                                     // 0x0150(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Transient, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TomeArchiveId;                                     // 0x0160(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Transient, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStoreItemUnlockInfoViewData           UnlockInfo;                                        // 0x0170(0x0030)(Edit, BlueprintVisible, Transient, ExposeOnSpawn, NativeAccessSpecifierPublic)
	EDisabledItemOption                           DisabledItemOption;                                // 0x01A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A1[0x7];                                      // 0x01A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool GetHasNotification() const;
	TSoftObjectPtr<class UTexture2D> GetIcon() const;
	bool GetIsAvailable() const;
	bool GetIsBuyable() const;
	bool GetIsEnabled() const;
	bool GetIsOwned() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StoreItemViewData">();
	}
	static class UStoreItemViewData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStoreItemViewData>();
	}
};
static_assert(alignof(UStoreItemViewData) == 0x000008, "Wrong alignment on UStoreItemViewData");
static_assert(sizeof(UStoreItemViewData) == 0x0001A8, "Wrong size on UStoreItemViewData");
static_assert(offsetof(UStoreItemViewData, DisplayName) == 0x000030, "Member 'UStoreItemViewData::DisplayName' has a wrong offset!");
static_assert(offsetof(UStoreItemViewData, PriceTagData) == 0x000048, "Member 'UStoreItemViewData::PriceTagData' has a wrong offset!");
static_assert(offsetof(UStoreItemViewData, IsInStore) == 0x000058, "Member 'UStoreItemViewData::IsInStore' has a wrong offset!");
static_assert(offsetof(UStoreItemViewData, IsNewInStore) == 0x000059, "Member 'UStoreItemViewData::IsNewInStore' has a wrong offset!");
static_assert(offsetof(UStoreItemViewData, IsTutorialItem) == 0x00005A, "Member 'UStoreItemViewData::IsTutorialItem' has a wrong offset!");
static_assert(offsetof(UStoreItemViewData, LimitedTimeFlag) == 0x000060, "Member 'UStoreItemViewData::LimitedTimeFlag' has a wrong offset!");
static_assert(offsetof(UStoreItemViewData, DiscountTimeFlag) == 0x000090, "Member 'UStoreItemViewData::DiscountTimeFlag' has a wrong offset!");
static_assert(offsetof(UStoreItemViewData, EventInfo) == 0x0000C0, "Member 'UStoreItemViewData::EventInfo' has a wrong offset!");
static_assert(offsetof(UStoreItemViewData, ChapterPackId) == 0x000120, "Member 'UStoreItemViewData::ChapterPackId' has a wrong offset!");
static_assert(offsetof(UStoreItemViewData, HeritagePackId) == 0x000130, "Member 'UStoreItemViewData::HeritagePackId' has a wrong offset!");
static_assert(offsetof(UStoreItemViewData, SpecialPackIds) == 0x000140, "Member 'UStoreItemViewData::SpecialPackIds' has a wrong offset!");
static_assert(offsetof(UStoreItemViewData, RiftArchiveId) == 0x000150, "Member 'UStoreItemViewData::RiftArchiveId' has a wrong offset!");
static_assert(offsetof(UStoreItemViewData, TomeArchiveId) == 0x000160, "Member 'UStoreItemViewData::TomeArchiveId' has a wrong offset!");
static_assert(offsetof(UStoreItemViewData, UnlockInfo) == 0x000170, "Member 'UStoreItemViewData::UnlockInfo' has a wrong offset!");
static_assert(offsetof(UStoreItemViewData, DisabledItemOption) == 0x0001A0, "Member 'UStoreItemViewData::DisabledItemOption' has a wrong offset!");

// Class DBDUIViewInterfaces.StoreCharacterItemViewData
// 0x0178 (0x0320 - 0x01A8)
class UStoreCharacterItemViewData final : public UStoreItemViewData
{
public:
	struct FCharacterRewardViewData               CharacterReward;                                   // 0x01A8(0x0110)(Edit, BlueprintVisible, Transient, ExposeOnSpawn, NativeAccessSpecifierPublic)
	int32                                         CharacterIndex;                                    // 0x02B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CharacterId;                                       // 0x02BC(0x000C)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   BackStory;                                         // 0x02C8(0x0018)(Edit, BlueprintVisible, Transient, ExposeOnSpawn, NativeAccessSpecifierPublic)
	class FName                                   BackgroundImagePath;                               // 0x02E0(0x000C)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FKillerAttributes                      KillerAttributes;                                  // 0x02EC(0x000C)(Edit, BlueprintVisible, Transient, NoDestructor, ExposeOnSpawn, NativeAccessSpecifierPublic)
	ECharacterDifficulty                          Difficulty;                                        // 0x02F8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F9[0x3];                                      // 0x02F9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   EquippedPowerItemId;                               // 0x02FC(0x000C)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsEquipped;                                        // 0x0308(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasNonSelectedPerks;                               // 0x0309(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsDlcLockedKiller;                                 // 0x030A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30B[0x1];                                      // 0x030B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPrestigeViewData                      Prestige;                                          // 0x030C(0x0008)(Edit, BlueprintVisible, Transient, NoDestructor, ExposeOnSpawn, NativeAccessSpecifierPublic)
	int32                                         NewItemsCount;                                     // 0x0314(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DlcUiOrder;                                        // 0x0318(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsBaseCharacter;                                   // 0x031C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31D[0x3];                                      // 0x031D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StoreCharacterItemViewData">();
	}
	static class UStoreCharacterItemViewData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStoreCharacterItemViewData>();
	}
};
static_assert(alignof(UStoreCharacterItemViewData) == 0x000008, "Wrong alignment on UStoreCharacterItemViewData");
static_assert(sizeof(UStoreCharacterItemViewData) == 0x000320, "Wrong size on UStoreCharacterItemViewData");
static_assert(offsetof(UStoreCharacterItemViewData, CharacterReward) == 0x0001A8, "Member 'UStoreCharacterItemViewData::CharacterReward' has a wrong offset!");
static_assert(offsetof(UStoreCharacterItemViewData, CharacterIndex) == 0x0002B8, "Member 'UStoreCharacterItemViewData::CharacterIndex' has a wrong offset!");
static_assert(offsetof(UStoreCharacterItemViewData, CharacterId) == 0x0002BC, "Member 'UStoreCharacterItemViewData::CharacterId' has a wrong offset!");
static_assert(offsetof(UStoreCharacterItemViewData, BackStory) == 0x0002C8, "Member 'UStoreCharacterItemViewData::BackStory' has a wrong offset!");
static_assert(offsetof(UStoreCharacterItemViewData, BackgroundImagePath) == 0x0002E0, "Member 'UStoreCharacterItemViewData::BackgroundImagePath' has a wrong offset!");
static_assert(offsetof(UStoreCharacterItemViewData, KillerAttributes) == 0x0002EC, "Member 'UStoreCharacterItemViewData::KillerAttributes' has a wrong offset!");
static_assert(offsetof(UStoreCharacterItemViewData, Difficulty) == 0x0002F8, "Member 'UStoreCharacterItemViewData::Difficulty' has a wrong offset!");
static_assert(offsetof(UStoreCharacterItemViewData, EquippedPowerItemId) == 0x0002FC, "Member 'UStoreCharacterItemViewData::EquippedPowerItemId' has a wrong offset!");
static_assert(offsetof(UStoreCharacterItemViewData, IsEquipped) == 0x000308, "Member 'UStoreCharacterItemViewData::IsEquipped' has a wrong offset!");
static_assert(offsetof(UStoreCharacterItemViewData, HasNonSelectedPerks) == 0x000309, "Member 'UStoreCharacterItemViewData::HasNonSelectedPerks' has a wrong offset!");
static_assert(offsetof(UStoreCharacterItemViewData, IsDlcLockedKiller) == 0x00030A, "Member 'UStoreCharacterItemViewData::IsDlcLockedKiller' has a wrong offset!");
static_assert(offsetof(UStoreCharacterItemViewData, Prestige) == 0x00030C, "Member 'UStoreCharacterItemViewData::Prestige' has a wrong offset!");
static_assert(offsetof(UStoreCharacterItemViewData, NewItemsCount) == 0x000314, "Member 'UStoreCharacterItemViewData::NewItemsCount' has a wrong offset!");
static_assert(offsetof(UStoreCharacterItemViewData, DlcUiOrder) == 0x000318, "Member 'UStoreCharacterItemViewData::DlcUiOrder' has a wrong offset!");
static_assert(offsetof(UStoreCharacterItemViewData, IsBaseCharacter) == 0x00031C, "Member 'UStoreCharacterItemViewData::IsBaseCharacter' has a wrong offset!");

// Class DBDUIViewInterfaces.EventEntryViewData
// 0x00D8 (0x0108 - 0x0030)
class UEventEntryViewData final : public UObject
{
public:
	class FText                                   Title;                                             // 0x0030(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FString                                 Message;                                           // 0x0048(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              StartDate;                                         // 0x0058(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              EndDate;                                           // 0x0060(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   AvailabilityDates;                                 // 0x0068(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   EventFrameLabel;                                   // 0x0080(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   ImageBannerText;                                   // 0x0098(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   EventTabMessage;                                   // 0x00B0(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              ImageTexture;                                      // 0x00C8(0x0038)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShouldShowEventTomeButton;                         // 0x0100(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShouldActivateUiTakeover;                          // 0x0101(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_102[0x6];                                      // 0x0102(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventEntryViewData">();
	}
	static class UEventEntryViewData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventEntryViewData>();
	}
};
static_assert(alignof(UEventEntryViewData) == 0x000008, "Wrong alignment on UEventEntryViewData");
static_assert(sizeof(UEventEntryViewData) == 0x000108, "Wrong size on UEventEntryViewData");
static_assert(offsetof(UEventEntryViewData, Title) == 0x000030, "Member 'UEventEntryViewData::Title' has a wrong offset!");
static_assert(offsetof(UEventEntryViewData, Message) == 0x000048, "Member 'UEventEntryViewData::Message' has a wrong offset!");
static_assert(offsetof(UEventEntryViewData, StartDate) == 0x000058, "Member 'UEventEntryViewData::StartDate' has a wrong offset!");
static_assert(offsetof(UEventEntryViewData, EndDate) == 0x000060, "Member 'UEventEntryViewData::EndDate' has a wrong offset!");
static_assert(offsetof(UEventEntryViewData, AvailabilityDates) == 0x000068, "Member 'UEventEntryViewData::AvailabilityDates' has a wrong offset!");
static_assert(offsetof(UEventEntryViewData, EventFrameLabel) == 0x000080, "Member 'UEventEntryViewData::EventFrameLabel' has a wrong offset!");
static_assert(offsetof(UEventEntryViewData, ImageBannerText) == 0x000098, "Member 'UEventEntryViewData::ImageBannerText' has a wrong offset!");
static_assert(offsetof(UEventEntryViewData, EventTabMessage) == 0x0000B0, "Member 'UEventEntryViewData::EventTabMessage' has a wrong offset!");
static_assert(offsetof(UEventEntryViewData, ImageTexture) == 0x0000C8, "Member 'UEventEntryViewData::ImageTexture' has a wrong offset!");
static_assert(offsetof(UEventEntryViewData, ShouldShowEventTomeButton) == 0x000100, "Member 'UEventEntryViewData::ShouldShowEventTomeButton' has a wrong offset!");
static_assert(offsetof(UEventEntryViewData, ShouldActivateUiTakeover) == 0x000101, "Member 'UEventEntryViewData::ShouldActivateUiTakeover' has a wrong offset!");

// Class DBDUIViewInterfaces.EventEntryViewInterface
// 0x0000 (0x0030 - 0x0030)
class IEventEntryViewInterface final : public IInterface
{
public:
	void ChangeSelectedTab(const int32 Key);
	void DeselectMilestoneTrackerItems();
	bool GetRowDataFromEventSkinDataTable(struct FEventEntryPopupSkinUIData* SkinData, const class FText& EventFrameLabel);
	void InitializeOverlay(class UEventEntryViewData* ViewData);
	void RequestOverlayClosure();
	void SelectMilestoneTrackerItem(class FName ItemId);
	void SetMilestoneTrackerData(const struct FMilestoneTrackerViewData& ViewData);
	void SetMilestoneTrackerVisibility(bool IsVisible);
	void SetOverlayState(const EEventEntryTabState& TabState);
	void SetTabsData(const TArray<struct FTabWidgetData>& TabsData, const int32 SelectedKey);

	TScriptInterface<class IEventCollectionViewInterface> GetCollectionSubPresenterInterface() const;
	TScriptInterface<class IEventDetailsViewInterface> GetDetailsSubPresenterInterface() const;
	class UDataTable* GetEventSkinDataTable() const;
	TScriptInterface<class IEventInfoViewInterface> GetEventSubPresenterInterface() const;
	TScriptInterface<class IEventCollectionViewInterface> GetStoreSubPresenterInterface() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventEntryViewInterface">();
	}
	static class IEventEntryViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IEventEntryViewInterface>();
	}
};
static_assert(alignof(IEventEntryViewInterface) == 0x000008, "Wrong alignment on IEventEntryViewInterface");
static_assert(sizeof(IEventEntryViewInterface) == 0x000030, "Wrong size on IEventEntryViewInterface");

// Class DBDUIViewInterfaces.SpectateBarViewInterface
// 0x0000 (0x0030 - 0x0030)
class ISpectateBarViewInterface final : public IInterface
{
public:
	void SetArrowsVisibility(const bool IsVisible);
	void SetBotTag(const bool IsBot);
	void SetSpectateBarVisibility(const bool IsVisible);
	void SetSpectatedName(const class FString& PlayerName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpectateBarViewInterface">();
	}
	static class ISpectateBarViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ISpectateBarViewInterface>();
	}
};
static_assert(alignof(ISpectateBarViewInterface) == 0x000008, "Wrong alignment on ISpectateBarViewInterface");
static_assert(sizeof(ISpectateBarViewInterface) == 0x000030, "Wrong size on ISpectateBarViewInterface");

// Class DBDUIViewInterfaces.EventTabViewData
// 0x0058 (0x0088 - 0x0030)
class UEventTabViewData final : public UObject
{
public:
	TSoftObjectPtr<class UTexture2D>              ImageTexture;                                      // 0x0030(0x0038)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShouldShowEventTomeButton;                         // 0x0068(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Message;                                           // 0x0070(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventTabViewData">();
	}
	static class UEventTabViewData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventTabViewData>();
	}
};
static_assert(alignof(UEventTabViewData) == 0x000008, "Wrong alignment on UEventTabViewData");
static_assert(sizeof(UEventTabViewData) == 0x000088, "Wrong size on UEventTabViewData");
static_assert(offsetof(UEventTabViewData, ImageTexture) == 0x000030, "Member 'UEventTabViewData::ImageTexture' has a wrong offset!");
static_assert(offsetof(UEventTabViewData, ShouldShowEventTomeButton) == 0x000068, "Member 'UEventTabViewData::ShouldShowEventTomeButton' has a wrong offset!");
static_assert(offsetof(UEventTabViewData, Message) == 0x000070, "Member 'UEventTabViewData::Message' has a wrong offset!");

// Class DBDUIViewInterfaces.EventInfoViewInterface
// 0x0000 (0x0030 - 0x0030)
class IEventInfoViewInterface final : public IInterface
{
public:
	void Deinit();
	void DisableArchivesButton();
	void Init(class UEventTabViewData* ViewData, const struct FEventEntryPopupSkinUIData& SkinData);
	void SetArchivesButtonVisibility(bool IsVisible);
	void SetEventObjectiveTrackerData(const struct FEventObjectiveTrackerViewData& ViewData);
	void SetEventObjectiveTrackerVisibility(const bool IsVisible);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventInfoViewInterface">();
	}
	static class IEventInfoViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IEventInfoViewInterface>();
	}
};
static_assert(alignof(IEventInfoViewInterface) == 0x000008, "Wrong alignment on IEventInfoViewInterface");
static_assert(sizeof(IEventInfoViewInterface) == 0x000030, "Wrong size on IEventInfoViewInterface");

// Class DBDUIViewInterfaces.SettingsMatchDetailsViewInterface
// 0x0000 (0x0030 - 0x0030)
class ISettingsMatchDetailsViewInterface final : public IInterface
{
public:
	void SetLayout(const EGameType GameType);
	void SetMapData(const class FText& MapInfo, const class FString& MapThemeName, const class FString& MapTileName);
	void SetOfferings(const TArray<class UMenuOfferingViewData*>& SurvivorOfferingsData, const TArray<class UMenuOfferingViewData*>& KillerOfferingsData);
	void SetPerks(const TArray<class UMenuPerkViewData*>& PerksData);
	void SetPlayersInfo(const TArray<struct FPlayerInfoData>& SurvivorInfoData, const TArray<struct FPlayerInfoData>& KillerInfoData, bool IsLocalPlayerSurvivor);
	void SetPlayersInfoButtonsEnabled(const bool IsEnabled);
	void SetPlayersPings(const TMap<class FString, float>& PingData);
	void SetSkills(const TArray<class UMenuSkillViewData*>& SkillsData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SettingsMatchDetailsViewInterface">();
	}
	static class ISettingsMatchDetailsViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ISettingsMatchDetailsViewInterface>();
	}
};
static_assert(alignof(ISettingsMatchDetailsViewInterface) == 0x000008, "Wrong alignment on ISettingsMatchDetailsViewInterface");
static_assert(sizeof(ISettingsMatchDetailsViewInterface) == 0x000030, "Wrong size on ISettingsMatchDetailsViewInterface");

// Class DBDUIViewInterfaces.ExampleViewInterface
// 0x0000 (0x0030 - 0x0030)
class IExampleViewInterface final : public IInterface
{
public:
	void SetExampleProgressRatio(float Ratio);
	void SetExampleText(const class FString& Text);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExampleViewInterface">();
	}
	static class IExampleViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IExampleViewInterface>();
	}
};
static_assert(alignof(IExampleViewInterface) == 0x000008, "Wrong alignment on IExampleViewInterface");
static_assert(sizeof(IExampleViewInterface) == 0x000030, "Wrong size on IExampleViewInterface");

// Class DBDUIViewInterfaces.ExternalEffectsViewInterface
// 0x0000 (0x0030 - 0x0030)
class IExternalEffectsViewInterface final : public IInterface
{
public:
	void HideAllExternalAddons();
	void HideAllExternalPerks();
	void HideExternalAddon(const class FName ItemId);
	void HideExternalPerk(const class FName ItemId);
	void HideExternalSkill(const class FName ItemId);
	void ShowExternalAddon(const struct FAddonViewData& AddonViewData);
	void ShowExternalPerk(const struct FPerkViewData& PerkViewData);
	void ShowExternalSkill(const struct FSkillViewData& SkillViewData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExternalEffectsViewInterface">();
	}
	static class IExternalEffectsViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IExternalEffectsViewInterface>();
	}
};
static_assert(alignof(IExternalEffectsViewInterface) == 0x000008, "Wrong alignment on IExternalEffectsViewInterface");
static_assert(sizeof(IExternalEffectsViewInterface) == 0x000030, "Wrong size on IExternalEffectsViewInterface");

// Class DBDUIViewInterfaces.StoreChapterPackViewData
// 0x01B8 (0x01E8 - 0x0030)
class UStoreChapterPackViewData final : public UObject
{
public:
	class FString                                 ID;                                                // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 OriginalDlcId;                                     // 0x0040(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   DisplayTitle;                                      // 0x0050(0x0018)(BlueprintVisible, BlueprintReadOnly, Transient, ExposeOnSpawn, NativeAccessSpecifierPublic)
	class FString                                 HeritagePackId;                                    // 0x0068(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              PackImage;                                         // 0x0078(0x0038)(BlueprintVisible, BlueprintReadOnly, Transient, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UStoreCharacterItemViewData*>    CharactersData;                                    // 0x00B0(0x0010)(BlueprintVisible, ZeroConstructor, Transient, ExposeOnSpawn, NativeAccessSpecifierPublic)
	TArray<class UStoreCustomizationItemViewData*> CustomizationsData;                                // 0x00C0(0x0010)(BlueprintVisible, ZeroConstructor, Transient, ExposeOnSpawn, NativeAccessSpecifierPublic)
	TArray<class UStorePackContentData*>          SortedContent;                                     // 0x00D0(0x0010)(BlueprintVisible, ZeroConstructor, Transient, ExposeOnSpawn, NativeAccessSpecifierPublic)
	int32                                         SortOrder;                                         // 0x00E0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsNew;                                             // 0x00E4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsOwned;                                           // 0x00E5(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsIndividuallyAvailable;                           // 0x00E6(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E7[0x1];                                       // 0x00E7(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              ActivationStartDate;                               // 0x00E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              ActivationEndDate;                                 // 0x00F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimerFlagViewData                     TimerViewData;                                     // 0x00F8(0x0030)(BlueprintVisible, Transient, ExposeOnSpawn, NativeAccessSpecifierPublic)
	struct FSoftRemoteContentCacheObjectPtr       PackImagePtr;                                      // 0x0128(0x0070)(BlueprintVisible, BlueprintReadOnly, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPriceTagViewData                      PriceTagData;                                      // 0x0198(0x0050)(BlueprintVisible, Transient, ExposeOnSpawn, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StoreChapterPackViewData">();
	}
	static class UStoreChapterPackViewData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStoreChapterPackViewData>();
	}
};
static_assert(alignof(UStoreChapterPackViewData) == 0x000008, "Wrong alignment on UStoreChapterPackViewData");
static_assert(sizeof(UStoreChapterPackViewData) == 0x0001E8, "Wrong size on UStoreChapterPackViewData");
static_assert(offsetof(UStoreChapterPackViewData, ID) == 0x000030, "Member 'UStoreChapterPackViewData::ID' has a wrong offset!");
static_assert(offsetof(UStoreChapterPackViewData, OriginalDlcId) == 0x000040, "Member 'UStoreChapterPackViewData::OriginalDlcId' has a wrong offset!");
static_assert(offsetof(UStoreChapterPackViewData, DisplayTitle) == 0x000050, "Member 'UStoreChapterPackViewData::DisplayTitle' has a wrong offset!");
static_assert(offsetof(UStoreChapterPackViewData, HeritagePackId) == 0x000068, "Member 'UStoreChapterPackViewData::HeritagePackId' has a wrong offset!");
static_assert(offsetof(UStoreChapterPackViewData, PackImage) == 0x000078, "Member 'UStoreChapterPackViewData::PackImage' has a wrong offset!");
static_assert(offsetof(UStoreChapterPackViewData, CharactersData) == 0x0000B0, "Member 'UStoreChapterPackViewData::CharactersData' has a wrong offset!");
static_assert(offsetof(UStoreChapterPackViewData, CustomizationsData) == 0x0000C0, "Member 'UStoreChapterPackViewData::CustomizationsData' has a wrong offset!");
static_assert(offsetof(UStoreChapterPackViewData, SortedContent) == 0x0000D0, "Member 'UStoreChapterPackViewData::SortedContent' has a wrong offset!");
static_assert(offsetof(UStoreChapterPackViewData, SortOrder) == 0x0000E0, "Member 'UStoreChapterPackViewData::SortOrder' has a wrong offset!");
static_assert(offsetof(UStoreChapterPackViewData, IsNew) == 0x0000E4, "Member 'UStoreChapterPackViewData::IsNew' has a wrong offset!");
static_assert(offsetof(UStoreChapterPackViewData, IsOwned) == 0x0000E5, "Member 'UStoreChapterPackViewData::IsOwned' has a wrong offset!");
static_assert(offsetof(UStoreChapterPackViewData, IsIndividuallyAvailable) == 0x0000E6, "Member 'UStoreChapterPackViewData::IsIndividuallyAvailable' has a wrong offset!");
static_assert(offsetof(UStoreChapterPackViewData, ActivationStartDate) == 0x0000E8, "Member 'UStoreChapterPackViewData::ActivationStartDate' has a wrong offset!");
static_assert(offsetof(UStoreChapterPackViewData, ActivationEndDate) == 0x0000F0, "Member 'UStoreChapterPackViewData::ActivationEndDate' has a wrong offset!");
static_assert(offsetof(UStoreChapterPackViewData, TimerViewData) == 0x0000F8, "Member 'UStoreChapterPackViewData::TimerViewData' has a wrong offset!");
static_assert(offsetof(UStoreChapterPackViewData, PackImagePtr) == 0x000128, "Member 'UStoreChapterPackViewData::PackImagePtr' has a wrong offset!");
static_assert(offsetof(UStoreChapterPackViewData, PriceTagData) == 0x000198, "Member 'UStoreChapterPackViewData::PriceTagData' has a wrong offset!");

// Class DBDUIViewInterfaces.FearMarketPopupViewData
// 0x0020 (0x0210 - 0x01F0)
class UFearMarketPopupViewData final : public UGenericPopupViewData
{
public:
	class UMenuPerkViewData*                      ItemData;                                          // 0x01F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Cost;                                              // 0x01F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BloodpointConversion;                              // 0x01FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsPurchased;                                       // 0x0200(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AlreadyOwned;                                      // 0x0201(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_202[0x2];                                      // 0x0202(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AvailableTokens;                                   // 0x0204(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_208[0x8];                                      // 0x0208(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FearMarketPopupViewData">();
	}
	static class UFearMarketPopupViewData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFearMarketPopupViewData>();
	}
};
static_assert(alignof(UFearMarketPopupViewData) == 0x000010, "Wrong alignment on UFearMarketPopupViewData");
static_assert(sizeof(UFearMarketPopupViewData) == 0x000210, "Wrong size on UFearMarketPopupViewData");
static_assert(offsetof(UFearMarketPopupViewData, ItemData) == 0x0001F0, "Member 'UFearMarketPopupViewData::ItemData' has a wrong offset!");
static_assert(offsetof(UFearMarketPopupViewData, Cost) == 0x0001F8, "Member 'UFearMarketPopupViewData::Cost' has a wrong offset!");
static_assert(offsetof(UFearMarketPopupViewData, BloodpointConversion) == 0x0001FC, "Member 'UFearMarketPopupViewData::BloodpointConversion' has a wrong offset!");
static_assert(offsetof(UFearMarketPopupViewData, IsPurchased) == 0x000200, "Member 'UFearMarketPopupViewData::IsPurchased' has a wrong offset!");
static_assert(offsetof(UFearMarketPopupViewData, AlreadyOwned) == 0x000201, "Member 'UFearMarketPopupViewData::AlreadyOwned' has a wrong offset!");
static_assert(offsetof(UFearMarketPopupViewData, AvailableTokens) == 0x000204, "Member 'UFearMarketPopupViewData::AvailableTokens' has a wrong offset!");

// Class DBDUIViewInterfaces.GenericTextInputPopupViewInterface
// 0x0000 (0x0030 - 0x0030)
class IGenericTextInputPopupViewInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GenericTextInputPopupViewInterface">();
	}
	static class IGenericTextInputPopupViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGenericTextInputPopupViewInterface>();
	}
};
static_assert(alignof(IGenericTextInputPopupViewInterface) == 0x000008, "Wrong alignment on IGenericTextInputPopupViewInterface");
static_assert(sizeof(IGenericTextInputPopupViewInterface) == 0x000030, "Wrong size on IGenericTextInputPopupViewInterface");

// Class DBDUIViewInterfaces.FearMarketPopupViewInterface
// 0x0000 (0x0030 - 0x0030)
class IFearMarketPopupViewInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FearMarketPopupViewInterface">();
	}
	static class IFearMarketPopupViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFearMarketPopupViewInterface>();
	}
};
static_assert(alignof(IFearMarketPopupViewInterface) == 0x000008, "Wrong alignment on IFearMarketPopupViewInterface");
static_assert(sizeof(IFearMarketPopupViewInterface) == 0x000030, "Wrong size on IFearMarketPopupViewInterface");

// Class DBDUIViewInterfaces.StoreCollectionsViewInterface
// 0x0000 (0x0030 - 0x0030)
class IStoreCollectionsViewInterface final : public IInterface
{
public:
	void SetMenuState(EStoreCollectionsMenuState MenuState);

	TScriptInterface<class IStoreCollectionsCustomizationsViewInterface> GetCollectionsCustomizationsInterface() const;
	TScriptInterface<class IStoreCollectionsListViewInterface> GetCollectionsListViewInterface() const;
	EStoreCollectionsMenuState GetMenuState() const;
	TScriptInterface<class IStoreRightStickControllableViewInterface> GetStoreRightStickControllableViewInterface() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StoreCollectionsViewInterface">();
	}
	static class IStoreCollectionsViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IStoreCollectionsViewInterface>();
	}
};
static_assert(alignof(IStoreCollectionsViewInterface) == 0x000008, "Wrong alignment on IStoreCollectionsViewInterface");
static_assert(sizeof(IStoreCollectionsViewInterface) == 0x000030, "Wrong size on IStoreCollectionsViewInterface");

// Class DBDUIViewInterfaces.FriendSearchPopupViewInterface
// 0x0000 (0x0030 - 0x0030)
class IFriendSearchPopupViewInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FriendSearchPopupViewInterface">();
	}
	static class IFriendSearchPopupViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFriendSearchPopupViewInterface>();
	}
};
static_assert(alignof(IFriendSearchPopupViewInterface) == 0x000008, "Wrong alignment on IFriendSearchPopupViewInterface");
static_assert(sizeof(IFriendSearchPopupViewInterface) == 0x000030, "Wrong size on IFriendSearchPopupViewInterface");

// Class DBDUIViewInterfaces.GameManualViewInterface
// 0x0000 (0x0030 - 0x0030)
class IGameManualViewInterface final : public IInterface
{
public:
	void SetCategoryData(const struct FHelpCategoryData& CategoryData, const TArray<struct FHelpTopicData>& TopicsData);
	void SetCurrentManualMenuState(const EGameManualMenuState MenuState);

	const EGameManualMenuState GetCurrentManualMenuState() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameManualViewInterface">();
	}
	static class IGameManualViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGameManualViewInterface>();
	}
};
static_assert(alignof(IGameManualViewInterface) == 0x000008, "Wrong alignment on IGameManualViewInterface");
static_assert(sizeof(IGameManualViewInterface) == 0x000030, "Wrong size on IGameManualViewInterface");

// Class DBDUIViewInterfaces.StoreCharactersCustomizationsViewInterface
// 0x0000 (0x0030 - 0x0030)
class IStoreCharactersCustomizationsViewInterface final : public IInterface
{
public:
	void SetData(const struct FStoreCharactersCustomizationsViewData& Data, const EScrollAction ScrollAction);
	void ToggleCharmSlotsVisibility();
	void UpdateCategories(const TArray<struct FStoreCategoryViewData>& Categories, const ECustomizationCategory SelectedCategory);
	void UpdateCurrentPresetButton(const bool IsPreviewingAnyCustomization);
	void UpdateSelectedCustomizations(const TArray<class UStoreCustomizationItemViewData*>& SelectedCustomizations, const int32 SelectedSlotIndex, const EScrollAction ScrollAction);

	TScriptInterface<class ISearchBarViewInterface> GetSearchBarViewInterface() const;
	TScriptInterface<class IStoreCharactersFilterViewInterface> GetStoreCharactersFilterInterface() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StoreCharactersCustomizationsViewInterface">();
	}
	static class IStoreCharactersCustomizationsViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IStoreCharactersCustomizationsViewInterface>();
	}
};
static_assert(alignof(IStoreCharactersCustomizationsViewInterface) == 0x000008, "Wrong alignment on IStoreCharactersCustomizationsViewInterface");
static_assert(sizeof(IStoreCharactersCustomizationsViewInterface) == 0x000030, "Wrong size on IStoreCharactersCustomizationsViewInterface");

// Class DBDUIViewInterfaces.GenericPopupViewInterface
// 0x0000 (0x0030 - 0x0030)
class IGenericPopupViewInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GenericPopupViewInterface">();
	}
	static class IGenericPopupViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGenericPopupViewInterface>();
	}
};
static_assert(alignof(IGenericPopupViewInterface) == 0x000008, "Wrong alignment on IGenericPopupViewInterface");
static_assert(sizeof(IGenericPopupViewInterface) == 0x000030, "Wrong size on IGenericPopupViewInterface");

// Class DBDUIViewInterfaces.HudAlertViewInterface
// 0x0000 (0x0030 - 0x0030)
class IHudAlertViewInterface final : public IInterface
{
public:
	void FadeIn();
	void FadeOut(float Delay);
	void SetScoreEventsVisibility(bool Visible);
	void ShowScoreAlert(const struct FScoreAlertViewData& Data);
	void ShowStatusEffectAlert(const struct FStatusEffectAlertViewData& Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HudAlertViewInterface">();
	}
	static class IHudAlertViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IHudAlertViewInterface>();
	}
};
static_assert(alignof(IHudAlertViewInterface) == 0x000008, "Wrong alignment on IHudAlertViewInterface");
static_assert(sizeof(IHudAlertViewInterface) == 0x000030, "Wrong size on IHudAlertViewInterface");

// Class DBDUIViewInterfaces.GenericRefreshingPopupViewData
// 0x0050 (0x0240 - 0x01F0)
class UGenericRefreshingPopupViewData final : public UGenericPopupViewData
{
public:
	float                                         RefreshingIntervalsTime;                           // 0x01F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeoutTime;                                       // 0x01F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F8[0x48];                                     // 0x01F8(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GenericRefreshingPopupViewData">();
	}
	static class UGenericRefreshingPopupViewData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGenericRefreshingPopupViewData>();
	}
};
static_assert(alignof(UGenericRefreshingPopupViewData) == 0x000010, "Wrong alignment on UGenericRefreshingPopupViewData");
static_assert(sizeof(UGenericRefreshingPopupViewData) == 0x000240, "Wrong size on UGenericRefreshingPopupViewData");
static_assert(offsetof(UGenericRefreshingPopupViewData, RefreshingIntervalsTime) == 0x0001F0, "Member 'UGenericRefreshingPopupViewData::RefreshingIntervalsTime' has a wrong offset!");
static_assert(offsetof(UGenericRefreshingPopupViewData, TimeoutTime) == 0x0001F4, "Member 'UGenericRefreshingPopupViewData::TimeoutTime' has a wrong offset!");

// Class DBDUIViewInterfaces.StatusEffectViewInterface
// 0x0000 (0x0030 - 0x0030)
class IStatusEffectViewInterface final : public IInterface
{
public:
	void RemoveExistingStatusEffect(const class FName& StatusEffectId);
	void ShowActiveStatusEffect(const struct FStatusEffectViewData& StatusEffectData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StatusEffectViewInterface">();
	}
	static class IStatusEffectViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IStatusEffectViewInterface>();
	}
};
static_assert(alignof(IStatusEffectViewInterface) == 0x000008, "Wrong alignment on IStatusEffectViewInterface");
static_assert(sizeof(IStatusEffectViewInterface) == 0x000030, "Wrong size on IStatusEffectViewInterface");

// Class DBDUIViewInterfaces.GenericRefreshingPopupViewInterface
// 0x0000 (0x0030 - 0x0030)
class IGenericRefreshingPopupViewInterface final : public IInterface
{
public:
	void Refresh(float RemainingTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GenericRefreshingPopupViewInterface">();
	}
	static class IGenericRefreshingPopupViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGenericRefreshingPopupViewInterface>();
	}
};
static_assert(alignof(IGenericRefreshingPopupViewInterface) == 0x000008, "Wrong alignment on IGenericRefreshingPopupViewInterface");
static_assert(sizeof(IGenericRefreshingPopupViewInterface) == 0x000030, "Wrong size on IGenericRefreshingPopupViewInterface");

// Class DBDUIViewInterfaces.HookCountViewInterface
// 0x0000 (0x0030 - 0x0030)
class IHookCountViewInterface final : public IInterface
{
public:
	void ClearData();
	void InitWidget(const EGameType GameType, const int32 NumberOfSegments);
	void SetData(const int32 CurrentHookCount, const int32 MaxHookCount, const int32 InitialMaxHookCount, const TSet<int32>& AssistedHookIndices, const bool IsFinisherMoriAvailable);
	void SetHookCountVisibility(bool Visible);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HookCountViewInterface">();
	}
	static class IHookCountViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IHookCountViewInterface>();
	}
};
static_assert(alignof(IHookCountViewInterface) == 0x000008, "Wrong alignment on IHookCountViewInterface");
static_assert(sizeof(IHookCountViewInterface) == 0x000030, "Wrong size on IHookCountViewInterface");

// Class DBDUIViewInterfaces.HudAimingCrosshairViewInterface
// 0x0000 (0x0030 - 0x0030)
class IHudAimingCrosshairViewInterface final : public IInterface
{
public:
	void SetProgress(const float Progress);
	void SetState(const EAimingCrosshairState NewState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HudAimingCrosshairViewInterface">();
	}
	static class IHudAimingCrosshairViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IHudAimingCrosshairViewInterface>();
	}
};
static_assert(alignof(IHudAimingCrosshairViewInterface) == 0x000008, "Wrong alignment on IHudAimingCrosshairViewInterface");
static_assert(sizeof(IHudAimingCrosshairViewInterface) == 0x000030, "Wrong size on IHudAimingCrosshairViewInterface");

// Class DBDUIViewInterfaces.HudDirectionalMiniGameViewInterface
// 0x0000 (0x0030 - 0x0030)
class IHudDirectionalMiniGameViewInterface final : public IInterface
{
public:
	void Hide();
	void Init(int32 MaxItems, EDirectionalMiniGameType Type);
	void Show(const TArray<EDirectionalInputKey>& Directions);
	void UpdateFinalResult(EDirectionalMinigameResult FinalResult);
	void UpdateResult(int32 Param_Index, bool IsSuccessful);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HudDirectionalMiniGameViewInterface">();
	}
	static class IHudDirectionalMiniGameViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IHudDirectionalMiniGameViewInterface>();
	}
};
static_assert(alignof(IHudDirectionalMiniGameViewInterface) == 0x000008, "Wrong alignment on IHudDirectionalMiniGameViewInterface");
static_assert(sizeof(IHudDirectionalMiniGameViewInterface) == 0x000030, "Wrong size on IHudDirectionalMiniGameViewInterface");

// Class DBDUIViewInterfaces.HudEffectCardViewInterface
// 0x0000 (0x0030 - 0x0030)
class IHudEffectCardViewInterface final : public IInterface
{
public:
	void ActivateNextCard();
	void FadeIn();
	void FadeOut();
	void SetData(const TArray<struct FEffectCardViewData>& EffectCardsViewData, const int32 ActiveCardIndex, const int32 Points, const float ActiveCardTime);
	void SetMatchPoints(const int32 Points);
	void UpdateTimerFeedback(const float ElapsedTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HudEffectCardViewInterface">();
	}
	static class IHudEffectCardViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IHudEffectCardViewInterface>();
	}
};
static_assert(alignof(IHudEffectCardViewInterface) == 0x000008, "Wrong alignment on IHudEffectCardViewInterface");
static_assert(sizeof(IHudEffectCardViewInterface) == 0x000030, "Wrong size on IHudEffectCardViewInterface");

// Class DBDUIViewInterfaces.HudEventObjectiveItemViewInterface
// 0x0000 (0x0030 - 0x0030)
class IHudEventObjectiveItemViewInterface final : public IInterface
{
public:
	void BP_OnStateAnimationFinished(const EEventObjectiveItemState FinishedEventItemState);
	void ClearData();
	void InitWidget(bool IsLocalKiller);
	void SetAvailableCharges(const int32 Charges, const int32 MaxCharges);
	void SetChargePercentage(const float ChargePercent);
	void SetCooldownPercentage(const float CooldownPercent);
	void SetInputKey(const struct FKey& InputKey);
	void SetWidgetData(const EEventObjectiveItemState EventItemState, const int32 Charges, const int32 MaxCharges, const float ChargePercent);
	void SetWidgetState(const EEventObjectiveItemState EventItemState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HudEventObjectiveItemViewInterface">();
	}
	static class IHudEventObjectiveItemViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IHudEventObjectiveItemViewInterface>();
	}
};
static_assert(alignof(IHudEventObjectiveItemViewInterface) == 0x000008, "Wrong alignment on IHudEventObjectiveItemViewInterface");
static_assert(sizeof(IHudEventObjectiveItemViewInterface) == 0x000030, "Wrong size on IHudEventObjectiveItemViewInterface");

// Class DBDUIViewInterfaces.HudEventProgression2023ViewInterface
// 0x0000 (0x0030 - 0x0030)
class IHudEventProgression2023ViewInterface final : public IInterface
{
public:
	void EnableEventProgression(const bool IsEnabled);
	void InitEventProgression(const struct FHudEventProgression2023ViewData& HudEventProgressionViewData);
	void UpdateEnergyProgress(const struct FHudEventProgression2023ViewData& HudEventProgressionViewData);
	void UpdateHauntTarget(const struct FHudEventProgression2023ViewData& HudEventProgressionViewData);
	void UpdateVoidZoneState(const struct FHudEventProgression2023ViewData& HudEventProgressionViewData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HudEventProgression2023ViewInterface">();
	}
	static class IHudEventProgression2023ViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IHudEventProgression2023ViewInterface>();
	}
};
static_assert(alignof(IHudEventProgression2023ViewInterface) == 0x000008, "Wrong alignment on IHudEventProgression2023ViewInterface");
static_assert(sizeof(IHudEventProgression2023ViewInterface) == 0x000030, "Wrong size on IHudEventProgression2023ViewInterface");

// Class DBDUIViewInterfaces.HudEventProgressionViewInterface
// 0x0000 (0x0030 - 0x0030)
class IHudEventProgressionViewInterface final : public IInterface
{
public:
	void EnableEventProgression(const bool IsEnabled);
	void InitEventProgression(const struct FHudEventProgressionViewData& HudEventProgressionViewData);
	void UpdateEventBankedProgress(const struct FHudEventProgressionViewData& HudEventProgressionViewData);
	void UpdateEventPendingProgress(const struct FHudEventProgressionViewData& HudEventProgressionViewData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HudEventProgressionViewInterface">();
	}
	static class IHudEventProgressionViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IHudEventProgressionViewInterface>();
	}
};
static_assert(alignof(IHudEventProgressionViewInterface) == 0x000008, "Wrong alignment on IHudEventProgressionViewInterface");
static_assert(sizeof(IHudEventProgressionViewInterface) == 0x000030, "Wrong size on IHudEventProgressionViewInterface");

// Class DBDUIViewInterfaces.HudItemPickupViewInterface
// 0x0000 (0x0030 - 0x0030)
class IHudItemPickupViewInterface final : public IInterface
{
public:
	void HideItemPickupPrompt();
	void SetData(const struct FItemPickupViewData& ItemToPickUpData, const struct FItemPickupViewData& CurrentItem);
	void ShowItemPickupPrompt();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HudItemPickupViewInterface">();
	}
	static class IHudItemPickupViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IHudItemPickupViewInterface>();
	}
};
static_assert(alignof(IHudItemPickupViewInterface) == 0x000008, "Wrong alignment on IHudItemPickupViewInterface");
static_assert(sizeof(IHudItemPickupViewInterface) == 0x000030, "Wrong size on IHudItemPickupViewInterface");

// Class DBDUIViewInterfaces.HudObjectivesViewInterface
// 0x0000 (0x0030 - 0x0030)
class IHudObjectivesViewInterface final : public IInterface
{
public:
	void ClearData();
	void ClearHookCountData();
	void InitWidget(const EGameType GameType, const int32 NumberOfSegments);
	void SetHookCountData(const int32 CurrentHookCount, const int32 MaxHookCount, const int32 InitialMaxHookCount, const TSet<int32>& AssistedHookIndices, const bool IsFinisherMoriAvailable);
	void SetHookCountVisibility(bool Visible);
	void SetHudObjectiveData(const struct FHudObjectivesViewData& HudObjectiveViewData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HudObjectivesViewInterface">();
	}
	static class IHudObjectivesViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IHudObjectivesViewInterface>();
	}
};
static_assert(alignof(IHudObjectivesViewInterface) == 0x000008, "Wrong alignment on IHudObjectivesViewInterface");
static_assert(sizeof(IHudObjectivesViewInterface) == 0x000030, "Wrong size on IHudObjectivesViewInterface");

// Class DBDUIViewInterfaces.InboxBodySectionViewData
// 0x00C8 (0x00F8 - 0x0030)
class UInboxBodySectionViewData final : public UObject
{
public:
	ENewsAndMessagesSectionType                   Type;                                              // 0x0030(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Text;                                              // 0x0038(0x0018)(BlueprintVisible, BlueprintReadOnly, Transient, ExposeOnSpawn, NativeAccessSpecifierPublic)
	struct FSoftRemoteContentCacheObjectPtr       Image;                                             // 0x0050(0x0070)(BlueprintVisible, BlueprintReadOnly, Transient, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ENewsAndMessagesAlignmentType                 Alignment;                                         // 0x00C0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C1[0x7];                                       // 0x00C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRewardWrapperViewData>         Rewards;                                           // 0x00C8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, ExposeOnSpawn, NativeAccessSpecifierPublic)
	struct FDateTime                              ItemExpirationDate;                                // 0x00D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 QRCode;                                            // 0x00E0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SwitchKillSwitch;                                  // 0x00F0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F1[0x7];                                       // 0x00F1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InboxBodySectionViewData">();
	}
	static class UInboxBodySectionViewData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInboxBodySectionViewData>();
	}
};
static_assert(alignof(UInboxBodySectionViewData) == 0x000008, "Wrong alignment on UInboxBodySectionViewData");
static_assert(sizeof(UInboxBodySectionViewData) == 0x0000F8, "Wrong size on UInboxBodySectionViewData");
static_assert(offsetof(UInboxBodySectionViewData, Type) == 0x000030, "Member 'UInboxBodySectionViewData::Type' has a wrong offset!");
static_assert(offsetof(UInboxBodySectionViewData, Text) == 0x000038, "Member 'UInboxBodySectionViewData::Text' has a wrong offset!");
static_assert(offsetof(UInboxBodySectionViewData, Image) == 0x000050, "Member 'UInboxBodySectionViewData::Image' has a wrong offset!");
static_assert(offsetof(UInboxBodySectionViewData, Alignment) == 0x0000C0, "Member 'UInboxBodySectionViewData::Alignment' has a wrong offset!");
static_assert(offsetof(UInboxBodySectionViewData, Rewards) == 0x0000C8, "Member 'UInboxBodySectionViewData::Rewards' has a wrong offset!");
static_assert(offsetof(UInboxBodySectionViewData, ItemExpirationDate) == 0x0000D8, "Member 'UInboxBodySectionViewData::ItemExpirationDate' has a wrong offset!");
static_assert(offsetof(UInboxBodySectionViewData, QRCode) == 0x0000E0, "Member 'UInboxBodySectionViewData::QRCode' has a wrong offset!");
static_assert(offsetof(UInboxBodySectionViewData, SwitchKillSwitch) == 0x0000F0, "Member 'UInboxBodySectionViewData::SwitchKillSwitch' has a wrong offset!");

// Class DBDUIViewInterfaces.InboxBodyViewData
// 0x0018 (0x0048 - 0x0030)
class UInboxBodyViewData final : public UObject
{
public:
	TArray<class UInboxBodySectionViewData*>      Sections;                                          // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, ExposeOnSpawn, NativeAccessSpecifierPublic)
	ENewsAndMessagesBodyType                      BodyType;                                          // 0x0040(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InboxBodyViewData">();
	}
	static class UInboxBodyViewData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInboxBodyViewData>();
	}
};
static_assert(alignof(UInboxBodyViewData) == 0x000008, "Wrong alignment on UInboxBodyViewData");
static_assert(sizeof(UInboxBodyViewData) == 0x000048, "Wrong size on UInboxBodyViewData");
static_assert(offsetof(UInboxBodyViewData, Sections) == 0x000030, "Member 'UInboxBodyViewData::Sections' has a wrong offset!");
static_assert(offsetof(UInboxBodyViewData, BodyType) == 0x000040, "Member 'UInboxBodyViewData::BodyType' has a wrong offset!");

// Class DBDUIViewInterfaces.InboxItemViewData
// 0x0070 (0x00A0 - 0x0030)
class UInboxItemViewData final : public UObject
{
public:
	class FName                                   ID;                                                // 0x0030(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Title;                                             // 0x0040(0x0018)(BlueprintVisible, BlueprintReadOnly, Transient, ExposeOnSpawn, NativeAccessSpecifierPublic)
	class FText                                   Subtitle;                                          // 0x0058(0x0018)(BlueprintVisible, BlueprintReadOnly, Transient, ExposeOnSpawn, NativeAccessSpecifierPublic)
	ENewsAndMessagesIconType                      IconType;                                          // 0x0070(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsNew;                                             // 0x0071(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsSticky;                                          // 0x0072(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_73[0x5];                                       // 0x0073(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              StartDate;                                         // 0x0078(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              ExpirationDate;                                    // 0x0080(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInboxRewardStatus                            RewardStatus;                                      // 0x0088(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UInboxBodyViewData*                     BodyViewData;                                      // 0x0090(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         MessageId;                                         // 0x0098(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InboxItemViewData">();
	}
	static class UInboxItemViewData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInboxItemViewData>();
	}
};
static_assert(alignof(UInboxItemViewData) == 0x000008, "Wrong alignment on UInboxItemViewData");
static_assert(sizeof(UInboxItemViewData) == 0x0000A0, "Wrong size on UInboxItemViewData");
static_assert(offsetof(UInboxItemViewData, ID) == 0x000030, "Member 'UInboxItemViewData::ID' has a wrong offset!");
static_assert(offsetof(UInboxItemViewData, Title) == 0x000040, "Member 'UInboxItemViewData::Title' has a wrong offset!");
static_assert(offsetof(UInboxItemViewData, Subtitle) == 0x000058, "Member 'UInboxItemViewData::Subtitle' has a wrong offset!");
static_assert(offsetof(UInboxItemViewData, IconType) == 0x000070, "Member 'UInboxItemViewData::IconType' has a wrong offset!");
static_assert(offsetof(UInboxItemViewData, IsNew) == 0x000071, "Member 'UInboxItemViewData::IsNew' has a wrong offset!");
static_assert(offsetof(UInboxItemViewData, IsSticky) == 0x000072, "Member 'UInboxItemViewData::IsSticky' has a wrong offset!");
static_assert(offsetof(UInboxItemViewData, StartDate) == 0x000078, "Member 'UInboxItemViewData::StartDate' has a wrong offset!");
static_assert(offsetof(UInboxItemViewData, ExpirationDate) == 0x000080, "Member 'UInboxItemViewData::ExpirationDate' has a wrong offset!");
static_assert(offsetof(UInboxItemViewData, RewardStatus) == 0x000088, "Member 'UInboxItemViewData::RewardStatus' has a wrong offset!");
static_assert(offsetof(UInboxItemViewData, BodyViewData) == 0x000090, "Member 'UInboxItemViewData::BodyViewData' has a wrong offset!");
static_assert(offsetof(UInboxItemViewData, MessageId) == 0x000098, "Member 'UInboxItemViewData::MessageId' has a wrong offset!");

// Class DBDUIViewInterfaces.InboxViewInterface
// 0x0000 (0x0030 - 0x0030)
class IInboxViewInterface final : public IInterface
{
public:
	void SetData(const EInboxTab Tab, const TArray<class UInboxItemViewData*>& Data);
	void SetListError(const EInboxTab Tab);
	void SetLoading(const EInboxTab Tab);
	void SetSelectedItem(const class UInboxItemViewData* ViewData, const EInboxTab Tab);
	void SetTabNotificationIcon(const EInboxTab Tab, const bool ShowNotificationIcon);
	void SetTabsData(const TArray<struct FTabWidgetData>& TabsData, const EInboxTab SelectedTab);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InboxViewInterface">();
	}
	static class IInboxViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IInboxViewInterface>();
	}
};
static_assert(alignof(IInboxViewInterface) == 0x000008, "Wrong alignment on IInboxViewInterface");
static_assert(sizeof(IInboxViewInterface) == 0x000030, "Wrong size on IInboxViewInterface");

// Class DBDUIViewInterfaces.InteractionProgressViewInterface
// 0x0000 (0x0030 - 0x0030)
class IInteractionProgressViewInterface final : public IInterface
{
public:
	void HideInputProgressPrompt();
	void PlayHemorrhageAnimation();
	void SetInputProgressPrompt(const struct FInteractionProgressViewData& Data);
	void UpdateInputProgress(const float Progress, const float ItemCharge, bool IsBlocked, float PercentageStopDischarge);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionProgressViewInterface">();
	}
	static class IInteractionProgressViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IInteractionProgressViewInterface>();
	}
};
static_assert(alignof(IInteractionProgressViewInterface) == 0x000008, "Wrong alignment on IInteractionProgressViewInterface");
static_assert(sizeof(IInteractionProgressViewInterface) == 0x000030, "Wrong size on IInteractionProgressViewInterface");

// Class DBDUIViewInterfaces.InteractionPromptsContainerViewInterface
// 0x0000 (0x0030 - 0x0030)
class IInteractionPromptsContainerViewInterface final : public IInterface
{
public:
	void AddPrompt(const struct FInteractionPromptViewData& Data);
	void RemoveAllPrompts();
	void RemovePrompt(class FName ID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionPromptsContainerViewInterface">();
	}
	static class IInteractionPromptsContainerViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IInteractionPromptsContainerViewInterface>();
	}
};
static_assert(alignof(IInteractionPromptsContainerViewInterface) == 0x000008, "Wrong alignment on IInteractionPromptsContainerViewInterface");
static_assert(sizeof(IInteractionPromptsContainerViewInterface) == 0x000030, "Wrong size on IInteractionPromptsContainerViewInterface");

// Class DBDUIViewInterfaces.ItemBundleViewInterface
// 0x0000 (0x0030 - 0x0030)
class IItemBundleViewInterface final : public IInterface
{
public:
	void ClearData();
	void SetData(const struct FItemBundleViewData& ItemBundleViewData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemBundleViewInterface">();
	}
	static class IItemBundleViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IItemBundleViewInterface>();
	}
};
static_assert(alignof(IItemBundleViewInterface) == 0x000008, "Wrong alignment on IItemBundleViewInterface");
static_assert(sizeof(IItemBundleViewInterface) == 0x000030, "Wrong size on IItemBundleViewInterface");

// Class DBDUIViewInterfaces.ItemInteractionViewInterface
// 0x0000 (0x0030 - 0x0030)
class IItemInteractionViewInterface final : public IInterface
{
public:
	void ClearData();
	void SetData(const struct FItemBundleViewData& ItemBundleData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemInteractionViewInterface">();
	}
	static class IItemInteractionViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IItemInteractionViewInterface>();
	}
};
static_assert(alignof(IItemInteractionViewInterface) == 0x000008, "Wrong alignment on IItemInteractionViewInterface");
static_assert(sizeof(IItemInteractionViewInterface) == 0x000030, "Wrong size on IItemInteractionViewInterface");

// Class DBDUIViewInterfaces.ItemViewInterface
// 0x0000 (0x0030 - 0x0030)
class IItemViewInterface final : public IInterface
{
public:
	void ClearData();
	void SetData(const struct FItemViewData& ItemViewData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemViewInterface">();
	}
	static class IItemViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IItemViewInterface>();
	}
};
static_assert(alignof(IItemViewInterface) == 0x000008, "Wrong alignment on IItemViewInterface");
static_assert(sizeof(IItemViewInterface) == 0x000030, "Wrong size on IItemViewInterface");

// Class DBDUIViewInterfaces.KillerStatusViewInterface
// 0x0000 (0x0030 - 0x0030)
class IKillerStatusViewInterface final : public IInterface
{
public:
	void ClearData();
	void SetData(const struct FPlayerStatusViewData& Data);
	void SetPlayerNameVisibility(bool Visible);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerStatusViewInterface">();
	}
	static class IKillerStatusViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IKillerStatusViewInterface>();
	}
};
static_assert(alignof(IKillerStatusViewInterface) == 0x000008, "Wrong alignment on IKillerStatusViewInterface");
static_assert(sizeof(IKillerStatusViewInterface) == 0x000030, "Wrong size on IKillerStatusViewInterface");

// Class DBDUIViewInterfaces.LeaningArrowsViewInterface
// 0x0000 (0x0030 - 0x0030)
class ILeaningArrowsViewInterface final : public IInterface
{
public:
	void SetData(const ELeanState& LeanState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LeaningArrowsViewInterface">();
	}
	static class ILeaningArrowsViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ILeaningArrowsViewInterface>();
	}
};
static_assert(alignof(ILeaningArrowsViewInterface) == 0x000008, "Wrong alignment on ILeaningArrowsViewInterface");
static_assert(sizeof(ILeaningArrowsViewInterface) == 0x000030, "Wrong size on ILeaningArrowsViewInterface");

// Class DBDUIViewInterfaces.LoadingScreenViewInterface
// 0x0000 (0x0030 - 0x0030)
class ILoadingScreenViewInterface final : public IInterface
{
public:
	bool HasCustomWidgetForEvent(const class FName& EventID);
	void SetLoadingHint(const struct FLoadingHintViewData& LoadingHintData);
	void SetLoadingScreenType(ELoadingScreenType LoadingScreenType);
	void SetSpecialEventLoadingScreen(const class FName EventID);
	void Setup();
	void ShowLoadingBannerImage(const bool IsKiller);
	void UpdateProgress(float Progress);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoadingScreenViewInterface">();
	}
	static class ILoadingScreenViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ILoadingScreenViewInterface>();
	}
};
static_assert(alignof(ILoadingScreenViewInterface) == 0x000008, "Wrong alignment on ILoadingScreenViewInterface");
static_assert(sizeof(ILoadingScreenViewInterface) == 0x000030, "Wrong size on ILoadingScreenViewInterface");

// Class DBDUIViewInterfaces.LoadoutMenuViewInterface
// 0x0000 (0x0030 - 0x0030)
class ILoadoutMenuViewInterface final : public IInterface
{
public:
	void SetIsPerkSurfacingExperimentActive(const bool IsPerkSurfacingExperimentActive);
	void SetLoadoutMenuInventoryData(const TArray<class ULoadoutMenuViewData*>& LoadoutMenuSlotButtonData, const ELoadoutSlot SlotSelected, const bool IsNextSlot);
	void SetLoadoutMenuSlotData(const TArray<class ULoadoutMenuViewData*>& LoadoutMenuSlotButtonData);
	void SetSelectableCharacters(const TArray<struct FTabWidgetData>& SelectableCharacters, const struct FTabWidgetData& SelectedCharacterData, const int32 botIndex);
	void SetSelectedInventoryItem(const TArray<int32>& SelectedIndex, const bool IsUnequip);
	void UpdatePresetData(const TArray<int32>& PresetData, const int32 SelectedPreset);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoadoutMenuViewInterface">();
	}
	static class ILoadoutMenuViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ILoadoutMenuViewInterface>();
	}
};
static_assert(alignof(ILoadoutMenuViewInterface) == 0x000008, "Wrong alignment on ILoadoutMenuViewInterface");
static_assert(sizeof(ILoadoutMenuViewInterface) == 0x000030, "Wrong size on ILoadoutMenuViewInterface");

// Class DBDUIViewInterfaces.LobbyCharactersViewInterface
// 0x0000 (0x0030 - 0x0030)
class ILobbyCharactersViewInterface final : public IInterface
{
public:
	TScriptInterface<class IStoreCharactersBioViewInterface> GetStoreCharactersBioInterface() const;
	TScriptInterface<class IStoreCharactersCustomizationsViewInterface> GetStoreCharactersCustomizationsInterface() const;
	TScriptInterface<class IStoreCharactersSelectionViewInterface> GetStoreCharactersSelectionInterface() const;
	TScriptInterface<class IWardrobeActionButtonsViewInterface> GetWardrobeActionButtonsInterface() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LobbyCharactersViewInterface">();
	}
	static class ILobbyCharactersViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ILobbyCharactersViewInterface>();
	}
};
static_assert(alignof(ILobbyCharactersViewInterface) == 0x000008, "Wrong alignment on ILobbyCharactersViewInterface");
static_assert(sizeof(ILobbyCharactersViewInterface) == 0x000030, "Wrong size on ILobbyCharactersViewInterface");

// Class DBDUIViewInterfaces.LobbyPlayerListViewInterface
// 0x0000 (0x0030 - 0x0030)
class ILobbyPlayerListViewInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LobbyPlayerListViewInterface">();
	}
	static class ILobbyPlayerListViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ILobbyPlayerListViewInterface>();
	}
};
static_assert(alignof(ILobbyPlayerListViewInterface) == 0x000008, "Wrong alignment on ILobbyPlayerListViewInterface");
static_assert(sizeof(ILobbyPlayerListViewInterface) == 0x000030, "Wrong size on ILobbyPlayerListViewInterface");

// Class DBDUIViewInterfaces.LockedFeatureElementViewInterface
// 0x0000 (0x0030 - 0x0030)
class ILockedFeatureElementViewInterface final : public IInterface
{
public:
	bool IsLockedFeature();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LockedFeatureElementViewInterface">();
	}
	static class ILockedFeatureElementViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ILockedFeatureElementViewInterface>();
	}
};
static_assert(alignof(ILockedFeatureElementViewInterface) == 0x000008, "Wrong alignment on ILockedFeatureElementViewInterface");
static_assert(sizeof(ILockedFeatureElementViewInterface) == 0x000030, "Wrong size on ILockedFeatureElementViewInterface");

// Class DBDUIViewInterfaces.MainMenuButtonViewInterface
// 0x0000 (0x0030 - 0x0030)
class IMainMenuButtonViewInterface final : public IInterface
{
public:
	int32 GetMainMenuButtonIndex();
	EMainMenuButtonType GetMainMenuButtonType();
	void SetMainMenuButtonIndex(int32 ButtonIndex);
	void SetMainMenuButtonType(EMainMenuButtonType MainMenuButtonType);
	void SetNotificationVisibility(bool IsVisible);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MainMenuButtonViewInterface">();
	}
	static class IMainMenuButtonViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IMainMenuButtonViewInterface>();
	}
};
static_assert(alignof(IMainMenuButtonViewInterface) == 0x000008, "Wrong alignment on IMainMenuButtonViewInterface");
static_assert(sizeof(IMainMenuButtonViewInterface) == 0x000030, "Wrong size on IMainMenuButtonViewInterface");

// Class DBDUIViewInterfaces.MainMenuViewInterface
// 0x0000 (0x0030 - 0x0030)
class IMainMenuViewInterface final : public IInterface
{
public:
	void AddButtonTimerFlag(EMainMenuButtonType ButtonType, const struct FTimerFlagViewData& TimerFlagViewData);
	void ClearButtonTimerFlags(EMainMenuButtonType ButtonType, int32 ButtonIndex);
	void DisplayMainMenu(const bool IsDisplayed);
	void ResetAllButtons();
	void ResetButton(EMainMenuButtonType ButtonType, int32 ButtonIndex);
	void SetButtonBetaFeatureVisibility(EMainMenuButtonType ButtonType, bool IsVisible, int32 ButtonIndex);
	void SetButtonDecoration(EMainMenuButtonType ButtonType, const class FString& DecorationId);
	void SetButtonDecorationVisible(EMainMenuButtonType ButtonType, bool IsVisible, int32 ButtonIndex);
	void SetButtonDisableState(const EMainMenuButtonType ButtonType, EButtonDisableState buttonDisableState, int32 ButtonIndex);
	void SetButtonEnabled(const EMainMenuButtonType ButtonType, bool IsEnabled, int32 ButtonIndex);
	void SetButtonIcon(EMainMenuButtonType ButtonType, const class FString& IconId, int32 ButtonIndex);
	void SetButtonNotificationVisibility(EMainMenuButtonType ButtonType, bool IsVisible, int32 ButtonIndex);
	void SetButtonVisibility(EMainMenuButtonType ButtonType, bool IsVisible);
	void SetChallengesButtonVisibility(const bool IsVisible);
	void SetChangeAccountInputSwitcherPlayerNickname(const class FString& PlayerNickname);
	void SetChangeAccountInputSwitcherVisible(bool Visible);
	void SetLabelButton(EMainMenuButtonType ButtonType, const class FText& Label, int32 ButtonIndex);
	void SetLTEButtons(const TArray<class FName>& EventNames, const TArray<EGameType>& EventGameTypes);
	void SetMatchmakingIncentive(const class FName& GameMode, EPlayerRole Role, int32 PercentAmount);
	void SetStoreButtonFlags(bool HasNewItem, const struct FTimerFlagViewData& RemainingLimitedItemTimeData, const struct FTimerFlagViewData& RemainingSaleTimeData);
	void SetSubtitle(EMainMenuButtonType ButtonType, const class FText& Subtitle, int32 ButtonIndex);
	void SetSubtitleVisible(EMainMenuButtonType ButtonType, bool IsVisible, int32 ButtonIndex);
	void SetUiTakeoverActive(const bool IsActive);

	void SetExitButtonEnabled(bool IsEnabled) const;
	void SetMarketingInvitationPopupButtonIcon(ECurrencyType CurrencyType) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MainMenuViewInterface">();
	}
	static class IMainMenuViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IMainMenuViewInterface>();
	}
};
static_assert(alignof(IMainMenuViewInterface) == 0x000008, "Wrong alignment on IMainMenuViewInterface");
static_assert(sizeof(IMainMenuViewInterface) == 0x000030, "Wrong size on IMainMenuViewInterface");

// Class DBDUIViewInterfaces.MarketingInvitationPopupViewData
// 0x00D0 (0x02C0 - 0x01F0)
class UMarketingInvitationPopupViewData final : public UGenericPopupViewData
{
public:
	bool                                          ShouldShowRewards;                                 // 0x01F0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShouldShowOptOutToggle;                            // 0x01F1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InitialOptOutToggleValue;                          // 0x01F2(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F3[0x5];                                      // 0x01F3(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UTexture2D>              KeyArtImage;                                       // 0x01F8(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              QrCodeImage;                                       // 0x0230(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   InstructionText;                                   // 0x0268(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	class FText                                   RewardTitleText;                                   // 0x0280(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FCurrencyProgressionRewardViewData> Rewards;                                           // 0x0298(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FSoftObjectPath>                VideosUri;                                         // 0x02A8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B8[0x8];                                      // 0x02B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarketingInvitationPopupViewData">();
	}
	static class UMarketingInvitationPopupViewData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMarketingInvitationPopupViewData>();
	}
};
static_assert(alignof(UMarketingInvitationPopupViewData) == 0x000010, "Wrong alignment on UMarketingInvitationPopupViewData");
static_assert(sizeof(UMarketingInvitationPopupViewData) == 0x0002C0, "Wrong size on UMarketingInvitationPopupViewData");
static_assert(offsetof(UMarketingInvitationPopupViewData, ShouldShowRewards) == 0x0001F0, "Member 'UMarketingInvitationPopupViewData::ShouldShowRewards' has a wrong offset!");
static_assert(offsetof(UMarketingInvitationPopupViewData, ShouldShowOptOutToggle) == 0x0001F1, "Member 'UMarketingInvitationPopupViewData::ShouldShowOptOutToggle' has a wrong offset!");
static_assert(offsetof(UMarketingInvitationPopupViewData, InitialOptOutToggleValue) == 0x0001F2, "Member 'UMarketingInvitationPopupViewData::InitialOptOutToggleValue' has a wrong offset!");
static_assert(offsetof(UMarketingInvitationPopupViewData, KeyArtImage) == 0x0001F8, "Member 'UMarketingInvitationPopupViewData::KeyArtImage' has a wrong offset!");
static_assert(offsetof(UMarketingInvitationPopupViewData, QrCodeImage) == 0x000230, "Member 'UMarketingInvitationPopupViewData::QrCodeImage' has a wrong offset!");
static_assert(offsetof(UMarketingInvitationPopupViewData, InstructionText) == 0x000268, "Member 'UMarketingInvitationPopupViewData::InstructionText' has a wrong offset!");
static_assert(offsetof(UMarketingInvitationPopupViewData, RewardTitleText) == 0x000280, "Member 'UMarketingInvitationPopupViewData::RewardTitleText' has a wrong offset!");
static_assert(offsetof(UMarketingInvitationPopupViewData, Rewards) == 0x000298, "Member 'UMarketingInvitationPopupViewData::Rewards' has a wrong offset!");
static_assert(offsetof(UMarketingInvitationPopupViewData, VideosUri) == 0x0002A8, "Member 'UMarketingInvitationPopupViewData::VideosUri' has a wrong offset!");

// Class DBDUIViewInterfaces.MarketingInvitationPopupViewInterface
// 0x0000 (0x0030 - 0x0030)
class IMarketingInvitationPopupViewInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarketingInvitationPopupViewInterface">();
	}
	static class IMarketingInvitationPopupViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IMarketingInvitationPopupViewInterface>();
	}
};
static_assert(alignof(IMarketingInvitationPopupViewInterface) == 0x000008, "Wrong alignment on IMarketingInvitationPopupViewInterface");
static_assert(sizeof(IMarketingInvitationPopupViewInterface) == 0x000030, "Wrong size on IMarketingInvitationPopupViewInterface");

// Class DBDUIViewInterfaces.MatchmakingViewInterface
// 0x0000 (0x0030 - 0x0030)
class IMatchmakingViewInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchmakingViewInterface">();
	}
	static class IMatchmakingViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IMatchmakingViewInterface>();
	}
};
static_assert(alignof(IMatchmakingViewInterface) == 0x000008, "Wrong alignment on IMatchmakingViewInterface");
static_assert(sizeof(IMatchmakingViewInterface) == 0x000030, "Wrong size on IMatchmakingViewInterface");

// Class DBDUIViewInterfaces.MatchResultViewInterface
// 0x0000 (0x0030 - 0x0030)
class IMatchResultViewInterface final : public IInterface
{
public:
	void PlayAnimationSequence();
	void SetMatchResultVisibility(ESlateVisibility Visibility);
	void UpdateWidget(const struct FMatchResultViewData& Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchResultViewInterface">();
	}
	static class IMatchResultViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IMatchResultViewInterface>();
	}
};
static_assert(alignof(IMatchResultViewInterface) == 0x000008, "Wrong alignment on IMatchResultViewInterface");
static_assert(sizeof(IMatchResultViewInterface) == 0x000030, "Wrong size on IMatchResultViewInterface");

// Class DBDUIViewInterfaces.MenuLoadoutPartViewData
// 0x0120 (0x0150 - 0x0030)
class UMenuLoadoutPartViewData : public UObject
{
public:
	class FName                                   ItemId;                                            // 0x0030(0x000C)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UTexture2D>              IconTexture;                                       // 0x0040(0x0038)(Edit, BlueprintVisible, Transient, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemRarity                                   Rarity;                                            // 0x0078(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x3];                                       // 0x0079(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         StackCount;                                        // 0x007C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ParentDisplayName;                                 // 0x0080(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          IsLocked;                                          // 0x0098(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemAvailability                             Availability;                                      // 0x0099(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsKillSwitchEnabled;                               // 0x009A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9B[0x5];                                       // 0x009B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLoadoutTooltipData                    TooltipData;                                       // 0x00A0(0x00B0)(Edit, BlueprintVisible, Transient, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MenuLoadoutPartViewData">();
	}
	static class UMenuLoadoutPartViewData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMenuLoadoutPartViewData>();
	}
};
static_assert(alignof(UMenuLoadoutPartViewData) == 0x000008, "Wrong alignment on UMenuLoadoutPartViewData");
static_assert(sizeof(UMenuLoadoutPartViewData) == 0x000150, "Wrong size on UMenuLoadoutPartViewData");
static_assert(offsetof(UMenuLoadoutPartViewData, ItemId) == 0x000030, "Member 'UMenuLoadoutPartViewData::ItemId' has a wrong offset!");
static_assert(offsetof(UMenuLoadoutPartViewData, IconTexture) == 0x000040, "Member 'UMenuLoadoutPartViewData::IconTexture' has a wrong offset!");
static_assert(offsetof(UMenuLoadoutPartViewData, Rarity) == 0x000078, "Member 'UMenuLoadoutPartViewData::Rarity' has a wrong offset!");
static_assert(offsetof(UMenuLoadoutPartViewData, StackCount) == 0x00007C, "Member 'UMenuLoadoutPartViewData::StackCount' has a wrong offset!");
static_assert(offsetof(UMenuLoadoutPartViewData, ParentDisplayName) == 0x000080, "Member 'UMenuLoadoutPartViewData::ParentDisplayName' has a wrong offset!");
static_assert(offsetof(UMenuLoadoutPartViewData, IsLocked) == 0x000098, "Member 'UMenuLoadoutPartViewData::IsLocked' has a wrong offset!");
static_assert(offsetof(UMenuLoadoutPartViewData, Availability) == 0x000099, "Member 'UMenuLoadoutPartViewData::Availability' has a wrong offset!");
static_assert(offsetof(UMenuLoadoutPartViewData, IsKillSwitchEnabled) == 0x00009A, "Member 'UMenuLoadoutPartViewData::IsKillSwitchEnabled' has a wrong offset!");
static_assert(offsetof(UMenuLoadoutPartViewData, TooltipData) == 0x0000A0, "Member 'UMenuLoadoutPartViewData::TooltipData' has a wrong offset!");

// Class DBDUIViewInterfaces.MenuAddonViewData
// 0x0000 (0x0150 - 0x0150)
class UMenuAddonViewData final : public UMenuLoadoutPartViewData
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MenuAddonViewData">();
	}
	static class UMenuAddonViewData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMenuAddonViewData>();
	}
};
static_assert(alignof(UMenuAddonViewData) == 0x000008, "Wrong alignment on UMenuAddonViewData");
static_assert(sizeof(UMenuAddonViewData) == 0x000150, "Wrong size on UMenuAddonViewData");

// Class DBDUIViewInterfaces.MenuClassViewData
// 0x0000 (0x0150 - 0x0150)
class UMenuClassViewData final : public UMenuLoadoutPartViewData
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MenuClassViewData">();
	}
	static class UMenuClassViewData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMenuClassViewData>();
	}
};
static_assert(alignof(UMenuClassViewData) == 0x000008, "Wrong alignment on UMenuClassViewData");
static_assert(sizeof(UMenuClassViewData) == 0x000150, "Wrong size on UMenuClassViewData");

// Class DBDUIViewInterfaces.MenuItemViewData
// 0x0000 (0x0150 - 0x0150)
class UMenuItemViewData final : public UMenuLoadoutPartViewData
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MenuItemViewData">();
	}
	static class UMenuItemViewData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMenuItemViewData>();
	}
};
static_assert(alignof(UMenuItemViewData) == 0x000008, "Wrong alignment on UMenuItemViewData");
static_assert(sizeof(UMenuItemViewData) == 0x000150, "Wrong size on UMenuItemViewData");

// Class DBDUIViewInterfaces.MenuOfferingViewData
// 0x0000 (0x0150 - 0x0150)
class UMenuOfferingViewData final : public UMenuLoadoutPartViewData
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MenuOfferingViewData">();
	}
	static class UMenuOfferingViewData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMenuOfferingViewData>();
	}
};
static_assert(alignof(UMenuOfferingViewData) == 0x000008, "Wrong alignment on UMenuOfferingViewData");
static_assert(sizeof(UMenuOfferingViewData) == 0x000150, "Wrong size on UMenuOfferingViewData");

// Class DBDUIViewInterfaces.MenuPerkViewData
// 0x0060 (0x01B0 - 0x0150)
class UMenuPerkViewData final : public UMenuLoadoutPartViewData
{
public:
	int32                                         Level;                                             // 0x0150(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_154[0x4];                                      // 0x0154(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DisplayName;                                       // 0x0158(0x0018)(Edit, BlueprintVisible, Transient, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0170(0x0018)(Edit, BlueprintVisible, Transient, NativeAccessSpecifierPublic)
	class FText                                   EventName;                                         // 0x0188(0x0018)(Edit, BlueprintVisible, Transient, NativeAccessSpecifierPublic)
	class FString                                 EventID;                                           // 0x01A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MenuPerkViewData">();
	}
	static class UMenuPerkViewData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMenuPerkViewData>();
	}
};
static_assert(alignof(UMenuPerkViewData) == 0x000008, "Wrong alignment on UMenuPerkViewData");
static_assert(sizeof(UMenuPerkViewData) == 0x0001B0, "Wrong size on UMenuPerkViewData");
static_assert(offsetof(UMenuPerkViewData, Level) == 0x000150, "Member 'UMenuPerkViewData::Level' has a wrong offset!");
static_assert(offsetof(UMenuPerkViewData, DisplayName) == 0x000158, "Member 'UMenuPerkViewData::DisplayName' has a wrong offset!");
static_assert(offsetof(UMenuPerkViewData, Description) == 0x000170, "Member 'UMenuPerkViewData::Description' has a wrong offset!");
static_assert(offsetof(UMenuPerkViewData, EventName) == 0x000188, "Member 'UMenuPerkViewData::EventName' has a wrong offset!");
static_assert(offsetof(UMenuPerkViewData, EventID) == 0x0001A0, "Member 'UMenuPerkViewData::EventID' has a wrong offset!");

// Class DBDUIViewInterfaces.MenuPowerViewData
// 0x0050 (0x01A0 - 0x0150)
class UMenuPowerViewData final : public UMenuLoadoutPartViewData
{
public:
	class FText                                   DisplayName;                                       // 0x0150(0x0018)(Edit, BlueprintVisible, Transient, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0168(0x0018)(Edit, BlueprintVisible, Transient, NativeAccessSpecifierPublic)
	class FText                                   EventName;                                         // 0x0180(0x0018)(Edit, BlueprintVisible, Transient, NativeAccessSpecifierPublic)
	EInventoryItemType                            ItemType;                                          // 0x0198(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_199[0x7];                                      // 0x0199(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MenuPowerViewData">();
	}
	static class UMenuPowerViewData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMenuPowerViewData>();
	}
};
static_assert(alignof(UMenuPowerViewData) == 0x000008, "Wrong alignment on UMenuPowerViewData");
static_assert(sizeof(UMenuPowerViewData) == 0x0001A0, "Wrong size on UMenuPowerViewData");
static_assert(offsetof(UMenuPowerViewData, DisplayName) == 0x000150, "Member 'UMenuPowerViewData::DisplayName' has a wrong offset!");
static_assert(offsetof(UMenuPowerViewData, Description) == 0x000168, "Member 'UMenuPowerViewData::Description' has a wrong offset!");
static_assert(offsetof(UMenuPowerViewData, EventName) == 0x000180, "Member 'UMenuPowerViewData::EventName' has a wrong offset!");
static_assert(offsetof(UMenuPowerViewData, ItemType) == 0x000198, "Member 'UMenuPowerViewData::ItemType' has a wrong offset!");

// Class DBDUIViewInterfaces.MenuSkillViewData
// 0x0000 (0x0150 - 0x0150)
class UMenuSkillViewData final : public UMenuLoadoutPartViewData
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MenuSkillViewData">();
	}
	static class UMenuSkillViewData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMenuSkillViewData>();
	}
};
static_assert(alignof(UMenuSkillViewData) == 0x000008, "Wrong alignment on UMenuSkillViewData");
static_assert(sizeof(UMenuSkillViewData) == 0x000150, "Wrong size on UMenuSkillViewData");

// Class DBDUIViewInterfaces.MenuSkinDataAsset
// 0x0128 (0x0160 - 0x0038)
class UMenuSkinDataAsset final : public UDataAsset
{
public:
	class UColorTripleDataAsset*                  MainColor;                                         // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UColorTripleDataAsset*                  ContrastColor;                                     // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UMaterialInstance>       TabMaterialInstance;                               // 0x0048(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UMaterialInstance>       SubTabMaterialInstance;                            // 0x0080(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UMaterialInstance>       TitleBannerMaterial;                               // 0x00B8(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              TitleIcon;                                         // 0x00F0(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UMaterialInstance>       HeaderBackgroundMaterial;                          // 0x0128(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MenuSkinDataAsset">();
	}
	static class UMenuSkinDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMenuSkinDataAsset>();
	}
};
static_assert(alignof(UMenuSkinDataAsset) == 0x000008, "Wrong alignment on UMenuSkinDataAsset");
static_assert(sizeof(UMenuSkinDataAsset) == 0x000160, "Wrong size on UMenuSkinDataAsset");
static_assert(offsetof(UMenuSkinDataAsset, MainColor) == 0x000038, "Member 'UMenuSkinDataAsset::MainColor' has a wrong offset!");
static_assert(offsetof(UMenuSkinDataAsset, ContrastColor) == 0x000040, "Member 'UMenuSkinDataAsset::ContrastColor' has a wrong offset!");
static_assert(offsetof(UMenuSkinDataAsset, TabMaterialInstance) == 0x000048, "Member 'UMenuSkinDataAsset::TabMaterialInstance' has a wrong offset!");
static_assert(offsetof(UMenuSkinDataAsset, SubTabMaterialInstance) == 0x000080, "Member 'UMenuSkinDataAsset::SubTabMaterialInstance' has a wrong offset!");
static_assert(offsetof(UMenuSkinDataAsset, TitleBannerMaterial) == 0x0000B8, "Member 'UMenuSkinDataAsset::TitleBannerMaterial' has a wrong offset!");
static_assert(offsetof(UMenuSkinDataAsset, TitleIcon) == 0x0000F0, "Member 'UMenuSkinDataAsset::TitleIcon' has a wrong offset!");
static_assert(offsetof(UMenuSkinDataAsset, HeaderBackgroundMaterial) == 0x000128, "Member 'UMenuSkinDataAsset::HeaderBackgroundMaterial' has a wrong offset!");

// Class DBDUIViewInterfaces.MultipleDisableStateButtonViewInterface
// 0x0000 (0x0030 - 0x0030)
class IMultipleDisableStateButtonViewInterface final : public IInterface
{
public:
	void SetButtonDisableState(EButtonDisableState buttonDisableState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MultipleDisableStateButtonViewInterface">();
	}
	static class IMultipleDisableStateButtonViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IMultipleDisableStateButtonViewInterface>();
	}
};
static_assert(alignof(IMultipleDisableStateButtonViewInterface) == 0x000008, "Wrong alignment on IMultipleDisableStateButtonViewInterface");
static_assert(sizeof(IMultipleDisableStateButtonViewInterface) == 0x000030, "Wrong size on IMultipleDisableStateButtonViewInterface");

// Class DBDUIViewInterfaces.NewActiveTomePopupViewData
// 0x0000 (0x01F0 - 0x01F0)
class UNewActiveTomePopupViewData final : public UGenericPopupViewData
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NewActiveTomePopupViewData">();
	}
	static class UNewActiveTomePopupViewData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNewActiveTomePopupViewData>();
	}
};
static_assert(alignof(UNewActiveTomePopupViewData) == 0x000010, "Wrong alignment on UNewActiveTomePopupViewData");
static_assert(sizeof(UNewActiveTomePopupViewData) == 0x0001F0, "Wrong size on UNewActiveTomePopupViewData");

// Class DBDUIViewInterfaces.NewActiveTomePopupViewInterface
// 0x0000 (0x0030 - 0x0030)
class INewActiveTomePopupViewInterface final : public IInterface
{
public:
	void SetRemainingTime(const class FString& RemainingTime);
	void SetRiftEnabled(const bool IsEnabled);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NewActiveTomePopupViewInterface">();
	}
	static class INewActiveTomePopupViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<INewActiveTomePopupViewInterface>();
	}
};
static_assert(alignof(INewActiveTomePopupViewInterface) == 0x000008, "Wrong alignment on INewActiveTomePopupViewInterface");
static_assert(sizeof(INewActiveTomePopupViewInterface) == 0x000030, "Wrong size on INewActiveTomePopupViewInterface");

// Class DBDUIViewInterfaces.NewsViewInterface
// 0x0000 (0x0030 - 0x0030)
class INewsViewInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NewsViewInterface">();
	}
	static class INewsViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<INewsViewInterface>();
	}
};
static_assert(alignof(INewsViewInterface) == 0x000008, "Wrong alignment on INewsViewInterface");
static_assert(sizeof(INewsViewInterface) == 0x000030, "Wrong size on INewsViewInterface");

// Class DBDUIViewInterfaces.OfferingInteractionViewInterface
// 0x0000 (0x0030 - 0x0030)
class IOfferingInteractionViewInterface final : public IInterface
{
public:
	void ClearData();
	void SetData(const struct FOfferingViewData& OfferingData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OfferingInteractionViewInterface">();
	}
	static class IOfferingInteractionViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IOfferingInteractionViewInterface>();
	}
};
static_assert(alignof(IOfferingInteractionViewInterface) == 0x000008, "Wrong alignment on IOfferingInteractionViewInterface");
static_assert(sizeof(IOfferingInteractionViewInterface) == 0x000030, "Wrong size on IOfferingInteractionViewInterface");

// Class DBDUIViewInterfaces.OfferingViewInterface
// 0x0000 (0x0030 - 0x0030)
class IOfferingViewInterface final : public IInterface
{
public:
	void ClearData();
	void SetData(const struct FOfferingViewData& OfferingViewData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OfferingViewInterface">();
	}
	static class IOfferingViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IOfferingViewInterface>();
	}
};
static_assert(alignof(IOfferingViewInterface) == 0x000008, "Wrong alignment on IOfferingViewInterface");
static_assert(sizeof(IOfferingViewInterface) == 0x000030, "Wrong size on IOfferingViewInterface");

// Class DBDUIViewInterfaces.OnboardingMenuViewInterface
// 0x0000 (0x0030 - 0x0030)
class IOnboardingMenuViewInterface final : public IInterface
{
public:
	void SetBackButtonVisible(bool Visible);
	void SetChangeAccountInputSwitcherPlayerNickname(const class FString& PlayerNickname);
	void SetChangeAccountInputSwitcherVisible(bool Visible);
	void SetFirstTimeUserExperience(bool Ftue);
	void SetOnboardingMenuState(EOnboardingMenuState MenuState);
	void SetQuitGameButtonVisible(bool Visible);
	void SetUIEnabled(bool Enabled);

	TScriptInterface<class IGameManualViewInterface> GetGameManualInterface() const;
	TScriptInterface<class IOnboardingTutorialViewInterface> GetOnboardingTutorialInterface() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnboardingMenuViewInterface">();
	}
	static class IOnboardingMenuViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IOnboardingMenuViewInterface>();
	}
};
static_assert(alignof(IOnboardingMenuViewInterface) == 0x000008, "Wrong alignment on IOnboardingMenuViewInterface");
static_assert(sizeof(IOnboardingMenuViewInterface) == 0x000030, "Wrong size on IOnboardingMenuViewInterface");

// Class DBDUIViewInterfaces.OnboardingTutorialViewInterface
// 0x0000 (0x0030 - 0x0030)
class IOnboardingTutorialViewInterface final : public IInterface
{
public:
	void SetCanShowGoToMainMenuTutorialButton(bool CanShowGoToMainMenuTutorialButton);
	void SetIsKillSwitch(bool IsKillSwitch);
	void SetProgress(const TArray<struct FOnboardingStepViewData>& Progress);
	void SetTutorialProgressionFeedbacks(const class FString& CompletedStepId, const bool IsOnboardingEnabled);
	void SetUIEnabled(bool Enabled);
	void StopLoadingSpinner();
	void UpdateProgress(const TArray<struct FOnboardingStepViewData>& before, const TArray<struct FOnboardingStepViewData>& After, const TArray<struct FRewardWrapperViewData>& Rewards);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnboardingTutorialViewInterface">();
	}
	static class IOnboardingTutorialViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IOnboardingTutorialViewInterface>();
	}
};
static_assert(alignof(IOnboardingTutorialViewInterface) == 0x000008, "Wrong alignment on IOnboardingTutorialViewInterface");
static_assert(sizeof(IOnboardingTutorialViewInterface) == 0x000030, "Wrong size on IOnboardingTutorialViewInterface");

// Class DBDUIViewInterfaces.PerkViewInterface
// 0x0000 (0x0030 - 0x0030)
class IPerkViewInterface final : public IInterface
{
public:
	void ClearData();
	void SetData(const struct FPerkViewData& PerkViewData);
	void TriggerRandomSuccess(const struct FPerkRandomSuccessViewData& RandomSuccessViewData);
	void UpdatePerkCooldown(float CooldownValue, bool IsRechargeable, bool IsRechargeableActive);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PerkViewInterface">();
	}
	static class IPerkViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPerkViewInterface>();
	}
};
static_assert(alignof(IPerkViewInterface) == 0x000008, "Wrong alignment on IPerkViewInterface");
static_assert(sizeof(IPerkViewInterface) == 0x000030, "Wrong size on IPerkViewInterface");

// Class DBDUIViewInterfaces.PingStatusViewInterface
// 0x0000 (0x0030 - 0x0030)
class IPingStatusViewInterface final : public IInterface
{
public:
	void InitPingStatus(const int32 NumberOfSurvivors);
	void SetKillerConnectionQualityStatus(const EConnectionQuality& KillerConnectionQuality);
	void SetLocalPacketLossStatus(const EConnectionQuality& LocalPacketLoss);
	void SetLocalPingStatus(const EConnectionQuality& LocalPing);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PingStatusViewInterface">();
	}
	static class IPingStatusViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPingStatusViewInterface>();
	}
};
static_assert(alignof(IPingStatusViewInterface) == 0x000008, "Wrong alignment on IPingStatusViewInterface");
static_assert(sizeof(IPingStatusViewInterface) == 0x000030, "Wrong size on IPingStatusViewInterface");

// Class DBDUIViewInterfaces.PlayerCardAnimationViewInterface
// 0x0000 (0x0030 - 0x0030)
class IPlayerCardAnimationViewInterface final : public IInterface
{
public:
	void OnPlayAnimation();
	void OnStopAnimation();
	void SetRetainerBoxMaterial(const TSoftObjectPtr<class UTexture2D>& bannerTexture);
	void SetRetainerBoxOpacity(const float Opacity);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerCardAnimationViewInterface">();
	}
	static class IPlayerCardAnimationViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPlayerCardAnimationViewInterface>();
	}
};
static_assert(alignof(IPlayerCardAnimationViewInterface) == 0x000008, "Wrong alignment on IPlayerCardAnimationViewInterface");
static_assert(sizeof(IPlayerCardAnimationViewInterface) == 0x000030, "Wrong size on IPlayerCardAnimationViewInterface");

// Class DBDUIViewInterfaces.PlayerCardViewInterface
// 0x0000 (0x0030 - 0x0030)
class IPlayerCardViewInterface final : public IInterface
{
public:
	void SetData(const struct FPlayerCardViewData& PlayerCardData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerCardViewInterface">();
	}
	static class IPlayerCardViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPlayerCardViewInterface>();
	}
};
static_assert(alignof(IPlayerCardViewInterface) == 0x000008, "Wrong alignment on IPlayerCardViewInterface");
static_assert(sizeof(IPlayerCardViewInterface) == 0x000030, "Wrong size on IPlayerCardViewInterface");

// Class DBDUIViewInterfaces.PlayerProfileViewInterface
// 0x0000 (0x0030 - 0x0030)
class IPlayerProfileViewInterface final : public IInterface
{
public:
	void FullUpdateCurrency(const struct FCurrencyLabelViewData& ViewData);
	void HidePlayerCard();
	void HidePlayerName();
	void HideUI();
	void SetPlayerCard(const struct FPlayerCardViewData& Badge, const struct FPlayerCardViewData& Banner);
	void SetPlayerCardAnimationMode(const EPlayerCardAnimationMode PlayerCardAnimationMode);
	void SetPlayerCardBannerOpacity(float Opacity);
	void SetPlayerName(const class FText& PlayerNameText);
	void SetPlayerProfileEnabled(bool IsEnabled);
	void SetWalletData(const TArray<struct FCurrencyLabelViewData>& WalletData);
	void SetWalletVisibility(const bool IsVisible);
	void ShowPlayerCard();
	void ShowUI();
	void UpdatePlayerCardButton(const bool IsProfileMenuContextEntered);
	void UpdatePlayerProfileOpacity(const bool IsFocused);
	void UpdateWallet(const ECurrencyType Type, int32 NewBalance, int32 PreviousBalance);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerProfileViewInterface">();
	}
	static class IPlayerProfileViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPlayerProfileViewInterface>();
	}
};
static_assert(alignof(IPlayerProfileViewInterface) == 0x000008, "Wrong alignment on IPlayerProfileViewInterface");
static_assert(sizeof(IPlayerProfileViewInterface) == 0x000030, "Wrong size on IPlayerProfileViewInterface");

// Class DBDUIViewInterfaces.PlayerStatusesContainerViewInterface
// 0x0000 (0x0030 - 0x0030)
class IPlayerStatusesContainerViewInterface final : public IInterface
{
public:
	TScriptInterface<class IPlayerStatusViewInterface> GetPlayerStatusInterface(int32 Param_Index);
	void SetPlayerStatusesCount(const int32 TotalCount);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerStatusesContainerViewInterface">();
	}
	static class IPlayerStatusesContainerViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPlayerStatusesContainerViewInterface>();
	}
};
static_assert(alignof(IPlayerStatusesContainerViewInterface) == 0x000008, "Wrong alignment on IPlayerStatusesContainerViewInterface");
static_assert(sizeof(IPlayerStatusesContainerViewInterface) == 0x000030, "Wrong size on IPlayerStatusesContainerViewInterface");

// Class DBDUIViewInterfaces.DoctorStatusData
// 0x0008 (0x0038 - 0x0030)
class UDoctorStatusData final : public UKillerStatusData
{
public:
	EAfflictionLevel                              AfflictionLevel;                                   // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DoctorStatusData">();
	}
	static class UDoctorStatusData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDoctorStatusData>();
	}
};
static_assert(alignof(UDoctorStatusData) == 0x000008, "Wrong alignment on UDoctorStatusData");
static_assert(sizeof(UDoctorStatusData) == 0x000038, "Wrong size on UDoctorStatusData");
static_assert(offsetof(UDoctorStatusData, AfflictionLevel) == 0x000030, "Member 'UDoctorStatusData::AfflictionLevel' has a wrong offset!");

// Class DBDUIViewInterfaces.ExecutionerStatusData
// 0x0008 (0x0038 - 0x0030)
class UExecutionerStatusData final : public UKillerStatusData
{
public:
	float                                         AgonyProgress;                                     // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExecutionerStatusData">();
	}
	static class UExecutionerStatusData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UExecutionerStatusData>();
	}
};
static_assert(alignof(UExecutionerStatusData) == 0x000008, "Wrong alignment on UExecutionerStatusData");
static_assert(sizeof(UExecutionerStatusData) == 0x000038, "Wrong size on UExecutionerStatusData");
static_assert(offsetof(UExecutionerStatusData, AgonyProgress) == 0x000030, "Member 'UExecutionerStatusData::AgonyProgress' has a wrong offset!");

// Class DBDUIViewInterfaces.GhostfaceStatusData
// 0x0008 (0x0038 - 0x0030)
class UGhostfaceStatusData final : public UKillerStatusData
{
public:
	bool                                          IsExposed;                                         // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StalkingProgress;                                  // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GhostfaceStatusData">();
	}
	static class UGhostfaceStatusData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGhostfaceStatusData>();
	}
};
static_assert(alignof(UGhostfaceStatusData) == 0x000008, "Wrong alignment on UGhostfaceStatusData");
static_assert(sizeof(UGhostfaceStatusData) == 0x000038, "Wrong size on UGhostfaceStatusData");
static_assert(offsetof(UGhostfaceStatusData, IsExposed) == 0x000030, "Member 'UGhostfaceStatusData::IsExposed' has a wrong offset!");
static_assert(offsetof(UGhostfaceStatusData, StalkingProgress) == 0x000034, "Member 'UGhostfaceStatusData::StalkingProgress' has a wrong offset!");

// Class DBDUIViewInterfaces.PigStatusData
// 0x0008 (0x0038 - 0x0030)
class UPigStatusData final : public UKillerStatusData
{
public:
	EReverseBearTrapUIState                       ReverseBearTrapState;                              // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimerProgress;                                     // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PigStatusData">();
	}
	static class UPigStatusData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPigStatusData>();
	}
};
static_assert(alignof(UPigStatusData) == 0x000008, "Wrong alignment on UPigStatusData");
static_assert(sizeof(UPigStatusData) == 0x000038, "Wrong size on UPigStatusData");
static_assert(offsetof(UPigStatusData, ReverseBearTrapState) == 0x000030, "Member 'UPigStatusData::ReverseBearTrapState' has a wrong offset!");
static_assert(offsetof(UPigStatusData, TimerProgress) == 0x000034, "Member 'UPigStatusData::TimerProgress' has a wrong offset!");

// Class DBDUIViewInterfaces.PlagueStatusData
// 0x0008 (0x0038 - 0x0030)
class UPlagueStatusData final : public UKillerStatusData
{
public:
	ESicknessLevel                                SicknessLevel;                                     // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SicknessProgress;                                  // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlagueStatusData">();
	}
	static class UPlagueStatusData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlagueStatusData>();
	}
};
static_assert(alignof(UPlagueStatusData) == 0x000008, "Wrong alignment on UPlagueStatusData");
static_assert(sizeof(UPlagueStatusData) == 0x000038, "Wrong size on UPlagueStatusData");
static_assert(offsetof(UPlagueStatusData, SicknessLevel) == 0x000030, "Member 'UPlagueStatusData::SicknessLevel' has a wrong offset!");
static_assert(offsetof(UPlagueStatusData, SicknessProgress) == 0x000034, "Member 'UPlagueStatusData::SicknessProgress' has a wrong offset!");

// Class DBDUIViewInterfaces.TricksterStatusData
// 0x0010 (0x0040 - 0x0030)
class UTricksterStatusData final : public UKillerStatusData
{
public:
	float                                         CurrentLacerationLevel;                            // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaximumLacerationLevel;                            // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsDangerousLacerationLevel;                        // 0x0038(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          WasRecentlyDamagedByLaceration;                    // 0x0039(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x6];                                       // 0x003A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TricksterStatusData">();
	}
	static class UTricksterStatusData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTricksterStatusData>();
	}
};
static_assert(alignof(UTricksterStatusData) == 0x000008, "Wrong alignment on UTricksterStatusData");
static_assert(sizeof(UTricksterStatusData) == 0x000040, "Wrong size on UTricksterStatusData");
static_assert(offsetof(UTricksterStatusData, CurrentLacerationLevel) == 0x000030, "Member 'UTricksterStatusData::CurrentLacerationLevel' has a wrong offset!");
static_assert(offsetof(UTricksterStatusData, MaximumLacerationLevel) == 0x000034, "Member 'UTricksterStatusData::MaximumLacerationLevel' has a wrong offset!");
static_assert(offsetof(UTricksterStatusData, IsDangerousLacerationLevel) == 0x000038, "Member 'UTricksterStatusData::IsDangerousLacerationLevel' has a wrong offset!");
static_assert(offsetof(UTricksterStatusData, WasRecentlyDamagedByLaceration) == 0x000039, "Member 'UTricksterStatusData::WasRecentlyDamagedByLaceration' has a wrong offset!");

// Class DBDUIViewInterfaces.K25StatusData
// 0x0008 (0x0038 - 0x0030)
class UK25StatusData final : public UKillerStatusData
{
public:
	float                                         ChainHuntProgressPercentage;                       // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsHoldingLamentConfiguration;                      // 0x0034(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsSolvingLamentConfiguration;                      // 0x0035(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_36[0x2];                                       // 0x0036(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K25StatusData">();
	}
	static class UK25StatusData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK25StatusData>();
	}
};
static_assert(alignof(UK25StatusData) == 0x000008, "Wrong alignment on UK25StatusData");
static_assert(sizeof(UK25StatusData) == 0x000038, "Wrong size on UK25StatusData");
static_assert(offsetof(UK25StatusData, ChainHuntProgressPercentage) == 0x000030, "Member 'UK25StatusData::ChainHuntProgressPercentage' has a wrong offset!");
static_assert(offsetof(UK25StatusData, IsHoldingLamentConfiguration) == 0x000034, "Member 'UK25StatusData::IsHoldingLamentConfiguration' has a wrong offset!");
static_assert(offsetof(UK25StatusData, IsSolvingLamentConfiguration) == 0x000035, "Member 'UK25StatusData::IsSolvingLamentConfiguration' has a wrong offset!");

// Class DBDUIViewInterfaces.TheOnryoStatusData
// 0x0010 (0x0040 - 0x0030)
class UTheOnryoStatusData final : public UKillerStatusData
{
public:
	bool                                          IsCondemnedActive;                                 // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CondemnedProgress;                                 // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LockedProgress;                                    // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsFullCondemned;                                   // 0x003C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsHoldingTape;                                     // 0x003D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E[0x2];                                       // 0x003E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TheOnryoStatusData">();
	}
	static class UTheOnryoStatusData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTheOnryoStatusData>();
	}
};
static_assert(alignof(UTheOnryoStatusData) == 0x000008, "Wrong alignment on UTheOnryoStatusData");
static_assert(sizeof(UTheOnryoStatusData) == 0x000040, "Wrong size on UTheOnryoStatusData");
static_assert(offsetof(UTheOnryoStatusData, IsCondemnedActive) == 0x000030, "Member 'UTheOnryoStatusData::IsCondemnedActive' has a wrong offset!");
static_assert(offsetof(UTheOnryoStatusData, CondemnedProgress) == 0x000034, "Member 'UTheOnryoStatusData::CondemnedProgress' has a wrong offset!");
static_assert(offsetof(UTheOnryoStatusData, LockedProgress) == 0x000038, "Member 'UTheOnryoStatusData::LockedProgress' has a wrong offset!");
static_assert(offsetof(UTheOnryoStatusData, IsFullCondemned) == 0x00003C, "Member 'UTheOnryoStatusData::IsFullCondemned' has a wrong offset!");
static_assert(offsetof(UTheOnryoStatusData, IsHoldingTape) == 0x00003D, "Member 'UTheOnryoStatusData::IsHoldingTape' has a wrong offset!");

// Class DBDUIViewInterfaces.K29StatusData
// 0x0008 (0x0038 - 0x0030)
class UK29StatusData final : public UKillerStatusData
{
public:
	float                                         InfectionPercentage;                               // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsInfected;                                        // 0x0034(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsInfectionActive;                                 // 0x0035(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsInfectionCritical;                               // 0x0036(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_37[0x1];                                       // 0x0037(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K29StatusData">();
	}
	static class UK29StatusData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK29StatusData>();
	}
};
static_assert(alignof(UK29StatusData) == 0x000008, "Wrong alignment on UK29StatusData");
static_assert(sizeof(UK29StatusData) == 0x000038, "Wrong size on UK29StatusData");
static_assert(offsetof(UK29StatusData, InfectionPercentage) == 0x000030, "Member 'UK29StatusData::InfectionPercentage' has a wrong offset!");
static_assert(offsetof(UK29StatusData, IsInfected) == 0x000034, "Member 'UK29StatusData::IsInfected' has a wrong offset!");
static_assert(offsetof(UK29StatusData, IsInfectionActive) == 0x000035, "Member 'UK29StatusData::IsInfectionActive' has a wrong offset!");
static_assert(offsetof(UK29StatusData, IsInfectionCritical) == 0x000036, "Member 'UK29StatusData::IsInfectionCritical' has a wrong offset!");

// Class DBDUIViewInterfaces.K31StatusData
// 0x0008 (0x0038 - 0x0030)
class UK31StatusData final : public UKillerStatusData
{
public:
	float                                         EffectProgressPercentage;                          // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsClawTrapped;                                     // 0x0034(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K31StatusData">();
	}
	static class UK31StatusData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK31StatusData>();
	}
};
static_assert(alignof(UK31StatusData) == 0x000008, "Wrong alignment on UK31StatusData");
static_assert(sizeof(UK31StatusData) == 0x000038, "Wrong size on UK31StatusData");
static_assert(offsetof(UK31StatusData, EffectProgressPercentage) == 0x000030, "Member 'UK31StatusData::EffectProgressPercentage' has a wrong offset!");
static_assert(offsetof(UK31StatusData, IsClawTrapped) == 0x000034, "Member 'UK31StatusData::IsClawTrapped' has a wrong offset!");

// Class DBDUIViewInterfaces.K35StatusData
// 0x0008 (0x0038 - 0x0030)
class UK35StatusData final : public UKillerStatusData
{
public:
	bool                                          IsAfflictedWithKillerEffect;                       // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsRemovingKillerEffect;                            // 0x0031(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x2];                                       // 0x0032(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         KillerEffectRemovalProgress;                       // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K35StatusData">();
	}
	static class UK35StatusData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK35StatusData>();
	}
};
static_assert(alignof(UK35StatusData) == 0x000008, "Wrong alignment on UK35StatusData");
static_assert(sizeof(UK35StatusData) == 0x000038, "Wrong size on UK35StatusData");
static_assert(offsetof(UK35StatusData, IsAfflictedWithKillerEffect) == 0x000030, "Member 'UK35StatusData::IsAfflictedWithKillerEffect' has a wrong offset!");
static_assert(offsetof(UK35StatusData, IsRemovingKillerEffect) == 0x000031, "Member 'UK35StatusData::IsRemovingKillerEffect' has a wrong offset!");
static_assert(offsetof(UK35StatusData, KillerEffectRemovalProgress) == 0x000034, "Member 'UK35StatusData::KillerEffectRemovalProgress' has a wrong offset!");

// Class DBDUIViewInterfaces.PlayerStatusViewInterface
// 0x0000 (0x0030 - 0x0030)
class IPlayerStatusViewInterface final : public IInterface
{
public:
	void ClearData();
	void DimObsessionAndChaseClaws(const bool DisableLeftClaw, const bool DisableRightClaw);
	void EnableChasesMode(const bool IsChased);
	void HideSurvivorActivity();
	void PlayHookEscapeFailedAnimation();
	void PlayTimerAnimation();
	void SetCampProgress(float Value, bool IsLocalPlayerAKiller);
	void SetData(const struct FPlayerStatusViewData& Data);
	void SetKiller(const struct FGameplayTag& KillerTag);
	void SetPlayerNameVisibility(bool Visible);
	void SetTimerProgress(float Value, bool IsDeepWound);
	void ShowSurvivorActivity(const TSoftObjectPtr<class UTexture2D>& ActivityIcon, const bool ShouldDisplayProgress);
	void TriggerAfflictionHit();
	void UpdateSurvivorActivityProgress(const float Progress);
	void UpdateSurvivorSpecificPingIcon(const EConnectionQuality& ConnectionQuality);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerStatusViewInterface">();
	}
	static class IPlayerStatusViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPlayerStatusViewInterface>();
	}
};
static_assert(alignof(IPlayerStatusViewInterface) == 0x000008, "Wrong alignment on IPlayerStatusViewInterface");
static_assert(sizeof(IPlayerStatusViewInterface) == 0x000030, "Wrong size on IPlayerStatusViewInterface");

// Class DBDUIViewInterfaces.PowerViewInterface
// 0x0000 (0x0030 - 0x0030)
class IPowerViewInterface final : public IInterface
{
public:
	void ClearData();
	void SetData(const struct FPowerViewData& PowerViewData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PowerViewInterface">();
	}
	static class IPowerViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPowerViewInterface>();
	}
};
static_assert(alignof(IPowerViewInterface) == 0x000008, "Wrong alignment on IPowerViewInterface");
static_assert(sizeof(IPowerViewInterface) == 0x000030, "Wrong size on IPowerViewInterface");

// Class DBDUIViewInterfaces.ProcessingPopupViewInterface
// 0x0000 (0x0030 - 0x0030)
class IProcessingPopupViewInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProcessingPopupViewInterface">();
	}
	static class IProcessingPopupViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IProcessingPopupViewInterface>();
	}
};
static_assert(alignof(IProcessingPopupViewInterface) == 0x000008, "Wrong alignment on IProcessingPopupViewInterface");
static_assert(sizeof(IProcessingPopupViewInterface) == 0x000030, "Wrong size on IProcessingPopupViewInterface");

// Class DBDUIViewInterfaces.ProfileMenuStatsViewInterface
// 0x0000 (0x0030 - 0x0030)
class IProfileMenuStatsViewInterface final : public IInterface
{
public:
	void SetPlayerLevel(const struct FPlayerLevelViewData& ViewData);
	void SetPlayerRanks(const struct FRankViewData& SurvivorViewData, const struct FRankViewData& KillerViewData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProfileMenuStatsViewInterface">();
	}
	static class IProfileMenuStatsViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IProfileMenuStatsViewInterface>();
	}
};
static_assert(alignof(IProfileMenuStatsViewInterface) == 0x000008, "Wrong alignment on IProfileMenuStatsViewInterface");
static_assert(sizeof(IProfileMenuStatsViewInterface) == 0x000030, "Wrong size on IProfileMenuStatsViewInterface");

// Class DBDUIViewInterfaces.ProfileMenuViewInterface
// 0x0000 (0x0030 - 0x0030)
class IProfileMenuViewInterface final : public IInterface
{
public:
	void SetIsFocused(const bool IsFocused);
	void SetMenuState(EProfileMenuState MenuState);
	void SetSubtitle(const class FText& Subtitle);
	void SetTabEnabled(int32 Key, bool Enabled);
	void SetTabsData(const TArray<struct FTabWidgetData>& TabsData, int32 SelectedKey);
	void SetTabSelected(int32 Key);
	void SetTitle(const class FText& Title);

	TScriptInterface<class IProfileMenuCustomizationViewInterface> GetProfileMenuBadgeInterface() const;
	TScriptInterface<class IProfileMenuCustomizationViewInterface> GetProfileMenuBannerInterface() const;
	TScriptInterface<class IProfileMenuStatsViewInterface> GetProfileMenuStatsInterface() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProfileMenuViewInterface">();
	}
	static class IProfileMenuViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IProfileMenuViewInterface>();
	}
};
static_assert(alignof(IProfileMenuViewInterface) == 0x000008, "Wrong alignment on IProfileMenuViewInterface");
static_assert(sizeof(IProfileMenuViewInterface) == 0x000030, "Wrong size on IProfileMenuViewInterface");

// Class DBDUIViewInterfaces.ProgressionSystemInfoPopupViewData
// 0x0000 (0x01F0 - 0x01F0)
class UProgressionSystemInfoPopupViewData final : public UGenericPopupViewData
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProgressionSystemInfoPopupViewData">();
	}
	static class UProgressionSystemInfoPopupViewData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProgressionSystemInfoPopupViewData>();
	}
};
static_assert(alignof(UProgressionSystemInfoPopupViewData) == 0x000010, "Wrong alignment on UProgressionSystemInfoPopupViewData");
static_assert(sizeof(UProgressionSystemInfoPopupViewData) == 0x0001F0, "Wrong size on UProgressionSystemInfoPopupViewData");

// Class DBDUIViewInterfaces.ProgressionSystemInfoPopupViewInterface
// 0x0000 (0x0030 - 0x0030)
class IProgressionSystemInfoPopupViewInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProgressionSystemInfoPopupViewInterface">();
	}
	static class IProgressionSystemInfoPopupViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IProgressionSystemInfoPopupViewInterface>();
	}
};
static_assert(alignof(IProgressionSystemInfoPopupViewInterface) == 0x000008, "Wrong alignment on IProgressionSystemInfoPopupViewInterface");
static_assert(sizeof(IProgressionSystemInfoPopupViewInterface) == 0x000030, "Wrong size on IProgressionSystemInfoPopupViewInterface");

// Class DBDUIViewInterfaces.ReportFeedbackPopupViewData
// 0x0010 (0x0200 - 0x01F0)
class UReportFeedbackPopupViewData final : public UGenericPopupViewData
{
public:
	uint8                                         Pad_1F0[0x10];                                     // 0x01F0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReportFeedbackPopupViewData">();
	}
	static class UReportFeedbackPopupViewData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReportFeedbackPopupViewData>();
	}
};
static_assert(alignof(UReportFeedbackPopupViewData) == 0x000010, "Wrong alignment on UReportFeedbackPopupViewData");
static_assert(sizeof(UReportFeedbackPopupViewData) == 0x000200, "Wrong size on UReportFeedbackPopupViewData");

// Class DBDUIViewInterfaces.AuricCellBundleRewardPopupViewData
// 0x0098 (0x00F0 - 0x0058)
class UAuricCellBundleRewardPopupViewData final : public UGrantedRewardPopupViewData
{
public:
	struct FAuricCellsBundleViewData              AuricCellsBundleViewData;                          // 0x0058(0x0098)(Edit, BlueprintVisible, BlueprintReadOnly, Transient, EditConst, ExposeOnSpawn, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AuricCellBundleRewardPopupViewData">();
	}
	static class UAuricCellBundleRewardPopupViewData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAuricCellBundleRewardPopupViewData>();
	}
};
static_assert(alignof(UAuricCellBundleRewardPopupViewData) == 0x000008, "Wrong alignment on UAuricCellBundleRewardPopupViewData");
static_assert(sizeof(UAuricCellBundleRewardPopupViewData) == 0x0000F0, "Wrong size on UAuricCellBundleRewardPopupViewData");
static_assert(offsetof(UAuricCellBundleRewardPopupViewData, AuricCellsBundleViewData) == 0x000058, "Member 'UAuricCellBundleRewardPopupViewData::AuricCellsBundleViewData' has a wrong offset!");

// Class DBDUIViewInterfaces.RewardWrapperRewardPopupViewData
// 0x0528 (0x0580 - 0x0058)
class URewardWrapperRewardPopupViewData final : public UGrantedRewardPopupViewData
{
public:
	struct FRewardWrapperViewData                 WrappedViewData;                                   // 0x0058(0x0528)(BlueprintVisible, BlueprintReadOnly, Transient, ExposeOnSpawn, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RewardWrapperRewardPopupViewData">();
	}
	static class URewardWrapperRewardPopupViewData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URewardWrapperRewardPopupViewData>();
	}
};
static_assert(alignof(URewardWrapperRewardPopupViewData) == 0x000008, "Wrong alignment on URewardWrapperRewardPopupViewData");
static_assert(sizeof(URewardWrapperRewardPopupViewData) == 0x000580, "Wrong size on URewardWrapperRewardPopupViewData");
static_assert(offsetof(URewardWrapperRewardPopupViewData, WrappedViewData) == 0x000058, "Member 'URewardWrapperRewardPopupViewData::WrappedViewData' has a wrong offset!");

// Class DBDUIViewInterfaces.RewardPopupViewData
// 0x0020 (0x0210 - 0x01F0)
class URewardPopupViewData final : public UGenericPopupViewData
{
public:
	class FName                                   RewardId;                                          // 0x01F0(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FC[0x4];                                      // 0x01FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UGrantedRewardPopupViewData*>    Rewards;                                           // 0x0200(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RewardPopupViewData">();
	}
	static class URewardPopupViewData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URewardPopupViewData>();
	}
};
static_assert(alignof(URewardPopupViewData) == 0x000010, "Wrong alignment on URewardPopupViewData");
static_assert(sizeof(URewardPopupViewData) == 0x000210, "Wrong size on URewardPopupViewData");
static_assert(offsetof(URewardPopupViewData, RewardId) == 0x0001F0, "Member 'URewardPopupViewData::RewardId' has a wrong offset!");
static_assert(offsetof(URewardPopupViewData, Rewards) == 0x000200, "Member 'URewardPopupViewData::Rewards' has a wrong offset!");

// Class DBDUIViewInterfaces.ScaleformTooltipViewInterface
// 0x0000 (0x0030 - 0x0030)
class IScaleformTooltipViewInterface final : public IInterface
{
public:
	void OnLoadoutTooltipHovered(const struct FTooltipTriggerGeometry& TriggeredGeometry, const struct FLoadoutTooltipData& TooltipData);
	void OnTooltipTargetUnhovered();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScaleformTooltipViewInterface">();
	}
	static class IScaleformTooltipViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IScaleformTooltipViewInterface>();
	}
};
static_assert(alignof(IScaleformTooltipViewInterface) == 0x000008, "Wrong alignment on IScaleformTooltipViewInterface");
static_assert(sizeof(IScaleformTooltipViewInterface) == 0x000030, "Wrong size on IScaleformTooltipViewInterface");

// Class DBDUIViewInterfaces.SearchBarViewInterface
// 0x0000 (0x0030 - 0x0030)
class ISearchBarViewInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SearchBarViewInterface">();
	}
	static class ISearchBarViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ISearchBarViewInterface>();
	}
};
static_assert(alignof(ISearchBarViewInterface) == 0x000008, "Wrong alignment on ISearchBarViewInterface");
static_assert(sizeof(ISearchBarViewInterface) == 0x000030, "Wrong size on ISearchBarViewInterface");

// Class DBDUIViewInterfaces.SeasonEndRankRewardsPopupViewInterface
// 0x0000 (0x0030 - 0x0030)
class ISeasonEndRankRewardsPopupViewInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SeasonEndRankRewardsPopupViewInterface">();
	}
	static class ISeasonEndRankRewardsPopupViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ISeasonEndRankRewardsPopupViewInterface>();
	}
};
static_assert(alignof(ISeasonEndRankRewardsPopupViewInterface) == 0x000008, "Wrong alignment on ISeasonEndRankRewardsPopupViewInterface");
static_assert(sizeof(ISeasonEndRankRewardsPopupViewInterface) == 0x000030, "Wrong size on ISeasonEndRankRewardsPopupViewInterface");

// Class DBDUIViewInterfaces.SettingsViewInterface
// 0x0000 (0x0030 - 0x0030)
class ISettingsViewInterface final : public IInterface
{
public:
	void SetMenuState(EOverlayTabs State);

	TScriptInterface<class ISettingsMatchDetailsViewInterface> GetSettingsMatchDetailsInterface() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SettingsViewInterface">();
	}
	static class ISettingsViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ISettingsViewInterface>();
	}
};
static_assert(alignof(ISettingsViewInterface) == 0x000008, "Wrong alignment on ISettingsViewInterface");
static_assert(sizeof(ISettingsViewInterface) == 0x000030, "Wrong size on ISettingsViewInterface");

// Class DBDUIViewInterfaces.SkillCheckViewInterface
// 0x0000 (0x0030 - 0x0030)
class ISkillCheckViewInterface final : public IInterface
{
public:
	void ApplyScaleFactor(float Scale);
	void HideSkillCheck();
	void ShowSkillCheck(const struct FSkillCheckViewData& SkillCheckData);
	void ShowSkillCheckFail();
	void ShowSkillCheckSuccess(bool IsBonus);
	void UpdatePositionOffset(int32 X, int32 Y);
	void UpdateProgress(float Value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SkillCheckViewInterface">();
	}
	static class ISkillCheckViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ISkillCheckViewInterface>();
	}
};
static_assert(alignof(ISkillCheckViewInterface) == 0x000008, "Wrong alignment on ISkillCheckViewInterface");
static_assert(sizeof(ISkillCheckViewInterface) == 0x000030, "Wrong size on ISkillCheckViewInterface");

// Class DBDUIViewInterfaces.SkillViewInterface
// 0x0000 (0x0030 - 0x0030)
class ISkillViewInterface final : public IInterface
{
public:
	void ClearData();
	void SetData(const struct FSkillViewData& SkillViewData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SkillViewInterface">();
	}
	static class ISkillViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ISkillViewInterface>();
	}
};
static_assert(alignof(ISkillViewInterface) == 0x000008, "Wrong alignment on ISkillViewInterface");
static_assert(sizeof(ISkillViewInterface) == 0x000030, "Wrong size on ISkillViewInterface");

// Class DBDUIViewInterfaces.StartSequenceViewInterface
// 0x0000 (0x0030 - 0x0030)
class IStartSequenceViewInterface final : public IInterface
{
public:
	void HideStartSequence();
	void ShowStartSequence(const struct FStartSequenceViewData& Data);

	bool GetIsStartSequenceVisible() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StartSequenceViewInterface">();
	}
	static class IStartSequenceViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IStartSequenceViewInterface>();
	}
};
static_assert(alignof(IStartSequenceViewInterface) == 0x000008, "Wrong alignment on IStartSequenceViewInterface");
static_assert(sizeof(IStartSequenceViewInterface) == 0x000030, "Wrong size on IStartSequenceViewInterface");

// Class DBDUIViewInterfaces.StoreBaseSubTabsViewInterface
// 0x0000 (0x0030 - 0x0030)
class IStoreBaseSubTabsViewInterface final : public IInterface
{
public:
	void ActivateSubTabContent(const int32 State);
	void HideSubTab(const int32 SubTabId);
	bool IsSubTabVisible(const int32 SubTabId);
	void SelectSubTab(const int32 SelectedKey);
	void SetSubTabsData(const TArray<struct FTabWidgetData>& TabsData);
	void ShowSubTab(const int32 SubTabId);
	void UnselectCurrentTab();
	void UpdateTabData(const int32 SubTabId, const struct FTabWidgetData& TabWidgetData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StoreBaseSubTabsViewInterface">();
	}
	static class IStoreBaseSubTabsViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IStoreBaseSubTabsViewInterface>();
	}
};
static_assert(alignof(IStoreBaseSubTabsViewInterface) == 0x000008, "Wrong alignment on IStoreBaseSubTabsViewInterface");
static_assert(sizeof(IStoreBaseSubTabsViewInterface) == 0x000030, "Wrong size on IStoreBaseSubTabsViewInterface");

// Class DBDUIViewInterfaces.StoreCharactersBioViewInterface
// 0x0000 (0x0030 - 0x0030)
class IStoreCharactersBioViewInterface final : public IInterface
{
public:
	void SetData(const struct FCharacterBioViewData& CharacterBioViewData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StoreCharactersBioViewInterface">();
	}
	static class IStoreCharactersBioViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IStoreCharactersBioViewInterface>();
	}
};
static_assert(alignof(IStoreCharactersBioViewInterface) == 0x000008, "Wrong alignment on IStoreCharactersBioViewInterface");
static_assert(sizeof(IStoreCharactersBioViewInterface) == 0x000030, "Wrong size on IStoreCharactersBioViewInterface");

// Class DBDUIViewInterfaces.StoreCharactersFilterViewInterface
// 0x0000 (0x0030 - 0x0030)
class IStoreCharactersFilterViewInterface final : public IInterface
{
public:
	void SetFiltersState(const struct FStoreCharactersFiltersData& NewFiltersData);
	void SetFiltersVisibility(bool ShowAvailabilityFilter, bool ShowRarityFilters, bool ShowClearFiltersButton);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StoreCharactersFilterViewInterface">();
	}
	static class IStoreCharactersFilterViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IStoreCharactersFilterViewInterface>();
	}
};
static_assert(alignof(IStoreCharactersFilterViewInterface) == 0x000008, "Wrong alignment on IStoreCharactersFilterViewInterface");
static_assert(sizeof(IStoreCharactersFilterViewInterface) == 0x000030, "Wrong size on IStoreCharactersFilterViewInterface");

// Class DBDUIViewInterfaces.StoreCharactersViewInterface
// 0x0000 (0x0030 - 0x0030)
class IStoreCharactersViewInterface final : public IInterface
{
public:
	void SetCharacterData(const class FText& CharacterName);
	void SetCharacterNameVisibility(const bool ShowCharacterName);

	TScriptInterface<class IStoreCharactersBioViewInterface> GetStoreCharactersBioInterface() const;
	TScriptInterface<class IStoreCharactersCustomizationsViewInterface> GetStoreCharactersCustomizationsInterface() const;
	TScriptInterface<class IStoreCharactersSelectionViewInterface> GetStoreCharactersSelectionInterface() const;
	TScriptInterface<class IStoreRightStickControllableViewInterface> GetStoreRightStickControllableViewInterface() const;
	TScriptInterface<class IWardrobeActionButtonsViewInterface> GetWardrobeActionButtonsViewInterface() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StoreCharactersViewInterface">();
	}
	static class IStoreCharactersViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IStoreCharactersViewInterface>();
	}
};
static_assert(alignof(IStoreCharactersViewInterface) == 0x000008, "Wrong alignment on IStoreCharactersViewInterface");
static_assert(sizeof(IStoreCharactersViewInterface) == 0x000030, "Wrong size on IStoreCharactersViewInterface");

// Class DBDUIViewInterfaces.StoreCollectionsCustomizationsViewInterface
// 0x0000 (0x0030 - 0x0030)
class IStoreCollectionsCustomizationsViewInterface final : public IInterface
{
public:
	TScriptInterface<class IStoreCharactersCustomizationsViewInterface> GetStoreCharactersSelectionInterface() const;
	TScriptInterface<class IStoreRightStickControllableViewInterface> GetStoreRightStickControllableViewInterface() const;
	TScriptInterface<class IWardrobeActionButtonsViewInterface> GetWardrobeActionButtonsViewInterface() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StoreCollectionsCustomizationsViewInterface">();
	}
	static class IStoreCollectionsCustomizationsViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IStoreCollectionsCustomizationsViewInterface>();
	}
};
static_assert(alignof(IStoreCollectionsCustomizationsViewInterface) == 0x000008, "Wrong alignment on IStoreCollectionsCustomizationsViewInterface");
static_assert(sizeof(IStoreCollectionsCustomizationsViewInterface) == 0x000030, "Wrong size on IStoreCollectionsCustomizationsViewInterface");

// Class DBDUIViewInterfaces.StoreCollectionsListViewInterface
// 0x0000 (0x0030 - 0x0030)
class IStoreCollectionsListViewInterface final : public IInterface
{
public:
	TScriptInterface<class ISearchBarViewInterface> GetSearchBarViewInterface() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StoreCollectionsListViewInterface">();
	}
	static class IStoreCollectionsListViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IStoreCollectionsListViewInterface>();
	}
};
static_assert(alignof(IStoreCollectionsListViewInterface) == 0x000008, "Wrong alignment on IStoreCollectionsListViewInterface");
static_assert(sizeof(IStoreCollectionsListViewInterface) == 0x000030, "Wrong size on IStoreCollectionsListViewInterface");

// Class DBDUIViewInterfaces.StoreCollectionViewData
// 0x0188 (0x01B8 - 0x0030)
class UStoreCollectionViewData final : public UObject
{
public:
	class FString                                 CollectionId;                                      // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DisplayTitle;                                      // 0x0040(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DisplaySubtitle;                                   // 0x0050(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              LimitedAvailabilityStartDate;                      // 0x0060(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          VisibleBeforeStartDate;                            // 0x0068(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              LimitedAvailabilityEndDate;                        // 0x0070(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          VisibleAfterEndDate;                               // 0x0078(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x3];                                       // 0x0079(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SortOrder;                                         // 0x007C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftRemoteContentCacheObjectPtr       HeroImage;                                         // 0x0080(0x0070)(BlueprintVisible, BlueprintReadOnly, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UFileMediaSource>        HeroVideo;                                         // 0x00F0(0x0038)(BlueprintVisible, BlueprintReadOnly, Transient, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSoftRemoteContentCacheObjectPtr> AdditionalImages;                                  // 0x0128(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	bool                                          IsNew;                                             // 0x0138(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_139[0x7];                                      // 0x0139(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UStoreCustomizationItemViewData*> Items;                                             // 0x0140(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	int32                                         AvailableItemsCount;                               // 0x0150(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OwnedItemsCount;                                   // 0x0154(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimerFlagViewData                     DiscountTimerViewData;                             // 0x0158(0x0030)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPublic)
	struct FTimerFlagViewData                     AvailabilityTimerViewData;                         // 0x0188(0x0030)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPublic)

public:
	bool HasHeroImage() const;
	bool HasHeroVideo() const;
	bool IsCollectionActive() const;
	bool IsCollectionHidden() const;
	bool IsSpecial() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StoreCollectionViewData">();
	}
	static class UStoreCollectionViewData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStoreCollectionViewData>();
	}
};
static_assert(alignof(UStoreCollectionViewData) == 0x000008, "Wrong alignment on UStoreCollectionViewData");
static_assert(sizeof(UStoreCollectionViewData) == 0x0001B8, "Wrong size on UStoreCollectionViewData");
static_assert(offsetof(UStoreCollectionViewData, CollectionId) == 0x000030, "Member 'UStoreCollectionViewData::CollectionId' has a wrong offset!");
static_assert(offsetof(UStoreCollectionViewData, DisplayTitle) == 0x000040, "Member 'UStoreCollectionViewData::DisplayTitle' has a wrong offset!");
static_assert(offsetof(UStoreCollectionViewData, DisplaySubtitle) == 0x000050, "Member 'UStoreCollectionViewData::DisplaySubtitle' has a wrong offset!");
static_assert(offsetof(UStoreCollectionViewData, LimitedAvailabilityStartDate) == 0x000060, "Member 'UStoreCollectionViewData::LimitedAvailabilityStartDate' has a wrong offset!");
static_assert(offsetof(UStoreCollectionViewData, VisibleBeforeStartDate) == 0x000068, "Member 'UStoreCollectionViewData::VisibleBeforeStartDate' has a wrong offset!");
static_assert(offsetof(UStoreCollectionViewData, LimitedAvailabilityEndDate) == 0x000070, "Member 'UStoreCollectionViewData::LimitedAvailabilityEndDate' has a wrong offset!");
static_assert(offsetof(UStoreCollectionViewData, VisibleAfterEndDate) == 0x000078, "Member 'UStoreCollectionViewData::VisibleAfterEndDate' has a wrong offset!");
static_assert(offsetof(UStoreCollectionViewData, SortOrder) == 0x00007C, "Member 'UStoreCollectionViewData::SortOrder' has a wrong offset!");
static_assert(offsetof(UStoreCollectionViewData, HeroImage) == 0x000080, "Member 'UStoreCollectionViewData::HeroImage' has a wrong offset!");
static_assert(offsetof(UStoreCollectionViewData, HeroVideo) == 0x0000F0, "Member 'UStoreCollectionViewData::HeroVideo' has a wrong offset!");
static_assert(offsetof(UStoreCollectionViewData, AdditionalImages) == 0x000128, "Member 'UStoreCollectionViewData::AdditionalImages' has a wrong offset!");
static_assert(offsetof(UStoreCollectionViewData, IsNew) == 0x000138, "Member 'UStoreCollectionViewData::IsNew' has a wrong offset!");
static_assert(offsetof(UStoreCollectionViewData, Items) == 0x000140, "Member 'UStoreCollectionViewData::Items' has a wrong offset!");
static_assert(offsetof(UStoreCollectionViewData, AvailableItemsCount) == 0x000150, "Member 'UStoreCollectionViewData::AvailableItemsCount' has a wrong offset!");
static_assert(offsetof(UStoreCollectionViewData, OwnedItemsCount) == 0x000154, "Member 'UStoreCollectionViewData::OwnedItemsCount' has a wrong offset!");
static_assert(offsetof(UStoreCollectionViewData, DiscountTimerViewData) == 0x000158, "Member 'UStoreCollectionViewData::DiscountTimerViewData' has a wrong offset!");
static_assert(offsetof(UStoreCollectionViewData, AvailabilityTimerViewData) == 0x000188, "Member 'UStoreCollectionViewData::AvailabilityTimerViewData' has a wrong offset!");

// Class DBDUIViewInterfaces.StoreCustomizationItemViewData
// 0x02D0 (0x0478 - 0x01A8)
class UStoreCustomizationItemViewData final : public UStoreItemViewData
{
public:
	struct FCustomizationRewardViewData           CustomizationReward;                               // 0x01A8(0x0210)(BlueprintVisible, Transient, ExposeOnSpawn, NativeAccessSpecifierPublic)
	class FName                                   MirrorsId;                                         // 0x03B8(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C4[0x4];                                      // 0x03C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   RarityInfoText;                                    // 0x03C8(0x0018)(BlueprintVisible, BlueprintReadOnly, Transient, ExposeOnSpawn, NativeAccessSpecifierPublic)
	bool                                          IsLocked;                                          // 0x03E0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsUsingSmallTemplate;                              // 0x03E1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerRole                                   AssociatedRole;                                    // 0x03E2(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E3[0x5];                                      // 0x03E3(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              ReleaseDate;                                       // 0x03E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FOutfitInfoViewData                    OutfitInfo;                                        // 0x03F0(0x0048)(BlueprintVisible, BlueprintReadOnly, Transient, ExposeOnSpawn, NativeAccessSpecifierPublic)
	class FText                                   AssociatedCharacterDisplayName;                    // 0x0438(0x0018)(BlueprintVisible, BlueprintReadOnly, Transient, ExposeOnSpawn, NativeAccessSpecifierPublic)
	class FName                                   AssociatedCharacterName;                           // 0x0450(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45C[0x4];                                      // 0x045C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   CategoryInfoText;                                  // 0x0460(0x0018)(BlueprintVisible, BlueprintReadOnly, Transient, ExposeOnSpawn, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StoreCustomizationItemViewData">();
	}
	static class UStoreCustomizationItemViewData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStoreCustomizationItemViewData>();
	}
};
static_assert(alignof(UStoreCustomizationItemViewData) == 0x000008, "Wrong alignment on UStoreCustomizationItemViewData");
static_assert(sizeof(UStoreCustomizationItemViewData) == 0x000478, "Wrong size on UStoreCustomizationItemViewData");
static_assert(offsetof(UStoreCustomizationItemViewData, CustomizationReward) == 0x0001A8, "Member 'UStoreCustomizationItemViewData::CustomizationReward' has a wrong offset!");
static_assert(offsetof(UStoreCustomizationItemViewData, MirrorsId) == 0x0003B8, "Member 'UStoreCustomizationItemViewData::MirrorsId' has a wrong offset!");
static_assert(offsetof(UStoreCustomizationItemViewData, RarityInfoText) == 0x0003C8, "Member 'UStoreCustomizationItemViewData::RarityInfoText' has a wrong offset!");
static_assert(offsetof(UStoreCustomizationItemViewData, IsLocked) == 0x0003E0, "Member 'UStoreCustomizationItemViewData::IsLocked' has a wrong offset!");
static_assert(offsetof(UStoreCustomizationItemViewData, IsUsingSmallTemplate) == 0x0003E1, "Member 'UStoreCustomizationItemViewData::IsUsingSmallTemplate' has a wrong offset!");
static_assert(offsetof(UStoreCustomizationItemViewData, AssociatedRole) == 0x0003E2, "Member 'UStoreCustomizationItemViewData::AssociatedRole' has a wrong offset!");
static_assert(offsetof(UStoreCustomizationItemViewData, ReleaseDate) == 0x0003E8, "Member 'UStoreCustomizationItemViewData::ReleaseDate' has a wrong offset!");
static_assert(offsetof(UStoreCustomizationItemViewData, OutfitInfo) == 0x0003F0, "Member 'UStoreCustomizationItemViewData::OutfitInfo' has a wrong offset!");
static_assert(offsetof(UStoreCustomizationItemViewData, AssociatedCharacterDisplayName) == 0x000438, "Member 'UStoreCustomizationItemViewData::AssociatedCharacterDisplayName' has a wrong offset!");
static_assert(offsetof(UStoreCustomizationItemViewData, AssociatedCharacterName) == 0x000450, "Member 'UStoreCustomizationItemViewData::AssociatedCharacterName' has a wrong offset!");
static_assert(offsetof(UStoreCustomizationItemViewData, CategoryInfoText) == 0x000460, "Member 'UStoreCustomizationItemViewData::CategoryInfoText' has a wrong offset!");

// Class DBDUIViewInterfaces.StoreFeaturedViewInterface
// 0x0000 (0x0030 - 0x0030)
class IStoreFeaturedViewInterface final : public IInterface
{
public:
	void InitFeaturedChapterPack(class UStoreChapterPackViewData* ViewData);
	void InitFeaturedCharacters(const TArray<class UStoreCharacterItemViewData*>& CharacterViewDataArray);
	void InitFeaturedCrossPromotion(const struct FCrossPromoCampaignViewData& ViewData);
	void InitFeaturedCustomizationItems(const TArray<class UStoreCustomizationItemViewData*>& ViewDataArray);
	void InitFeaturedSpecialPack(class UStoreSpecialPackViewData* ViewData);
	void InitMysteryBox(const struct FStoreMysteryBoxViewData& MysteryBoxViewData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StoreFeaturedViewInterface">();
	}
	static class IStoreFeaturedViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IStoreFeaturedViewInterface>();
	}
};
static_assert(alignof(IStoreFeaturedViewInterface) == 0x000008, "Wrong alignment on IStoreFeaturedViewInterface");
static_assert(sizeof(IStoreFeaturedViewInterface) == 0x000030, "Wrong size on IStoreFeaturedViewInterface");

// Class DBDUIViewInterfaces.StoreMenuViewInterface
// 0x0000 (0x0030 - 0x0030)
class IStoreMenuViewInterface final : public IInterface
{
public:
	void HandlePageStateUpdate();
	void SetBackButtonLabel(const class FText& Label);
	void SetMenuState(EStoreMenuState State);
	void SetTabEnabled(int32 Key, bool Enabled);
	void SetTabsData(const TArray<struct FTabWidgetData>& TabsData, int32 SelectedKey);
	void SetTabSelected(int32 Key);

	TScriptInterface<class IDisplayStandViewInterface> GetDisplayStandViewInterface() const;
	TScriptInterface<class IStoreCollectionsViewInterface> GetStoreCollectionsInterface() const;
	TScriptInterface<class IStoreFeaturedViewInterface> GetStoreFeaturedInterface() const;
	TScriptInterface<class IStoreCharactersViewInterface> GetStoreKillersInterface() const;
	TScriptInterface<class IStoreSpecialPacksViewInterface> GetStoreSpecialPacksInterface() const;
	TScriptInterface<class IStoreSpecialsViewInterface> GetStoreSpecialsInterface() const;
	TScriptInterface<class IStoreCharactersViewInterface> GetStoreSurvivorsInterface() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StoreMenuViewInterface">();
	}
	static class IStoreMenuViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IStoreMenuViewInterface>();
	}
};
static_assert(alignof(IStoreMenuViewInterface) == 0x000008, "Wrong alignment on IStoreMenuViewInterface");
static_assert(sizeof(IStoreMenuViewInterface) == 0x000030, "Wrong size on IStoreMenuViewInterface");

// Class DBDUIViewInterfaces.MysteryBoxPreviousReward
// 0x0008 (0x0038 - 0x0030)
class UMysteryBoxPreviousReward : public UObject
{
public:
	ERewardType                                   Type;                                              // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MysteryBoxPreviousReward">();
	}
	static class UMysteryBoxPreviousReward* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMysteryBoxPreviousReward>();
	}
};
static_assert(alignof(UMysteryBoxPreviousReward) == 0x000008, "Wrong alignment on UMysteryBoxPreviousReward");
static_assert(sizeof(UMysteryBoxPreviousReward) == 0x000038, "Wrong size on UMysteryBoxPreviousReward");
static_assert(offsetof(UMysteryBoxPreviousReward, Type) == 0x000030, "Member 'UMysteryBoxPreviousReward::Type' has a wrong offset!");

// Class DBDUIViewInterfaces.MysteryBoxPreviousCurrencyReward
// 0x0008 (0x0040 - 0x0038)
class UMysteryBoxPreviousCurrencyReward final : public UMysteryBoxPreviousReward
{
public:
	ECurrencyType                                 Currency;                                          // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Amount;                                            // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MysteryBoxPreviousCurrencyReward">();
	}
	static class UMysteryBoxPreviousCurrencyReward* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMysteryBoxPreviousCurrencyReward>();
	}
};
static_assert(alignof(UMysteryBoxPreviousCurrencyReward) == 0x000008, "Wrong alignment on UMysteryBoxPreviousCurrencyReward");
static_assert(sizeof(UMysteryBoxPreviousCurrencyReward) == 0x000040, "Wrong size on UMysteryBoxPreviousCurrencyReward");
static_assert(offsetof(UMysteryBoxPreviousCurrencyReward, Currency) == 0x000038, "Member 'UMysteryBoxPreviousCurrencyReward::Currency' has a wrong offset!");
static_assert(offsetof(UMysteryBoxPreviousCurrencyReward, Amount) == 0x00003C, "Member 'UMysteryBoxPreviousCurrencyReward::Amount' has a wrong offset!");

// Class DBDUIViewInterfaces.MysteryBoxPreviousProgressionReward
// 0x0008 (0x0040 - 0x0038)
class UMysteryBoxPreviousProgressionReward final : public UMysteryBoxPreviousReward
{
public:
	EProgressionType                              Progression;                                       // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Amount;                                            // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MysteryBoxPreviousProgressionReward">();
	}
	static class UMysteryBoxPreviousProgressionReward* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMysteryBoxPreviousProgressionReward>();
	}
};
static_assert(alignof(UMysteryBoxPreviousProgressionReward) == 0x000008, "Wrong alignment on UMysteryBoxPreviousProgressionReward");
static_assert(sizeof(UMysteryBoxPreviousProgressionReward) == 0x000040, "Wrong size on UMysteryBoxPreviousProgressionReward");
static_assert(offsetof(UMysteryBoxPreviousProgressionReward, Progression) == 0x000038, "Member 'UMysteryBoxPreviousProgressionReward::Progression' has a wrong offset!");
static_assert(offsetof(UMysteryBoxPreviousProgressionReward, Amount) == 0x00003C, "Member 'UMysteryBoxPreviousProgressionReward::Amount' has a wrong offset!");

// Class DBDUIViewInterfaces.StorePackContentData
// 0x02C8 (0x02F8 - 0x0030)
class UStorePackContentData final : public UObject
{
public:
	class UStoreCharacterItemViewData*            CharacterViewData;                                 // 0x0030(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStoreCustomizationItemViewData*        CustomizationViewData;                             // 0x0038(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStoreArchivePassViewData              ArchivePassViewData;                               // 0x0040(0x0158)(Transient, NativeAccessSpecifierPublic)
	struct FStoreArchiveFragmentViewData          ArchiveFragmentViewData;                           // 0x0198(0x0158)(Transient, NativeAccessSpecifierPublic)
	bool                                          HasPriority;                                       // 0x02F0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F1[0x7];                                      // 0x02F1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	TSoftObjectPtr<class UTexture2D> GetIconTexturePtr();

	class FName GetId() const;
	EPlayerRole GetPlayerRole() const;
	ERewardType GetRewardType() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StorePackContentData">();
	}
	static class UStorePackContentData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStorePackContentData>();
	}
};
static_assert(alignof(UStorePackContentData) == 0x000008, "Wrong alignment on UStorePackContentData");
static_assert(sizeof(UStorePackContentData) == 0x0002F8, "Wrong size on UStorePackContentData");
static_assert(offsetof(UStorePackContentData, CharacterViewData) == 0x000030, "Member 'UStorePackContentData::CharacterViewData' has a wrong offset!");
static_assert(offsetof(UStorePackContentData, CustomizationViewData) == 0x000038, "Member 'UStorePackContentData::CustomizationViewData' has a wrong offset!");
static_assert(offsetof(UStorePackContentData, ArchivePassViewData) == 0x000040, "Member 'UStorePackContentData::ArchivePassViewData' has a wrong offset!");
static_assert(offsetof(UStorePackContentData, ArchiveFragmentViewData) == 0x000198, "Member 'UStorePackContentData::ArchiveFragmentViewData' has a wrong offset!");
static_assert(offsetof(UStorePackContentData, HasPriority) == 0x0002F0, "Member 'UStorePackContentData::HasPriority' has a wrong offset!");

// Class DBDUIViewInterfaces.StoreRightStickControllableViewInterface
// 0x0000 (0x0030 - 0x0030)
class IStoreRightStickControllableViewInterface final : public IInterface
{
public:
	ERightStickMode ToggleRightStickMode();
	void UpdateScrollPrompt();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StoreRightStickControllableViewInterface">();
	}
	static class IStoreRightStickControllableViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IStoreRightStickControllableViewInterface>();
	}
};
static_assert(alignof(IStoreRightStickControllableViewInterface) == 0x000008, "Wrong alignment on IStoreRightStickControllableViewInterface");
static_assert(sizeof(IStoreRightStickControllableViewInterface) == 0x000030, "Wrong size on IStoreRightStickControllableViewInterface");

// Class DBDUIViewInterfaces.StoreSpecialPacksDetailsViewInterface
// 0x0000 (0x0030 - 0x0030)
class IStoreSpecialPacksDetailsViewInterface final : public IInterface
{
public:
	void OnEnter();
	void OnLeave();
	void SetChapterPackData(class UStoreChapterPackViewData* Data);
	void SetSpecialPackData(class UStoreSpecialPackViewData* Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StoreSpecialPacksDetailsViewInterface">();
	}
	static class IStoreSpecialPacksDetailsViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IStoreSpecialPacksDetailsViewInterface>();
	}
};
static_assert(alignof(IStoreSpecialPacksDetailsViewInterface) == 0x000008, "Wrong alignment on IStoreSpecialPacksDetailsViewInterface");
static_assert(sizeof(IStoreSpecialPacksDetailsViewInterface) == 0x000030, "Wrong size on IStoreSpecialPacksDetailsViewInterface");

// Class DBDUIViewInterfaces.StoreSpecialPacksListViewInterface
// 0x0000 (0x0030 - 0x0030)
class IStoreSpecialPacksListViewInterface final : public IInterface
{
public:
	void SetChapterPacksData(const TArray<class UStoreChapterPackViewData*>& Data);
	void SetHeritagePacksData(const TArray<struct FStoreHeritagePackViewData>& Data);
	void SetSpecialPacksData(const TArray<class UStoreSpecialPackViewData*>& Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StoreSpecialPacksListViewInterface">();
	}
	static class IStoreSpecialPacksListViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IStoreSpecialPacksListViewInterface>();
	}
};
static_assert(alignof(IStoreSpecialPacksListViewInterface) == 0x000008, "Wrong alignment on IStoreSpecialPacksListViewInterface");
static_assert(sizeof(IStoreSpecialPacksListViewInterface) == 0x000030, "Wrong size on IStoreSpecialPacksListViewInterface");

// Class DBDUIViewInterfaces.StoreSpecialPacksViewInterface
// 0x0000 (0x0030 - 0x0030)
class IStoreSpecialPacksViewInterface final : public IInterface
{
public:
	bool IsAnimating();
	void SetScreenState(EStoreSpecialPacksScreenState State, bool ShouldAnimate);

	TScriptInterface<class IStoreSpecialPacksDetailsViewInterface> GetDetailsInterface() const;
	TScriptInterface<class IStoreRightStickControllableViewInterface> GetStoreRightStickControllableViewInterface() const;
	TScriptInterface<class IStoreSpecialPacksListViewInterface> GetTabChaptersInterface() const;
	TScriptInterface<class IStoreSpecialPacksListViewInterface> GetTabHeritageInterface() const;
	TScriptInterface<class IStoreSpecialPacksListViewInterface> GetTabSpecialsInterface() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StoreSpecialPacksViewInterface">();
	}
	static class IStoreSpecialPacksViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IStoreSpecialPacksViewInterface>();
	}
};
static_assert(alignof(IStoreSpecialPacksViewInterface) == 0x000008, "Wrong alignment on IStoreSpecialPacksViewInterface");
static_assert(sizeof(IStoreSpecialPacksViewInterface) == 0x000030, "Wrong size on IStoreSpecialPacksViewInterface");

// Class DBDUIViewInterfaces.StoreSpecialPackViewData
// 0x0410 (0x0440 - 0x0030)
class UStoreSpecialPackViewData final : public UObject
{
public:
	class FString                                 ID;                                                // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DisplayTitle;                                      // 0x0040(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftRemoteContentCacheObjectPtr       PackImage;                                         // 0x0050(0x0070)(BlueprintVisible, BlueprintReadOnly, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPriceTagViewData                      PriceTagData;                                      // 0x00C0(0x0050)(BlueprintVisible, Transient, ExposeOnSpawn, NativeAccessSpecifierPublic)
	TArray<class UStorePackContentData*>          SortedContent;                                     // 0x0110(0x0010)(BlueprintVisible, ZeroConstructor, Transient, ExposeOnSpawn, NativeAccessSpecifierPublic)
	TArray<class UStoreCharacterItemViewData*>    CharactersData;                                    // 0x0120(0x0010)(BlueprintVisible, ZeroConstructor, Transient, ExposeOnSpawn, NativeAccessSpecifierPublic)
	TArray<class UStoreCustomizationItemViewData*> CustomizationsData;                                // 0x0130(0x0010)(BlueprintVisible, ZeroConstructor, Transient, ExposeOnSpawn, NativeAccessSpecifierPublic)
	struct FStoreArchivePassViewData              ArchivePassData;                                   // 0x0140(0x0158)(BlueprintVisible, Transient, ExposeOnSpawn, NativeAccessSpecifierPublic)
	struct FStoreArchiveFragmentViewData          ArchiveFragmentData;                               // 0x0298(0x0158)(BlueprintVisible, Transient, ExposeOnSpawn, NativeAccessSpecifierPublic)
	struct FTimerFlagViewData                     TimerViewData;                                     // 0x03F0(0x0030)(BlueprintVisible, Transient, ExposeOnSpawn, NativeAccessSpecifierPublic)
	struct FDateTime                              ActivationStartDate;                               // 0x0420(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              ActivationEndDate;                                 // 0x0428(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SortOrder;                                         // 0x0430(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsNew;                                             // 0x0434(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsOwned;                                           // 0x0435(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseCompositionForPackImage;                        // 0x0436(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_437[0x1];                                      // 0x0437(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PackImageCompositionNumberOfItems;                 // 0x0438(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_43C[0x4];                                      // 0x043C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool ContainsArchivePass() const;
	bool ContainsArchivePassFragments() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StoreSpecialPackViewData">();
	}
	static class UStoreSpecialPackViewData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStoreSpecialPackViewData>();
	}
};
static_assert(alignof(UStoreSpecialPackViewData) == 0x000008, "Wrong alignment on UStoreSpecialPackViewData");
static_assert(sizeof(UStoreSpecialPackViewData) == 0x000440, "Wrong size on UStoreSpecialPackViewData");
static_assert(offsetof(UStoreSpecialPackViewData, ID) == 0x000030, "Member 'UStoreSpecialPackViewData::ID' has a wrong offset!");
static_assert(offsetof(UStoreSpecialPackViewData, DisplayTitle) == 0x000040, "Member 'UStoreSpecialPackViewData::DisplayTitle' has a wrong offset!");
static_assert(offsetof(UStoreSpecialPackViewData, PackImage) == 0x000050, "Member 'UStoreSpecialPackViewData::PackImage' has a wrong offset!");
static_assert(offsetof(UStoreSpecialPackViewData, PriceTagData) == 0x0000C0, "Member 'UStoreSpecialPackViewData::PriceTagData' has a wrong offset!");
static_assert(offsetof(UStoreSpecialPackViewData, SortedContent) == 0x000110, "Member 'UStoreSpecialPackViewData::SortedContent' has a wrong offset!");
static_assert(offsetof(UStoreSpecialPackViewData, CharactersData) == 0x000120, "Member 'UStoreSpecialPackViewData::CharactersData' has a wrong offset!");
static_assert(offsetof(UStoreSpecialPackViewData, CustomizationsData) == 0x000130, "Member 'UStoreSpecialPackViewData::CustomizationsData' has a wrong offset!");
static_assert(offsetof(UStoreSpecialPackViewData, ArchivePassData) == 0x000140, "Member 'UStoreSpecialPackViewData::ArchivePassData' has a wrong offset!");
static_assert(offsetof(UStoreSpecialPackViewData, ArchiveFragmentData) == 0x000298, "Member 'UStoreSpecialPackViewData::ArchiveFragmentData' has a wrong offset!");
static_assert(offsetof(UStoreSpecialPackViewData, TimerViewData) == 0x0003F0, "Member 'UStoreSpecialPackViewData::TimerViewData' has a wrong offset!");
static_assert(offsetof(UStoreSpecialPackViewData, ActivationStartDate) == 0x000420, "Member 'UStoreSpecialPackViewData::ActivationStartDate' has a wrong offset!");
static_assert(offsetof(UStoreSpecialPackViewData, ActivationEndDate) == 0x000428, "Member 'UStoreSpecialPackViewData::ActivationEndDate' has a wrong offset!");
static_assert(offsetof(UStoreSpecialPackViewData, SortOrder) == 0x000430, "Member 'UStoreSpecialPackViewData::SortOrder' has a wrong offset!");
static_assert(offsetof(UStoreSpecialPackViewData, IsNew) == 0x000434, "Member 'UStoreSpecialPackViewData::IsNew' has a wrong offset!");
static_assert(offsetof(UStoreSpecialPackViewData, IsOwned) == 0x000435, "Member 'UStoreSpecialPackViewData::IsOwned' has a wrong offset!");
static_assert(offsetof(UStoreSpecialPackViewData, UseCompositionForPackImage) == 0x000436, "Member 'UStoreSpecialPackViewData::UseCompositionForPackImage' has a wrong offset!");
static_assert(offsetof(UStoreSpecialPackViewData, PackImageCompositionNumberOfItems) == 0x000438, "Member 'UStoreSpecialPackViewData::PackImageCompositionNumberOfItems' has a wrong offset!");

// Class DBDUIViewInterfaces.StoreSpecialsViewInterface
// 0x0000 (0x0030 - 0x0030)
class IStoreSpecialsViewInterface final : public IInterface
{
public:
	void HideAuricCellsSpecialOffer();
	void SetAuricCellsSpecialOfferData(const struct FAuricCellsBundleViewData& AuricCellsSpecialOfferData, const struct FAuricCellsFirstPurchaseViewData& AuricCellsFirstPurchaseViewData);
	void SetSpecialsData(const TArray<class UStoreCustomizationItemViewData*>& SpecialsData, const struct FStoreArchivePassViewData& ArchivePassViewData);

	TScriptInterface<class IStoreRightStickControllableViewInterface> GetStoreRightStickControllableViewInterface() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StoreSpecialsViewInterface">();
	}
	static class IStoreSpecialsViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IStoreSpecialsViewInterface>();
	}
};
static_assert(alignof(IStoreSpecialsViewInterface) == 0x000008, "Wrong alignment on IStoreSpecialsViewInterface");
static_assert(sizeof(IStoreSpecialsViewInterface) == 0x000030, "Wrong size on IStoreSpecialsViewInterface");

// Class DBDUIViewInterfaces.StoreUnlockConfirmationPopupViewData
// 0x0050 (0x0240 - 0x01F0)
class UStoreUnlockConfirmationPopupViewData final : public UGenericPopupViewData
{
public:
	struct FPriceTagViewData                      PriceTagData;                                      // 0x01F0(0x0050)(BlueprintVisible, Transient, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StoreUnlockConfirmationPopupViewData">();
	}
	static class UStoreUnlockConfirmationPopupViewData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStoreUnlockConfirmationPopupViewData>();
	}
};
static_assert(alignof(UStoreUnlockConfirmationPopupViewData) == 0x000010, "Wrong alignment on UStoreUnlockConfirmationPopupViewData");
static_assert(sizeof(UStoreUnlockConfirmationPopupViewData) == 0x000240, "Wrong size on UStoreUnlockConfirmationPopupViewData");
static_assert(offsetof(UStoreUnlockConfirmationPopupViewData, PriceTagData) == 0x0001F0, "Member 'UStoreUnlockConfirmationPopupViewData::PriceTagData' has a wrong offset!");

// Class DBDUIViewInterfaces.StoreUnlockConfirmationPopupViewInterface
// 0x0000 (0x0030 - 0x0030)
class IStoreUnlockConfirmationPopupViewInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StoreUnlockConfirmationPopupViewInterface">();
	}
	static class IStoreUnlockConfirmationPopupViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IStoreUnlockConfirmationPopupViewInterface>();
	}
};
static_assert(alignof(IStoreUnlockConfirmationPopupViewInterface) == 0x000008, "Wrong alignment on IStoreUnlockConfirmationPopupViewInterface");
static_assert(sizeof(IStoreUnlockConfirmationPopupViewInterface) == 0x000030, "Wrong size on IStoreUnlockConfirmationPopupViewInterface");

// Class DBDUIViewInterfaces.SubtitlesViewInterface
// 0x0000 (0x0030 - 0x0030)
class ISubtitlesViewInterface final : public IInterface
{
public:
	void HideSubtitles();
	void SetConstrainAspectRatioChanged(bool IsConstrained, float AspectRatio);
	void SetSubtitlesBackgroundOpacity(ESubtitlesBackgroundOpacity Opacity);
	void SetSubtitlesPosition(ESubtitlesPosition Position);
	void SetSubtitlesSize(ESubtitlesSize Size);
	void ShowSubtitle(const class FText& SubtitleText);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SubtitlesViewInterface">();
	}
	static class ISubtitlesViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ISubtitlesViewInterface>();
	}
};
static_assert(alignof(ISubtitlesViewInterface) == 0x000008, "Wrong alignment on ISubtitlesViewInterface");
static_assert(sizeof(ISubtitlesViewInterface) == 0x000030, "Wrong size on ISubtitlesViewInterface");

// Class DBDUIViewInterfaces.TallyMenuViewInterface
// 0x0000 (0x0030 - 0x0030)
class ITallyMenuViewInterface final : public IInterface
{
public:
	void SetBackgroundVisibility(bool IsVisible);
	void SetTabSelected(const ETallyTabState& TabState);

	TScriptInterface<class ITallyScoreboardViewInterface> GetTallyScoreboardInterface() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TallyMenuViewInterface">();
	}
	static class ITallyMenuViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ITallyMenuViewInterface>();
	}
};
static_assert(alignof(ITallyMenuViewInterface) == 0x000008, "Wrong alignment on ITallyMenuViewInterface");
static_assert(sizeof(ITallyMenuViewInterface) == 0x000030, "Wrong size on ITallyMenuViewInterface");

// Class DBDUIViewInterfaces.TallyScoreboardViewInterface
// 0x0000 (0x0030 - 0x0030)
class ITallyScoreboardViewInterface final : public IInterface
{
public:
	void SetKillerLoadoutBlocked(const bool IsBlocked);
	void SetPlayerCardAnimationMode(const EPlayerCardAnimationMode PlayerCardAnimationMode);
	void SetTallyPlayerStatusWidgets(const EGameType GameType);
	void SetTallyScoreboardData(const TArray<struct FTallyPlayerStatusViewData>& TallyPlayerStatus, EGameType GameType, bool IsUsingCharacterClass);
	void ShowOptionsMenu(const TArray<struct FPlayerSocialOptionViewData>& PlayerOptionsData);
	void UpdateReportedPlayer(const class FString& MirrorsId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TallyScoreboardViewInterface">();
	}
	static class ITallyScoreboardViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ITallyScoreboardViewInterface>();
	}
};
static_assert(alignof(ITallyScoreboardViewInterface) == 0x000008, "Wrong alignment on ITallyScoreboardViewInterface");
static_assert(sizeof(ITallyScoreboardViewInterface) == 0x000030, "Wrong size on ITallyScoreboardViewInterface");

// Class DBDUIViewInterfaces.TemplateViewInterface
// 0x0000 (0x0030 - 0x0030)
class ITemplateViewInterface final : public IInterface
{
public:
	void TemplateExampleFunction(const struct FTemplateViewData& TemplateData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TemplateViewInterface">();
	}
	static class ITemplateViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ITemplateViewInterface>();
	}
};
static_assert(alignof(ITemplateViewInterface) == 0x000008, "Wrong alignment on ITemplateViewInterface");
static_assert(sizeof(ITemplateViewInterface) == 0x000030, "Wrong size on ITemplateViewInterface");

// Class DBDUIViewInterfaces.TestBuildFlagViewInterface
// 0x0000 (0x0030 - 0x0030)
class ITestBuildFlagViewInterface final : public IInterface
{
public:
	void UpdateWidget(ETestBuildType TestBuildType, ETestBuildFlagPosition TestBuildFlagPosition);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TestBuildFlagViewInterface">();
	}
	static class ITestBuildFlagViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ITestBuildFlagViewInterface>();
	}
};
static_assert(alignof(ITestBuildFlagViewInterface) == 0x000008, "Wrong alignment on ITestBuildFlagViewInterface");
static_assert(sizeof(ITestBuildFlagViewInterface) == 0x000030, "Wrong size on ITestBuildFlagViewInterface");

// Class DBDUIViewInterfaces.ToastNotificationContainerViewInterface
// 0x0000 (0x0030 - 0x0030)
class IToastNotificationContainerViewInterface final : public IInterface
{
public:
	void AddToastNotification(const struct FToastNotificationViewData& ToastData);
	void RemoveToastNotification(const int32 NotificationId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ToastNotificationContainerViewInterface">();
	}
	static class IToastNotificationContainerViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IToastNotificationContainerViewInterface>();
	}
};
static_assert(alignof(IToastNotificationContainerViewInterface) == 0x000008, "Wrong alignment on IToastNotificationContainerViewInterface");
static_assert(sizeof(IToastNotificationContainerViewInterface) == 0x000030, "Wrong size on IToastNotificationContainerViewInterface");

// Class DBDUIViewInterfaces.TutorialHighlightViewInterface
// 0x0000 (0x0030 - 0x0030)
class ITutorialHighlightViewInterface final : public IInterface
{
public:
	void SetTutorialHighlight(const bool Show, const EHudComponent& ComponentId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TutorialHighlightViewInterface">();
	}
	static class ITutorialHighlightViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ITutorialHighlightViewInterface>();
	}
};
static_assert(alignof(ITutorialHighlightViewInterface) == 0x000008, "Wrong alignment on ITutorialHighlightViewInterface");
static_assert(sizeof(ITutorialHighlightViewInterface) == 0x000030, "Wrong size on ITutorialHighlightViewInterface");

// Class DBDUIViewInterfaces.TutorialMysteryNoteViewInterface
// 0x0000 (0x0030 - 0x0030)
class ITutorialMysteryNoteViewInterface final : public IInterface
{
public:
	void HideMysteryNote();
	void ShowMysteryNote(const struct FNotifTutorialPopupViewData& NotifData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TutorialMysteryNoteViewInterface">();
	}
	static class ITutorialMysteryNoteViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ITutorialMysteryNoteViewInterface>();
	}
};
static_assert(alignof(ITutorialMysteryNoteViewInterface) == 0x000008, "Wrong alignment on ITutorialMysteryNoteViewInterface");
static_assert(sizeof(ITutorialMysteryNoteViewInterface) == 0x000030, "Wrong size on ITutorialMysteryNoteViewInterface");

// Class DBDUIViewInterfaces.TutorialObjectivesViewInterface
// 0x0000 (0x0030 - 0x0030)
class ITutorialObjectivesViewInterface final : public IInterface
{
public:
	void AddTutorialObjective(const class FName& ID, const struct FTutorialObjectivesViewData& InteractionPromptViewData);
	void CompleteTutorialObjective(const class FName& ID, bool RemoveAfterCompletion);
	void RemoveAllTutorialObjectives();
	void RemoveTutorialObjective(const class FName& ID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TutorialObjectivesViewInterface">();
	}
	static class ITutorialObjectivesViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ITutorialObjectivesViewInterface>();
	}
};
static_assert(alignof(ITutorialObjectivesViewInterface) == 0x000008, "Wrong alignment on ITutorialObjectivesViewInterface");
static_assert(sizeof(ITutorialObjectivesViewInterface) == 0x000030, "Wrong size on ITutorialObjectivesViewInterface");

// Class DBDUIViewInterfaces.TutorialPopupViewInterface
// 0x0000 (0x0030 - 0x0030)
class ITutorialPopupViewInterface final : public IInterface
{
public:
	void HideTutorialPopup(bool PlaySoundEffect);
	void ShowNotifTutorialPopup(const struct FNotifTutorialPopupViewData& NotifTutoData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TutorialPopupViewInterface">();
	}
	static class ITutorialPopupViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ITutorialPopupViewInterface>();
	}
};
static_assert(alignof(ITutorialPopupViewInterface) == 0x000008, "Wrong alignment on ITutorialPopupViewInterface");
static_assert(sizeof(ITutorialPopupViewInterface) == 0x000030, "Wrong size on ITutorialPopupViewInterface");

// Class DBDUIViewInterfaces.UIUtilities
// 0x0000 (0x0030 - 0x0030)
class UUIUtilities final : public UBlueprintFunctionLibrary
{
public:
	static void ConvertArchiveCurrentAndMaxProgressionInPercentage(int32& OutCurrentProgression, int32& OutMaxProgression);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIUtilities">();
	}
	static class UUIUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIUtilities>();
	}
};
static_assert(alignof(UUIUtilities) == 0x000008, "Wrong alignment on UUIUtilities");
static_assert(sizeof(UUIUtilities) == 0x000030, "Wrong size on UUIUtilities");

// Class DBDUIViewInterfaces.UnlockPersonalPerksPopupViewData
// 0x0010 (0x0200 - 0x01F0)
class UUnlockPersonalPerksPopupViewData final : public UGenericPopupViewData
{
public:
	TArray<class UMenuPerkViewData*>              PerksData;                                         // 0x01F0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnlockPersonalPerksPopupViewData">();
	}
	static class UUnlockPersonalPerksPopupViewData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnlockPersonalPerksPopupViewData>();
	}
};
static_assert(alignof(UUnlockPersonalPerksPopupViewData) == 0x000010, "Wrong alignment on UUnlockPersonalPerksPopupViewData");
static_assert(sizeof(UUnlockPersonalPerksPopupViewData) == 0x000200, "Wrong size on UUnlockPersonalPerksPopupViewData");
static_assert(offsetof(UUnlockPersonalPerksPopupViewData, PerksData) == 0x0001F0, "Member 'UUnlockPersonalPerksPopupViewData::PerksData' has a wrong offset!");

// Class DBDUIViewInterfaces.UnlockPersonalPerksPopupViewInterface
// 0x0000 (0x0030 - 0x0030)
class IUnlockPersonalPerksPopupViewInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnlockPersonalPerksPopupViewInterface">();
	}
	static class IUnlockPersonalPerksPopupViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IUnlockPersonalPerksPopupViewInterface>();
	}
};
static_assert(alignof(IUnlockPersonalPerksPopupViewInterface) == 0x000008, "Wrong alignment on IUnlockPersonalPerksPopupViewInterface");
static_assert(sizeof(IUnlockPersonalPerksPopupViewInterface) == 0x000030, "Wrong size on IUnlockPersonalPerksPopupViewInterface");

// Class DBDUIViewInterfaces.WardrobeActionButtonsViewInterface
// 0x0000 (0x0030 - 0x0030)
class IWardrobeActionButtonsViewInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WardrobeActionButtonsViewInterface">();
	}
	static class IWardrobeActionButtonsViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IWardrobeActionButtonsViewInterface>();
	}
};
static_assert(alignof(IWardrobeActionButtonsViewInterface) == 0x000008, "Wrong alignment on IWardrobeActionButtonsViewInterface");
static_assert(sizeof(IWardrobeActionButtonsViewInterface) == 0x000030, "Wrong size on IWardrobeActionButtonsViewInterface");

// Class DBDUIViewInterfaces.WatermarkViewInterface
// 0x0000 (0x0030 - 0x0030)
class IWatermarkViewInterface final : public IInterface
{
public:
	void SetSteamValuesText(const class FString& SteamName, const class FString& SteamId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WatermarkViewInterface">();
	}
	static class IWatermarkViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IWatermarkViewInterface>();
	}
};
static_assert(alignof(IWatermarkViewInterface) == 0x000008, "Wrong alignment on IWatermarkViewInterface");
static_assert(sizeof(IWatermarkViewInterface) == 0x000030, "Wrong size on IWatermarkViewInterface");

}

