#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: ScriptableToolsFramework

#include "Basic.hpp"

#include "Engine_classes.hpp"
#include "InteractiveToolsFramework_structs.hpp"
#include "InteractiveToolsFramework_classes.hpp"
#include "ScriptableToolsFramework_structs.hpp"
#include "CoreUObject_classes.hpp"


namespace SDK
{

// Class ScriptableToolsFramework.ScriptableInteractiveTool
// 0x01A0 (0x0240 - 0x00A0)
class UScriptableInteractiveTool : public UInteractiveTool
{
public:
	class FText                                   ToolName;                                          // 0x00A0(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   ToolLongName;                                      // 0x00B8(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   ToolCategory;                                      // 0x00D0(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   ToolTooltip;                                       // 0x00E8(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bShowToolInEditor;                                 // 0x0100(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EScriptableToolShutdownType                   ToolShutdownType;                                  // 0x0101(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_102[0x2];                                      // 0x0102(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UWorld>                  TargetWorld;                                       // 0x0104(0x0008)(ZeroConstructor, Transient, DuplicateTransient, IsPlainOldData, NonTransactional, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_10C[0x4];                                      // 0x010C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UScriptableTool_RenderAPI*              RenderHelper;                                      // 0x0110(0x0008)(ZeroConstructor, Transient, DuplicateTransient, NonTransactional, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UScriptableTool_HUDAPI*                 DrawHUDHelper;                                     // 0x0118(0x0008)(ZeroConstructor, Transient, DuplicateTransient, NonTransactional, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_120[0xD0];                                     // 0x0120(0x00D0)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, class UCombinedTransformGizmo*> Gizmos;                                            // 0x01F0(0x0050)(Transient, DuplicateTransient, NonTransactional, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	void AddLogMessage(const class FText& Message, bool bHighlighted);
	class UScriptableInteractiveToolPropertySet* AddPropertySetOfType(TSubclassOf<class UScriptableInteractiveToolPropertySet> PropertySetType, const class FString& Identifier, EToolsFrameworkOutcomePins* Outcome);
	void ClearUserMessages(bool bHelpMessage, bool bWarningMessage);
	void CreateTRSGizmo(const class FString& Identifier, const struct FTransform& InitialTransform, const struct FScriptableToolGizmoOptions& GizmoOptions, EToolsFrameworkOutcomePins* Outcome);
	void DestroyTRSGizmo(const class FString& Identifier, EToolsFrameworkOutcomePins* Outcome);
	void DisplayUserHelpMessage(const class FText& Message);
	void DisplayUserWarningMessage(const class FText& Message);
	void ForcePropertySetUpdateByName(const class FString& Identifier);
	struct FTransform GetGizmoTransform(const class FString& Identifier);
	class UWorld* GetToolWorld();
	void OnGizmoTransformChanged(const class FString& GizmoIdentifier, const struct FTransform& NewTransform);
	void OnScriptDrawHUD(class UScriptableTool_HUDAPI* DrawHUDAPI);
	void OnScriptRender(class UScriptableTool_RenderAPI* RenderAPI);
	void OnScriptSetup();
	void OnScriptShutdown(EToolShutdownType ShutdownType);
	void OnScriptTick(float DeltaTime);
	void RemovePropertySetByName(const class FString& Identifier, EToolsFrameworkOutcomePins* Outcome);
	void RequestToolShutdown(bool bAccept, bool bShowUserPopupMessage, const class FText& UserMessage);
	class UScriptableInteractiveToolPropertySet* RestorePropertySetSettings(class UScriptableInteractiveToolPropertySet* PropertySet, const class FString& SaveKey);
	class UScriptableInteractiveToolPropertySet* SavePropertySetSettings(class UScriptableInteractiveToolPropertySet* PropertySet, const class FString& SaveKey);
	void SetGizmoTransform(const class FString& Identifier, const struct FTransform& NewTransform, bool bUndoable);
	void SetGizmoVisible(const class FString& Identifier, bool bVisible);
	void SetPropertySetVisibleByName(const class FString& Identifier, bool bVisible);
	class UScriptableInteractiveToolPropertySet* WatchBoolProperty(class UScriptableInteractiveToolPropertySet* PropertySet, const class FString& PropertyName, const TDelegate<void(class UScriptableInteractiveToolPropertySet* PropertySet, const class FString& PropertyName, bool bNewValue)>& OnModified);
	class UScriptableInteractiveToolPropertySet* WatchEnumProperty(class UScriptableInteractiveToolPropertySet* PropertySet, const class FString& PropertyName, const TDelegate<void(class UScriptableInteractiveToolPropertySet* PropertySet, const class FString& PropertyName, uint8 NewValue)>& OnModified);
	class UScriptableInteractiveToolPropertySet* WatchFloatProperty(class UScriptableInteractiveToolPropertySet* PropertySet, const class FString& PropertyName, const TDelegate<void(class UScriptableInteractiveToolPropertySet* PropertySet, const class FString& PropertyName, double NewValue)>& OnModified);
	class UScriptableInteractiveToolPropertySet* WatchIntProperty(class UScriptableInteractiveToolPropertySet* PropertySet, const class FString& PropertyName, const TDelegate<void(class UScriptableInteractiveToolPropertySet* PropertySet, const class FString& PropertyName, int32 NewValue)>& OnModified);
	class UScriptableInteractiveToolPropertySet* WatchNameProperty(class UScriptableInteractiveToolPropertySet* PropertySet, const class FString& PropertyName, const TDelegate<void(class UScriptableInteractiveToolPropertySet* PropertySet, const class FString& PropertyName, class FName NewValue)>& OnModified);
	class UScriptableInteractiveToolPropertySet* WatchObjectProperty(class UScriptableInteractiveToolPropertySet* PropertySet, const class FString& PropertyName, const TDelegate<void(class UScriptableInteractiveToolPropertySet* PropertySet, const class FString& PropertyName, class UObject* NewValue)>& OnModified);
	class UScriptableInteractiveToolPropertySet* WatchProperty(class UScriptableInteractiveToolPropertySet* PropertySet, const class FString& PropertyName, const TDelegate<void(class UScriptableInteractiveToolPropertySet* PropertySet, const class FString& PropertyName)>& OnModified);
	class UScriptableInteractiveToolPropertySet* WatchStringProperty(class UScriptableInteractiveToolPropertySet* PropertySet, const class FString& PropertyName, const TDelegate<void(class UScriptableInteractiveToolPropertySet* PropertySet, const class FString& PropertyName, const class FString& NewValue)>& OnModified);

	bool OnScriptCanAccept() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScriptableInteractiveTool">();
	}
	static class UScriptableInteractiveTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScriptableInteractiveTool>();
	}
};
static_assert(alignof(UScriptableInteractiveTool) == 0x000008, "Wrong alignment on UScriptableInteractiveTool");
static_assert(sizeof(UScriptableInteractiveTool) == 0x000240, "Wrong size on UScriptableInteractiveTool");
static_assert(offsetof(UScriptableInteractiveTool, ToolName) == 0x0000A0, "Member 'UScriptableInteractiveTool::ToolName' has a wrong offset!");
static_assert(offsetof(UScriptableInteractiveTool, ToolLongName) == 0x0000B8, "Member 'UScriptableInteractiveTool::ToolLongName' has a wrong offset!");
static_assert(offsetof(UScriptableInteractiveTool, ToolCategory) == 0x0000D0, "Member 'UScriptableInteractiveTool::ToolCategory' has a wrong offset!");
static_assert(offsetof(UScriptableInteractiveTool, ToolTooltip) == 0x0000E8, "Member 'UScriptableInteractiveTool::ToolTooltip' has a wrong offset!");
static_assert(offsetof(UScriptableInteractiveTool, bShowToolInEditor) == 0x000100, "Member 'UScriptableInteractiveTool::bShowToolInEditor' has a wrong offset!");
static_assert(offsetof(UScriptableInteractiveTool, ToolShutdownType) == 0x000101, "Member 'UScriptableInteractiveTool::ToolShutdownType' has a wrong offset!");
static_assert(offsetof(UScriptableInteractiveTool, TargetWorld) == 0x000104, "Member 'UScriptableInteractiveTool::TargetWorld' has a wrong offset!");
static_assert(offsetof(UScriptableInteractiveTool, RenderHelper) == 0x000110, "Member 'UScriptableInteractiveTool::RenderHelper' has a wrong offset!");
static_assert(offsetof(UScriptableInteractiveTool, DrawHUDHelper) == 0x000118, "Member 'UScriptableInteractiveTool::DrawHUDHelper' has a wrong offset!");
static_assert(offsetof(UScriptableInteractiveTool, Gizmos) == 0x0001F0, "Member 'UScriptableInteractiveTool::Gizmos' has a wrong offset!");

// Class ScriptableToolsFramework.ScriptableClickDragTool
// 0x0038 (0x0278 - 0x0240)
class UScriptableClickDragTool final : public UScriptableInteractiveTool
{
public:
	uint8                                         Pad_240[0x10];                                     // 0x0240(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bWantMouseHover;                                   // 0x0250(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUpdateModifiersDuringDrag;                        // 0x0251(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_252[0x6];                                      // 0x0252(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UClickDragInputBehavior*                ClickDragBehavior;                                 // 0x0258(0x0008)(ZeroConstructor, Transient, DuplicateTransient, NonTransactional, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_260[0x8];                                      // 0x0260(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UMouseHoverBehavior*                    MouseHoverBehavior;                                // 0x0268(0x0008)(ZeroConstructor, Transient, DuplicateTransient, NonTransactional, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_270[0x8];                                      // 0x0270(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FScriptableToolModifierStates GetActiveModifiers();
	void OnDragBegin(const struct FInputDeviceRay& StartPosition, const struct FScriptableToolModifierStates& Modifiers);
	void OnDragEnd(const struct FInputDeviceRay& EndPosition, const struct FScriptableToolModifierStates& Modifiers);
	void OnDragSequenceCancelled();
	void OnDragUpdatePosition(const struct FInputDeviceRay& NewPosition, const struct FScriptableToolModifierStates& Modifiers);
	void OnHoverBegin(const struct FInputDeviceRay& HoverPos, const struct FScriptableToolModifierStates& Modifiers);
	void OnHoverEnd(const struct FScriptableToolModifierStates& Modifiers);
	struct FInputRayHit OnHoverHitTest(const struct FInputDeviceRay& HoverPos, const struct FScriptableToolModifierStates& Modifiers);
	bool OnHoverUpdate(const struct FInputDeviceRay& HoverPos, const struct FScriptableToolModifierStates& Modifiers);
	struct FInputRayHit TestIfCanBeginClickDrag(const struct FInputDeviceRay& ClickPos, const struct FScriptableToolModifierStates& Modifiers);

	bool InActiveClickDrag() const;
	bool InActiveHover() const;
	bool IsAltDown() const;
	bool IsCtrlDown() const;
	bool IsShiftDown() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScriptableClickDragTool">();
	}
	static class UScriptableClickDragTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScriptableClickDragTool>();
	}
};
static_assert(alignof(UScriptableClickDragTool) == 0x000008, "Wrong alignment on UScriptableClickDragTool");
static_assert(sizeof(UScriptableClickDragTool) == 0x000278, "Wrong size on UScriptableClickDragTool");
static_assert(offsetof(UScriptableClickDragTool, bWantMouseHover) == 0x000250, "Member 'UScriptableClickDragTool::bWantMouseHover' has a wrong offset!");
static_assert(offsetof(UScriptableClickDragTool, bUpdateModifiersDuringDrag) == 0x000251, "Member 'UScriptableClickDragTool::bUpdateModifiersDuringDrag' has a wrong offset!");
static_assert(offsetof(UScriptableClickDragTool, ClickDragBehavior) == 0x000258, "Member 'UScriptableClickDragTool::ClickDragBehavior' has a wrong offset!");
static_assert(offsetof(UScriptableClickDragTool, MouseHoverBehavior) == 0x000268, "Member 'UScriptableClickDragTool::MouseHoverBehavior' has a wrong offset!");

// Class ScriptableToolsFramework.ScriptableTool_RenderAPI
// 0x0008 (0x0038 - 0x0030)
class UScriptableTool_RenderAPI final : public UObject
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UScriptableTool_RenderAPI* DrawLine(const struct FVector& Start, const struct FVector& End, const struct FLinearColor& Color, float Thickness, float DepthBias, bool bDepthTested);
	class UScriptableTool_RenderAPI* DrawRectWidthHeightXY(const struct FTransform& Transform, double Width, double Height, const struct FLinearColor& Color, float LineThickness, float DepthBias, bool bDepthTested, bool bCentered);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScriptableTool_RenderAPI">();
	}
	static class UScriptableTool_RenderAPI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScriptableTool_RenderAPI>();
	}
};
static_assert(alignof(UScriptableTool_RenderAPI) == 0x000008, "Wrong alignment on UScriptableTool_RenderAPI");
static_assert(sizeof(UScriptableTool_RenderAPI) == 0x000038, "Wrong size on UScriptableTool_RenderAPI");

// Class ScriptableToolsFramework.ScriptableTool_HUDAPI
// 0x0010 (0x0040 - 0x0030)
class UScriptableTool_HUDAPI final : public UObject
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UScriptableTool_HUDAPI* DrawTextArrayAtLocation(const struct FVector& Location, const TArray<class FString>& Strings, const struct FLinearColor& Color, bool bCentered, float ShiftRowsY);
	class UScriptableTool_HUDAPI* DrawTextAtLocation(const struct FVector& Location, const class FString& String, const struct FLinearColor& Color, bool bCentered, float ShiftRowsY);
	class UScriptableTool_HUDAPI* GetCanvasLocation(const struct FVector& Location, struct FVector2D* CanvasLocation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScriptableTool_HUDAPI">();
	}
	static class UScriptableTool_HUDAPI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScriptableTool_HUDAPI>();
	}
};
static_assert(alignof(UScriptableTool_HUDAPI) == 0x000008, "Wrong alignment on UScriptableTool_HUDAPI");
static_assert(sizeof(UScriptableTool_HUDAPI) == 0x000040, "Wrong size on UScriptableTool_HUDAPI");

// Class ScriptableToolsFramework.ScriptableInteractiveToolPropertySet
// 0x0008 (0x00B8 - 0x00B0)
class UScriptableInteractiveToolPropertySet final : public UInteractiveToolPropertySet
{
public:
	uint8                                         Pad_B0[0x8];                                       // 0x00B0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UScriptableInteractiveTool* GetOwningTool(EToolsFrameworkOutcomePins* Outcome);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScriptableInteractiveToolPropertySet">();
	}
	static class UScriptableInteractiveToolPropertySet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScriptableInteractiveToolPropertySet>();
	}
};
static_assert(alignof(UScriptableInteractiveToolPropertySet) == 0x000008, "Wrong alignment on UScriptableInteractiveToolPropertySet");
static_assert(sizeof(UScriptableInteractiveToolPropertySet) == 0x0000B8, "Wrong size on UScriptableInteractiveToolPropertySet");

// Class ScriptableToolsFramework.ScriptableToolsUtilityLibrary
// 0x0000 (0x0030 - 0x0030)
class UScriptableToolsUtilityLibrary final : public UBlueprintFunctionLibrary
{
public:
	static struct FInputRayHit MakeInputRayHit(double HitDepth, class UObject* OptionalHitObject);
	static struct FInputRayHit MakeInputRayHit_MaxDepth();
	static struct FInputRayHit MakeInputRayHit_Miss();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScriptableToolsUtilityLibrary">();
	}
	static class UScriptableToolsUtilityLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScriptableToolsUtilityLibrary>();
	}
};
static_assert(alignof(UScriptableToolsUtilityLibrary) == 0x000008, "Wrong alignment on UScriptableToolsUtilityLibrary");
static_assert(sizeof(UScriptableToolsUtilityLibrary) == 0x000030, "Wrong size on UScriptableToolsUtilityLibrary");

// Class ScriptableToolsFramework.ScriptableSingleClickTool
// 0x0030 (0x0270 - 0x0240)
class UScriptableSingleClickTool final : public UScriptableInteractiveTool
{
public:
	uint8                                         Pad_240[0x10];                                     // 0x0240(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bWantMouseHover;                                   // 0x0250(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_251[0x7];                                      // 0x0251(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USingleClickInputBehavior*              SingleClickBehavior;                               // 0x0258(0x0008)(ZeroConstructor, Transient, DuplicateTransient, NonTransactional, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMouseHoverBehavior*                    MouseHoverBehavior;                                // 0x0260(0x0008)(ZeroConstructor, Transient, DuplicateTransient, NonTransactional, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_268[0x8];                                      // 0x0268(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FScriptableToolModifierStates GetActiveModifiers();
	void OnHitByClick(const struct FInputDeviceRay& ClickPos, const struct FScriptableToolModifierStates& Modifiers);
	void OnHoverBegin(const struct FInputDeviceRay& HoverPos, const struct FScriptableToolModifierStates& Modifiers);
	void OnHoverEnd(const struct FScriptableToolModifierStates& Modifiers);
	struct FInputRayHit OnHoverHitTest(const struct FInputDeviceRay& HoverPos, const struct FScriptableToolModifierStates& Modifiers);
	bool OnHoverUpdate(const struct FInputDeviceRay& HoverPos, const struct FScriptableToolModifierStates& Modifiers);
	struct FInputRayHit TestIfHitByClick(const struct FInputDeviceRay& ClickPos, const struct FScriptableToolModifierStates& Modifiers);

	bool InActiveHover() const;
	bool IsAltDown() const;
	bool IsCtrlDown() const;
	bool IsShiftDown() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScriptableSingleClickTool">();
	}
	static class UScriptableSingleClickTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScriptableSingleClickTool>();
	}
};
static_assert(alignof(UScriptableSingleClickTool) == 0x000008, "Wrong alignment on UScriptableSingleClickTool");
static_assert(sizeof(UScriptableSingleClickTool) == 0x000270, "Wrong size on UScriptableSingleClickTool");
static_assert(offsetof(UScriptableSingleClickTool, bWantMouseHover) == 0x000250, "Member 'UScriptableSingleClickTool::bWantMouseHover' has a wrong offset!");
static_assert(offsetof(UScriptableSingleClickTool, SingleClickBehavior) == 0x000258, "Member 'UScriptableSingleClickTool::SingleClickBehavior' has a wrong offset!");
static_assert(offsetof(UScriptableSingleClickTool, MouseHoverBehavior) == 0x000260, "Member 'UScriptableSingleClickTool::MouseHoverBehavior' has a wrong offset!");

// Class ScriptableToolsFramework.BaseScriptableToolBuilder
// 0x0008 (0x0038 - 0x0030)
class UBaseScriptableToolBuilder final : public UInteractiveToolBuilder
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseScriptableToolBuilder">();
	}
	static class UBaseScriptableToolBuilder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseScriptableToolBuilder>();
	}
};
static_assert(alignof(UBaseScriptableToolBuilder) == 0x000008, "Wrong alignment on UBaseScriptableToolBuilder");
static_assert(sizeof(UBaseScriptableToolBuilder) == 0x000038, "Wrong size on UBaseScriptableToolBuilder");

}

