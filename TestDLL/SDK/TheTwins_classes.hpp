#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: TheTwins

#include "Basic.hpp"

#include "DBDGameplay_classes.hpp"
#include "DBDCompetence_classes.hpp"
#include "DBDInteraction_classes.hpp"
#include "DataTableUtilities_structs.hpp"
#include "SystemUtilities_structs.hpp"
#include "DeadByDaylight_structs.hpp"
#include "DeadByDaylight_classes.hpp"
#include "DBDBots_classes.hpp"
#include "StatSystem_structs.hpp"
#include "DBDSharedTypes_structs.hpp"
#include "DBDAnimation_classes.hpp"
#include "TheTwins_structs.hpp"
#include "Competence_classes.hpp"
#include "Engine_classes.hpp"
#include "GameplayTags_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "DBDAttack_classes.hpp"


namespace SDK
{

// Class TheTwins.Addon_K22Power_10
// 0x0008 (0x0300 - 0x02F8)
class UAddon_K22Power_10 final : public UOnEventBaseAddon
{
public:
	TSubclassOf<class UStatusEffect>              _hemorrhageStatusEffectClass;                      // 0x02F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Addon_K22Power_10">();
	}
	static class UAddon_K22Power_10* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAddon_K22Power_10>();
	}
};
static_assert(alignof(UAddon_K22Power_10) == 0x000008, "Wrong alignment on UAddon_K22Power_10");
static_assert(sizeof(UAddon_K22Power_10) == 0x000300, "Wrong size on UAddon_K22Power_10");
static_assert(offsetof(UAddon_K22Power_10, _hemorrhageStatusEffectClass) == 0x0002F8, "Member 'UAddon_K22Power_10::_hemorrhageStatusEffectClass' has a wrong offset!");

// Class TheTwins.TwinFirstPersonViewComponent
// 0x0020 (0x0110 - 0x00F0)
class UTwinFirstPersonViewComponent final : public UFirstPersonViewComponent
{
public:
	uint8                                         Pad_F0[0x20];                                      // 0x00F0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TwinFirstPersonViewComponent">();
	}
	static class UTwinFirstPersonViewComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTwinFirstPersonViewComponent>();
	}
};
static_assert(alignof(UTwinFirstPersonViewComponent) == 0x000008, "Wrong alignment on UTwinFirstPersonViewComponent");
static_assert(sizeof(UTwinFirstPersonViewComponent) == 0x000110, "Wrong size on UTwinFirstPersonViewComponent");

// Class TheTwins.Addon_K22Power_11
// 0x0010 (0x0308 - 0x02F8)
class UAddon_K22Power_11 final : public USpawnEffectsOnAllSurvivorsBaseAddon
{
public:
	TSubclassOf<class UStatusEffect>              _survivorRemoveTwinMaxChargeAdditiveEffect;        // 0x02F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _increaseRemoveTwinTime;                           // 0x0300(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_304[0x4];                                      // 0x0304(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Addon_K22Power_11">();
	}
	static class UAddon_K22Power_11* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAddon_K22Power_11>();
	}
};
static_assert(alignof(UAddon_K22Power_11) == 0x000008, "Wrong alignment on UAddon_K22Power_11");
static_assert(sizeof(UAddon_K22Power_11) == 0x000308, "Wrong size on UAddon_K22Power_11");
static_assert(offsetof(UAddon_K22Power_11, _survivorRemoveTwinMaxChargeAdditiveEffect) == 0x0002F8, "Member 'UAddon_K22Power_11::_survivorRemoveTwinMaxChargeAdditiveEffect' has a wrong offset!");
static_assert(offsetof(UAddon_K22Power_11, _increaseRemoveTwinTime) == 0x000300, "Member 'UAddon_K22Power_11::_increaseRemoveTwinTime' has a wrong offset!");

// Class TheTwins.TwinHuskAnimInstance
// 0x0020 (0x0370 - 0x0350)
class UTwinHuskAnimInstance final : public UAnimInstance
{
public:
	bool                                          _isDeadFromSurvivorBack;                           // 0x0350(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_351[0x7];                                      // 0x0351(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class APawn*                                  _owningPawn;                                       // 0x0358(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTwinHuskStateComponent*                _twinHuskStateComponent;                           // 0x0360(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_368[0x8];                                      // 0x0368(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TwinHuskAnimInstance">();
	}
	static class UTwinHuskAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTwinHuskAnimInstance>();
	}
};
static_assert(alignof(UTwinHuskAnimInstance) == 0x000010, "Wrong alignment on UTwinHuskAnimInstance");
static_assert(sizeof(UTwinHuskAnimInstance) == 0x000370, "Wrong size on UTwinHuskAnimInstance");
static_assert(offsetof(UTwinHuskAnimInstance, _isDeadFromSurvivorBack) == 0x000350, "Member 'UTwinHuskAnimInstance::_isDeadFromSurvivorBack' has a wrong offset!");
static_assert(offsetof(UTwinHuskAnimInstance, _owningPawn) == 0x000358, "Member 'UTwinHuskAnimInstance::_owningPawn' has a wrong offset!");
static_assert(offsetof(UTwinHuskAnimInstance, _twinHuskStateComponent) == 0x000360, "Member 'UTwinHuskAnimInstance::_twinHuskStateComponent' has a wrong offset!");

// Class TheTwins.Addon_K22Power_14
// 0x0010 (0x0308 - 0x02F8)
class UAddon_K22Power_14 final : public UOnEventBaseAddon
{
public:
	TSubclassOf<class UStatusEffect>              _brokenStatusEffectClass;                          // 0x02F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _brokenDuration;                                   // 0x0300(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_304[0x4];                                      // 0x0304(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Addon_K22Power_14">();
	}
	static class UAddon_K22Power_14* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAddon_K22Power_14>();
	}
};
static_assert(alignof(UAddon_K22Power_14) == 0x000008, "Wrong alignment on UAddon_K22Power_14");
static_assert(sizeof(UAddon_K22Power_14) == 0x000308, "Wrong size on UAddon_K22Power_14");
static_assert(offsetof(UAddon_K22Power_14, _brokenStatusEffectClass) == 0x0002F8, "Member 'UAddon_K22Power_14::_brokenStatusEffectClass' has a wrong offset!");
static_assert(offsetof(UAddon_K22Power_14, _brokenDuration) == 0x000300, "Member 'UAddon_K22Power_14::_brokenDuration' has a wrong offset!");

// Class TheTwins.TwinHuskStateComponent
// 0x0008 (0x00B0 - 0x00A8)
class UTwinHuskStateComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsDeadFromSurvivorBack() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TwinHuskStateComponent">();
	}
	static class UTwinHuskStateComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTwinHuskStateComponent>();
	}
};
static_assert(alignof(UTwinHuskStateComponent) == 0x000008, "Wrong alignment on UTwinHuskStateComponent");
static_assert(sizeof(UTwinHuskStateComponent) == 0x0000B0, "Wrong size on UTwinHuskStateComponent");

// Class TheTwins.Addon_K22Power_16
// 0x0000 (0x02F8 - 0x02F8)
class UAddon_K22Power_16 final : public UOnEventBaseAddon
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Addon_K22Power_16">();
	}
	static class UAddon_K22Power_16* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAddon_K22Power_16>();
	}
};
static_assert(alignof(UAddon_K22Power_16) == 0x000008, "Wrong alignment on UAddon_K22Power_16");
static_assert(sizeof(UAddon_K22Power_16) == 0x0002F8, "Wrong size on UAddon_K22Power_16");

// Class TheTwins.BaseTwinInspectLocker
// 0x0030 (0x07E0 - 0x07B0)
class UBaseTwinInspectLocker : public UBaseLockerInteraction
{
public:
	struct FDBDTunableRowHandle                   _inspectInteractionTime;                           // 0x07A8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7D0[0x10];                                     // 0x07D0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseTwinInspectLocker">();
	}
	static class UBaseTwinInspectLocker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseTwinInspectLocker>();
	}
};
static_assert(alignof(UBaseTwinInspectLocker) == 0x000010, "Wrong alignment on UBaseTwinInspectLocker");
static_assert(sizeof(UBaseTwinInspectLocker) == 0x0007E0, "Wrong size on UBaseTwinInspectLocker");
static_assert(offsetof(UBaseTwinInspectLocker, _inspectInteractionTime) == 0x0007A8, "Member 'UBaseTwinInspectLocker::_inspectInteractionTime' has a wrong offset!");

// Class TheTwins.TwinInspectEmptyLocker
// 0x0000 (0x07E0 - 0x07E0)
class UTwinInspectEmptyLocker final : public UBaseTwinInspectLocker
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TwinInspectEmptyLocker">();
	}
	static class UTwinInspectEmptyLocker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTwinInspectEmptyLocker>();
	}
};
static_assert(alignof(UTwinInspectEmptyLocker) == 0x000010, "Wrong alignment on UTwinInspectEmptyLocker");
static_assert(sizeof(UTwinInspectEmptyLocker) == 0x0007E0, "Wrong size on UTwinInspectEmptyLocker");

// Class TheTwins.Addon_K22Power_17
// 0x0038 (0x0330 - 0x02F8)
class UAddon_K22Power_17 final : public USpawnEffectsOnAllSurvivorsBaseAddon
{
public:
	uint8                                         Pad_2F8[0x8];                                      // 0x02F8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UStatusEffect>              _twinDormantObliviousEffectClass;                  // 0x0300(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _lingerDuration;                                   // 0x0308(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	void Authority_OnTwinSet(class AConjoinedTwin* Twin);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Addon_K22Power_17">();
	}
	static class UAddon_K22Power_17* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAddon_K22Power_17>();
	}
};
static_assert(alignof(UAddon_K22Power_17) == 0x000008, "Wrong alignment on UAddon_K22Power_17");
static_assert(sizeof(UAddon_K22Power_17) == 0x000330, "Wrong size on UAddon_K22Power_17");
static_assert(offsetof(UAddon_K22Power_17, _twinDormantObliviousEffectClass) == 0x000300, "Member 'UAddon_K22Power_17::_twinDormantObliviousEffectClass' has a wrong offset!");
static_assert(offsetof(UAddon_K22Power_17, _lingerDuration) == 0x000308, "Member 'UAddon_K22Power_17::_lingerDuration' has a wrong offset!");

// Class TheTwins.TwinInspectOccupiedLocker
// 0x0000 (0x07E0 - 0x07E0)
class UTwinInspectOccupiedLocker final : public UBaseTwinInspectLocker
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TwinInspectOccupiedLocker">();
	}
	static class UTwinInspectOccupiedLocker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTwinInspectOccupiedLocker>();
	}
};
static_assert(alignof(UTwinInspectOccupiedLocker) == 0x000010, "Wrong alignment on UTwinInspectOccupiedLocker");
static_assert(sizeof(UTwinInspectOccupiedLocker) == 0x0007E0, "Wrong size on UTwinInspectOccupiedLocker");

// Class TheTwins.Addon_K22Power_18
// 0x0010 (0x0308 - 0x02F8)
class UAddon_K22Power_18 final : public UOnEventBaseAddon
{
public:
	TSubclassOf<class UStatusEffect>              _timedRevealToKillerStatusEffectClass;             // 0x02F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _auraRevealedDuration;                             // 0x0300(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_304[0x4];                                      // 0x0304(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Addon_K22Power_18">();
	}
	static class UAddon_K22Power_18* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAddon_K22Power_18>();
	}
};
static_assert(alignof(UAddon_K22Power_18) == 0x000008, "Wrong alignment on UAddon_K22Power_18");
static_assert(sizeof(UAddon_K22Power_18) == 0x000308, "Wrong size on UAddon_K22Power_18");
static_assert(offsetof(UAddon_K22Power_18, _timedRevealToKillerStatusEffectClass) == 0x0002F8, "Member 'UAddon_K22Power_18::_timedRevealToKillerStatusEffectClass' has a wrong offset!");
static_assert(offsetof(UAddon_K22Power_18, _auraRevealedDuration) == 0x000300, "Member 'UAddon_K22Power_18::_auraRevealedDuration' has a wrong offset!");

// Class TheTwins.TwinJumpAttack
// 0x0150 (0x0570 - 0x0420)
class UTwinJumpAttack final : public UPounceAttack
{
public:
	bool                                          _wasLastAttackSuccessful;                          // 0x0420(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_421[0x7];                                      // 0x0421(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _jumpVelocity;                                     // 0x0428(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _jumpAngleCurve;                                   // 0x0450(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_458[0x48];                                     // 0x0458(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _upDownObstructionAnglePrecision;                  // 0x04A0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _leftRightObstructionAnglePrecision;               // 0x04C8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _authorizedLandingHeight;                          // 0x04F0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_518[0x9];                                      // 0x0518(0x0009)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _shouldTwinHaveJumpObjectType;                     // 0x0521(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_522[0x4E];                                     // 0x0522(0x004E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Client_Debug_PrintLandingLocationDebug(const bool FoundProjectedPoint, const bool FoundPath);
	void Cosmetic_OnIsForbiddenLandingLocationChanged(bool IsForbiddenLocation, class AConjoinedTwin* Twin);
	void Cosmetic_OnJumpCooldownChanged(bool IsInJumpCooldown, class AConjoinedTwin* OwningTwin);
	void Cosmetic_OnJumpLanded(class AConjoinedTwin* OwningTwin);
	void Cosmetic_OnJumpObstructed(class AConjoinedTwin* OwningTwin);
	void Cosmetic_OnJumpStarted(class AConjoinedTwin* OwningTwin);
	void Cosmetic_OnSuccessfulJumpAttack(class AConjoinedTwin* OwningTwin);
	void Cosmetic_OnUnSuccessfulJumpAttack(class AConjoinedTwin* OwningTwin);
	void Multicast_AttachToSurvivor(class ADBDPlayer* SurvivorToAttachTo);
	void Multicast_DestroyTwinOnWrongLanding();
	void Multicast_SetIsForbiddenLandingLocation(bool IsForbiddenLocation);
	void OnRep_ShouldTwinHaveJumpObjectType();
	void Server_OnJumpStartTwin();
	void Server_StopJump();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TwinJumpAttack">();
	}
	static class UTwinJumpAttack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTwinJumpAttack>();
	}
};
static_assert(alignof(UTwinJumpAttack) == 0x000010, "Wrong alignment on UTwinJumpAttack");
static_assert(sizeof(UTwinJumpAttack) == 0x000570, "Wrong size on UTwinJumpAttack");
static_assert(offsetof(UTwinJumpAttack, _wasLastAttackSuccessful) == 0x000420, "Member 'UTwinJumpAttack::_wasLastAttackSuccessful' has a wrong offset!");
static_assert(offsetof(UTwinJumpAttack, _jumpVelocity) == 0x000428, "Member 'UTwinJumpAttack::_jumpVelocity' has a wrong offset!");
static_assert(offsetof(UTwinJumpAttack, _jumpAngleCurve) == 0x000450, "Member 'UTwinJumpAttack::_jumpAngleCurve' has a wrong offset!");
static_assert(offsetof(UTwinJumpAttack, _upDownObstructionAnglePrecision) == 0x0004A0, "Member 'UTwinJumpAttack::_upDownObstructionAnglePrecision' has a wrong offset!");
static_assert(offsetof(UTwinJumpAttack, _leftRightObstructionAnglePrecision) == 0x0004C8, "Member 'UTwinJumpAttack::_leftRightObstructionAnglePrecision' has a wrong offset!");
static_assert(offsetof(UTwinJumpAttack, _authorizedLandingHeight) == 0x0004F0, "Member 'UTwinJumpAttack::_authorizedLandingHeight' has a wrong offset!");
static_assert(offsetof(UTwinJumpAttack, _shouldTwinHaveJumpObjectType) == 0x000521, "Member 'UTwinJumpAttack::_shouldTwinHaveJumpObjectType' has a wrong offset!");

// Class TheTwins.Addon_K22Power_19
// 0x0010 (0x0308 - 0x02F8)
class UAddon_K22Power_19 final : public UOnEventBaseAddon
{
public:
	float                                         _undetectableDuration;                             // 0x02F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2FC[0x4];                                      // 0x02FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UStatusEffect>              _undetectableEffectClass;                          // 0x0300(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Addon_K22Power_19">();
	}
	static class UAddon_K22Power_19* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAddon_K22Power_19>();
	}
};
static_assert(alignof(UAddon_K22Power_19) == 0x000008, "Wrong alignment on UAddon_K22Power_19");
static_assert(sizeof(UAddon_K22Power_19) == 0x000308, "Wrong size on UAddon_K22Power_19");
static_assert(offsetof(UAddon_K22Power_19, _undetectableDuration) == 0x0002F8, "Member 'UAddon_K22Power_19::_undetectableDuration' has a wrong offset!");
static_assert(offsetof(UAddon_K22Power_19, _undetectableEffectClass) == 0x000300, "Member 'UAddon_K22Power_19::_undetectableEffectClass' has a wrong offset!");

// Class TheTwins.TwinJumpAttackOpenSubstate
// 0x0108 (0x0238 - 0x0130)
class UTwinJumpAttackOpenSubstate final : public UPounceAttackOpenSubstate
{
public:
	uint8                                         Pad_130[0x108];                                    // 0x0130(0x0108)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Local_OnTwinCapsuleHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	void Local_OnTwinOverlapEnter(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& Hit);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TwinJumpAttackOpenSubstate">();
	}
	static class UTwinJumpAttackOpenSubstate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTwinJumpAttackOpenSubstate>();
	}
};
static_assert(alignof(UTwinJumpAttackOpenSubstate) == 0x000008, "Wrong alignment on UTwinJumpAttackOpenSubstate");
static_assert(sizeof(UTwinJumpAttackOpenSubstate) == 0x000238, "Wrong size on UTwinJumpAttackOpenSubstate");

// Class TheTwins.Addon_K22Power_20
// 0x0010 (0x0308 - 0x02F8)
class UAddon_K22Power_20 final : public UOnEventBaseAddon
{
public:
	float                                         _exposedDuration;                                  // 0x02F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2FC[0x4];                                      // 0x02FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UStatusEffect>              _exposedEffect;                                    // 0x0300(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Addon_K22Power_20">();
	}
	static class UAddon_K22Power_20* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAddon_K22Power_20>();
	}
};
static_assert(alignof(UAddon_K22Power_20) == 0x000008, "Wrong alignment on UAddon_K22Power_20");
static_assert(sizeof(UAddon_K22Power_20) == 0x000308, "Wrong size on UAddon_K22Power_20");
static_assert(offsetof(UAddon_K22Power_20, _exposedDuration) == 0x0002F8, "Member 'UAddon_K22Power_20::_exposedDuration' has a wrong offset!");
static_assert(offsetof(UAddon_K22Power_20, _exposedEffect) == 0x000300, "Member 'UAddon_K22Power_20::_exposedEffect' has a wrong offset!");

// Class TheTwins.TwinJumpAttackSuccessSubstate
// 0x0050 (0x0168 - 0x0118)
class UTwinJumpAttackSuccessSubstate final : public UPounceAttackSuccessSubstate
{
public:
	struct FDBDTunableRowHandle                   _jumpSucceedAttachedCooldownTime;                  // 0x0118(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _jumpSucceedNotAttachedCooldownTime;               // 0x0140(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TwinJumpAttackSuccessSubstate">();
	}
	static class UTwinJumpAttackSuccessSubstate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTwinJumpAttackSuccessSubstate>();
	}
};
static_assert(alignof(UTwinJumpAttackSuccessSubstate) == 0x000008, "Wrong alignment on UTwinJumpAttackSuccessSubstate");
static_assert(sizeof(UTwinJumpAttackSuccessSubstate) == 0x000168, "Wrong size on UTwinJumpAttackSuccessSubstate");
static_assert(offsetof(UTwinJumpAttackSuccessSubstate, _jumpSucceedAttachedCooldownTime) == 0x000118, "Member 'UTwinJumpAttackSuccessSubstate::_jumpSucceedAttachedCooldownTime' has a wrong offset!");
static_assert(offsetof(UTwinJumpAttackSuccessSubstate, _jumpSucceedNotAttachedCooldownTime) == 0x000140, "Member 'UTwinJumpAttackSuccessSubstate::_jumpSucceedNotAttachedCooldownTime' has a wrong offset!");

// Class TheTwins.Addon_K22Power_8
// 0x0010 (0x0308 - 0x02F8)
class UAddon_K22Power_8 final : public USpawnEffectsOnAllSurvivorsBaseAddon
{
public:
	TSubclassOf<class UStatusEffect>              _survivorDestroyTwinMaxChargeAdditiveEffectClass;  // 0x02F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _increaseDestroyTwinTime;                          // 0x0300(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_304[0x4];                                      // 0x0304(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Addon_K22Power_8">();
	}
	static class UAddon_K22Power_8* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAddon_K22Power_8>();
	}
};
static_assert(alignof(UAddon_K22Power_8) == 0x000008, "Wrong alignment on UAddon_K22Power_8");
static_assert(sizeof(UAddon_K22Power_8) == 0x000308, "Wrong size on UAddon_K22Power_8");
static_assert(offsetof(UAddon_K22Power_8, _survivorDestroyTwinMaxChargeAdditiveEffectClass) == 0x0002F8, "Member 'UAddon_K22Power_8::_survivorDestroyTwinMaxChargeAdditiveEffectClass' has a wrong offset!");
static_assert(offsetof(UAddon_K22Power_8, _increaseDestroyTwinTime) == 0x000300, "Member 'UAddon_K22Power_8::_increaseDestroyTwinTime' has a wrong offset!");

// Class TheTwins.TwinJumpAttackMissSubstate
// 0x0000 (0x0120 - 0x0120)
class UTwinJumpAttackMissSubstate final : public UPounceAttackMissSubstate
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TwinJumpAttackMissSubstate">();
	}
	static class UTwinJumpAttackMissSubstate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTwinJumpAttackMissSubstate>();
	}
};
static_assert(alignof(UTwinJumpAttackMissSubstate) == 0x000008, "Wrong alignment on UTwinJumpAttackMissSubstate");
static_assert(sizeof(UTwinJumpAttackMissSubstate) == 0x000120, "Wrong size on UTwinJumpAttackMissSubstate");

// Class TheTwins.Addon_K22Power_9
// 0x0010 (0x0308 - 0x02F8)
class UAddon_K22Power_9 final : public UOnEventBaseAddon
{
public:
	TSubclassOf<class UStatusEffect>              _blindnessStatusEffectClass;                       // 0x02F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _blindnessDuration;                                // 0x0300(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_304[0x4];                                      // 0x0304(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Addon_K22Power_9">();
	}
	static class UAddon_K22Power_9* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAddon_K22Power_9>();
	}
};
static_assert(alignof(UAddon_K22Power_9) == 0x000008, "Wrong alignment on UAddon_K22Power_9");
static_assert(sizeof(UAddon_K22Power_9) == 0x000308, "Wrong size on UAddon_K22Power_9");
static_assert(offsetof(UAddon_K22Power_9, _blindnessStatusEffectClass) == 0x0002F8, "Member 'UAddon_K22Power_9::_blindnessStatusEffectClass' has a wrong offset!");
static_assert(offsetof(UAddon_K22Power_9, _blindnessDuration) == 0x000300, "Member 'UAddon_K22Power_9::_blindnessDuration' has a wrong offset!");

// Class TheTwins.TwinJumpAttackObstructSubstate
// 0x0000 (0x0128 - 0x0128)
class UTwinJumpAttackObstructSubstate final : public UPounceAttackObstructSubstate
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TwinJumpAttackObstructSubstate">();
	}
	static class UTwinJumpAttackObstructSubstate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTwinJumpAttackObstructSubstate>();
	}
};
static_assert(alignof(UTwinJumpAttackObstructSubstate) == 0x000008, "Wrong alignment on UTwinJumpAttackObstructSubstate");
static_assert(sizeof(UTwinJumpAttackObstructSubstate) == 0x000128, "Wrong size on UTwinJumpAttackObstructSubstate");

// Class TheTwins.AISkill_FindInteractable_CrushTwin
// 0x0158 (0x0460 - 0x0308)
class UAISkill_FindInteractable_CrushTwin final : public UAISkill_FindInteractable
{
public:
	uint8                                         Pad_308[0x10];                                     // 0x0308(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAITunableParameter                    _crushVictorGoalWeight;                            // 0x0318(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FAITunableParameter                    _recoveringTimeEstimationErrorMin;                 // 0x0378(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FAITunableParameter                    _recoveringTimeEstimationErrorMax;                 // 0x03D8(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _destroyTwinMaxCharge;                             // 0x0438(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_FindInteractable_CrushTwin">();
	}
	static class UAISkill_FindInteractable_CrushTwin* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_FindInteractable_CrushTwin>();
	}
};
static_assert(alignof(UAISkill_FindInteractable_CrushTwin) == 0x000008, "Wrong alignment on UAISkill_FindInteractable_CrushTwin");
static_assert(sizeof(UAISkill_FindInteractable_CrushTwin) == 0x000460, "Wrong size on UAISkill_FindInteractable_CrushTwin");
static_assert(offsetof(UAISkill_FindInteractable_CrushTwin, _crushVictorGoalWeight) == 0x000318, "Member 'UAISkill_FindInteractable_CrushTwin::_crushVictorGoalWeight' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_CrushTwin, _recoveringTimeEstimationErrorMin) == 0x000378, "Member 'UAISkill_FindInteractable_CrushTwin::_recoveringTimeEstimationErrorMin' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_CrushTwin, _recoveringTimeEstimationErrorMax) == 0x0003D8, "Member 'UAISkill_FindInteractable_CrushTwin::_recoveringTimeEstimationErrorMax' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_CrushTwin, _destroyTwinMaxCharge) == 0x000438, "Member 'UAISkill_FindInteractable_CrushTwin::_destroyTwinMaxCharge' has a wrong offset!");

// Class TheTwins.TwinJumpAudioMutedEffect
// 0x0000 (0x0380 - 0x0380)
class UTwinJumpAudioMutedEffect final : public UStatusEffect
{
public:
	void Cosmetic_OnTwinMuted();
	void Cosmetic_OnTwinUnmuted();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TwinJumpAudioMutedEffect">();
	}
	static class UTwinJumpAudioMutedEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTwinJumpAudioMutedEffect>();
	}
};
static_assert(alignof(UTwinJumpAudioMutedEffect) == 0x000008, "Wrong alignment on UTwinJumpAudioMutedEffect");
static_assert(sizeof(UTwinJumpAudioMutedEffect) == 0x000380, "Wrong size on UTwinJumpAudioMutedEffect");

// Class TheTwins.AISkill_Interaction_RemoveTwin
// 0x0028 (0x02A8 - 0x0280)
class UAISkill_Interaction_RemoveTwin final : public UAISkill_Interaction
{
public:
	struct FDBDTunableRowHandle                   _removeTwinMaxCharge;                              // 0x0280(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_Interaction_RemoveTwin">();
	}
	static class UAISkill_Interaction_RemoveTwin* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_Interaction_RemoveTwin>();
	}
};
static_assert(alignof(UAISkill_Interaction_RemoveTwin) == 0x000008, "Wrong alignment on UAISkill_Interaction_RemoveTwin");
static_assert(sizeof(UAISkill_Interaction_RemoveTwin) == 0x0002A8, "Wrong size on UAISkill_Interaction_RemoveTwin");
static_assert(offsetof(UAISkill_Interaction_RemoveTwin, _removeTwinMaxCharge) == 0x000280, "Member 'UAISkill_Interaction_RemoveTwin::_removeTwinMaxCharge' has a wrong offset!");

// Class TheTwins.TwinJumpTargetVisibleEffect
// 0x0018 (0x0398 - 0x0380)
class UTwinJumpTargetVisibleEffect final : public UStatusEffect
{
public:
	TSubclassOf<class AActor>                     _twinJumpTargetObject;                             // 0x0380(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 _twinJumpTarget;                                   // 0x0388(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USelectiveVisibilityComponent*          _jumpTargetVisibility;                             // 0x0390(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnHideTargetPosition();
	void OnJumpTargetTick(const struct FVector& Location);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TwinJumpTargetVisibleEffect">();
	}
	static class UTwinJumpTargetVisibleEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTwinJumpTargetVisibleEffect>();
	}
};
static_assert(alignof(UTwinJumpTargetVisibleEffect) == 0x000008, "Wrong alignment on UTwinJumpTargetVisibleEffect");
static_assert(sizeof(UTwinJumpTargetVisibleEffect) == 0x000398, "Wrong size on UTwinJumpTargetVisibleEffect");
static_assert(offsetof(UTwinJumpTargetVisibleEffect, _twinJumpTargetObject) == 0x000380, "Member 'UTwinJumpTargetVisibleEffect::_twinJumpTargetObject' has a wrong offset!");
static_assert(offsetof(UTwinJumpTargetVisibleEffect, _twinJumpTarget) == 0x000388, "Member 'UTwinJumpTargetVisibleEffect::_twinJumpTarget' has a wrong offset!");
static_assert(offsetof(UTwinJumpTargetVisibleEffect, _jumpTargetVisibility) == 0x000390, "Member 'UTwinJumpTargetVisibleEffect::_jumpTargetVisibility' has a wrong offset!");

// Class TheTwins.PossessPlayer
// 0x0030 (0x08F0 - 0x08C0)
class UPossessPlayer : public UChargeableInteractionDefinition
{
public:
	struct FDBDTunableRowHandle                   _possessThePlayerMaxCharge;                        // 0x08C0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8E8[0x8];                                      // 0x08E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_OnPossessCancelled(class ADBDPlayer* Player);
	void Cosmetic_OnPossessStart(class ADBDPlayer* Player);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PossessPlayer">();
	}
	static class UPossessPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPossessPlayer>();
	}
};
static_assert(alignof(UPossessPlayer) == 0x000010, "Wrong alignment on UPossessPlayer");
static_assert(sizeof(UPossessPlayer) == 0x0008F0, "Wrong size on UPossessPlayer");
static_assert(offsetof(UPossessPlayer, _possessThePlayerMaxCharge) == 0x0008C0, "Member 'UPossessPlayer::_possessThePlayerMaxCharge' has a wrong offset!");

// Class TheTwins.PossessTheConjoinedTwin
// 0x0070 (0x0960 - 0x08F0)
class UPossessTheConjoinedTwin : public UPossessPlayer
{
public:
	uint8                                         Pad_8F0[0x70];                                     // 0x08F0(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPowerCollected(class ADBDPlayer* Collector);
	void OnTwinSet(class AConjoinedTwin* Twin);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PossessTheConjoinedTwin">();
	}
	static class UPossessTheConjoinedTwin* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPossessTheConjoinedTwin>();
	}
};
static_assert(alignof(UPossessTheConjoinedTwin) == 0x000010, "Wrong alignment on UPossessTheConjoinedTwin");
static_assert(sizeof(UPossessTheConjoinedTwin) == 0x000960, "Wrong size on UPossessTheConjoinedTwin");

// Class TheTwins.AutoPossessTheConjoinedTwin
// 0x0000 (0x0960 - 0x0960)
class UAutoPossessTheConjoinedTwin final : public UPossessTheConjoinedTwin
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AutoPossessTheConjoinedTwin">();
	}
	static class UAutoPossessTheConjoinedTwin* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAutoPossessTheConjoinedTwin>();
	}
};
static_assert(alignof(UAutoPossessTheConjoinedTwin) == 0x000010, "Wrong alignment on UAutoPossessTheConjoinedTwin");
static_assert(sizeof(UAutoPossessTheConjoinedTwin) == 0x000960, "Wrong size on UAutoPossessTheConjoinedTwin");

// Class TheTwins.BeingPossessedInteraction
// 0x0090 (0x0950 - 0x08C0)
class UBeingPossessedInteraction : public UChargeableInteractionDefinition
{
public:
	class UCurveFloat*                            _wakeUpSpeedCurve;                                 // 0x08C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTunableStat                           _beingPossessedMaxCharge;                          // 0x08C8(0x0080)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_948[0x8];                                      // 0x0948(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnLevelReadyToPlay();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BeingPossessedInteraction">();
	}
	static class UBeingPossessedInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBeingPossessedInteraction>();
	}
};
static_assert(alignof(UBeingPossessedInteraction) == 0x000010, "Wrong alignment on UBeingPossessedInteraction");
static_assert(sizeof(UBeingPossessedInteraction) == 0x000950, "Wrong size on UBeingPossessedInteraction");
static_assert(offsetof(UBeingPossessedInteraction, _wakeUpSpeedCurve) == 0x0008C0, "Member 'UBeingPossessedInteraction::_wakeUpSpeedCurve' has a wrong offset!");
static_assert(offsetof(UBeingPossessedInteraction, _beingPossessedMaxCharge) == 0x0008C8, "Member 'UBeingPossessedInteraction::_beingPossessedMaxCharge' has a wrong offset!");

// Class TheTwins.BrotherBlindFlashlightableLightingStrategy
// 0x0018 (0x0068 - 0x0050)
class UBrotherBlindFlashlightableLightingStrategy final : public UBlindFlashlightableLightingStrategy
{
public:
	uint8                                         Pad_50[0x18];                                      // 0x0050(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrotherBlindFlashlightableLightingStrategy">();
	}
	static class UBrotherBlindFlashlightableLightingStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrotherBlindFlashlightableLightingStrategy>();
	}
};
static_assert(alignof(UBrotherBlindFlashlightableLightingStrategy) == 0x000008, "Wrong alignment on UBrotherBlindFlashlightableLightingStrategy");
static_assert(sizeof(UBrotherBlindFlashlightableLightingStrategy) == 0x000068, "Wrong size on UBrotherBlindFlashlightableLightingStrategy");

// Class TheTwins.ChargeTwinJumpInteraction
// 0x0150 (0x0A10 - 0x08C0)
class UChargeTwinJumpInteraction final : public UChargeableInteractionDefinition
{
public:
	uint8                                         Pad_8C0[0x48];                                     // 0x08C0(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _chargeJumpMaxCharge;                              // 0x0908(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _interactionViewPitchMax;                          // 0x0930(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _interactionViewPitchMin;                          // 0x0958(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_980[0x30];                                     // 0x0980(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _cancelCooldownTime;                               // 0x09B0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_9D8[0x38];                                     // 0x09D8(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_OnJumpReadyChanged(class ADBDPlayer* Twin, const bool Ready);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChargeTwinJumpInteraction">();
	}
	static class UChargeTwinJumpInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChargeTwinJumpInteraction>();
	}
};
static_assert(alignof(UChargeTwinJumpInteraction) == 0x000010, "Wrong alignment on UChargeTwinJumpInteraction");
static_assert(sizeof(UChargeTwinJumpInteraction) == 0x000A10, "Wrong size on UChargeTwinJumpInteraction");
static_assert(offsetof(UChargeTwinJumpInteraction, _chargeJumpMaxCharge) == 0x000908, "Member 'UChargeTwinJumpInteraction::_chargeJumpMaxCharge' has a wrong offset!");
static_assert(offsetof(UChargeTwinJumpInteraction, _interactionViewPitchMax) == 0x000930, "Member 'UChargeTwinJumpInteraction::_interactionViewPitchMax' has a wrong offset!");
static_assert(offsetof(UChargeTwinJumpInteraction, _interactionViewPitchMin) == 0x000958, "Member 'UChargeTwinJumpInteraction::_interactionViewPitchMin' has a wrong offset!");
static_assert(offsetof(UChargeTwinJumpInteraction, _cancelCooldownTime) == 0x0009B0, "Member 'UChargeTwinJumpInteraction::_cancelCooldownTime' has a wrong offset!");

// Class TheTwins.ConjoinedTwin
// 0x0200 (0x1740 - 0x1540)
class AConjoinedTwin final : public ADBDPlayer
{
public:
	class URangeToActorsTrackerComponent*         _restrictedPossessionAreaTracker;                  // 0x1540(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTwinOutlineUpdateStrategy*             _twinOutlineUpdateStrategy;                        // 0x1548(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkComponent*                           _twinLullabyAudioComponent;                        // 0x1550(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UKillerBlindingFXComponent*             _twinBlindingFX;                                   // 0x1558(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TwinNoiseRange;                                    // 0x1560(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1564[0x4];                                     // 0x1564(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCustomizedAudioComponent*              _customizedAudio;                                  // 0x1568(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDBDAttackerComponent*                  _attackerComponent;                                // 0x1570(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _maxWalkSpeed;                                     // 0x1578(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class UHitValidatorComponent*                 _hitValidator;                                     // 0x15A0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHitValidatorConfigurator*              _hitValidationConfigurator;                        // 0x15A8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _gravityScale;                                     // 0x15B0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class UAnimationMontageSlave*                 _animationFollower;                                // 0x15D8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_15E0[0x20];                                    // 0x15E0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _revealDurationOnAttached;                         // 0x1600(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class UTwinFirstPersonViewComponent*          _firstPersonViewComponent;                         // 0x1628(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFlashlightableComponent*               _eyesFlashlightable;                               // 0x1630(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBlindFlashlightTargetFXComponent*      _blindFlashlightTargetFXComponent;                 // 0x1638(0x0008)(Edit, ExportObject, ZeroConstructor, Transient, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URangedExplosiveEffectHandlerComponent* _rangedExplosiveEffectHandlerComponent;            // 0x1640(0x0008)(Edit, ExportObject, ZeroConstructor, Transient, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1648[0x8];                                     // 0x1648(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFastTimer                             _flashlightBlindEvasionScoreTimer;                 // 0x1650(0x0030)(Transient, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _flashlightEvasionScoreCooldown;                   // 0x1680(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _hideFootstepsEffect;                              // 0x16A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _twinsBloodhoundEffect;                            // 0x16B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _twinsRevealKillerAuraEffect;                      // 0x16B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _twinsDormantKillerInstinctEffect;                 // 0x16C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _twinsRevealAuraOnAttachedToSurvivorEffect;        // 0x16C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _twinsRevealAuraOnRecallReadyEffect;               // 0x16D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _timeDeafenedOnTriggerEffect;                      // 0x16D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTwinPossessNegationEffectComponent*    _twinPossessNegationEffectComponent;               // 0x16E0(0x0008)(Edit, ExportObject, ZeroConstructor, Transient, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_16E8[0x58];                                    // 0x16E8(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnFirecrackerInRangeBegin(const struct FRangedExplosiveEffectData& EffectData);
	void Cosmetic_OnOnGroundUncontrolledChanged(bool OnGroundAndUncontrolled);
	void OnFinishedPlayingEvent(const struct FGameplayTag& GameEventType, const struct FGameEventData& GameEventData);
	void Server_SendAttackInput(bool Pressed);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConjoinedTwin">();
	}
	static class AConjoinedTwin* GetDefaultObj()
	{
		return GetDefaultObjImpl<AConjoinedTwin>();
	}
};
static_assert(alignof(AConjoinedTwin) == 0x000010, "Wrong alignment on AConjoinedTwin");
static_assert(sizeof(AConjoinedTwin) == 0x001740, "Wrong size on AConjoinedTwin");
static_assert(offsetof(AConjoinedTwin, _restrictedPossessionAreaTracker) == 0x001540, "Member 'AConjoinedTwin::_restrictedPossessionAreaTracker' has a wrong offset!");
static_assert(offsetof(AConjoinedTwin, _twinOutlineUpdateStrategy) == 0x001548, "Member 'AConjoinedTwin::_twinOutlineUpdateStrategy' has a wrong offset!");
static_assert(offsetof(AConjoinedTwin, _twinLullabyAudioComponent) == 0x001550, "Member 'AConjoinedTwin::_twinLullabyAudioComponent' has a wrong offset!");
static_assert(offsetof(AConjoinedTwin, _twinBlindingFX) == 0x001558, "Member 'AConjoinedTwin::_twinBlindingFX' has a wrong offset!");
static_assert(offsetof(AConjoinedTwin, TwinNoiseRange) == 0x001560, "Member 'AConjoinedTwin::TwinNoiseRange' has a wrong offset!");
static_assert(offsetof(AConjoinedTwin, _customizedAudio) == 0x001568, "Member 'AConjoinedTwin::_customizedAudio' has a wrong offset!");
static_assert(offsetof(AConjoinedTwin, _attackerComponent) == 0x001570, "Member 'AConjoinedTwin::_attackerComponent' has a wrong offset!");
static_assert(offsetof(AConjoinedTwin, _maxWalkSpeed) == 0x001578, "Member 'AConjoinedTwin::_maxWalkSpeed' has a wrong offset!");
static_assert(offsetof(AConjoinedTwin, _hitValidator) == 0x0015A0, "Member 'AConjoinedTwin::_hitValidator' has a wrong offset!");
static_assert(offsetof(AConjoinedTwin, _hitValidationConfigurator) == 0x0015A8, "Member 'AConjoinedTwin::_hitValidationConfigurator' has a wrong offset!");
static_assert(offsetof(AConjoinedTwin, _gravityScale) == 0x0015B0, "Member 'AConjoinedTwin::_gravityScale' has a wrong offset!");
static_assert(offsetof(AConjoinedTwin, _animationFollower) == 0x0015D8, "Member 'AConjoinedTwin::_animationFollower' has a wrong offset!");
static_assert(offsetof(AConjoinedTwin, _revealDurationOnAttached) == 0x001600, "Member 'AConjoinedTwin::_revealDurationOnAttached' has a wrong offset!");
static_assert(offsetof(AConjoinedTwin, _firstPersonViewComponent) == 0x001628, "Member 'AConjoinedTwin::_firstPersonViewComponent' has a wrong offset!");
static_assert(offsetof(AConjoinedTwin, _eyesFlashlightable) == 0x001630, "Member 'AConjoinedTwin::_eyesFlashlightable' has a wrong offset!");
static_assert(offsetof(AConjoinedTwin, _blindFlashlightTargetFXComponent) == 0x001638, "Member 'AConjoinedTwin::_blindFlashlightTargetFXComponent' has a wrong offset!");
static_assert(offsetof(AConjoinedTwin, _rangedExplosiveEffectHandlerComponent) == 0x001640, "Member 'AConjoinedTwin::_rangedExplosiveEffectHandlerComponent' has a wrong offset!");
static_assert(offsetof(AConjoinedTwin, _flashlightBlindEvasionScoreTimer) == 0x001650, "Member 'AConjoinedTwin::_flashlightBlindEvasionScoreTimer' has a wrong offset!");
static_assert(offsetof(AConjoinedTwin, _flashlightEvasionScoreCooldown) == 0x001680, "Member 'AConjoinedTwin::_flashlightEvasionScoreCooldown' has a wrong offset!");
static_assert(offsetof(AConjoinedTwin, _hideFootstepsEffect) == 0x0016A8, "Member 'AConjoinedTwin::_hideFootstepsEffect' has a wrong offset!");
static_assert(offsetof(AConjoinedTwin, _twinsBloodhoundEffect) == 0x0016B0, "Member 'AConjoinedTwin::_twinsBloodhoundEffect' has a wrong offset!");
static_assert(offsetof(AConjoinedTwin, _twinsRevealKillerAuraEffect) == 0x0016B8, "Member 'AConjoinedTwin::_twinsRevealKillerAuraEffect' has a wrong offset!");
static_assert(offsetof(AConjoinedTwin, _twinsDormantKillerInstinctEffect) == 0x0016C0, "Member 'AConjoinedTwin::_twinsDormantKillerInstinctEffect' has a wrong offset!");
static_assert(offsetof(AConjoinedTwin, _twinsRevealAuraOnAttachedToSurvivorEffect) == 0x0016C8, "Member 'AConjoinedTwin::_twinsRevealAuraOnAttachedToSurvivorEffect' has a wrong offset!");
static_assert(offsetof(AConjoinedTwin, _twinsRevealAuraOnRecallReadyEffect) == 0x0016D0, "Member 'AConjoinedTwin::_twinsRevealAuraOnRecallReadyEffect' has a wrong offset!");
static_assert(offsetof(AConjoinedTwin, _timeDeafenedOnTriggerEffect) == 0x0016D8, "Member 'AConjoinedTwin::_timeDeafenedOnTriggerEffect' has a wrong offset!");
static_assert(offsetof(AConjoinedTwin, _twinPossessNegationEffectComponent) == 0x0016E0, "Member 'AConjoinedTwin::_twinPossessNegationEffectComponent' has a wrong offset!");

// Class TheTwins.ConjoinedTwinAnimInstance
// 0x00E0 (0x06C0 - 0x05E0)
class UConjoinedTwinAnimInstance final : public UPlayerAnimInstance
{
public:
	class AConjoinedTwin*                         _owningConjoinedTwin;                              // 0x05D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _firstPersonView;                                  // 0x05E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5E1[0x3];                                      // 0x05E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _forwardVelocity;                                  // 0x05E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _lateralVelocity;                                  // 0x05E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EInteractionAnimation                         _interactionType;                                  // 0x05EC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isInAir;                                          // 0x05ED(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isIdle;                                           // 0x05EE(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5EF[0x1];                                      // 0x05EF(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _idleTime;                                         // 0x05F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isAttacking;                                      // 0x05F4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5F5[0x3];                                      // 0x05F5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UDBDAttackerComponent*                  _attackerComponent;                                // 0x05F8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTwinAttachmentComponent*               _twinAttachmentComponent;                          // 0x0600(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTwinLockerBlockerComponent*            _twinLockerBlockerComponent;                       // 0x0608(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _animYaw;                                          // 0x0610(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _animPitch;                                        // 0x0614(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isSpectator;                                      // 0x0618(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_619[0x3];                                      // 0x0619(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _animDirection;                                    // 0x061C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _animSpeed;                                        // 0x0620(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isAttachedToSister;                               // 0x0624(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isAttachedToSurvivor;                             // 0x0625(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isAttachedToFemaleSurvivor;                       // 0x0626(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isChargingTwinJump;                               // 0x0627(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isPossessing;                                     // 0x0628(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isWakingUpFromPossess;                            // 0x0629(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isDormant;                                        // 0x062A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isBeingAutoPossessedAfterRelease;                 // 0x062B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isAttachedToLocker;                               // 0x062C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAttackSubstate                               _attackState;                                      // 0x062D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_62E[0x92];                                     // 0x062E(0x0092)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	const class AConjoinedTwin* GetOwningConjoinedTwin() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConjoinedTwinAnimInstance">();
	}
	static class UConjoinedTwinAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConjoinedTwinAnimInstance>();
	}
};
static_assert(alignof(UConjoinedTwinAnimInstance) == 0x000010, "Wrong alignment on UConjoinedTwinAnimInstance");
static_assert(sizeof(UConjoinedTwinAnimInstance) == 0x0006C0, "Wrong size on UConjoinedTwinAnimInstance");
static_assert(offsetof(UConjoinedTwinAnimInstance, _owningConjoinedTwin) == 0x0005D8, "Member 'UConjoinedTwinAnimInstance::_owningConjoinedTwin' has a wrong offset!");
static_assert(offsetof(UConjoinedTwinAnimInstance, _firstPersonView) == 0x0005E0, "Member 'UConjoinedTwinAnimInstance::_firstPersonView' has a wrong offset!");
static_assert(offsetof(UConjoinedTwinAnimInstance, _forwardVelocity) == 0x0005E4, "Member 'UConjoinedTwinAnimInstance::_forwardVelocity' has a wrong offset!");
static_assert(offsetof(UConjoinedTwinAnimInstance, _lateralVelocity) == 0x0005E8, "Member 'UConjoinedTwinAnimInstance::_lateralVelocity' has a wrong offset!");
static_assert(offsetof(UConjoinedTwinAnimInstance, _interactionType) == 0x0005EC, "Member 'UConjoinedTwinAnimInstance::_interactionType' has a wrong offset!");
static_assert(offsetof(UConjoinedTwinAnimInstance, _isInAir) == 0x0005ED, "Member 'UConjoinedTwinAnimInstance::_isInAir' has a wrong offset!");
static_assert(offsetof(UConjoinedTwinAnimInstance, _isIdle) == 0x0005EE, "Member 'UConjoinedTwinAnimInstance::_isIdle' has a wrong offset!");
static_assert(offsetof(UConjoinedTwinAnimInstance, _idleTime) == 0x0005F0, "Member 'UConjoinedTwinAnimInstance::_idleTime' has a wrong offset!");
static_assert(offsetof(UConjoinedTwinAnimInstance, _isAttacking) == 0x0005F4, "Member 'UConjoinedTwinAnimInstance::_isAttacking' has a wrong offset!");
static_assert(offsetof(UConjoinedTwinAnimInstance, _attackerComponent) == 0x0005F8, "Member 'UConjoinedTwinAnimInstance::_attackerComponent' has a wrong offset!");
static_assert(offsetof(UConjoinedTwinAnimInstance, _twinAttachmentComponent) == 0x000600, "Member 'UConjoinedTwinAnimInstance::_twinAttachmentComponent' has a wrong offset!");
static_assert(offsetof(UConjoinedTwinAnimInstance, _twinLockerBlockerComponent) == 0x000608, "Member 'UConjoinedTwinAnimInstance::_twinLockerBlockerComponent' has a wrong offset!");
static_assert(offsetof(UConjoinedTwinAnimInstance, _animYaw) == 0x000610, "Member 'UConjoinedTwinAnimInstance::_animYaw' has a wrong offset!");
static_assert(offsetof(UConjoinedTwinAnimInstance, _animPitch) == 0x000614, "Member 'UConjoinedTwinAnimInstance::_animPitch' has a wrong offset!");
static_assert(offsetof(UConjoinedTwinAnimInstance, _isSpectator) == 0x000618, "Member 'UConjoinedTwinAnimInstance::_isSpectator' has a wrong offset!");
static_assert(offsetof(UConjoinedTwinAnimInstance, _animDirection) == 0x00061C, "Member 'UConjoinedTwinAnimInstance::_animDirection' has a wrong offset!");
static_assert(offsetof(UConjoinedTwinAnimInstance, _animSpeed) == 0x000620, "Member 'UConjoinedTwinAnimInstance::_animSpeed' has a wrong offset!");
static_assert(offsetof(UConjoinedTwinAnimInstance, _isAttachedToSister) == 0x000624, "Member 'UConjoinedTwinAnimInstance::_isAttachedToSister' has a wrong offset!");
static_assert(offsetof(UConjoinedTwinAnimInstance, _isAttachedToSurvivor) == 0x000625, "Member 'UConjoinedTwinAnimInstance::_isAttachedToSurvivor' has a wrong offset!");
static_assert(offsetof(UConjoinedTwinAnimInstance, _isAttachedToFemaleSurvivor) == 0x000626, "Member 'UConjoinedTwinAnimInstance::_isAttachedToFemaleSurvivor' has a wrong offset!");
static_assert(offsetof(UConjoinedTwinAnimInstance, _isChargingTwinJump) == 0x000627, "Member 'UConjoinedTwinAnimInstance::_isChargingTwinJump' has a wrong offset!");
static_assert(offsetof(UConjoinedTwinAnimInstance, _isPossessing) == 0x000628, "Member 'UConjoinedTwinAnimInstance::_isPossessing' has a wrong offset!");
static_assert(offsetof(UConjoinedTwinAnimInstance, _isWakingUpFromPossess) == 0x000629, "Member 'UConjoinedTwinAnimInstance::_isWakingUpFromPossess' has a wrong offset!");
static_assert(offsetof(UConjoinedTwinAnimInstance, _isDormant) == 0x00062A, "Member 'UConjoinedTwinAnimInstance::_isDormant' has a wrong offset!");
static_assert(offsetof(UConjoinedTwinAnimInstance, _isBeingAutoPossessedAfterRelease) == 0x00062B, "Member 'UConjoinedTwinAnimInstance::_isBeingAutoPossessedAfterRelease' has a wrong offset!");
static_assert(offsetof(UConjoinedTwinAnimInstance, _isAttachedToLocker) == 0x00062C, "Member 'UConjoinedTwinAnimInstance::_isAttachedToLocker' has a wrong offset!");
static_assert(offsetof(UConjoinedTwinAnimInstance, _attackState) == 0x00062D, "Member 'UConjoinedTwinAnimInstance::_attackState' has a wrong offset!");

// Class TheTwins.ConjoinedTwinInteractable
// 0x0028 (0x0408 - 0x03E0)
class AConjoinedTwinInteractable final : public APlayerInteractable
{
public:
	class UChargeableComponent*                   _possessKillerChargeable;                          // 0x03E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UChargeableComponent*                   _twinBeingPossessedChargeable;                     // 0x03E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UChargeableComponent*                   _chargeTwinJumpChargeable;                         // 0x03F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UChargeableComponent*                   _removeTwinChargeable;                             // 0x03F8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UChargeableComponent*                   _destroyTwinChargeable;                            // 0x0400(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConjoinedTwinInteractable">();
	}
	static class AConjoinedTwinInteractable* GetDefaultObj()
	{
		return GetDefaultObjImpl<AConjoinedTwinInteractable>();
	}
};
static_assert(alignof(AConjoinedTwinInteractable) == 0x000008, "Wrong alignment on AConjoinedTwinInteractable");
static_assert(sizeof(AConjoinedTwinInteractable) == 0x000408, "Wrong size on AConjoinedTwinInteractable");
static_assert(offsetof(AConjoinedTwinInteractable, _possessKillerChargeable) == 0x0003E0, "Member 'AConjoinedTwinInteractable::_possessKillerChargeable' has a wrong offset!");
static_assert(offsetof(AConjoinedTwinInteractable, _twinBeingPossessedChargeable) == 0x0003E8, "Member 'AConjoinedTwinInteractable::_twinBeingPossessedChargeable' has a wrong offset!");
static_assert(offsetof(AConjoinedTwinInteractable, _chargeTwinJumpChargeable) == 0x0003F0, "Member 'AConjoinedTwinInteractable::_chargeTwinJumpChargeable' has a wrong offset!");
static_assert(offsetof(AConjoinedTwinInteractable, _removeTwinChargeable) == 0x0003F8, "Member 'AConjoinedTwinInteractable::_removeTwinChargeable' has a wrong offset!");
static_assert(offsetof(AConjoinedTwinInteractable, _destroyTwinChargeable) == 0x000400, "Member 'AConjoinedTwinInteractable::_destroyTwinChargeable' has a wrong offset!");

// Class TheTwins.ConjoinedTwinStateMachine
// 0x0000 (0x0120 - 0x0120)
class UConjoinedTwinStateMachine final : public UPlayerStateMachine
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConjoinedTwinStateMachine">();
	}
	static class UConjoinedTwinStateMachine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConjoinedTwinStateMachine>();
	}
};
static_assert(alignof(UConjoinedTwinStateMachine) == 0x000010, "Wrong alignment on UConjoinedTwinStateMachine");
static_assert(sizeof(UConjoinedTwinStateMachine) == 0x000120, "Wrong size on UConjoinedTwinStateMachine");

// Class TheTwins.CoupDeGrace
// 0x0020 (0x0440 - 0x0420)
class UCoupDeGrace final : public UPerk
{
public:
	uint8                                         _tokenGainOnRepair;                                // 0x0420(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_421[0x3];                                      // 0x0421(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _lungeAttackAddDurationMultiplier[0x3];            // 0x0424(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class AGenerator*>                     _completedGenerators;                              // 0x0430(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CoupDeGrace">();
	}
	static class UCoupDeGrace* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCoupDeGrace>();
	}
};
static_assert(alignof(UCoupDeGrace) == 0x000008, "Wrong alignment on UCoupDeGrace");
static_assert(sizeof(UCoupDeGrace) == 0x000440, "Wrong size on UCoupDeGrace");
static_assert(offsetof(UCoupDeGrace, _tokenGainOnRepair) == 0x000420, "Member 'UCoupDeGrace::_tokenGainOnRepair' has a wrong offset!");
static_assert(offsetof(UCoupDeGrace, _lungeAttackAddDurationMultiplier) == 0x000424, "Member 'UCoupDeGrace::_lungeAttackAddDurationMultiplier' has a wrong offset!");
static_assert(offsetof(UCoupDeGrace, _completedGenerators) == 0x000430, "Member 'UCoupDeGrace::_completedGenerators' has a wrong offset!");

// Class TheTwins.DestroyTwin
// 0x0080 (0x0940 - 0x08C0)
class UDestroyTwin final : public UChargeableInteractionDefinition
{
public:
	uint8                                         Pad_8C0[0x50];                                     // 0x08C0(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _destroyTwinMaxCharge;                             // 0x0910(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_938[0x8];                                      // 0x0938(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DestroyTwin">();
	}
	static class UDestroyTwin* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDestroyTwin>();
	}
};
static_assert(alignof(UDestroyTwin) == 0x000010, "Wrong alignment on UDestroyTwin");
static_assert(sizeof(UDestroyTwin) == 0x000940, "Wrong size on UDestroyTwin");
static_assert(offsetof(UDestroyTwin, _destroyTwinMaxCharge) == 0x000910, "Member 'UDestroyTwin::_destroyTwinMaxCharge' has a wrong offset!");

// Class TheTwins.Hoarder
// 0x0050 (0x0470 - 0x0420)
class UHoarder final : public UPerk
{
public:
	uint8                                         Pad_420[0x8];                                      // 0x0420(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ASearchable*>                    _chests;                                           // 0x0428(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	float                                         _camperInteractItemPickupRevealRange[0x3];         // 0x0438(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         _extraChestsSpawned[0x3];                          // 0x0444(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _bubbleIndicatorLifetime[0x3];                     // 0x0450(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _showUniqueChestVisualPerState;                    // 0x045C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_45D[0x13];                                     // 0x045D(0x0013)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Local_ThrowBubbleIndicator(const EPerkInteractionObjectType CamperInteractionType, const class AActor* ObjectActor, const class ACamperPlayer* InteractingCamperPlayer);
	void OnItemAddedToPlayer(class ACollectable* Item, EInventoryType InventoryType, class ACamperPlayer* Player);
	void OnItemRemovedFromPlayer(class ACollectable* Item, EInventoryType InventoryType);

	float GetBubbleIndicatorLifetime() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Hoarder">();
	}
	static class UHoarder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHoarder>();
	}
};
static_assert(alignof(UHoarder) == 0x000008, "Wrong alignment on UHoarder");
static_assert(sizeof(UHoarder) == 0x000470, "Wrong size on UHoarder");
static_assert(offsetof(UHoarder, _chests) == 0x000428, "Member 'UHoarder::_chests' has a wrong offset!");
static_assert(offsetof(UHoarder, _camperInteractItemPickupRevealRange) == 0x000438, "Member 'UHoarder::_camperInteractItemPickupRevealRange' has a wrong offset!");
static_assert(offsetof(UHoarder, _extraChestsSpawned) == 0x000444, "Member 'UHoarder::_extraChestsSpawned' has a wrong offset!");
static_assert(offsetof(UHoarder, _bubbleIndicatorLifetime) == 0x000450, "Member 'UHoarder::_bubbleIndicatorLifetime' has a wrong offset!");
static_assert(offsetof(UHoarder, _showUniqueChestVisualPerState) == 0x00045C, "Member 'UHoarder::_showUniqueChestVisualPerState' has a wrong offset!");

// Class TheTwins.IsTwinRecallReady
// 0x0008 (0x00E8 - 0x00E0)
class UIsTwinRecallReady final : public UEventDrivenModifierCondition
{
public:
	uint8                                         Pad_E0[0x8];                                       // 0x00E0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnLevelReadyToPlay();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IsTwinRecallReady">();
	}
	static class UIsTwinRecallReady* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIsTwinRecallReady>();
	}
};
static_assert(alignof(UIsTwinRecallReady) == 0x000008, "Wrong alignment on UIsTwinRecallReady");
static_assert(sizeof(UIsTwinRecallReady) == 0x0000E8, "Wrong size on UIsTwinRecallReady");

// Class TheTwins.K22AchievementTagTeam
// 0x0010 (0x00B8 - 0x00A8)
class UK22AchievementTagTeam final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x10];                                      // 0x00A8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K22AchievementTagTeam">();
	}
	static class UK22AchievementTagTeam* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK22AchievementTagTeam>();
	}
};
static_assert(alignof(UK22AchievementTagTeam) == 0x000008, "Wrong alignment on UK22AchievementTagTeam");
static_assert(sizeof(UK22AchievementTagTeam) == 0x0000B8, "Wrong size on UK22AchievementTagTeam");

// Class TheTwins.K22Power
// 0x0220 (0x0770 - 0x0550)
class AK22Power final : public ACollectable
{
public:
	uint8                                         Pad_550[0x18];                                     // 0x0550(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UChargeableComponent*                   _releaseConjoinedTwinChargeable;                   // 0x0568(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UChargeableComponent*                   _possessConjoinedTwinChargeable;                   // 0x0570(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UStatusEffect>              _killerDormantStealthStatusEffectClass;            // 0x0578(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_580[0x18];                                     // 0x0580(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class AConjoinedTwin*                         _conjoinedTwin;                                    // 0x0598(0x0008)(Net, ZeroConstructor, Transient, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AConjoinedTwin*                         _conjoinedTwinParadise;                            // 0x05A0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPowerChargeComponent*                  _powerCharge;                                      // 0x05A8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UK22PowerChargePresentationItemProgressComponent* _powerChargePresentationItemProgress;              // 0x05B0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UK22PowerFadeComponent*                 _powerFadeComponent;                               // 0x05B8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _powerMaxCharge;                                   // 0x05C0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TSubclassOf<class AConjoinedTwin>             _conjoinedTwinClass;                               // 0x05E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5F0[0x10];                                     // 0x05F0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _defaultPowerRechargeTime;                         // 0x0600(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _powerRechargeTimeAfterTwinKicked;                 // 0x0628(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _timeBeforeAutoDestroy;                            // 0x0650(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _timeBeforeRecallFromDormant;                      // 0x0678(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _timeBeforeRecallFromAttachedSurvivor;             // 0x06A0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _timeBeforeRecallFromLocker;                       // 0x06C8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6F0[0x44];                                     // 0x06F0(0x0044)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _recallReady;                                      // 0x0734(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_735[0x3B];                                     // 0x0735(0x003B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnDestroyTwinChargePercentChanged(class UChargeableComponent* ChargeableComponent, float PercentCompletionChange, float TotalPercentComplete);
	void Authority_OnPossessTwinChargePercentChanged(class UChargeableComponent* ChargeableComponent, float PercentCompletionChange, float TotalPercentComplete);
	void Authority_TwinDestroyedBySurvivor(const struct FGameplayTag& GameplayTag, const struct FGameEventData& GameEventData);
	void OnFirstAttachmentToSister();
	void OnPowerChargeEmpty();
	void OnRep_ConjoinedTwin();
	void OnRep_RecallReady();

	class AConjoinedTwin* GetConjoinedTwin() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K22Power">();
	}
	static class AK22Power* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK22Power>();
	}
};
static_assert(alignof(AK22Power) == 0x000008, "Wrong alignment on AK22Power");
static_assert(sizeof(AK22Power) == 0x000770, "Wrong size on AK22Power");
static_assert(offsetof(AK22Power, _releaseConjoinedTwinChargeable) == 0x000568, "Member 'AK22Power::_releaseConjoinedTwinChargeable' has a wrong offset!");
static_assert(offsetof(AK22Power, _possessConjoinedTwinChargeable) == 0x000570, "Member 'AK22Power::_possessConjoinedTwinChargeable' has a wrong offset!");
static_assert(offsetof(AK22Power, _killerDormantStealthStatusEffectClass) == 0x000578, "Member 'AK22Power::_killerDormantStealthStatusEffectClass' has a wrong offset!");
static_assert(offsetof(AK22Power, _conjoinedTwin) == 0x000598, "Member 'AK22Power::_conjoinedTwin' has a wrong offset!");
static_assert(offsetof(AK22Power, _conjoinedTwinParadise) == 0x0005A0, "Member 'AK22Power::_conjoinedTwinParadise' has a wrong offset!");
static_assert(offsetof(AK22Power, _powerCharge) == 0x0005A8, "Member 'AK22Power::_powerCharge' has a wrong offset!");
static_assert(offsetof(AK22Power, _powerChargePresentationItemProgress) == 0x0005B0, "Member 'AK22Power::_powerChargePresentationItemProgress' has a wrong offset!");
static_assert(offsetof(AK22Power, _powerFadeComponent) == 0x0005B8, "Member 'AK22Power::_powerFadeComponent' has a wrong offset!");
static_assert(offsetof(AK22Power, _powerMaxCharge) == 0x0005C0, "Member 'AK22Power::_powerMaxCharge' has a wrong offset!");
static_assert(offsetof(AK22Power, _conjoinedTwinClass) == 0x0005E8, "Member 'AK22Power::_conjoinedTwinClass' has a wrong offset!");
static_assert(offsetof(AK22Power, _defaultPowerRechargeTime) == 0x000600, "Member 'AK22Power::_defaultPowerRechargeTime' has a wrong offset!");
static_assert(offsetof(AK22Power, _powerRechargeTimeAfterTwinKicked) == 0x000628, "Member 'AK22Power::_powerRechargeTimeAfterTwinKicked' has a wrong offset!");
static_assert(offsetof(AK22Power, _timeBeforeAutoDestroy) == 0x000650, "Member 'AK22Power::_timeBeforeAutoDestroy' has a wrong offset!");
static_assert(offsetof(AK22Power, _timeBeforeRecallFromDormant) == 0x000678, "Member 'AK22Power::_timeBeforeRecallFromDormant' has a wrong offset!");
static_assert(offsetof(AK22Power, _timeBeforeRecallFromAttachedSurvivor) == 0x0006A0, "Member 'AK22Power::_timeBeforeRecallFromAttachedSurvivor' has a wrong offset!");
static_assert(offsetof(AK22Power, _timeBeforeRecallFromLocker) == 0x0006C8, "Member 'AK22Power::_timeBeforeRecallFromLocker' has a wrong offset!");
static_assert(offsetof(AK22Power, _recallReady) == 0x000734, "Member 'AK22Power::_recallReady' has a wrong offset!");

// Class TheTwins.K22PowerChargePresentationItemProgressComponent
// 0x0020 (0x00D0 - 0x00B0)
class UK22PowerChargePresentationItemProgressComponent final : public UPresentationItemProgressComponent
{
public:
	class UPowerChargeComponent*                  _powerChargeComponent;                             // 0x00B0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B8[0x18];                                      // 0x00B8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnTwinSet(class AConjoinedTwin* Twin);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K22PowerChargePresentationItemProgressComponent">();
	}
	static class UK22PowerChargePresentationItemProgressComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK22PowerChargePresentationItemProgressComponent>();
	}
};
static_assert(alignof(UK22PowerChargePresentationItemProgressComponent) == 0x000008, "Wrong alignment on UK22PowerChargePresentationItemProgressComponent");
static_assert(sizeof(UK22PowerChargePresentationItemProgressComponent) == 0x0000D0, "Wrong size on UK22PowerChargePresentationItemProgressComponent");
static_assert(offsetof(UK22PowerChargePresentationItemProgressComponent, _powerChargeComponent) == 0x0000B0, "Member 'UK22PowerChargePresentationItemProgressComponent::_powerChargeComponent' has a wrong offset!");

// Class TheTwins.K22PowerFadeComponent
// 0x0020 (0x00C8 - 0x00A8)
class UK22PowerFadeComponent final : public UPresentationPowerFadeComponent
{
public:
	class UPowerChargeComponent*                  _powerChargeComponent;                             // 0x00A8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B0[0x18];                                      // 0x00B0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K22PowerFadeComponent">();
	}
	static class UK22PowerFadeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK22PowerFadeComponent>();
	}
};
static_assert(alignof(UK22PowerFadeComponent) == 0x000008, "Wrong alignment on UK22PowerFadeComponent");
static_assert(sizeof(UK22PowerFadeComponent) == 0x0000C8, "Wrong size on UK22PowerFadeComponent");
static_assert(offsetof(UK22PowerFadeComponent, _powerChargeComponent) == 0x0000A8, "Member 'UK22PowerFadeComponent::_powerChargeComponent' has a wrong offset!");

// Class TheTwins.K22ScoreComponent
// 0x0010 (0x00B8 - 0x00A8)
class UK22ScoreComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x10];                                      // 0x00A8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K22ScoreComponent">();
	}
	static class UK22ScoreComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK22ScoreComponent>();
	}
};
static_assert(alignof(UK22ScoreComponent) == 0x000008, "Wrong alignment on UK22ScoreComponent");
static_assert(sizeof(UK22ScoreComponent) == 0x0000B8, "Wrong size on UK22ScoreComponent");

// Class TheTwins.KillerBeingPossessedInteraction
// 0x0000 (0x0950 - 0x0950)
class UKillerBeingPossessedInteraction final : public UBeingPossessedInteraction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerBeingPossessedInteraction">();
	}
	static class UKillerBeingPossessedInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillerBeingPossessedInteraction>();
	}
};
static_assert(alignof(UKillerBeingPossessedInteraction) == 0x000010, "Wrong alignment on UKillerBeingPossessedInteraction");
static_assert(sizeof(UKillerBeingPossessedInteraction) == 0x000950, "Wrong size on UKillerBeingPossessedInteraction");

// Class TheTwins.PossessionComponent
// 0x00A8 (0x0150 - 0x00A8)
class UPossessionComponent : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x79];                                      // 0x00A8(0x0079)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _startPossessed;                                   // 0x0121(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_122[0x6];                                      // 0x0122(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class AAIController*                          _emptyController;                                  // 0x0128(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_130[0x20];                                     // 0x0130(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Client_StartStateMachineDriverChangeProcess();
	void Client_WaitForBeingPossessedInteractionToStart();
	void Cosmetic_OnControlledChanged(class ADBDPlayer* Player, bool IsControlled);
	void CosmeticLocal_OnControlled(class ADBDPlayer* Player);
	void CosmeticLocal_OnUncontrolled(class ADBDPlayer* Player);
	void Multicast_NotifyPossessionDone();
	void Multicast_StartPossessionOf(class ADBDPlayer* PlayerToPossess);
	void OnLevelReadyToPlay();
	void Server_NotifyBeingPossessedInteractionStarted();
	void Server_NotifyPossessionDone();
	void Server_StartPossessionOf(class ADBDPlayer* PlayerToPossess, bool ShouldStartBeingPossessedInteraction);

	bool IsDormant() const;
	bool IsPossessed() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PossessionComponent">();
	}
	static class UPossessionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPossessionComponent>();
	}
};
static_assert(alignof(UPossessionComponent) == 0x000008, "Wrong alignment on UPossessionComponent");
static_assert(sizeof(UPossessionComponent) == 0x000150, "Wrong size on UPossessionComponent");
static_assert(offsetof(UPossessionComponent, _startPossessed) == 0x000121, "Member 'UPossessionComponent::_startPossessed' has a wrong offset!");
static_assert(offsetof(UPossessionComponent, _emptyController) == 0x000128, "Member 'UPossessionComponent::_emptyController' has a wrong offset!");

// Class TheTwins.KillerPossessionComponent
// 0x0060 (0x01B0 - 0x0150)
class UKillerPossessionComponent final : public UPossessionComponent
{
public:
	bool                                          _shouldDeactivateCollisionsWithSurvivors;          // 0x0150(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_151[0x37];                                     // 0x0151(0x0037)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _timeBeforeCollisionsDeactivation;                 // 0x0188(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	void OnRep_ShouldDeactivateCollisionsWithSurvivors();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerPossessionComponent">();
	}
	static class UKillerPossessionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillerPossessionComponent>();
	}
};
static_assert(alignof(UKillerPossessionComponent) == 0x000008, "Wrong alignment on UKillerPossessionComponent");
static_assert(sizeof(UKillerPossessionComponent) == 0x0001B0, "Wrong size on UKillerPossessionComponent");
static_assert(offsetof(UKillerPossessionComponent, _shouldDeactivateCollisionsWithSurvivors) == 0x000150, "Member 'UKillerPossessionComponent::_shouldDeactivateCollisionsWithSurvivors' has a wrong offset!");
static_assert(offsetof(UKillerPossessionComponent, _timeBeforeCollisionsDeactivation) == 0x000188, "Member 'UKillerPossessionComponent::_timeBeforeCollisionsDeactivation' has a wrong offset!");

// Class TheTwins.PossessNegationEffectComponent
// 0x0018 (0x00C0 - 0x00A8)
class UPossessNegationEffectComponent : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             PlayCantPossessSound;                              // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnLevelReadyToPlay();
	void PlayCantPossessSound__DelegateSignature();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PossessNegationEffectComponent">();
	}
	static class UPossessNegationEffectComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPossessNegationEffectComponent>();
	}
};
static_assert(alignof(UPossessNegationEffectComponent) == 0x000008, "Wrong alignment on UPossessNegationEffectComponent");
static_assert(sizeof(UPossessNegationEffectComponent) == 0x0000C0, "Wrong size on UPossessNegationEffectComponent");
static_assert(offsetof(UPossessNegationEffectComponent, PlayCantPossessSound) == 0x0000A8, "Member 'UPossessNegationEffectComponent::PlayCantPossessSound' has a wrong offset!");

// Class TheTwins.KillerPossessNegationEffectComponent
// 0x0028 (0x00E8 - 0x00C0)
class UKillerPossessNegationEffectComponent final : public UPossessNegationEffectComponent
{
public:
	uint8                                         Pad_C0[0x28];                                      // 0x00C0(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnTwinSet(class AConjoinedTwin* Twin);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerPossessNegationEffectComponent">();
	}
	static class UKillerPossessNegationEffectComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillerPossessNegationEffectComponent>();
	}
};
static_assert(alignof(UKillerPossessNegationEffectComponent) == 0x000008, "Wrong alignment on UKillerPossessNegationEffectComponent");
static_assert(sizeof(UKillerPossessNegationEffectComponent) == 0x0000E8, "Wrong size on UKillerPossessNegationEffectComponent");

// Class TheTwins.Oppression
// 0x0018 (0x0438 - 0x0420)
class UOppression final : public UPerk
{
public:
	int32                                         _nbGeneratorsAffectedByPerk[0x3];                  // 0x0420(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         _perkCooldown[0x3];                                // 0x042C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	float GetNumberGensAffectedByPerkAtLevel() const;
	float GetPerkCooldownAtLevel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Oppression">();
	}
	static class UOppression* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOppression>();
	}
};
static_assert(alignof(UOppression) == 0x000008, "Wrong alignment on UOppression");
static_assert(sizeof(UOppression) == 0x000438, "Wrong size on UOppression");
static_assert(offsetof(UOppression, _nbGeneratorsAffectedByPerk) == 0x000420, "Member 'UOppression::_nbGeneratorsAffectedByPerk' has a wrong offset!");
static_assert(offsetof(UOppression, _perkCooldown) == 0x00042C, "Member 'UOppression::_perkCooldown' has a wrong offset!");

// Class TheTwins.PossessTheKiller
// 0x0040 (0x0930 - 0x08F0)
class UPossessTheKiller final : public UPossessPlayer
{
public:
	uint8                                         Pad_8F0[0x40];                                     // 0x08F0(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PossessTheKiller">();
	}
	static class UPossessTheKiller* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPossessTheKiller>();
	}
};
static_assert(alignof(UPossessTheKiller) == 0x000010, "Wrong alignment on UPossessTheKiller");
static_assert(sizeof(UPossessTheKiller) == 0x000930, "Wrong size on UPossessTheKiller");

// Class TheTwins.PushTwinOnLockerInteraction
// 0x0060 (0x0920 - 0x08C0)
class UPushTwinOnLockerInteraction final : public UChargeableInteractionDefinition
{
public:
	class UChargeableComponent*                   _pushTwinOnLockerChargeable;                       // 0x08C0(0x0008)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _pushTwinOnLockerMaxCharge;                        // 0x08C8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8F0[0x30];                                     // 0x08F0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnPlayerInLockerChanged(class ADBDPlayer* PreviousPlayerInLocker, class ADBDPlayer* NewPlayerInLocker);
	void OnRep_PushTwinOnLockerChargeable();
	void OnTwinSet(class AConjoinedTwin* Twin);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PushTwinOnLockerInteraction">();
	}
	static class UPushTwinOnLockerInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPushTwinOnLockerInteraction>();
	}
};
static_assert(alignof(UPushTwinOnLockerInteraction) == 0x000010, "Wrong alignment on UPushTwinOnLockerInteraction");
static_assert(sizeof(UPushTwinOnLockerInteraction) == 0x000920, "Wrong size on UPushTwinOnLockerInteraction");
static_assert(offsetof(UPushTwinOnLockerInteraction, _pushTwinOnLockerChargeable) == 0x0008C0, "Member 'UPushTwinOnLockerInteraction::_pushTwinOnLockerChargeable' has a wrong offset!");
static_assert(offsetof(UPushTwinOnLockerInteraction, _pushTwinOnLockerMaxCharge) == 0x0008C8, "Member 'UPushTwinOnLockerInteraction::_pushTwinOnLockerMaxCharge' has a wrong offset!");

// Class TheTwins.RecallTwin
// 0x0030 (0x07B0 - 0x0780)
class URecallTwin final : public UInteractionDefinition
{
public:
	uint8                                         Pad_778[0x38];                                     // 0x0778(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnTwinSet(class AConjoinedTwin* Twin);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RecallTwin">();
	}
	static class URecallTwin* GetDefaultObj()
	{
		return GetDefaultObjImpl<URecallTwin>();
	}
};
static_assert(alignof(URecallTwin) == 0x000010, "Wrong alignment on URecallTwin");
static_assert(sizeof(URecallTwin) == 0x0007B0, "Wrong size on URecallTwin");

// Class TheTwins.ReleaseConjoinedTwin
// 0x01A0 (0x0A60 - 0x08C0)
class UReleaseConjoinedTwin final : public UChargeableInteractionDefinition
{
public:
	struct FDBDTunableRowHandle                   _releaseMaxCharge;                                 // 0x08C0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _releaseExitTime;                                  // 0x08E8(0x0080)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_968[0x3C];                                     // 0x0968(0x003C)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _releaseAnimationWentToTheEnd;                     // 0x09A4(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_9A5[0xBB];                                     // 0x09A5(0x00BB)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_OnReleaseCancelled(class ADBDPlayer* Sister, class AConjoinedTwin* brother);
	void Cosmetic_OnReleaseChargeComplete(class ADBDPlayer* Sister, class AConjoinedTwin* brother);
	void Cosmetic_OnReleaseTwinInteractionUpdate(class ADBDPlayer* Sister, class AConjoinedTwin* brother, float DeltaTime);
	void Cosmetic_OnReleaseTwinInteractionUpdateStart(class ADBDPlayer* Sister, class AConjoinedTwin* brother);
	void OnKillerStunned(const struct FGameplayTag& GameEventType, const struct FGameEventData& GameEventData);
	void OnPowerCollected(class ADBDPlayer* Collector);
	void OnRep_ReleaseAnimationWentToTheEnd();
	void OnTwinSet(class AConjoinedTwin* Twin);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReleaseConjoinedTwin">();
	}
	static class UReleaseConjoinedTwin* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReleaseConjoinedTwin>();
	}
};
static_assert(alignof(UReleaseConjoinedTwin) == 0x000010, "Wrong alignment on UReleaseConjoinedTwin");
static_assert(sizeof(UReleaseConjoinedTwin) == 0x000A60, "Wrong size on UReleaseConjoinedTwin");
static_assert(offsetof(UReleaseConjoinedTwin, _releaseMaxCharge) == 0x0008C0, "Member 'UReleaseConjoinedTwin::_releaseMaxCharge' has a wrong offset!");
static_assert(offsetof(UReleaseConjoinedTwin, _releaseExitTime) == 0x0008E8, "Member 'UReleaseConjoinedTwin::_releaseExitTime' has a wrong offset!");
static_assert(offsetof(UReleaseConjoinedTwin, _releaseAnimationWentToTheEnd) == 0x0009A4, "Member 'UReleaseConjoinedTwin::_releaseAnimationWentToTheEnd' has a wrong offset!");

// Class TheTwins.RemoveTwin
// 0x00A0 (0x0960 - 0x08C0)
class URemoveTwin final : public UChargeableInteractionDefinition
{
public:
	uint8                                         Pad_8C0[0x40];                                     // 0x08C0(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _removeTwinMaxCharge;                              // 0x0900(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _removeTwinExitTime;                               // 0x0928(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	float                                         _brotherRemoveDistanceFromSurvivor;                // 0x0950(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_954[0xC];                                      // 0x0954(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRemoveMontageEnd(const struct FAnimationMontageDescriptor& Montage, bool Interrupted, class ADBDPlayer* DestroyingPlayer);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RemoveTwin">();
	}
	static class URemoveTwin* GetDefaultObj()
	{
		return GetDefaultObjImpl<URemoveTwin>();
	}
};
static_assert(alignof(URemoveTwin) == 0x000010, "Wrong alignment on URemoveTwin");
static_assert(sizeof(URemoveTwin) == 0x000960, "Wrong size on URemoveTwin");
static_assert(offsetof(URemoveTwin, _removeTwinMaxCharge) == 0x000900, "Member 'URemoveTwin::_removeTwinMaxCharge' has a wrong offset!");
static_assert(offsetof(URemoveTwin, _removeTwinExitTime) == 0x000928, "Member 'URemoveTwin::_removeTwinExitTime' has a wrong offset!");
static_assert(offsetof(URemoveTwin, _brotherRemoveDistanceFromSurvivor) == 0x000950, "Member 'URemoveTwin::_brotherRemoveDistanceFromSurvivor' has a wrong offset!");

// Class TheTwins.SisterBlindFlashlightableLightingStrategy
// 0x0038 (0x0088 - 0x0050)
class USisterBlindFlashlightableLightingStrategy final : public UBlindFlashlightableLightingStrategy
{
public:
	uint8                                         Pad_50[0x38];                                      // 0x0050(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnTwinSet(class AConjoinedTwin* Twin);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SisterBlindFlashlightableLightingStrategy">();
	}
	static class USisterBlindFlashlightableLightingStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<USisterBlindFlashlightableLightingStrategy>();
	}
};
static_assert(alignof(USisterBlindFlashlightableLightingStrategy) == 0x000008, "Wrong alignment on USisterBlindFlashlightableLightingStrategy");
static_assert(sizeof(USisterBlindFlashlightableLightingStrategy) == 0x000088, "Wrong size on USisterBlindFlashlightableLightingStrategy");

// Class TheTwins.TheTwinsCheatComponent
// 0x0000 (0x00A8 - 0x00A8)
class UTheTwinsCheatComponent final : public UActorComponent
{
public:
	void DBD_TwinDestroyTheTwin();
	void Multicast_TrySendThePlayerBackInKiller(class UTwinPossessionComponent* TwinPossessionComponent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TheTwinsCheatComponent">();
	}
	static class UTheTwinsCheatComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTheTwinsCheatComponent>();
	}
};
static_assert(alignof(UTheTwinsCheatComponent) == 0x000008, "Wrong alignment on UTheTwinsCheatComponent");
static_assert(sizeof(UTheTwinsCheatComponent) == 0x0000A8, "Wrong size on UTheTwinsCheatComponent");

// Class TheTwins.TwinAOELingeringStatusEffect
// 0x00A0 (0x0488 - 0x03E8)
class UTwinAOELingeringStatusEffect final : public UBaseLingeringStatusEffect
{
public:
	struct FTunableStat                           _shriekingRange;                                   // 0x03E8(0x0080)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_468[0x20];                                     // 0x0468(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnInRangeChanged(const bool InRange);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TwinAOELingeringStatusEffect">();
	}
	static class UTwinAOELingeringStatusEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTwinAOELingeringStatusEffect>();
	}
};
static_assert(alignof(UTwinAOELingeringStatusEffect) == 0x000008, "Wrong alignment on UTwinAOELingeringStatusEffect");
static_assert(sizeof(UTwinAOELingeringStatusEffect) == 0x000488, "Wrong size on UTwinAOELingeringStatusEffect");
static_assert(offsetof(UTwinAOELingeringStatusEffect, _shriekingRange) == 0x0003E8, "Member 'UTwinAOELingeringStatusEffect::_shriekingRange' has a wrong offset!");

// Class TheTwins.TwinAttachmentComponent
// 0x01D0 (0x0278 - 0x00A8)
class UTwinAttachmentComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x40];                                      // 0x00A8(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	class ADBDPlayer*                             _attachedPlayer;                                   // 0x00E8(0x0008)(Net, ZeroConstructor, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F0[0x80];                                      // 0x00F0(0x0080)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UStatusEffect>              _gateBlockerEffectClass;                           // 0x0170(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _graspBrokenEffectClass;                           // 0x0178(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _graspIncapacitatedEffectClass;                    // 0x0180(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _graspObliviousEffectClass;                        // 0x0188(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _graspKillerInstinctEffectClass;                   // 0x0190(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStatusEffect*                          _gateBlockerStatusEffect;                          // 0x0198(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1A0[0x12];                                     // 0x01A0(0x0012)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _hasBeenDetachedBySurvivorDamageChanged;           // 0x01B2(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1B3[0x5];                                      // 0x01B3(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _cantEscapeByGateLingerDuration;                   // 0x01B8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TMap<class ADBDPlayer*, struct FFastTimer>    _escapeBlockerLingerTimers;                        // 0x01E0(0x0050)(Transient, NativeAccessSpecifierPrivate)
	struct FGameplayTagContainer                  _notCancelableInteractionTags;                     // 0x0230(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_250[0x28];                                     // 0x0250(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnRemoveTwinChargePercentChanged(class UChargeableComponent* ChargeableComponent, float PercentCompletionChange, float TotalPercentComplete);
	void Cosmetic_OnTwinAttachedToSister(class ADBDPlayer* Sister, class ADBDPlayer* brother, bool IsFirstAttachment);
	void Cosmetic_OnTwinAttachedToSurvivor(class ADBDPlayer* Survivor, class ADBDPlayer* brother);
	void Cosmetic_OnTwinDetachedFromSister(class ADBDPlayer* Sister, class ADBDPlayer* brother);
	void Cosmetic_OnTwinDetachedFromSurvivor(class ADBDPlayer* Survivor, class ADBDPlayer* brother);
	void Multicast_QuickDestroyTwin();
	void OnAttachedSurvivorDamageStateChanged(const ECamperDamageState OldState, const ECamperDamageState NewState);
	void OnLevelReadyToPlay();
	void OnMoriMontageEnd(const struct FAnimationMontageDescriptor& Montage, bool Interrupted);
	void OnRep_AttachedPlayer(class ADBDPlayer* OldAttachedPlayer);

	bool IsAttachedToSister() const;
	bool IsAttachedToSurvivor() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TwinAttachmentComponent">();
	}
	static class UTwinAttachmentComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTwinAttachmentComponent>();
	}
};
static_assert(alignof(UTwinAttachmentComponent) == 0x000008, "Wrong alignment on UTwinAttachmentComponent");
static_assert(sizeof(UTwinAttachmentComponent) == 0x000278, "Wrong size on UTwinAttachmentComponent");
static_assert(offsetof(UTwinAttachmentComponent, _attachedPlayer) == 0x0000E8, "Member 'UTwinAttachmentComponent::_attachedPlayer' has a wrong offset!");
static_assert(offsetof(UTwinAttachmentComponent, _gateBlockerEffectClass) == 0x000170, "Member 'UTwinAttachmentComponent::_gateBlockerEffectClass' has a wrong offset!");
static_assert(offsetof(UTwinAttachmentComponent, _graspBrokenEffectClass) == 0x000178, "Member 'UTwinAttachmentComponent::_graspBrokenEffectClass' has a wrong offset!");
static_assert(offsetof(UTwinAttachmentComponent, _graspIncapacitatedEffectClass) == 0x000180, "Member 'UTwinAttachmentComponent::_graspIncapacitatedEffectClass' has a wrong offset!");
static_assert(offsetof(UTwinAttachmentComponent, _graspObliviousEffectClass) == 0x000188, "Member 'UTwinAttachmentComponent::_graspObliviousEffectClass' has a wrong offset!");
static_assert(offsetof(UTwinAttachmentComponent, _graspKillerInstinctEffectClass) == 0x000190, "Member 'UTwinAttachmentComponent::_graspKillerInstinctEffectClass' has a wrong offset!");
static_assert(offsetof(UTwinAttachmentComponent, _gateBlockerStatusEffect) == 0x000198, "Member 'UTwinAttachmentComponent::_gateBlockerStatusEffect' has a wrong offset!");
static_assert(offsetof(UTwinAttachmentComponent, _hasBeenDetachedBySurvivorDamageChanged) == 0x0001B2, "Member 'UTwinAttachmentComponent::_hasBeenDetachedBySurvivorDamageChanged' has a wrong offset!");
static_assert(offsetof(UTwinAttachmentComponent, _cantEscapeByGateLingerDuration) == 0x0001B8, "Member 'UTwinAttachmentComponent::_cantEscapeByGateLingerDuration' has a wrong offset!");
static_assert(offsetof(UTwinAttachmentComponent, _escapeBlockerLingerTimers) == 0x0001E0, "Member 'UTwinAttachmentComponent::_escapeBlockerLingerTimers' has a wrong offset!");
static_assert(offsetof(UTwinAttachmentComponent, _notCancelableInteractionTags) == 0x000230, "Member 'UTwinAttachmentComponent::_notCancelableInteractionTags' has a wrong offset!");

// Class TheTwins.TwinBaseAddon
// 0x0010 (0x02F8 - 0x02E8)
class UTwinBaseAddon final : public UItemAddon
{
public:
	TSubclassOf<class UStatusEffect>              _statusEffectClass;                                // 0x02E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _customParam;                                      // 0x02F0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2F4[0x4];                                      // 0x02F4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnTwinSet(class AConjoinedTwin* Twin);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TwinBaseAddon">();
	}
	static class UTwinBaseAddon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTwinBaseAddon>();
	}
};
static_assert(alignof(UTwinBaseAddon) == 0x000008, "Wrong alignment on UTwinBaseAddon");
static_assert(sizeof(UTwinBaseAddon) == 0x0002F8, "Wrong size on UTwinBaseAddon");
static_assert(offsetof(UTwinBaseAddon, _statusEffectClass) == 0x0002E8, "Member 'UTwinBaseAddon::_statusEffectClass' has a wrong offset!");
static_assert(offsetof(UTwinBaseAddon, _customParam) == 0x0002F0, "Member 'UTwinBaseAddon::_customParam' has a wrong offset!");

// Class TheTwins.TwinBaseKillerInstinctEffect
// 0x0160 (0x04E0 - 0x0380)
class UTwinBaseKillerInstinctEffect final : public UStatusEffect
{
public:
	struct FTunableStat                           _lullabyRange;                                     // 0x0380(0x0080)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _lingerDuration;                                   // 0x0400(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_428[0xB8];                                     // 0x0428(0x00B8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnInRangeChanged(const bool InRange);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TwinBaseKillerInstinctEffect">();
	}
	static class UTwinBaseKillerInstinctEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTwinBaseKillerInstinctEffect>();
	}
};
static_assert(alignof(UTwinBaseKillerInstinctEffect) == 0x000008, "Wrong alignment on UTwinBaseKillerInstinctEffect");
static_assert(sizeof(UTwinBaseKillerInstinctEffect) == 0x0004E0, "Wrong size on UTwinBaseKillerInstinctEffect");
static_assert(offsetof(UTwinBaseKillerInstinctEffect, _lullabyRange) == 0x000380, "Member 'UTwinBaseKillerInstinctEffect::_lullabyRange' has a wrong offset!");
static_assert(offsetof(UTwinBaseKillerInstinctEffect, _lingerDuration) == 0x000400, "Member 'UTwinBaseKillerInstinctEffect::_lingerDuration' has a wrong offset!");

// Class TheTwins.TwinBeingPossessedInteraction
// 0x0000 (0x0950 - 0x0950)
class UTwinBeingPossessedInteraction final : public UBeingPossessedInteraction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TwinBeingPossessedInteraction">();
	}
	static class UTwinBeingPossessedInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTwinBeingPossessedInteraction>();
	}
};
static_assert(alignof(UTwinBeingPossessedInteraction) == 0x000010, "Wrong alignment on UTwinBeingPossessedInteraction");
static_assert(sizeof(UTwinBeingPossessedInteraction) == 0x000950, "Wrong size on UTwinBeingPossessedInteraction");

// Class TheTwins.TwinCharacterMovementComponent
// 0x0020 (0x1440 - 0x1420)
class UTwinCharacterMovementComponent final : public UDBDCharacterMovementComponent
{
public:
	uint8                                         Pad_1420[0x20];                                    // 0x1420(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TwinCharacterMovementComponent">();
	}
	static class UTwinCharacterMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTwinCharacterMovementComponent>();
	}
};
static_assert(alignof(UTwinCharacterMovementComponent) == 0x000010, "Wrong alignment on UTwinCharacterMovementComponent");
static_assert(sizeof(UTwinCharacterMovementComponent) == 0x001440, "Wrong size on UTwinCharacterMovementComponent");

// Class TheTwins.TwinDestructionComponent
// 0x0148 (0x01F0 - 0x00A8)
class UTwinDestructionComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x48];                                      // 0x00A8(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AActor>                     _huskClass;                                        // 0x00F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F8[0x8];                                       // 0x00F8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             _dyingTransform;                                   // 0x0100(0x0060)(Net, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_160[0x88];                                     // 0x0160(0x0088)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _dyingFromSurvivorTranslation;                     // 0x01E8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1EC[0x4];                                      // 0x01EC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnTwinQuickDestroyOver();
	void Cosmetic_OnTwinDestroyedFromKick(class AConjoinedTwin* OwningTwin);
	void Cosmetic_OnTwinDestroyedFromSurvivorRemove(class AConjoinedTwin* OwningTwin);
	void OnDyingMontageEnd(const struct FAnimationMontageDescriptor& Montage, bool Interrupted);
	void OnTwinQuickDestroy(class AConjoinedTwin* OwningTwin);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TwinDestructionComponent">();
	}
	static class UTwinDestructionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTwinDestructionComponent>();
	}
};
static_assert(alignof(UTwinDestructionComponent) == 0x000010, "Wrong alignment on UTwinDestructionComponent");
static_assert(sizeof(UTwinDestructionComponent) == 0x0001F0, "Wrong size on UTwinDestructionComponent");
static_assert(offsetof(UTwinDestructionComponent, _huskClass) == 0x0000F0, "Member 'UTwinDestructionComponent::_huskClass' has a wrong offset!");
static_assert(offsetof(UTwinDestructionComponent, _dyingTransform) == 0x000100, "Member 'UTwinDestructionComponent::_dyingTransform' has a wrong offset!");
static_assert(offsetof(UTwinDestructionComponent, _dyingFromSurvivorTranslation) == 0x0001E8, "Member 'UTwinDestructionComponent::_dyingFromSurvivorTranslation' has a wrong offset!");

// Class TheTwins.TwinLockerBlockerComponent
// 0x0078 (0x0120 - 0x00A8)
class UTwinLockerBlockerComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x18];                                      // 0x00A8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UInteractionDefinition>> _interactionClasses;                               // 0x00C0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D0[0x10];                                      // 0x00D0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UInteractionDefinition>> _interactionsToDisableOnLockerClasses;             // 0x00E0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F0[0x30];                                      // 0x00F0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnLevelReadyToPlay();
	void Cosmetic_OnTwinOnLockerChanged(bool IsOnLocker);
	void OnPlayerInLockerChanged(class ADBDPlayer* PreviousPlayerInLocker, class ADBDPlayer* NewPlayerInLocker);
	void OnPushedMontageEnded(const struct FAnimationMontageDescriptor& MontageDescriptor, bool Interrupted);
	void OnPushedMontageStarted(const struct FAnimationMontageDescriptor& MontageDescriptor, const float Rate);
	void OnPushedMontageStopped(const struct FAnimationMontageDescriptor& MontageDescriptor);

	bool IsTwinAttachedToLocker() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TwinLockerBlockerComponent">();
	}
	static class UTwinLockerBlockerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTwinLockerBlockerComponent>();
	}
};
static_assert(alignof(UTwinLockerBlockerComponent) == 0x000008, "Wrong alignment on UTwinLockerBlockerComponent");
static_assert(sizeof(UTwinLockerBlockerComponent) == 0x000120, "Wrong size on UTwinLockerBlockerComponent");
static_assert(offsetof(UTwinLockerBlockerComponent, _interactionClasses) == 0x0000C0, "Member 'UTwinLockerBlockerComponent::_interactionClasses' has a wrong offset!");
static_assert(offsetof(UTwinLockerBlockerComponent, _interactionsToDisableOnLockerClasses) == 0x0000E0, "Member 'UTwinLockerBlockerComponent::_interactionsToDisableOnLockerClasses' has a wrong offset!");

// Class TheTwins.TwinLullabyRangeAdditiveEffect
// 0x0150 (0x04D0 - 0x0380)
class UTwinLullabyRangeAdditiveEffect final : public UStatusEffect
{
public:
	struct FDBDTunableRowHandle                   _defaultTwinLullabyDormantRange;                   // 0x0380(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _twinLullabyDormantRange;                          // 0x03A8(0x0080)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _twinLullabyAttachedRange;                         // 0x0428(0x0080)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4A8[0x28];                                     // 0x04A8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TwinLullabyRangeAdditiveEffect">();
	}
	static class UTwinLullabyRangeAdditiveEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTwinLullabyRangeAdditiveEffect>();
	}
};
static_assert(alignof(UTwinLullabyRangeAdditiveEffect) == 0x000008, "Wrong alignment on UTwinLullabyRangeAdditiveEffect");
static_assert(sizeof(UTwinLullabyRangeAdditiveEffect) == 0x0004D0, "Wrong size on UTwinLullabyRangeAdditiveEffect");
static_assert(offsetof(UTwinLullabyRangeAdditiveEffect, _defaultTwinLullabyDormantRange) == 0x000380, "Member 'UTwinLullabyRangeAdditiveEffect::_defaultTwinLullabyDormantRange' has a wrong offset!");
static_assert(offsetof(UTwinLullabyRangeAdditiveEffect, _twinLullabyDormantRange) == 0x0003A8, "Member 'UTwinLullabyRangeAdditiveEffect::_twinLullabyDormantRange' has a wrong offset!");
static_assert(offsetof(UTwinLullabyRangeAdditiveEffect, _twinLullabyAttachedRange) == 0x000428, "Member 'UTwinLullabyRangeAdditiveEffect::_twinLullabyAttachedRange' has a wrong offset!");

// Class TheTwins.TwinOutlineUpdateStrategy
// 0x0070 (0x0140 - 0x00D0)
class UTwinOutlineUpdateStrategy final : public UOutlineUpdateStrategy
{
public:
	struct FLinearColor                           _visibleColorForKiller;                            // 0x00D0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E0[0x60];                                      // 0x00E0(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TwinOutlineUpdateStrategy">();
	}
	static class UTwinOutlineUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTwinOutlineUpdateStrategy>();
	}
};
static_assert(alignof(UTwinOutlineUpdateStrategy) == 0x000008, "Wrong alignment on UTwinOutlineUpdateStrategy");
static_assert(sizeof(UTwinOutlineUpdateStrategy) == 0x000140, "Wrong size on UTwinOutlineUpdateStrategy");
static_assert(offsetof(UTwinOutlineUpdateStrategy, _visibleColorForKiller) == 0x0000D0, "Member 'UTwinOutlineUpdateStrategy::_visibleColorForKiller' has a wrong offset!");

// Class TheTwins.TwinPlacerComponent
// 0x0010 (0x0340 - 0x0330)
class UTwinPlacerComponent final : public UObjectPlacerComponent
{
public:
	uint8                                         Pad_330[0x10];                                     // 0x0330(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TwinPlacerComponent">();
	}
	static class UTwinPlacerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTwinPlacerComponent>();
	}
};
static_assert(alignof(UTwinPlacerComponent) == 0x000010, "Wrong alignment on UTwinPlacerComponent");
static_assert(sizeof(UTwinPlacerComponent) == 0x000340, "Wrong size on UTwinPlacerComponent");

// Class TheTwins.TwinPossessionComponent
// 0x0018 (0x0168 - 0x0150)
class UTwinPossessionComponent final : public UPossessionComponent
{
public:
	uint8                                         Pad_150[0x18];                                     // 0x0150(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TwinPossessionComponent">();
	}
	static class UTwinPossessionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTwinPossessionComponent>();
	}
};
static_assert(alignof(UTwinPossessionComponent) == 0x000008, "Wrong alignment on UTwinPossessionComponent");
static_assert(sizeof(UTwinPossessionComponent) == 0x000168, "Wrong size on UTwinPossessionComponent");

// Class TheTwins.TwinPossessNegationEffectComponent
// 0x0028 (0x00E8 - 0x00C0)
class UTwinPossessNegationEffectComponent final : public UPossessNegationEffectComponent
{
public:
	uint8                                         Pad_C0[0x28];                                      // 0x00C0(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TwinPossessNegationEffectComponent">();
	}
	static class UTwinPossessNegationEffectComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTwinPossessNegationEffectComponent>();
	}
};
static_assert(alignof(UTwinPossessNegationEffectComponent) == 0x000008, "Wrong alignment on UTwinPossessNegationEffectComponent");
static_assert(sizeof(UTwinPossessNegationEffectComponent) == 0x0000E8, "Wrong size on UTwinPossessNegationEffectComponent");

// Class TheTwins.TwinPowerChargePresentationItemProgressComponent
// 0x0000 (0x00B0 - 0x00B0)
class UTwinPowerChargePresentationItemProgressComponent final : public UPresentationItemProgressComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TwinPowerChargePresentationItemProgressComponent">();
	}
	static class UTwinPowerChargePresentationItemProgressComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTwinPowerChargePresentationItemProgressComponent>();
	}
};
static_assert(alignof(UTwinPowerChargePresentationItemProgressComponent) == 0x000008, "Wrong alignment on UTwinPowerChargePresentationItemProgressComponent");
static_assert(sizeof(UTwinPowerChargePresentationItemProgressComponent) == 0x0000B0, "Wrong size on UTwinPowerChargePresentationItemProgressComponent");

// Class TheTwins.TwinPowerFadeComponent
// 0x0000 (0x00A8 - 0x00A8)
class UTwinPowerFadeComponent final : public UPresentationPowerFadeComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TwinPowerFadeComponent">();
	}
	static class UTwinPowerFadeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTwinPowerFadeComponent>();
	}
};
static_assert(alignof(UTwinPowerFadeComponent) == 0x000008, "Wrong alignment on UTwinPowerFadeComponent");
static_assert(sizeof(UTwinPowerFadeComponent) == 0x0000A8, "Wrong size on UTwinPowerFadeComponent");

// Class TheTwins.TwinRevealAuraOnAttachedToSurvivorStatusEffect
// 0x0000 (0x03B0 - 0x03B0)
class UTwinRevealAuraOnAttachedToSurvivorStatusEffect final : public UActivateOnEventTimedStatusEffect
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TwinRevealAuraOnAttachedToSurvivorStatusEffect">();
	}
	static class UTwinRevealAuraOnAttachedToSurvivorStatusEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTwinRevealAuraOnAttachedToSurvivorStatusEffect>();
	}
};
static_assert(alignof(UTwinRevealAuraOnAttachedToSurvivorStatusEffect) == 0x000008, "Wrong alignment on UTwinRevealAuraOnAttachedToSurvivorStatusEffect");
static_assert(sizeof(UTwinRevealAuraOnAttachedToSurvivorStatusEffect) == 0x0003B0, "Wrong size on UTwinRevealAuraOnAttachedToSurvivorStatusEffect");

// Class TheTwins.TwinsAnimInstance
// 0x00E0 (0x0800 - 0x0720)
class UTwinsAnimInstance final : public UKillerAnimInstance
{
public:
	bool                                          _isDormant;                                        // 0x0720(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _hasBrotherAttached;                               // 0x0721(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isPossessing;                                     // 0x0722(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isWakingUpFromPossess;                            // 0x0723(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isAutoPossessingAfterRelease;                     // 0x0724(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_725[0xDB];                                     // 0x0725(0x00DB)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TwinsAnimInstance">();
	}
	static class UTwinsAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTwinsAnimInstance>();
	}
};
static_assert(alignof(UTwinsAnimInstance) == 0x000010, "Wrong alignment on UTwinsAnimInstance");
static_assert(sizeof(UTwinsAnimInstance) == 0x000800, "Wrong size on UTwinsAnimInstance");
static_assert(offsetof(UTwinsAnimInstance, _isDormant) == 0x000720, "Member 'UTwinsAnimInstance::_isDormant' has a wrong offset!");
static_assert(offsetof(UTwinsAnimInstance, _hasBrotherAttached) == 0x000721, "Member 'UTwinsAnimInstance::_hasBrotherAttached' has a wrong offset!");
static_assert(offsetof(UTwinsAnimInstance, _isPossessing) == 0x000722, "Member 'UTwinsAnimInstance::_isPossessing' has a wrong offset!");
static_assert(offsetof(UTwinsAnimInstance, _isWakingUpFromPossess) == 0x000723, "Member 'UTwinsAnimInstance::_isWakingUpFromPossess' has a wrong offset!");
static_assert(offsetof(UTwinsAnimInstance, _isAutoPossessingAfterRelease) == 0x000724, "Member 'UTwinsAnimInstance::_isAutoPossessingAfterRelease' has a wrong offset!");

// Class TheTwins.TwinsSurvivorSubAnimInstance
// 0x0060 (0x0640 - 0x05E0)
class UTwinsSurvivorSubAnimInstance final : public UBaseSurvivorAnimInstance
{
public:
	uint8                                         Pad_5E0[0x8];                                      // 0x05E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _isRemovingTwin;                                   // 0x05E8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isIdle;                                           // 0x05E9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isCrouching;                                      // 0x05EA(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5EB[0x55];                                     // 0x05EB(0x0055)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TwinsSurvivorSubAnimInstance">();
	}
	static class UTwinsSurvivorSubAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTwinsSurvivorSubAnimInstance>();
	}
};
static_assert(alignof(UTwinsSurvivorSubAnimInstance) == 0x000010, "Wrong alignment on UTwinsSurvivorSubAnimInstance");
static_assert(sizeof(UTwinsSurvivorSubAnimInstance) == 0x000640, "Wrong size on UTwinsSurvivorSubAnimInstance");
static_assert(offsetof(UTwinsSurvivorSubAnimInstance, _isRemovingTwin) == 0x0005E8, "Member 'UTwinsSurvivorSubAnimInstance::_isRemovingTwin' has a wrong offset!");
static_assert(offsetof(UTwinsSurvivorSubAnimInstance, _isIdle) == 0x0005E9, "Member 'UTwinsSurvivorSubAnimInstance::_isIdle' has a wrong offset!");
static_assert(offsetof(UTwinsSurvivorSubAnimInstance, _isCrouching) == 0x0005EA, "Member 'UTwinsSurvivorSubAnimInstance::_isCrouching' has a wrong offset!");

// Class TheTwins.TwinStateHelperComponent
// 0x0058 (0x0100 - 0x00A8)
class UTwinStateHelperComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x58];                                      // 0x00A8(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TwinStateHelperComponent">();
	}
	static class UTwinStateHelperComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTwinStateHelperComponent>();
	}
};
static_assert(alignof(UTwinStateHelperComponent) == 0x000008, "Wrong alignment on UTwinStateHelperComponent");
static_assert(sizeof(UTwinStateHelperComponent) == 0x000100, "Wrong size on UTwinStateHelperComponent");

// Class TheTwins.TwinStunnableComponent
// 0x0030 (0x00D8 - 0x00A8)
class UTwinStunnableComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x30];                                      // 0x00A8(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TwinStunnableComponent">();
	}
	static class UTwinStunnableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTwinStunnableComponent>();
	}
};
static_assert(alignof(UTwinStunnableComponent) == 0x000008, "Wrong alignment on UTwinStunnableComponent");
static_assert(sizeof(UTwinStunnableComponent) == 0x0000D8, "Wrong size on UTwinStunnableComponent");

// Class TheTwins.TwinSubjectProvider
// 0x0008 (0x0050 - 0x0048)
class UTwinSubjectProvider final : public UModifierSubjectProvider
{
public:
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ListenToTwinSet(class ASlasherPlayer* Killer);
	void OnTwinSet(class AConjoinedTwin* Twin);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TwinSubjectProvider">();
	}
	static class UTwinSubjectProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTwinSubjectProvider>();
	}
};
static_assert(alignof(UTwinSubjectProvider) == 0x000008, "Wrong alignment on UTwinSubjectProvider");
static_assert(sizeof(UTwinSubjectProvider) == 0x000050, "Wrong size on UTwinSubjectProvider");

}

