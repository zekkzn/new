#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: TheK26

#include "Basic.hpp"

#include "DBDCompetence_classes.hpp"
#include "GameplayTags_structs.hpp"
#include "StatSystem_structs.hpp"
#include "Competence_classes.hpp"
#include "GameplayTagUtilities_structs.hpp"
#include "DBDAnimation_classes.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "TheK26_structs.hpp"
#include "DataTableUtilities_structs.hpp"
#include "DeadByDaylight_structs.hpp"
#include "DeadByDaylight_classes.hpp"
#include "CoreUObject_structs.hpp"


namespace SDK
{

// Class TheK26.K26AttachedCrow
// 0x01B8 (0x0458 - 0x02A0)
class AK26AttachedCrow final : public AActor
{
public:
	uint8                                         Pad_2A0[0x40];                                     // 0x02A0(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTunableStat                           _lingerTime;                                       // 0x02E0(0x0080)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _infectionDelay;                                   // 0x0360(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _infectRadius;                                     // 0x0388(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class UK26PowerOutlineUpdateStrategy*         _outlineUpdateStrategy;                            // 0x03B0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDBDOutlineComponent*                   _outlineComponent;                                 // 0x03B8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticMeshComponent*                   _visualStaticMeshComponent;                        // 0x03C0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USceneComponent*                        _rootComponent;                                    // 0x03C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UK26PowerStatusHandlerComponent*        _statusHandler;                                    // 0x03D0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _authority_isInfecting;                            // 0x03D8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FK26AttachmentStatus                   _attachmentStatus;                                 // 0x03D9(0x0002)(Net, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3DB[0x7D];                                     // 0x03DB(0x007D)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_ActivateInfection();
	void Authority_DeactivateInfection();
	void Authority_OnIsWithinOtherSurvivorRangeChanged(class AActor* SurvivorActor, const bool IsInRange);
	void Authority_OnKillerSet(class ASlasherPlayer* Killer);
	void Authority_OnOtherAttachedCrowRemoved();
	void Authority_OnOtherSurvivorDamageStateChanged(ECamperDamageState before, ECamperDamageState After);
	void Authority_OnOtherSurvivorGuidedActionChanged();
	void Authority_OnOtherSurvivorPerkFlagsChanged(const struct FGameplayTag& GameplayTag, bool IsAdded);
	void Authority_OnPlayerLeftGame(const struct FGameplayTag& GameEventType, const struct FGameEventData& GameEventData);
	void Authority_OnSurvivorAdded(class ACamperPlayer* Survivor);
	void Authority_OnSurvivorDroppedEnd();
	void Authority_OnSurvivorExitLocker(const struct FGameplayTag& GameEventType, const struct FGameEventData& GameEventData);
	void Authority_OnSurvivorStatusIndicatorSet(const class ACamperPlayer* Survivor, class AK26AttachedCrow* AttachedCrow);
	void Authority_OnSurvivorWasUnhooked(const struct FGameplayTag& GameEventType, const struct FGameEventData& GameEventData);
	void Cosmetic_OnAttachedCrowRemoved(EFK26AttachedCrowRemovalReason RemovalReason);
	void Cosmetic_OnAuraHidden();
	void Cosmetic_OnAuraShown();
	void Cosmetic_OnCrowAttached();
	void Cosmetic_OnStartDetaching();
	void Cosmetic_OnStopDetaching();
	void HideOutline();
	void Multicast_OnStartDetaching();
	void Multicast_OnStopDetaching();
	void OnRep_AttachmentStatus();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K26AttachedCrow">();
	}
	static class AK26AttachedCrow* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK26AttachedCrow>();
	}
};
static_assert(alignof(AK26AttachedCrow) == 0x000008, "Wrong alignment on AK26AttachedCrow");
static_assert(sizeof(AK26AttachedCrow) == 0x000458, "Wrong size on AK26AttachedCrow");
static_assert(offsetof(AK26AttachedCrow, _lingerTime) == 0x0002E0, "Member 'AK26AttachedCrow::_lingerTime' has a wrong offset!");
static_assert(offsetof(AK26AttachedCrow, _infectionDelay) == 0x000360, "Member 'AK26AttachedCrow::_infectionDelay' has a wrong offset!");
static_assert(offsetof(AK26AttachedCrow, _infectRadius) == 0x000388, "Member 'AK26AttachedCrow::_infectRadius' has a wrong offset!");
static_assert(offsetof(AK26AttachedCrow, _outlineUpdateStrategy) == 0x0003B0, "Member 'AK26AttachedCrow::_outlineUpdateStrategy' has a wrong offset!");
static_assert(offsetof(AK26AttachedCrow, _outlineComponent) == 0x0003B8, "Member 'AK26AttachedCrow::_outlineComponent' has a wrong offset!");
static_assert(offsetof(AK26AttachedCrow, _visualStaticMeshComponent) == 0x0003C0, "Member 'AK26AttachedCrow::_visualStaticMeshComponent' has a wrong offset!");
static_assert(offsetof(AK26AttachedCrow, _rootComponent) == 0x0003C8, "Member 'AK26AttachedCrow::_rootComponent' has a wrong offset!");
static_assert(offsetof(AK26AttachedCrow, _statusHandler) == 0x0003D0, "Member 'AK26AttachedCrow::_statusHandler' has a wrong offset!");
static_assert(offsetof(AK26AttachedCrow, _authority_isInfecting) == 0x0003D8, "Member 'AK26AttachedCrow::_authority_isInfecting' has a wrong offset!");
static_assert(offsetof(AK26AttachedCrow, _attachmentStatus) == 0x0003D9, "Member 'AK26AttachedCrow::_attachmentStatus' has a wrong offset!");

// Class TheK26.HexPentimento
// 0x0030 (0x04D0 - 0x04A0)
class UHexPentimento final : public UHexPerk
{
public:
	TSubclassOf<class URekindleTotemInteraction>  _rekindleInteractionClass;                         // 0x04A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class ATotem*>                         _blockedTotems;                                    // 0x04A8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<TSubclassOf<class UStatusEffect>>      _statusEffectClasses;                              // 0x04B8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4C8[0x8];                                      // 0x04C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HexPentimento">();
	}
	static class UHexPentimento* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHexPentimento>();
	}
};
static_assert(alignof(UHexPentimento) == 0x000008, "Wrong alignment on UHexPentimento");
static_assert(sizeof(UHexPentimento) == 0x0004D0, "Wrong size on UHexPentimento");
static_assert(offsetof(UHexPentimento, _rekindleInteractionClass) == 0x0004A0, "Member 'UHexPentimento::_rekindleInteractionClass' has a wrong offset!");
static_assert(offsetof(UHexPentimento, _blockedTotems) == 0x0004A8, "Member 'UHexPentimento::_blockedTotems' has a wrong offset!");
static_assert(offsetof(UHexPentimento, _statusEffectClasses) == 0x0004B8, "Member 'UHexPentimento::_statusEffectClasses' has a wrong offset!");

// Class TheK26.HinderOnCrowAttachStatusEffect
// 0x00B8 (0x04A0 - 0x03E8)
class UHinderOnCrowAttachStatusEffect final : public UBaseLingeringStatusEffect
{
public:
	struct FGameplayTag                           _onCrowAttachStateTag;                             // 0x03E8(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3F4[0x4];                                      // 0x03F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTunableStat                           _hinderOnIdleLingerTime;                           // 0x03F8(0x0080)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_478[0x28];                                     // 0x0478(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnKillerSet(class ASlasherPlayer* Killer);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HinderOnCrowAttachStatusEffect">();
	}
	static class UHinderOnCrowAttachStatusEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHinderOnCrowAttachStatusEffect>();
	}
};
static_assert(alignof(UHinderOnCrowAttachStatusEffect) == 0x000008, "Wrong alignment on UHinderOnCrowAttachStatusEffect");
static_assert(sizeof(UHinderOnCrowAttachStatusEffect) == 0x0004A0, "Wrong size on UHinderOnCrowAttachStatusEffect");
static_assert(offsetof(UHinderOnCrowAttachStatusEffect, _onCrowAttachStateTag) == 0x0003E8, "Member 'UHinderOnCrowAttachStatusEffect::_onCrowAttachStateTag' has a wrong offset!");
static_assert(offsetof(UHinderOnCrowAttachStatusEffect, _hinderOnIdleLingerTime) == 0x0003F8, "Member 'UHinderOnCrowAttachStatusEffect::_hinderOnIdleLingerTime' has a wrong offset!");

// Class TheK26.HinderOnIdleAndAttachStatusEffect
// 0x0038 (0x0458 - 0x0420)
class UHinderOnIdleAndAttachStatusEffect final : public ULingeringStateTagStatusEffect
{
public:
	struct FGameplayTag                           _onCrowAttachStateTag;                             // 0x0420(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_42C[0x2C];                                     // 0x042C(0x002C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HinderOnIdleAndAttachStatusEffect">();
	}
	static class UHinderOnIdleAndAttachStatusEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHinderOnIdleAndAttachStatusEffect>();
	}
};
static_assert(alignof(UHinderOnIdleAndAttachStatusEffect) == 0x000008, "Wrong alignment on UHinderOnIdleAndAttachStatusEffect");
static_assert(sizeof(UHinderOnIdleAndAttachStatusEffect) == 0x000458, "Wrong size on UHinderOnIdleAndAttachStatusEffect");
static_assert(offsetof(UHinderOnIdleAndAttachStatusEffect, _onCrowAttachStateTag) == 0x000420, "Member 'UHinderOnIdleAndAttachStatusEffect::_onCrowAttachStateTag' has a wrong offset!");

// Class TheK26.K26AbilitySubAnimInstance
// 0x0090 (0x0680 - 0x05F0)
class UK26AbilitySubAnimInstance final : public UBaseKillerAnimInstance
{
public:
	float                                         _fireInteractionCooldownTime;                      // 0x05F0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5F4[0x4];                                      // 0x05F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTunableStat                           _fireInteractionCooldownTimeTunable;               // 0x05F8(0x0080)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          _hasChargingStarted;                               // 0x0678(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _hasProjectileBeenSummoned;                        // 0x0679(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _hasChargingEnded;                                 // 0x067A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _hasProjectileFired;                               // 0x067B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_67C[0x4];                                      // 0x067C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ConsumeHasProjectileBeenSummoned();
	void ConsumeHasProjectileFired();
	void OnHasProjectileBeenSummoned(const int32 RemainingAmmo, const int32 MaxAmmo);
	void OnHasProjectileFired();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K26AbilitySubAnimInstance">();
	}
	static class UK26AbilitySubAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK26AbilitySubAnimInstance>();
	}
};
static_assert(alignof(UK26AbilitySubAnimInstance) == 0x000010, "Wrong alignment on UK26AbilitySubAnimInstance");
static_assert(sizeof(UK26AbilitySubAnimInstance) == 0x000680, "Wrong size on UK26AbilitySubAnimInstance");
static_assert(offsetof(UK26AbilitySubAnimInstance, _fireInteractionCooldownTime) == 0x0005F0, "Member 'UK26AbilitySubAnimInstance::_fireInteractionCooldownTime' has a wrong offset!");
static_assert(offsetof(UK26AbilitySubAnimInstance, _fireInteractionCooldownTimeTunable) == 0x0005F8, "Member 'UK26AbilitySubAnimInstance::_fireInteractionCooldownTimeTunable' has a wrong offset!");
static_assert(offsetof(UK26AbilitySubAnimInstance, _hasChargingStarted) == 0x000678, "Member 'UK26AbilitySubAnimInstance::_hasChargingStarted' has a wrong offset!");
static_assert(offsetof(UK26AbilitySubAnimInstance, _hasProjectileBeenSummoned) == 0x000679, "Member 'UK26AbilitySubAnimInstance::_hasProjectileBeenSummoned' has a wrong offset!");
static_assert(offsetof(UK26AbilitySubAnimInstance, _hasChargingEnded) == 0x00067A, "Member 'UK26AbilitySubAnimInstance::_hasChargingEnded' has a wrong offset!");
static_assert(offsetof(UK26AbilitySubAnimInstance, _hasProjectileFired) == 0x00067B, "Member 'UK26AbilitySubAnimInstance::_hasProjectileFired' has a wrong offset!");

// Class TheK26.K26AimingGuide
// 0x0000 (0x02A0 - 0x02A0)
class AK26AimingGuide final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K26AimingGuide">();
	}
	static class AK26AimingGuide* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK26AimingGuide>();
	}
};
static_assert(alignof(AK26AimingGuide) == 0x000008, "Wrong alignment on AK26AimingGuide");
static_assert(sizeof(AK26AimingGuide) == 0x0002A0, "Wrong size on AK26AimingGuide");

// Class TheK26.K26AmmoHandlerComponent
// 0x03D0 (0x0478 - 0x00A8)
class UK26AmmoHandlerComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x10];                                      // 0x00A8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnCurrentAmmoStateChanged;                         // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FTagStateBool                          _isAmmoOnCooldown;                                 // 0x00C8(0x0048)(Net, Transient, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             _onMaxAmmoSet;                                     // 0x0110(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	float                                         _rechargeEndTime;                                  // 0x0120(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isTunableInit;                                    // 0x0124(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_125[0x3];                                      // 0x0125(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AActor>                     _projectileClass;                                  // 0x0128(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _expirationCooldownTime;                           // 0x0130(0x0080)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TArray<struct FDBDTunableRowHandle>           _firedCooldownTimesPerCrow;                        // 0x01B0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _cooldownReductionPerCrowFired;                    // 0x01C0(0x0080)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _expirationTime;                                   // 0x0240(0x0080)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _expirationWarningBufferTime;                      // 0x02C0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _maxAmmo;                                          // 0x02E8(0x0080)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	int32                                         _currentAmmo;                                      // 0x0368(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EK26AmmoCooldownReason                        _lastCooldownReason;                               // 0x036C(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EK26AmmoState                                 _currentAmmoState;                                 // 0x036D(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_36E[0x2];                                      // 0x036E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class UK26PathHandlerComponent*               _pathHandler;                                      // 0x0370(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UK26PowerStatusHandlerComponent*        _statusHandler;                                    // 0x0378(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAuthoritativeActorPoolComponent*       _authoritativeActorPoolComponent;                  // 0x0380(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_388[0x8];                                      // 0x0388(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTagStateBool                          _isOutOfAmmo;                                      // 0x0390(0x0048)(Net, Transient, NativeAccessSpecifierPrivate)
	float                                         _fallbackFireCooldown;                             // 0x03D8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3DC[0x9C];                                     // 0x03DC(0x009C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_InitializePoolComponent(const int32 MaxAmmo);
	void Authority_OnAmmoInit(class AActor* InitAmmo);
	void Authority_OnZoneChange();
	void CallOnMaxAmmoSet(TDelegate<void(int32 MaxAmmo)> Callback);
	void OnMaxAmmoSetDelegate__DelegateSignature(const int32 MaxAmmo);
	void Cosmetic_OnAmmoExpired();
	void Cosmetic_OnAmmoHasBeenFired();
	void Cosmetic_OnExpiringWarning();
	void Multicast_ForceExpireAmmo();
	void Multicast_OnAmmoExpired();
	void Multicast_OnAmmoHasBeenFired();
	void Multicast_OnCurrentAmmoStateChanged(const EK26AmmoState NewState, const int32 CurrentAmmo, const int32 MaxAmmo);
	void Multicast_StartExpiring();
	void Multicast_StartRecharging(const EK26AmmoCooldownReason LastCooldownReason);
	void OnKillerSet(class ASlasherPlayer* Killer);
	void OnLevelReadyToPlay();
	void SendHasExpiredDelegate();
	void SetDependencies(class UK26PathHandlerComponent* PathHandler, class UK26PowerStatusHandlerComponent* StatusHandler, class UAuthoritativeActorPoolComponent* AuthoritativeActorPoolComponent);

	int32 GetCurrentAmmo() const;
	EK26AmmoState GetCurrentAmmoState() const;
	EK26AmmoCooldownReason GetCurrentCooldownReason() const;
	int32 GetMaxAmmo() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K26AmmoHandlerComponent">();
	}
	static class UK26AmmoHandlerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK26AmmoHandlerComponent>();
	}
};
static_assert(alignof(UK26AmmoHandlerComponent) == 0x000008, "Wrong alignment on UK26AmmoHandlerComponent");
static_assert(sizeof(UK26AmmoHandlerComponent) == 0x000478, "Wrong size on UK26AmmoHandlerComponent");
static_assert(offsetof(UK26AmmoHandlerComponent, OnCurrentAmmoStateChanged) == 0x0000B8, "Member 'UK26AmmoHandlerComponent::OnCurrentAmmoStateChanged' has a wrong offset!");
static_assert(offsetof(UK26AmmoHandlerComponent, _isAmmoOnCooldown) == 0x0000C8, "Member 'UK26AmmoHandlerComponent::_isAmmoOnCooldown' has a wrong offset!");
static_assert(offsetof(UK26AmmoHandlerComponent, _onMaxAmmoSet) == 0x000110, "Member 'UK26AmmoHandlerComponent::_onMaxAmmoSet' has a wrong offset!");
static_assert(offsetof(UK26AmmoHandlerComponent, _rechargeEndTime) == 0x000120, "Member 'UK26AmmoHandlerComponent::_rechargeEndTime' has a wrong offset!");
static_assert(offsetof(UK26AmmoHandlerComponent, _isTunableInit) == 0x000124, "Member 'UK26AmmoHandlerComponent::_isTunableInit' has a wrong offset!");
static_assert(offsetof(UK26AmmoHandlerComponent, _projectileClass) == 0x000128, "Member 'UK26AmmoHandlerComponent::_projectileClass' has a wrong offset!");
static_assert(offsetof(UK26AmmoHandlerComponent, _expirationCooldownTime) == 0x000130, "Member 'UK26AmmoHandlerComponent::_expirationCooldownTime' has a wrong offset!");
static_assert(offsetof(UK26AmmoHandlerComponent, _firedCooldownTimesPerCrow) == 0x0001B0, "Member 'UK26AmmoHandlerComponent::_firedCooldownTimesPerCrow' has a wrong offset!");
static_assert(offsetof(UK26AmmoHandlerComponent, _cooldownReductionPerCrowFired) == 0x0001C0, "Member 'UK26AmmoHandlerComponent::_cooldownReductionPerCrowFired' has a wrong offset!");
static_assert(offsetof(UK26AmmoHandlerComponent, _expirationTime) == 0x000240, "Member 'UK26AmmoHandlerComponent::_expirationTime' has a wrong offset!");
static_assert(offsetof(UK26AmmoHandlerComponent, _expirationWarningBufferTime) == 0x0002C0, "Member 'UK26AmmoHandlerComponent::_expirationWarningBufferTime' has a wrong offset!");
static_assert(offsetof(UK26AmmoHandlerComponent, _maxAmmo) == 0x0002E8, "Member 'UK26AmmoHandlerComponent::_maxAmmo' has a wrong offset!");
static_assert(offsetof(UK26AmmoHandlerComponent, _currentAmmo) == 0x000368, "Member 'UK26AmmoHandlerComponent::_currentAmmo' has a wrong offset!");
static_assert(offsetof(UK26AmmoHandlerComponent, _lastCooldownReason) == 0x00036C, "Member 'UK26AmmoHandlerComponent::_lastCooldownReason' has a wrong offset!");
static_assert(offsetof(UK26AmmoHandlerComponent, _currentAmmoState) == 0x00036D, "Member 'UK26AmmoHandlerComponent::_currentAmmoState' has a wrong offset!");
static_assert(offsetof(UK26AmmoHandlerComponent, _pathHandler) == 0x000370, "Member 'UK26AmmoHandlerComponent::_pathHandler' has a wrong offset!");
static_assert(offsetof(UK26AmmoHandlerComponent, _statusHandler) == 0x000378, "Member 'UK26AmmoHandlerComponent::_statusHandler' has a wrong offset!");
static_assert(offsetof(UK26AmmoHandlerComponent, _authoritativeActorPoolComponent) == 0x000380, "Member 'UK26AmmoHandlerComponent::_authoritativeActorPoolComponent' has a wrong offset!");
static_assert(offsetof(UK26AmmoHandlerComponent, _isOutOfAmmo) == 0x000390, "Member 'UK26AmmoHandlerComponent::_isOutOfAmmo' has a wrong offset!");
static_assert(offsetof(UK26AmmoHandlerComponent, _fallbackFireCooldown) == 0x0003D8, "Member 'UK26AmmoHandlerComponent::_fallbackFireCooldown' has a wrong offset!");

// Class TheK26.K26AnimInstance
// 0x0010 (0x0730 - 0x0720)
class UK26AnimInstance final : public UKillerAnimInstance
{
public:
	bool                                          _isUsingPower;                                     // 0x0720(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_721[0xF];                                      // 0x0721(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K26AnimInstance">();
	}
	static class UK26AnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK26AnimInstance>();
	}
};
static_assert(alignof(UK26AnimInstance) == 0x000010, "Wrong alignment on UK26AnimInstance");
static_assert(sizeof(UK26AnimInstance) == 0x000730, "Wrong size on UK26AnimInstance");
static_assert(offsetof(UK26AnimInstance, _isUsingPower) == 0x000720, "Member 'UK26AnimInstance::_isUsingPower' has a wrong offset!");

// Class TheK26.K26CooldownInteractionDefinition
// 0x0080 (0x0800 - 0x0780)
class UK26CooldownInteractionDefinition final : public UInteractionDefinition
{
public:
	struct FTunableStat                           _cooldownTime;                                     // 0x0778(0x0080)(Edit, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7F8[0x8];                                      // 0x07F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnKillerSet(class ASlasherPlayer* Killer);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K26CooldownInteractionDefinition">();
	}
	static class UK26CooldownInteractionDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK26CooldownInteractionDefinition>();
	}
};
static_assert(alignof(UK26CooldownInteractionDefinition) == 0x000010, "Wrong alignment on UK26CooldownInteractionDefinition");
static_assert(sizeof(UK26CooldownInteractionDefinition) == 0x000800, "Wrong size on UK26CooldownInteractionDefinition");
static_assert(offsetof(UK26CooldownInteractionDefinition, _cooldownTime) == 0x000778, "Member 'UK26CooldownInteractionDefinition::_cooldownTime' has a wrong offset!");

// Class TheK26.K26CrowAttachmentSubAnimInstance
// 0x0020 (0x0600 - 0x05E0)
class UK26CrowAttachmentSubAnimInstance final : public UBaseSurvivorAnimInstance
{
public:
	uint8                                         Pad_5E0[0x8];                                      // 0x05E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _hasCrowAttached;                                  // 0x05E8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isRemovingCrow;                                   // 0x05E9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isIdle;                                           // 0x05EA(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isCrawling;                                       // 0x05EB(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isDead;                                           // 0x05EC(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isHooked;                                         // 0x05ED(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isInsideCloset;                                   // 0x05EE(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isInteracting;                                    // 0x05EF(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isHoldingSmallItem;                               // 0x05F0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isUsingAimItem;                                   // 0x05F1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isCrouched;                                       // 0x05F2(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5F3[0xD];                                      // 0x05F3(0x000D)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K26CrowAttachmentSubAnimInstance">();
	}
	static class UK26CrowAttachmentSubAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK26CrowAttachmentSubAnimInstance>();
	}
};
static_assert(alignof(UK26CrowAttachmentSubAnimInstance) == 0x000010, "Wrong alignment on UK26CrowAttachmentSubAnimInstance");
static_assert(sizeof(UK26CrowAttachmentSubAnimInstance) == 0x000600, "Wrong size on UK26CrowAttachmentSubAnimInstance");
static_assert(offsetof(UK26CrowAttachmentSubAnimInstance, _hasCrowAttached) == 0x0005E8, "Member 'UK26CrowAttachmentSubAnimInstance::_hasCrowAttached' has a wrong offset!");
static_assert(offsetof(UK26CrowAttachmentSubAnimInstance, _isRemovingCrow) == 0x0005E9, "Member 'UK26CrowAttachmentSubAnimInstance::_isRemovingCrow' has a wrong offset!");
static_assert(offsetof(UK26CrowAttachmentSubAnimInstance, _isIdle) == 0x0005EA, "Member 'UK26CrowAttachmentSubAnimInstance::_isIdle' has a wrong offset!");
static_assert(offsetof(UK26CrowAttachmentSubAnimInstance, _isCrawling) == 0x0005EB, "Member 'UK26CrowAttachmentSubAnimInstance::_isCrawling' has a wrong offset!");
static_assert(offsetof(UK26CrowAttachmentSubAnimInstance, _isDead) == 0x0005EC, "Member 'UK26CrowAttachmentSubAnimInstance::_isDead' has a wrong offset!");
static_assert(offsetof(UK26CrowAttachmentSubAnimInstance, _isHooked) == 0x0005ED, "Member 'UK26CrowAttachmentSubAnimInstance::_isHooked' has a wrong offset!");
static_assert(offsetof(UK26CrowAttachmentSubAnimInstance, _isInsideCloset) == 0x0005EE, "Member 'UK26CrowAttachmentSubAnimInstance::_isInsideCloset' has a wrong offset!");
static_assert(offsetof(UK26CrowAttachmentSubAnimInstance, _isInteracting) == 0x0005EF, "Member 'UK26CrowAttachmentSubAnimInstance::_isInteracting' has a wrong offset!");
static_assert(offsetof(UK26CrowAttachmentSubAnimInstance, _isHoldingSmallItem) == 0x0005F0, "Member 'UK26CrowAttachmentSubAnimInstance::_isHoldingSmallItem' has a wrong offset!");
static_assert(offsetof(UK26CrowAttachmentSubAnimInstance, _isUsingAimItem) == 0x0005F1, "Member 'UK26CrowAttachmentSubAnimInstance::_isUsingAimItem' has a wrong offset!");
static_assert(offsetof(UK26CrowAttachmentSubAnimInstance, _isCrouched) == 0x0005F2, "Member 'UK26CrowAttachmentSubAnimInstance::_isCrouched' has a wrong offset!");

// Class TheK26.K26CrowPlacementValidatorComponent
// 0x0008 (0x00B0 - 0x00A8)
class UK26CrowPlacementValidatorComponent final : public UActorComponent
{
public:
	class UObjectPlacementValidationWithRestrictionStrategy* _objectPlacementValidationStrategyWithRestrictions; // 0x00A8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K26CrowPlacementValidatorComponent">();
	}
	static class UK26CrowPlacementValidatorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK26CrowPlacementValidatorComponent>();
	}
};
static_assert(alignof(UK26CrowPlacementValidatorComponent) == 0x000008, "Wrong alignment on UK26CrowPlacementValidatorComponent");
static_assert(sizeof(UK26CrowPlacementValidatorComponent) == 0x0000B0, "Wrong size on UK26CrowPlacementValidatorComponent");
static_assert(offsetof(UK26CrowPlacementValidatorComponent, _objectPlacementValidationStrategyWithRestrictions) == 0x0000A8, "Member 'UK26CrowPlacementValidatorComponent::_objectPlacementValidationStrategyWithRestrictions' has a wrong offset!");

// Class TheK26.K26CrowProjectile
// 0x04F0 (0x0790 - 0x02A0)
class AK26CrowProjectile final : public AActor
{
public:
	uint8                                         Pad_2A0[0x10];                                     // 0x02A0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnCrowProjectileStateChanged;                      // 0x02B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FVector                                _originalFireLocation;                             // 0x02C0(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<EK26ProjectileState, struct FK26ProjectileStateDetails> _projectileStateDetails;                           // 0x02D8(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _summonTime;                                       // 0x0328(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FTunableStat                           _detectionRadiusScaleX;                            // 0x0350(0x0080)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FTunableStat                           _detectionRadiusScaleY;                            // 0x03D0(0x0080)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FTunableStat                           _detectionRadiusScaleZ;                            // 0x0450(0x0080)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _crowFireAuraVisibilityForSurvivorsTime;           // 0x04D0(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _crowSummonAuraVisibilityForSurvivorsTime;         // 0x04F8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _detectionRadiusFromAbove;                         // 0x0520(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _baseSpeed;                                        // 0x0548(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _selfDestructTimeOnDestroyed;                      // 0x0570(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _rangeToTriggerNearSurvivorSFX;                    // 0x0598(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UCurveFloat*                            _onPathMovementSpeedModifierCurve;                 // 0x05C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            _offPathMovementSpeedModifierCurve;                // 0x05C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _projectileOffPathCurveDuration;                   // 0x05D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5D4[0x4];                                      // 0x05D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        _path;                                             // 0x05D8(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, RepNotify, Protected, NativeAccessSpecifierProtected)
	int32                                         _pooledPathIndex;                                  // 0x05E8(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EK26ProjectileState                           _currentProjectileState;                           // 0x05EC(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5ED[0x3];                                      // 0x05ED(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UK26PowerOutlineUpdateStrategy*         _outlineUpdateStrategy;                            // 0x05F0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UK26PowerOutlineUpdateStrategy*         _crowFlockOutlineUpdateStrategy;                   // 0x05F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDBDOutlineComponent*                   _outlineComponent;                                 // 0x0600(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USplineComponent*                       _pathSplineComponent;                              // 0x0608(0x0008)(Edit, ExportObject, Net, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   _collisionStaticMeshComponent;                     // 0x0610(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   _killerInstinctStaticMeshComponent;                // 0x0618(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDBDSkeletalMeshComponentBudgeted*      _visualSkeletalMeshComponent;                      // 0x0620(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        _rootComponent;                                    // 0x0628(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDBDNavModifierComponent*               _dangerNavModifierComponent;                       // 0x0630(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             _k26ProjectileStateChangeDelegate;                 // 0x0638(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnAcquiredChanged;                                 // 0x0648(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_658[0x10];                                     // 0x0658(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ALocker*>                        _lockersWithSurvivorsInitiallyOnKillerInstinctRadius; // 0x0668(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	struct FVector                                _forwardDirection;                                 // 0x0678(0x0018)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _fireTime;                                         // 0x0690(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _currentDistanceAlongSpline;                       // 0x0694(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _offPathTime;                                      // 0x0698(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_69C[0x4];                                      // 0x069C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UK26PowerStatusHandlerComponent*        _statusHandlerComponent;                           // 0x06A0(0x0008)(ExportObject, Net, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UK26AmmoHandlerComponent*               _ammoHandlerComponent;                             // 0x06A8(0x0008)(ExportObject, Net, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UK26PathHandlerComponent*               _pathHandlerComponent;                             // 0x06B0(0x0008)(ExportObject, Net, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6B8[0xD8];                                     // 0x06B8(0x00D8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnCollisionOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool FromSweep, const struct FHitResult& SweepResult);
	void Authority_OnCollisionOverlapEnd(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void Authority_OnDestroyAttempt(const TArray<class AActor*>& InstigatorsForCompletion);
	void Authority_OnDestroyTimerExpired();
	void Authority_OnScoutingOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool FromSweep, const struct FHitResult& SweepResult);
	void Authority_OnScoutingOverlapEnd(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void Authority_OnSummonComplete();
	void Client_LocalKillerStartSummonTimer(const float KillerLocalSummonTime);
	void Cosmetic_OnEnteredNearAudioRangeOfSurvivor(class ACamperPlayer* Survivor);
	void Cosmetic_OnExpiration();
	void HideOutlineFromSurvivor();
	void Local_OnCollisionOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool FromSweep, const struct FHitResult& SweepResult);
	void Local_OnSummonComplete();
	void Multicast_OnExpiration();
	void Multicast_SetStartingPosition(const struct FVector& Position, const struct FRotator& Angle);
	void Multicast_SetState(const EK26ProjectileState NewState, const int32 PooledPathIndex);
	void OnIntroCompleted();
	void OnIsWithinSurvivorRangeChanged(class AActor* SurvivorActor, const bool IsInRange);
	void OnLevelReadyToPlay();
	void OnRep_Path();
	void OnSurvivorAdded(class ACamperPlayer* SurvivorAdded);
	void ProjectileWentOutOfBoundsEvent();
	void Server_OnSurvivorHit(const EK26ProjectileState StateOnHit, class ACamperPlayer* HitSurvivor);

	float GetDistanceFromFirePosition() const;
	bool IsHitboxBeingShown() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K26CrowProjectile">();
	}
	static class AK26CrowProjectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK26CrowProjectile>();
	}
};
static_assert(alignof(AK26CrowProjectile) == 0x000008, "Wrong alignment on AK26CrowProjectile");
static_assert(sizeof(AK26CrowProjectile) == 0x000790, "Wrong size on AK26CrowProjectile");
static_assert(offsetof(AK26CrowProjectile, OnCrowProjectileStateChanged) == 0x0002B0, "Member 'AK26CrowProjectile::OnCrowProjectileStateChanged' has a wrong offset!");
static_assert(offsetof(AK26CrowProjectile, _originalFireLocation) == 0x0002C0, "Member 'AK26CrowProjectile::_originalFireLocation' has a wrong offset!");
static_assert(offsetof(AK26CrowProjectile, _projectileStateDetails) == 0x0002D8, "Member 'AK26CrowProjectile::_projectileStateDetails' has a wrong offset!");
static_assert(offsetof(AK26CrowProjectile, _summonTime) == 0x000328, "Member 'AK26CrowProjectile::_summonTime' has a wrong offset!");
static_assert(offsetof(AK26CrowProjectile, _detectionRadiusScaleX) == 0x000350, "Member 'AK26CrowProjectile::_detectionRadiusScaleX' has a wrong offset!");
static_assert(offsetof(AK26CrowProjectile, _detectionRadiusScaleY) == 0x0003D0, "Member 'AK26CrowProjectile::_detectionRadiusScaleY' has a wrong offset!");
static_assert(offsetof(AK26CrowProjectile, _detectionRadiusScaleZ) == 0x000450, "Member 'AK26CrowProjectile::_detectionRadiusScaleZ' has a wrong offset!");
static_assert(offsetof(AK26CrowProjectile, _crowFireAuraVisibilityForSurvivorsTime) == 0x0004D0, "Member 'AK26CrowProjectile::_crowFireAuraVisibilityForSurvivorsTime' has a wrong offset!");
static_assert(offsetof(AK26CrowProjectile, _crowSummonAuraVisibilityForSurvivorsTime) == 0x0004F8, "Member 'AK26CrowProjectile::_crowSummonAuraVisibilityForSurvivorsTime' has a wrong offset!");
static_assert(offsetof(AK26CrowProjectile, _detectionRadiusFromAbove) == 0x000520, "Member 'AK26CrowProjectile::_detectionRadiusFromAbove' has a wrong offset!");
static_assert(offsetof(AK26CrowProjectile, _baseSpeed) == 0x000548, "Member 'AK26CrowProjectile::_baseSpeed' has a wrong offset!");
static_assert(offsetof(AK26CrowProjectile, _selfDestructTimeOnDestroyed) == 0x000570, "Member 'AK26CrowProjectile::_selfDestructTimeOnDestroyed' has a wrong offset!");
static_assert(offsetof(AK26CrowProjectile, _rangeToTriggerNearSurvivorSFX) == 0x000598, "Member 'AK26CrowProjectile::_rangeToTriggerNearSurvivorSFX' has a wrong offset!");
static_assert(offsetof(AK26CrowProjectile, _onPathMovementSpeedModifierCurve) == 0x0005C0, "Member 'AK26CrowProjectile::_onPathMovementSpeedModifierCurve' has a wrong offset!");
static_assert(offsetof(AK26CrowProjectile, _offPathMovementSpeedModifierCurve) == 0x0005C8, "Member 'AK26CrowProjectile::_offPathMovementSpeedModifierCurve' has a wrong offset!");
static_assert(offsetof(AK26CrowProjectile, _projectileOffPathCurveDuration) == 0x0005D0, "Member 'AK26CrowProjectile::_projectileOffPathCurveDuration' has a wrong offset!");
static_assert(offsetof(AK26CrowProjectile, _path) == 0x0005D8, "Member 'AK26CrowProjectile::_path' has a wrong offset!");
static_assert(offsetof(AK26CrowProjectile, _pooledPathIndex) == 0x0005E8, "Member 'AK26CrowProjectile::_pooledPathIndex' has a wrong offset!");
static_assert(offsetof(AK26CrowProjectile, _currentProjectileState) == 0x0005EC, "Member 'AK26CrowProjectile::_currentProjectileState' has a wrong offset!");
static_assert(offsetof(AK26CrowProjectile, _outlineUpdateStrategy) == 0x0005F0, "Member 'AK26CrowProjectile::_outlineUpdateStrategy' has a wrong offset!");
static_assert(offsetof(AK26CrowProjectile, _crowFlockOutlineUpdateStrategy) == 0x0005F8, "Member 'AK26CrowProjectile::_crowFlockOutlineUpdateStrategy' has a wrong offset!");
static_assert(offsetof(AK26CrowProjectile, _outlineComponent) == 0x000600, "Member 'AK26CrowProjectile::_outlineComponent' has a wrong offset!");
static_assert(offsetof(AK26CrowProjectile, _pathSplineComponent) == 0x000608, "Member 'AK26CrowProjectile::_pathSplineComponent' has a wrong offset!");
static_assert(offsetof(AK26CrowProjectile, _collisionStaticMeshComponent) == 0x000610, "Member 'AK26CrowProjectile::_collisionStaticMeshComponent' has a wrong offset!");
static_assert(offsetof(AK26CrowProjectile, _killerInstinctStaticMeshComponent) == 0x000618, "Member 'AK26CrowProjectile::_killerInstinctStaticMeshComponent' has a wrong offset!");
static_assert(offsetof(AK26CrowProjectile, _visualSkeletalMeshComponent) == 0x000620, "Member 'AK26CrowProjectile::_visualSkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(AK26CrowProjectile, _rootComponent) == 0x000628, "Member 'AK26CrowProjectile::_rootComponent' has a wrong offset!");
static_assert(offsetof(AK26CrowProjectile, _dangerNavModifierComponent) == 0x000630, "Member 'AK26CrowProjectile::_dangerNavModifierComponent' has a wrong offset!");
static_assert(offsetof(AK26CrowProjectile, _k26ProjectileStateChangeDelegate) == 0x000638, "Member 'AK26CrowProjectile::_k26ProjectileStateChangeDelegate' has a wrong offset!");
static_assert(offsetof(AK26CrowProjectile, OnAcquiredChanged) == 0x000648, "Member 'AK26CrowProjectile::OnAcquiredChanged' has a wrong offset!");
static_assert(offsetof(AK26CrowProjectile, _lockersWithSurvivorsInitiallyOnKillerInstinctRadius) == 0x000668, "Member 'AK26CrowProjectile::_lockersWithSurvivorsInitiallyOnKillerInstinctRadius' has a wrong offset!");
static_assert(offsetof(AK26CrowProjectile, _forwardDirection) == 0x000678, "Member 'AK26CrowProjectile::_forwardDirection' has a wrong offset!");
static_assert(offsetof(AK26CrowProjectile, _fireTime) == 0x000690, "Member 'AK26CrowProjectile::_fireTime' has a wrong offset!");
static_assert(offsetof(AK26CrowProjectile, _currentDistanceAlongSpline) == 0x000694, "Member 'AK26CrowProjectile::_currentDistanceAlongSpline' has a wrong offset!");
static_assert(offsetof(AK26CrowProjectile, _offPathTime) == 0x000698, "Member 'AK26CrowProjectile::_offPathTime' has a wrong offset!");
static_assert(offsetof(AK26CrowProjectile, _statusHandlerComponent) == 0x0006A0, "Member 'AK26CrowProjectile::_statusHandlerComponent' has a wrong offset!");
static_assert(offsetof(AK26CrowProjectile, _ammoHandlerComponent) == 0x0006A8, "Member 'AK26CrowProjectile::_ammoHandlerComponent' has a wrong offset!");
static_assert(offsetof(AK26CrowProjectile, _pathHandlerComponent) == 0x0006B0, "Member 'AK26CrowProjectile::_pathHandlerComponent' has a wrong offset!");

// Class TheK26.K26CrowProjectileAnimInstance
// 0x0030 (0x0380 - 0x0350)
class UK26CrowProjectileAnimInstance final : public UAnimInstance
{
public:
	bool                                          _isInInvalidState;                                 // 0x0350(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isInSummonState;                                  // 0x0351(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isInIdleState;                                    // 0x0352(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isInFollowPathState;                              // 0x0353(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isInOffPathState;                                 // 0x0354(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isInDestroyedState;                               // 0x0355(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isBeingFlashlighted;                              // 0x0356(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_357[0x1];                                      // 0x0357(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _flashlightProgress;                               // 0x0358(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_35C[0x1C];                                     // 0x035C(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	class AK26CrowProjectile*                     _owningCrowProjectile;                             // 0x0378(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K26CrowProjectileAnimInstance">();
	}
	static class UK26CrowProjectileAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK26CrowProjectileAnimInstance>();
	}
};
static_assert(alignof(UK26CrowProjectileAnimInstance) == 0x000010, "Wrong alignment on UK26CrowProjectileAnimInstance");
static_assert(sizeof(UK26CrowProjectileAnimInstance) == 0x000380, "Wrong size on UK26CrowProjectileAnimInstance");
static_assert(offsetof(UK26CrowProjectileAnimInstance, _isInInvalidState) == 0x000350, "Member 'UK26CrowProjectileAnimInstance::_isInInvalidState' has a wrong offset!");
static_assert(offsetof(UK26CrowProjectileAnimInstance, _isInSummonState) == 0x000351, "Member 'UK26CrowProjectileAnimInstance::_isInSummonState' has a wrong offset!");
static_assert(offsetof(UK26CrowProjectileAnimInstance, _isInIdleState) == 0x000352, "Member 'UK26CrowProjectileAnimInstance::_isInIdleState' has a wrong offset!");
static_assert(offsetof(UK26CrowProjectileAnimInstance, _isInFollowPathState) == 0x000353, "Member 'UK26CrowProjectileAnimInstance::_isInFollowPathState' has a wrong offset!");
static_assert(offsetof(UK26CrowProjectileAnimInstance, _isInOffPathState) == 0x000354, "Member 'UK26CrowProjectileAnimInstance::_isInOffPathState' has a wrong offset!");
static_assert(offsetof(UK26CrowProjectileAnimInstance, _isInDestroyedState) == 0x000355, "Member 'UK26CrowProjectileAnimInstance::_isInDestroyedState' has a wrong offset!");
static_assert(offsetof(UK26CrowProjectileAnimInstance, _isBeingFlashlighted) == 0x000356, "Member 'UK26CrowProjectileAnimInstance::_isBeingFlashlighted' has a wrong offset!");
static_assert(offsetof(UK26CrowProjectileAnimInstance, _flashlightProgress) == 0x000358, "Member 'UK26CrowProjectileAnimInstance::_flashlightProgress' has a wrong offset!");
static_assert(offsetof(UK26CrowProjectileAnimInstance, _owningCrowProjectile) == 0x000378, "Member 'UK26CrowProjectileAnimInstance::_owningCrowProjectile' has a wrong offset!");

// Class TheK26.K26CrowProjectilePlacementValidationStrategy
// 0x0018 (0x00C0 - 0x00A8)
class UK26CrowProjectilePlacementValidationStrategy final : public URestrictedPlacementAreaStrategy
{
public:
	uint8                                         Pad_A8[0x10];                                      // 0x00A8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UK26AmmoHandlerComponent*               _ammoHandler;                                      // 0x00B8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K26CrowProjectilePlacementValidationStrategy">();
	}
	static class UK26CrowProjectilePlacementValidationStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK26CrowProjectilePlacementValidationStrategy>();
	}
};
static_assert(alignof(UK26CrowProjectilePlacementValidationStrategy) == 0x000008, "Wrong alignment on UK26CrowProjectilePlacementValidationStrategy");
static_assert(sizeof(UK26CrowProjectilePlacementValidationStrategy) == 0x0000C0, "Wrong size on UK26CrowProjectilePlacementValidationStrategy");
static_assert(offsetof(UK26CrowProjectilePlacementValidationStrategy, _ammoHandler) == 0x0000B8, "Member 'UK26CrowProjectilePlacementValidationStrategy::_ammoHandler' has a wrong offset!");

// Class TheK26.K26DismissCrowChargeableInteractionDefinition
// 0x00A0 (0x0960 - 0x08C0)
class UK26DismissCrowChargeableInteractionDefinition final : public UChargeableInteractionDefinition
{
public:
	struct FTunableStat                           _chargeTime;                                       // 0x08C0(0x0080)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UK26PowerStatusHandlerComponent*        _k26PowerStatusHandlerComponent;                   // 0x0940(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isLevelReadyToPlay;                               // 0x0948(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_949[0x17];                                     // 0x0949(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnDamageStateChanged(ECamperDamageState OldDamageState, ECamperDamageState CurrentDamageState);
	void OnKillerSet(class ASlasherPlayer* Killer, class UChargeableComponent* ChargeableComponent);
	void OnLevelReadyToPlay();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K26DismissCrowChargeableInteractionDefinition">();
	}
	static class UK26DismissCrowChargeableInteractionDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK26DismissCrowChargeableInteractionDefinition>();
	}
};
static_assert(alignof(UK26DismissCrowChargeableInteractionDefinition) == 0x000010, "Wrong alignment on UK26DismissCrowChargeableInteractionDefinition");
static_assert(sizeof(UK26DismissCrowChargeableInteractionDefinition) == 0x000960, "Wrong size on UK26DismissCrowChargeableInteractionDefinition");
static_assert(offsetof(UK26DismissCrowChargeableInteractionDefinition, _chargeTime) == 0x0008C0, "Member 'UK26DismissCrowChargeableInteractionDefinition::_chargeTime' has a wrong offset!");
static_assert(offsetof(UK26DismissCrowChargeableInteractionDefinition, _k26PowerStatusHandlerComponent) == 0x000940, "Member 'UK26DismissCrowChargeableInteractionDefinition::_k26PowerStatusHandlerComponent' has a wrong offset!");
static_assert(offsetof(UK26DismissCrowChargeableInteractionDefinition, _isLevelReadyToPlay) == 0x000948, "Member 'UK26DismissCrowChargeableInteractionDefinition::_isLevelReadyToPlay' has a wrong offset!");

// Class TheK26.K26FireCrowProjectileInteractionDefinition
// 0x0050 (0x07D0 - 0x0780)
class UK26FireCrowProjectileInteractionDefinition final : public UInteractionDefinition
{
public:
	FMulticastInlineDelegateProperty_             OnProjectileFired;                                 // 0x0778(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UK26CooldownInteractionDefinition*      _cooldownInteraction;                              // 0x0788(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UK26AmmoHandlerComponent*               _ammoHandler;                                      // 0x0790(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UK26PathHandlerComponent*               _pathHandler;                                      // 0x0798(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7A0[0x30];                                     // 0x07A0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Multicast_OnProjectileFired(const class ASlasherPlayer* Killer);
	void Server_RequestFireOnAmmo(class ASlasherPlayer* Killer);
	void SetDependencies(class UK26AmmoHandlerComponent* AmmoHandler, class UK26PathHandlerComponent* PathHandler, class UK26CooldownInteractionDefinition* CooldownInteraction);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K26FireCrowProjectileInteractionDefinition">();
	}
	static class UK26FireCrowProjectileInteractionDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK26FireCrowProjectileInteractionDefinition>();
	}
};
static_assert(alignof(UK26FireCrowProjectileInteractionDefinition) == 0x000010, "Wrong alignment on UK26FireCrowProjectileInteractionDefinition");
static_assert(sizeof(UK26FireCrowProjectileInteractionDefinition) == 0x0007D0, "Wrong size on UK26FireCrowProjectileInteractionDefinition");
static_assert(offsetof(UK26FireCrowProjectileInteractionDefinition, OnProjectileFired) == 0x000778, "Member 'UK26FireCrowProjectileInteractionDefinition::OnProjectileFired' has a wrong offset!");
static_assert(offsetof(UK26FireCrowProjectileInteractionDefinition, _cooldownInteraction) == 0x000788, "Member 'UK26FireCrowProjectileInteractionDefinition::_cooldownInteraction' has a wrong offset!");
static_assert(offsetof(UK26FireCrowProjectileInteractionDefinition, _ammoHandler) == 0x000790, "Member 'UK26FireCrowProjectileInteractionDefinition::_ammoHandler' has a wrong offset!");
static_assert(offsetof(UK26FireCrowProjectileInteractionDefinition, _pathHandler) == 0x000798, "Member 'UK26FireCrowProjectileInteractionDefinition::_pathHandler' has a wrong offset!");

// Class TheK26.K26IsLastCrowRemovalReasonDueToInteraction
// 0x0018 (0x00F8 - 0x00E0)
class UK26IsLastCrowRemovalReasonDueToInteraction final : public UEventDrivenModifierCondition
{
public:
	class AK26AttachedCrow*                       _owningAttachedCrow;                               // 0x00E0(0x0008)(Net, ZeroConstructor, Transient, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UK26PowerStatusHandlerComponent*        _statusHandlerComponent;                           // 0x00E8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F0[0x8];                                       // 0x00F0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnKillerSet(class ASlasherPlayer* Killer);
	void Authority_OnSurvivorStatusIndicatorSet(const class ACamperPlayer* Survivor, class AK26AttachedCrow* AttachedCrow);
	void OnLastRemovalReasonSet(EFK26AttachedCrowRemovalReason LastCrowRemovalReason);
	void OnRep_OwningAttachedCrow();
	void OnSurvivorStatusIndicatorSet(class AK26AttachedCrow* AttachedCrow);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K26IsLastCrowRemovalReasonDueToInteraction">();
	}
	static class UK26IsLastCrowRemovalReasonDueToInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK26IsLastCrowRemovalReasonDueToInteraction>();
	}
};
static_assert(alignof(UK26IsLastCrowRemovalReasonDueToInteraction) == 0x000008, "Wrong alignment on UK26IsLastCrowRemovalReasonDueToInteraction");
static_assert(sizeof(UK26IsLastCrowRemovalReasonDueToInteraction) == 0x0000F8, "Wrong size on UK26IsLastCrowRemovalReasonDueToInteraction");
static_assert(offsetof(UK26IsLastCrowRemovalReasonDueToInteraction, _owningAttachedCrow) == 0x0000E0, "Member 'UK26IsLastCrowRemovalReasonDueToInteraction::_owningAttachedCrow' has a wrong offset!");
static_assert(offsetof(UK26IsLastCrowRemovalReasonDueToInteraction, _statusHandlerComponent) == 0x0000E8, "Member 'UK26IsLastCrowRemovalReasonDueToInteraction::_statusHandlerComponent' has a wrong offset!");

// Class TheK26.K26IsSurvivorInRangeOfAnyIdleCrow
// 0x0030 (0x0110 - 0x00E0)
class UK26IsSurvivorInRangeOfAnyIdleCrow final : public UEventDrivenModifierCondition
{
public:
	FMulticastInlineDelegateProperty_             OnIsTrueChanged;                                   // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_F0[0x8];                                       // 0x00F0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ACamperPlayer*                          _trackedSurvivor;                                  // 0x00F8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_100[0x10];                                     // 0x0100(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnCrowAddedToPool(class AActor* CrowProjectileActor);
	void Authority_OnCrowProjectileStateChanged(class AK26CrowProjectile* CrowProjectile);
	void Authority_OnInRangeChanged(const bool InRange);
	void Authority_SetVariables(class ACamperPlayer* TrackedSurvivor, class UAuthoritativeActorPoolComponent* AuthoritativeActorPoolComponent, const float Range);
	void Multicast_SetIsTrue(const bool IsTrue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K26IsSurvivorInRangeOfAnyIdleCrow">();
	}
	static class UK26IsSurvivorInRangeOfAnyIdleCrow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK26IsSurvivorInRangeOfAnyIdleCrow>();
	}
};
static_assert(alignof(UK26IsSurvivorInRangeOfAnyIdleCrow) == 0x000008, "Wrong alignment on UK26IsSurvivorInRangeOfAnyIdleCrow");
static_assert(sizeof(UK26IsSurvivorInRangeOfAnyIdleCrow) == 0x000110, "Wrong size on UK26IsSurvivorInRangeOfAnyIdleCrow");
static_assert(offsetof(UK26IsSurvivorInRangeOfAnyIdleCrow, OnIsTrueChanged) == 0x0000E0, "Member 'UK26IsSurvivorInRangeOfAnyIdleCrow::OnIsTrueChanged' has a wrong offset!");
static_assert(offsetof(UK26IsSurvivorInRangeOfAnyIdleCrow, _trackedSurvivor) == 0x0000F8, "Member 'UK26IsSurvivorInRangeOfAnyIdleCrow::_trackedSurvivor' has a wrong offset!");

// Class TheK26.K26KillerInstinctStatusEffect
// 0x0090 (0x0410 - 0x0380)
class UK26KillerInstinctStatusEffect final : public UStatusEffect
{
public:
	struct FTunableStat                           _lingerDuration;                                   // 0x0380(0x0080)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TSubclassOf<class UInteractionDefinition>     _openExitGateInteractionClass;                     // 0x0400(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _hasInitializedLingerDuration;                     // 0x0408(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_409[0x7];                                      // 0x0409(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K26KillerInstinctStatusEffect">();
	}
	static class UK26KillerInstinctStatusEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK26KillerInstinctStatusEffect>();
	}
};
static_assert(alignof(UK26KillerInstinctStatusEffect) == 0x000008, "Wrong alignment on UK26KillerInstinctStatusEffect");
static_assert(sizeof(UK26KillerInstinctStatusEffect) == 0x000410, "Wrong size on UK26KillerInstinctStatusEffect");
static_assert(offsetof(UK26KillerInstinctStatusEffect, _lingerDuration) == 0x000380, "Member 'UK26KillerInstinctStatusEffect::_lingerDuration' has a wrong offset!");
static_assert(offsetof(UK26KillerInstinctStatusEffect, _openExitGateInteractionClass) == 0x000400, "Member 'UK26KillerInstinctStatusEffect::_openExitGateInteractionClass' has a wrong offset!");
static_assert(offsetof(UK26KillerInstinctStatusEffect, _hasInitializedLingerDuration) == 0x000408, "Member 'UK26KillerInstinctStatusEffect::_hasInitializedLingerDuration' has a wrong offset!");

// Class TheK26.K26OnCrowAttachLingeringStatusEffectBase
// 0x0060 (0x03E0 - 0x0380)
class UK26OnCrowAttachLingeringStatusEffectBase final : public UStatusEffect
{
public:
	struct FGameplayTag                           _onCrowAttachStateTag;                             // 0x0380(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_38C[0x4];                                      // 0x038C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _lingerTime;                                       // 0x0390(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B8[0x28];                                     // 0x03B8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetLingerTime() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K26OnCrowAttachLingeringStatusEffectBase">();
	}
	static class UK26OnCrowAttachLingeringStatusEffectBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK26OnCrowAttachLingeringStatusEffectBase>();
	}
};
static_assert(alignof(UK26OnCrowAttachLingeringStatusEffectBase) == 0x000008, "Wrong alignment on UK26OnCrowAttachLingeringStatusEffectBase");
static_assert(sizeof(UK26OnCrowAttachLingeringStatusEffectBase) == 0x0003E0, "Wrong size on UK26OnCrowAttachLingeringStatusEffectBase");
static_assert(offsetof(UK26OnCrowAttachLingeringStatusEffectBase, _onCrowAttachStateTag) == 0x000380, "Member 'UK26OnCrowAttachLingeringStatusEffectBase::_onCrowAttachStateTag' has a wrong offset!");
static_assert(offsetof(UK26OnCrowAttachLingeringStatusEffectBase, _lingerTime) == 0x000390, "Member 'UK26OnCrowAttachLingeringStatusEffectBase::_lingerTime' has a wrong offset!");

// Class TheK26.K26P01
// 0x0098 (0x04B8 - 0x0420)
class UK26P01 final : public UPerk
{
public:
	float                                         _generatorBlockDuration[0x3];                      // 0x0420(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _hookedRange[0x3];                                 // 0x042C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _auraRevealDuration;                               // 0x0438(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _finalGeneratorBlockDuration;                      // 0x043C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           _generatorAuraColorForKiller;                      // 0x0440(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _survivorsToBeHooked;                              // 0x0450(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_454[0x4];                                      // 0x0454(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UStatusEffect>              _timedRevealToKillerClass;                         // 0x0458(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class AGenerator*>                     _blockedGenerators;                                // 0x0460(0x0010)(Net, ZeroConstructor, Transient, RepNotify, NativeAccessSpecifierPrivate)
	TArray<class AActor*>                         _hookedSurvivors;                                  // 0x0470(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class UStatusEffect*                          _timedRevealToKillerEffect;                        // 0x0480(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_488[0x30];                                     // 0x0488(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnInRangeChanged(const bool InRange);
	void OnRep_BlockedGenerators();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K26P01">();
	}
	static class UK26P01* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK26P01>();
	}
};
static_assert(alignof(UK26P01) == 0x000008, "Wrong alignment on UK26P01");
static_assert(sizeof(UK26P01) == 0x0004B8, "Wrong size on UK26P01");
static_assert(offsetof(UK26P01, _generatorBlockDuration) == 0x000420, "Member 'UK26P01::_generatorBlockDuration' has a wrong offset!");
static_assert(offsetof(UK26P01, _hookedRange) == 0x00042C, "Member 'UK26P01::_hookedRange' has a wrong offset!");
static_assert(offsetof(UK26P01, _auraRevealDuration) == 0x000438, "Member 'UK26P01::_auraRevealDuration' has a wrong offset!");
static_assert(offsetof(UK26P01, _finalGeneratorBlockDuration) == 0x00043C, "Member 'UK26P01::_finalGeneratorBlockDuration' has a wrong offset!");
static_assert(offsetof(UK26P01, _generatorAuraColorForKiller) == 0x000440, "Member 'UK26P01::_generatorAuraColorForKiller' has a wrong offset!");
static_assert(offsetof(UK26P01, _survivorsToBeHooked) == 0x000450, "Member 'UK26P01::_survivorsToBeHooked' has a wrong offset!");
static_assert(offsetof(UK26P01, _timedRevealToKillerClass) == 0x000458, "Member 'UK26P01::_timedRevealToKillerClass' has a wrong offset!");
static_assert(offsetof(UK26P01, _blockedGenerators) == 0x000460, "Member 'UK26P01::_blockedGenerators' has a wrong offset!");
static_assert(offsetof(UK26P01, _hookedSurvivors) == 0x000470, "Member 'UK26P01::_hookedSurvivors' has a wrong offset!");
static_assert(offsetof(UK26P01, _timedRevealToKillerEffect) == 0x000480, "Member 'UK26P01::_timedRevealToKillerEffect' has a wrong offset!");

// Class TheK26.K26P02
// 0x0070 (0x0490 - 0x0420)
class UK26P02 final : public UPerk
{
public:
	uint8                                         Pad_420[0x8];                                      // 0x0420(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _generatorRegressPercentage[0x3];                  // 0x0428(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_434[0x4];                                      // 0x0434(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class ACamperPlayer*>                    _hookedPlayers;                                    // 0x0438(0x0050)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_488[0x8];                                      // 0x0488(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnSurvivorHookedOnScourgeHook(const struct FGameEventData& GameEventData);

	float GetGeneratorRegressPercentageAtLevel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K26P02">();
	}
	static class UK26P02* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK26P02>();
	}
};
static_assert(alignof(UK26P02) == 0x000008, "Wrong alignment on UK26P02");
static_assert(sizeof(UK26P02) == 0x000490, "Wrong size on UK26P02");
static_assert(offsetof(UK26P02, _generatorRegressPercentage) == 0x000428, "Member 'UK26P02::_generatorRegressPercentage' has a wrong offset!");
static_assert(offsetof(UK26P02, _hookedPlayers) == 0x000438, "Member 'UK26P02::_hookedPlayers' has a wrong offset!");

// Class TheK26.K26PathHandlerComponent
// 0x0178 (0x0220 - 0x00A8)
class UK26PathHandlerComponent final : public UActorComponent
{
public:
	struct FDBDTunableRowHandle                   _maxPathDistance;                                  // 0x00A8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _survivorPathVisibilityTimeOnFire;                 // 0x00D0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _defaultProjectileDistanceFromFloor;               // 0x00F8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _maxPathIterations;                                // 0x0120(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _maxGroundSearchingDistance;                       // 0x0148(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TSubclassOf<class AActor>                     _visualPathPart;                                   // 0x0170(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class AActor>                     _visualPathEndArrow;                               // 0x0178(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _projectileSummonDistance;                         // 0x0180(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class UK26AmmoHandlerComponent*               _ammoHandler;                                      // 0x01A8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UK26CrowPlacementValidatorComponent*    _placementValidator;                               // 0x01B0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FK26PathData>                   _availablePathData;                                // 0x01B8(0x0010)(Net, ZeroConstructor, Transient, RepNotify, NativeAccessSpecifierPrivate)
	TArray<struct FK26Path>                       _availablePaths;                                   // 0x01C8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1D8[0x48];                                     // 0x01D8(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnMaxAmmoSet(const int32 MaxAmmo);
	void Multicast_FillAvailablePathArray(const int32 MaxAmmo);
	void OnIterativeAvailablePathUpdate();
	void OnRep_AvailablePathData();
	void SetDependencies(class UK26AmmoHandlerComponent* AmmoHandler, class UK26CrowPlacementValidatorComponent* PlacementValidator);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K26PathHandlerComponent">();
	}
	static class UK26PathHandlerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK26PathHandlerComponent>();
	}
};
static_assert(alignof(UK26PathHandlerComponent) == 0x000008, "Wrong alignment on UK26PathHandlerComponent");
static_assert(sizeof(UK26PathHandlerComponent) == 0x000220, "Wrong size on UK26PathHandlerComponent");
static_assert(offsetof(UK26PathHandlerComponent, _maxPathDistance) == 0x0000A8, "Member 'UK26PathHandlerComponent::_maxPathDistance' has a wrong offset!");
static_assert(offsetof(UK26PathHandlerComponent, _survivorPathVisibilityTimeOnFire) == 0x0000D0, "Member 'UK26PathHandlerComponent::_survivorPathVisibilityTimeOnFire' has a wrong offset!");
static_assert(offsetof(UK26PathHandlerComponent, _defaultProjectileDistanceFromFloor) == 0x0000F8, "Member 'UK26PathHandlerComponent::_defaultProjectileDistanceFromFloor' has a wrong offset!");
static_assert(offsetof(UK26PathHandlerComponent, _maxPathIterations) == 0x000120, "Member 'UK26PathHandlerComponent::_maxPathIterations' has a wrong offset!");
static_assert(offsetof(UK26PathHandlerComponent, _maxGroundSearchingDistance) == 0x000148, "Member 'UK26PathHandlerComponent::_maxGroundSearchingDistance' has a wrong offset!");
static_assert(offsetof(UK26PathHandlerComponent, _visualPathPart) == 0x000170, "Member 'UK26PathHandlerComponent::_visualPathPart' has a wrong offset!");
static_assert(offsetof(UK26PathHandlerComponent, _visualPathEndArrow) == 0x000178, "Member 'UK26PathHandlerComponent::_visualPathEndArrow' has a wrong offset!");
static_assert(offsetof(UK26PathHandlerComponent, _projectileSummonDistance) == 0x000180, "Member 'UK26PathHandlerComponent::_projectileSummonDistance' has a wrong offset!");
static_assert(offsetof(UK26PathHandlerComponent, _ammoHandler) == 0x0001A8, "Member 'UK26PathHandlerComponent::_ammoHandler' has a wrong offset!");
static_assert(offsetof(UK26PathHandlerComponent, _placementValidator) == 0x0001B0, "Member 'UK26PathHandlerComponent::_placementValidator' has a wrong offset!");
static_assert(offsetof(UK26PathHandlerComponent, _availablePathData) == 0x0001B8, "Member 'UK26PathHandlerComponent::_availablePathData' has a wrong offset!");
static_assert(offsetof(UK26PathHandlerComponent, _availablePaths) == 0x0001C8, "Member 'UK26PathHandlerComponent::_availablePaths' has a wrong offset!");

// Class TheK26.K26PathPart
// 0x0038 (0x02D8 - 0x02A0)
class AK26PathPart final : public AActor
{
public:
	class UStaticMeshComponent*                   _mesh;                                             // 0x02A0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDBDOutlineComponent*                   _outlineComponent;                                 // 0x02A8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      _visualEffectKiller;                               // 0x02B0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      _visualEffectSurvivor;                             // 0x02B8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UK26PowerOutlineUpdateStrategy*         _outlineUpdateStrategy;                            // 0x02C0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        _rootComponent;                                    // 0x02C8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isVisibleForSurvivor;                             // 0x02D0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isVisibleForKiller;                               // 0x02D1(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D2[0x6];                                      // 0x02D2(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K26PathPart">();
	}
	static class AK26PathPart* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK26PathPart>();
	}
};
static_assert(alignof(AK26PathPart) == 0x000008, "Wrong alignment on AK26PathPart");
static_assert(sizeof(AK26PathPart) == 0x0002D8, "Wrong size on AK26PathPart");
static_assert(offsetof(AK26PathPart, _mesh) == 0x0002A0, "Member 'AK26PathPart::_mesh' has a wrong offset!");
static_assert(offsetof(AK26PathPart, _outlineComponent) == 0x0002A8, "Member 'AK26PathPart::_outlineComponent' has a wrong offset!");
static_assert(offsetof(AK26PathPart, _visualEffectKiller) == 0x0002B0, "Member 'AK26PathPart::_visualEffectKiller' has a wrong offset!");
static_assert(offsetof(AK26PathPart, _visualEffectSurvivor) == 0x0002B8, "Member 'AK26PathPart::_visualEffectSurvivor' has a wrong offset!");
static_assert(offsetof(AK26PathPart, _outlineUpdateStrategy) == 0x0002C0, "Member 'AK26PathPart::_outlineUpdateStrategy' has a wrong offset!");
static_assert(offsetof(AK26PathPart, _rootComponent) == 0x0002C8, "Member 'AK26PathPart::_rootComponent' has a wrong offset!");
static_assert(offsetof(AK26PathPart, _isVisibleForSurvivor) == 0x0002D0, "Member 'AK26PathPart::_isVisibleForSurvivor' has a wrong offset!");
static_assert(offsetof(AK26PathPart, _isVisibleForKiller) == 0x0002D1, "Member 'AK26PathPart::_isVisibleForKiller' has a wrong offset!");

// Class TheK26.K26PowerChargePresentationItemProgressComponent
// 0x0008 (0x00B8 - 0x00B0)
class UK26PowerChargePresentationItemProgressComponent final : public UPresentationItemProgressComponent
{
public:
	class UK26AmmoHandlerComponent*               _ammoHandler;                                      // 0x00B0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void SetDependencies(class UK26AmmoHandlerComponent* AmmoHandler);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K26PowerChargePresentationItemProgressComponent">();
	}
	static class UK26PowerChargePresentationItemProgressComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK26PowerChargePresentationItemProgressComponent>();
	}
};
static_assert(alignof(UK26PowerChargePresentationItemProgressComponent) == 0x000008, "Wrong alignment on UK26PowerChargePresentationItemProgressComponent");
static_assert(sizeof(UK26PowerChargePresentationItemProgressComponent) == 0x0000B8, "Wrong size on UK26PowerChargePresentationItemProgressComponent");
static_assert(offsetof(UK26PowerChargePresentationItemProgressComponent, _ammoHandler) == 0x0000B0, "Member 'UK26PowerChargePresentationItemProgressComponent::_ammoHandler' has a wrong offset!");

// Class TheK26.K26PowerChargePresentationPowerFadeComponent
// 0x0008 (0x00B0 - 0x00A8)
class UK26PowerChargePresentationPowerFadeComponent final : public UPresentationPowerFadeComponent
{
public:
	class UK26AmmoHandlerComponent*               _ammoHandler;                                      // 0x00A8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void SetDependencies(class UK26AmmoHandlerComponent* AmmoHandler);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K26PowerChargePresentationPowerFadeComponent">();
	}
	static class UK26PowerChargePresentationPowerFadeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK26PowerChargePresentationPowerFadeComponent>();
	}
};
static_assert(alignof(UK26PowerChargePresentationPowerFadeComponent) == 0x000008, "Wrong alignment on UK26PowerChargePresentationPowerFadeComponent");
static_assert(sizeof(UK26PowerChargePresentationPowerFadeComponent) == 0x0000B0, "Wrong size on UK26PowerChargePresentationPowerFadeComponent");
static_assert(offsetof(UK26PowerChargePresentationPowerFadeComponent, _ammoHandler) == 0x0000A8, "Member 'UK26PowerChargePresentationPowerFadeComponent::_ammoHandler' has a wrong offset!");

// Class TheK26.K26PowerOutlineUpdateStrategy
// 0x0018 (0x00E8 - 0x00D0)
class UK26PowerOutlineUpdateStrategy final : public UOutlineUpdateStrategy
{
public:
	struct FLinearColor                           _k26ProjectileOutlineColour;                       // 0x00D0(0x0010)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isOutlineEnabled;                                 // 0x00E0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isOnlyVisibleForKiller;                           // 0x00E1(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E2[0x6];                                       // 0x00E2(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetOutlineVisibility(bool Param_IsActive);

	bool IsOutlineVisible() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K26PowerOutlineUpdateStrategy">();
	}
	static class UK26PowerOutlineUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK26PowerOutlineUpdateStrategy>();
	}
};
static_assert(alignof(UK26PowerOutlineUpdateStrategy) == 0x000008, "Wrong alignment on UK26PowerOutlineUpdateStrategy");
static_assert(sizeof(UK26PowerOutlineUpdateStrategy) == 0x0000E8, "Wrong size on UK26PowerOutlineUpdateStrategy");
static_assert(offsetof(UK26PowerOutlineUpdateStrategy, _k26ProjectileOutlineColour) == 0x0000D0, "Member 'UK26PowerOutlineUpdateStrategy::_k26ProjectileOutlineColour' has a wrong offset!");
static_assert(offsetof(UK26PowerOutlineUpdateStrategy, _isOutlineEnabled) == 0x0000E0, "Member 'UK26PowerOutlineUpdateStrategy::_isOutlineEnabled' has a wrong offset!");
static_assert(offsetof(UK26PowerOutlineUpdateStrategy, _isOnlyVisibleForKiller) == 0x0000E1, "Member 'UK26PowerOutlineUpdateStrategy::_isOnlyVisibleForKiller' has a wrong offset!");

// Class TheK26.K26PowerStatusHandlerComponent
// 0x00F0 (0x0198 - 0x00A8)
class UK26PowerStatusHandlerComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x10];                                      // 0x00A8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UInteractionDefinition>> _interactionsDuringWhichTheCrowIsIgnored;          // 0x00B8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_C8[0x10];                                      // 0x00C8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _invincibilityTime;                                // 0x00D8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _killerInstinctDelay;                              // 0x0100(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _killerInstinctGracePeriod;                        // 0x0128(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TSubclassOf<class AActor>                     _statusIndicatorClass;                             // 0x0150(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _k26KillerInstinctStatusEffectClass;               // 0x0158(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FK26SurvivorStatus>             _survivorStatusList;                               // 0x0160(0x0010)(Net, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_170[0x28];                                     // 0x0170(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnIntroCompleted();
	void Authority_OnKillerInstinctTimePassed(const class ACamperPlayer* Survivor);
	void Authority_OnSurvivorAdded(class ACamperPlayer* Survivor);
	void Authority_OnSurvivorRemoved(class ACamperPlayer* Survivor);
	void Cosmetic_OnCrowDamagedSurvivor(class ASlasherPlayer* Killer, class ACamperPlayer* Survivor);
	void Cosmetic_OnCrowIdleInterrupt(class ACamperPlayer* Survivor);
	void Multicast_OnCrowAttached(class ACamperPlayer* Survivor);
	void Multicast_OnCrowDamagedSurvivor(class ASlasherPlayer* Killer, class ACamperPlayer* Survivor);
	void Multicast_OnCrowDetached(const class ACamperPlayer* Survivor);
	void Multicast_OnIdleCrowInterrupt(class ACamperPlayer* Survivor);
	void Multicast_OnStartRemovingCrow(const class ACamperPlayer* Survivor);
	void Multicast_OnStopRemovingCrow(const class ACamperPlayer* Survivor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K26PowerStatusHandlerComponent">();
	}
	static class UK26PowerStatusHandlerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK26PowerStatusHandlerComponent>();
	}
};
static_assert(alignof(UK26PowerStatusHandlerComponent) == 0x000008, "Wrong alignment on UK26PowerStatusHandlerComponent");
static_assert(sizeof(UK26PowerStatusHandlerComponent) == 0x000198, "Wrong size on UK26PowerStatusHandlerComponent");
static_assert(offsetof(UK26PowerStatusHandlerComponent, _interactionsDuringWhichTheCrowIsIgnored) == 0x0000B8, "Member 'UK26PowerStatusHandlerComponent::_interactionsDuringWhichTheCrowIsIgnored' has a wrong offset!");
static_assert(offsetof(UK26PowerStatusHandlerComponent, _invincibilityTime) == 0x0000D8, "Member 'UK26PowerStatusHandlerComponent::_invincibilityTime' has a wrong offset!");
static_assert(offsetof(UK26PowerStatusHandlerComponent, _killerInstinctDelay) == 0x000100, "Member 'UK26PowerStatusHandlerComponent::_killerInstinctDelay' has a wrong offset!");
static_assert(offsetof(UK26PowerStatusHandlerComponent, _killerInstinctGracePeriod) == 0x000128, "Member 'UK26PowerStatusHandlerComponent::_killerInstinctGracePeriod' has a wrong offset!");
static_assert(offsetof(UK26PowerStatusHandlerComponent, _statusIndicatorClass) == 0x000150, "Member 'UK26PowerStatusHandlerComponent::_statusIndicatorClass' has a wrong offset!");
static_assert(offsetof(UK26PowerStatusHandlerComponent, _k26KillerInstinctStatusEffectClass) == 0x000158, "Member 'UK26PowerStatusHandlerComponent::_k26KillerInstinctStatusEffectClass' has a wrong offset!");
static_assert(offsetof(UK26PowerStatusHandlerComponent, _survivorStatusList) == 0x000160, "Member 'UK26PowerStatusHandlerComponent::_survivorStatusList' has a wrong offset!");

// Class TheK26.K26SpawnCrowProjectileChargeableInteractionDefinition
// 0x0220 (0x0AE0 - 0x08C0)
class UK26SpawnCrowProjectileChargeableInteractionDefinition final : public UChargeableInteractionDefinition
{
public:
	FMulticastInlineDelegateProperty_             OnChargingStarted;                                 // 0x08C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnChargingStopped;                                 // 0x08D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnProjectileSummoned;                              // 0x08E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FDBDTunableRowHandle                   _chargeCooldownTime;                               // 0x08F0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _summonCooldownTime;                               // 0x0918(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _pathLength;                                       // 0x0940(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _projectileHeight;                                 // 0x0968(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _projectileSummonDistance;                         // 0x0990(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _cooldownGracePeriodPercentage;                    // 0x09B8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _globalSpawnCooldownTime;                          // 0x09E0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _pathDistanceCheckAttempts;                        // 0x0A08(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TSubclassOf<class AK26AimingGuide>            _aimingGuideClass;                                 // 0x0A30(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AK26AimingGuide*                        _local_aimingGuide;                                // 0x0A38(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isConfirmButtonPressed;                           // 0x0A40(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A41[0x7];                                      // 0x0A41(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UK26AmmoHandlerComponent*               _ammoHandler;                                      // 0x0A48(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UK26PathHandlerComponent*               _pathHandler;                                      // 0x0A50(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UK26PowerStatusHandlerComponent*        _statusHandler;                                    // 0x0A58(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _firedFullyChargedEvent;                           // 0x0A60(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isWaitingForSummonAcknowledgement;                // 0x0A61(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A62[0x6];                                      // 0x0A62(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            _globalCooldownMovementSpeedCurve;                 // 0x0A68(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A70[0x70];                                     // 0x0A70(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CanSummonCrow();
	bool CanSummonCrowOnceFullyCharged();
	void Cosmetic_LocalOnSummonCooldownComplete(const int32 AmountOfAmmoLeft, const bool IsInteractionActive);
	void Cosmetic_OnFullyCharged(class ADBDPlayer* Player);
	void Cosmetic_OnSummonButtonUsedWhenCrowSummonIsNotPossible();
	void Local_OnGlobalCooldownDone(class ADBDPlayer* Player);
	void Multicast_OnK26CrowSummonAttemptAcknowledged();
	void Multicast_OnK26CrowSummoned(const class ASlasherPlayer* Killer, const int32 RemainingAmmo, const int32 MaxAmmo);
	void OnConfirmButtonPressed(class ASlasherPlayer* Killer);
	void OnSummonCooldownComplete();
	void Server_PlaceProjectileWithPath(class ASlasherPlayer* Killer, const struct FVector& ProjectileSpawnPoint, const float KillerLocalTime);
	void SetDependencies(class UK26AmmoHandlerComponent* AmmoHandler, class UK26PathHandlerComponent* PathHandler, class UK26PowerStatusHandlerComponent* StatusHandler);
	void SetSummonCooldown();

	bool IsSummonOnCooldown() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K26SpawnCrowProjectileChargeableInteractionDefinition">();
	}
	static class UK26SpawnCrowProjectileChargeableInteractionDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK26SpawnCrowProjectileChargeableInteractionDefinition>();
	}
};
static_assert(alignof(UK26SpawnCrowProjectileChargeableInteractionDefinition) == 0x000010, "Wrong alignment on UK26SpawnCrowProjectileChargeableInteractionDefinition");
static_assert(sizeof(UK26SpawnCrowProjectileChargeableInteractionDefinition) == 0x000AE0, "Wrong size on UK26SpawnCrowProjectileChargeableInteractionDefinition");
static_assert(offsetof(UK26SpawnCrowProjectileChargeableInteractionDefinition, OnChargingStarted) == 0x0008C0, "Member 'UK26SpawnCrowProjectileChargeableInteractionDefinition::OnChargingStarted' has a wrong offset!");
static_assert(offsetof(UK26SpawnCrowProjectileChargeableInteractionDefinition, OnChargingStopped) == 0x0008D0, "Member 'UK26SpawnCrowProjectileChargeableInteractionDefinition::OnChargingStopped' has a wrong offset!");
static_assert(offsetof(UK26SpawnCrowProjectileChargeableInteractionDefinition, OnProjectileSummoned) == 0x0008E0, "Member 'UK26SpawnCrowProjectileChargeableInteractionDefinition::OnProjectileSummoned' has a wrong offset!");
static_assert(offsetof(UK26SpawnCrowProjectileChargeableInteractionDefinition, _chargeCooldownTime) == 0x0008F0, "Member 'UK26SpawnCrowProjectileChargeableInteractionDefinition::_chargeCooldownTime' has a wrong offset!");
static_assert(offsetof(UK26SpawnCrowProjectileChargeableInteractionDefinition, _summonCooldownTime) == 0x000918, "Member 'UK26SpawnCrowProjectileChargeableInteractionDefinition::_summonCooldownTime' has a wrong offset!");
static_assert(offsetof(UK26SpawnCrowProjectileChargeableInteractionDefinition, _pathLength) == 0x000940, "Member 'UK26SpawnCrowProjectileChargeableInteractionDefinition::_pathLength' has a wrong offset!");
static_assert(offsetof(UK26SpawnCrowProjectileChargeableInteractionDefinition, _projectileHeight) == 0x000968, "Member 'UK26SpawnCrowProjectileChargeableInteractionDefinition::_projectileHeight' has a wrong offset!");
static_assert(offsetof(UK26SpawnCrowProjectileChargeableInteractionDefinition, _projectileSummonDistance) == 0x000990, "Member 'UK26SpawnCrowProjectileChargeableInteractionDefinition::_projectileSummonDistance' has a wrong offset!");
static_assert(offsetof(UK26SpawnCrowProjectileChargeableInteractionDefinition, _cooldownGracePeriodPercentage) == 0x0009B8, "Member 'UK26SpawnCrowProjectileChargeableInteractionDefinition::_cooldownGracePeriodPercentage' has a wrong offset!");
static_assert(offsetof(UK26SpawnCrowProjectileChargeableInteractionDefinition, _globalSpawnCooldownTime) == 0x0009E0, "Member 'UK26SpawnCrowProjectileChargeableInteractionDefinition::_globalSpawnCooldownTime' has a wrong offset!");
static_assert(offsetof(UK26SpawnCrowProjectileChargeableInteractionDefinition, _pathDistanceCheckAttempts) == 0x000A08, "Member 'UK26SpawnCrowProjectileChargeableInteractionDefinition::_pathDistanceCheckAttempts' has a wrong offset!");
static_assert(offsetof(UK26SpawnCrowProjectileChargeableInteractionDefinition, _aimingGuideClass) == 0x000A30, "Member 'UK26SpawnCrowProjectileChargeableInteractionDefinition::_aimingGuideClass' has a wrong offset!");
static_assert(offsetof(UK26SpawnCrowProjectileChargeableInteractionDefinition, _local_aimingGuide) == 0x000A38, "Member 'UK26SpawnCrowProjectileChargeableInteractionDefinition::_local_aimingGuide' has a wrong offset!");
static_assert(offsetof(UK26SpawnCrowProjectileChargeableInteractionDefinition, _isConfirmButtonPressed) == 0x000A40, "Member 'UK26SpawnCrowProjectileChargeableInteractionDefinition::_isConfirmButtonPressed' has a wrong offset!");
static_assert(offsetof(UK26SpawnCrowProjectileChargeableInteractionDefinition, _ammoHandler) == 0x000A48, "Member 'UK26SpawnCrowProjectileChargeableInteractionDefinition::_ammoHandler' has a wrong offset!");
static_assert(offsetof(UK26SpawnCrowProjectileChargeableInteractionDefinition, _pathHandler) == 0x000A50, "Member 'UK26SpawnCrowProjectileChargeableInteractionDefinition::_pathHandler' has a wrong offset!");
static_assert(offsetof(UK26SpawnCrowProjectileChargeableInteractionDefinition, _statusHandler) == 0x000A58, "Member 'UK26SpawnCrowProjectileChargeableInteractionDefinition::_statusHandler' has a wrong offset!");
static_assert(offsetof(UK26SpawnCrowProjectileChargeableInteractionDefinition, _firedFullyChargedEvent) == 0x000A60, "Member 'UK26SpawnCrowProjectileChargeableInteractionDefinition::_firedFullyChargedEvent' has a wrong offset!");
static_assert(offsetof(UK26SpawnCrowProjectileChargeableInteractionDefinition, _isWaitingForSummonAcknowledgement) == 0x000A61, "Member 'UK26SpawnCrowProjectileChargeableInteractionDefinition::_isWaitingForSummonAcknowledgement' has a wrong offset!");
static_assert(offsetof(UK26SpawnCrowProjectileChargeableInteractionDefinition, _globalCooldownMovementSpeedCurve) == 0x000A68, "Member 'UK26SpawnCrowProjectileChargeableInteractionDefinition::_globalCooldownMovementSpeedCurve' has a wrong offset!");

// Class TheK26.RekindledTotem
// 0x0038 (0x02E8 - 0x02B0)
class ARekindledTotem final : public AStaticMeshActor
{
public:
	struct FLinearColor                           _auraColor;                                        // 0x02B0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USourceBasedOutlineUpdateStrategy*      _outlineStrategy;                                  // 0x02C0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDBDOutlineComponent*                   _outlineComponent;                                 // 0x02C8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D0[0x18];                                     // 0x02D0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CleanseTotem(class ATotem* Totem, const ETotemState OldTotemState);
	void Cosmetic_HideShadowTotem(bool Instant);
	void Cosmetic_ShowShadowTotem(bool Instant);
	void OnParentTotemEndPlay(class AActor* Actor, EEndPlayReason EndPlayReason);
	void RebuildTotem(class ATotem* Totem);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RekindledTotem">();
	}
	static class ARekindledTotem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARekindledTotem>();
	}
};
static_assert(alignof(ARekindledTotem) == 0x000008, "Wrong alignment on ARekindledTotem");
static_assert(sizeof(ARekindledTotem) == 0x0002E8, "Wrong size on ARekindledTotem");
static_assert(offsetof(ARekindledTotem, _auraColor) == 0x0002B0, "Member 'ARekindledTotem::_auraColor' has a wrong offset!");
static_assert(offsetof(ARekindledTotem, _outlineStrategy) == 0x0002C0, "Member 'ARekindledTotem::_outlineStrategy' has a wrong offset!");
static_assert(offsetof(ARekindledTotem, _outlineComponent) == 0x0002C8, "Member 'ARekindledTotem::_outlineComponent' has a wrong offset!");

// Class TheK26.RekindleTotemInteraction
// 0x0020 (0x07A0 - 0x0780)
class URekindleTotemInteraction final : public UInteractionDefinition
{
public:
	float                                         _slasherFacingTolerance;                           // 0x0778(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_77C[0x4];                                      // 0x077C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ARekindledTotem>            _rekindledTotemClass;                              // 0x0780(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ARekindledTotem*                        _rekindledTotem;                                   // 0x0788(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_790[0x10];                                     // 0x0790(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RekindleTotemInteraction">();
	}
	static class URekindleTotemInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<URekindleTotemInteraction>();
	}
};
static_assert(alignof(URekindleTotemInteraction) == 0x000010, "Wrong alignment on URekindleTotemInteraction");
static_assert(sizeof(URekindleTotemInteraction) == 0x0007A0, "Wrong size on URekindleTotemInteraction");
static_assert(offsetof(URekindleTotemInteraction, _slasherFacingTolerance) == 0x000778, "Member 'URekindleTotemInteraction::_slasherFacingTolerance' has a wrong offset!");
static_assert(offsetof(URekindleTotemInteraction, _rekindledTotemClass) == 0x000780, "Member 'URekindleTotemInteraction::_rekindledTotemClass' has a wrong offset!");
static_assert(offsetof(URekindleTotemInteraction, _rekindledTotem) == 0x000788, "Member 'URekindleTotemInteraction::_rekindledTotem' has a wrong offset!");

}

