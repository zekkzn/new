#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: TheK35

#include "Basic.hpp"

#include "DeadByDaylight_structs.hpp"
#include "DeadByDaylight_classes.hpp"
#include "TheK35_structs.hpp"
#include "DBDAnimation_classes.hpp"
#include "DataTableUtilities_structs.hpp"
#include "PhysicsCore_structs.hpp"
#include "Engine_classes.hpp"
#include "StatSystem_structs.hpp"
#include "DBDGameplay_classes.hpp"
#include "GameplayUtilities_classes.hpp"
#include "GameplayTagUtilities_structs.hpp"
#include "DBDCosmetic_classes.hpp"
#include "DBDCompetence_classes.hpp"


namespace SDK
{

// Class TheK35.K35PowerWidgetPresentationComponent
// 0x0000 (0x00C0 - 0x00C0)
class UK35PowerWidgetPresentationComponent : public UPowerWidgetPresentationComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K35PowerWidgetPresentationComponent">();
	}
	static class UK35PowerWidgetPresentationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK35PowerWidgetPresentationComponent>();
	}
};
static_assert(alignof(UK35PowerWidgetPresentationComponent) == 0x000008, "Wrong alignment on UK35PowerWidgetPresentationComponent");
static_assert(sizeof(UK35PowerWidgetPresentationComponent) == 0x0000C0, "Wrong size on UK35PowerWidgetPresentationComponent");

// Class TheK35.K35AimProjectileWidgetComponent
// 0x0018 (0x00D8 - 0x00C0)
class UK35AimProjectileWidgetComponent final : public UK35PowerWidgetPresentationComponent
{
public:
	uint8                                         Pad_C0[0x18];                                      // 0x00C0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K35AimProjectileWidgetComponent">();
	}
	static class UK35AimProjectileWidgetComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK35AimProjectileWidgetComponent>();
	}
};
static_assert(alignof(UK35AimProjectileWidgetComponent) == 0x000008, "Wrong alignment on UK35AimProjectileWidgetComponent");
static_assert(sizeof(UK35AimProjectileWidgetComponent) == 0x0000D8, "Wrong size on UK35AimProjectileWidgetComponent");

// Class TheK35.K35AnimInstance
// 0x0020 (0x0740 - 0x0720)
class UK35AnimInstance final : public UKillerAnimInstance
{
public:
	bool                                          _isChargingAreaBlastTravelProjectile;              // 0x0720(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isShootingAreaBlastTravelProjectile;              // 0x0721(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isTeleporting;                                    // 0x0722(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_723[0x1D];                                     // 0x0723(0x001D)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnGameEventReceived(const struct FGameplayTag& GameplayTag, const struct FGameEventData& GameEventData);
	void ResetIsShootingAreaBlastTravelProjectile();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K35AnimInstance">();
	}
	static class UK35AnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK35AnimInstance>();
	}
};
static_assert(alignof(UK35AnimInstance) == 0x000010, "Wrong alignment on UK35AnimInstance");
static_assert(sizeof(UK35AnimInstance) == 0x000740, "Wrong size on UK35AnimInstance");
static_assert(offsetof(UK35AnimInstance, _isChargingAreaBlastTravelProjectile) == 0x000720, "Member 'UK35AnimInstance::_isChargingAreaBlastTravelProjectile' has a wrong offset!");
static_assert(offsetof(UK35AnimInstance, _isShootingAreaBlastTravelProjectile) == 0x000721, "Member 'UK35AnimInstance::_isShootingAreaBlastTravelProjectile' has a wrong offset!");
static_assert(offsetof(UK35AnimInstance, _isTeleporting) == 0x000722, "Member 'UK35AnimInstance::_isTeleporting' has a wrong offset!");

// Class TheK35.K35AreaBlast
// 0x0150 (0x03F0 - 0x02A0)
class AK35AreaBlast final : public AActor
{
public:
	TMap<EK35AreaBlastState, struct FDBDTunableRowHandle> _stateDurationMap;                                 // 0x02A0(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<EK35AreaBlastState, EK35AreaBlastState>  _nextStateMap;                                     // 0x02F0(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UCurveFloat*                            _growCurve;                                        // 0x0340(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            _shrinkCurve;                                      // 0x0348(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USphereComponent*                       _playerCollision;                                  // 0x0350(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        _offsetComponent;                                  // 0x0358(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _minScale;                                         // 0x0360(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _maxScale;                                         // 0x0388(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B0[0x8];                                      // 0x03B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ACamperPlayer*>                  _affectedSurvivors;                                // 0x03B8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3C8[0x28];                                     // 0x03C8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_OnStateChanged(EK35AreaBlastState NewState);
	void Cosmetic_OnSurvivorAfflictedWithKillerEffectByAreaBlast(class ACamperPlayer* Survivor, ECamperDamageState CurrentHealthState);
	void Cosmetic_OnSurvivorDamagedByAreaBlast(class ACamperPlayer* Survivor, ECamperDamageState TargetHealthState, bool IsAnySurvivorAlreadyHit);
	void Cosmetic_ToggleAreaBlastDebugSphere();
	void Multicast_Spawn(const struct FVector& SpawnLocation);
	void Multicast_SurvivorAfflictedWithKillerEffectByAreaBlast(class ACamperPlayer* Survivor, ECamperDamageState CurrentHealthState);
	void Multicast_SurvivorDamagedByAreaBlast(class ACamperPlayer* Survivor, ECamperDamageState TargetHealthState);
	void OnIntroCompleted();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K35AreaBlast">();
	}
	static class AK35AreaBlast* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK35AreaBlast>();
	}
};
static_assert(alignof(AK35AreaBlast) == 0x000008, "Wrong alignment on AK35AreaBlast");
static_assert(sizeof(AK35AreaBlast) == 0x0003F0, "Wrong size on AK35AreaBlast");
static_assert(offsetof(AK35AreaBlast, _stateDurationMap) == 0x0002A0, "Member 'AK35AreaBlast::_stateDurationMap' has a wrong offset!");
static_assert(offsetof(AK35AreaBlast, _nextStateMap) == 0x0002F0, "Member 'AK35AreaBlast::_nextStateMap' has a wrong offset!");
static_assert(offsetof(AK35AreaBlast, _growCurve) == 0x000340, "Member 'AK35AreaBlast::_growCurve' has a wrong offset!");
static_assert(offsetof(AK35AreaBlast, _shrinkCurve) == 0x000348, "Member 'AK35AreaBlast::_shrinkCurve' has a wrong offset!");
static_assert(offsetof(AK35AreaBlast, _playerCollision) == 0x000350, "Member 'AK35AreaBlast::_playerCollision' has a wrong offset!");
static_assert(offsetof(AK35AreaBlast, _offsetComponent) == 0x000358, "Member 'AK35AreaBlast::_offsetComponent' has a wrong offset!");
static_assert(offsetof(AK35AreaBlast, _minScale) == 0x000360, "Member 'AK35AreaBlast::_minScale' has a wrong offset!");
static_assert(offsetof(AK35AreaBlast, _maxScale) == 0x000388, "Member 'AK35AreaBlast::_maxScale' has a wrong offset!");
static_assert(offsetof(AK35AreaBlast, _affectedSurvivors) == 0x0003B8, "Member 'AK35AreaBlast::_affectedSurvivors' has a wrong offset!");

// Class TheK35.K35CheatComponent
// 0x0000 (0x00A8 - 0x00A8)
class UK35CheatComponent final : public UActorComponent
{
public:
	void DBD_K35CompleteAllCooldowns() const;
	void DBD_K35CompleteKillerTeleportPointSpawnChargeTime() const;
	void DBD_K35PrintIsAbleToSpawnHuskOnCurrentLocation() const;
	void DBD_K35RecycleOldestKillerTeleportPoint() const;
	void DBD_K35ToggleAreaBlastDebugSphere() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K35CheatComponent">();
	}
	static class UK35CheatComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK35CheatComponent>();
	}
};
static_assert(alignof(UK35CheatComponent) == 0x000008, "Wrong alignment on UK35CheatComponent");
static_assert(sizeof(UK35CheatComponent) == 0x0000A8, "Wrong size on UK35CheatComponent");

// Class TheK35.K35Decoy
// 0x01A8 (0x0490 - 0x02E8)
class AK35Decoy final : public ABaseHusk
{
public:
	uint8                                         Pad_2E8[0x38];                                     // 0x02E8(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _killerOverlapIgnoreOnSpawnDuration;               // 0x0320(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_324[0x4];                                      // 0x0324(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   _playerOverlapComponent;                           // 0x0328(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPrimitivesRegistererComponent*         _primitivesRegistererComponent;                    // 0x0330(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UClippableProviderComponent*            _clippableProviderComponent;                       // 0x0338(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USphereComponent*                       _headSphereComponent;                              // 0x0340(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _bodySocketName;                                   // 0x0348(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _headSocketName;                                   // 0x0354(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCapsuleComponent*                      _bodyCapsuleComponent;                             // 0x0360(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTunableStat                           _selfDestroyTime;                                  // 0x0368(0x0080)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          _isTerrorRadiusAndRedStainActive;                  // 0x03E8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3E9[0x17];                                     // 0x03E9(0x0017)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<TWeakObjectPtr<class ADBDPlayer>>        _overlappingPlayers;                               // 0x0400(0x0050)(Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	class UGameplayTagContainerComponent*         _objectState;                                      // 0x0450(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_458[0x38];                                     // 0x0458(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnSelfDestructTimerComplete();
	void Cosmetic_OnAllPlayersStopOverlap();
	void Cosmetic_OnAmountOfOverlappingPlayersChangedDuringOverlap();
	void Cosmetic_OnAnyPlayerStartsOverlap();
	void Cosmetic_OnIntroCompleted();
	void Cosmetic_OnVisibilityChanged(const bool IsVisible);
	void Multicast_SelfDestruct();
	void Multicast_Spawn(const struct FVector& SpawnLocation);
	void OnIntroCompleted();
	void OnKillerCustomizationMeshChanged();
	void OnKillerSet(class ASlasherPlayer* Killer);
	void OnPlayerOverlapBegin(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComponent, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnPlayerOverlapEnd(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComponent, int32 OtherBodyIndex);
	void SetHuskVisibilityChecked(const bool IsVisible);

	bool IsLocalPlayerOverlapping() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K35Decoy">();
	}
	static class AK35Decoy* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK35Decoy>();
	}
};
static_assert(alignof(AK35Decoy) == 0x000008, "Wrong alignment on AK35Decoy");
static_assert(sizeof(AK35Decoy) == 0x000490, "Wrong size on AK35Decoy");
static_assert(offsetof(AK35Decoy, _killerOverlapIgnoreOnSpawnDuration) == 0x000320, "Member 'AK35Decoy::_killerOverlapIgnoreOnSpawnDuration' has a wrong offset!");
static_assert(offsetof(AK35Decoy, _playerOverlapComponent) == 0x000328, "Member 'AK35Decoy::_playerOverlapComponent' has a wrong offset!");
static_assert(offsetof(AK35Decoy, _primitivesRegistererComponent) == 0x000330, "Member 'AK35Decoy::_primitivesRegistererComponent' has a wrong offset!");
static_assert(offsetof(AK35Decoy, _clippableProviderComponent) == 0x000338, "Member 'AK35Decoy::_clippableProviderComponent' has a wrong offset!");
static_assert(offsetof(AK35Decoy, _headSphereComponent) == 0x000340, "Member 'AK35Decoy::_headSphereComponent' has a wrong offset!");
static_assert(offsetof(AK35Decoy, _bodySocketName) == 0x000348, "Member 'AK35Decoy::_bodySocketName' has a wrong offset!");
static_assert(offsetof(AK35Decoy, _headSocketName) == 0x000354, "Member 'AK35Decoy::_headSocketName' has a wrong offset!");
static_assert(offsetof(AK35Decoy, _bodyCapsuleComponent) == 0x000360, "Member 'AK35Decoy::_bodyCapsuleComponent' has a wrong offset!");
static_assert(offsetof(AK35Decoy, _selfDestroyTime) == 0x000368, "Member 'AK35Decoy::_selfDestroyTime' has a wrong offset!");
static_assert(offsetof(AK35Decoy, _isTerrorRadiusAndRedStainActive) == 0x0003E8, "Member 'AK35Decoy::_isTerrorRadiusAndRedStainActive' has a wrong offset!");
static_assert(offsetof(AK35Decoy, _overlappingPlayers) == 0x000400, "Member 'AK35Decoy::_overlappingPlayers' has a wrong offset!");
static_assert(offsetof(AK35Decoy, _objectState) == 0x000450, "Member 'AK35Decoy::_objectState' has a wrong offset!");

// Class TheK35.K35KillerAreaBlastTravelProjectile
// 0x02F8 (0x06A0 - 0x03A8)
class AK35KillerAreaBlastTravelProjectile final : public AKillerProjectile
{
public:
	class USphereComponent*                       _environmentCollision;                             // 0x03A8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USphereComponent*                       _playerCollision;                                  // 0x03B0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UKillerProjectileDodgeComponent*        _killerProjectileDodge;                            // 0x03B8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _projectileTimeoutTime;                            // 0x03C0(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FTunableStat                           _maxAllowedBounces;                                // 0x03E8(0x0080)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FTunableStat                           _bounciness;                                       // 0x0468(0x0080)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FTunableStat                           _friction;                                         // 0x04E8(0x0080)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FTunableStat                           _hinderedOnPassThroughLifetime;                    // 0x0568(0x0080)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UStatusEffect>              _hinderedOnPassThroughStatusEffectClass;           // 0x05E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isProjectileActive;                               // 0x05F0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5F1[0xAF];                                     // 0x05F1(0x00AF)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnEnvironmentCollisionComponentHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	void Authority_OnEnvironmentCollisionComponentOverlapBegin(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool IsFromSweep, const struct FHitResult& SweepResult);
	void Authority_OnProjectileTimeout();
	void Cosmetic_OnEndReached();
	void Cosmetic_OnLaunch();
	void Cosmetic_OnProjectileHitEnvironment(const struct FVector& ImpactLocation, const struct FVector& ImpactNormal, const EPhysicalSurface& SurfaceType);
	void Cosmetic_OnProjectileHitSurvivor(class ACamperPlayer* Survivor, const float HinderedLifetime);
	void Multicast_OnProjectileReachedEnd(const struct FVector& EndLocation);
	void OnIntroCompleted();
	void OnKillerSet(class ASlasherPlayer* Killer);
	void OnSurvivorHitDetected(class UPrimitiveComponent* Component, const struct FHitResult& Hit);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K35KillerAreaBlastTravelProjectile">();
	}
	static class AK35KillerAreaBlastTravelProjectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK35KillerAreaBlastTravelProjectile>();
	}
};
static_assert(alignof(AK35KillerAreaBlastTravelProjectile) == 0x000008, "Wrong alignment on AK35KillerAreaBlastTravelProjectile");
static_assert(sizeof(AK35KillerAreaBlastTravelProjectile) == 0x0006A0, "Wrong size on AK35KillerAreaBlastTravelProjectile");
static_assert(offsetof(AK35KillerAreaBlastTravelProjectile, _environmentCollision) == 0x0003A8, "Member 'AK35KillerAreaBlastTravelProjectile::_environmentCollision' has a wrong offset!");
static_assert(offsetof(AK35KillerAreaBlastTravelProjectile, _playerCollision) == 0x0003B0, "Member 'AK35KillerAreaBlastTravelProjectile::_playerCollision' has a wrong offset!");
static_assert(offsetof(AK35KillerAreaBlastTravelProjectile, _killerProjectileDodge) == 0x0003B8, "Member 'AK35KillerAreaBlastTravelProjectile::_killerProjectileDodge' has a wrong offset!");
static_assert(offsetof(AK35KillerAreaBlastTravelProjectile, _projectileTimeoutTime) == 0x0003C0, "Member 'AK35KillerAreaBlastTravelProjectile::_projectileTimeoutTime' has a wrong offset!");
static_assert(offsetof(AK35KillerAreaBlastTravelProjectile, _maxAllowedBounces) == 0x0003E8, "Member 'AK35KillerAreaBlastTravelProjectile::_maxAllowedBounces' has a wrong offset!");
static_assert(offsetof(AK35KillerAreaBlastTravelProjectile, _bounciness) == 0x000468, "Member 'AK35KillerAreaBlastTravelProjectile::_bounciness' has a wrong offset!");
static_assert(offsetof(AK35KillerAreaBlastTravelProjectile, _friction) == 0x0004E8, "Member 'AK35KillerAreaBlastTravelProjectile::_friction' has a wrong offset!");
static_assert(offsetof(AK35KillerAreaBlastTravelProjectile, _hinderedOnPassThroughLifetime) == 0x000568, "Member 'AK35KillerAreaBlastTravelProjectile::_hinderedOnPassThroughLifetime' has a wrong offset!");
static_assert(offsetof(AK35KillerAreaBlastTravelProjectile, _hinderedOnPassThroughStatusEffectClass) == 0x0005E8, "Member 'AK35KillerAreaBlastTravelProjectile::_hinderedOnPassThroughStatusEffectClass' has a wrong offset!");
static_assert(offsetof(AK35KillerAreaBlastTravelProjectile, _isProjectileActive) == 0x0005F0, "Member 'AK35KillerAreaBlastTravelProjectile::_isProjectileActive' has a wrong offset!");

// Class TheK35.K35KillerAreaBlastTravelProjectileLauncher
// 0x0080 (0x0218 - 0x0198)
class UK35KillerAreaBlastTravelProjectileLauncher final : public UKillerProjectileLauncher
{
public:
	struct FDBDTunableRowHandle                   _launchSpeed;                                      // 0x0198(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FName                                   _spawnSocketName;                                  // 0x01C0(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1CC[0x4];                                      // 0x01CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            _pitchCurve;                                       // 0x01D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1D8[0x40];                                     // 0x01D8(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K35KillerAreaBlastTravelProjectileLauncher">();
	}
	static class UK35KillerAreaBlastTravelProjectileLauncher* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK35KillerAreaBlastTravelProjectileLauncher>();
	}
};
static_assert(alignof(UK35KillerAreaBlastTravelProjectileLauncher) == 0x000008, "Wrong alignment on UK35KillerAreaBlastTravelProjectileLauncher");
static_assert(sizeof(UK35KillerAreaBlastTravelProjectileLauncher) == 0x000218, "Wrong size on UK35KillerAreaBlastTravelProjectileLauncher");
static_assert(offsetof(UK35KillerAreaBlastTravelProjectileLauncher, _launchSpeed) == 0x000198, "Member 'UK35KillerAreaBlastTravelProjectileLauncher::_launchSpeed' has a wrong offset!");
static_assert(offsetof(UK35KillerAreaBlastTravelProjectileLauncher, _spawnSocketName) == 0x0001C0, "Member 'UK35KillerAreaBlastTravelProjectileLauncher::_spawnSocketName' has a wrong offset!");
static_assert(offsetof(UK35KillerAreaBlastTravelProjectileLauncher, _pitchCurve) == 0x0001D0, "Member 'UK35KillerAreaBlastTravelProjectileLauncher::_pitchCurve' has a wrong offset!");

// Class TheK35.K35KillerEffectTracker
// 0x0098 (0x0140 - 0x00A8)
class UK35KillerEffectTracker final : public UActorComponent
{
public:
	struct FDBDTunableRowHandle                   _removalTime;                                      // 0x00A8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _effectExtensionTimeOnInjury;                      // 0x00D0(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FK35KillerEffectData>           _killerEffectData;                                 // 0x00F8(0x0010)(Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPrivate)
	uint8                                         Pad_108[0x38];                                     // 0x0108(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnSurvivorAdded(class ACamperPlayer* Survivor, class ASlasherPlayer* Killer);
	void Authority_OnSurvivorDowned(const struct FGameplayTag& GameEventType, const struct FGameEventData& GameEventData);
	void Authority_OnSurvivorEscaped(const struct FGameplayTag& GameEventType, const struct FGameEventData& GameEventData);
	void Authority_OnSurvivorFinishedRepairingGenerator(const struct FGameplayTag& GameEventType, const struct FGameEventData& GameEventData);
	void Authority_OnSurvivorInjuredByAreaBlast(const struct FGameplayTag& GameEventType, const struct FGameEventData& GameEventData);
	void Cosmetic_SurvivorGainedKillerEffect(const class ACamperPlayer* Survivor);
	void Cosmetic_SurvivorKillerEffectIncreased(const class ACamperPlayer* Survivor);
	void Cosmetic_SurvivorLostKillerEffect(const class ACamperPlayer* Survivor);
	void Cosmetic_SurvivorStartsRemovingKillerEffect(const class ACamperPlayer* Survivor);
	void Cosmetic_SurvivorStopsRemovingKillerEffect(const class ACamperPlayer* Survivor);
	void OnIntroCompleted();
	void OnRep_KillerEffectData(const TArray<struct FK35KillerEffectData>& OldKillerEffectData);

	float GetKillerEffectRemovalProgressionForSurvivor(const class ACamperPlayer* Survivor) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K35KillerEffectTracker">();
	}
	static class UK35KillerEffectTracker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK35KillerEffectTracker>();
	}
};
static_assert(alignof(UK35KillerEffectTracker) == 0x000008, "Wrong alignment on UK35KillerEffectTracker");
static_assert(sizeof(UK35KillerEffectTracker) == 0x000140, "Wrong size on UK35KillerEffectTracker");
static_assert(offsetof(UK35KillerEffectTracker, _removalTime) == 0x0000A8, "Member 'UK35KillerEffectTracker::_removalTime' has a wrong offset!");
static_assert(offsetof(UK35KillerEffectTracker, _effectExtensionTimeOnInjury) == 0x0000D0, "Member 'UK35KillerEffectTracker::_effectExtensionTimeOnInjury' has a wrong offset!");
static_assert(offsetof(UK35KillerEffectTracker, _killerEffectData) == 0x0000F8, "Member 'UK35KillerEffectTracker::_killerEffectData' has a wrong offset!");

// Class TheK35.K35KillerRemoteDetonateAreaBlastInteractionDefinition
// 0x0010 (0x0790 - 0x0780)
class UK35KillerRemoteDetonateAreaBlastInteractionDefinition final : public UInteractionDefinition
{
public:
	uint8                                         Pad_778[0x18];                                     // 0x0778(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnIntroCompleted();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K35KillerRemoteDetonateAreaBlastInteractionDefinition">();
	}
	static class UK35KillerRemoteDetonateAreaBlastInteractionDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK35KillerRemoteDetonateAreaBlastInteractionDefinition>();
	}
};
static_assert(alignof(UK35KillerRemoteDetonateAreaBlastInteractionDefinition) == 0x000010, "Wrong alignment on UK35KillerRemoteDetonateAreaBlastInteractionDefinition");
static_assert(sizeof(UK35KillerRemoteDetonateAreaBlastInteractionDefinition) == 0x000790, "Wrong size on UK35KillerRemoteDetonateAreaBlastInteractionDefinition");

// Class TheK35.K35KillerShootAreaBlastCooldownInteractionDefinition
// 0x0000 (0x0780 - 0x0780)
class UK35KillerShootAreaBlastCooldownInteractionDefinition final : public UInteractionDefinition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K35KillerShootAreaBlastCooldownInteractionDefinition">();
	}
	static class UK35KillerShootAreaBlastCooldownInteractionDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK35KillerShootAreaBlastCooldownInteractionDefinition>();
	}
};
static_assert(alignof(UK35KillerShootAreaBlastCooldownInteractionDefinition) == 0x000010, "Wrong alignment on UK35KillerShootAreaBlastCooldownInteractionDefinition");
static_assert(sizeof(UK35KillerShootAreaBlastCooldownInteractionDefinition) == 0x000780, "Wrong size on UK35KillerShootAreaBlastCooldownInteractionDefinition");

// Class TheK35.K35KillerShootAreaBlastTravelProjectileChargeableInteractionDefinition
// 0x0160 (0x0A20 - 0x08C0)
class UK35KillerShootAreaBlastTravelProjectileChargeableInteractionDefinition final : public UChargeableInteractionDefinition
{
public:
	uint8                                         Pad_8C0[0x8];                                      // 0x08C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _secondsToCharge;                                  // 0x08C8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FTunableStat                           _secondsCooldown;                                  // 0x08F0(0x0080)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _gracePeriodPercentage;                            // 0x0970(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UCurveFloat*                            _improvedNavigationSpeedCurve;                     // 0x0998(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_9A0[0x80];                                     // 0x09A0(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnKillerTeleportPointSpawn(const struct FGameplayTag& GameEventType, const struct FGameEventData& GameEventData);
	void Cosmetic_OnChargeComplete();
	void Cosmetic_OnCooldownComplete(class ASlasherPlayer* Killer);
	void Multicast_CompleteCooldown();
	void Multicast_UpdateLastTimeLaunched();
	void OnChargeComplete();
	void OnIntroCompleted();
	void OnKillerSet(class ASlasherPlayer* Killer);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K35KillerShootAreaBlastTravelProjectileChargeableInteractionDefinition">();
	}
	static class UK35KillerShootAreaBlastTravelProjectileChargeableInteractionDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK35KillerShootAreaBlastTravelProjectileChargeableInteractionDefinition>();
	}
};
static_assert(alignof(UK35KillerShootAreaBlastTravelProjectileChargeableInteractionDefinition) == 0x000010, "Wrong alignment on UK35KillerShootAreaBlastTravelProjectileChargeableInteractionDefinition");
static_assert(sizeof(UK35KillerShootAreaBlastTravelProjectileChargeableInteractionDefinition) == 0x000A20, "Wrong size on UK35KillerShootAreaBlastTravelProjectileChargeableInteractionDefinition");
static_assert(offsetof(UK35KillerShootAreaBlastTravelProjectileChargeableInteractionDefinition, _secondsToCharge) == 0x0008C8, "Member 'UK35KillerShootAreaBlastTravelProjectileChargeableInteractionDefinition::_secondsToCharge' has a wrong offset!");
static_assert(offsetof(UK35KillerShootAreaBlastTravelProjectileChargeableInteractionDefinition, _secondsCooldown) == 0x0008F0, "Member 'UK35KillerShootAreaBlastTravelProjectileChargeableInteractionDefinition::_secondsCooldown' has a wrong offset!");
static_assert(offsetof(UK35KillerShootAreaBlastTravelProjectileChargeableInteractionDefinition, _gracePeriodPercentage) == 0x000970, "Member 'UK35KillerShootAreaBlastTravelProjectileChargeableInteractionDefinition::_gracePeriodPercentage' has a wrong offset!");
static_assert(offsetof(UK35KillerShootAreaBlastTravelProjectileChargeableInteractionDefinition, _improvedNavigationSpeedCurve) == 0x000998, "Member 'UK35KillerShootAreaBlastTravelProjectileChargeableInteractionDefinition::_improvedNavigationSpeedCurve' has a wrong offset!");

// Class TheK35.K35KillerTeleportPoint
// 0x0210 (0x04F8 - 0x02E8)
class AK35KillerTeleportPoint final : public ABaseHusk
{
public:
	uint8                                         Pad_2E8[0x10];                                     // 0x02E8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnAcquiredChanged;                                 // 0x02F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_308[0x18];                                     // 0x0308(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _rotationSpeed;                                    // 0x0320(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _minRotationDistance;                              // 0x0324(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _dialogRange;                                      // 0x0328(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _decoyTouchDistance;                               // 0x032C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _killerTeleportLingerTime;                         // 0x0330(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_334[0x4];                                      // 0x0334(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _spawnTime;                                        // 0x0338(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class AK35KillerTeleportPointInteractable> _killerTeleportPointInteractableClass;             // 0x0360(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDBDOutlineComponent*                   _outlineComponent;                                 // 0x0368(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UK35KillerTeleportPointOutlineStrategy* _outlineStrategy;                                  // 0x0370(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   _targetOverlapComponent;                           // 0x0378(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   _playerOverlapComponent;                           // 0x0380(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPrimitivesRegistererComponent*         _primitivesRegistererComponent;                    // 0x0388(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UClippableProviderComponent*            _clippableProviderComponent;                       // 0x0390(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USphereComponent*                       _headSphereComponent;                              // 0x0398(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCapsuleComponent*                      _bodyCapsuleComponent;                             // 0x03A0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class USceneComponent*>                _visionCheckingPoints;                             // 0x03A8(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UDBDNavModifierComponent*               _navModifierComponent;                             // 0x03B8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UK35KillerTeleportPointDangerPredictionComponent* _dangerPredictionComponent;                        // 0x03C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EK35KillerTeleportPointState                  _killerTeleportPointState;                         // 0x03C8(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isAcquiredFromPool;                               // 0x03C9(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3CA[0x6];                                      // 0x03CA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class AK35KillerTeleportPointInteractable*    _killerTeleportPointInteractable;                  // 0x03D0(0x0008)(Net, ZeroConstructor, Transient, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3D8[0x60];                                     // 0x03D8(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<TWeakObjectPtr<class ADBDPlayer>>        _overlappingPlayers;                               // 0x0438(0x0050)(Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_488[0x68];                                     // 0x0488(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	class UGameplayTagContainerComponent*         _objectState;                                      // 0x04F0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Authority_OnSpawnComplete();
	void Cosmetic_OnAllPlayersStopOverlap();
	void Cosmetic_OnAmountOfOverlappingPlayersChangedDuringOverlap();
	void Cosmetic_OnAnyPlayerStartsOverlap();
	void Cosmetic_OnCancelledDestroyInteraction(class ADBDPlayer* CaughtSurvivor);
	void Cosmetic_OnHuskFirstTimeActivePerSpawn();
	void Cosmetic_OnKillerTeleportPointStateChanged(const EK35KillerTeleportPointState NewKillerTeleportPointState);
	void Cosmetic_OnVisibilityChanged(const bool IsVisible);
	void Multicast_OnCancelledDestroyInteraction(class ADBDPlayer* CaughtSurvivor);
	void OnDecoyDespawn();
	void OnDecoySpawn(const struct FVector& Location);
	void OnIntroCompleted();
	void OnKillerCustomizationMeshChanged();
	void OnKillerSet(class ASlasherPlayer* Killer);
	void OnKillerTeleportLingerTimeComplete();
	void OnKillerTeleportPointStateChanged(const EK35KillerTeleportPointState NewKillerTeleportPointState);
	void OnPlayerOverlapBegin(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComponent, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnPlayerOverlapEnd(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComponent, int32 OtherBodyIndex);
	void OnRep_IsAcquiredFromPool(bool OldIsAcquiredFromPool);
	void OnRep_KillerTeleportPointInteractable();
	void OnRep_KillerTeleportPointState();
	void SetHuskVisibilityChecked(const bool IsVisible);

	EK35KillerTeleportPointState GetState() const;
	bool IsKillerAbleToTeleportToThisPoint() const;
	bool IsKillerTeleportingToThis() const;
	bool IsLocalPlayerOverlapping() const;
	bool IsSurvivorAbleToDestroyHusk() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K35KillerTeleportPoint">();
	}
	static class AK35KillerTeleportPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK35KillerTeleportPoint>();
	}
};
static_assert(alignof(AK35KillerTeleportPoint) == 0x000008, "Wrong alignment on AK35KillerTeleportPoint");
static_assert(sizeof(AK35KillerTeleportPoint) == 0x0004F8, "Wrong size on AK35KillerTeleportPoint");
static_assert(offsetof(AK35KillerTeleportPoint, OnAcquiredChanged) == 0x0002F8, "Member 'AK35KillerTeleportPoint::OnAcquiredChanged' has a wrong offset!");
static_assert(offsetof(AK35KillerTeleportPoint, _rotationSpeed) == 0x000320, "Member 'AK35KillerTeleportPoint::_rotationSpeed' has a wrong offset!");
static_assert(offsetof(AK35KillerTeleportPoint, _minRotationDistance) == 0x000324, "Member 'AK35KillerTeleportPoint::_minRotationDistance' has a wrong offset!");
static_assert(offsetof(AK35KillerTeleportPoint, _dialogRange) == 0x000328, "Member 'AK35KillerTeleportPoint::_dialogRange' has a wrong offset!");
static_assert(offsetof(AK35KillerTeleportPoint, _decoyTouchDistance) == 0x00032C, "Member 'AK35KillerTeleportPoint::_decoyTouchDistance' has a wrong offset!");
static_assert(offsetof(AK35KillerTeleportPoint, _killerTeleportLingerTime) == 0x000330, "Member 'AK35KillerTeleportPoint::_killerTeleportLingerTime' has a wrong offset!");
static_assert(offsetof(AK35KillerTeleportPoint, _spawnTime) == 0x000338, "Member 'AK35KillerTeleportPoint::_spawnTime' has a wrong offset!");
static_assert(offsetof(AK35KillerTeleportPoint, _killerTeleportPointInteractableClass) == 0x000360, "Member 'AK35KillerTeleportPoint::_killerTeleportPointInteractableClass' has a wrong offset!");
static_assert(offsetof(AK35KillerTeleportPoint, _outlineComponent) == 0x000368, "Member 'AK35KillerTeleportPoint::_outlineComponent' has a wrong offset!");
static_assert(offsetof(AK35KillerTeleportPoint, _outlineStrategy) == 0x000370, "Member 'AK35KillerTeleportPoint::_outlineStrategy' has a wrong offset!");
static_assert(offsetof(AK35KillerTeleportPoint, _targetOverlapComponent) == 0x000378, "Member 'AK35KillerTeleportPoint::_targetOverlapComponent' has a wrong offset!");
static_assert(offsetof(AK35KillerTeleportPoint, _playerOverlapComponent) == 0x000380, "Member 'AK35KillerTeleportPoint::_playerOverlapComponent' has a wrong offset!");
static_assert(offsetof(AK35KillerTeleportPoint, _primitivesRegistererComponent) == 0x000388, "Member 'AK35KillerTeleportPoint::_primitivesRegistererComponent' has a wrong offset!");
static_assert(offsetof(AK35KillerTeleportPoint, _clippableProviderComponent) == 0x000390, "Member 'AK35KillerTeleportPoint::_clippableProviderComponent' has a wrong offset!");
static_assert(offsetof(AK35KillerTeleportPoint, _headSphereComponent) == 0x000398, "Member 'AK35KillerTeleportPoint::_headSphereComponent' has a wrong offset!");
static_assert(offsetof(AK35KillerTeleportPoint, _bodyCapsuleComponent) == 0x0003A0, "Member 'AK35KillerTeleportPoint::_bodyCapsuleComponent' has a wrong offset!");
static_assert(offsetof(AK35KillerTeleportPoint, _visionCheckingPoints) == 0x0003A8, "Member 'AK35KillerTeleportPoint::_visionCheckingPoints' has a wrong offset!");
static_assert(offsetof(AK35KillerTeleportPoint, _navModifierComponent) == 0x0003B8, "Member 'AK35KillerTeleportPoint::_navModifierComponent' has a wrong offset!");
static_assert(offsetof(AK35KillerTeleportPoint, _dangerPredictionComponent) == 0x0003C0, "Member 'AK35KillerTeleportPoint::_dangerPredictionComponent' has a wrong offset!");
static_assert(offsetof(AK35KillerTeleportPoint, _killerTeleportPointState) == 0x0003C8, "Member 'AK35KillerTeleportPoint::_killerTeleportPointState' has a wrong offset!");
static_assert(offsetof(AK35KillerTeleportPoint, _isAcquiredFromPool) == 0x0003C9, "Member 'AK35KillerTeleportPoint::_isAcquiredFromPool' has a wrong offset!");
static_assert(offsetof(AK35KillerTeleportPoint, _killerTeleportPointInteractable) == 0x0003D0, "Member 'AK35KillerTeleportPoint::_killerTeleportPointInteractable' has a wrong offset!");
static_assert(offsetof(AK35KillerTeleportPoint, _overlappingPlayers) == 0x000438, "Member 'AK35KillerTeleportPoint::_overlappingPlayers' has a wrong offset!");
static_assert(offsetof(AK35KillerTeleportPoint, _objectState) == 0x0004F0, "Member 'AK35KillerTeleportPoint::_objectState' has a wrong offset!");

// Class TheK35.K35KillerTeleportPointAnimInstance
// 0x0040 (0x0390 - 0x0350)
class UK35KillerTeleportPointAnimInstance final : public UAnimInstance
{
public:
	bool                                          _isVisible;                                        // 0x0350(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isOnCooldown;                                     // 0x0351(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isBeingDestroyedBySurvivor;                       // 0x0352(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isKillerTeleportingToOwner;                       // 0x0353(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_354[0x3C];                                     // 0x0354(0x003C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnGameEventReceived(const struct FGameplayTag& GameplayTag, const struct FGameEventData& GameEventData);
	void ResetIsKillerTeleportingToOwner();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K35KillerTeleportPointAnimInstance">();
	}
	static class UK35KillerTeleportPointAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK35KillerTeleportPointAnimInstance>();
	}
};
static_assert(alignof(UK35KillerTeleportPointAnimInstance) == 0x000010, "Wrong alignment on UK35KillerTeleportPointAnimInstance");
static_assert(sizeof(UK35KillerTeleportPointAnimInstance) == 0x000390, "Wrong size on UK35KillerTeleportPointAnimInstance");
static_assert(offsetof(UK35KillerTeleportPointAnimInstance, _isVisible) == 0x000350, "Member 'UK35KillerTeleportPointAnimInstance::_isVisible' has a wrong offset!");
static_assert(offsetof(UK35KillerTeleportPointAnimInstance, _isOnCooldown) == 0x000351, "Member 'UK35KillerTeleportPointAnimInstance::_isOnCooldown' has a wrong offset!");
static_assert(offsetof(UK35KillerTeleportPointAnimInstance, _isBeingDestroyedBySurvivor) == 0x000352, "Member 'UK35KillerTeleportPointAnimInstance::_isBeingDestroyedBySurvivor' has a wrong offset!");
static_assert(offsetof(UK35KillerTeleportPointAnimInstance, _isKillerTeleportingToOwner) == 0x000353, "Member 'UK35KillerTeleportPointAnimInstance::_isKillerTeleportingToOwner' has a wrong offset!");

// Class TheK35.K35KillerTeleportPointDangerPredictionComponent
// 0x0000 (0x0110 - 0x0110)
class UK35KillerTeleportPointDangerPredictionComponent final : public UDBDDangerPredictionComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K35KillerTeleportPointDangerPredictionComponent">();
	}
	static class UK35KillerTeleportPointDangerPredictionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK35KillerTeleportPointDangerPredictionComponent>();
	}
};
static_assert(alignof(UK35KillerTeleportPointDangerPredictionComponent) == 0x000008, "Wrong alignment on UK35KillerTeleportPointDangerPredictionComponent");
static_assert(sizeof(UK35KillerTeleportPointDangerPredictionComponent) == 0x000110, "Wrong size on UK35KillerTeleportPointDangerPredictionComponent");

// Class TheK35.K35KillerTeleportPointInteractable
// 0x0000 (0x03A8 - 0x03A8)
class AK35KillerTeleportPointInteractable final : public AInteractable
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K35KillerTeleportPointInteractable">();
	}
	static class AK35KillerTeleportPointInteractable* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK35KillerTeleportPointInteractable>();
	}
};
static_assert(alignof(AK35KillerTeleportPointInteractable) == 0x000008, "Wrong alignment on AK35KillerTeleportPointInteractable");
static_assert(sizeof(AK35KillerTeleportPointInteractable) == 0x0003A8, "Wrong size on AK35KillerTeleportPointInteractable");

// Class TheK35.K35KillerTeleportPointOutlineStrategy
// 0x00B0 (0x0180 - 0x00D0)
class UK35KillerTeleportPointOutlineStrategy final : public UOutlineUpdateStrategy
{
public:
	struct FTunableStat                           _visibleAuraDistanceSurvivor;                      // 0x00D0(0x0080)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_150[0x30];                                     // 0x0150(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnIntroCompleted();
	void OnKillerSet(class ASlasherPlayer* Killer);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K35KillerTeleportPointOutlineStrategy">();
	}
	static class UK35KillerTeleportPointOutlineStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK35KillerTeleportPointOutlineStrategy>();
	}
};
static_assert(alignof(UK35KillerTeleportPointOutlineStrategy) == 0x000008, "Wrong alignment on UK35KillerTeleportPointOutlineStrategy");
static_assert(sizeof(UK35KillerTeleportPointOutlineStrategy) == 0x000180, "Wrong size on UK35KillerTeleportPointOutlineStrategy");
static_assert(offsetof(UK35KillerTeleportPointOutlineStrategy, _visibleAuraDistanceSurvivor) == 0x0000D0, "Member 'UK35KillerTeleportPointOutlineStrategy::_visibleAuraDistanceSurvivor' has a wrong offset!");

// Class TheK35.K35KillerTeleportPointPlacementValidationStrategy
// 0x0018 (0x00C0 - 0x00A8)
class UK35KillerTeleportPointPlacementValidationStrategy final : public URestrictedPlacementAreaStrategy
{
public:
	uint8                                         Pad_A8[0x18];                                      // 0x00A8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnIntroCompleted();
	void OnKillerTeleportPointStateChanged();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K35KillerTeleportPointPlacementValidationStrategy">();
	}
	static class UK35KillerTeleportPointPlacementValidationStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK35KillerTeleportPointPlacementValidationStrategy>();
	}
};
static_assert(alignof(UK35KillerTeleportPointPlacementValidationStrategy) == 0x000008, "Wrong alignment on UK35KillerTeleportPointPlacementValidationStrategy");
static_assert(sizeof(UK35KillerTeleportPointPlacementValidationStrategy) == 0x0000C0, "Wrong size on UK35KillerTeleportPointPlacementValidationStrategy");

// Class TheK35.K35KillerTeleportPointPlacementValidatorComponent
// 0x0008 (0x00B0 - 0x00A8)
class UK35KillerTeleportPointPlacementValidatorComponent final : public UActorComponent
{
public:
	class UObjectPlacementValidationWithRestrictionStrategy* _objectPlacementValidationStrategyWithRestrictions; // 0x00A8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K35KillerTeleportPointPlacementValidatorComponent">();
	}
	static class UK35KillerTeleportPointPlacementValidatorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK35KillerTeleportPointPlacementValidatorComponent>();
	}
};
static_assert(alignof(UK35KillerTeleportPointPlacementValidatorComponent) == 0x000008, "Wrong alignment on UK35KillerTeleportPointPlacementValidatorComponent");
static_assert(sizeof(UK35KillerTeleportPointPlacementValidatorComponent) == 0x0000B0, "Wrong size on UK35KillerTeleportPointPlacementValidatorComponent");
static_assert(offsetof(UK35KillerTeleportPointPlacementValidatorComponent, _objectPlacementValidationStrategyWithRestrictions) == 0x0000A8, "Member 'UK35KillerTeleportPointPlacementValidatorComponent::_objectPlacementValidationStrategyWithRestrictions' has a wrong offset!");

// Class TheK35.K35KillerTeleportPointPool
// 0x01E8 (0x02F0 - 0x0108)
class UK35KillerTeleportPointPool final : public UAuthoritativeActorPoolComponent
{
public:
	uint8                                         Pad_108[0x30];                                     // 0x0108(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTunableStat                           _maxKillerTeleportPoints;                          // 0x0138(0x0080)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FTunableStat                           _secondsCooldown;                                  // 0x01B8(0x0080)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FTunableStat                           _visibleAuraDistanceSurvivor;                      // 0x0238(0x0080)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B8[0x8];                                      // 0x02B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UTimerObject*                           _cooldownTimer;                                    // 0x02C0(0x0008)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C8[0x28];                                     // 0x02C8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnInRangeChanged(const bool IsInRange, class ACamperPlayer* Survivor);
	void Authority_OnSurvivorDamaged(const struct FGameplayTag& GameEventType, const struct FGameEventData& GameEventData);
	void OnIntroCompleted();
	void OnKillerSet(class ASlasherPlayer* Killer);
	void OnKillerTeleportPointAcquiredChanged(const bool IsAcquired);
	void OnKillerTeleportPointCreated(class AActor* Actor);
	void OnKillerTeleportPointSpawned();

	void Authority_OnKillerTeleportCooldownComplete() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K35KillerTeleportPointPool">();
	}
	static class UK35KillerTeleportPointPool* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK35KillerTeleportPointPool>();
	}
};
static_assert(alignof(UK35KillerTeleportPointPool) == 0x000008, "Wrong alignment on UK35KillerTeleportPointPool");
static_assert(sizeof(UK35KillerTeleportPointPool) == 0x0002F0, "Wrong size on UK35KillerTeleportPointPool");
static_assert(offsetof(UK35KillerTeleportPointPool, _maxKillerTeleportPoints) == 0x000138, "Member 'UK35KillerTeleportPointPool::_maxKillerTeleportPoints' has a wrong offset!");
static_assert(offsetof(UK35KillerTeleportPointPool, _secondsCooldown) == 0x0001B8, "Member 'UK35KillerTeleportPointPool::_secondsCooldown' has a wrong offset!");
static_assert(offsetof(UK35KillerTeleportPointPool, _visibleAuraDistanceSurvivor) == 0x000238, "Member 'UK35KillerTeleportPointPool::_visibleAuraDistanceSurvivor' has a wrong offset!");
static_assert(offsetof(UK35KillerTeleportPointPool, _cooldownTimer) == 0x0002C0, "Member 'UK35KillerTeleportPointPool::_cooldownTimer' has a wrong offset!");

// Class TheK35.K35KillerTeleportPointSpawningManager
// 0x0268 (0x0410 - 0x01A8)
class UK35KillerTeleportPointSpawningManager final : public UKillerAbilityComponent
{
public:
	struct FTunableStat                           _maximumChargeTime;                                // 0x01A8(0x0080)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _chargeTimerReductionMultiplierOnManuallyDestroyingKillerTeleportPoint; // 0x0228(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _spawnTime;                                        // 0x0250(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _spawnTimeReductionOnSurvivorHookedWithKillerTeleportPointNearby; // 0x0278(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _spawnTimeReductionOnInjuredSurvivorWithKillerEffect; // 0x02A0(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _addon16SpawnTimeReductionOnWallOrPalletBreakPercentage; // 0x02C8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FTunableStat                           _spawnTimeReductionOnAfflictedSurvivorWithKillerEffect; // 0x02F0(0x0080)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UCurveFloat*                            _spawnTimeMultiplierBySurvivorsAffectedWithKillerEffectCurve; // 0x0370(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_378[0x98];                                     // 0x0378(0x0098)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnSpawnTimerEnded();
	void Authority_OnSurvivorHookedChanged(const struct FGameplayTag& GameEventType, const struct FGameEventData& GameEventData);
	void Cosmetic_OnChargeTimerReduced(const class ASlasherPlayer* Killer);
	void Cosmetic_OnChargingComplete(const class ASlasherPlayer* Killer, const bool IsSpawningPossible);
	void Cosmetic_OnChargingStarted(const class ASlasherPlayer* Killer);
	void Cosmetic_OnSpawnComplete(const class ASlasherPlayer* Killer, const class AK35KillerTeleportPoint* AcquiredTeleportPoint);
	void Cosmetic_OnSpawningCancelled(const class ASlasherPlayer* Killer);
	void Cosmetic_OnSpawningStarted(const class ASlasherPlayer* Killer);
	void Multicast_CompleteChargingTime();
	void Multicast_OnChargingComplete();
	void Multicast_OnChargingStarted();
	void Multicast_OnHookCausedRecycle();
	void Multicast_OnSpawningCancelled();
	void Multicast_OnSpawningComplete(class AK35KillerTeleportPoint* AcquiredTeleportPoint);
	void Multicast_OnSpawningStarted();
	void OnBreakWallOrPallet(const struct FGameplayTag& GameEventType, const struct FGameEventData& GameEventData);
	void OnGeneratorFixed(const struct FGameplayTag& GameEventType, const struct FGameEventData& GameEventData);
	void OnIntroCompleted();
	void OnKillerManuallyDestroyedKillerTeleportPoint(const struct FGameplayTag& GameEventType, const struct FGameEventData& GameEventData);
	void OnKillerSet(class ASlasherPlayer* Killer);
	void OnSurvivorAfflictedWithKillerEffect(const struct FGameplayTag& GameEventType, const struct FGameEventData& GameEventData);
	void OnSurvivorInjuredWithKillerEffect(const struct FGameplayTag& GameEventType, const struct FGameEventData& GameEventData);

	float GetChargeTimerProgress() const;
	float GetSpawnTimerProgress() const;
	bool IsAbleToSpawnKillerTeleportPoint() const;
	bool IsChargeTimerActive() const;
	bool IsSpawnTimerActive() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K35KillerTeleportPointSpawningManager">();
	}
	static class UK35KillerTeleportPointSpawningManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK35KillerTeleportPointSpawningManager>();
	}
};
static_assert(alignof(UK35KillerTeleportPointSpawningManager) == 0x000008, "Wrong alignment on UK35KillerTeleportPointSpawningManager");
static_assert(sizeof(UK35KillerTeleportPointSpawningManager) == 0x000410, "Wrong size on UK35KillerTeleportPointSpawningManager");
static_assert(offsetof(UK35KillerTeleportPointSpawningManager, _maximumChargeTime) == 0x0001A8, "Member 'UK35KillerTeleportPointSpawningManager::_maximumChargeTime' has a wrong offset!");
static_assert(offsetof(UK35KillerTeleportPointSpawningManager, _chargeTimerReductionMultiplierOnManuallyDestroyingKillerTeleportPoint) == 0x000228, "Member 'UK35KillerTeleportPointSpawningManager::_chargeTimerReductionMultiplierOnManuallyDestroyingKillerTeleportPoint' has a wrong offset!");
static_assert(offsetof(UK35KillerTeleportPointSpawningManager, _spawnTime) == 0x000250, "Member 'UK35KillerTeleportPointSpawningManager::_spawnTime' has a wrong offset!");
static_assert(offsetof(UK35KillerTeleportPointSpawningManager, _spawnTimeReductionOnSurvivorHookedWithKillerTeleportPointNearby) == 0x000278, "Member 'UK35KillerTeleportPointSpawningManager::_spawnTimeReductionOnSurvivorHookedWithKillerTeleportPointNearby' has a wrong offset!");
static_assert(offsetof(UK35KillerTeleportPointSpawningManager, _spawnTimeReductionOnInjuredSurvivorWithKillerEffect) == 0x0002A0, "Member 'UK35KillerTeleportPointSpawningManager::_spawnTimeReductionOnInjuredSurvivorWithKillerEffect' has a wrong offset!");
static_assert(offsetof(UK35KillerTeleportPointSpawningManager, _addon16SpawnTimeReductionOnWallOrPalletBreakPercentage) == 0x0002C8, "Member 'UK35KillerTeleportPointSpawningManager::_addon16SpawnTimeReductionOnWallOrPalletBreakPercentage' has a wrong offset!");
static_assert(offsetof(UK35KillerTeleportPointSpawningManager, _spawnTimeReductionOnAfflictedSurvivorWithKillerEffect) == 0x0002F0, "Member 'UK35KillerTeleportPointSpawningManager::_spawnTimeReductionOnAfflictedSurvivorWithKillerEffect' has a wrong offset!");
static_assert(offsetof(UK35KillerTeleportPointSpawningManager, _spawnTimeMultiplierBySurvivorsAffectedWithKillerEffectCurve) == 0x000370, "Member 'UK35KillerTeleportPointSpawningManager::_spawnTimeMultiplierBySurvivorsAffectedWithKillerEffectCurve' has a wrong offset!");

// Class TheK35.K35KillerTeleportPointTargetingComponent
// 0x0070 (0x0118 - 0x00A8)
class UK35KillerTeleportPointTargetingComponent final : public UActorComponent
{
public:
	struct FDBDTunableRowHandle                   _minimumTeleportDistance;                          // 0x00A8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_D0[0x48];                                      // 0x00D0(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_Local_NewKillerKillerTeleportPointTargeted(class AK35KillerTeleportPoint* NewTarget);

	class AK35KillerTeleportPoint* GetTarget() const;
	bool HasTarget() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K35KillerTeleportPointTargetingComponent">();
	}
	static class UK35KillerTeleportPointTargetingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK35KillerTeleportPointTargetingComponent>();
	}
};
static_assert(alignof(UK35KillerTeleportPointTargetingComponent) == 0x000008, "Wrong alignment on UK35KillerTeleportPointTargetingComponent");
static_assert(sizeof(UK35KillerTeleportPointTargetingComponent) == 0x000118, "Wrong size on UK35KillerTeleportPointTargetingComponent");
static_assert(offsetof(UK35KillerTeleportPointTargetingComponent, _minimumTeleportDistance) == 0x0000A8, "Member 'UK35KillerTeleportPointTargetingComponent::_minimumTeleportDistance' has a wrong offset!");

// Class TheK35.K35KillerTeleportPointTargetingIndicator
// 0x0038 (0x02D8 - 0x02A0)
class AK35KillerTeleportPointTargetingIndicator final : public AActor
{
public:
	struct FK35KillerTeleportPointTargetIndicatorSettings _settings;                                         // 0x02A0(0x0038)(NoDestructor, NativeAccessSpecifierPrivate)

public:
	void Cosmetic_OnSettingsChanged(const struct FK35KillerTeleportPointTargetIndicatorSettings& PreviousSettings, const struct FK35KillerTeleportPointTargetIndicatorSettings& Settings);

	struct FK35KillerTeleportPointTargetIndicatorSettings GetSettings() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K35KillerTeleportPointTargetingIndicator">();
	}
	static class AK35KillerTeleportPointTargetingIndicator* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK35KillerTeleportPointTargetingIndicator>();
	}
};
static_assert(alignof(AK35KillerTeleportPointTargetingIndicator) == 0x000008, "Wrong alignment on AK35KillerTeleportPointTargetingIndicator");
static_assert(sizeof(AK35KillerTeleportPointTargetingIndicator) == 0x0002D8, "Wrong size on AK35KillerTeleportPointTargetingIndicator");
static_assert(offsetof(AK35KillerTeleportPointTargetingIndicator, _settings) == 0x0002A0, "Member 'AK35KillerTeleportPointTargetingIndicator::_settings' has a wrong offset!");

// Class TheK35.K35KillerTeleportToKillerTeleportPointInteractionDefinition
// 0x0190 (0x0910 - 0x0780)
class UK35KillerTeleportToKillerTeleportPointInteractionDefinition final : public UInteractionDefinition
{
public:
	uint8                                         Pad_778[0x8];                                      // 0x0778(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _addon20SurvivorNearDecoyOrKillerTeleportRangeDistance; // 0x0780(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _teleportDuration;                                 // 0x07A8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FTunableStat                           _wakeUpTime;                                       // 0x07D0(0x0080)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         _killerCollisionIgnoredLingerTime;                 // 0x0850(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_854[0xBC];                                     // 0x0854(0x00BC)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_DisableTeleportVignette(class ADBDPlayer* Killer);
	void Cosmetic_EnableTeleportVignette(class ADBDPlayer* Killer);
	void Cosmetic_OnSurvivorScream(const class ACamperPlayer* Survivor);
	void Cosmetic_OnTeleportEnd(const struct FVector& TeleportEndLocation);
	void Cosmetic_OnTeleportStart(const struct FVector& TeleportStartLocation, const struct FVector& TeleportEndLocation, const class AK35KillerTeleportPoint* TeleportPoint, const class ACamperPlayer* InteractingSurvivor);
	void Multicast_OnTeleportEnded(class ADBDPlayer* Player, const struct FVector& TeleportEndLocation);
	void Multicast_OnTeleportStarted(class ADBDPlayer* Player, const struct FVector& TeleportStartLocation, const struct FVector& TeleportEndLocation, class AK35KillerTeleportPoint* TargetTeleportPoint);
	void Multicast_SetTeleportPoint(class AK35KillerTeleportPoint* KillerTeleportPoint);
	void OnKillerCollisionIgnoreLingerComplete(class ADBDPlayer* Player);
	void OnTeleportationComplete(class ADBDPlayer* Player);
	void Server_SetTeleportPoint(class AK35KillerTeleportPoint* KillerTeleportPoint);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K35KillerTeleportToKillerTeleportPointInteractionDefinition">();
	}
	static class UK35KillerTeleportToKillerTeleportPointInteractionDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK35KillerTeleportToKillerTeleportPointInteractionDefinition>();
	}
};
static_assert(alignof(UK35KillerTeleportToKillerTeleportPointInteractionDefinition) == 0x000010, "Wrong alignment on UK35KillerTeleportToKillerTeleportPointInteractionDefinition");
static_assert(sizeof(UK35KillerTeleportToKillerTeleportPointInteractionDefinition) == 0x000910, "Wrong size on UK35KillerTeleportToKillerTeleportPointInteractionDefinition");
static_assert(offsetof(UK35KillerTeleportToKillerTeleportPointInteractionDefinition, _addon20SurvivorNearDecoyOrKillerTeleportRangeDistance) == 0x000780, "Member 'UK35KillerTeleportToKillerTeleportPointInteractionDefinition::_addon20SurvivorNearDecoyOrKillerTeleportRangeDistance' has a wrong offset!");
static_assert(offsetof(UK35KillerTeleportToKillerTeleportPointInteractionDefinition, _teleportDuration) == 0x0007A8, "Member 'UK35KillerTeleportToKillerTeleportPointInteractionDefinition::_teleportDuration' has a wrong offset!");
static_assert(offsetof(UK35KillerTeleportToKillerTeleportPointInteractionDefinition, _wakeUpTime) == 0x0007D0, "Member 'UK35KillerTeleportToKillerTeleportPointInteractionDefinition::_wakeUpTime' has a wrong offset!");
static_assert(offsetof(UK35KillerTeleportToKillerTeleportPointInteractionDefinition, _killerCollisionIgnoredLingerTime) == 0x000850, "Member 'UK35KillerTeleportToKillerTeleportPointInteractionDefinition::_killerCollisionIgnoredLingerTime' has a wrong offset!");

// Class TheK35.K35NeckWormAnimInstance
// 0x0030 (0x0380 - 0x0350)
class UK35NeckWormAnimInstance final : public UAnimInstance
{
public:
	bool                                          _isChargingAreaBlastTravelProjectile;              // 0x0350(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isShootingAreaBlastTravelProjectile;              // 0x0351(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_352[0x2E];                                     // 0x0352(0x002E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnGameEventReceived(const struct FGameplayTag& GameplayTag, const struct FGameEventData& GameEventData);
	void OnKillerSet(class ASlasherPlayer* Killer);
	void ResetIsShootingAreaBlastTravelProjectile();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K35NeckWormAnimInstance">();
	}
	static class UK35NeckWormAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK35NeckWormAnimInstance>();
	}
};
static_assert(alignof(UK35NeckWormAnimInstance) == 0x000010, "Wrong alignment on UK35NeckWormAnimInstance");
static_assert(sizeof(UK35NeckWormAnimInstance) == 0x000380, "Wrong size on UK35NeckWormAnimInstance");
static_assert(offsetof(UK35NeckWormAnimInstance, _isChargingAreaBlastTravelProjectile) == 0x000350, "Member 'UK35NeckWormAnimInstance::_isChargingAreaBlastTravelProjectile' has a wrong offset!");
static_assert(offsetof(UK35NeckWormAnimInstance, _isShootingAreaBlastTravelProjectile) == 0x000351, "Member 'UK35NeckWormAnimInstance::_isShootingAreaBlastTravelProjectile' has a wrong offset!");

// Class TheK35.K35P01
// 0x0020 (0x0440 - 0x0420)
class UK35P01 final : public UPerk
{
public:
	float                                         _activeTime[0x3];                                  // 0x0420(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_42C[0x4];                                      // 0x042C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UStatusEffect>              _timedHasteEffectClass;                            // 0x0430(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _hasteStatusEffectDuration;                        // 0x0438(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _hasteAmount;                                      // 0x043C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K35P01">();
	}
	static class UK35P01* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK35P01>();
	}
};
static_assert(alignof(UK35P01) == 0x000008, "Wrong alignment on UK35P01");
static_assert(sizeof(UK35P01) == 0x000440, "Wrong size on UK35P01");
static_assert(offsetof(UK35P01, _activeTime) == 0x000420, "Member 'UK35P01::_activeTime' has a wrong offset!");
static_assert(offsetof(UK35P01, _timedHasteEffectClass) == 0x000430, "Member 'UK35P01::_timedHasteEffectClass' has a wrong offset!");
static_assert(offsetof(UK35P01, _hasteStatusEffectDuration) == 0x000438, "Member 'UK35P01::_hasteStatusEffectDuration' has a wrong offset!");
static_assert(offsetof(UK35P01, _hasteAmount) == 0x00043C, "Member 'UK35P01::_hasteAmount' has a wrong offset!");

// Class TheK35.K35P02
// 0x0040 (0x0460 - 0x0420)
class UK35P02 final : public UPerk
{
public:
	class UTerrorRadiusEmitterComponent*          _generatorTerrorRadiusEmitter;                     // 0x0420(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStatusEffect*                          _undetectableStatusEffect;                         // 0x0428(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _activePerkDuration[0x3];                          // 0x0430(0x0004)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _cooldownDuration[0x3];                            // 0x043C(0x0004)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _terrorRadiusSize;                                 // 0x0448(0x0004)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_44C[0x4];                                      // 0x044C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UStatusEffect>              _undetectableStatusEffectClass;                    // 0x0450(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_458[0x8];                                      // 0x0458(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K35P02">();
	}
	static class UK35P02* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK35P02>();
	}
};
static_assert(alignof(UK35P02) == 0x000008, "Wrong alignment on UK35P02");
static_assert(sizeof(UK35P02) == 0x000460, "Wrong size on UK35P02");
static_assert(offsetof(UK35P02, _generatorTerrorRadiusEmitter) == 0x000420, "Member 'UK35P02::_generatorTerrorRadiusEmitter' has a wrong offset!");
static_assert(offsetof(UK35P02, _undetectableStatusEffect) == 0x000428, "Member 'UK35P02::_undetectableStatusEffect' has a wrong offset!");
static_assert(offsetof(UK35P02, _activePerkDuration) == 0x000430, "Member 'UK35P02::_activePerkDuration' has a wrong offset!");
static_assert(offsetof(UK35P02, _cooldownDuration) == 0x00043C, "Member 'UK35P02::_cooldownDuration' has a wrong offset!");
static_assert(offsetof(UK35P02, _terrorRadiusSize) == 0x000448, "Member 'UK35P02::_terrorRadiusSize' has a wrong offset!");
static_assert(offsetof(UK35P02, _undetectableStatusEffectClass) == 0x000450, "Member 'UK35P02::_undetectableStatusEffectClass' has a wrong offset!");

// Class TheK35.K35P03
// 0x0018 (0x0438 - 0x0420)
class UK35P03 final : public UPerk
{
public:
	int32                                         _maxTokens[0x3];                                   // 0x0420(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         _tokenGain;                                        // 0x042C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _cooldownTime;                                     // 0x0430(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_434[0x4];                                      // 0x0434(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K35P03">();
	}
	static class UK35P03* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK35P03>();
	}
};
static_assert(alignof(UK35P03) == 0x000008, "Wrong alignment on UK35P03");
static_assert(sizeof(UK35P03) == 0x000438, "Wrong size on UK35P03");
static_assert(offsetof(UK35P03, _maxTokens) == 0x000420, "Member 'UK35P03::_maxTokens' has a wrong offset!");
static_assert(offsetof(UK35P03, _tokenGain) == 0x00042C, "Member 'UK35P03::_tokenGain' has a wrong offset!");
static_assert(offsetof(UK35P03, _cooldownTime) == 0x000430, "Member 'UK35P03::_cooldownTime' has a wrong offset!");

// Class TheK35.K35Power
// 0x0150 (0x0748 - 0x05F8)
class AK35Power final : public AKillerPower
{
public:
	FMulticastInlineDelegateProperty_             OnMoriBegin;                                       // 0x05F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnMoriEnd;                                         // 0x0608(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class AK35AreaBlast>              _areaBlastClass;                                   // 0x0618(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AK35Decoy>                  _decoyClass;                                       // 0x0620(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AK35KillerTeleportPointTargetingIndicator> _teleportPointTargetingIndicatorClass;             // 0x0628(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UStatusEffect>              _extendedDestructionTimeWhenInfectedStatusEffect;  // 0x0630(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractionAttacherComponent*          _interactionAttacherComponent;                     // 0x0638(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _cosmeticIdleTimerBuffer;                          // 0x0640(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _minKillerCosmeticIdleTime;                        // 0x0644(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _maxKillerCosmeticIdleTime;                        // 0x0648(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _minKillerTeleportPointCosmeticIdleTime;           // 0x064C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _maxKillerTeleportPointCosmeticIdleTime;           // 0x0650(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_654[0x4];                                      // 0x0654(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AK35AreaBlast*                          _areaBlast;                                        // 0x0658(0x0008)(Net, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AK35Decoy*                              _decoy;                                            // 0x0660(0x0008)(Net, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AK35KillerTeleportPointTargetingIndicator* _teleportPointTargetingIndicator;                  // 0x0668(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTagStateBool                          _isKillerInMori;                                   // 0x0670(0x0048)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6B8[0x90];                                     // 0x06B8(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnIntroCompleted();
	void OnKillerCosmeticIdleTimeComplete();
	void OnKillerTeleportPointCosmeticIdleTimeComplete();
	void OnMoriStateChanged__DelegateSignature();

	void OnSurvivorAdded(class ACamperPlayer* Survivor) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K35Power">();
	}
	static class AK35Power* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK35Power>();
	}
};
static_assert(alignof(AK35Power) == 0x000008, "Wrong alignment on AK35Power");
static_assert(sizeof(AK35Power) == 0x000748, "Wrong size on AK35Power");
static_assert(offsetof(AK35Power, OnMoriBegin) == 0x0005F8, "Member 'AK35Power::OnMoriBegin' has a wrong offset!");
static_assert(offsetof(AK35Power, OnMoriEnd) == 0x000608, "Member 'AK35Power::OnMoriEnd' has a wrong offset!");
static_assert(offsetof(AK35Power, _areaBlastClass) == 0x000618, "Member 'AK35Power::_areaBlastClass' has a wrong offset!");
static_assert(offsetof(AK35Power, _decoyClass) == 0x000620, "Member 'AK35Power::_decoyClass' has a wrong offset!");
static_assert(offsetof(AK35Power, _teleportPointTargetingIndicatorClass) == 0x000628, "Member 'AK35Power::_teleportPointTargetingIndicatorClass' has a wrong offset!");
static_assert(offsetof(AK35Power, _extendedDestructionTimeWhenInfectedStatusEffect) == 0x000630, "Member 'AK35Power::_extendedDestructionTimeWhenInfectedStatusEffect' has a wrong offset!");
static_assert(offsetof(AK35Power, _interactionAttacherComponent) == 0x000638, "Member 'AK35Power::_interactionAttacherComponent' has a wrong offset!");
static_assert(offsetof(AK35Power, _cosmeticIdleTimerBuffer) == 0x000640, "Member 'AK35Power::_cosmeticIdleTimerBuffer' has a wrong offset!");
static_assert(offsetof(AK35Power, _minKillerCosmeticIdleTime) == 0x000644, "Member 'AK35Power::_minKillerCosmeticIdleTime' has a wrong offset!");
static_assert(offsetof(AK35Power, _maxKillerCosmeticIdleTime) == 0x000648, "Member 'AK35Power::_maxKillerCosmeticIdleTime' has a wrong offset!");
static_assert(offsetof(AK35Power, _minKillerTeleportPointCosmeticIdleTime) == 0x00064C, "Member 'AK35Power::_minKillerTeleportPointCosmeticIdleTime' has a wrong offset!");
static_assert(offsetof(AK35Power, _maxKillerTeleportPointCosmeticIdleTime) == 0x000650, "Member 'AK35Power::_maxKillerTeleportPointCosmeticIdleTime' has a wrong offset!");
static_assert(offsetof(AK35Power, _areaBlast) == 0x000658, "Member 'AK35Power::_areaBlast' has a wrong offset!");
static_assert(offsetof(AK35Power, _decoy) == 0x000660, "Member 'AK35Power::_decoy' has a wrong offset!");
static_assert(offsetof(AK35Power, _teleportPointTargetingIndicator) == 0x000668, "Member 'AK35Power::_teleportPointTargetingIndicator' has a wrong offset!");
static_assert(offsetof(AK35Power, _isKillerInMori) == 0x000670, "Member 'AK35Power::_isKillerInMori' has a wrong offset!");

// Class TheK35.K35PowerWidgetBundlePresentationComponent
// 0x0000 (0x0108 - 0x0108)
class UK35PowerWidgetBundlePresentationComponent final : public UPowerWidgetBundlePresentationComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K35PowerWidgetBundlePresentationComponent">();
	}
	static class UK35PowerWidgetBundlePresentationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK35PowerWidgetBundlePresentationComponent>();
	}
};
static_assert(alignof(UK35PowerWidgetBundlePresentationComponent) == 0x000008, "Wrong alignment on UK35PowerWidgetBundlePresentationComponent");
static_assert(sizeof(UK35PowerWidgetBundlePresentationComponent) == 0x000108, "Wrong size on UK35PowerWidgetBundlePresentationComponent");

// Class TheK35.K35ShootProjectileWidgetComponent
// 0x0018 (0x00D8 - 0x00C0)
class UK35ShootProjectileWidgetComponent final : public UK35PowerWidgetPresentationComponent
{
public:
	uint8                                         Pad_C0[0x18];                                      // 0x00C0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K35ShootProjectileWidgetComponent">();
	}
	static class UK35ShootProjectileWidgetComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK35ShootProjectileWidgetComponent>();
	}
};
static_assert(alignof(UK35ShootProjectileWidgetComponent) == 0x000008, "Wrong alignment on UK35ShootProjectileWidgetComponent");
static_assert(sizeof(UK35ShootProjectileWidgetComponent) == 0x0000D8, "Wrong size on UK35ShootProjectileWidgetComponent");

// Class TheK35.K35SightManager
// 0x0000 (0x0158 - 0x0158)
class UK35SightManager final : public UBaseSightManagerComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K35SightManager">();
	}
	static class UK35SightManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK35SightManager>();
	}
};
static_assert(alignof(UK35SightManager) == 0x000008, "Wrong alignment on UK35SightManager");
static_assert(sizeof(UK35SightManager) == 0x000158, "Wrong size on UK35SightManager");

// Class TheK35.K35SpawnHuskWidgetComponent
// 0x0000 (0x00C0 - 0x00C0)
class UK35SpawnHuskWidgetComponent final : public UK35PowerWidgetPresentationComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K35SpawnHuskWidgetComponent">();
	}
	static class UK35SpawnHuskWidgetComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK35SpawnHuskWidgetComponent>();
	}
};
static_assert(alignof(UK35SpawnHuskWidgetComponent) == 0x000008, "Wrong alignment on UK35SpawnHuskWidgetComponent");
static_assert(sizeof(UK35SpawnHuskWidgetComponent) == 0x0000C0, "Wrong size on UK35SpawnHuskWidgetComponent");

// Class TheK35.K35SurvivorAnimInstance
// 0x0040 (0x0620 - 0x05E0)
class UK35SurvivorAnimInstance final : public UBaseSurvivorAnimInstance
{
public:
	bool                                          _isDestroyingKillerTeleportPoint;                  // 0x05E0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5E1[0x3];                                      // 0x05E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _huskDestructionHorizontalCameraOffset;            // 0x05E4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _huskDestructionVerticalCameraOffset;              // 0x05E8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isAfflictedByKillerEffect;                        // 0x05EC(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isRespondingToKillerTeleportPointInterruptByTeleport; // 0x05ED(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isRespondingToInfection;                          // 0x05EE(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isRespondingToProjectileHindered;                 // 0x05EF(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isRespondingToAreaBlastInjury;                    // 0x05F0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECamperDamageState                            _damageState;                                      // 0x05F1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5F2[0x2];                                      // 0x05F2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _destroyLingerTime;                                // 0x05F4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5F8[0x28];                                     // 0x05F8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EndKillCam();
	void OnGameEventReceived(const struct FGameplayTag& GameplayTag, const struct FGameEventData& GameEventData);
	void ResetRespondingToAreaBlastInjuryEvent();
	void ResetRespondingToInfectionEvent();
	void ResetRespondingToProjectileHinderedEvent();
	void StartKillCam();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K35SurvivorAnimInstance">();
	}
	static class UK35SurvivorAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK35SurvivorAnimInstance>();
	}
};
static_assert(alignof(UK35SurvivorAnimInstance) == 0x000010, "Wrong alignment on UK35SurvivorAnimInstance");
static_assert(sizeof(UK35SurvivorAnimInstance) == 0x000620, "Wrong size on UK35SurvivorAnimInstance");
static_assert(offsetof(UK35SurvivorAnimInstance, _isDestroyingKillerTeleportPoint) == 0x0005E0, "Member 'UK35SurvivorAnimInstance::_isDestroyingKillerTeleportPoint' has a wrong offset!");
static_assert(offsetof(UK35SurvivorAnimInstance, _huskDestructionHorizontalCameraOffset) == 0x0005E4, "Member 'UK35SurvivorAnimInstance::_huskDestructionHorizontalCameraOffset' has a wrong offset!");
static_assert(offsetof(UK35SurvivorAnimInstance, _huskDestructionVerticalCameraOffset) == 0x0005E8, "Member 'UK35SurvivorAnimInstance::_huskDestructionVerticalCameraOffset' has a wrong offset!");
static_assert(offsetof(UK35SurvivorAnimInstance, _isAfflictedByKillerEffect) == 0x0005EC, "Member 'UK35SurvivorAnimInstance::_isAfflictedByKillerEffect' has a wrong offset!");
static_assert(offsetof(UK35SurvivorAnimInstance, _isRespondingToKillerTeleportPointInterruptByTeleport) == 0x0005ED, "Member 'UK35SurvivorAnimInstance::_isRespondingToKillerTeleportPointInterruptByTeleport' has a wrong offset!");
static_assert(offsetof(UK35SurvivorAnimInstance, _isRespondingToInfection) == 0x0005EE, "Member 'UK35SurvivorAnimInstance::_isRespondingToInfection' has a wrong offset!");
static_assert(offsetof(UK35SurvivorAnimInstance, _isRespondingToProjectileHindered) == 0x0005EF, "Member 'UK35SurvivorAnimInstance::_isRespondingToProjectileHindered' has a wrong offset!");
static_assert(offsetof(UK35SurvivorAnimInstance, _isRespondingToAreaBlastInjury) == 0x0005F0, "Member 'UK35SurvivorAnimInstance::_isRespondingToAreaBlastInjury' has a wrong offset!");
static_assert(offsetof(UK35SurvivorAnimInstance, _damageState) == 0x0005F1, "Member 'UK35SurvivorAnimInstance::_damageState' has a wrong offset!");
static_assert(offsetof(UK35SurvivorAnimInstance, _destroyLingerTime) == 0x0005F4, "Member 'UK35SurvivorAnimInstance::_destroyLingerTime' has a wrong offset!");

// Class TheK35.K35SurvivorCosmeticHelperActor
// 0x0010 (0x0318 - 0x0308)
class AK35SurvivorCosmeticHelperActor final : public ASurvivorCosmeticHelperActor
{
public:
	uint8                                         Pad_308[0x10];                                     // 0x0308(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Comsetic_OnIntroCompleted();
	void Cosmetic_OnSurvivorLeftGame();
	void OnIntroCompleted();
	void OnPlayerLeftGame(const struct FGameplayTag& GameplayTag, const struct FGameEventData& GameEventData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K35SurvivorCosmeticHelperActor">();
	}
	static class AK35SurvivorCosmeticHelperActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK35SurvivorCosmeticHelperActor>();
	}
};
static_assert(alignof(AK35SurvivorCosmeticHelperActor) == 0x000008, "Wrong alignment on AK35SurvivorCosmeticHelperActor");
static_assert(sizeof(AK35SurvivorCosmeticHelperActor) == 0x000318, "Wrong size on AK35SurvivorCosmeticHelperActor");

// Class TheK35.K35SurvivorDestroyKillerTeleportPointChargeableInteractionDefinition
// 0x0130 (0x09F0 - 0x08C0)
class UK35SurvivorDestroyKillerTeleportPointChargeableInteractionDefinition final : public UChargeableInteractionDefinition
{
public:
	float                                         _horizontalDestroyCheckDistance;                   // 0x08C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _verticalDestroyCheckDistance;                     // 0x08C4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _cameraCheckSphereRadius;                          // 0x08C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _lineOfSightCheckSphereRadius;                     // 0x08CC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UStatusEffect>              _killerInstinctStatusEffect;                       // 0x08D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _failureKillerInstinctDuration;                    // 0x08D8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _secondsToCharge;                                  // 0x0900(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _interactionDistance;                              // 0x0928(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _gracePeriodPercentage;                            // 0x0950(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _successPercentage;                                // 0x0978(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         _lineOfSightCollisionSize;                         // 0x09A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_9A4[0x4C];                                     // 0x09A4(0x004C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_OnInteractionAvailable(const class ACamperPlayer* Survivor);
	void Cosmetic_OnInteractionNoLongerAvailable(const class ACamperPlayer* Survivor);
	void Cosmetic_OnSurvivorCancelledInteraction(const class ACamperPlayer* Survivor);
	void Cosmetic_OnSurvivorCancelledInteractionDuringGracePeriod(const class ACamperPlayer* Survivor);
	void Cosmetic_OnSurvivorFinishedInteraction(const class ACamperPlayer* Survivor);
	void Cosmetic_OnSurvivorStartInteraction(const class ACamperPlayer* Survivor);
	void OnIntroCompleted();

	class AK35KillerTeleportPoint* GetOwningKillerTeleportPoint() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K35SurvivorDestroyKillerTeleportPointChargeableInteractionDefinition">();
	}
	static class UK35SurvivorDestroyKillerTeleportPointChargeableInteractionDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK35SurvivorDestroyKillerTeleportPointChargeableInteractionDefinition>();
	}
};
static_assert(alignof(UK35SurvivorDestroyKillerTeleportPointChargeableInteractionDefinition) == 0x000010, "Wrong alignment on UK35SurvivorDestroyKillerTeleportPointChargeableInteractionDefinition");
static_assert(sizeof(UK35SurvivorDestroyKillerTeleportPointChargeableInteractionDefinition) == 0x0009F0, "Wrong size on UK35SurvivorDestroyKillerTeleportPointChargeableInteractionDefinition");
static_assert(offsetof(UK35SurvivorDestroyKillerTeleportPointChargeableInteractionDefinition, _horizontalDestroyCheckDistance) == 0x0008C0, "Member 'UK35SurvivorDestroyKillerTeleportPointChargeableInteractionDefinition::_horizontalDestroyCheckDistance' has a wrong offset!");
static_assert(offsetof(UK35SurvivorDestroyKillerTeleportPointChargeableInteractionDefinition, _verticalDestroyCheckDistance) == 0x0008C4, "Member 'UK35SurvivorDestroyKillerTeleportPointChargeableInteractionDefinition::_verticalDestroyCheckDistance' has a wrong offset!");
static_assert(offsetof(UK35SurvivorDestroyKillerTeleportPointChargeableInteractionDefinition, _cameraCheckSphereRadius) == 0x0008C8, "Member 'UK35SurvivorDestroyKillerTeleportPointChargeableInteractionDefinition::_cameraCheckSphereRadius' has a wrong offset!");
static_assert(offsetof(UK35SurvivorDestroyKillerTeleportPointChargeableInteractionDefinition, _lineOfSightCheckSphereRadius) == 0x0008CC, "Member 'UK35SurvivorDestroyKillerTeleportPointChargeableInteractionDefinition::_lineOfSightCheckSphereRadius' has a wrong offset!");
static_assert(offsetof(UK35SurvivorDestroyKillerTeleportPointChargeableInteractionDefinition, _killerInstinctStatusEffect) == 0x0008D0, "Member 'UK35SurvivorDestroyKillerTeleportPointChargeableInteractionDefinition::_killerInstinctStatusEffect' has a wrong offset!");
static_assert(offsetof(UK35SurvivorDestroyKillerTeleportPointChargeableInteractionDefinition, _failureKillerInstinctDuration) == 0x0008D8, "Member 'UK35SurvivorDestroyKillerTeleportPointChargeableInteractionDefinition::_failureKillerInstinctDuration' has a wrong offset!");
static_assert(offsetof(UK35SurvivorDestroyKillerTeleportPointChargeableInteractionDefinition, _secondsToCharge) == 0x000900, "Member 'UK35SurvivorDestroyKillerTeleportPointChargeableInteractionDefinition::_secondsToCharge' has a wrong offset!");
static_assert(offsetof(UK35SurvivorDestroyKillerTeleportPointChargeableInteractionDefinition, _interactionDistance) == 0x000928, "Member 'UK35SurvivorDestroyKillerTeleportPointChargeableInteractionDefinition::_interactionDistance' has a wrong offset!");
static_assert(offsetof(UK35SurvivorDestroyKillerTeleportPointChargeableInteractionDefinition, _gracePeriodPercentage) == 0x000950, "Member 'UK35SurvivorDestroyKillerTeleportPointChargeableInteractionDefinition::_gracePeriodPercentage' has a wrong offset!");
static_assert(offsetof(UK35SurvivorDestroyKillerTeleportPointChargeableInteractionDefinition, _successPercentage) == 0x000978, "Member 'UK35SurvivorDestroyKillerTeleportPointChargeableInteractionDefinition::_successPercentage' has a wrong offset!");
static_assert(offsetof(UK35SurvivorDestroyKillerTeleportPointChargeableInteractionDefinition, _lineOfSightCollisionSize) == 0x0009A0, "Member 'UK35SurvivorDestroyKillerTeleportPointChargeableInteractionDefinition::_lineOfSightCollisionSize' has a wrong offset!");

// Class TheK35.K35SurvivorDestroyKillerTeleportPointFailureStunInteractionDefinition
// 0x0000 (0x0780 - 0x0780)
class UK35SurvivorDestroyKillerTeleportPointFailureStunInteractionDefinition final : public UInteractionDefinition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K35SurvivorDestroyKillerTeleportPointFailureStunInteractionDefinition">();
	}
	static class UK35SurvivorDestroyKillerTeleportPointFailureStunInteractionDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK35SurvivorDestroyKillerTeleportPointFailureStunInteractionDefinition>();
	}
};
static_assert(alignof(UK35SurvivorDestroyKillerTeleportPointFailureStunInteractionDefinition) == 0x000010, "Wrong alignment on UK35SurvivorDestroyKillerTeleportPointFailureStunInteractionDefinition");
static_assert(sizeof(UK35SurvivorDestroyKillerTeleportPointFailureStunInteractionDefinition) == 0x000780, "Wrong size on UK35SurvivorDestroyKillerTeleportPointFailureStunInteractionDefinition");

// Class TheK35.K35SurvivorKillerEffectUIComponent
// 0x0020 (0x00C8 - 0x00A8)
class UK35SurvivorKillerEffectUIComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x20];                                      // 0x00A8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K35SurvivorKillerEffectUIComponent">();
	}
	static class UK35SurvivorKillerEffectUIComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK35SurvivorKillerEffectUIComponent>();
	}
};
static_assert(alignof(UK35SurvivorKillerEffectUIComponent) == 0x000008, "Wrong alignment on UK35SurvivorKillerEffectUIComponent");
static_assert(sizeof(UK35SurvivorKillerEffectUIComponent) == 0x0000C8, "Wrong size on UK35SurvivorKillerEffectUIComponent");

// Class TheK35.K35TeleportToHuskWidgetComponent
// 0x0018 (0x00D8 - 0x00C0)
class UK35TeleportToHuskWidgetComponent final : public UK35PowerWidgetPresentationComponent
{
public:
	uint8                                         Pad_C0[0x18];                                      // 0x00C0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K35TeleportToHuskWidgetComponent">();
	}
	static class UK35TeleportToHuskWidgetComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK35TeleportToHuskWidgetComponent>();
	}
};
static_assert(alignof(UK35TeleportToHuskWidgetComponent) == 0x000008, "Wrong alignment on UK35TeleportToHuskWidgetComponent");
static_assert(sizeof(UK35TeleportToHuskWidgetComponent) == 0x0000D8, "Wrong size on UK35TeleportToHuskWidgetComponent");

// Class TheK35.K35Utilities
// 0x0000 (0x0030 - 0x0030)
class UK35Utilities final : public UBlueprintFunctionLibrary
{
public:
	static class AK35Power* GetK35Power(const class UObject* WorldContextObject);
	static bool IsSurvivorAbleToBeAffectedByPower(const class ACamperPlayer* Survivor, const class ASlasherPlayer* Killer);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K35Utilities">();
	}
	static class UK35Utilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK35Utilities>();
	}
};
static_assert(alignof(UK35Utilities) == 0x000008, "Wrong alignment on UK35Utilities");
static_assert(sizeof(UK35Utilities) == 0x000030, "Wrong size on UK35Utilities");

// Class TheK35.OwningPlayerInK35KillerTeleportPointRange
// 0x0098 (0x0190 - 0x00F8)
class UOwningPlayerInK35KillerTeleportPointRange final : public UAnyActorPairQueryRangeIsTrue
{
public:
	struct FTunableStat                           _killerTeleportPointRange;                         // 0x00F8(0x0080)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_178[0x18];                                     // 0x0178(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAcquiredKillerTeleportPointsChanged();
	void OnIntroComplete();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OwningPlayerInK35KillerTeleportPointRange">();
	}
	static class UOwningPlayerInK35KillerTeleportPointRange* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOwningPlayerInK35KillerTeleportPointRange>();
	}
};
static_assert(alignof(UOwningPlayerInK35KillerTeleportPointRange) == 0x000008, "Wrong alignment on UOwningPlayerInK35KillerTeleportPointRange");
static_assert(sizeof(UOwningPlayerInK35KillerTeleportPointRange) == 0x000190, "Wrong size on UOwningPlayerInK35KillerTeleportPointRange");
static_assert(offsetof(UOwningPlayerInK35KillerTeleportPointRange, _killerTeleportPointRange) == 0x0000F8, "Member 'UOwningPlayerInK35KillerTeleportPointRange::_killerTeleportPointRange' has a wrong offset!");

}

