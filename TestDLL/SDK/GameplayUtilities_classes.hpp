#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: GameplayUtilities

#include "Basic.hpp"

#include "CoreUtilities_structs.hpp"
#include "Engine_classes.hpp"
#include "GameplayTags_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "DataTableUtilities_structs.hpp"
#include "GameplayUtilities_structs.hpp"
#include "Activation_structs.hpp"


namespace SDK
{

// Class GameplayUtilities.BaseInputAccelerationConstraintStrategy
// 0x0000 (0x00A8 - 0x00A8)
class UBaseInputAccelerationConstraintStrategy : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseInputAccelerationConstraintStrategy">();
	}
	static class UBaseInputAccelerationConstraintStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseInputAccelerationConstraintStrategy>();
	}
};
static_assert(alignof(UBaseInputAccelerationConstraintStrategy) == 0x000008, "Wrong alignment on UBaseInputAccelerationConstraintStrategy");
static_assert(sizeof(UBaseInputAccelerationConstraintStrategy) == 0x0000A8, "Wrong size on UBaseInputAccelerationConstraintStrategy");

// Class GameplayUtilities.CharacterPusherComponent
// 0x00B8 (0x0160 - 0x00A8)
class UCharacterPusherComponent : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x30];                                      // 0x00A8(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ACharacter*>                     _charactersToPush;                                 // 0x00D8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TSet<class ACharacter*>                       _ignoredCharacters;                                // 0x00E8(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	class UCapsuleComponent*                      _characterDetector;                                // 0x0138(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCapsuleComponent*                      _characterCollision;                               // 0x0140(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBasePushStrategyComponent*             _pushStrategy;                                     // 0x0148(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class ACharacter*>                     _ignoredByPushedCharacters;                        // 0x0150(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	void Construct(class UCapsuleComponent* CharacterDetector, class UCapsuleComponent* CharacterCollision, class UBasePushStrategyComponent* PushStrategy);
	void OnCharacterDetectorOverlapExit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void SetIgnoredCharacter(class ACharacter* Character, const bool Ignore);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterPusherComponent">();
	}
	static class UCharacterPusherComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterPusherComponent>();
	}
};
static_assert(alignof(UCharacterPusherComponent) == 0x000008, "Wrong alignment on UCharacterPusherComponent");
static_assert(sizeof(UCharacterPusherComponent) == 0x000160, "Wrong size on UCharacterPusherComponent");
static_assert(offsetof(UCharacterPusherComponent, _charactersToPush) == 0x0000D8, "Member 'UCharacterPusherComponent::_charactersToPush' has a wrong offset!");
static_assert(offsetof(UCharacterPusherComponent, _ignoredCharacters) == 0x0000E8, "Member 'UCharacterPusherComponent::_ignoredCharacters' has a wrong offset!");
static_assert(offsetof(UCharacterPusherComponent, _characterDetector) == 0x000138, "Member 'UCharacterPusherComponent::_characterDetector' has a wrong offset!");
static_assert(offsetof(UCharacterPusherComponent, _characterCollision) == 0x000140, "Member 'UCharacterPusherComponent::_characterCollision' has a wrong offset!");
static_assert(offsetof(UCharacterPusherComponent, _pushStrategy) == 0x000148, "Member 'UCharacterPusherComponent::_pushStrategy' has a wrong offset!");
static_assert(offsetof(UCharacterPusherComponent, _ignoredByPushedCharacters) == 0x000150, "Member 'UCharacterPusherComponent::_ignoredByPushedCharacters' has a wrong offset!");

// Class GameplayUtilities.BaseCharacterVelocityCalculationStrategy
// 0x0000 (0x00A8 - 0x00A8)
class UBaseCharacterVelocityCalculationStrategy : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseCharacterVelocityCalculationStrategy">();
	}
	static class UBaseCharacterVelocityCalculationStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseCharacterVelocityCalculationStrategy>();
	}
};
static_assert(alignof(UBaseCharacterVelocityCalculationStrategy) == 0x000008, "Wrong alignment on UBaseCharacterVelocityCalculationStrategy");
static_assert(sizeof(UBaseCharacterVelocityCalculationStrategy) == 0x0000A8, "Wrong size on UBaseCharacterVelocityCalculationStrategy");

// Class GameplayUtilities.ActorPoolComponent
// 0x0040 (0x00E8 - 0x00A8)
class UActorPoolComponent : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x30];                                      // 0x00A8(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AActor>                     _actorClass;                                       // 0x00D8(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _size;                                             // 0x00E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E4[0x4];                                       // 0x00E4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnActorDestroyed(class AActor* DestroyedActor);
	void OnActorsInPoolAcquiredChanged(bool Acquired);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActorPoolComponent">();
	}
	static class UActorPoolComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActorPoolComponent>();
	}
};
static_assert(alignof(UActorPoolComponent) == 0x000008, "Wrong alignment on UActorPoolComponent");
static_assert(sizeof(UActorPoolComponent) == 0x0000E8, "Wrong size on UActorPoolComponent");
static_assert(offsetof(UActorPoolComponent, _actorClass) == 0x0000D8, "Member 'UActorPoolComponent::_actorClass' has a wrong offset!");
static_assert(offsetof(UActorPoolComponent, _size) == 0x0000E0, "Member 'UActorPoolComponent::_size' has a wrong offset!");

// Class GameplayUtilities.BaseCharacterRotationStrategy
// 0x0000 (0x00A8 - 0x00A8)
class UBaseCharacterRotationStrategy : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseCharacterRotationStrategy">();
	}
	static class UBaseCharacterRotationStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseCharacterRotationStrategy>();
	}
};
static_assert(alignof(UBaseCharacterRotationStrategy) == 0x000008, "Wrong alignment on UBaseCharacterRotationStrategy");
static_assert(sizeof(UBaseCharacterRotationStrategy) == 0x0000A8, "Wrong size on UBaseCharacterRotationStrategy");

// Class GameplayUtilities.AuthoritativeActorPoolComponent
// 0x0020 (0x0108 - 0x00E8)
class UAuthoritativeActorPoolComponent : public UActorPoolComponent
{
public:
	TArray<class AActor*>                         _replicatedPool;                                   // 0x00E8(0x0010)(Net, ZeroConstructor, Transient, RepNotify, NativeAccessSpecifierPrivate)
	TArray<class AActor*>                         _local_oldPool;                                    // 0x00F8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	void OnRep_ReplicatedPool();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AuthoritativeActorPoolComponent">();
	}
	static class UAuthoritativeActorPoolComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAuthoritativeActorPoolComponent>();
	}
};
static_assert(alignof(UAuthoritativeActorPoolComponent) == 0x000008, "Wrong alignment on UAuthoritativeActorPoolComponent");
static_assert(sizeof(UAuthoritativeActorPoolComponent) == 0x000108, "Wrong size on UAuthoritativeActorPoolComponent");
static_assert(offsetof(UAuthoritativeActorPoolComponent, _replicatedPool) == 0x0000E8, "Member 'UAuthoritativeActorPoolComponent::_replicatedPool' has a wrong offset!");
static_assert(offsetof(UAuthoritativeActorPoolComponent, _local_oldPool) == 0x0000F8, "Member 'UAuthoritativeActorPoolComponent::_local_oldPool' has a wrong offset!");

// Class GameplayUtilities.BaseReplicatedState
// 0x0020 (0x0050 - 0x0030)
class UBaseReplicatedState : public UObject
{
public:
	struct FGameplayTag                           _id;                                               // 0x0030(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UStateController*                       _stateController;                                  // 0x0040(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseReplicatedState">();
	}
	static class UBaseReplicatedState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseReplicatedState>();
	}
};
static_assert(alignof(UBaseReplicatedState) == 0x000008, "Wrong alignment on UBaseReplicatedState");
static_assert(sizeof(UBaseReplicatedState) == 0x000050, "Wrong size on UBaseReplicatedState");
static_assert(offsetof(UBaseReplicatedState, _id) == 0x000030, "Member 'UBaseReplicatedState::_id' has a wrong offset!");
static_assert(offsetof(UBaseReplicatedState, _stateController) == 0x000040, "Member 'UBaseReplicatedState::_stateController' has a wrong offset!");

// Class GameplayUtilities.BasePoolableActorComponent
// 0x0018 (0x00C0 - 0x00A8)
class UBasePoolableActorComponent : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnAcquiredChanged;                                 // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void SetAcquired(bool Active);

	bool IsAcquired() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BasePoolableActorComponent">();
	}
	static class UBasePoolableActorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBasePoolableActorComponent>();
	}
};
static_assert(alignof(UBasePoolableActorComponent) == 0x000008, "Wrong alignment on UBasePoolableActorComponent");
static_assert(sizeof(UBasePoolableActorComponent) == 0x0000C0, "Wrong size on UBasePoolableActorComponent");
static_assert(offsetof(UBasePoolableActorComponent, OnAcquiredChanged) == 0x0000B0, "Member 'UBasePoolableActorComponent::OnAcquiredChanged' has a wrong offset!");

// Class GameplayUtilities.BasePushStrategyComponent
// 0x0000 (0x00A8 - 0x00A8)
class UBasePushStrategyComponent : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BasePushStrategyComponent">();
	}
	static class UBasePushStrategyComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBasePushStrategyComponent>();
	}
};
static_assert(alignof(UBasePushStrategyComponent) == 0x000008, "Wrong alignment on UBasePushStrategyComponent");
static_assert(sizeof(UBasePushStrategyComponent) == 0x0000A8, "Wrong size on UBasePushStrategyComponent");

// Class GameplayUtilities.AuthoritativePoolableActorComponent
// 0x0008 (0x00C8 - 0x00C0)
class UAuthoritativePoolableActorComponent : public UBasePoolableActorComponent
{
public:
	bool                                          _acquired;                                         // 0x00C0(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C1[0x7];                                       // 0x00C1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_Acquired();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AuthoritativePoolableActorComponent">();
	}
	static class UAuthoritativePoolableActorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAuthoritativePoolableActorComponent>();
	}
};
static_assert(alignof(UAuthoritativePoolableActorComponent) == 0x000008, "Wrong alignment on UAuthoritativePoolableActorComponent");
static_assert(sizeof(UAuthoritativePoolableActorComponent) == 0x0000C8, "Wrong size on UAuthoritativePoolableActorComponent");
static_assert(offsetof(UAuthoritativePoolableActorComponent, _acquired) == 0x0000C0, "Member 'UAuthoritativePoolableActorComponent::_acquired' has a wrong offset!");

// Class GameplayUtilities.ActorPoolInitializer
// 0x0040 (0x00E8 - 0x00A8)
class UActorPoolInitializer final : public UActorComponent
{
public:
	struct FDBDTunableRowHandle                   _poolSize;                                         // 0x00A8(0x0028)(Edit, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D0[0x18];                                      // 0x00D0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActorPoolInitializer">();
	}
	static class UActorPoolInitializer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActorPoolInitializer>();
	}
};
static_assert(alignof(UActorPoolInitializer) == 0x000008, "Wrong alignment on UActorPoolInitializer");
static_assert(sizeof(UActorPoolInitializer) == 0x0000E8, "Wrong size on UActorPoolInitializer");
static_assert(offsetof(UActorPoolInitializer, _poolSize) == 0x0000A8, "Member 'UActorPoolInitializer::_poolSize' has a wrong offset!");

// Class GameplayUtilities.BoxOcclusionQueryComponent
// 0x0020 (0x05F0 - 0x05D0)
class UBoxOcclusionQueryComponent final : public UBoxComponent
{
public:
	float                                         TimeUntilOccluded;                                 // 0x05D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D4[0x1C];                                     // 0x05D4(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetEstimatedRenderedPixelCount() const;
	float GetNumberOfVisiblePixels() const;
	float GetVisiblePercentOfScreen() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BoxOcclusionQueryComponent">();
	}
	static class UBoxOcclusionQueryComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBoxOcclusionQueryComponent>();
	}
};
static_assert(alignof(UBoxOcclusionQueryComponent) == 0x000010, "Wrong alignment on UBoxOcclusionQueryComponent");
static_assert(sizeof(UBoxOcclusionQueryComponent) == 0x0005F0, "Wrong size on UBoxOcclusionQueryComponent");
static_assert(offsetof(UBoxOcclusionQueryComponent, TimeUntilOccluded) == 0x0005D0, "Member 'UBoxOcclusionQueryComponent::TimeUntilOccluded' has a wrong offset!");

// Class GameplayUtilities.CameraUtilities
// 0x0000 (0x0030 - 0x0030)
class UCameraUtilities final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraUtilities">();
	}
	static class UCameraUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCameraUtilities>();
	}
};
static_assert(alignof(UCameraUtilities) == 0x000008, "Wrong alignment on UCameraUtilities");
static_assert(sizeof(UCameraUtilities) == 0x000030, "Wrong size on UCameraUtilities");

// Class GameplayUtilities.CharacterPositionRecorderComponent
// 0x0020 (0x00C8 - 0x00A8)
class UCharacterPositionRecorderComponent final : public UActorComponent
{
public:
	float                                         _cacheTimespan;                                    // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_AC[0x1C];                                      // 0x00AC(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterPositionRecorderComponent">();
	}
	static class UCharacterPositionRecorderComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterPositionRecorderComponent>();
	}
};
static_assert(alignof(UCharacterPositionRecorderComponent) == 0x000008, "Wrong alignment on UCharacterPositionRecorderComponent");
static_assert(sizeof(UCharacterPositionRecorderComponent) == 0x0000C8, "Wrong size on UCharacterPositionRecorderComponent");
static_assert(offsetof(UCharacterPositionRecorderComponent, _cacheTimespan) == 0x0000A8, "Member 'UCharacterPositionRecorderComponent::_cacheTimespan' has a wrong offset!");

// Class GameplayUtilities.CharacterSightableComponent
// 0x00E8 (0x0190 - 0x00A8)
class UCharacterSightableComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x30];                                      // 0x00A8(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnHighestSightStatusChangedBP;                     // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMap<TWeakObjectPtr<class ACharacter>, struct FDelegateHandleWrapper> _sightDelegateHandles;                             // 0x00E8(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMap<TWeakObjectPtr<class ACharacter>, ESightStatus> _sightersStatus;                                   // 0x0138(0x0050)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_188[0x8];                                      // 0x0188(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnHighestSightStatusChangedBP__DelegateSignature(ESightStatus Status);

	ESightStatus GetHighestSightStatus() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterSightableComponent">();
	}
	static class UCharacterSightableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterSightableComponent>();
	}
};
static_assert(alignof(UCharacterSightableComponent) == 0x000008, "Wrong alignment on UCharacterSightableComponent");
static_assert(sizeof(UCharacterSightableComponent) == 0x000190, "Wrong size on UCharacterSightableComponent");
static_assert(offsetof(UCharacterSightableComponent, OnHighestSightStatusChangedBP) == 0x0000D8, "Member 'UCharacterSightableComponent::OnHighestSightStatusChangedBP' has a wrong offset!");
static_assert(offsetof(UCharacterSightableComponent, _sightDelegateHandles) == 0x0000E8, "Member 'UCharacterSightableComponent::_sightDelegateHandles' has a wrong offset!");
static_assert(offsetof(UCharacterSightableComponent, _sightersStatus) == 0x000138, "Member 'UCharacterSightableComponent::_sightersStatus' has a wrong offset!");

// Class GameplayUtilities.CharacterSightComponent
// 0x00D8 (0x0180 - 0x00A8)
class UCharacterSightComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x38];                                      // 0x00A8(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _minimumCharacterScreenPercentInZoneTrigger;       // 0x00E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _minimumCharacterScreenPercentInZoneUntrigger;     // 0x00E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _minimumCharacterScreenPercentNotInZoneTrigger;    // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _minimumCharacterScreenPercentNotInZoneUntrigger;  // 0x00EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _minimumCharacterVisiblePixelsPercentTrigger;      // 0x00F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _minimumCharacterVisiblePixelsPercentUntrigger;    // 0x00F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _maximumSightDistance;                             // 0x00F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _screenVisibilityZoneRadiusPercentX;               // 0x00FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _screenVisibilityZoneRadiusPercentY;               // 0x0100(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _sightingDelay;                                    // 0x0104(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _discerningDelay;                                  // 0x0108(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _undiscerningDelay;                                // 0x010C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class ACharacter>                 _sightableCharacterClass;                          // 0x0110(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FAuthorityDiscernedCharacter>   _discernedCharacters;                              // 0x0118(0x0010)(Net, ZeroConstructor, Transient, RepNotify, NativeAccessSpecifierPrivate)
	TArray<struct FDiscernibleCharacter>          _localDiscernibleCharacters;                       // 0x0128(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_138[0x10];                                     // 0x0138(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _debugMode;                                        // 0x0148(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _canSee;                                           // 0x0149(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_14A[0x6];                                      // 0x014A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FActivationDefinition                  _activationDefinition;                             // 0x0150(0x0028)(Edit, NativeAccessSpecifierPrivate)
	uint8                                         Pad_178[0x8];                                      // 0x0178(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_CanSee();
	void OnRep_DiscernibleCharacters();
	void Server_UpdateDiscernedCharacters(const TArray<class ACharacter*>& Characters);
	void SetMaximumSightDistance(float Value);
	void SetMinimumCharacterScreenPercentInZone(float Trigger, float Untrigger);
	void SetMinimumCharacterScreenPercentNotInZone(float Trigger, float Untrigger);
	void SetMinimumCharacterVisiblePixelsPercent(float Trigger, float Untrigger);
	void SetScreenVisibilityZoneRadiusPercent(float ValueX, float ValueY);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterSightComponent">();
	}
	static class UCharacterSightComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterSightComponent>();
	}
};
static_assert(alignof(UCharacterSightComponent) == 0x000008, "Wrong alignment on UCharacterSightComponent");
static_assert(sizeof(UCharacterSightComponent) == 0x000180, "Wrong size on UCharacterSightComponent");
static_assert(offsetof(UCharacterSightComponent, _minimumCharacterScreenPercentInZoneTrigger) == 0x0000E0, "Member 'UCharacterSightComponent::_minimumCharacterScreenPercentInZoneTrigger' has a wrong offset!");
static_assert(offsetof(UCharacterSightComponent, _minimumCharacterScreenPercentInZoneUntrigger) == 0x0000E4, "Member 'UCharacterSightComponent::_minimumCharacterScreenPercentInZoneUntrigger' has a wrong offset!");
static_assert(offsetof(UCharacterSightComponent, _minimumCharacterScreenPercentNotInZoneTrigger) == 0x0000E8, "Member 'UCharacterSightComponent::_minimumCharacterScreenPercentNotInZoneTrigger' has a wrong offset!");
static_assert(offsetof(UCharacterSightComponent, _minimumCharacterScreenPercentNotInZoneUntrigger) == 0x0000EC, "Member 'UCharacterSightComponent::_minimumCharacterScreenPercentNotInZoneUntrigger' has a wrong offset!");
static_assert(offsetof(UCharacterSightComponent, _minimumCharacterVisiblePixelsPercentTrigger) == 0x0000F0, "Member 'UCharacterSightComponent::_minimumCharacterVisiblePixelsPercentTrigger' has a wrong offset!");
static_assert(offsetof(UCharacterSightComponent, _minimumCharacterVisiblePixelsPercentUntrigger) == 0x0000F4, "Member 'UCharacterSightComponent::_minimumCharacterVisiblePixelsPercentUntrigger' has a wrong offset!");
static_assert(offsetof(UCharacterSightComponent, _maximumSightDistance) == 0x0000F8, "Member 'UCharacterSightComponent::_maximumSightDistance' has a wrong offset!");
static_assert(offsetof(UCharacterSightComponent, _screenVisibilityZoneRadiusPercentX) == 0x0000FC, "Member 'UCharacterSightComponent::_screenVisibilityZoneRadiusPercentX' has a wrong offset!");
static_assert(offsetof(UCharacterSightComponent, _screenVisibilityZoneRadiusPercentY) == 0x000100, "Member 'UCharacterSightComponent::_screenVisibilityZoneRadiusPercentY' has a wrong offset!");
static_assert(offsetof(UCharacterSightComponent, _sightingDelay) == 0x000104, "Member 'UCharacterSightComponent::_sightingDelay' has a wrong offset!");
static_assert(offsetof(UCharacterSightComponent, _discerningDelay) == 0x000108, "Member 'UCharacterSightComponent::_discerningDelay' has a wrong offset!");
static_assert(offsetof(UCharacterSightComponent, _undiscerningDelay) == 0x00010C, "Member 'UCharacterSightComponent::_undiscerningDelay' has a wrong offset!");
static_assert(offsetof(UCharacterSightComponent, _sightableCharacterClass) == 0x000110, "Member 'UCharacterSightComponent::_sightableCharacterClass' has a wrong offset!");
static_assert(offsetof(UCharacterSightComponent, _discernedCharacters) == 0x000118, "Member 'UCharacterSightComponent::_discernedCharacters' has a wrong offset!");
static_assert(offsetof(UCharacterSightComponent, _localDiscernibleCharacters) == 0x000128, "Member 'UCharacterSightComponent::_localDiscernibleCharacters' has a wrong offset!");
static_assert(offsetof(UCharacterSightComponent, _debugMode) == 0x000148, "Member 'UCharacterSightComponent::_debugMode' has a wrong offset!");
static_assert(offsetof(UCharacterSightComponent, _canSee) == 0x000149, "Member 'UCharacterSightComponent::_canSee' has a wrong offset!");
static_assert(offsetof(UCharacterSightComponent, _activationDefinition) == 0x000150, "Member 'UCharacterSightComponent::_activationDefinition' has a wrong offset!");

// Class GameplayUtilities.ChargeableUtilities
// 0x0000 (0x0030 - 0x0030)
class UChargeableUtilities final : public UBlueprintFunctionLibrary
{
public:
	static float ConvertSecondsToAddToRateMultiplier(float SecondsToAdd, float baseMaxSeconds, float baseRate);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChargeableUtilities">();
	}
	static class UChargeableUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChargeableUtilities>();
	}
};
static_assert(alignof(UChargeableUtilities) == 0x000008, "Wrong alignment on UChargeableUtilities");
static_assert(sizeof(UChargeableUtilities) == 0x000030, "Wrong size on UChargeableUtilities");

// Class GameplayUtilities.CollectedObjectCollection
// 0x00A0 (0x0148 - 0x00A8)
class UCollectedObjectCollection final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0xA0];                                      // 0x00A8(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CollectedObjectCollection">();
	}
	static class UCollectedObjectCollection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCollectedObjectCollection>();
	}
};
static_assert(alignof(UCollectedObjectCollection) == 0x000008, "Wrong alignment on UCollectedObjectCollection");
static_assert(sizeof(UCollectedObjectCollection) == 0x000148, "Wrong size on UCollectedObjectCollection");

// Class GameplayUtilities.ContainerUtilities
// 0x0000 (0x0030 - 0x0030)
class UContainerUtilities final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ContainerUtilities">();
	}
	static class UContainerUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UContainerUtilities>();
	}
};
static_assert(alignof(UContainerUtilities) == 0x000008, "Wrong alignment on UContainerUtilities");
static_assert(sizeof(UContainerUtilities) == 0x000030, "Wrong size on UContainerUtilities");

// Class GameplayUtilities.FallOutOfWorldPositionFinder
// 0x0000 (0x0030 - 0x0030)
class IFallOutOfWorldPositionFinder final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FallOutOfWorldPositionFinder">();
	}
	static class IFallOutOfWorldPositionFinder* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFallOutOfWorldPositionFinder>();
	}
};
static_assert(alignof(IFallOutOfWorldPositionFinder) == 0x000008, "Wrong alignment on IFallOutOfWorldPositionFinder");
static_assert(sizeof(IFallOutOfWorldPositionFinder) == 0x000030, "Wrong size on IFallOutOfWorldPositionFinder");

// Class GameplayUtilities.PoolableActor
// 0x0000 (0x0030 - 0x0030)
class IPoolableActor final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PoolableActor">();
	}
	static class IPoolableActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPoolableActor>();
	}
};
static_assert(alignof(IPoolableActor) == 0x000008, "Wrong alignment on IPoolableActor");
static_assert(sizeof(IPoolableActor) == 0x000030, "Wrong size on IPoolableActor");

// Class GameplayUtilities.PotentialAttack
// 0x0000 (0x0030 - 0x0030)
class IPotentialAttack final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PotentialAttack">();
	}
	static class IPotentialAttack* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPotentialAttack>();
	}
};
static_assert(alignof(IPotentialAttack) == 0x000008, "Wrong alignment on IPotentialAttack");
static_assert(sizeof(IPotentialAttack) == 0x000030, "Wrong size on IPotentialAttack");

// Class GameplayUtilities.IsLookingTowardsQueryComponent
// 0x0010 (0x00B8 - 0x00A8)
class UIsLookingTowardsQueryComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x10];                                      // 0x00A8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IsLookingTowardsQueryComponent">();
	}
	static class UIsLookingTowardsQueryComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIsLookingTowardsQueryComponent>();
	}
};
static_assert(alignof(UIsLookingTowardsQueryComponent) == 0x000008, "Wrong alignment on UIsLookingTowardsQueryComponent");
static_assert(sizeof(UIsLookingTowardsQueryComponent) == 0x0000B8, "Wrong size on UIsLookingTowardsQueryComponent");

// Class GameplayUtilities.SpecialAttackInstigator
// 0x0000 (0x0030 - 0x0030)
class ISpecialAttackInstigator final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpecialAttackInstigator">();
	}
	static class ISpecialAttackInstigator* GetDefaultObj()
	{
		return GetDefaultObjImpl<ISpecialAttackInstigator>();
	}
};
static_assert(alignof(ISpecialAttackInstigator) == 0x000008, "Wrong alignment on ISpecialAttackInstigator");
static_assert(sizeof(ISpecialAttackInstigator) == 0x000030, "Wrong size on ISpecialAttackInstigator");

// Class GameplayUtilities.LocalActorPoolComponent
// 0x0010 (0x00F8 - 0x00E8)
class ULocalActorPoolComponent final : public UActorPoolComponent
{
public:
	TArray<class AActor*>                         _pool;                                             // 0x00E8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LocalActorPoolComponent">();
	}
	static class ULocalActorPoolComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULocalActorPoolComponent>();
	}
};
static_assert(alignof(ULocalActorPoolComponent) == 0x000008, "Wrong alignment on ULocalActorPoolComponent");
static_assert(sizeof(ULocalActorPoolComponent) == 0x0000F8, "Wrong size on ULocalActorPoolComponent");
static_assert(offsetof(ULocalActorPoolComponent, _pool) == 0x0000E8, "Member 'ULocalActorPoolComponent::_pool' has a wrong offset!");

// Class GameplayUtilities.MockPoolableActor
// 0x0008 (0x02A8 - 0x02A0)
class AMockPoolableActor final : public AActor
{
public:
	class UPoolableActorComponent*                _poolable;                                         // 0x02A0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MockPoolableActor">();
	}
	static class AMockPoolableActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMockPoolableActor>();
	}
};
static_assert(alignof(AMockPoolableActor) == 0x000008, "Wrong alignment on AMockPoolableActor");
static_assert(sizeof(AMockPoolableActor) == 0x0002A8, "Wrong size on AMockPoolableActor");
static_assert(offsetof(AMockPoolableActor, _poolable) == 0x0002A0, "Member 'AMockPoolableActor::_poolable' has a wrong offset!");

// Class GameplayUtilities.MovableCamera
// 0x0040 (0x0368 - 0x0328)
class AMovableCamera final : public APawn
{
public:
	float                                         MovementSpeed;                                     // 0x0328(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RequiresShiftModifierForInput;                     // 0x032C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32D[0x33];                                     // 0x032D(0x0033)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerController*                      _playerController;                                 // 0x0360(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovableCamera">();
	}
	static class AMovableCamera* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMovableCamera>();
	}
};
static_assert(alignof(AMovableCamera) == 0x000008, "Wrong alignment on AMovableCamera");
static_assert(sizeof(AMovableCamera) == 0x000368, "Wrong size on AMovableCamera");
static_assert(offsetof(AMovableCamera, MovementSpeed) == 0x000328, "Member 'AMovableCamera::MovementSpeed' has a wrong offset!");
static_assert(offsetof(AMovableCamera, RequiresShiftModifierForInput) == 0x00032C, "Member 'AMovableCamera::RequiresShiftModifierForInput' has a wrong offset!");
static_assert(offsetof(AMovableCamera, _playerController) == 0x000360, "Member 'AMovableCamera::_playerController' has a wrong offset!");

// Class GameplayUtilities.MoveActorToComponent
// 0x0068 (0x0110 - 0x00A8)
class UMoveActorToComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x68];                                      // 0x00A8(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoveActorToComponent">();
	}
	static class UMoveActorToComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoveActorToComponent>();
	}
};
static_assert(alignof(UMoveActorToComponent) == 0x000008, "Wrong alignment on UMoveActorToComponent");
static_assert(sizeof(UMoveActorToComponent) == 0x000110, "Wrong size on UMoveActorToComponent");

// Class GameplayUtilities.MovementUtilities
// 0x0000 (0x0030 - 0x0030)
class UMovementUtilities final : public UBlueprintFunctionLibrary
{
public:
	static void Local_MoveActorTo(class AActor* Actor, const struct FVector& Location, const struct FRotator& Rotation, const float Duration);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovementUtilities">();
	}
	static class UMovementUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMovementUtilities>();
	}
};
static_assert(alignof(UMovementUtilities) == 0x000008, "Wrong alignment on UMovementUtilities");
static_assert(sizeof(UMovementUtilities) == 0x000030, "Wrong size on UMovementUtilities");

// Class GameplayUtilities.PawnUtilities
// 0x0000 (0x0030 - 0x0030)
class UPawnUtilities final : public UBlueprintFunctionLibrary
{
public:
	static class APawn* GetLocallyObservedPawn(const class UObject* WorldContext);
	static class APawn* GetOwningPawn(const class AActor* Origin);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PawnUtilities">();
	}
	static class UPawnUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPawnUtilities>();
	}
};
static_assert(alignof(UPawnUtilities) == 0x000008, "Wrong alignment on UPawnUtilities");
static_assert(sizeof(UPawnUtilities) == 0x000030, "Wrong size on UPawnUtilities");

// Class GameplayUtilities.PlayerStateExt
// 0x0000 (0x0030 - 0x0030)
class UPlayerStateExt final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerStateExt">();
	}
	static class UPlayerStateExt* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerStateExt>();
	}
};
static_assert(alignof(UPlayerStateExt) == 0x000008, "Wrong alignment on UPlayerStateExt");
static_assert(sizeof(UPlayerStateExt) == 0x000030, "Wrong size on UPlayerStateExt");

// Class GameplayUtilities.PoolableActorComponent
// 0x0008 (0x00C8 - 0x00C0)
class UPoolableActorComponent final : public UBasePoolableActorComponent
{
public:
	uint8                                         Pad_C0[0x8];                                       // 0x00C0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PoolableActorComponent">();
	}
	static class UPoolableActorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPoolableActorComponent>();
	}
};
static_assert(alignof(UPoolableActorComponent) == 0x000008, "Wrong alignment on UPoolableActorComponent");
static_assert(sizeof(UPoolableActorComponent) == 0x0000C8, "Wrong size on UPoolableActorComponent");

// Class GameplayUtilities.SceneComponentExt
// 0x0000 (0x0030 - 0x0030)
class USceneComponentExt final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SceneComponentExt">();
	}
	static class USceneComponentExt* GetDefaultObj()
	{
		return GetDefaultObjImpl<USceneComponentExt>();
	}
};
static_assert(alignof(USceneComponentExt) == 0x000008, "Wrong alignment on USceneComponentExt");
static_assert(sizeof(USceneComponentExt) == 0x000030, "Wrong size on USceneComponentExt");

// Class GameplayUtilities.SidePushStrategyComponent
// 0x0010 (0x00B8 - 0x00A8)
class USidePushStrategyComponent final : public UBasePushStrategyComponent
{
public:
	float                                         _maxImpulseStrength;                               // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _minImpulseStrength;                               // 0x00AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _detectorCapsuleInflation;                         // 0x00B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B4[0x4];                                       // 0x00B4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SidePushStrategyComponent">();
	}
	static class USidePushStrategyComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USidePushStrategyComponent>();
	}
};
static_assert(alignof(USidePushStrategyComponent) == 0x000008, "Wrong alignment on USidePushStrategyComponent");
static_assert(sizeof(USidePushStrategyComponent) == 0x0000B8, "Wrong size on USidePushStrategyComponent");
static_assert(offsetof(USidePushStrategyComponent, _maxImpulseStrength) == 0x0000A8, "Member 'USidePushStrategyComponent::_maxImpulseStrength' has a wrong offset!");
static_assert(offsetof(USidePushStrategyComponent, _minImpulseStrength) == 0x0000AC, "Member 'USidePushStrategyComponent::_minImpulseStrength' has a wrong offset!");
static_assert(offsetof(USidePushStrategyComponent, _detectorCapsuleInflation) == 0x0000B0, "Member 'USidePushStrategyComponent::_detectorCapsuleInflation' has a wrong offset!");

// Class GameplayUtilities.StateController
// 0x0098 (0x0140 - 0x00A8)
class alignas(0x10) UStateController final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x30];                                      // 0x00A8(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnStateChangedBlueprintEvent;                      // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UBaseReplicatedState>> _stateClasses;                                     // 0x00E8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	TSubclassOf<class UBaseReplicatedState>       _defaultStateClass;                                // 0x00F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UBaseReplicatedState*>           _states;                                           // 0x0100(0x0010)(Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPrivate)
	uint8                                         Pad_110[0x10];                                     // 0x0110(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UBaseReplicatedState*                   _local_currentState;                               // 0x0120(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBaseReplicatedState*                   _authority_RepCurrentState;                        // 0x0128(0x0008)(Net, ZeroConstructor, Transient, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_130[0x10];                                     // 0x0130(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_AuthorityRepCurrentState();
	void OnRep_States();
	void OnStateChangedBlueprintEvent__DelegateSignature(const struct FGameplayTag& OldState, const struct FGameplayTag& NewState);

	struct FGameplayTag GetCurrentStateID() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StateController">();
	}
	static class UStateController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStateController>();
	}
};
static_assert(alignof(UStateController) == 0x000010, "Wrong alignment on UStateController");
static_assert(sizeof(UStateController) == 0x000140, "Wrong size on UStateController");
static_assert(offsetof(UStateController, OnStateChangedBlueprintEvent) == 0x0000D8, "Member 'UStateController::OnStateChangedBlueprintEvent' has a wrong offset!");
static_assert(offsetof(UStateController, _stateClasses) == 0x0000E8, "Member 'UStateController::_stateClasses' has a wrong offset!");
static_assert(offsetof(UStateController, _defaultStateClass) == 0x0000F8, "Member 'UStateController::_defaultStateClass' has a wrong offset!");
static_assert(offsetof(UStateController, _states) == 0x000100, "Member 'UStateController::_states' has a wrong offset!");
static_assert(offsetof(UStateController, _local_currentState) == 0x000120, "Member 'UStateController::_local_currentState' has a wrong offset!");
static_assert(offsetof(UStateController, _authority_RepCurrentState) == 0x000128, "Member 'UStateController::_authority_RepCurrentState' has a wrong offset!");

// Class GameplayUtilities.VisualLoggerExt
// 0x0000 (0x0030 - 0x0030)
class UVisualLoggerExt final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VisualLoggerExt">();
	}
	static class UVisualLoggerExt* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVisualLoggerExt>();
	}
};
static_assert(alignof(UVisualLoggerExt) == 0x000008, "Wrong alignment on UVisualLoggerExt");
static_assert(sizeof(UVisualLoggerExt) == 0x000030, "Wrong size on UVisualLoggerExt");

}

