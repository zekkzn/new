#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: TheK28

#include "Basic.hpp"

#include "Engine_structs.hpp"
#include "TheK28_structs.hpp"
#include "DeadByDaylight_structs.hpp"
#include "CoreUObject_structs.hpp"


namespace SDK::Params
{

// Function TheK28.Addon_K28Power_18.Multicast_TriggerLockerAnimationOnAllLockers
// 0x0010 (0x0010 - 0x0000)
struct Addon_K28Power_18_Multicast_TriggerLockerAnimationOnAllLockers final
{
public:
	TArray<class ALocker*>                        Lockers;                                           // 0x0000(0x0010)(ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(Addon_K28Power_18_Multicast_TriggerLockerAnimationOnAllLockers) == 0x000008, "Wrong alignment on Addon_K28Power_18_Multicast_TriggerLockerAnimationOnAllLockers");
static_assert(sizeof(Addon_K28Power_18_Multicast_TriggerLockerAnimationOnAllLockers) == 0x000010, "Wrong size on Addon_K28Power_18_Multicast_TriggerLockerAnimationOnAllLockers");
static_assert(offsetof(Addon_K28Power_18_Multicast_TriggerLockerAnimationOnAllLockers, Lockers) == 0x000000, "Member 'Addon_K28Power_18_Multicast_TriggerLockerAnimationOnAllLockers::Lockers' has a wrong offset!");

// Function TheK28.K28AnimInstance.BP_OnCustomizationAnimationMappingIDChanged
// 0x0004 (0x0004 - 0x0000)
struct K28AnimInstance_BP_OnCustomizationAnimationMappingIDChanged final
{
public:
	int32                                         AnimationMappingIndex;                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28AnimInstance_BP_OnCustomizationAnimationMappingIDChanged) == 0x000004, "Wrong alignment on K28AnimInstance_BP_OnCustomizationAnimationMappingIDChanged");
static_assert(sizeof(K28AnimInstance_BP_OnCustomizationAnimationMappingIDChanged) == 0x000004, "Wrong size on K28AnimInstance_BP_OnCustomizationAnimationMappingIDChanged");
static_assert(offsetof(K28AnimInstance_BP_OnCustomizationAnimationMappingIDChanged, AnimationMappingIndex) == 0x000000, "Member 'K28AnimInstance_BP_OnCustomizationAnimationMappingIDChanged::AnimationMappingIndex' has a wrong offset!");

// Function TheK28.K28AnimInstance.GetAnimationMappingIndex
// 0x0004 (0x0004 - 0x0000)
struct K28AnimInstance_GetAnimationMappingIndex final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28AnimInstance_GetAnimationMappingIndex) == 0x000004, "Wrong alignment on K28AnimInstance_GetAnimationMappingIndex");
static_assert(sizeof(K28AnimInstance_GetAnimationMappingIndex) == 0x000004, "Wrong size on K28AnimInstance_GetAnimationMappingIndex");
static_assert(offsetof(K28AnimInstance_GetAnimationMappingIndex, ReturnValue) == 0x000000, "Member 'K28AnimInstance_GetAnimationMappingIndex::ReturnValue' has a wrong offset!");

// Function TheK28.K28AnimInstance.GetCustomAnimationTags
// 0x0010 (0x0010 - 0x0000)
struct K28AnimInstance_GetCustomAnimationTags final
{
public:
	TArray<class FName>                           ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28AnimInstance_GetCustomAnimationTags) == 0x000008, "Wrong alignment on K28AnimInstance_GetCustomAnimationTags");
static_assert(sizeof(K28AnimInstance_GetCustomAnimationTags) == 0x000010, "Wrong size on K28AnimInstance_GetCustomAnimationTags");
static_assert(offsetof(K28AnimInstance_GetCustomAnimationTags, ReturnValue) == 0x000000, "Member 'K28AnimInstance_GetCustomAnimationTags::ReturnValue' has a wrong offset!");

// Function TheK28.K28CheatComponent.DBD_K28DebugCosmetics
// 0x0001 (0x0001 - 0x0000)
struct K28CheatComponent_DBD_K28DebugCosmetics final
{
public:
	bool                                          NoCooldown;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28CheatComponent_DBD_K28DebugCosmetics) == 0x000001, "Wrong alignment on K28CheatComponent_DBD_K28DebugCosmetics");
static_assert(sizeof(K28CheatComponent_DBD_K28DebugCosmetics) == 0x000001, "Wrong size on K28CheatComponent_DBD_K28DebugCosmetics");
static_assert(offsetof(K28CheatComponent_DBD_K28DebugCosmetics, NoCooldown) == 0x000000, "Member 'K28CheatComponent_DBD_K28DebugCosmetics::NoCooldown' has a wrong offset!");

// Function TheK28.K28CheatComponent.DBD_K28DisplayLockerClusters
// 0x0004 (0x0004 - 0x0000)
struct K28CheatComponent_DBD_K28DisplayLockerClusters final
{
public:
	float                                         SecondsToDisplayDebugElements;                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28CheatComponent_DBD_K28DisplayLockerClusters) == 0x000004, "Wrong alignment on K28CheatComponent_DBD_K28DisplayLockerClusters");
static_assert(sizeof(K28CheatComponent_DBD_K28DisplayLockerClusters) == 0x000004, "Wrong size on K28CheatComponent_DBD_K28DisplayLockerClusters");
static_assert(offsetof(K28CheatComponent_DBD_K28DisplayLockerClusters, SecondsToDisplayDebugElements) == 0x000000, "Member 'K28CheatComponent_DBD_K28DisplayLockerClusters::SecondsToDisplayDebugElements' has a wrong offset!");

// Function TheK28.K28CheatComponent.DBD_K28SetPowerNoCooldown
// 0x0001 (0x0001 - 0x0000)
struct K28CheatComponent_DBD_K28SetPowerNoCooldown final
{
public:
	bool                                          NoCooldown;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28CheatComponent_DBD_K28SetPowerNoCooldown) == 0x000001, "Wrong alignment on K28CheatComponent_DBD_K28SetPowerNoCooldown");
static_assert(sizeof(K28CheatComponent_DBD_K28SetPowerNoCooldown) == 0x000001, "Wrong size on K28CheatComponent_DBD_K28SetPowerNoCooldown");
static_assert(offsetof(K28CheatComponent_DBD_K28SetPowerNoCooldown, NoCooldown) == 0x000000, "Member 'K28CheatComponent_DBD_K28SetPowerNoCooldown::NoCooldown' has a wrong offset!");

// Function TheK28.K28DayNightComponent.Authority_OnSurvivorDamageStateChanged
// 0x0002 (0x0002 - 0x0000)
struct K28DayNightComponent_Authority_OnSurvivorDamageStateChanged final
{
public:
	ECamperDamageState                            PreviousDamageState;                               // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECamperDamageState                            NewDamageState;                                    // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28DayNightComponent_Authority_OnSurvivorDamageStateChanged) == 0x000001, "Wrong alignment on K28DayNightComponent_Authority_OnSurvivorDamageStateChanged");
static_assert(sizeof(K28DayNightComponent_Authority_OnSurvivorDamageStateChanged) == 0x000002, "Wrong size on K28DayNightComponent_Authority_OnSurvivorDamageStateChanged");
static_assert(offsetof(K28DayNightComponent_Authority_OnSurvivorDamageStateChanged, PreviousDamageState) == 0x000000, "Member 'K28DayNightComponent_Authority_OnSurvivorDamageStateChanged::PreviousDamageState' has a wrong offset!");
static_assert(offsetof(K28DayNightComponent_Authority_OnSurvivorDamageStateChanged, NewDamageState) == 0x000001, "Member 'K28DayNightComponent_Authority_OnSurvivorDamageStateChanged::NewDamageState' has a wrong offset!");

// Function TheK28.K28DayNightComponent.Cosmetic_OnIsInLastTwentySecondsOfNightCycle
// 0x0008 (0x0008 - 0x0000)
struct K28DayNightComponent_Cosmetic_OnIsInLastTwentySecondsOfNightCycle final
{
public:
	class UAkComponent*                           AkComponent;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28DayNightComponent_Cosmetic_OnIsInLastTwentySecondsOfNightCycle) == 0x000008, "Wrong alignment on K28DayNightComponent_Cosmetic_OnIsInLastTwentySecondsOfNightCycle");
static_assert(sizeof(K28DayNightComponent_Cosmetic_OnIsInLastTwentySecondsOfNightCycle) == 0x000008, "Wrong size on K28DayNightComponent_Cosmetic_OnIsInLastTwentySecondsOfNightCycle");
static_assert(offsetof(K28DayNightComponent_Cosmetic_OnIsInLastTwentySecondsOfNightCycle, AkComponent) == 0x000000, "Member 'K28DayNightComponent_Cosmetic_OnIsInLastTwentySecondsOfNightCycle::AkComponent' has a wrong offset!");

// Function TheK28.K28DayNightComponent.Cosmetic_OnNightCycleChanged
// 0x0010 (0x0010 - 0x0000)
struct K28DayNightComponent_Cosmetic_OnNightCycleChanged final
{
public:
	class UAkComponent*                           AkComponent;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EK28NightCycleState                           NewNightCycleState;                                // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(K28DayNightComponent_Cosmetic_OnNightCycleChanged) == 0x000008, "Wrong alignment on K28DayNightComponent_Cosmetic_OnNightCycleChanged");
static_assert(sizeof(K28DayNightComponent_Cosmetic_OnNightCycleChanged) == 0x000010, "Wrong size on K28DayNightComponent_Cosmetic_OnNightCycleChanged");
static_assert(offsetof(K28DayNightComponent_Cosmetic_OnNightCycleChanged, AkComponent) == 0x000000, "Member 'K28DayNightComponent_Cosmetic_OnNightCycleChanged::AkComponent' has a wrong offset!");
static_assert(offsetof(K28DayNightComponent_Cosmetic_OnNightCycleChanged, NewNightCycleState) == 0x000008, "Member 'K28DayNightComponent_Cosmetic_OnNightCycleChanged::NewNightCycleState' has a wrong offset!");

// Function TheK28.K28FXInterface.Cosmetic_OnIsKillingSurvivorWithMoriStateChanged
// 0x0001 (0x0001 - 0x0000)
struct K28FXInterface_Cosmetic_OnIsKillingSurvivorWithMoriStateChanged final
{
public:
	bool                                          IsKillingSurvivorWithMori;                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28FXInterface_Cosmetic_OnIsKillingSurvivorWithMoriStateChanged) == 0x000001, "Wrong alignment on K28FXInterface_Cosmetic_OnIsKillingSurvivorWithMoriStateChanged");
static_assert(sizeof(K28FXInterface_Cosmetic_OnIsKillingSurvivorWithMoriStateChanged) == 0x000001, "Wrong size on K28FXInterface_Cosmetic_OnIsKillingSurvivorWithMoriStateChanged");
static_assert(offsetof(K28FXInterface_Cosmetic_OnIsKillingSurvivorWithMoriStateChanged, IsKillingSurvivorWithMori) == 0x000000, "Member 'K28FXInterface_Cosmetic_OnIsKillingSurvivorWithMoriStateChanged::IsKillingSurvivorWithMori' has a wrong offset!");

// Function TheK28.K28FXInterface.Cosmetic_OnShowKiller
// 0x0001 (0x0001 - 0x0000)
struct K28FXInterface_Cosmetic_OnShowKiller final
{
public:
	bool                                          IsInstantShow;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28FXInterface_Cosmetic_OnShowKiller) == 0x000001, "Wrong alignment on K28FXInterface_Cosmetic_OnShowKiller");
static_assert(sizeof(K28FXInterface_Cosmetic_OnShowKiller) == 0x000001, "Wrong size on K28FXInterface_Cosmetic_OnShowKiller");
static_assert(offsetof(K28FXInterface_Cosmetic_OnShowKiller, IsInstantShow) == 0x000000, "Member 'K28FXInterface_Cosmetic_OnShowKiller::IsInstantShow' has a wrong offset!");

// Function TheK28.K28FXInterface.Cosmetic_OnTeleportationToLockerStart
// 0x0008 (0x0008 - 0x0000)
struct K28FXInterface_Cosmetic_OnTeleportationToLockerStart final
{
public:
	float                                         TeleportationDuration;                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsKillerAlreadyHidingInLocker;                     // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(K28FXInterface_Cosmetic_OnTeleportationToLockerStart) == 0x000004, "Wrong alignment on K28FXInterface_Cosmetic_OnTeleportationToLockerStart");
static_assert(sizeof(K28FXInterface_Cosmetic_OnTeleportationToLockerStart) == 0x000008, "Wrong size on K28FXInterface_Cosmetic_OnTeleportationToLockerStart");
static_assert(offsetof(K28FXInterface_Cosmetic_OnTeleportationToLockerStart, TeleportationDuration) == 0x000000, "Member 'K28FXInterface_Cosmetic_OnTeleportationToLockerStart::TeleportationDuration' has a wrong offset!");
static_assert(offsetof(K28FXInterface_Cosmetic_OnTeleportationToLockerStart, IsKillerAlreadyHidingInLocker) == 0x000004, "Member 'K28FXInterface_Cosmetic_OnTeleportationToLockerStart::IsKillerAlreadyHidingInLocker' has a wrong offset!");

// Function TheK28.K28FXInterface.Cosmetic_SetBlackMaterialOnKiller
// 0x0001 (0x0001 - 0x0000)
struct K28FXInterface_Cosmetic_SetBlackMaterialOnKiller final
{
public:
	bool                                          blackMaterialApplied;                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28FXInterface_Cosmetic_SetBlackMaterialOnKiller) == 0x000001, "Wrong alignment on K28FXInterface_Cosmetic_SetBlackMaterialOnKiller");
static_assert(sizeof(K28FXInterface_Cosmetic_SetBlackMaterialOnKiller) == 0x000001, "Wrong size on K28FXInterface_Cosmetic_SetBlackMaterialOnKiller");
static_assert(offsetof(K28FXInterface_Cosmetic_SetBlackMaterialOnKiller, blackMaterialApplied) == 0x000000, "Member 'K28FXInterface_Cosmetic_SetBlackMaterialOnKiller::blackMaterialApplied' has a wrong offset!");

// Function TheK28.K28FXInterface.Cosmetic_SetDebugCosmetics
// 0x0001 (0x0001 - 0x0000)
struct K28FXInterface_Cosmetic_SetDebugCosmetics final
{
public:
	bool                                          IsDebugCosmeticsActive;                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28FXInterface_Cosmetic_SetDebugCosmetics) == 0x000001, "Wrong alignment on K28FXInterface_Cosmetic_SetDebugCosmetics");
static_assert(sizeof(K28FXInterface_Cosmetic_SetDebugCosmetics) == 0x000001, "Wrong size on K28FXInterface_Cosmetic_SetDebugCosmetics");
static_assert(offsetof(K28FXInterface_Cosmetic_SetDebugCosmetics, IsDebugCosmeticsActive) == 0x000000, "Member 'K28FXInterface_Cosmetic_SetDebugCosmetics::IsDebugCosmeticsActive' has a wrong offset!");

// Function TheK28.K28PlayerComponent.OnSurvivorInRangeChanged
// 0x0010 (0x0010 - 0x0000)
struct K28PlayerComponent_OnSurvivorInRangeChanged final
{
public:
	bool                                          InRange;                                           // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ACamperPlayer*                          Player;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28PlayerComponent_OnSurvivorInRangeChanged) == 0x000008, "Wrong alignment on K28PlayerComponent_OnSurvivorInRangeChanged");
static_assert(sizeof(K28PlayerComponent_OnSurvivorInRangeChanged) == 0x000010, "Wrong size on K28PlayerComponent_OnSurvivorInRangeChanged");
static_assert(offsetof(K28PlayerComponent_OnSurvivorInRangeChanged, InRange) == 0x000000, "Member 'K28PlayerComponent_OnSurvivorInRangeChanged::InRange' has a wrong offset!");
static_assert(offsetof(K28PlayerComponent_OnSurvivorInRangeChanged, Player) == 0x000008, "Member 'K28PlayerComponent_OnSurvivorInRangeChanged::Player' has a wrong offset!");

// Function TheK28.K28KillerComponent.Cosmetic_OnNightCycleStateChanged
// 0x0010 (0x0010 - 0x0000)
struct K28KillerComponent_Cosmetic_OnNightCycleStateChanged final
{
public:
	class ASlasherPlayer*                         Killer;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EK28NightCycleState                           DayNightCycleState;                                // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Instant;                                           // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(K28KillerComponent_Cosmetic_OnNightCycleStateChanged) == 0x000008, "Wrong alignment on K28KillerComponent_Cosmetic_OnNightCycleStateChanged");
static_assert(sizeof(K28KillerComponent_Cosmetic_OnNightCycleStateChanged) == 0x000010, "Wrong size on K28KillerComponent_Cosmetic_OnNightCycleStateChanged");
static_assert(offsetof(K28KillerComponent_Cosmetic_OnNightCycleStateChanged, Killer) == 0x000000, "Member 'K28KillerComponent_Cosmetic_OnNightCycleStateChanged::Killer' has a wrong offset!");
static_assert(offsetof(K28KillerComponent_Cosmetic_OnNightCycleStateChanged, DayNightCycleState) == 0x000008, "Member 'K28KillerComponent_Cosmetic_OnNightCycleStateChanged::DayNightCycleState' has a wrong offset!");
static_assert(offsetof(K28KillerComponent_Cosmetic_OnNightCycleStateChanged, Instant) == 0x000009, "Member 'K28KillerComponent_Cosmetic_OnNightCycleStateChanged::Instant' has a wrong offset!");

// Function TheK28.K28KillerComponent.Cosmetic_OnNighttimeNearingActivation
// 0x0008 (0x0008 - 0x0000)
struct K28KillerComponent_Cosmetic_OnNighttimeNearingActivation final
{
public:
	class ASlasherPlayer*                         Killer;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28KillerComponent_Cosmetic_OnNighttimeNearingActivation) == 0x000008, "Wrong alignment on K28KillerComponent_Cosmetic_OnNighttimeNearingActivation");
static_assert(sizeof(K28KillerComponent_Cosmetic_OnNighttimeNearingActivation) == 0x000008, "Wrong size on K28KillerComponent_Cosmetic_OnNighttimeNearingActivation");
static_assert(offsetof(K28KillerComponent_Cosmetic_OnNighttimeNearingActivation, Killer) == 0x000000, "Member 'K28KillerComponent_Cosmetic_OnNighttimeNearingActivation::Killer' has a wrong offset!");

// Function TheK28.K28KillerEnterLockerInteraction.IsKillerAllowedToEnterLocker
// 0x0010 (0x0010 - 0x0000)
struct K28KillerEnterLockerInteraction_IsKillerAllowedToEnterLocker final
{
public:
	const class ADBDPlayer*                       Player;                                            // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(K28KillerEnterLockerInteraction_IsKillerAllowedToEnterLocker) == 0x000008, "Wrong alignment on K28KillerEnterLockerInteraction_IsKillerAllowedToEnterLocker");
static_assert(sizeof(K28KillerEnterLockerInteraction_IsKillerAllowedToEnterLocker) == 0x000010, "Wrong size on K28KillerEnterLockerInteraction_IsKillerAllowedToEnterLocker");
static_assert(offsetof(K28KillerEnterLockerInteraction_IsKillerAllowedToEnterLocker, Player) == 0x000000, "Member 'K28KillerEnterLockerInteraction_IsKillerAllowedToEnterLocker::Player' has a wrong offset!");
static_assert(offsetof(K28KillerEnterLockerInteraction_IsKillerAllowedToEnterLocker, ReturnValue) == 0x000008, "Member 'K28KillerEnterLockerInteraction_IsKillerAllowedToEnterLocker::ReturnValue' has a wrong offset!");

// Function TheK28.K28KillerInstinctEffect.Authority_OnKillerInstinctApplicableChanged
// 0x0001 (0x0001 - 0x0000)
struct K28KillerInstinctEffect_Authority_OnKillerInstinctApplicableChanged final
{
public:
	bool                                          Active;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28KillerInstinctEffect_Authority_OnKillerInstinctApplicableChanged) == 0x000001, "Wrong alignment on K28KillerInstinctEffect_Authority_OnKillerInstinctApplicableChanged");
static_assert(sizeof(K28KillerInstinctEffect_Authority_OnKillerInstinctApplicableChanged) == 0x000001, "Wrong size on K28KillerInstinctEffect_Authority_OnKillerInstinctApplicableChanged");
static_assert(offsetof(K28KillerInstinctEffect_Authority_OnKillerInstinctApplicableChanged, Active) == 0x000000, "Member 'K28KillerInstinctEffect_Authority_OnKillerInstinctApplicableChanged::Active' has a wrong offset!");

// Function TheK28.K28KillerLockerComponent.OnPlayerInLockerChanged
// 0x0010 (0x0010 - 0x0000)
struct K28KillerLockerComponent_OnPlayerInLockerChanged final
{
public:
	class ADBDPlayer*                             PreviousPlayerInLocker;                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ADBDPlayer*                             NewPlayerInLocker;                                 // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28KillerLockerComponent_OnPlayerInLockerChanged) == 0x000008, "Wrong alignment on K28KillerLockerComponent_OnPlayerInLockerChanged");
static_assert(sizeof(K28KillerLockerComponent_OnPlayerInLockerChanged) == 0x000010, "Wrong size on K28KillerLockerComponent_OnPlayerInLockerChanged");
static_assert(offsetof(K28KillerLockerComponent_OnPlayerInLockerChanged, PreviousPlayerInLocker) == 0x000000, "Member 'K28KillerLockerComponent_OnPlayerInLockerChanged::PreviousPlayerInLocker' has a wrong offset!");
static_assert(offsetof(K28KillerLockerComponent_OnPlayerInLockerChanged, NewPlayerInLocker) == 0x000008, "Member 'K28KillerLockerComponent_OnPlayerInLockerChanged::NewPlayerInLocker' has a wrong offset!");

// Function TheK28.K28KillerTeleportationComponent.Local_OnTeleportCollisionOverlapBegin
// 0x0110 (0x0110 - 0x0000)
struct K28KillerTeleportationComponent_Local_OnTeleportCollisionOverlapBegin final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x00F0)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28KillerTeleportationComponent_Local_OnTeleportCollisionOverlapBegin) == 0x000008, "Wrong alignment on K28KillerTeleportationComponent_Local_OnTeleportCollisionOverlapBegin");
static_assert(sizeof(K28KillerTeleportationComponent_Local_OnTeleportCollisionOverlapBegin) == 0x000110, "Wrong size on K28KillerTeleportationComponent_Local_OnTeleportCollisionOverlapBegin");
static_assert(offsetof(K28KillerTeleportationComponent_Local_OnTeleportCollisionOverlapBegin, OverlappedComponent) == 0x000000, "Member 'K28KillerTeleportationComponent_Local_OnTeleportCollisionOverlapBegin::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(K28KillerTeleportationComponent_Local_OnTeleportCollisionOverlapBegin, OtherActor) == 0x000008, "Member 'K28KillerTeleportationComponent_Local_OnTeleportCollisionOverlapBegin::OtherActor' has a wrong offset!");
static_assert(offsetof(K28KillerTeleportationComponent_Local_OnTeleportCollisionOverlapBegin, OtherComp) == 0x000010, "Member 'K28KillerTeleportationComponent_Local_OnTeleportCollisionOverlapBegin::OtherComp' has a wrong offset!");
static_assert(offsetof(K28KillerTeleportationComponent_Local_OnTeleportCollisionOverlapBegin, OtherBodyIndex) == 0x000018, "Member 'K28KillerTeleportationComponent_Local_OnTeleportCollisionOverlapBegin::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(K28KillerTeleportationComponent_Local_OnTeleportCollisionOverlapBegin, bFromSweep) == 0x00001C, "Member 'K28KillerTeleportationComponent_Local_OnTeleportCollisionOverlapBegin::bFromSweep' has a wrong offset!");
static_assert(offsetof(K28KillerTeleportationComponent_Local_OnTeleportCollisionOverlapBegin, SweepResult) == 0x000020, "Member 'K28KillerTeleportationComponent_Local_OnTeleportCollisionOverlapBegin::SweepResult' has a wrong offset!");

// Function TheK28.K28KillerTeleportationComponent.Local_OnTeleportCollisionOverlapEnd
// 0x0020 (0x0020 - 0x0000)
struct K28KillerTeleportationComponent_Local_OnTeleportCollisionOverlapEnd final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(K28KillerTeleportationComponent_Local_OnTeleportCollisionOverlapEnd) == 0x000008, "Wrong alignment on K28KillerTeleportationComponent_Local_OnTeleportCollisionOverlapEnd");
static_assert(sizeof(K28KillerTeleportationComponent_Local_OnTeleportCollisionOverlapEnd) == 0x000020, "Wrong size on K28KillerTeleportationComponent_Local_OnTeleportCollisionOverlapEnd");
static_assert(offsetof(K28KillerTeleportationComponent_Local_OnTeleportCollisionOverlapEnd, OverlappedComponent) == 0x000000, "Member 'K28KillerTeleportationComponent_Local_OnTeleportCollisionOverlapEnd::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(K28KillerTeleportationComponent_Local_OnTeleportCollisionOverlapEnd, OtherActor) == 0x000008, "Member 'K28KillerTeleportationComponent_Local_OnTeleportCollisionOverlapEnd::OtherActor' has a wrong offset!");
static_assert(offsetof(K28KillerTeleportationComponent_Local_OnTeleportCollisionOverlapEnd, OtherComp) == 0x000010, "Member 'K28KillerTeleportationComponent_Local_OnTeleportCollisionOverlapEnd::OtherComp' has a wrong offset!");
static_assert(offsetof(K28KillerTeleportationComponent_Local_OnTeleportCollisionOverlapEnd, OtherBodyIndex) == 0x000018, "Member 'K28KillerTeleportationComponent_Local_OnTeleportCollisionOverlapEnd::OtherBodyIndex' has a wrong offset!");

// Function TheK28.K28KillerTeleportationComponent.Multicast_TeleportToLockerEnd
// 0x0010 (0x0010 - 0x0000)
struct K28KillerTeleportationComponent_Multicast_TeleportToLockerEnd final
{
public:
	class UK28LockerComponent*                    LockerTeleportedTo;                                // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACamperPlayer*                          SurvivorInLocker;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28KillerTeleportationComponent_Multicast_TeleportToLockerEnd) == 0x000008, "Wrong alignment on K28KillerTeleportationComponent_Multicast_TeleportToLockerEnd");
static_assert(sizeof(K28KillerTeleportationComponent_Multicast_TeleportToLockerEnd) == 0x000010, "Wrong size on K28KillerTeleportationComponent_Multicast_TeleportToLockerEnd");
static_assert(offsetof(K28KillerTeleportationComponent_Multicast_TeleportToLockerEnd, LockerTeleportedTo) == 0x000000, "Member 'K28KillerTeleportationComponent_Multicast_TeleportToLockerEnd::LockerTeleportedTo' has a wrong offset!");
static_assert(offsetof(K28KillerTeleportationComponent_Multicast_TeleportToLockerEnd, SurvivorInLocker) == 0x000008, "Member 'K28KillerTeleportationComponent_Multicast_TeleportToLockerEnd::SurvivorInLocker' has a wrong offset!");

// Function TheK28.K28KillerTeleportationComponent.Multicast_TeleportToLockerStart
// 0x0090 (0x0090 - 0x0000)
struct K28KillerTeleportationComponent_Multicast_TeleportToLockerStart final
{
public:
	struct FK28SecondaryCameraMovementData        CameraMovementData;                                // 0x0000(0x0080)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	class UK28LockerComponent*                    LockerBeingTeleportedTo;                           // 0x0080(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACamperPlayer*                          SurvivorToGrab;                                    // 0x0088(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28KillerTeleportationComponent_Multicast_TeleportToLockerStart) == 0x000008, "Wrong alignment on K28KillerTeleportationComponent_Multicast_TeleportToLockerStart");
static_assert(sizeof(K28KillerTeleportationComponent_Multicast_TeleportToLockerStart) == 0x000090, "Wrong size on K28KillerTeleportationComponent_Multicast_TeleportToLockerStart");
static_assert(offsetof(K28KillerTeleportationComponent_Multicast_TeleportToLockerStart, CameraMovementData) == 0x000000, "Member 'K28KillerTeleportationComponent_Multicast_TeleportToLockerStart::CameraMovementData' has a wrong offset!");
static_assert(offsetof(K28KillerTeleportationComponent_Multicast_TeleportToLockerStart, LockerBeingTeleportedTo) == 0x000080, "Member 'K28KillerTeleportationComponent_Multicast_TeleportToLockerStart::LockerBeingTeleportedTo' has a wrong offset!");
static_assert(offsetof(K28KillerTeleportationComponent_Multicast_TeleportToLockerStart, SurvivorToGrab) == 0x000088, "Member 'K28KillerTeleportationComponent_Multicast_TeleportToLockerStart::SurvivorToGrab' has a wrong offset!");

// Function TheK28.K28KillerTeleportationComponent.OnPlayerFinishedEnteringLocker
// 0x0010 (0x0010 - 0x0000)
struct K28KillerTeleportationComponent_OnPlayerFinishedEnteringLocker final
{
public:
	class ADBDPlayer*                             PlayerThatWasInLocker;                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ADBDPlayer*                             PlayerNowInLocker;                                 // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28KillerTeleportationComponent_OnPlayerFinishedEnteringLocker) == 0x000008, "Wrong alignment on K28KillerTeleportationComponent_OnPlayerFinishedEnteringLocker");
static_assert(sizeof(K28KillerTeleportationComponent_OnPlayerFinishedEnteringLocker) == 0x000010, "Wrong size on K28KillerTeleportationComponent_OnPlayerFinishedEnteringLocker");
static_assert(offsetof(K28KillerTeleportationComponent_OnPlayerFinishedEnteringLocker, PlayerThatWasInLocker) == 0x000000, "Member 'K28KillerTeleportationComponent_OnPlayerFinishedEnteringLocker::PlayerThatWasInLocker' has a wrong offset!");
static_assert(offsetof(K28KillerTeleportationComponent_OnPlayerFinishedEnteringLocker, PlayerNowInLocker) == 0x000008, "Member 'K28KillerTeleportationComponent_OnPlayerFinishedEnteringLocker::PlayerNowInLocker' has a wrong offset!");

// Function TheK28.K28Lockbar.Cosmetic_OnStateChanged
// 0x0001 (0x0001 - 0x0000)
struct K28Lockbar_Cosmetic_OnStateChanged final
{
public:
	EK28LockbarState                              NewState;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28Lockbar_Cosmetic_OnStateChanged) == 0x000001, "Wrong alignment on K28Lockbar_Cosmetic_OnStateChanged");
static_assert(sizeof(K28Lockbar_Cosmetic_OnStateChanged) == 0x000001, "Wrong size on K28Lockbar_Cosmetic_OnStateChanged");
static_assert(offsetof(K28Lockbar_Cosmetic_OnStateChanged, NewState) == 0x000000, "Member 'K28Lockbar_Cosmetic_OnStateChanged::NewState' has a wrong offset!");

// Function TheK28.K28Lockbar.Cosmetic_SetLockbarHighlightActivationState
// 0x0001 (0x0001 - 0x0000)
struct K28Lockbar_Cosmetic_SetLockbarHighlightActivationState final
{
public:
	bool                                          IsHightlightActive;                                // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28Lockbar_Cosmetic_SetLockbarHighlightActivationState) == 0x000001, "Wrong alignment on K28Lockbar_Cosmetic_SetLockbarHighlightActivationState");
static_assert(sizeof(K28Lockbar_Cosmetic_SetLockbarHighlightActivationState) == 0x000001, "Wrong size on K28Lockbar_Cosmetic_SetLockbarHighlightActivationState");
static_assert(offsetof(K28Lockbar_Cosmetic_SetLockbarHighlightActivationState, IsHightlightActive) == 0x000000, "Member 'K28Lockbar_Cosmetic_SetLockbarHighlightActivationState::IsHightlightActive' has a wrong offset!");

// Function TheK28.K28Lockbar.OnPlayerInLockerChanged
// 0x0010 (0x0010 - 0x0000)
struct K28Lockbar_OnPlayerInLockerChanged final
{
public:
	class ADBDPlayer*                             PreviousPlayerInLocker;                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ADBDPlayer*                             NewPlayerInLocker;                                 // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28Lockbar_OnPlayerInLockerChanged) == 0x000008, "Wrong alignment on K28Lockbar_OnPlayerInLockerChanged");
static_assert(sizeof(K28Lockbar_OnPlayerInLockerChanged) == 0x000010, "Wrong size on K28Lockbar_OnPlayerInLockerChanged");
static_assert(offsetof(K28Lockbar_OnPlayerInLockerChanged, PreviousPlayerInLocker) == 0x000000, "Member 'K28Lockbar_OnPlayerInLockerChanged::PreviousPlayerInLocker' has a wrong offset!");
static_assert(offsetof(K28Lockbar_OnPlayerInLockerChanged, NewPlayerInLocker) == 0x000008, "Member 'K28Lockbar_OnPlayerInLockerChanged::NewPlayerInLocker' has a wrong offset!");

// Function TheK28.K28Lockbar.GetMontagePlayer
// 0x0008 (0x0008 - 0x0000)
struct K28Lockbar_GetMontagePlayer final
{
public:
	class UMontagePlayer*                         ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28Lockbar_GetMontagePlayer) == 0x000008, "Wrong alignment on K28Lockbar_GetMontagePlayer");
static_assert(sizeof(K28Lockbar_GetMontagePlayer) == 0x000008, "Wrong size on K28Lockbar_GetMontagePlayer");
static_assert(offsetof(K28Lockbar_GetMontagePlayer, ReturnValue) == 0x000000, "Member 'K28Lockbar_GetMontagePlayer::ReturnValue' has a wrong offset!");

// Function TheK28.K28LockerCosmeticHelperActor.Cosmetic_OnLockedStateChanged
// 0x0001 (0x0001 - 0x0000)
struct K28LockerCosmeticHelperActor_Cosmetic_OnLockedStateChanged final
{
public:
	bool                                          IsLockerLocked;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28LockerCosmeticHelperActor_Cosmetic_OnLockedStateChanged) == 0x000001, "Wrong alignment on K28LockerCosmeticHelperActor_Cosmetic_OnLockedStateChanged");
static_assert(sizeof(K28LockerCosmeticHelperActor_Cosmetic_OnLockedStateChanged) == 0x000001, "Wrong size on K28LockerCosmeticHelperActor_Cosmetic_OnLockedStateChanged");
static_assert(offsetof(K28LockerCosmeticHelperActor_Cosmetic_OnLockedStateChanged, IsLockerLocked) == 0x000000, "Member 'K28LockerCosmeticHelperActor_Cosmetic_OnLockedStateChanged::IsLockerLocked' has a wrong offset!");

// Function TheK28.K28LockerCosmeticHelperActor.Cosmetic_OnLockerGrabStateChanged
// 0x0001 (0x0001 - 0x0000)
struct K28LockerCosmeticHelperActor_Cosmetic_OnLockerGrabStateChanged final
{
public:
	bool                                          IsLockerGrabOngoing;                               // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28LockerCosmeticHelperActor_Cosmetic_OnLockerGrabStateChanged) == 0x000001, "Wrong alignment on K28LockerCosmeticHelperActor_Cosmetic_OnLockerGrabStateChanged");
static_assert(sizeof(K28LockerCosmeticHelperActor_Cosmetic_OnLockerGrabStateChanged) == 0x000001, "Wrong size on K28LockerCosmeticHelperActor_Cosmetic_OnLockerGrabStateChanged");
static_assert(offsetof(K28LockerCosmeticHelperActor_Cosmetic_OnLockerGrabStateChanged, IsLockerGrabOngoing) == 0x000000, "Member 'K28LockerCosmeticHelperActor_Cosmetic_OnLockerGrabStateChanged::IsLockerGrabOngoing' has a wrong offset!");

// Function TheK28.K28LockerCosmeticHelperActor.GetLocker
// 0x0008 (0x0008 - 0x0000)
struct K28LockerCosmeticHelperActor_GetLocker final
{
public:
	class ALocker*                                ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28LockerCosmeticHelperActor_GetLocker) == 0x000008, "Wrong alignment on K28LockerCosmeticHelperActor_GetLocker");
static_assert(sizeof(K28LockerCosmeticHelperActor_GetLocker) == 0x000008, "Wrong size on K28LockerCosmeticHelperActor_GetLocker");
static_assert(offsetof(K28LockerCosmeticHelperActor_GetLocker, ReturnValue) == 0x000000, "Member 'K28LockerCosmeticHelperActor_GetLocker::ReturnValue' has a wrong offset!");

// Function TheK28.K28LockerCosmeticHelperActor.GetMaterialHelper
// 0x0008 (0x0008 - 0x0000)
struct K28LockerCosmeticHelperActor_GetMaterialHelper final
{
public:
	class UMaterialHelper*                        ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28LockerCosmeticHelperActor_GetMaterialHelper) == 0x000008, "Wrong alignment on K28LockerCosmeticHelperActor_GetMaterialHelper");
static_assert(sizeof(K28LockerCosmeticHelperActor_GetMaterialHelper) == 0x000008, "Wrong size on K28LockerCosmeticHelperActor_GetMaterialHelper");
static_assert(offsetof(K28LockerCosmeticHelperActor_GetMaterialHelper, ReturnValue) == 0x000000, "Member 'K28LockerCosmeticHelperActor_GetMaterialHelper::ReturnValue' has a wrong offset!");

// Function TheK28.K28LockerCosmeticHelperActor.GetSkeletalMesh
// 0x0008 (0x0008 - 0x0000)
struct K28LockerCosmeticHelperActor_GetSkeletalMesh final
{
public:
	class USkeletalMeshComponent*                 ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28LockerCosmeticHelperActor_GetSkeletalMesh) == 0x000008, "Wrong alignment on K28LockerCosmeticHelperActor_GetSkeletalMesh");
static_assert(sizeof(K28LockerCosmeticHelperActor_GetSkeletalMesh) == 0x000008, "Wrong size on K28LockerCosmeticHelperActor_GetSkeletalMesh");
static_assert(offsetof(K28LockerCosmeticHelperActor_GetSkeletalMesh, ReturnValue) == 0x000000, "Member 'K28LockerCosmeticHelperActor_GetSkeletalMesh::ReturnValue' has a wrong offset!");

// Function TheK28.K28LockerTeleportSwapInteraction.Multicast_ConfirmTeleportationRequest
// 0x0010 (0x0010 - 0x0000)
struct K28LockerTeleportSwapInteraction_Multicast_ConfirmTeleportationRequest final
{
public:
	class ASlasherPlayer*                         Killer;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UActorComponent*                        TeleportTarget;                                    // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28LockerTeleportSwapInteraction_Multicast_ConfirmTeleportationRequest) == 0x000008, "Wrong alignment on K28LockerTeleportSwapInteraction_Multicast_ConfirmTeleportationRequest");
static_assert(sizeof(K28LockerTeleportSwapInteraction_Multicast_ConfirmTeleportationRequest) == 0x000010, "Wrong size on K28LockerTeleportSwapInteraction_Multicast_ConfirmTeleportationRequest");
static_assert(offsetof(K28LockerTeleportSwapInteraction_Multicast_ConfirmTeleportationRequest, Killer) == 0x000000, "Member 'K28LockerTeleportSwapInteraction_Multicast_ConfirmTeleportationRequest::Killer' has a wrong offset!");
static_assert(offsetof(K28LockerTeleportSwapInteraction_Multicast_ConfirmTeleportationRequest, TeleportTarget) == 0x000008, "Member 'K28LockerTeleportSwapInteraction_Multicast_ConfirmTeleportationRequest::TeleportTarget' has a wrong offset!");

// Function TheK28.K28LockerTeleportSwapInteraction.Server_RequestTeleportToTarget
// 0x0010 (0x0010 - 0x0000)
struct K28LockerTeleportSwapInteraction_Server_RequestTeleportToTarget final
{
public:
	class ASlasherPlayer*                         Killer;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UActorComponent*                        TeleportTarget;                                    // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28LockerTeleportSwapInteraction_Server_RequestTeleportToTarget) == 0x000008, "Wrong alignment on K28LockerTeleportSwapInteraction_Server_RequestTeleportToTarget");
static_assert(sizeof(K28LockerTeleportSwapInteraction_Server_RequestTeleportToTarget) == 0x000010, "Wrong size on K28LockerTeleportSwapInteraction_Server_RequestTeleportToTarget");
static_assert(offsetof(K28LockerTeleportSwapInteraction_Server_RequestTeleportToTarget, Killer) == 0x000000, "Member 'K28LockerTeleportSwapInteraction_Server_RequestTeleportToTarget::Killer' has a wrong offset!");
static_assert(offsetof(K28LockerTeleportSwapInteraction_Server_RequestTeleportToTarget, TeleportTarget) == 0x000008, "Member 'K28LockerTeleportSwapInteraction_Server_RequestTeleportToTarget::TeleportTarget' has a wrong offset!");

// Function TheK28.K28MenuAnimInstance.BP_OnCustomizationAnimationMappingIDChanged
// 0x0004 (0x0004 - 0x0000)
struct K28MenuAnimInstance_BP_OnCustomizationAnimationMappingIDChanged final
{
public:
	int32                                         AnimationMappingIndex;                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28MenuAnimInstance_BP_OnCustomizationAnimationMappingIDChanged) == 0x000004, "Wrong alignment on K28MenuAnimInstance_BP_OnCustomizationAnimationMappingIDChanged");
static_assert(sizeof(K28MenuAnimInstance_BP_OnCustomizationAnimationMappingIDChanged) == 0x000004, "Wrong size on K28MenuAnimInstance_BP_OnCustomizationAnimationMappingIDChanged");
static_assert(offsetof(K28MenuAnimInstance_BP_OnCustomizationAnimationMappingIDChanged, AnimationMappingIndex) == 0x000000, "Member 'K28MenuAnimInstance_BP_OnCustomizationAnimationMappingIDChanged::AnimationMappingIndex' has a wrong offset!");

// Function TheK28.K28MenuAnimInstance.GetAnimationMappingIndex
// 0x0004 (0x0004 - 0x0000)
struct K28MenuAnimInstance_GetAnimationMappingIndex final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28MenuAnimInstance_GetAnimationMappingIndex) == 0x000004, "Wrong alignment on K28MenuAnimInstance_GetAnimationMappingIndex");
static_assert(sizeof(K28MenuAnimInstance_GetAnimationMappingIndex) == 0x000004, "Wrong size on K28MenuAnimInstance_GetAnimationMappingIndex");
static_assert(offsetof(K28MenuAnimInstance_GetAnimationMappingIndex, ReturnValue) == 0x000000, "Member 'K28MenuAnimInstance_GetAnimationMappingIndex::ReturnValue' has a wrong offset!");

// Function TheK28.K28P01.GetInjuryTimerDuration
// 0x0004 (0x0004 - 0x0000)
struct K28P01_GetInjuryTimerDuration final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28P01_GetInjuryTimerDuration) == 0x000004, "Wrong alignment on K28P01_GetInjuryTimerDuration");
static_assert(sizeof(K28P01_GetInjuryTimerDuration) == 0x000004, "Wrong size on K28P01_GetInjuryTimerDuration");
static_assert(offsetof(K28P01_GetInjuryTimerDuration, ReturnValue) == 0x000000, "Member 'K28P01_GetInjuryTimerDuration::ReturnValue' has a wrong offset!");

// Function TheK28.K28P01.GetPerkActivationDurationAtLevel
// 0x0004 (0x0004 - 0x0000)
struct K28P01_GetPerkActivationDurationAtLevel final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28P01_GetPerkActivationDurationAtLevel) == 0x000004, "Wrong alignment on K28P01_GetPerkActivationDurationAtLevel");
static_assert(sizeof(K28P01_GetPerkActivationDurationAtLevel) == 0x000004, "Wrong size on K28P01_GetPerkActivationDurationAtLevel");
static_assert(offsetof(K28P01_GetPerkActivationDurationAtLevel, ReturnValue) == 0x000000, "Member 'K28P01_GetPerkActivationDurationAtLevel::ReturnValue' has a wrong offset!");

// Function TheK28.K28P02.GetLockerDetectionRadius
// 0x0004 (0x0004 - 0x0000)
struct K28P02_GetLockerDetectionRadius final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28P02_GetLockerDetectionRadius) == 0x000004, "Wrong alignment on K28P02_GetLockerDetectionRadius");
static_assert(sizeof(K28P02_GetLockerDetectionRadius) == 0x000004, "Wrong size on K28P02_GetLockerDetectionRadius");
static_assert(offsetof(K28P02_GetLockerDetectionRadius, ReturnValue) == 0x000000, "Member 'K28P02_GetLockerDetectionRadius::ReturnValue' has a wrong offset!");

// Function TheK28.K28P02.GetPerkActivationTime
// 0x0004 (0x0004 - 0x0000)
struct K28P02_GetPerkActivationTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28P02_GetPerkActivationTime) == 0x000004, "Wrong alignment on K28P02_GetPerkActivationTime");
static_assert(sizeof(K28P02_GetPerkActivationTime) == 0x000004, "Wrong size on K28P02_GetPerkActivationTime");
static_assert(offsetof(K28P02_GetPerkActivationTime, ReturnValue) == 0x000000, "Member 'K28P02_GetPerkActivationTime::ReturnValue' has a wrong offset!");

// Function TheK28.K28Remnant.Authority_OnCollisionDetected
// 0x0110 (0x0110 - 0x0000)
struct K28Remnant_Authority_OnCollisionDetected final
{
public:
	class UPrimitiveComponent*                    HitComponent;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x00F0)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28Remnant_Authority_OnCollisionDetected) == 0x000008, "Wrong alignment on K28Remnant_Authority_OnCollisionDetected");
static_assert(sizeof(K28Remnant_Authority_OnCollisionDetected) == 0x000110, "Wrong size on K28Remnant_Authority_OnCollisionDetected");
static_assert(offsetof(K28Remnant_Authority_OnCollisionDetected, HitComponent) == 0x000000, "Member 'K28Remnant_Authority_OnCollisionDetected::HitComponent' has a wrong offset!");
static_assert(offsetof(K28Remnant_Authority_OnCollisionDetected, OtherActor) == 0x000008, "Member 'K28Remnant_Authority_OnCollisionDetected::OtherActor' has a wrong offset!");
static_assert(offsetof(K28Remnant_Authority_OnCollisionDetected, OtherComp) == 0x000010, "Member 'K28Remnant_Authority_OnCollisionDetected::OtherComp' has a wrong offset!");
static_assert(offsetof(K28Remnant_Authority_OnCollisionDetected, OtherBodyIndex) == 0x000018, "Member 'K28Remnant_Authority_OnCollisionDetected::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(K28Remnant_Authority_OnCollisionDetected, bFromSweep) == 0x00001C, "Member 'K28Remnant_Authority_OnCollisionDetected::bFromSweep' has a wrong offset!");
static_assert(offsetof(K28Remnant_Authority_OnCollisionDetected, SweepResult) == 0x000020, "Member 'K28Remnant_Authority_OnCollisionDetected::SweepResult' has a wrong offset!");

// Function TheK28.K28Remnant.Cosmetic_OnRemnantStateChanged
// 0x0001 (0x0001 - 0x0000)
struct K28Remnant_Cosmetic_OnRemnantStateChanged final
{
public:
	EK28RemnantState                              RemnantState;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28Remnant_Cosmetic_OnRemnantStateChanged) == 0x000001, "Wrong alignment on K28Remnant_Cosmetic_OnRemnantStateChanged");
static_assert(sizeof(K28Remnant_Cosmetic_OnRemnantStateChanged) == 0x000001, "Wrong size on K28Remnant_Cosmetic_OnRemnantStateChanged");
static_assert(offsetof(K28Remnant_Cosmetic_OnRemnantStateChanged, RemnantState) == 0x000000, "Member 'K28Remnant_Cosmetic_OnRemnantStateChanged::RemnantState' has a wrong offset!");

// Function TheK28.K28Remnant.Cosmetic_OnTeleportationPerformedVFX
// 0x0010 (0x0010 - 0x0000)
struct K28Remnant_Cosmetic_OnTeleportationPerformedVFX final
{
public:
	class ASlasherPlayer*                         Killer;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsSlowTeleportation;                               // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(K28Remnant_Cosmetic_OnTeleportationPerformedVFX) == 0x000008, "Wrong alignment on K28Remnant_Cosmetic_OnTeleportationPerformedVFX");
static_assert(sizeof(K28Remnant_Cosmetic_OnTeleportationPerformedVFX) == 0x000010, "Wrong size on K28Remnant_Cosmetic_OnTeleportationPerformedVFX");
static_assert(offsetof(K28Remnant_Cosmetic_OnTeleportationPerformedVFX, Killer) == 0x000000, "Member 'K28Remnant_Cosmetic_OnTeleportationPerformedVFX::Killer' has a wrong offset!");
static_assert(offsetof(K28Remnant_Cosmetic_OnTeleportationPerformedVFX, IsSlowTeleportation) == 0x000008, "Member 'K28Remnant_Cosmetic_OnTeleportationPerformedVFX::IsSlowTeleportation' has a wrong offset!");

// Function TheK28.K28Remnant.Cosmetic_OnTeleportationStartVFX
// 0x0008 (0x0008 - 0x0000)
struct K28Remnant_Cosmetic_OnTeleportationStartVFX final
{
public:
	class ASlasherPlayer*                         Killer;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28Remnant_Cosmetic_OnTeleportationStartVFX) == 0x000008, "Wrong alignment on K28Remnant_Cosmetic_OnTeleportationStartVFX");
static_assert(sizeof(K28Remnant_Cosmetic_OnTeleportationStartVFX) == 0x000008, "Wrong size on K28Remnant_Cosmetic_OnTeleportationStartVFX");
static_assert(offsetof(K28Remnant_Cosmetic_OnTeleportationStartVFX, Killer) == 0x000000, "Member 'K28Remnant_Cosmetic_OnTeleportationStartVFX::Killer' has a wrong offset!");

// Function TheK28.K28Remnant.Cosmetic_SurvivorDestroyedRemnant
// 0x0008 (0x0008 - 0x0000)
struct K28Remnant_Cosmetic_SurvivorDestroyedRemnant final
{
public:
	class ACamperPlayer*                          Survivor;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28Remnant_Cosmetic_SurvivorDestroyedRemnant) == 0x000008, "Wrong alignment on K28Remnant_Cosmetic_SurvivorDestroyedRemnant");
static_assert(sizeof(K28Remnant_Cosmetic_SurvivorDestroyedRemnant) == 0x000008, "Wrong size on K28Remnant_Cosmetic_SurvivorDestroyedRemnant");
static_assert(offsetof(K28Remnant_Cosmetic_SurvivorDestroyedRemnant, Survivor) == 0x000000, "Member 'K28Remnant_Cosmetic_SurvivorDestroyedRemnant::Survivor' has a wrong offset!");

// Function TheK28.K28Remnant.Multicast_ActivateRemnant
// 0x0030 (0x0030 - 0x0000)
struct K28Remnant_Multicast_ActivateRemnant final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x0018)(ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0018(0x0018)(ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28Remnant_Multicast_ActivateRemnant) == 0x000008, "Wrong alignment on K28Remnant_Multicast_ActivateRemnant");
static_assert(sizeof(K28Remnant_Multicast_ActivateRemnant) == 0x000030, "Wrong size on K28Remnant_Multicast_ActivateRemnant");
static_assert(offsetof(K28Remnant_Multicast_ActivateRemnant, Location) == 0x000000, "Member 'K28Remnant_Multicast_ActivateRemnant::Location' has a wrong offset!");
static_assert(offsetof(K28Remnant_Multicast_ActivateRemnant, Rotation) == 0x000018, "Member 'K28Remnant_Multicast_ActivateRemnant::Rotation' has a wrong offset!");

// Function TheK28.K28Remnant.Multicast_SurvivorDestroyedRemnant
// 0x0008 (0x0008 - 0x0000)
struct K28Remnant_Multicast_SurvivorDestroyedRemnant final
{
public:
	class ACamperPlayer*                          Survivor;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28Remnant_Multicast_SurvivorDestroyedRemnant) == 0x000008, "Wrong alignment on K28Remnant_Multicast_SurvivorDestroyedRemnant");
static_assert(sizeof(K28Remnant_Multicast_SurvivorDestroyedRemnant) == 0x000008, "Wrong size on K28Remnant_Multicast_SurvivorDestroyedRemnant");
static_assert(offsetof(K28Remnant_Multicast_SurvivorDestroyedRemnant, Survivor) == 0x000000, "Member 'K28Remnant_Multicast_SurvivorDestroyedRemnant::Survivor' has a wrong offset!");

// Function TheK28.K28Remnant.Multicast_TeleportToRemnant
// 0x0028 (0x0028 - 0x0000)
struct K28Remnant_Multicast_TeleportToRemnant final
{
public:
	class ASlasherPlayer*                         Killer;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               TeleportRotation;                                  // 0x0008(0x0018)(ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          IsAnimationSlowed;                                 // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(K28Remnant_Multicast_TeleportToRemnant) == 0x000008, "Wrong alignment on K28Remnant_Multicast_TeleportToRemnant");
static_assert(sizeof(K28Remnant_Multicast_TeleportToRemnant) == 0x000028, "Wrong size on K28Remnant_Multicast_TeleportToRemnant");
static_assert(offsetof(K28Remnant_Multicast_TeleportToRemnant, Killer) == 0x000000, "Member 'K28Remnant_Multicast_TeleportToRemnant::Killer' has a wrong offset!");
static_assert(offsetof(K28Remnant_Multicast_TeleportToRemnant, TeleportRotation) == 0x000008, "Member 'K28Remnant_Multicast_TeleportToRemnant::TeleportRotation' has a wrong offset!");
static_assert(offsetof(K28Remnant_Multicast_TeleportToRemnant, IsAnimationSlowed) == 0x000020, "Member 'K28Remnant_Multicast_TeleportToRemnant::IsAnimationSlowed' has a wrong offset!");

// Function TheK28.K28Remnant.Multicast_TriggerTeleportStart
// 0x0008 (0x0008 - 0x0000)
struct K28Remnant_Multicast_TriggerTeleportStart final
{
public:
	class ASlasherPlayer*                         Killer;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28Remnant_Multicast_TriggerTeleportStart) == 0x000008, "Wrong alignment on K28Remnant_Multicast_TriggerTeleportStart");
static_assert(sizeof(K28Remnant_Multicast_TriggerTeleportStart) == 0x000008, "Wrong size on K28Remnant_Multicast_TriggerTeleportStart");
static_assert(offsetof(K28Remnant_Multicast_TriggerTeleportStart, Killer) == 0x000000, "Member 'K28Remnant_Multicast_TriggerTeleportStart::Killer' has a wrong offset!");

// Function TheK28.K28RemnantAnimInstance.ConsumeSurvivorWhoDestroyedRemnant
// 0x0008 (0x0008 - 0x0000)
struct K28RemnantAnimInstance_ConsumeSurvivorWhoDestroyedRemnant final
{
public:
	class ACamperPlayer*                          ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28RemnantAnimInstance_ConsumeSurvivorWhoDestroyedRemnant) == 0x000008, "Wrong alignment on K28RemnantAnimInstance_ConsumeSurvivorWhoDestroyedRemnant");
static_assert(sizeof(K28RemnantAnimInstance_ConsumeSurvivorWhoDestroyedRemnant) == 0x000008, "Wrong size on K28RemnantAnimInstance_ConsumeSurvivorWhoDestroyedRemnant");
static_assert(offsetof(K28RemnantAnimInstance_ConsumeSurvivorWhoDestroyedRemnant, ReturnValue) == 0x000000, "Member 'K28RemnantAnimInstance_ConsumeSurvivorWhoDestroyedRemnant::ReturnValue' has a wrong offset!");

// Function TheK28.K28SecondaryCamera.Cosmetic_OnIsLocallyObservingKillerChanged
// 0x0001 (0x0001 - 0x0000)
struct K28SecondaryCamera_Cosmetic_OnIsLocallyObservingKillerChanged final
{
public:
	bool                                          IsLocallyObservingKiller;                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28SecondaryCamera_Cosmetic_OnIsLocallyObservingKillerChanged) == 0x000001, "Wrong alignment on K28SecondaryCamera_Cosmetic_OnIsLocallyObservingKillerChanged");
static_assert(sizeof(K28SecondaryCamera_Cosmetic_OnIsLocallyObservingKillerChanged) == 0x000001, "Wrong size on K28SecondaryCamera_Cosmetic_OnIsLocallyObservingKillerChanged");
static_assert(offsetof(K28SecondaryCamera_Cosmetic_OnIsLocallyObservingKillerChanged, IsLocallyObservingKiller) == 0x000000, "Member 'K28SecondaryCamera_Cosmetic_OnIsLocallyObservingKillerChanged::IsLocallyObservingKiller' has a wrong offset!");

// Function TheK28.K28SecondaryCamera.Cosmetic_OnNightCycleChanged
// 0x0001 (0x0001 - 0x0000)
struct K28SecondaryCamera_Cosmetic_OnNightCycleChanged final
{
public:
	EK28NightCycleState                           NewNightCycleState;                                // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28SecondaryCamera_Cosmetic_OnNightCycleChanged) == 0x000001, "Wrong alignment on K28SecondaryCamera_Cosmetic_OnNightCycleChanged");
static_assert(sizeof(K28SecondaryCamera_Cosmetic_OnNightCycleChanged) == 0x000001, "Wrong size on K28SecondaryCamera_Cosmetic_OnNightCycleChanged");
static_assert(offsetof(K28SecondaryCamera_Cosmetic_OnNightCycleChanged, NewNightCycleState) == 0x000000, "Member 'K28SecondaryCamera_Cosmetic_OnNightCycleChanged::NewNightCycleState' has a wrong offset!");

// Function TheK28.K28SecondaryCamera.Cosmetic_UpdateDarknessPlaneVisibility
// 0x0001 (0x0001 - 0x0000)
struct K28SecondaryCamera_Cosmetic_UpdateDarknessPlaneVisibility final
{
public:
	bool                                          IsVisible;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28SecondaryCamera_Cosmetic_UpdateDarknessPlaneVisibility) == 0x000001, "Wrong alignment on K28SecondaryCamera_Cosmetic_UpdateDarknessPlaneVisibility");
static_assert(sizeof(K28SecondaryCamera_Cosmetic_UpdateDarknessPlaneVisibility) == 0x000001, "Wrong size on K28SecondaryCamera_Cosmetic_UpdateDarknessPlaneVisibility");
static_assert(offsetof(K28SecondaryCamera_Cosmetic_UpdateDarknessPlaneVisibility, IsVisible) == 0x000000, "Member 'K28SecondaryCamera_Cosmetic_UpdateDarknessPlaneVisibility::IsVisible' has a wrong offset!");

// Function TheK28.K28SecondaryCamera.Multicast_SetCameraOrientation
// 0x0020 (0x0020 - 0x0000)
struct K28SecondaryCamera_Multicast_SetCameraOrientation final
{
public:
	struct FRotator                               NewOrientation;                                    // 0x0000(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          IsRelativeRotation;                                // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(K28SecondaryCamera_Multicast_SetCameraOrientation) == 0x000008, "Wrong alignment on K28SecondaryCamera_Multicast_SetCameraOrientation");
static_assert(sizeof(K28SecondaryCamera_Multicast_SetCameraOrientation) == 0x000020, "Wrong size on K28SecondaryCamera_Multicast_SetCameraOrientation");
static_assert(offsetof(K28SecondaryCamera_Multicast_SetCameraOrientation, NewOrientation) == 0x000000, "Member 'K28SecondaryCamera_Multicast_SetCameraOrientation::NewOrientation' has a wrong offset!");
static_assert(offsetof(K28SecondaryCamera_Multicast_SetCameraOrientation, IsRelativeRotation) == 0x000018, "Member 'K28SecondaryCamera_Multicast_SetCameraOrientation::IsRelativeRotation' has a wrong offset!");

// Function TheK28.K28SecondaryCamera.Server_SetCameraOrientation
// 0x0018 (0x0018 - 0x0000)
struct K28SecondaryCamera_Server_SetCameraOrientation final
{
public:
	struct FRotator                               NewOrientation;                                    // 0x0000(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28SecondaryCamera_Server_SetCameraOrientation) == 0x000008, "Wrong alignment on K28SecondaryCamera_Server_SetCameraOrientation");
static_assert(sizeof(K28SecondaryCamera_Server_SetCameraOrientation) == 0x000018, "Wrong size on K28SecondaryCamera_Server_SetCameraOrientation");
static_assert(offsetof(K28SecondaryCamera_Server_SetCameraOrientation, NewOrientation) == 0x000000, "Member 'K28SecondaryCamera_Server_SetCameraOrientation::NewOrientation' has a wrong offset!");

// Function TheK28.K28SecondaryCamera.Server_SetIsKillerPlayerViewTarget
// 0x0001 (0x0001 - 0x0000)
struct K28SecondaryCamera_Server_SetIsKillerPlayerViewTarget final
{
public:
	bool                                          IsKillerPlayerViewTarget;                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28SecondaryCamera_Server_SetIsKillerPlayerViewTarget) == 0x000001, "Wrong alignment on K28SecondaryCamera_Server_SetIsKillerPlayerViewTarget");
static_assert(sizeof(K28SecondaryCamera_Server_SetIsKillerPlayerViewTarget) == 0x000001, "Wrong size on K28SecondaryCamera_Server_SetIsKillerPlayerViewTarget");
static_assert(offsetof(K28SecondaryCamera_Server_SetIsKillerPlayerViewTarget, IsKillerPlayerViewTarget) == 0x000000, "Member 'K28SecondaryCamera_Server_SetIsKillerPlayerViewTarget::IsKillerPlayerViewTarget' has a wrong offset!");

// Function TheK28.K28SecondaryCamera.GetCameraWorldRotation
// 0x0018 (0x0018 - 0x0000)
struct K28SecondaryCamera_GetCameraWorldRotation final
{
public:
	struct FRotator                               ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28SecondaryCamera_GetCameraWorldRotation) == 0x000008, "Wrong alignment on K28SecondaryCamera_GetCameraWorldRotation");
static_assert(sizeof(K28SecondaryCamera_GetCameraWorldRotation) == 0x000018, "Wrong size on K28SecondaryCamera_GetCameraWorldRotation");
static_assert(offsetof(K28SecondaryCamera_GetCameraWorldRotation, ReturnValue) == 0x000000, "Member 'K28SecondaryCamera_GetCameraWorldRotation::ReturnValue' has a wrong offset!");

// Function TheK28.K28SecondaryCamera.GetIsKillerPlayerViewTarget
// 0x0001 (0x0001 - 0x0000)
struct K28SecondaryCamera_GetIsKillerPlayerViewTarget final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28SecondaryCamera_GetIsKillerPlayerViewTarget) == 0x000001, "Wrong alignment on K28SecondaryCamera_GetIsKillerPlayerViewTarget");
static_assert(sizeof(K28SecondaryCamera_GetIsKillerPlayerViewTarget) == 0x000001, "Wrong size on K28SecondaryCamera_GetIsKillerPlayerViewTarget");
static_assert(offsetof(K28SecondaryCamera_GetIsKillerPlayerViewTarget, ReturnValue) == 0x000000, "Member 'K28SecondaryCamera_GetIsKillerPlayerViewTarget::ReturnValue' has a wrong offset!");

// Function TheK28.K28SurvivorComponent.OnKillerInRangeChanged
// 0x0001 (0x0001 - 0x0000)
struct K28SurvivorComponent_OnKillerInRangeChanged final
{
public:
	bool                                          InRange;                                           // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28SurvivorComponent_OnKillerInRangeChanged) == 0x000001, "Wrong alignment on K28SurvivorComponent_OnKillerInRangeChanged");
static_assert(sizeof(K28SurvivorComponent_OnKillerInRangeChanged) == 0x000001, "Wrong size on K28SurvivorComponent_OnKillerInRangeChanged");
static_assert(offsetof(K28SurvivorComponent_OnKillerInRangeChanged, InRange) == 0x000000, "Member 'K28SurvivorComponent_OnKillerInRangeChanged::InRange' has a wrong offset!");

// Function TheK28.K28SurvivorCosmeticHelperActor.Cosmetic_OnNightCycleChanged
// 0x0002 (0x0002 - 0x0000)
struct K28SurvivorCosmeticHelperActor_Cosmetic_OnNightCycleChanged final
{
public:
	EK28NightCycleState                           NightCycleState;                                   // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Instant;                                           // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28SurvivorCosmeticHelperActor_Cosmetic_OnNightCycleChanged) == 0x000001, "Wrong alignment on K28SurvivorCosmeticHelperActor_Cosmetic_OnNightCycleChanged");
static_assert(sizeof(K28SurvivorCosmeticHelperActor_Cosmetic_OnNightCycleChanged) == 0x000002, "Wrong size on K28SurvivorCosmeticHelperActor_Cosmetic_OnNightCycleChanged");
static_assert(offsetof(K28SurvivorCosmeticHelperActor_Cosmetic_OnNightCycleChanged, NightCycleState) == 0x000000, "Member 'K28SurvivorCosmeticHelperActor_Cosmetic_OnNightCycleChanged::NightCycleState' has a wrong offset!");
static_assert(offsetof(K28SurvivorCosmeticHelperActor_Cosmetic_OnNightCycleChanged, Instant) == 0x000001, "Member 'K28SurvivorCosmeticHelperActor_Cosmetic_OnNightCycleChanged::Instant' has a wrong offset!");

// Function TheK28.K28SurvivorCosmeticHelperActor.GetDarknessPlaneMesh
// 0x0008 (0x0008 - 0x0000)
struct K28SurvivorCosmeticHelperActor_GetDarknessPlaneMesh final
{
public:
	class UStaticMeshComponent*                   ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28SurvivorCosmeticHelperActor_GetDarknessPlaneMesh) == 0x000008, "Wrong alignment on K28SurvivorCosmeticHelperActor_GetDarknessPlaneMesh");
static_assert(sizeof(K28SurvivorCosmeticHelperActor_GetDarknessPlaneMesh) == 0x000008, "Wrong size on K28SurvivorCosmeticHelperActor_GetDarknessPlaneMesh");
static_assert(offsetof(K28SurvivorCosmeticHelperActor_GetDarknessPlaneMesh, ReturnValue) == 0x000000, "Member 'K28SurvivorCosmeticHelperActor_GetDarknessPlaneMesh::ReturnValue' has a wrong offset!");

// Function TheK28.K28TeleportationStrategyComponent.Multicast_UpdateBestTeleportTarget
// 0x0004 (0x0004 - 0x0000)
struct K28TeleportationStrategyComponent_Multicast_UpdateBestTeleportTarget final
{
public:
	int32                                         bestTeleportTargetID;                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28TeleportationStrategyComponent_Multicast_UpdateBestTeleportTarget) == 0x000004, "Wrong alignment on K28TeleportationStrategyComponent_Multicast_UpdateBestTeleportTarget");
static_assert(sizeof(K28TeleportationStrategyComponent_Multicast_UpdateBestTeleportTarget) == 0x000004, "Wrong size on K28TeleportationStrategyComponent_Multicast_UpdateBestTeleportTarget");
static_assert(offsetof(K28TeleportationStrategyComponent_Multicast_UpdateBestTeleportTarget, bestTeleportTargetID) == 0x000000, "Member 'K28TeleportationStrategyComponent_Multicast_UpdateBestTeleportTarget::bestTeleportTargetID' has a wrong offset!");

// Function TheK28.K28TeleportationStrategyComponent.Server_UpdateBestTeleportTarget
// 0x0004 (0x0004 - 0x0000)
struct K28TeleportationStrategyComponent_Server_UpdateBestTeleportTarget final
{
public:
	int32                                         bestTeleportTargetID;                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28TeleportationStrategyComponent_Server_UpdateBestTeleportTarget) == 0x000004, "Wrong alignment on K28TeleportationStrategyComponent_Server_UpdateBestTeleportTarget");
static_assert(sizeof(K28TeleportationStrategyComponent_Server_UpdateBestTeleportTarget) == 0x000004, "Wrong size on K28TeleportationStrategyComponent_Server_UpdateBestTeleportTarget");
static_assert(offsetof(K28TeleportationStrategyComponent_Server_UpdateBestTeleportTarget, bestTeleportTargetID) == 0x000000, "Member 'K28TeleportationStrategyComponent_Server_UpdateBestTeleportTarget::bestTeleportTargetID' has a wrong offset!");

// Function TheK28.K28TeleportInteraction.Multicast_ConfirmTeleportationRequest
// 0x0010 (0x0010 - 0x0000)
struct K28TeleportInteraction_Multicast_ConfirmTeleportationRequest final
{
public:
	class ASlasherPlayer*                         Killer;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                TeleportTarget;                                    // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28TeleportInteraction_Multicast_ConfirmTeleportationRequest) == 0x000008, "Wrong alignment on K28TeleportInteraction_Multicast_ConfirmTeleportationRequest");
static_assert(sizeof(K28TeleportInteraction_Multicast_ConfirmTeleportationRequest) == 0x000010, "Wrong size on K28TeleportInteraction_Multicast_ConfirmTeleportationRequest");
static_assert(offsetof(K28TeleportInteraction_Multicast_ConfirmTeleportationRequest, Killer) == 0x000000, "Member 'K28TeleportInteraction_Multicast_ConfirmTeleportationRequest::Killer' has a wrong offset!");
static_assert(offsetof(K28TeleportInteraction_Multicast_ConfirmTeleportationRequest, TeleportTarget) == 0x000008, "Member 'K28TeleportInteraction_Multicast_ConfirmTeleportationRequest::TeleportTarget' has a wrong offset!");

// Function TheK28.K28TeleportInteraction.Server_RequestTeleportToTarget
// 0x0010 (0x0010 - 0x0000)
struct K28TeleportInteraction_Server_RequestTeleportToTarget final
{
public:
	class ASlasherPlayer*                         Killer;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                TeleportTarget;                                    // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28TeleportInteraction_Server_RequestTeleportToTarget) == 0x000008, "Wrong alignment on K28TeleportInteraction_Server_RequestTeleportToTarget");
static_assert(sizeof(K28TeleportInteraction_Server_RequestTeleportToTarget) == 0x000010, "Wrong size on K28TeleportInteraction_Server_RequestTeleportToTarget");
static_assert(offsetof(K28TeleportInteraction_Server_RequestTeleportToTarget, Killer) == 0x000000, "Member 'K28TeleportInteraction_Server_RequestTeleportToTarget::Killer' has a wrong offset!");
static_assert(offsetof(K28TeleportInteraction_Server_RequestTeleportToTarget, TeleportTarget) == 0x000008, "Member 'K28TeleportInteraction_Server_RequestTeleportToTarget::TeleportTarget' has a wrong offset!");

// Function TheK28.K28Utilities.GetDayNightComponent
// 0x0010 (0x0010 - 0x0000)
struct K28Utilities_GetDayNightComponent final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UK28DayNightComponent*                  ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28Utilities_GetDayNightComponent) == 0x000008, "Wrong alignment on K28Utilities_GetDayNightComponent");
static_assert(sizeof(K28Utilities_GetDayNightComponent) == 0x000010, "Wrong size on K28Utilities_GetDayNightComponent");
static_assert(offsetof(K28Utilities_GetDayNightComponent, WorldContextObject) == 0x000000, "Member 'K28Utilities_GetDayNightComponent::WorldContextObject' has a wrong offset!");
static_assert(offsetof(K28Utilities_GetDayNightComponent, ReturnValue) == 0x000008, "Member 'K28Utilities_GetDayNightComponent::ReturnValue' has a wrong offset!");

// Function TheK28.K28Utilities.GetK28Power
// 0x0010 (0x0010 - 0x0000)
struct K28Utilities_GetK28Power final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AK28Power*                              ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28Utilities_GetK28Power) == 0x000008, "Wrong alignment on K28Utilities_GetK28Power");
static_assert(sizeof(K28Utilities_GetK28Power) == 0x000010, "Wrong size on K28Utilities_GetK28Power");
static_assert(offsetof(K28Utilities_GetK28Power, WorldContextObject) == 0x000000, "Member 'K28Utilities_GetK28Power::WorldContextObject' has a wrong offset!");
static_assert(offsetof(K28Utilities_GetK28Power, ReturnValue) == 0x000008, "Member 'K28Utilities_GetK28Power::ReturnValue' has a wrong offset!");

// Function TheK28.K28Utilities.GetRemnant
// 0x0010 (0x0010 - 0x0000)
struct K28Utilities_GetRemnant final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AK28Remnant*                            ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28Utilities_GetRemnant) == 0x000008, "Wrong alignment on K28Utilities_GetRemnant");
static_assert(sizeof(K28Utilities_GetRemnant) == 0x000010, "Wrong size on K28Utilities_GetRemnant");
static_assert(offsetof(K28Utilities_GetRemnant, WorldContextObject) == 0x000000, "Member 'K28Utilities_GetRemnant::WorldContextObject' has a wrong offset!");
static_assert(offsetof(K28Utilities_GetRemnant, ReturnValue) == 0x000008, "Member 'K28Utilities_GetRemnant::ReturnValue' has a wrong offset!");

// Function TheK28.K28Utilities.GetSecondaryCamera
// 0x0010 (0x0010 - 0x0000)
struct K28Utilities_GetSecondaryCamera final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AK28SecondaryCamera*                    ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28Utilities_GetSecondaryCamera) == 0x000008, "Wrong alignment on K28Utilities_GetSecondaryCamera");
static_assert(sizeof(K28Utilities_GetSecondaryCamera) == 0x000010, "Wrong size on K28Utilities_GetSecondaryCamera");
static_assert(offsetof(K28Utilities_GetSecondaryCamera, WorldContextObject) == 0x000000, "Member 'K28Utilities_GetSecondaryCamera::WorldContextObject' has a wrong offset!");
static_assert(offsetof(K28Utilities_GetSecondaryCamera, ReturnValue) == 0x000008, "Member 'K28Utilities_GetSecondaryCamera::ReturnValue' has a wrong offset!");

// Function TheK28.K28Utilities.GetTeleportationStrategyComponent
// 0x0010 (0x0010 - 0x0000)
struct K28Utilities_GetTeleportationStrategyComponent final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UK28TeleportationStrategyComponent*     ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28Utilities_GetTeleportationStrategyComponent) == 0x000008, "Wrong alignment on K28Utilities_GetTeleportationStrategyComponent");
static_assert(sizeof(K28Utilities_GetTeleportationStrategyComponent) == 0x000010, "Wrong size on K28Utilities_GetTeleportationStrategyComponent");
static_assert(offsetof(K28Utilities_GetTeleportationStrategyComponent, WorldContextObject) == 0x000000, "Member 'K28Utilities_GetTeleportationStrategyComponent::WorldContextObject' has a wrong offset!");
static_assert(offsetof(K28Utilities_GetTeleportationStrategyComponent, ReturnValue) == 0x000008, "Member 'K28Utilities_GetTeleportationStrategyComponent::ReturnValue' has a wrong offset!");

// Function TheK28.K28Utilities.IsLockerUsedByKillerLocked
// 0x0010 (0x0010 - 0x0000)
struct K28Utilities_IsLockerUsedByKillerLocked final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(K28Utilities_IsLockerUsedByKillerLocked) == 0x000008, "Wrong alignment on K28Utilities_IsLockerUsedByKillerLocked");
static_assert(sizeof(K28Utilities_IsLockerUsedByKillerLocked) == 0x000010, "Wrong size on K28Utilities_IsLockerUsedByKillerLocked");
static_assert(offsetof(K28Utilities_IsLockerUsedByKillerLocked, WorldContextObject) == 0x000000, "Member 'K28Utilities_IsLockerUsedByKillerLocked::WorldContextObject' has a wrong offset!");
static_assert(offsetof(K28Utilities_IsLockerUsedByKillerLocked, ReturnValue) == 0x000008, "Member 'K28Utilities_IsLockerUsedByKillerLocked::ReturnValue' has a wrong offset!");

}

