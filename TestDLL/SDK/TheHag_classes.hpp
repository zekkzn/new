#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: TheHag

#include "Basic.hpp"

#include "Competence_classes.hpp"
#include "DBDAnimation_classes.hpp"
#include "DBDInteraction_classes.hpp"
#include "DataTableUtilities_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "DeadByDaylight_structs.hpp"
#include "DeadByDaylight_classes.hpp"
#include "CoreUObject_structs.hpp"


namespace SDK
{

// Class TheHag.PhantomTrapOutlineStrategy
// 0x0020 (0x0168 - 0x0148)
class UPhantomTrapOutlineStrategy final : public USourceBasedOutlineUpdateStrategy
{
public:
	TWeakObjectPtr<class APhantomTrap>            _cachedOwningPhantomTrap;                          // 0x0148(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           _colorWhenTeleportationIsAvailable;                // 0x0150(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _colorAlphaBasedOnDistance;                        // 0x0160(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PhantomTrapOutlineStrategy">();
	}
	static class UPhantomTrapOutlineStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPhantomTrapOutlineStrategy>();
	}
};
static_assert(alignof(UPhantomTrapOutlineStrategy) == 0x000008, "Wrong alignment on UPhantomTrapOutlineStrategy");
static_assert(sizeof(UPhantomTrapOutlineStrategy) == 0x000168, "Wrong size on UPhantomTrapOutlineStrategy");
static_assert(offsetof(UPhantomTrapOutlineStrategy, _cachedOwningPhantomTrap) == 0x000148, "Member 'UPhantomTrapOutlineStrategy::_cachedOwningPhantomTrap' has a wrong offset!");
static_assert(offsetof(UPhantomTrapOutlineStrategy, _colorWhenTeleportationIsAvailable) == 0x000150, "Member 'UPhantomTrapOutlineStrategy::_colorWhenTeleportationIsAvailable' has a wrong offset!");
static_assert(offsetof(UPhantomTrapOutlineStrategy, _colorAlphaBasedOnDistance) == 0x000160, "Member 'UPhantomTrapOutlineStrategy::_colorAlphaBasedOnDistance' has a wrong offset!");

// Class TheHag.HagAnimInstance
// 0x0000 (0x0720 - 0x0720)
class UHagAnimInstance final : public UKillerAnimInstance
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HagAnimInstance">();
	}
	static class UHagAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHagAnimInstance>();
	}
};
static_assert(alignof(UHagAnimInstance) == 0x000010, "Wrong alignment on UHagAnimInstance");
static_assert(sizeof(UHagAnimInstance) == 0x000720, "Wrong size on UHagAnimInstance");

// Class TheHag.HagDynamicAccessoryAnimInstance
// 0x0000 (0x0360 - 0x0360)
class UHagDynamicAccessoryAnimInstance final : public UDynamicAccessoryAnimInstance
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HagDynamicAccessoryAnimInstance">();
	}
	static class UHagDynamicAccessoryAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHagDynamicAccessoryAnimInstance>();
	}
};
static_assert(alignof(UHagDynamicAccessoryAnimInstance) == 0x000010, "Wrong alignment on UHagDynamicAccessoryAnimInstance");
static_assert(sizeof(UHagDynamicAccessoryAnimInstance) == 0x000360, "Wrong size on UHagDynamicAccessoryAnimInstance");

// Class TheHag.HagScoreComponent
// 0x00A8 (0x0150 - 0x00A8)
class UHagScoreComponent final : public UActorComponent
{
public:
	struct FDBDTunableRowHandle                   _trapAttackDuration;                               // 0x00A8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D0[0x80];                                      // 0x00D0(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnActorEndPlay(class AActor* Actor, EEndPlayReason EndPlayReason);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HagScoreComponent">();
	}
	static class UHagScoreComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHagScoreComponent>();
	}
};
static_assert(alignof(UHagScoreComponent) == 0x000008, "Wrong alignment on UHagScoreComponent");
static_assert(sizeof(UHagScoreComponent) == 0x000150, "Wrong size on UHagScoreComponent");
static_assert(offsetof(UHagScoreComponent, _trapAttackDuration) == 0x0000A8, "Member 'UHagScoreComponent::_trapAttackDuration' has a wrong offset!");

// Class TheHag.HasActivePhantomTrap
// 0x0018 (0x00F8 - 0x00E0)
class UHasActivePhantomTrap final : public UEventDrivenModifierCondition
{
public:
	uint8                                         Pad_E0[0x18];                                      // 0x00E0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HasActivePhantomTrap">();
	}
	static class UHasActivePhantomTrap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHasActivePhantomTrap>();
	}
};
static_assert(alignof(UHasActivePhantomTrap) == 0x000008, "Wrong alignment on UHasActivePhantomTrap");
static_assert(sizeof(UHasActivePhantomTrap) == 0x0000F8, "Wrong size on UHasActivePhantomTrap");

// Class TheHag.K05AnimInstance
// 0x0000 (0x0720 - 0x0720)
class UK05AnimInstance final : public UKillerAnimInstance
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K05AnimInstance">();
	}
	static class UK05AnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK05AnimInstance>();
	}
};
static_assert(alignof(UK05AnimInstance) == 0x000010, "Wrong alignment on UK05AnimInstance");
static_assert(sizeof(UK05AnimInstance) == 0x000720, "Wrong size on UK05AnimInstance");

// Class TheHag.PhantomTrap
// 0x0100 (0x04A8 - 0x03A8)
class APhantomTrap final : public AInteractable
{
public:
	uint8                                         Pad_3A8[0x18];                                     // 0x03A8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _phantomHasCollision;                              // 0x03C0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _silentTrapTrigger;                                // 0x03C1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isDeactivating;                                   // 0x03C2(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C3[0x5];                                      // 0x03C3(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class ADBDPlayer*                             _slasherOwner;                                     // 0x03C8(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UStatusEffect>              _slowdownInTrapZoneEffect;                         // 0x03D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTerrorRadiusEmitterComponent*          _terrorRadiusEmitter;                              // 0x03D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _camperOutlineDuration;                            // 0x03E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _lineOfSightTraceMinInterval;                      // 0x03E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _speedTolerance;                                   // 0x03E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3EC[0x4];                                      // 0x03EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        _trapLocation;                                     // 0x03F0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USphereComponent*                       _triggerZone;                                      // 0x03F8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UStatusEffect*>                  _survivorSlowdownEffects;                          // 0x0400(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class UChargeableComponent*                   _wipeAwayInteractionChargeable;                    // 0x0410(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoClear, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWipeAwayPhantomTrapInteraction*        _wipeAwayInteraction;                              // 0x0418(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoClear, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInteractor*                            _wipeAwayInteractor;                               // 0x0420(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoClear, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPrimitiveComponent*                    _wipeAwayInteractionZone;                          // 0x0428(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoClear, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _wipeAwayTimeDuration;                             // 0x0430(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_458[0xD];                                      // 0x0458(0x000D)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _hasTrapBeenSetOff;                                // 0x0465(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _hasTrapBeenDestroyed;                             // 0x0466(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isInUse;                                          // 0x0467(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTimer                              _activeTimer;                                      // 0x0468(0x0028)(Edit, BlueprintVisible, EditConst, NativeAccessSpecifierPrivate)
	bool                                          _isSlasherHere;                                    // 0x0490(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_491[0x17];                                     // 0x0491(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActivateSlasher(class ASlasherPlayer* Slasher);
	void Authority_OnTriggerZoneBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void Authority_OnTriggerZoneEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void BP_OnTrapActivate(class ACamperPlayer* Triggerer);
	void BP_OnTrapDestroyed(class ACamperPlayer* PlayerDestroyingTrap);
	bool CanActivateTrap(class ACamperPlayer* Camper, bool IsInUse);
	void InitializeTerrorRadiusEmitter(class ASlasherPlayer* OwningSlasher);
	void Multicast_DestroyTrap(class ACamperPlayer* PlayerDestroyingTrap);
	void OnTrapActivated();
	void OnTrapPlaced();
	void OnTrapReset();
	void RetrievePerkFlags(const struct FGameplayTag& SilentTrapTag, const struct FGameplayTag& PhantomCollisionTag);
	void SetIsInUse(bool InUse);

	class USkeletalMeshComponent* GetMesh() const;
	class USceneComponent* GetPhantomTransform() const;
	bool HasKillerTeleported() const;
	bool IsSilentTrigger() const;
	bool IsTrapActive() const;
	bool IsTrapDeactivating() const;
	bool IsTrapSet() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PhantomTrap">();
	}
	static class APhantomTrap* GetDefaultObj()
	{
		return GetDefaultObjImpl<APhantomTrap>();
	}
};
static_assert(alignof(APhantomTrap) == 0x000008, "Wrong alignment on APhantomTrap");
static_assert(sizeof(APhantomTrap) == 0x0004A8, "Wrong size on APhantomTrap");
static_assert(offsetof(APhantomTrap, _phantomHasCollision) == 0x0003C0, "Member 'APhantomTrap::_phantomHasCollision' has a wrong offset!");
static_assert(offsetof(APhantomTrap, _silentTrapTrigger) == 0x0003C1, "Member 'APhantomTrap::_silentTrapTrigger' has a wrong offset!");
static_assert(offsetof(APhantomTrap, _isDeactivating) == 0x0003C2, "Member 'APhantomTrap::_isDeactivating' has a wrong offset!");
static_assert(offsetof(APhantomTrap, _slasherOwner) == 0x0003C8, "Member 'APhantomTrap::_slasherOwner' has a wrong offset!");
static_assert(offsetof(APhantomTrap, _slowdownInTrapZoneEffect) == 0x0003D0, "Member 'APhantomTrap::_slowdownInTrapZoneEffect' has a wrong offset!");
static_assert(offsetof(APhantomTrap, _terrorRadiusEmitter) == 0x0003D8, "Member 'APhantomTrap::_terrorRadiusEmitter' has a wrong offset!");
static_assert(offsetof(APhantomTrap, _camperOutlineDuration) == 0x0003E0, "Member 'APhantomTrap::_camperOutlineDuration' has a wrong offset!");
static_assert(offsetof(APhantomTrap, _lineOfSightTraceMinInterval) == 0x0003E4, "Member 'APhantomTrap::_lineOfSightTraceMinInterval' has a wrong offset!");
static_assert(offsetof(APhantomTrap, _speedTolerance) == 0x0003E8, "Member 'APhantomTrap::_speedTolerance' has a wrong offset!");
static_assert(offsetof(APhantomTrap, _trapLocation) == 0x0003F0, "Member 'APhantomTrap::_trapLocation' has a wrong offset!");
static_assert(offsetof(APhantomTrap, _triggerZone) == 0x0003F8, "Member 'APhantomTrap::_triggerZone' has a wrong offset!");
static_assert(offsetof(APhantomTrap, _survivorSlowdownEffects) == 0x000400, "Member 'APhantomTrap::_survivorSlowdownEffects' has a wrong offset!");
static_assert(offsetof(APhantomTrap, _wipeAwayInteractionChargeable) == 0x000410, "Member 'APhantomTrap::_wipeAwayInteractionChargeable' has a wrong offset!");
static_assert(offsetof(APhantomTrap, _wipeAwayInteraction) == 0x000418, "Member 'APhantomTrap::_wipeAwayInteraction' has a wrong offset!");
static_assert(offsetof(APhantomTrap, _wipeAwayInteractor) == 0x000420, "Member 'APhantomTrap::_wipeAwayInteractor' has a wrong offset!");
static_assert(offsetof(APhantomTrap, _wipeAwayInteractionZone) == 0x000428, "Member 'APhantomTrap::_wipeAwayInteractionZone' has a wrong offset!");
static_assert(offsetof(APhantomTrap, _wipeAwayTimeDuration) == 0x000430, "Member 'APhantomTrap::_wipeAwayTimeDuration' has a wrong offset!");
static_assert(offsetof(APhantomTrap, _hasTrapBeenSetOff) == 0x000465, "Member 'APhantomTrap::_hasTrapBeenSetOff' has a wrong offset!");
static_assert(offsetof(APhantomTrap, _hasTrapBeenDestroyed) == 0x000466, "Member 'APhantomTrap::_hasTrapBeenDestroyed' has a wrong offset!");
static_assert(offsetof(APhantomTrap, _isInUse) == 0x000467, "Member 'APhantomTrap::_isInUse' has a wrong offset!");
static_assert(offsetof(APhantomTrap, _activeTimer) == 0x000468, "Member 'APhantomTrap::_activeTimer' has a wrong offset!");
static_assert(offsetof(APhantomTrap, _isSlasherHere) == 0x000490, "Member 'APhantomTrap::_isSlasherHere' has a wrong offset!");

// Class TheHag.TeleportToPhantomTrap
// 0x0050 (0x07D0 - 0x0780)
class UTeleportToPhantomTrap final : public UInteractionDefinition
{
public:
	struct FDBDTunableRowHandle                   _teleportMaxDistance;                              // 0x0778(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _slowdownTimeAfterTeleport;                        // 0x07A0(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UStatusEffect>              _hagSlowdownAfterTeleportStatusEffect;             // 0x07C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void BP_OnTeleport(class ASlasherPlayer* Slasher, class APhantomTrap* Trap);
	void Cosmetic_OnInteractionFinished(class ADBDPlayer* Slasher, bool HasInteractionStarted);
	void Cosmetic_OnTeleport(class ASlasherPlayer* Slasher, class APhantomTrap* Trap);

	class APhantomTrap* GetPhantomTrap() const;
	float GetTeleportMaxDistance(class ASlasherPlayer* Slasher) const;
	bool IsTeleportationPossible(const class ADBDPlayer* Player) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TeleportToPhantomTrap">();
	}
	static class UTeleportToPhantomTrap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTeleportToPhantomTrap>();
	}
};
static_assert(alignof(UTeleportToPhantomTrap) == 0x000010, "Wrong alignment on UTeleportToPhantomTrap");
static_assert(sizeof(UTeleportToPhantomTrap) == 0x0007D0, "Wrong size on UTeleportToPhantomTrap");
static_assert(offsetof(UTeleportToPhantomTrap, _teleportMaxDistance) == 0x000778, "Member 'UTeleportToPhantomTrap::_teleportMaxDistance' has a wrong offset!");
static_assert(offsetof(UTeleportToPhantomTrap, _slowdownTimeAfterTeleport) == 0x0007A0, "Member 'UTeleportToPhantomTrap::_slowdownTimeAfterTeleport' has a wrong offset!");
static_assert(offsetof(UTeleportToPhantomTrap, _hagSlowdownAfterTeleportStatusEffect) == 0x0007C8, "Member 'UTeleportToPhantomTrap::_hagSlowdownAfterTeleportStatusEffect' has a wrong offset!");

// Class TheHag.WipeAwayPhantomTrapInteraction
// 0x0000 (0x0920 - 0x0920)
class UWipeAwayPhantomTrapInteraction final : public UBasicChargeableInteraction
{
public:
	void CancelInteraction(class ADBDPlayer* Player);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WipeAwayPhantomTrapInteraction">();
	}
	static class UWipeAwayPhantomTrapInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWipeAwayPhantomTrapInteraction>();
	}
};
static_assert(alignof(UWipeAwayPhantomTrapInteraction) == 0x000010, "Wrong alignment on UWipeAwayPhantomTrapInteraction");
static_assert(sizeof(UWipeAwayPhantomTrapInteraction) == 0x000920, "Wrong size on UWipeAwayPhantomTrapInteraction");

}

