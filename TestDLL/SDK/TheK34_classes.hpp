#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: TheK34

#include "Basic.hpp"

#include "DBDAnimation_classes.hpp"
#include "Engine_classes.hpp"
#include "TheK34_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "AnimationUtilities_classes.hpp"
#include "DeadByDaylight_structs.hpp"
#include "DeadByDaylight_classes.hpp"
#include "GameplayTags_structs.hpp"
#include "AIModule_structs.hpp"
#include "DataTableUtilities_structs.hpp"
#include "StatSystem_structs.hpp"
#include "DBDSharedTypes_structs.hpp"
#include "DBDCompetence_classes.hpp"
#include "DBDAttack_classes.hpp"
#include "DBDCosmetic_classes.hpp"
#include "GameplayTagUtilities_structs.hpp"


namespace SDK
{

// Class TheK34.K34EnterTipToeModeInteraction
// 0x0000 (0x0780 - 0x0780)
class UK34EnterTipToeModeInteraction final : public UInteractionDefinition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K34EnterTipToeModeInteraction">();
	}
	static class UK34EnterTipToeModeInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK34EnterTipToeModeInteraction>();
	}
};
static_assert(alignof(UK34EnterTipToeModeInteraction) == 0x000010, "Wrong alignment on UK34EnterTipToeModeInteraction");
static_assert(sizeof(UK34EnterTipToeModeInteraction) == 0x000780, "Wrong size on UK34EnterTipToeModeInteraction");

// Class TheK34.K34AnimInstance
// 0x0010 (0x0730 - 0x0720)
class UK34AnimInstance final : public UKillerAnimInstance
{
public:
	bool                                          _isDodson;                                         // 0x0720(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _shouldUseLookAt;                                  // 0x0721(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_722[0xE];                                      // 0x0722(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K34AnimInstance">();
	}
	static class UK34AnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK34AnimInstance>();
	}
};
static_assert(alignof(UK34AnimInstance) == 0x000010, "Wrong alignment on UK34AnimInstance");
static_assert(sizeof(UK34AnimInstance) == 0x000730, "Wrong size on UK34AnimInstance");
static_assert(offsetof(UK34AnimInstance, _isDodson) == 0x000720, "Member 'UK34AnimInstance::_isDodson' has a wrong offset!");
static_assert(offsetof(UK34AnimInstance, _shouldUseLookAt) == 0x000721, "Member 'UK34AnimInstance::_shouldUseLookAt' has a wrong offset!");

// Class TheK34.K34ExitTipToeModeInteraction
// 0x0000 (0x0780 - 0x0780)
class UK34ExitTipToeModeInteraction final : public UInteractionDefinition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K34ExitTipToeModeInteraction">();
	}
	static class UK34ExitTipToeModeInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK34ExitTipToeModeInteraction>();
	}
};
static_assert(alignof(UK34ExitTipToeModeInteraction) == 0x000010, "Wrong alignment on UK34ExitTipToeModeInteraction");
static_assert(sizeof(UK34ExitTipToeModeInteraction) == 0x000780, "Wrong size on UK34ExitTipToeModeInteraction");

// Class TheK34.K34CheatComponent
// 0x0000 (0x00A8 - 0x00A8)
class UK34CheatComponent final : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K34CheatComponent">();
	}
	static class UK34CheatComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK34CheatComponent>();
	}
};
static_assert(alignof(UK34CheatComponent) == 0x000008, "Wrong alignment on UK34CheatComponent");
static_assert(sizeof(UK34CheatComponent) == 0x0000A8, "Wrong size on UK34CheatComponent");

// Class TheK34.K34DistractionGroundDetectorComponent
// 0x0008 (0x0270 - 0x0268)
class UK34DistractionGroundDetectorComponent final : public UBaseGroundDetectorComponent
{
public:
	float                                         _startPositionZOffSet;                             // 0x0268(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_26C[0x4];                                      // 0x026C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K34DistractionGroundDetectorComponent">();
	}
	static class UK34DistractionGroundDetectorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK34DistractionGroundDetectorComponent>();
	}
};
static_assert(alignof(UK34DistractionGroundDetectorComponent) == 0x000008, "Wrong alignment on UK34DistractionGroundDetectorComponent");
static_assert(sizeof(UK34DistractionGroundDetectorComponent) == 0x000270, "Wrong size on UK34DistractionGroundDetectorComponent");
static_assert(offsetof(UK34DistractionGroundDetectorComponent, _startPositionZOffSet) == 0x000268, "Member 'UK34DistractionGroundDetectorComponent::_startPositionZOffSet' has a wrong offset!");

// Class TheK34.K34DistractionNavMovementComponent
// 0x0090 (0x0218 - 0x0188)
class UK34DistractionNavMovementComponent final : public UActorNavMovementComponent
{
public:
	struct FAIMoveRequest                         _moveRequest;                                      // 0x0188(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TSubclassOf<class UNavigationQueryFilter>     _navFilter;                                        // 0x01D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _movementAcceptanceRadius;                         // 0x01E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1E4[0x4];                                      // 0x01E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _moveSpeed;                                        // 0x01E8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_210[0x8];                                      // 0x0210(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K34DistractionNavMovementComponent">();
	}
	static class UK34DistractionNavMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK34DistractionNavMovementComponent>();
	}
};
static_assert(alignof(UK34DistractionNavMovementComponent) == 0x000008, "Wrong alignment on UK34DistractionNavMovementComponent");
static_assert(sizeof(UK34DistractionNavMovementComponent) == 0x000218, "Wrong size on UK34DistractionNavMovementComponent");
static_assert(offsetof(UK34DistractionNavMovementComponent, _moveRequest) == 0x000188, "Member 'UK34DistractionNavMovementComponent::_moveRequest' has a wrong offset!");
static_assert(offsetof(UK34DistractionNavMovementComponent, _navFilter) == 0x0001D8, "Member 'UK34DistractionNavMovementComponent::_navFilter' has a wrong offset!");
static_assert(offsetof(UK34DistractionNavMovementComponent, _movementAcceptanceRadius) == 0x0001E0, "Member 'UK34DistractionNavMovementComponent::_movementAcceptanceRadius' has a wrong offset!");
static_assert(offsetof(UK34DistractionNavMovementComponent, _moveSpeed) == 0x0001E8, "Member 'UK34DistractionNavMovementComponent::_moveSpeed' has a wrong offset!");

// Class TheK34.K34Dodson
// 0x0040 (0x02E0 - 0x02A0)
class AK34Dodson final : public AActor
{
public:
	class USkeletalMeshComponent*                 _skeletalMesh;                                     // 0x02A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        _rootComponent;                                    // 0x02A8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimationMontageSlave*                 _animationMontageSlave;                            // 0x02B0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B8[0x28];                                     // 0x02B8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_OnEnterDodson();
	void Cosmetic_OnExitDodson();
	void OnLevelReadyToPlay();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K34Dodson">();
	}
	static class AK34Dodson* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK34Dodson>();
	}
};
static_assert(alignof(AK34Dodson) == 0x000008, "Wrong alignment on AK34Dodson");
static_assert(sizeof(AK34Dodson) == 0x0002E0, "Wrong size on AK34Dodson");
static_assert(offsetof(AK34Dodson, _skeletalMesh) == 0x0002A0, "Member 'AK34Dodson::_skeletalMesh' has a wrong offset!");
static_assert(offsetof(AK34Dodson, _rootComponent) == 0x0002A8, "Member 'AK34Dodson::_rootComponent' has a wrong offset!");
static_assert(offsetof(AK34Dodson, _animationMontageSlave) == 0x0002B0, "Member 'AK34Dodson::_animationMontageSlave' has a wrong offset!");

// Class TheK34.K34DodsonComponent
// 0x0088 (0x0130 - 0x00A8)
class UK34DodsonComponent final : public UActorComponent
{
public:
	TSubclassOf<class AK34Dodson>                 _dodsonActorClass;                                 // 0x00A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                _dodsonActorOffsetOnK34;                           // 0x00B0(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AK34Dodson*                             _dodsonActor;                                      // 0x00C8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D0[0x48];                                      // 0x00D0(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _isDodson;                                         // 0x0118(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_119[0x17];                                     // 0x0119(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsDodson();
	void OnRep_IsDodson();

	class AK34Dodson* GetDodsonActor() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K34DodsonComponent">();
	}
	static class UK34DodsonComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK34DodsonComponent>();
	}
};
static_assert(alignof(UK34DodsonComponent) == 0x000008, "Wrong alignment on UK34DodsonComponent");
static_assert(sizeof(UK34DodsonComponent) == 0x000130, "Wrong size on UK34DodsonComponent");
static_assert(offsetof(UK34DodsonComponent, _dodsonActorClass) == 0x0000A8, "Member 'UK34DodsonComponent::_dodsonActorClass' has a wrong offset!");
static_assert(offsetof(UK34DodsonComponent, _dodsonActorOffsetOnK34) == 0x0000B0, "Member 'UK34DodsonComponent::_dodsonActorOffsetOnK34' has a wrong offset!");
static_assert(offsetof(UK34DodsonComponent, _dodsonActor) == 0x0000C8, "Member 'UK34DodsonComponent::_dodsonActor' has a wrong offset!");
static_assert(offsetof(UK34DodsonComponent, _isDodson) == 0x000118, "Member 'UK34DodsonComponent::_isDodson' has a wrong offset!");

// Class TheK34.K34FirstPersonViewComponent
// 0x0000 (0x00F0 - 0x00F0)
class UK34FirstPersonViewComponent final : public UFirstPersonViewComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K34FirstPersonViewComponent">();
	}
	static class UK34FirstPersonViewComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK34FirstPersonViewComponent>();
	}
};
static_assert(alignof(UK34FirstPersonViewComponent) == 0x000008, "Wrong alignment on UK34FirstPersonViewComponent");
static_assert(sizeof(UK34FirstPersonViewComponent) == 0x0000F0, "Wrong size on UK34FirstPersonViewComponent");

// Class TheK34.K34Footstep
// 0x0190 (0x0430 - 0x02A0)
class AK34Footstep final : public AActor
{
public:
	uint8                                         Pad_2A0[0x8];                                      // 0x02A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	EK34Foot                                      _currentFootType;                                  // 0x02A8(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A9[0x7];                                      // 0x02A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTunableStat                           _footstepLifetime;                                 // 0x02B0(0x0080)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _footstepMaximumVisibilityDistance;                // 0x0330(0x0080)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_             OnAcquiredChanged;                                 // 0x03B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	bool                                          _isActive;                                         // 0x03C0(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3C1[0x47];                                     // 0x03C1(0x0047)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 _owningActor;                                      // 0x0408(0x0008)(Net, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ASlasherPlayer*                         _owningKiller;                                     // 0x0410(0x0008)(Net, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_418[0x8];                                      // 0x0418(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FK34FootstepVisibilityRaycastDefinition> _visibilityRaycastProperties;                      // 0x0420(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	void Cosmetic_TriggerFootstepVisibility(EK34Foot FootType, bool IsVisible);
	void OnRep_IsActive();

	struct FVector GetOwningActorsVelocity() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K34Footstep">();
	}
	static class AK34Footstep* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK34Footstep>();
	}
};
static_assert(alignof(AK34Footstep) == 0x000008, "Wrong alignment on AK34Footstep");
static_assert(sizeof(AK34Footstep) == 0x000430, "Wrong size on AK34Footstep");
static_assert(offsetof(AK34Footstep, _currentFootType) == 0x0002A8, "Member 'AK34Footstep::_currentFootType' has a wrong offset!");
static_assert(offsetof(AK34Footstep, _footstepLifetime) == 0x0002B0, "Member 'AK34Footstep::_footstepLifetime' has a wrong offset!");
static_assert(offsetof(AK34Footstep, _footstepMaximumVisibilityDistance) == 0x000330, "Member 'AK34Footstep::_footstepMaximumVisibilityDistance' has a wrong offset!");
static_assert(offsetof(AK34Footstep, OnAcquiredChanged) == 0x0003B0, "Member 'AK34Footstep::OnAcquiredChanged' has a wrong offset!");
static_assert(offsetof(AK34Footstep, _isActive) == 0x0003C0, "Member 'AK34Footstep::_isActive' has a wrong offset!");
static_assert(offsetof(AK34Footstep, _owningActor) == 0x000408, "Member 'AK34Footstep::_owningActor' has a wrong offset!");
static_assert(offsetof(AK34Footstep, _owningKiller) == 0x000410, "Member 'AK34Footstep::_owningKiller' has a wrong offset!");
static_assert(offsetof(AK34Footstep, _visibilityRaycastProperties) == 0x000420, "Member 'AK34Footstep::_visibilityRaycastProperties' has a wrong offset!");

// Class TheK34.K34FootstepsComponent
// 0x00A8 (0x0150 - 0x00A8)
class UK34FootstepsComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _footstepFrequency;                                // 0x00B0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _footstepsShouldOnlySpawnWhenMoving;               // 0x00D8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_100[0x1];                                      // 0x0100(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _showFootstepsInTipToeMode;                        // 0x0101(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_102[0x6];                                      // 0x0102(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagQuery                      _normalFootfallSpawningStateTagQuery;              // 0x0108(0x0048)(Edit, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K34FootstepsComponent">();
	}
	static class UK34FootstepsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK34FootstepsComponent>();
	}
};
static_assert(alignof(UK34FootstepsComponent) == 0x000008, "Wrong alignment on UK34FootstepsComponent");
static_assert(sizeof(UK34FootstepsComponent) == 0x000150, "Wrong size on UK34FootstepsComponent");
static_assert(offsetof(UK34FootstepsComponent, _footstepFrequency) == 0x0000B0, "Member 'UK34FootstepsComponent::_footstepFrequency' has a wrong offset!");
static_assert(offsetof(UK34FootstepsComponent, _footstepsShouldOnlySpawnWhenMoving) == 0x0000D8, "Member 'UK34FootstepsComponent::_footstepsShouldOnlySpawnWhenMoving' has a wrong offset!");
static_assert(offsetof(UK34FootstepsComponent, _showFootstepsInTipToeMode) == 0x000101, "Member 'UK34FootstepsComponent::_showFootstepsInTipToeMode' has a wrong offset!");
static_assert(offsetof(UK34FootstepsComponent, _normalFootfallSpawningStateTagQuery) == 0x000108, "Member 'UK34FootstepsComponent::_normalFootfallSpawningStateTagQuery' has a wrong offset!");

// Class TheK34.K34FXInterface
// 0x0000 (0x0030 - 0x0030)
class IK34FXInterface final : public IInterface
{
public:
	void Cosmetic_EndSliceAndDiceAttack();
	void Cosmetic_EnterSliceAndDice();
	void Cosmetic_EnterTipToeMode();
	void Cosmetic_ExitSliceAndDice();
	void Cosmetic_ExitTipToeMode();
	void Cosmetic_HideyHoModeDurationWarningTimeUp();
	void Cosmetic_OnEnterDodson();
	void Cosmetic_OnExitDodson();
	void Cosmetic_OnTipToeModeCooldownFinished();
	void Cosmetic_ScamperEnd(bool IsOnPallet, bool IsChaining);
	void Cosmetic_ScamperStart(bool IsOnPallet, bool IsChaining);
	void Cosmetic_StartSliceAndDiceAttack();
	void Cosmetic_UndetectableEnd();
	void Cosmetic_UndetectableStart();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K34FXInterface">();
	}
	static class IK34FXInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IK34FXInterface>();
	}
};
static_assert(alignof(IK34FXInterface) == 0x000008, "Wrong alignment on IK34FXInterface");
static_assert(sizeof(IK34FXInterface) == 0x000030, "Wrong size on IK34FXInterface");

// Class TheK34.K34KillerAttackSubAnimInstance
// 0x0030 (0x06F0 - 0x06C0)
class UK34KillerAttackSubAnimInstance final : public UKillerAttackSubAnimInstance
{
public:
	bool                                          _shouldTriggerSpecialAnimation;                    // 0x06B8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isDodson;                                         // 0x06B9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAttackSubstate                               _anticipatedAttackSubStateAfterHitting;            // 0x06BA(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6BB[0x5];                                      // 0x06BB(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                _targetWorldLocation;                              // 0x06C0(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _targetDistanceHorizontal;                         // 0x06D8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _percentOfJumpDistance;                            // 0x06DC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _maxJumpDistance;                                  // 0x06E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _specialAnimationTriggerChance;                    // 0x06E4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6E8[0x8];                                      // 0x06E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K34KillerAttackSubAnimInstance">();
	}
	static class UK34KillerAttackSubAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK34KillerAttackSubAnimInstance>();
	}
};
static_assert(alignof(UK34KillerAttackSubAnimInstance) == 0x000010, "Wrong alignment on UK34KillerAttackSubAnimInstance");
static_assert(sizeof(UK34KillerAttackSubAnimInstance) == 0x0006F0, "Wrong size on UK34KillerAttackSubAnimInstance");
static_assert(offsetof(UK34KillerAttackSubAnimInstance, _shouldTriggerSpecialAnimation) == 0x0006B8, "Member 'UK34KillerAttackSubAnimInstance::_shouldTriggerSpecialAnimation' has a wrong offset!");
static_assert(offsetof(UK34KillerAttackSubAnimInstance, _isDodson) == 0x0006B9, "Member 'UK34KillerAttackSubAnimInstance::_isDodson' has a wrong offset!");
static_assert(offsetof(UK34KillerAttackSubAnimInstance, _anticipatedAttackSubStateAfterHitting) == 0x0006BA, "Member 'UK34KillerAttackSubAnimInstance::_anticipatedAttackSubStateAfterHitting' has a wrong offset!");
static_assert(offsetof(UK34KillerAttackSubAnimInstance, _targetWorldLocation) == 0x0006C0, "Member 'UK34KillerAttackSubAnimInstance::_targetWorldLocation' has a wrong offset!");
static_assert(offsetof(UK34KillerAttackSubAnimInstance, _targetDistanceHorizontal) == 0x0006D8, "Member 'UK34KillerAttackSubAnimInstance::_targetDistanceHorizontal' has a wrong offset!");
static_assert(offsetof(UK34KillerAttackSubAnimInstance, _percentOfJumpDistance) == 0x0006DC, "Member 'UK34KillerAttackSubAnimInstance::_percentOfJumpDistance' has a wrong offset!");
static_assert(offsetof(UK34KillerAttackSubAnimInstance, _maxJumpDistance) == 0x0006E0, "Member 'UK34KillerAttackSubAnimInstance::_maxJumpDistance' has a wrong offset!");
static_assert(offsetof(UK34KillerAttackSubAnimInstance, _specialAnimationTriggerChance) == 0x0006E4, "Member 'UK34KillerAttackSubAnimInstance::_specialAnimationTriggerChance' has a wrong offset!");

// Class TheK34.K34P01
// 0x0038 (0x04D8 - 0x04A0)
class UK34P01 final : public UHexPerk
{
public:
	uint8                                         Pad_4A0[0x18];                                     // 0x04A0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UStatusEffect>              _rampingBlindEffectClass;                          // 0x04B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _rampingBlindRampTime;                             // 0x04C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         _stunnedOrBlindedTimesRequired[0x3];               // 0x04C4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _blindedEffectTime;                                // 0x04D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4D4[0x4];                                      // 0x04D4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnTotemStateChanged(const ETotemState OldState, const ETotemState NewState);
	void Client_UpdateHudIcon(float Percent);

	float GetBlindedEffectTime() const;
	int32 GetStunnedOrBlindedCount() const;
	int32 GetStunnedOrBlindedTimesRequiredByLevel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K34P01">();
	}
	static class UK34P01* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK34P01>();
	}
};
static_assert(alignof(UK34P01) == 0x000008, "Wrong alignment on UK34P01");
static_assert(sizeof(UK34P01) == 0x0004D8, "Wrong size on UK34P01");
static_assert(offsetof(UK34P01, _rampingBlindEffectClass) == 0x0004B8, "Member 'UK34P01::_rampingBlindEffectClass' has a wrong offset!");
static_assert(offsetof(UK34P01, _rampingBlindRampTime) == 0x0004C0, "Member 'UK34P01::_rampingBlindRampTime' has a wrong offset!");
static_assert(offsetof(UK34P01, _stunnedOrBlindedTimesRequired) == 0x0004C4, "Member 'UK34P01::_stunnedOrBlindedTimesRequired' has a wrong offset!");
static_assert(offsetof(UK34P01, _blindedEffectTime) == 0x0004D0, "Member 'UK34P01::_blindedEffectTime' has a wrong offset!");

// Class TheK34.K34P02
// 0x0040 (0x0460 - 0x0420)
class UK34P02 final : public UPerk
{
public:
	TSubclassOf<class UStatusEffect>              _exposedStatusEffectClass;                         // 0x0420(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStatusEffect*                          _exposedStatusEffect;                              // 0x0428(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _survivorAuraRevealClass;                          // 0x0430(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStatusEffect*                          _survivorAuraRevealEffect;                         // 0x0438(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _exposedEffectTime[0x3];                           // 0x0440(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _auraRevealEffectTime[0x3];                        // 0x044C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_458[0x8];                                      // 0x0458(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_RevealAndMakeSurvivorScream(class ACamperPlayer* SurvivorPlayer);
	void Multicast_RevealAndMakeSurvivorScream(class ACamperPlayer* Survivor);

	float GetAuraRevealEffectTimeAtLevel() const;
	float GetExposedEffectTimeAtLevel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K34P02">();
	}
	static class UK34P02* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK34P02>();
	}
};
static_assert(alignof(UK34P02) == 0x000008, "Wrong alignment on UK34P02");
static_assert(sizeof(UK34P02) == 0x000460, "Wrong size on UK34P02");
static_assert(offsetof(UK34P02, _exposedStatusEffectClass) == 0x000420, "Member 'UK34P02::_exposedStatusEffectClass' has a wrong offset!");
static_assert(offsetof(UK34P02, _exposedStatusEffect) == 0x000428, "Member 'UK34P02::_exposedStatusEffect' has a wrong offset!");
static_assert(offsetof(UK34P02, _survivorAuraRevealClass) == 0x000430, "Member 'UK34P02::_survivorAuraRevealClass' has a wrong offset!");
static_assert(offsetof(UK34P02, _survivorAuraRevealEffect) == 0x000438, "Member 'UK34P02::_survivorAuraRevealEffect' has a wrong offset!");
static_assert(offsetof(UK34P02, _exposedEffectTime) == 0x000440, "Member 'UK34P02::_exposedEffectTime' has a wrong offset!");
static_assert(offsetof(UK34P02, _auraRevealEffectTime) == 0x00044C, "Member 'UK34P02::_auraRevealEffectTime' has a wrong offset!");

// Class TheK34.K34P03
// 0x0050 (0x0470 - 0x0420)
class UK34P03 final : public UPerk
{
public:
	float                                         _generatorRangeFromPlayer;                         // 0x0420(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_424[0x24];                                     // 0x0424(0x0024)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _hasAnyGeneratorsInRange;                          // 0x0448(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_449[0x7];                                      // 0x0449(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UStatusEffect>              _hasteEffectClass;                                 // 0x0450(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStatusEffect*                          _hasteEffect;                                      // 0x0458(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _hasteEffectAmount;                                // 0x0460(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _hasteLingerTimes[0x3];                            // 0x0464(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	float GetGeneratorRangeFromPlayer() const;
	float GetHasteEffectAmount() const;
	float GetHasteLingerTimeAtLevel() const;
	bool HasAnyGeneratorsInRange() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K34P03">();
	}
	static class UK34P03* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK34P03>();
	}
};
static_assert(alignof(UK34P03) == 0x000008, "Wrong alignment on UK34P03");
static_assert(sizeof(UK34P03) == 0x000470, "Wrong size on UK34P03");
static_assert(offsetof(UK34P03, _generatorRangeFromPlayer) == 0x000420, "Member 'UK34P03::_generatorRangeFromPlayer' has a wrong offset!");
static_assert(offsetof(UK34P03, _hasAnyGeneratorsInRange) == 0x000448, "Member 'UK34P03::_hasAnyGeneratorsInRange' has a wrong offset!");
static_assert(offsetof(UK34P03, _hasteEffectClass) == 0x000450, "Member 'UK34P03::_hasteEffectClass' has a wrong offset!");
static_assert(offsetof(UK34P03, _hasteEffect) == 0x000458, "Member 'UK34P03::_hasteEffect' has a wrong offset!");
static_assert(offsetof(UK34P03, _hasteEffectAmount) == 0x000460, "Member 'UK34P03::_hasteEffectAmount' has a wrong offset!");
static_assert(offsetof(UK34P03, _hasteLingerTimes) == 0x000464, "Member 'UK34P03::_hasteLingerTimes' has a wrong offset!");

// Class TheK34.K34P03IconStrategy
// 0x0000 (0x0038 - 0x0038)
class UK34P03IconStrategy final : public UBasePerkIconStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K34P03IconStrategy">();
	}
	static class UK34P03IconStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK34P03IconStrategy>();
	}
};
static_assert(alignof(UK34P03IconStrategy) == 0x000008, "Wrong alignment on UK34P03IconStrategy");
static_assert(sizeof(UK34P03IconStrategy) == 0x000038, "Wrong size on UK34P03IconStrategy");

// Class TheK34.K34PerspectiveChangeComponent
// 0x0068 (0x0188 - 0x0120)
class UK34PerspectiveChangeComponent final : public UPlayerPerspectiveChangeComponent
{
public:
	struct FPlayerPerspectiveChangeTargetData     _firstPersonYerkesPerspectiveChangeTargetData;     // 0x0120(0x0020)(Edit, DisableEditOnInstance, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FPlayerPerspectiveChangeTargetData     _firstPersonDodsonPerspectiveChangeTargetData;     // 0x0140(0x0020)(Edit, DisableEditOnInstance, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FPlayerPerspectiveChangeTargetData     _thirdPersonYerkesPerspectiveChangeTargetData;     // 0x0160(0x0020)(Edit, DisableEditOnInstance, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	float                                         _dodsonThirdPersonViewTransitionTime;              // 0x0180(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_184[0x4];                                      // 0x0184(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K34PerspectiveChangeComponent">();
	}
	static class UK34PerspectiveChangeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK34PerspectiveChangeComponent>();
	}
};
static_assert(alignof(UK34PerspectiveChangeComponent) == 0x000008, "Wrong alignment on UK34PerspectiveChangeComponent");
static_assert(sizeof(UK34PerspectiveChangeComponent) == 0x000188, "Wrong size on UK34PerspectiveChangeComponent");
static_assert(offsetof(UK34PerspectiveChangeComponent, _firstPersonYerkesPerspectiveChangeTargetData) == 0x000120, "Member 'UK34PerspectiveChangeComponent::_firstPersonYerkesPerspectiveChangeTargetData' has a wrong offset!");
static_assert(offsetof(UK34PerspectiveChangeComponent, _firstPersonDodsonPerspectiveChangeTargetData) == 0x000140, "Member 'UK34PerspectiveChangeComponent::_firstPersonDodsonPerspectiveChangeTargetData' has a wrong offset!");
static_assert(offsetof(UK34PerspectiveChangeComponent, _thirdPersonYerkesPerspectiveChangeTargetData) == 0x000160, "Member 'UK34PerspectiveChangeComponent::_thirdPersonYerkesPerspectiveChangeTargetData' has a wrong offset!");
static_assert(offsetof(UK34PerspectiveChangeComponent, _dodsonThirdPersonViewTransitionTime) == 0x000180, "Member 'UK34PerspectiveChangeComponent::_dodsonThirdPersonViewTransitionTime' has a wrong offset!");

// Class TheK34.K34PounceAttack
// 0x0040 (0x0460 - 0x0420)
class UK34PounceAttack final : public UPounceAttack
{
public:
	uint8                                         Pad_420[0x20];                                     // 0x0420(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _sphereTraceRadiusObstruction;                     // 0x0440(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _maxSphereTraceDistanceObstruction;                // 0x0444(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _sphereTraceRadiusMidairLeap;                      // 0x0448(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _sphereTraceStartForwardOffsetMidairLeap;          // 0x044C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _sphereTraceEndForwardOffsetMidairLeap;            // 0x0450(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _sphereTraceVerticalOffsetMidairLeap;              // 0x0454(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_458[0x8];                                      // 0x0458(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K34PounceAttack">();
	}
	static class UK34PounceAttack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK34PounceAttack>();
	}
};
static_assert(alignof(UK34PounceAttack) == 0x000010, "Wrong alignment on UK34PounceAttack");
static_assert(sizeof(UK34PounceAttack) == 0x000460, "Wrong size on UK34PounceAttack");
static_assert(offsetof(UK34PounceAttack, _sphereTraceRadiusObstruction) == 0x000440, "Member 'UK34PounceAttack::_sphereTraceRadiusObstruction' has a wrong offset!");
static_assert(offsetof(UK34PounceAttack, _maxSphereTraceDistanceObstruction) == 0x000444, "Member 'UK34PounceAttack::_maxSphereTraceDistanceObstruction' has a wrong offset!");
static_assert(offsetof(UK34PounceAttack, _sphereTraceRadiusMidairLeap) == 0x000448, "Member 'UK34PounceAttack::_sphereTraceRadiusMidairLeap' has a wrong offset!");
static_assert(offsetof(UK34PounceAttack, _sphereTraceStartForwardOffsetMidairLeap) == 0x00044C, "Member 'UK34PounceAttack::_sphereTraceStartForwardOffsetMidairLeap' has a wrong offset!");
static_assert(offsetof(UK34PounceAttack, _sphereTraceEndForwardOffsetMidairLeap) == 0x000450, "Member 'UK34PounceAttack::_sphereTraceEndForwardOffsetMidairLeap' has a wrong offset!");
static_assert(offsetof(UK34PounceAttack, _sphereTraceVerticalOffsetMidairLeap) == 0x000454, "Member 'UK34PounceAttack::_sphereTraceVerticalOffsetMidairLeap' has a wrong offset!");

// Class TheK34.K34PounceAttackOpenSubstate
// 0x0000 (0x0130 - 0x0130)
class UK34PounceAttackOpenSubstate final : public UPounceAttackOpenSubstate
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K34PounceAttackOpenSubstate">();
	}
	static class UK34PounceAttackOpenSubstate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK34PounceAttackOpenSubstate>();
	}
};
static_assert(alignof(UK34PounceAttackOpenSubstate) == 0x000008, "Wrong alignment on UK34PounceAttackOpenSubstate");
static_assert(sizeof(UK34PounceAttackOpenSubstate) == 0x000130, "Wrong size on UK34PounceAttackOpenSubstate");

// Class TheK34.K34PounceAttackHittingSubstate
// 0x0000 (0x01A0 - 0x01A0)
class UK34PounceAttackHittingSubstate final : public UPounceAttackHittingSubstate
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K34PounceAttackHittingSubstate">();
	}
	static class UK34PounceAttackHittingSubstate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK34PounceAttackHittingSubstate>();
	}
};
static_assert(alignof(UK34PounceAttackHittingSubstate) == 0x000008, "Wrong alignment on UK34PounceAttackHittingSubstate");
static_assert(sizeof(UK34PounceAttackHittingSubstate) == 0x0001A0, "Wrong size on UK34PounceAttackHittingSubstate");

// Class TheK34.K34AttackSuccessSubstate
// 0x0000 (0x0118 - 0x0118)
class UK34AttackSuccessSubstate final : public UPounceAttackSuccessSubstate
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K34AttackSuccessSubstate">();
	}
	static class UK34AttackSuccessSubstate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK34AttackSuccessSubstate>();
	}
};
static_assert(alignof(UK34AttackSuccessSubstate) == 0x000008, "Wrong alignment on UK34AttackSuccessSubstate");
static_assert(sizeof(UK34AttackSuccessSubstate) == 0x000118, "Wrong size on UK34AttackSuccessSubstate");

// Class TheK34.K34AttackMissSubstate
// 0x0000 (0x0120 - 0x0120)
class UK34AttackMissSubstate final : public UPounceAttackMissSubstate
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K34AttackMissSubstate">();
	}
	static class UK34AttackMissSubstate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK34AttackMissSubstate>();
	}
};
static_assert(alignof(UK34AttackMissSubstate) == 0x000008, "Wrong alignment on UK34AttackMissSubstate");
static_assert(sizeof(UK34AttackMissSubstate) == 0x000120, "Wrong size on UK34AttackMissSubstate");

// Class TheK34.K34AttackObstructSubstate
// 0x0000 (0x0128 - 0x0128)
class UK34AttackObstructSubstate final : public UPounceAttackObstructSubstate
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K34AttackObstructSubstate">();
	}
	static class UK34AttackObstructSubstate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK34AttackObstructSubstate>();
	}
};
static_assert(alignof(UK34AttackObstructSubstate) == 0x000008, "Wrong alignment on UK34AttackObstructSubstate");
static_assert(sizeof(UK34AttackObstructSubstate) == 0x000128, "Wrong size on UK34AttackObstructSubstate");

// Class TheK34.K34Power
// 0x0078 (0x05C8 - 0x0550)
class AK34Power final : public ACollectable
{
public:
	TSubclassOf<class UK34TipToeModeComponent>    _tipToeModeComponentClassToSpawn;                  // 0x0550(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UK34FootstepsComponent>     _footstepsComponentClassToSpawn;                   // 0x0558(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UK34DodsonComponent>        _dodsonComponentClassToSpawn;                      // 0x0560(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UK34PerspectiveChangeComponent> _k34PerspectiveChangeComponentClass;               // 0x0568(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UK34ScoringComponent>       _k34ScoringComponentClass;                         // 0x0570(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAuthoritativeActorPoolComponent*       _feetActorPool;                                    // 0x0578(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoClear, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UK34PowerChargePresentationPowerFadeComponent* _presentationPowerFadeComponent;                   // 0x0580(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UK34PowerChargePresentationItemProgressComponent* _presentationItemProgressComponent;                // 0x0588(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTurnLimitationStrategy*                _viewRotationStrategy;                             // 0x0590(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_598[0x30];                                     // 0x0598(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class ASlasherPlayer* GetOwningKiller() const;
	void OnFootstepAddedToPool(class AActor* Actor) const;
	void OnKillerIntroCompleted() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K34Power">();
	}
	static class AK34Power* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK34Power>();
	}
};
static_assert(alignof(AK34Power) == 0x000008, "Wrong alignment on AK34Power");
static_assert(sizeof(AK34Power) == 0x0005C8, "Wrong size on AK34Power");
static_assert(offsetof(AK34Power, _tipToeModeComponentClassToSpawn) == 0x000550, "Member 'AK34Power::_tipToeModeComponentClassToSpawn' has a wrong offset!");
static_assert(offsetof(AK34Power, _footstepsComponentClassToSpawn) == 0x000558, "Member 'AK34Power::_footstepsComponentClassToSpawn' has a wrong offset!");
static_assert(offsetof(AK34Power, _dodsonComponentClassToSpawn) == 0x000560, "Member 'AK34Power::_dodsonComponentClassToSpawn' has a wrong offset!");
static_assert(offsetof(AK34Power, _k34PerspectiveChangeComponentClass) == 0x000568, "Member 'AK34Power::_k34PerspectiveChangeComponentClass' has a wrong offset!");
static_assert(offsetof(AK34Power, _k34ScoringComponentClass) == 0x000570, "Member 'AK34Power::_k34ScoringComponentClass' has a wrong offset!");
static_assert(offsetof(AK34Power, _feetActorPool) == 0x000578, "Member 'AK34Power::_feetActorPool' has a wrong offset!");
static_assert(offsetof(AK34Power, _presentationPowerFadeComponent) == 0x000580, "Member 'AK34Power::_presentationPowerFadeComponent' has a wrong offset!");
static_assert(offsetof(AK34Power, _presentationItemProgressComponent) == 0x000588, "Member 'AK34Power::_presentationItemProgressComponent' has a wrong offset!");
static_assert(offsetof(AK34Power, _viewRotationStrategy) == 0x000590, "Member 'AK34Power::_viewRotationStrategy' has a wrong offset!");

// Class TheK34.K34PowerAnimInstance
// 0x0070 (0x03F0 - 0x0380)
class UK34PowerAnimInstance final : public UDBDBaseAnimInstance
{
public:
	bool                                          _isInTipToeMode;                                   // 0x0380(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isChargingScamper;                                // 0x0381(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isScampering;                                     // 0x0382(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isChainScampering;                                // 0x0383(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _forwardVelocity;                                  // 0x0384(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _lateralVelocity;                                  // 0x0388(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAttackSubstate                               _attackState;                                      // 0x038C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _shouldTriggerLookBackAnimation;                   // 0x038D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_38E[0x4A];                                     // 0x038E(0x004A)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _minTimeToStartLookBackAnimation;                  // 0x03D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _maxTimeToStartLookBackAnimation;                  // 0x03DC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3E0[0x10];                                     // 0x03E0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K34PowerAnimInstance">();
	}
	static class UK34PowerAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK34PowerAnimInstance>();
	}
};
static_assert(alignof(UK34PowerAnimInstance) == 0x000010, "Wrong alignment on UK34PowerAnimInstance");
static_assert(sizeof(UK34PowerAnimInstance) == 0x0003F0, "Wrong size on UK34PowerAnimInstance");
static_assert(offsetof(UK34PowerAnimInstance, _isInTipToeMode) == 0x000380, "Member 'UK34PowerAnimInstance::_isInTipToeMode' has a wrong offset!");
static_assert(offsetof(UK34PowerAnimInstance, _isChargingScamper) == 0x000381, "Member 'UK34PowerAnimInstance::_isChargingScamper' has a wrong offset!");
static_assert(offsetof(UK34PowerAnimInstance, _isScampering) == 0x000382, "Member 'UK34PowerAnimInstance::_isScampering' has a wrong offset!");
static_assert(offsetof(UK34PowerAnimInstance, _isChainScampering) == 0x000383, "Member 'UK34PowerAnimInstance::_isChainScampering' has a wrong offset!");
static_assert(offsetof(UK34PowerAnimInstance, _forwardVelocity) == 0x000384, "Member 'UK34PowerAnimInstance::_forwardVelocity' has a wrong offset!");
static_assert(offsetof(UK34PowerAnimInstance, _lateralVelocity) == 0x000388, "Member 'UK34PowerAnimInstance::_lateralVelocity' has a wrong offset!");
static_assert(offsetof(UK34PowerAnimInstance, _attackState) == 0x00038C, "Member 'UK34PowerAnimInstance::_attackState' has a wrong offset!");
static_assert(offsetof(UK34PowerAnimInstance, _shouldTriggerLookBackAnimation) == 0x00038D, "Member 'UK34PowerAnimInstance::_shouldTriggerLookBackAnimation' has a wrong offset!");
static_assert(offsetof(UK34PowerAnimInstance, _minTimeToStartLookBackAnimation) == 0x0003D8, "Member 'UK34PowerAnimInstance::_minTimeToStartLookBackAnimation' has a wrong offset!");
static_assert(offsetof(UK34PowerAnimInstance, _maxTimeToStartLookBackAnimation) == 0x0003DC, "Member 'UK34PowerAnimInstance::_maxTimeToStartLookBackAnimation' has a wrong offset!");

// Class TheK34.K34PowerChargePresentationItemProgressComponent
// 0x0018 (0x00C8 - 0x00B0)
class UK34PowerChargePresentationItemProgressComponent final : public UPresentationItemProgressComponent
{
public:
	uint8                                         Pad_B0[0x18];                                      // 0x00B0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K34PowerChargePresentationItemProgressComponent">();
	}
	static class UK34PowerChargePresentationItemProgressComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK34PowerChargePresentationItemProgressComponent>();
	}
};
static_assert(alignof(UK34PowerChargePresentationItemProgressComponent) == 0x000008, "Wrong alignment on UK34PowerChargePresentationItemProgressComponent");
static_assert(sizeof(UK34PowerChargePresentationItemProgressComponent) == 0x0000C8, "Wrong size on UK34PowerChargePresentationItemProgressComponent");

// Class TheK34.K34PowerChargePresentationPowerFadeComponent
// 0x0018 (0x00C0 - 0x00A8)
class UK34PowerChargePresentationPowerFadeComponent final : public UPresentationPowerFadeComponent
{
public:
	uint8                                         Pad_A8[0x18];                                      // 0x00A8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K34PowerChargePresentationPowerFadeComponent">();
	}
	static class UK34PowerChargePresentationPowerFadeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK34PowerChargePresentationPowerFadeComponent>();
	}
};
static_assert(alignof(UK34PowerChargePresentationPowerFadeComponent) == 0x000008, "Wrong alignment on UK34PowerChargePresentationPowerFadeComponent");
static_assert(sizeof(UK34PowerChargePresentationPowerFadeComponent) == 0x0000C0, "Wrong size on UK34PowerChargePresentationPowerFadeComponent");

// Class TheK34.K34ScamperChargeableInteraction
// 0x0280 (0x0B40 - 0x08C0)
class UK34ScamperChargeableInteraction final : public UChargeableInteractionDefinition
{
public:
	EScamperPhase                                 _currentPhase;                                     // 0x08C0(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8C1[0x1DF];                                    // 0x08C1(0x01DF)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EScamperPhase, struct FK34ScamperMovementSpeedSetting> _scamperMovementSpeedSettings;                     // 0x0AA0(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	float                                         _chainVaultDetectionRange;                         // 0x0AF0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_AF4[0x4];                                      // 0x0AF4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _chainingHeldInputBuffer;                          // 0x0AF8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	float                                         _chainVaultSweepRadius;                            // 0x0B20(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _cameraTransitionToThirdPersonViewDuration;        // 0x0B24(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B28[0x8];                                      // 0x0B28(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _availabilityGracePeriodAfterScamper;              // 0x0B30(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _cancelCooldownTime;                               // 0x0B34(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B38[0x8];                                      // 0x0B38(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_BeginChargingPhase();
	void Cosmetic_EndChargingPhase();
	void OnDashingTimeoutTimerDone();
	void OnRep_CurrentPhase();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K34ScamperChargeableInteraction">();
	}
	static class UK34ScamperChargeableInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK34ScamperChargeableInteraction>();
	}
};
static_assert(alignof(UK34ScamperChargeableInteraction) == 0x000010, "Wrong alignment on UK34ScamperChargeableInteraction");
static_assert(sizeof(UK34ScamperChargeableInteraction) == 0x000B40, "Wrong size on UK34ScamperChargeableInteraction");
static_assert(offsetof(UK34ScamperChargeableInteraction, _currentPhase) == 0x0008C0, "Member 'UK34ScamperChargeableInteraction::_currentPhase' has a wrong offset!");
static_assert(offsetof(UK34ScamperChargeableInteraction, _scamperMovementSpeedSettings) == 0x000AA0, "Member 'UK34ScamperChargeableInteraction::_scamperMovementSpeedSettings' has a wrong offset!");
static_assert(offsetof(UK34ScamperChargeableInteraction, _chainVaultDetectionRange) == 0x000AF0, "Member 'UK34ScamperChargeableInteraction::_chainVaultDetectionRange' has a wrong offset!");
static_assert(offsetof(UK34ScamperChargeableInteraction, _chainingHeldInputBuffer) == 0x000AF8, "Member 'UK34ScamperChargeableInteraction::_chainingHeldInputBuffer' has a wrong offset!");
static_assert(offsetof(UK34ScamperChargeableInteraction, _chainVaultSweepRadius) == 0x000B20, "Member 'UK34ScamperChargeableInteraction::_chainVaultSweepRadius' has a wrong offset!");
static_assert(offsetof(UK34ScamperChargeableInteraction, _cameraTransitionToThirdPersonViewDuration) == 0x000B24, "Member 'UK34ScamperChargeableInteraction::_cameraTransitionToThirdPersonViewDuration' has a wrong offset!");
static_assert(offsetof(UK34ScamperChargeableInteraction, _availabilityGracePeriodAfterScamper) == 0x000B30, "Member 'UK34ScamperChargeableInteraction::_availabilityGracePeriodAfterScamper' has a wrong offset!");
static_assert(offsetof(UK34ScamperChargeableInteraction, _cancelCooldownTime) == 0x000B34, "Member 'UK34ScamperChargeableInteraction::_cancelCooldownTime' has a wrong offset!");

// Class TheK34.K34ScoringComponent
// 0x0068 (0x0110 - 0x00A8)
class UK34ScoringComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x40];                                      // 0x00A8(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _windowToFollowUpAScamperWithAHitTunableValue;     // 0x00E8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K34ScoringComponent">();
	}
	static class UK34ScoringComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK34ScoringComponent>();
	}
};
static_assert(alignof(UK34ScoringComponent) == 0x000008, "Wrong alignment on UK34ScoringComponent");
static_assert(sizeof(UK34ScoringComponent) == 0x000110, "Wrong size on UK34ScoringComponent");
static_assert(offsetof(UK34ScoringComponent, _windowToFollowUpAScamperWithAHitTunableValue) == 0x0000E8, "Member 'UK34ScoringComponent::_windowToFollowUpAScamperWithAHitTunableValue' has a wrong offset!");

// Class TheK34.K34SliceAndDiceAttack
// 0x0130 (0x0550 - 0x0420)
class UK34SliceAndDiceAttack final : public UPounceAttack
{
public:
	struct FDBDTunableRowHandle                   _attackZoneScaleFactor;                            // 0x0420(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _mouseMaxTurnAngleCurve;                           // 0x0448(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _controllerMaxTurnAngleCurve;                      // 0x0450(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _turnRateLimit;                                    // 0x0458(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	float                                         _endChaseAfterHitBuffer;                           // 0x0480(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_484[0xCC];                                     // 0x0484(0x00CC)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K34SliceAndDiceAttack">();
	}
	static class UK34SliceAndDiceAttack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK34SliceAndDiceAttack>();
	}
};
static_assert(alignof(UK34SliceAndDiceAttack) == 0x000010, "Wrong alignment on UK34SliceAndDiceAttack");
static_assert(sizeof(UK34SliceAndDiceAttack) == 0x000550, "Wrong size on UK34SliceAndDiceAttack");
static_assert(offsetof(UK34SliceAndDiceAttack, _attackZoneScaleFactor) == 0x000420, "Member 'UK34SliceAndDiceAttack::_attackZoneScaleFactor' has a wrong offset!");
static_assert(offsetof(UK34SliceAndDiceAttack, _mouseMaxTurnAngleCurve) == 0x000448, "Member 'UK34SliceAndDiceAttack::_mouseMaxTurnAngleCurve' has a wrong offset!");
static_assert(offsetof(UK34SliceAndDiceAttack, _controllerMaxTurnAngleCurve) == 0x000450, "Member 'UK34SliceAndDiceAttack::_controllerMaxTurnAngleCurve' has a wrong offset!");
static_assert(offsetof(UK34SliceAndDiceAttack, _turnRateLimit) == 0x000458, "Member 'UK34SliceAndDiceAttack::_turnRateLimit' has a wrong offset!");
static_assert(offsetof(UK34SliceAndDiceAttack, _endChaseAfterHitBuffer) == 0x000480, "Member 'UK34SliceAndDiceAttack::_endChaseAfterHitBuffer' has a wrong offset!");

// Class TheK34.K34SliceAndDiceAttackOpenSubstate
// 0x0000 (0x0130 - 0x0130)
class UK34SliceAndDiceAttackOpenSubstate final : public UPounceAttackOpenSubstate
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K34SliceAndDiceAttackOpenSubstate">();
	}
	static class UK34SliceAndDiceAttackOpenSubstate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK34SliceAndDiceAttackOpenSubstate>();
	}
};
static_assert(alignof(UK34SliceAndDiceAttackOpenSubstate) == 0x000008, "Wrong alignment on UK34SliceAndDiceAttackOpenSubstate");
static_assert(sizeof(UK34SliceAndDiceAttackOpenSubstate) == 0x000130, "Wrong size on UK34SliceAndDiceAttackOpenSubstate");

// Class TheK34.K34SliceAndDiceAttackSuccessSubstate
// 0x0000 (0x0118 - 0x0118)
class UK34SliceAndDiceAttackSuccessSubstate final : public UPounceAttackSuccessSubstate
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K34SliceAndDiceAttackSuccessSubstate">();
	}
	static class UK34SliceAndDiceAttackSuccessSubstate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK34SliceAndDiceAttackSuccessSubstate>();
	}
};
static_assert(alignof(UK34SliceAndDiceAttackSuccessSubstate) == 0x000008, "Wrong alignment on UK34SliceAndDiceAttackSuccessSubstate");
static_assert(sizeof(UK34SliceAndDiceAttackSuccessSubstate) == 0x000118, "Wrong size on UK34SliceAndDiceAttackSuccessSubstate");

// Class TheK34.K34SliceAndDiceAttackMissSubstate
// 0x0000 (0x0120 - 0x0120)
class UK34SliceAndDiceAttackMissSubstate final : public UPounceAttackMissSubstate
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K34SliceAndDiceAttackMissSubstate">();
	}
	static class UK34SliceAndDiceAttackMissSubstate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK34SliceAndDiceAttackMissSubstate>();
	}
};
static_assert(alignof(UK34SliceAndDiceAttackMissSubstate) == 0x000008, "Wrong alignment on UK34SliceAndDiceAttackMissSubstate");
static_assert(sizeof(UK34SliceAndDiceAttackMissSubstate) == 0x000120, "Wrong size on UK34SliceAndDiceAttackMissSubstate");

// Class TheK34.K34SliceAndDiceAttackObstructSubstate
// 0x0000 (0x0128 - 0x0128)
class UK34SliceAndDiceAttackObstructSubstate final : public UPounceAttackObstructSubstate
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K34SliceAndDiceAttackObstructSubstate">();
	}
	static class UK34SliceAndDiceAttackObstructSubstate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK34SliceAndDiceAttackObstructSubstate>();
	}
};
static_assert(alignof(UK34SliceAndDiceAttackObstructSubstate) == 0x000008, "Wrong alignment on UK34SliceAndDiceAttackObstructSubstate");
static_assert(sizeof(UK34SliceAndDiceAttackObstructSubstate) == 0x000128, "Wrong size on UK34SliceAndDiceAttackObstructSubstate");

// Class TheK34.K34SurvivorCosmeticHelperActor
// 0x0000 (0x0308 - 0x0308)
class AK34SurvivorCosmeticHelperActor final : public ASurvivorCosmeticHelperActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K34SurvivorCosmeticHelperActor">();
	}
	static class AK34SurvivorCosmeticHelperActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK34SurvivorCosmeticHelperActor>();
	}
};
static_assert(alignof(AK34SurvivorCosmeticHelperActor) == 0x000008, "Wrong alignment on AK34SurvivorCosmeticHelperActor");
static_assert(sizeof(AK34SurvivorCosmeticHelperActor) == 0x000308, "Wrong size on AK34SurvivorCosmeticHelperActor");

// Class TheK34.K34TipToeDistraction
// 0x0328 (0x05C8 - 0x02A0)
class AK34TipToeDistraction : public AActor
{
public:
	uint8                                         Pad_2A0[0x10];                                     // 0x02A0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             _onAcquiredChanged;                                // 0x02B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _maximumVisibilityDistance;                        // 0x02C0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _footStepSpawnRate;                                // 0x02E8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _chanceToRandomlyTurnBackOnPath;                   // 0x0310(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _chanceToRandomlyChangeDirection;                  // 0x0338(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _chanceToRandomlyStop;                             // 0x0360(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _newTargetRadius;                                  // 0x0388(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	float                                         _minTimeIdle;                                      // 0x03B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3B4[0x4];                                      // 0x03B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _maxTimeIdle;                                      // 0x03B8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	int8                                          _maxCountSameLocationConsideredStuck;              // 0x03E0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3E1[0x3];                                      // 0x03E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _distanceConsideredStuck;                          // 0x03E4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _randomBehaviourCheckRate;                         // 0x03E8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _overlapRadius;                                    // 0x03EC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _cosmeticFootSpawnRate;                            // 0x03F0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isAcquiredFromPool;                               // 0x03F4(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isInUse;                                          // 0x03F5(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3F6[0x1BA];                                    // 0x03F6(0x01BA)(Fixing Size After Last Property [ Dumper-7 ])
	class UK34DistractionNavMovementComponent*    _navMovementComponent;                             // 0x05B0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBaseGroundDetectorComponent*           _groundDetector;                                   // 0x05B8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkComponent*                           _akComponent;                                      // 0x05C0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Cosmetic_OnFootHitGround();
	class ADBDPlayer* GetOwningPlayer();
	void Multicast_OnDeactivated();
	void Multicast_OnSpawned(class ADBDPlayer* OwningPlayer);
	void Multicast_ShowDistractionDebug(const float HalfSize, const float Radius);

	class UAkComponent* GetAkComponent() const;
	class UCustomizedAudioComponent* GetCustomizedAudio() const;
	class FString GetFootAudioSurfaceName() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K34TipToeDistraction">();
	}
	static class AK34TipToeDistraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK34TipToeDistraction>();
	}
};
static_assert(alignof(AK34TipToeDistraction) == 0x000008, "Wrong alignment on AK34TipToeDistraction");
static_assert(sizeof(AK34TipToeDistraction) == 0x0005C8, "Wrong size on AK34TipToeDistraction");
static_assert(offsetof(AK34TipToeDistraction, _onAcquiredChanged) == 0x0002B0, "Member 'AK34TipToeDistraction::_onAcquiredChanged' has a wrong offset!");
static_assert(offsetof(AK34TipToeDistraction, _maximumVisibilityDistance) == 0x0002C0, "Member 'AK34TipToeDistraction::_maximumVisibilityDistance' has a wrong offset!");
static_assert(offsetof(AK34TipToeDistraction, _footStepSpawnRate) == 0x0002E8, "Member 'AK34TipToeDistraction::_footStepSpawnRate' has a wrong offset!");
static_assert(offsetof(AK34TipToeDistraction, _chanceToRandomlyTurnBackOnPath) == 0x000310, "Member 'AK34TipToeDistraction::_chanceToRandomlyTurnBackOnPath' has a wrong offset!");
static_assert(offsetof(AK34TipToeDistraction, _chanceToRandomlyChangeDirection) == 0x000338, "Member 'AK34TipToeDistraction::_chanceToRandomlyChangeDirection' has a wrong offset!");
static_assert(offsetof(AK34TipToeDistraction, _chanceToRandomlyStop) == 0x000360, "Member 'AK34TipToeDistraction::_chanceToRandomlyStop' has a wrong offset!");
static_assert(offsetof(AK34TipToeDistraction, _newTargetRadius) == 0x000388, "Member 'AK34TipToeDistraction::_newTargetRadius' has a wrong offset!");
static_assert(offsetof(AK34TipToeDistraction, _minTimeIdle) == 0x0003B0, "Member 'AK34TipToeDistraction::_minTimeIdle' has a wrong offset!");
static_assert(offsetof(AK34TipToeDistraction, _maxTimeIdle) == 0x0003B8, "Member 'AK34TipToeDistraction::_maxTimeIdle' has a wrong offset!");
static_assert(offsetof(AK34TipToeDistraction, _maxCountSameLocationConsideredStuck) == 0x0003E0, "Member 'AK34TipToeDistraction::_maxCountSameLocationConsideredStuck' has a wrong offset!");
static_assert(offsetof(AK34TipToeDistraction, _distanceConsideredStuck) == 0x0003E4, "Member 'AK34TipToeDistraction::_distanceConsideredStuck' has a wrong offset!");
static_assert(offsetof(AK34TipToeDistraction, _randomBehaviourCheckRate) == 0x0003E8, "Member 'AK34TipToeDistraction::_randomBehaviourCheckRate' has a wrong offset!");
static_assert(offsetof(AK34TipToeDistraction, _overlapRadius) == 0x0003EC, "Member 'AK34TipToeDistraction::_overlapRadius' has a wrong offset!");
static_assert(offsetof(AK34TipToeDistraction, _cosmeticFootSpawnRate) == 0x0003F0, "Member 'AK34TipToeDistraction::_cosmeticFootSpawnRate' has a wrong offset!");
static_assert(offsetof(AK34TipToeDistraction, _isAcquiredFromPool) == 0x0003F4, "Member 'AK34TipToeDistraction::_isAcquiredFromPool' has a wrong offset!");
static_assert(offsetof(AK34TipToeDistraction, _isInUse) == 0x0003F5, "Member 'AK34TipToeDistraction::_isInUse' has a wrong offset!");
static_assert(offsetof(AK34TipToeDistraction, _navMovementComponent) == 0x0005B0, "Member 'AK34TipToeDistraction::_navMovementComponent' has a wrong offset!");
static_assert(offsetof(AK34TipToeDistraction, _groundDetector) == 0x0005B8, "Member 'AK34TipToeDistraction::_groundDetector' has a wrong offset!");
static_assert(offsetof(AK34TipToeDistraction, _akComponent) == 0x0005C0, "Member 'AK34TipToeDistraction::_akComponent' has a wrong offset!");

// Class TheK34.K34TipToeModeComponent
// 0x0668 (0x0710 - 0x00A8)
class UK34TipToeModeComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnAuthorityDistractionSpawned;                     // 0x00A8(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnAuthorityDistractionDespawned;                   // 0x00B8(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FTagStateBool                          _isInTipToeMode;                                   // 0x00C8(0x0048)(Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	struct FTagStateBool                          _isInTipToeModeCooldown;                           // 0x0110(0x0048)(Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UStatusEffect>              _tipToeModeStatusEffectClass;                      // 0x0158(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FStatProperty                          _tipToeModeCooldown;                               // 0x0160(0x0088)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class UTimerObject*                           _tipToeModeCooldownTimer;                          // 0x01E8(0x0008)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1F0[0x30];                                     // 0x01F0(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	struct FStatProperty                          _tipToeModeDuration;                               // 0x0220(0x0088)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FStatProperty                          _tipToeModeDurationPenaltyPercentagePerM1Attempt;  // 0x02A8(0x0088)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _tipToeModeDurationWarningTimeUpAdvanceNotice;     // 0x0330(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class UTimerObject*                           _tipToeModeDurationTimer;                          // 0x0358(0x0008)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTimerObject*                           _tipToeModeDurationWarningTimeUpTimer;             // 0x0360(0x0008)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ULocalActorPoolComponent*               _authority_distractionPoolComponent;               // 0x0368(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EInputInteractionType                         _inputToDisplayWhileInTipToeMode;                  // 0x0370(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EInputInteractionType                         _inputToDisplayWhileInNormalMode;                  // 0x0371(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_372[0x6];                                      // 0x0372(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _enterTipToeBufferToExit;                          // 0x0378(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	int8                                          _distractionPoolSize;                              // 0x03A0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int8                                          _maxTryPerTickToFindSpawn;                         // 0x03A1(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3A2[0x6];                                      // 0x03A2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FStatProperty                          _maxDistractionPerSurvivor;                        // 0x03A8(0x0088)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FStatProperty                          _distractionRandomSpawnRateMin;                    // 0x0430(0x0088)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FStatProperty                          _distractionRandomSpawnRateMax;                    // 0x04B8(0x0088)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FStatProperty                          _distractionLifetime;                              // 0x0540(0x0088)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _spawnRadius;                                      // 0x05C8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _spawnRadiusBuffer;                                // 0x05F0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _directionRadius;                                  // 0x0618(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _maxVerticalDistance;                              // 0x0640(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	bool                                          _shouldMinimizeSpawnDistanceWhenInChase;           // 0x0668(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_669[0x7];                                      // 0x0669(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AK34TipToeDistraction>      _tipToeDistractionClass;                           // 0x0670(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UNavigationQueryFilter>     _navQueryFilter;                                   // 0x0678(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class ACamperPlayer*, struct FCamperDistractionData> _authority_survivorsData;                          // 0x0680(0x0050)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6D0[0x40];                                     // 0x06D0(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnIntroCompleted();
	void Authority_ReduceDuration(const float ReductionPercentage);
	void Authority_SetIsInTipToeMode(const bool Param_IsInTipToeMode, const bool TriggerExitEvent);
	float GetTipToeModeDuration();
	bool IsInTipToeMode();
	void OnDistractionSpawned__DelegateSignature(class AK34TipToeDistraction* K34Distraction);
	void OnRep_IsInTipToeMode();
	void OnRep_TipToeModeDurationWarningTimeUpTimer();

	void Authority_ReduceCooldown(const float ReductionPercentage) const;
	bool CanEnterTipToeMode() const;
	class ASlasherPlayer* GetKiller() const;
	float GetRemainingTipToeModeCooldownDuration() const;
	float GetRemainingTipToeModeDuration() const;
	float GetTipToeModeCooldownDuration() const;
	void OnRep_IsInTipToeModeCooldown() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K34TipToeModeComponent">();
	}
	static class UK34TipToeModeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK34TipToeModeComponent>();
	}
};
static_assert(alignof(UK34TipToeModeComponent) == 0x000008, "Wrong alignment on UK34TipToeModeComponent");
static_assert(sizeof(UK34TipToeModeComponent) == 0x000710, "Wrong size on UK34TipToeModeComponent");
static_assert(offsetof(UK34TipToeModeComponent, OnAuthorityDistractionSpawned) == 0x0000A8, "Member 'UK34TipToeModeComponent::OnAuthorityDistractionSpawned' has a wrong offset!");
static_assert(offsetof(UK34TipToeModeComponent, OnAuthorityDistractionDespawned) == 0x0000B8, "Member 'UK34TipToeModeComponent::OnAuthorityDistractionDespawned' has a wrong offset!");
static_assert(offsetof(UK34TipToeModeComponent, _isInTipToeMode) == 0x0000C8, "Member 'UK34TipToeModeComponent::_isInTipToeMode' has a wrong offset!");
static_assert(offsetof(UK34TipToeModeComponent, _isInTipToeModeCooldown) == 0x000110, "Member 'UK34TipToeModeComponent::_isInTipToeModeCooldown' has a wrong offset!");
static_assert(offsetof(UK34TipToeModeComponent, _tipToeModeStatusEffectClass) == 0x000158, "Member 'UK34TipToeModeComponent::_tipToeModeStatusEffectClass' has a wrong offset!");
static_assert(offsetof(UK34TipToeModeComponent, _tipToeModeCooldown) == 0x000160, "Member 'UK34TipToeModeComponent::_tipToeModeCooldown' has a wrong offset!");
static_assert(offsetof(UK34TipToeModeComponent, _tipToeModeCooldownTimer) == 0x0001E8, "Member 'UK34TipToeModeComponent::_tipToeModeCooldownTimer' has a wrong offset!");
static_assert(offsetof(UK34TipToeModeComponent, _tipToeModeDuration) == 0x000220, "Member 'UK34TipToeModeComponent::_tipToeModeDuration' has a wrong offset!");
static_assert(offsetof(UK34TipToeModeComponent, _tipToeModeDurationPenaltyPercentagePerM1Attempt) == 0x0002A8, "Member 'UK34TipToeModeComponent::_tipToeModeDurationPenaltyPercentagePerM1Attempt' has a wrong offset!");
static_assert(offsetof(UK34TipToeModeComponent, _tipToeModeDurationWarningTimeUpAdvanceNotice) == 0x000330, "Member 'UK34TipToeModeComponent::_tipToeModeDurationWarningTimeUpAdvanceNotice' has a wrong offset!");
static_assert(offsetof(UK34TipToeModeComponent, _tipToeModeDurationTimer) == 0x000358, "Member 'UK34TipToeModeComponent::_tipToeModeDurationTimer' has a wrong offset!");
static_assert(offsetof(UK34TipToeModeComponent, _tipToeModeDurationWarningTimeUpTimer) == 0x000360, "Member 'UK34TipToeModeComponent::_tipToeModeDurationWarningTimeUpTimer' has a wrong offset!");
static_assert(offsetof(UK34TipToeModeComponent, _authority_distractionPoolComponent) == 0x000368, "Member 'UK34TipToeModeComponent::_authority_distractionPoolComponent' has a wrong offset!");
static_assert(offsetof(UK34TipToeModeComponent, _inputToDisplayWhileInTipToeMode) == 0x000370, "Member 'UK34TipToeModeComponent::_inputToDisplayWhileInTipToeMode' has a wrong offset!");
static_assert(offsetof(UK34TipToeModeComponent, _inputToDisplayWhileInNormalMode) == 0x000371, "Member 'UK34TipToeModeComponent::_inputToDisplayWhileInNormalMode' has a wrong offset!");
static_assert(offsetof(UK34TipToeModeComponent, _enterTipToeBufferToExit) == 0x000378, "Member 'UK34TipToeModeComponent::_enterTipToeBufferToExit' has a wrong offset!");
static_assert(offsetof(UK34TipToeModeComponent, _distractionPoolSize) == 0x0003A0, "Member 'UK34TipToeModeComponent::_distractionPoolSize' has a wrong offset!");
static_assert(offsetof(UK34TipToeModeComponent, _maxTryPerTickToFindSpawn) == 0x0003A1, "Member 'UK34TipToeModeComponent::_maxTryPerTickToFindSpawn' has a wrong offset!");
static_assert(offsetof(UK34TipToeModeComponent, _maxDistractionPerSurvivor) == 0x0003A8, "Member 'UK34TipToeModeComponent::_maxDistractionPerSurvivor' has a wrong offset!");
static_assert(offsetof(UK34TipToeModeComponent, _distractionRandomSpawnRateMin) == 0x000430, "Member 'UK34TipToeModeComponent::_distractionRandomSpawnRateMin' has a wrong offset!");
static_assert(offsetof(UK34TipToeModeComponent, _distractionRandomSpawnRateMax) == 0x0004B8, "Member 'UK34TipToeModeComponent::_distractionRandomSpawnRateMax' has a wrong offset!");
static_assert(offsetof(UK34TipToeModeComponent, _distractionLifetime) == 0x000540, "Member 'UK34TipToeModeComponent::_distractionLifetime' has a wrong offset!");
static_assert(offsetof(UK34TipToeModeComponent, _spawnRadius) == 0x0005C8, "Member 'UK34TipToeModeComponent::_spawnRadius' has a wrong offset!");
static_assert(offsetof(UK34TipToeModeComponent, _spawnRadiusBuffer) == 0x0005F0, "Member 'UK34TipToeModeComponent::_spawnRadiusBuffer' has a wrong offset!");
static_assert(offsetof(UK34TipToeModeComponent, _directionRadius) == 0x000618, "Member 'UK34TipToeModeComponent::_directionRadius' has a wrong offset!");
static_assert(offsetof(UK34TipToeModeComponent, _maxVerticalDistance) == 0x000640, "Member 'UK34TipToeModeComponent::_maxVerticalDistance' has a wrong offset!");
static_assert(offsetof(UK34TipToeModeComponent, _shouldMinimizeSpawnDistanceWhenInChase) == 0x000668, "Member 'UK34TipToeModeComponent::_shouldMinimizeSpawnDistanceWhenInChase' has a wrong offset!");
static_assert(offsetof(UK34TipToeModeComponent, _tipToeDistractionClass) == 0x000670, "Member 'UK34TipToeModeComponent::_tipToeDistractionClass' has a wrong offset!");
static_assert(offsetof(UK34TipToeModeComponent, _navQueryFilter) == 0x000678, "Member 'UK34TipToeModeComponent::_navQueryFilter' has a wrong offset!");
static_assert(offsetof(UK34TipToeModeComponent, _authority_survivorsData) == 0x000680, "Member 'UK34TipToeModeComponent::_authority_survivorsData' has a wrong offset!");

// Class TheK34.K34Utilities
// 0x0000 (0x0030 - 0x0030)
class UK34Utilities final : public UBlueprintFunctionLibrary
{
public:
	static class AK34Power* GetK34Power(const class ADBDPlayer* Player);
	static class UAuthoritativeActorPoolComponent* GetK34VFXFeetPool(const class ADBDPlayer* Player);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K34Utilities">();
	}
	static class UK34Utilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK34Utilities>();
	}
};
static_assert(alignof(UK34Utilities) == 0x000008, "Wrong alignment on UK34Utilities");
static_assert(sizeof(UK34Utilities) == 0x000030, "Wrong size on UK34Utilities");

// Class TheK34.K34VaultInteraction
// 0x0060 (0x08D0 - 0x0870)
class UK34VaultInteraction : public UKillerVaultDefinition
{
public:
	uint8                                         Pad_870[0x48];                                     // 0x0870(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            _cachedChainingLimitationCurve;                    // 0x08B8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _availabilityGracePeriodAfterDash;                 // 0x08C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8C4[0xC];                                      // 0x08C4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K34VaultInteraction">();
	}
	static class UK34VaultInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK34VaultInteraction>();
	}
};
static_assert(alignof(UK34VaultInteraction) == 0x000010, "Wrong alignment on UK34VaultInteraction");
static_assert(sizeof(UK34VaultInteraction) == 0x0008D0, "Wrong size on UK34VaultInteraction");
static_assert(offsetof(UK34VaultInteraction, _cachedChainingLimitationCurve) == 0x0008B8, "Member 'UK34VaultInteraction::_cachedChainingLimitationCurve' has a wrong offset!");
static_assert(offsetof(UK34VaultInteraction, _availabilityGracePeriodAfterDash) == 0x0008C0, "Member 'UK34VaultInteraction::_availabilityGracePeriodAfterDash' has a wrong offset!");

}

