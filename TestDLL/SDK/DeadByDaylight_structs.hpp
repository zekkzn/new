#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: DeadByDaylight

#include "Basic.hpp"

#include "DBDAudio_structs.hpp"
#include "NetworkUtilities_structs.hpp"
#include "DBDSharedTypes_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "Customization_structs.hpp"
#include "GameplayTags_structs.hpp"
#include "AIModule_structs.hpp"
#include "DataTableUtilities_structs.hpp"
#include "SocialParty_structs.hpp"
#include "Engine_structs.hpp"
#include "DBDUIViewInterfaces_structs.hpp"
#include "SlateCore_structs.hpp"
#include "StatSystem_structs.hpp"
#include "PlatformsProviders_structs.hpp"
#include "InputCore_structs.hpp"


namespace SDK
{

// Enum DeadByDaylight.EDBDCameraViewType
// NumValues: 0x0018
enum class EDBDCameraViewType : uint8
{
	None                                     = 0,
	Main                                     = 1,
	Offering                                 = 2,
	AnimationPreview                         = 3,
	ArchiveIntro                             = 4,
	ArchiveRewards                           = 5,
	ArchiveTome                              = 6,
	SurvivorOnline                           = 7,
	KillerOnline                             = 8,
	SurvivorOffline                          = 9,
	KillerOffline                            = 10,
	LobbySurvivorOfflineStory                = 11,
	LobbySurvivorOfflineCharm                = 12,
	LobbyKillerOfflineStory                  = 13,
	LobbyKillerOfflineHook                   = 14,
	LobbyKillerOfflineCharm                  = 15,
	Shop                                     = 16,
	ShopEntry                                = 17,
	ShopStory                                = 18,
	ShopCharacter                            = 19,
	ShopHook                                 = 20,
	ShopCharm                                = 21,
	Paradise                                 = 22,
	EDBDCameraViewType_MAX                   = 23,
};

// Enum DeadByDaylight.EHitValidatorConfigName
// NumValues: 0x0009
enum class EHitValidatorConfigName : uint8
{
	Default                                  = 0,
	Hatchet                                  = 1,
	Bomb                                     = 2,
	Harpoon                                  = 3,
	Oni                                      = 4,
	Whip                                     = 5,
	Tail                                     = 6,
	DefaultProjectile                        = 7,
	EHitValidatorConfigName_MAX              = 8,
};

// Enum DeadByDaylight.EInventoryType
// NumValues: 0x0003
enum class EInventoryType : uint8
{
	Main                                     = 0,
	Backpack                                 = 1,
	EInventoryType_MAX                       = 2,
};

// Enum DeadByDaylight.EItemDropType
// NumValues: 0x0004
enum class EItemDropType : uint8
{
	DropManually                             = 0,
	DropForcefully                           = 1,
	UseItem                                  = 2,
	EItemDropType_MAX                        = 3,
};

// Enum DeadByDaylight.ECollectableState
// NumValues: 0x0006
enum class ECollectableState : uint8
{
	OnGround                                 = 0,
	Stored                                   = 1,
	Equipped                                 = 2,
	ToBeDropped                              = 3,
	InSearchable                             = 4,
	ECollectableState_MAX                    = 5,
};

// Enum DeadByDaylight.EAttachToSocketNameEnum
// NumValues: 0x0007
enum class EAttachToSocketNameEnum : uint8
{
	ManualAttachment                         = 0,
	HandItemSocket                           = 1,
	Weapon_SocketLT                          = 2,
	Weapon_SocketRT                          = 3,
	LanternCollectableSocket                 = 4,
	Tentacle_SocketLT                        = 5,
	EAttachToSocketNameEnum_MAX              = 6,
};

// Enum DeadByDaylight.ECollectableCategory
// NumValues: 0x0003
enum class ECollectableCategory : uint8
{
	Common                                   = 0,
	Rare                                     = 1,
	ECollectableCategory_MAX                 = 2,
};

// Enum DeadByDaylight.EItemHandPosition
// NumValues: 0x000B
enum class EItemHandPosition : uint8
{
	None                                     = 0,
	HandleItem                               = 1,
	AimItem                                  = 2,
	SmallItem                                = 3,
	FirecrackerItem                          = 4,
	VaccineItem                              = 5,
	FragileObjectItem                        = 6,
	SprayBottleItem                          = 7,
	VhsItem                                  = 8,
	WormholeFatherKeyCardItem                = 9,
	EItemHandPosition_MAX                    = 10,
};

// Enum DeadByDaylight.EAtlantaItemProgressionBarEnum
// NumValues: 0x0003
enum class EAtlantaItemProgressionBarEnum : uint8
{
	PrimaryBar                               = 0,
	SecondaryBar                             = 1,
	EAtlantaItemProgressionBarEnum_MAX       = 2,
};

// Enum DeadByDaylight.ETileSpawnPointType
// NumValues: 0x000A
enum class ETileSpawnPointType : uint8
{
	Unspecified                              = 0,
	Survivor                                 = 1,
	SurvivorItem                             = 2,
	Killer                                   = 3,
	KillerItem                               = 4,
	InteractableObject                       = 5,
	BasementObject                           = 6,
	FinisherMori                             = 7,
	Count                                    = 8,
	ETileSpawnPointType_MAX                  = 9,
};

// Enum DeadByDaylight.EEndGameReason
// NumValues: 0x0008
enum class EEndGameReason : uint8
{
	None                                     = 0,
	Normal                                   = 1,
	KillerLeft                               = 2,
	PlayerLeftDuringLoading                  = 3,
	KillerLeftEarly                          = 4,
	InvalidPlayerRoles                       = 5,
	LoadingTimeout                           = 6,
	EEndGameReason_MAX                       = 7,
};

// Enum DeadByDaylight.EServerUseNetAsyncLoading
// NumValues: 0x0004
enum class EServerUseNetAsyncLoading : uint8
{
	NotSet                                   = 0,
	Yes                                      = 1,
	No                                       = 2,
	EServerUseNetAsyncLoading_MAX            = 3,
};

// Enum DeadByDaylight.EIntroState
// NumValues: 0x0006
enum class EIntroState : uint8
{
	WaitingToStart                           = 0,
	RotationStarted                          = 1,
	RotationCompleted                        = 2,
	PanInStarted                             = 3,
	PanInCompleted                           = 4,
	EIntroState_MAX                          = 5,
};

// Enum DeadByDaylight.EPalletState
// NumValues: 0x0005
enum class EPalletState : uint8
{
	Up                                       = 0,
	Falling                                  = 1,
	Fallen                                   = 2,
	Destroyed                                = 3,
	EPalletState_MAX                         = 4,
};

// Enum DeadByDaylight.EPalletStunZoneSideStrategy
// NumValues: 0x0003
enum class EPalletStunZoneSideStrategy : uint8
{
	OppositeSideToPlayerExecutingPulldown    = 0,
	SameSideToPlayerExecutingPulldown        = 1,
	EPalletStunZoneSideStrategy_MAX          = 2,
};

// Enum DeadByDaylight.EPalletPushSideStrategy
// NumValues: 0x0003
enum class EPalletPushSideStrategy : uint8
{
	PushToClosestPalletSide                  = 0,
	PushOppositeToPlayerExecutingPulldown    = 1,
	EPalletPushSideStrategy_MAX              = 2,
};

// Enum DeadByDaylight.EAttackZoneSet
// NumValues: 0x0003
enum class EAttackZoneSet : uint8
{
	VE_OriginalZones                         = 0,
	VE_WedgeZones                            = 1,
	VE_MAX                                   = 2,
};

// Enum DeadByDaylight.EKillerCarryAnimWeight
// NumValues: 0x0004
enum class EKillerCarryAnimWeight : uint8
{
	Regular                                  = 0,
	Light                                    = 1,
	Heavy                                    = 2,
	EKillerCarryAnimWeight_MAX               = 3,
};

// Enum DeadByDaylight.ETotemState
// NumValues: 0x0005
enum class ETotemState : uint8
{
	Cleansed                                 = 0,
	Dull                                     = 1,
	Hex                                      = 2,
	Boon                                     = 3,
	ETotemState_MAX                          = 4,
};

// Enum DeadByDaylight.ETutorialStep
// NumValues: 0x0007
enum class ETutorialStep : uint8
{
	Survivor_NotStarted                      = 0,
	Survivor_CompleteGenerator               = 1,
	Survivor_EvadeKiller                     = 2,
	Survivor_OnHook                          = 3,
	Done                                     = 4,
	Invalid                                  = 5,
	ETutorialStep_MAX                        = 6,
};

// Enum DeadByDaylight.EDBDScoreTypes
// NumValues: 0x00EF
enum class EDBDScoreTypes : uint8
{
	DBDCamperScore_SurviveHealthy            = 0,
	DBDCamperScore_SurviveWounded            = 1,
	DBDCamperScore_SurviveKO                 = 2,
	DBDCamperScore_UnlockHatch               = 3,
	DBDCamperScore_EscapeThroughHatch        = 4,
	DBDCamperScore_AllEscapeThroughHatch     = 5,
	DBDCamperScore_EscapeCarry               = 6,
	DBDCamperScore_SurviveStreakSmall        = 7,
	DBDCamperScore_SurviveStreakBig          = 8,
	DBDCamperScore_DamageStateChanged        = 9,
	DBDCamperScore_NearFriendInNeed          = 10,
	DBDCamperScore_NearFriendInNeed_PostExit = 11,
	DBDCamperScore_FoundCamper               = 12,
	DBDCamperScore_CoopObjectives            = 13,
	DBDCamperScore_OpenDoorPercent           = 14,
	DBDCamperScore_OpenDoor                  = 15,
	DBDCamperScore_GeneratorPercent          = 16,
	DBDCamperScore_GeneratorSkillCheckSuccess = 17,
	DBDCamperScore_GeneratorSkillCheckBonus  = 18,
	DBDCamperScore_SearchablePercent         = 19,
	DBDCamperScore_SearchCompleteFinalContributionPercent = 20,
	DBDCamperScore_AddItemToMap              = 21,
	DBDCamperScore_FixGenerator              = 22,
	DBDCamperScore_FixSpecialMapGenerator    = 23,
	DBDCamperScore_LastSurvivorFixGenerator  = 24,
	DBDCamperScore_RepairDamagedGenerator    = 25,
	DBDCamperScore_PowerExitGates            = 26,
	DBDCamperScore_CoopAltruism              = 27,
	DBDCamperScore_HealPercent               = 28,
	DBDCamperScore_HealPercent_PostExit      = 29,
	DBDCamperScore_HealFromDying             = 30,
	DBDCamperScore_HealFromDying_PostExit    = 31,
	DBDCamperScore_HealFromInjured           = 32,
	DBDCamperScore_HealFromInjured_PostExit  = 33,
	DBDCamperScore_HealSkillCheckSuccess     = 34,
	DBDCamperScore_HealSkillCheckBonus       = 35,
	DBDCamperScore_HealSelfPercent           = 36,
	DBDCamperScore_HealSelfSkillCheckSuccess = 37,
	DBDCamperScore_HealSelfSkillCheckBonus   = 38,
	DBDCamperScore_HitAfterHookSave          = 39,
	DBDCamperScore_HitNearFriendInNeed       = 40,
	DBDCamperScore_HitNearUnhookedFriendInNeed = 41,
	DBDCamperScore_SabotageHook              = 42,
	DBDCamperScore_SabotageHookSkillCheckSuccess = 43,
	DBDCamperScore_SabotageHookSkillCheckBonus = 44,
	DBDCamperScore_EscapeFromHook            = 45,
	DBDCamperScore_HookStrugglePerSecond     = 46,
	DBDCamperScore_SaveFromHook              = 47,
	DBDCamperScore_SaveFromHook_PostExit     = 48,
	DBDCamperScore_WasUnhooked               = 49,
	DBDCamperScore_SabotageBearTrap          = 50,
	DBDCamperScore_SabotageBearTrapSkillCheckSuccess = 51,
	DBDCamperScore_SabotageBearTrapSkillCheckBonus = 52,
	DBDCamperScore_DisableBearTrap           = 53,
	DBDCamperScore_SaveFromBearTrap          = 54,
	DBDCamperScore_SaveFromBearTrap_PostExit = 55,
	DBDCamperScore_EscapeBearTrap            = 56,
	DBDCamperScore_BasementChillingPerSecond = 57,
	DBDCamperScore_CoopBoldness              = 58,
	DBDCamperScore_SlasherStun               = 59,
	DBDCamperScore_SlasherStunCarrying       = 60,
	DBDCamperScore_SlasherBlind              = 61,
	DBDCamperScore_SlasherBurnInvisibility   = 62,
	DBDCamperScore_ChasePerSecond            = 63,
	DBDCamperScore_ChaseEscape               = 64,
	DBDCamperScore_ChaseSteal                = 65,
	DBDCamperScore_ChaseBlind                = 66,
	DBDCamperScore_VaultInChase              = 67,
	DBDCamperScore_NoiseDistraction          = 68,
	DBDCamperScore_SprintingNearSlasherPerSecond = 69,
	DBDCamperScore_UnhideNearSlasher         = 70,
	DBDCamperScore_EscapeWhileChased         = 71,
	DBDCamperScore_DestroyPhantomTrap        = 72,
	DBDCamperScore_NewItem                   = 73,
	DBDCamperScore_StartMatchWithUltraRareItem = 74,
	DBDCamperScore_ItemFrom                  = 75,
	DBDCamperScore_ExposerAdded              = 76,
	DBDSlasherScore_Destroy                  = 77,
	DBDSlasherScore_Kill                     = 78,
	DBDSlasherScore_BleedOut                 = 79,
	DBDSlasherScore_BleedOutPercent          = 80,
	DBDSlasherScore_AttackSuccess            = 81,
	DBDSlasherScore_AttackDeviousness        = 82,
	DBDSlasherScore_InterruptGenerator       = 83,
	DBDSlasherScore_InterruptWindow          = 84,
	DBDSlasherScore_InterruptHide            = 85,
	DBDSlasherScore_InterruptExit            = 86,
	DBDSlasherScore_InterruptUnhook          = 87,
	DBDSlasherScore_InterruptChest           = 88,
	DBDSlasherScore_InterruptOpenHatch       = 89,
	DBDSlasherScore_InterruptExitHatch       = 90,
	DBDSlasherScore_FindHiding               = 91,
	DBDSlasherScore_PlaceTrap                = 92,
	DBDSlasherScore_Trap                     = 93,
	DBDSlasherScore_TrapPickup               = 94,
	DBDSlasherScore_Hook                     = 95,
	DBDSlasherScore_SacrificePercent         = 96,
	DBDSlasherScore_SacrificeSuccess         = 97,
	DBDSlasherScore_SacrificedCount          = 98,
	DBDSlasherScore_NoEscape                 = 99,
	DBDSlasherScore_ChaseStart               = 100,
	DBDSlasherScore_ChasePerSecond           = 101,
	DBDSlasherScore_CloakStalkPerSecond      = 102,
	DBDSlasherScore_UncloakInView            = 103,
	DBDSlasherScore_UncloakAttack            = 104,
	DBDSlasherScore_EvadeInvisBurn           = 105,
	DBDSlasherScore_EvadeBlind               = 106,
	DBDSlasherScore_CamperDisconnect         = 107,
	DBDSlasherScore_HitCamperWithChainsaw    = 108,
	DBDSlasherScore_RunningWithChainsaw      = 109,
	DBDSlasherScore_ChainBlinkAttack         = 110,
	DBDSlasherScore_ChainBlinkInterrupt      = 111,
	DBDSlasherScore_ChainBlinkInterruptAfter3 = 112,
	DBDSlasherScore_ChainBlinkStartChase     = 113,
	DBDSlasherScore_StalkpointGained         = 114,
	DBDSlasherScore_StalkerTierIncrement     = 115,
	DBDSlasherScore_StalkerTierFirstTime     = 116,
	DBDSlasherScore_StalkerKillAllCampers    = 117,
	DBDSlasherScore_PhantomTrapSet           = 118,
	DBDSlasherScore_PhantomTrapTrigger       = 119,
	DBDSlasherScore_PhantomTrapTriggerAttack = 120,
	DBDSlasherScore_PhantomTrapTeleportAttack = 121,
	DBDSlasherScore_PhantomTrapTeleportAttackAllCampers = 122,
	DBDSlasherScore_ThrillOfTheHunt          = 123,
	DBDPlayerScore_BloodwebLevelUp           = 124,
	DBDPlayerScore_BloodwebPrestigeLevelUp   = 125,
	DBDPlayerScore_BloodwebPrestige3LevelUp  = 126,
	DBDPlayerScore_AwardPips                 = 127,
	DBDPlayerScore_AddBloodpoints            = 128,
	DBDPlayerScore_BloodpointsOneCategory    = 129,
	DBDPlayerScore_MaxBloodpointsAllCategories = 130,
	DBDPlayerScore_AddNewPerk                = 131,
	DBDPlayerScore_PerkLevelUp               = 132,
	DBDPlayerScore_BurnOfferingUltraRare     = 133,
	DBDPlayerScore_StartGame                 = 134,
	DBDPlayerScore_UnlockRanking             = 135,
	DBDPlayerScore_FinishWithPerks           = 136,
	DBDCamperScore_CheatObjectives           = 137,
	DBDCamperScore_CheatSurvival             = 138,
	DBDCamperScore_CheatAltruism             = 139,
	DBDCamperScore_CheatBoldness             = 140,
	DBDSlasherScore_CheatSacrifice           = 141,
	DBDSlasherScore_CheatBrutality           = 142,
	DBDSlasherScore_CheatDeviousness         = 143,
	DBDSlasherScore_CheatHunter              = 144,
	DBDCamperScore_CleanseDullTotem          = 145,
	DBDCamperScore_CleanseHexTotem           = 146,
	DBDPlayerScore_BalancedLanding           = 147,
	DBDPlayerScore_Lithe                     = 148,
	DBDSlasherScore_DamageGenerator          = 149,
	DBDSlasherScore_Vault                    = 150,
	DBDCamperScore_StartInjuredBleedout      = 151,
	DBDCamperScore_FullRecovery              = 152,
	DBDCamperScore_FirstTimeDying            = 153,
	DBDCamperScore_SecondTimeDying           = 154,
	DBDCamperScore_FirecrackerDisturbance    = 155,
	DBDCamperScore_GeneratorSkillCheckRuinBonus = 156,
	DBDCamperScore_SlasherBurnBlink          = 157,
	DBDCamperScore_DieSacrificed             = 158,
	DBDCamperScore_DieBleedOut               = 159,
	DBDCamperScore_DieKill                   = 160,
	DBDPlayerScore_EndGame                   = 161,
	DBDPlayerScore_EnterParadise             = 162,
	DBDSlasherScore_CamperHookedFirstTime    = 163,
	DBDSlasherScore_CamperEnterHookStrugglePhase = 164,
	DBDSlasherScore_ElectroShockSurvivor     = 165,
	DBDSlasherScore_BringAllSurvivorsToMadnessTier3 = 166,
	DBDSlasherScore_BringSurvivorUpOneMadnessTier = 167,
	DBDSlasherScore_HitSurvivorAfterElectroShock = 168,
	DBDSlasherScore_PickupCamper             = 169,
	DBDSlasherScore_Blink                    = 170,
	DBDSlasherScore_TeleportToPhantomTrap    = 171,
	DBDSlasherScore_HatchetThrow             = 172,
	DBDSlasherScore_HatchetHit               = 173,
	DBDSlasherScore_HatchetSkillShotHit      = 174,
	DBDSlasherScore_HatchetFarHit            = 175,
	DBDCamperScore_QuickVault                = 176,
	DBDCamperScore_QuickCloset               = 177,
	DBDCamperScore_StartGeneratorRepair      = 178,
	DBDCamperScore_StartCleansingTotem       = 179,
	DBDCamperScore_FirstRepairSkillCheck     = 180,
	DBDSlasherScore_CamperDisconnectedBeforeMatchStart = 181,
	DBDSlasherScore_CamperDisconnectedDuringMatch = 182,
	DBDCamperScore_NearFriendInNeed_GeneratorsComplete = 183,
	DBDCamperScore_HealPercent_GeneratorsComplete = 184,
	DBDCamperScore_HealFromDying_GeneratorsComplete = 185,
	DBDCamperScore_SaveFromHook_GeneratorsComplete = 186,
	DBDCamperScore_SaveFromBearTrap_GeneratorsComplete = 187,
	DBDCamperScore_SnapOutOfIt               = 188,
	DBDSlasherScore_HookInBasement           = 189,
	DBDSlasherScore_LFChainsawHit            = 190,
	DBDCamperScore_PalletDrop                = 191,
	DBDCamperScore_Vault                     = 192,
	DBDSlasherScore_StartChaseWithChainsawAttack = 193,
	DBDSlasherScore_MissedAttackInChase      = 194,
	DBDCamperScore_DodgeAndVault             = 195,
	DBDCamperScore_BeginQuickVault           = 196,
	DBDSlasherScore_StartChainsawAttack      = 197,
	DBDCamperScore_WakeUpBySkillCheck        = 198,
	DBDCamperScore_FallAsleep                = 199,
	DBDCamperScore_WakeUpSelf                = 200,
	DBDCamperScore_WakeUpOther               = 201,
	DBDSlasherScore_RecentlyAsleepAttack     = 202,
	DBDSlasherScore_SurvivorPartyOnBasementHooks = 203,
	DBDCamperScore_LootBasementChest         = 204,
	DBDPlayerScore_OpenMysteryBox            = 205,
	DBDGameEvent_SurvivorDowned              = 206,
	DBDGameEvent_SurvivorDied                = 207,
	DBDGameEvent_KillerCloak                 = 208,
	DBDSlasherScore_SetReverseBearTrap       = 209,
	DBDSlasherScore_AbductionDash            = 210,
	DBDSlasherScore_DashHitSuccess           = 211,
	DBDSlasherScore_KillWithReverseBearTrap  = 212,
	DBDCamperScore_SearchRBTKey              = 213,
	DBDCamperScore_EscapeRBT                 = 214,
	DBDGameEvent_ReplacedGoodSkillCheckAsGreat = 215,
	DBDCamperScore_RemoveReverseBearTrapSkillCheckSuccess = 216,
	DBDCamperScore_RemoveReverseBearTrapSkillCheckBonus = 217,
	DBDSlasherScore_DamageGeneratorWhileHooked = 218,
	DBDGameEvent_SurvivorDamaged             = 219,
	DBDGameEvent_SurvivorHealed              = 220,
	DBDGameEvent_Interruption                = 221,
	DBDGameEvent_SurvivorFailedHealSkillcheck = 222,
	DBDGameEvent_HookedSurvivorSacrificeBegin = 223,
	DBDGameEvent_AcquireEventKillerCoin      = 224,
	DBDGameEvent_AcquireEventSurvivorCoin    = 225,
	DBDCamperScore_EventGeneratorFixed       = 226,
	DBDSlasherScore_HookedOnEventHook        = 227,
	DBDGameEvent_GeneratorProgress           = 228,
	DBDSlasherScore_DownSmokedCamper         = 229,
	DBDSlasherScore_HitSmokedCamper          = 230,
	DBDSlasherScore_SurvivorEnterGasCloud    = 231,
	DBDSlasherScore_BombDirectHit            = 232,
	DBDSlasherScore_ThrowBomb                = 233,
	DBDGameEvent_CoopAction                  = 234,
	DBDSlasherScore_StartActivePhaseWalk     = 235,
	DBDScore_Count                           = 236,
	Count                                    = 237,
	EDBDScoreTypes_MAX                       = 238,
};

// Enum DeadByDaylight.ELanternState
// NumValues: 0x0005
enum class ELanternState : uint8
{
	Collectable                              = 0,
	Collected                                = 1,
	Destroyed                                = 2,
	Destroyable                              = 3,
	ELanternState_MAX                        = 4,
};

// Enum DeadByDaylight.ECamperDamageState
// NumValues: 0x0005
enum class ECamperDamageState : uint8
{
	VE_Healthy                               = 0,
	VE_Injured                               = 1,
	VE_KO                                    = 2,
	VE_Dead                                  = 3,
	VE_MAX                                   = 4,
};

// Enum DeadByDaylight.EImmobilizedState
// NumValues: 0x0008
enum class EImmobilizedState : uint8
{
	VE_None                                  = 0,
	VE_Hooked                                = 1,
	VE_Trapped                               = 2,
	VE_Hiding                                = 3,
	VE_Dead                                  = 4,
	VE_InDeathBed                            = 5,
	VE_TwinImmobilized                       = 6,
	VE_MAX                                   = 7,
};

// Enum DeadByDaylight.EHealthType
// NumValues: 0x0006
enum class EHealthType : uint8
{
	Alive                                    = 0,
	Sacrificed                               = 1,
	Killed                                   = 2,
	BledOut                                  = 3,
	Left_Game                                = 4,
	EHealthType_MAX                          = 5,
};

// Enum DeadByDaylight.EInteractionComparisonPriority
// NumValues: 0x0004
enum class EInteractionComparisonPriority : uint8
{
	Lower                                    = 0,
	Equal                                    = 1,
	Higher                                   = 2,
	EInteractionComparisonPriority_MAX       = 3,
};

// Enum DeadByDaylight.EInteractionOwnership
// NumValues: 0x0004
enum class EInteractionOwnership : uint8
{
	AnyCanUse                                = 0,
	OnlyOwnerCanUse                          = 1,
	OwnerCannotUse                           = 2,
	EInteractionOwnership_MAX                = 3,
};

// Enum DeadByDaylight.ESnapBackPositionType
// NumValues: 0x0003
enum class ESnapBackPositionType : uint8
{
	SnapBackToInitialPosition                = 0,
	SnapBackToOffsetPositionFromSnap         = 1,
	ESnapBackPositionType_MAX                = 2,
};

// Enum DeadByDaylight.ESnapBackType
// NumValues: 0x0006
enum class ESnapBackType : uint8
{
	None                                     = 0,
	Always                                   = 1,
	OnInteractionCancelledOnly               = 2,
	OnInteractionEndOnly                     = 3,
	OnSurvivorDownedOnly                     = 4,
	ESnapBackType_MAX                        = 5,
};

// Enum DeadByDaylight.EOfferingAnimState
// NumValues: 0x000A
enum class EOfferingAnimState : uint8
{
	None                                     = 0,
	Idle                                     = 1,
	Init                                     = 2,
	Reveal                                   = 3,
	ShowInteraction                          = 4,
	Burned                                   = 5,
	Returned                                 = 6,
	Cancel                                   = 7,
	Hidden                                   = 8,
	EOfferingAnimState_MAX                   = 9,
};

// Enum DeadByDaylight.ETrapType
// NumValues: 0x0006
enum class ETrapType : uint8
{
	None                                     = 0,
	BlastMine                                = 1,
	Wiretap                                  = 2,
	RepressedAlliance                        = 3,
	NitrogenGrenade                          = 4,
	ETrapType_MAX                            = 5,
};

// Enum DeadByDaylight.EMovementCurveType
// NumValues: 0x0002
enum class EMovementCurveType : uint8
{
	MultiplicativeSpeedCurve                 = 0,
	EMovementCurveType_MAX                   = 1,
};

// Enum DeadByDaylight.EProgressModifier
// NumValues: 0x0004
enum class EProgressModifier : uint8
{
	Default                                  = 0,
	Buff                                     = 1,
	Debuff                                   = 2,
	EProgressModifier_MAX                    = 3,
};

// Enum DeadByDaylight.EGameplayElementType
// NumValues: 0x0019
enum class EGameplayElementType : uint8
{
	Generic                                  = 0,
	MeatLocker_Small                         = 1,
	TileLights                               = 2,
	MeatLocker_Big                           = 3,
	Searchable                               = 4,
	EdgeObjects                              = 5,
	LivingWorldObjects                       = 6,
	Hatch                                    = 7,
	Bookshelves                              = 8,
	Totems                                   = 9,
	QuadrantSpawn                            = 10,
	EdgeObjectsBlocker                       = 11,
	BreakableWalls                           = 12,
	Escape                                   = 13,
	ThemeSpawner                             = 14,
	Basement_Attachments                     = 15,
	SteamPipe                                = 16,
	SteamPipeButton                          = 17,
	EventSpawner                             = 18,
	BasementSeance                           = 19,
	RealmSpawner                             = 20,
	Cage                                     = 21,
	VoidSpawner                              = 22,
	Count                                    = 23,
	EGameplayElementType_MAX                 = 24,
};

// Enum DeadByDaylight.EActionButtonState
// NumValues: 0x0005
enum class EActionButtonState : uint8
{
	Normal                                   = 0,
	Toggled                                  = 1,
	Disabled                                 = 2,
	Hidden                                   = 3,
	EActionButtonState_MAX                   = 4,
};

// Enum DeadByDaylight.EKnowledgeSharingType
// NumValues: 0x0005
enum class EKnowledgeSharingType : uint8
{
	Possessor                                = 0,
	Survivors                                = 1,
	Killers                                  = 2,
	All                                      = 3,
	EKnowledgeSharingType_MAX                = 4,
};

// Enum DeadByDaylight.EAIHideInLockerState
// NumValues: 0x0004
enum class EAIHideInLockerState : uint8
{
	WalkToLocker                             = 0,
	GetIntoLocker                            = 1,
	HidingInLocker                           = 2,
	EAIHideInLockerState_MAX                 = 3,
};

// Enum DeadByDaylight.EAIRepairGeneratorState
// NumValues: 0x0006
enum class EAIRepairGeneratorState : uint8
{
	FindAvailableGeneratorPosition           = 0,
	WalkToGenerator                          = 1,
	RotateTowardsGenerator                   = 2,
	BeginGeneratorRepairs                    = 3,
	RepairingGenerator                       = 4,
	EAIRepairGeneratorState_MAX              = 5,
};

// Enum DeadByDaylight.EAnimationPreviewType
// NumValues: 0x0003
enum class EAnimationPreviewType : uint32
{
	Mori                                     = 0,
	MoriAlternate                            = 1,
	EAnimationPreviewType_MAX                = 2,
};

// Enum DeadByDaylight.EMoriPreviewVariant
// NumValues: 0x0003
enum class EMoriPreviewVariant : uint8
{
	Primary                                  = 0,
	Secondary                                = 1,
	EMoriPreviewVariant_MAX                  = 2,
};

// Enum DeadByDaylight.EContextualType
// NumValues: 0x000E
enum class EContextualType : uint8
{
	None                                     = 0,
	RedGlyph                                 = 1,
	BlueGlyph                                = 2,
	YellowGlyph                              = 3,
	PurpleGlyph                              = 4,
	IceBlueGlyph                             = 5,
	GreenGlyph                               = 6,
	OrangeGlyph                              = 7,
	PinkGlyph                                = 8,
	GlyphUpperBound                          = 9,
	ToxinPlantHalloween2020                  = 10,
	PumpkinHalloween2021                     = 11,
	CoreMemoryPortal                         = 12,
	EContextualType_MAX                      = 13,
};

// Enum DeadByDaylight.EAdditiveBehaviour
// NumValues: 0x0003
enum class EAdditiveBehaviour : uint8
{
	AddValues                                = 0,
	MaxValue                                 = 1,
	EAdditiveBehaviour_MAX                   = 2,
};

// Enum DeadByDaylight.EStackingBehaviours
// NumValues: 0x0003
enum class EStackingBehaviours : uint8
{
	Stackable                                = 0,
	Override                                 = 1,
	EStackingBehaviours_MAX                  = 2,
};

// Enum DeadByDaylight.EOwnershipBehaviour
// NumValues: 0x0003
enum class EOwnershipBehaviour : uint8
{
	Personal                                 = 0,
	Shared                                   = 1,
	EOwnershipBehaviour_MAX                  = 2,
};

// Enum DeadByDaylight.EArchiveStoryType
// NumValues: 0x0005
enum class EArchiveStoryType : uint8
{
	NotSet                                   = 0,
	CurrentStory                             = 1,
	PastStory                                = 2,
	EventStory                               = 3,
	EArchiveStoryType_MAX                    = 4,
};

// Enum DeadByDaylight.EArm
// NumValues: 0x0003
enum class EArm : uint8
{
	Left                                     = 0,
	Right                                    = 1,
	EArm_MAX                                 = 2,
};

// Enum DeadByDaylight.EAtlantaControlTypeSetting
// NumValues: 0x0003
enum class EAtlantaControlTypeSetting : uint8
{
	CameraFullScreen                         = 0,
	SnapOnJoystick                           = 1,
	EAtlantaControlTypeSetting_MAX           = 2,
};

// Enum DeadByDaylight.EAtlantaDisplayStandPosition
// NumValues: 0x0003
enum class EAtlantaDisplayStandPosition : uint8
{
	Forefront                                = 0,
	Background                               = 1,
	EAtlantaDisplayStandPosition_MAX         = 2,
};

// Enum DeadByDaylight.EFrameRateLimitButtonSetting
// NumValues: 0x0003
enum class EFrameRateLimitButtonSetting : uint8
{
	ThirtyFPS                                = 0,
	SixtyFPS                                 = 1,
	EFrameRateLimitButtonSetting_MAX         = 2,
};

// Enum DeadByDaylight.EMobileLoginAuthContext
// NumValues: 0x0004
enum class EMobileLoginAuthContext : uint8
{
	Splash                                   = 0,
	OverlayMenu                              = 1,
	ResumeFromSuspend                        = 2,
	EMobileLoginAuthContext_MAX              = 3,
};

// Enum DeadByDaylight.EAtlantaRewardType
// NumValues: 0x000D
enum class EAtlantaRewardType : uint8
{
	Item                                     = 0,
	AddOn                                    = 1,
	Offering                                 = 2,
	BloodPoints                              = 3,
	IridescentShards                         = 4,
	AuricCells                               = 5,
	Customization                            = 6,
	FreeTicket                               = 7,
	MysteryBox                               = 8,
	Character                                = 9,
	DuplicatesRefundKey                      = 10,
	Count                                    = 11,
	EAtlantaRewardType_MAX                   = 12,
};

// Enum DeadByDaylight.EAltantaRitualUIType
// NumValues: 0x0004
enum class EAltantaRitualUIType : uint8
{
	Single                                   = 0,
	Master                                   = 1,
	Special                                  = 2,
	EAltantaRitualUIType_MAX                 = 3,
};

// Enum DeadByDaylight.EAtlantaRitualRewardUIType
// NumValues: 0x000A
enum class EAtlantaRitualRewardUIType : uint8
{
	Item                                     = 0,
	AddOn                                    = 1,
	Offering                                 = 2,
	BloodPoints                              = 3,
	IridescentShards                         = 4,
	AuricCells                               = 5,
	Customization                            = 6,
	CustoTicket                              = 7,
	MysteryBox                               = 8,
	EAtlantaRitualRewardUIType_MAX           = 9,
};

// Enum DeadByDaylight.EAttackEventType
// NumValues: 0x0006
enum class EAttackEventType : uint8
{
	VE_None                                  = 0,
	VE_BasicAttackAttempt                    = 1,
	VE_BasicAttackHit                        = 2,
	VE_SpecialAttackAttempt                  = 3,
	VE_SpecialAttackHit                      = 4,
	VE_MAX                                   = 5,
};

// Enum DeadByDaylight.EBPBonusType
// NumValues: 0x0005
enum class EBPBonusType : uint8
{
	None                                     = 0,
	Event                                    = 1,
	Offerings                                = 2,
	Others                                   = 3,
	EBPBonusType_MAX                         = 4,
};

// Enum DeadByDaylight.EBloodchestType
// NumValues: 0x0005
enum class EBloodchestType : uint8
{
	None                                     = 0,
	Chest                                    = 1,
	SuperChests                              = 2,
	EntityBox                                = 3,
	EBloodchestType_MAX                      = 4,
};

// Enum DeadByDaylight.EBloodwebDataSource
// NumValues: 0x0003
enum class EBloodwebDataSource : uint8
{
	ByLevel                                  = 0,
	ByRing                                   = 1,
	EBloodwebDataSource_MAX                  = 2,
};

// Enum DeadByDaylight.EBloodwebDistributionType
// NumValues: 0x0003
enum class EBloodwebDistributionType : uint8
{
	PerWeb                                   = 0,
	PerRing                                  = 1,
	EBloodwebDistributionType_MAX            = 2,
};

// Enum DeadByDaylight.EBloodwebDefinitionContentType
// NumValues: 0x0006
enum class EBloodwebDefinitionContentType : uint8
{
	Empty                                    = 0,
	Nodes                                    = 1,
	Paths                                    = 2,
	NodesAndPaths                            = 3,
	NodesNoPath                              = 1,
	EBloodwebDefinitionContentType_MAX       = 4,
};

// Enum DeadByDaylight.EBloodMarketRefreshMethod
// NumValues: 0x0003
enum class EBloodMarketRefreshMethod : uint8
{
	Automatic                                = 0,
	Manual                                   = 1,
	EBloodMarketRefreshMethod_MAX            = 2,
};

// Enum DeadByDaylight.EBloodwebFillingMethod
// NumValues: 0x0003
enum class EBloodwebFillingMethod : uint8
{
	RestrictionsBasedOnData                  = 0,
	FillAll                                  = 1,
	EBloodwebFillingMethod_MAX               = 2,
};

// Enum DeadByDaylight.EBloodwebSaveReason
// NumValues: 0x0005
enum class EBloodwebSaveReason : uint8
{
	PayToRefresh                             = 0,
	PrestigeUp                               = 1,
	ShouldRebuild                            = 2,
	Cheat                                    = 3,
	EBloodwebSaveReason_MAX                  = 4,
};

// Enum DeadByDaylight.EBloodwebRing
// NumValues: 0x0008
enum class EBloodwebRing : uint8
{
	CenterRing                               = 0,
	InnerRing                                = 1,
	MiddleRing                               = 2,
	OuterRing                                = 3,
	EntityRing                               = 4,
	RingCount                                = 5,
	Count                                    = 6,
	EBloodwebRing_MAX                        = 7,
};

// Enum DeadByDaylight.EBloodwebNodeState
// NumValues: 0x0007
enum class EBloodwebNodeState : uint8
{
	Inactive                                 = 0,
	Available                                = 1,
	Locked_Do_Not_Use_Deprecated             = 2,
	Collected                                = 3,
	Consumed                                 = 4,
	Count                                    = 5,
	EBloodwebNodeState_MAX                   = 6,
};

// Enum DeadByDaylight.EBloodwebNodeContentType
// NumValues: 0x0011
enum class EBloodwebNodeContentType : uint8
{
	Empty                                    = 0,
	Perks                                    = 1,
	PerkBuffs_Do_Not_Use_Deprecated          = 2,
	Offerings                                = 3,
	Items                                    = 4,
	AddOn                                    = 5,
	Chests                                   = 6,
	PerksPacks                               = 7,
	IridiscentShards                         = 8,
	AuricCells                               = 9,
	SuperChests                              = 10,
	CosmeticItems                            = 11,
	Bloodpoints                              = 12,
	FreeTicket                               = 13,
	EntityBox                                = 14,
	Count                                    = 15,
	EBloodwebNodeContentType_MAX             = 16,
};

// Enum DeadByDaylight.EBloodwebNodeGateTypes
// NumValues: 0x0004
enum class EBloodwebNodeGateTypes : uint8
{
	RequiredRank                             = 0,
	RequiredItem                             = 1,
	Count                                    = 2,
	EBloodwebNodeGateTypes_MAX               = 3,
};

// Enum DeadByDaylight.EBreakableState
// NumValues: 0x0003
enum class EBreakableState : uint8
{
	Unbroken                                 = 0,
	Broken                                   = 1,
	EBreakableState_MAX                      = 2,
};

// Enum DeadByDaylight.ECameraOffsetState
// NumValues: 0x0006
enum class ECameraOffsetState : uint8
{
	None                                     = 0,
	Default                                  = 1,
	Crouching                                = 2,
	Crawling                                 = 3,
	Carried                                  = 4,
	ECameraOffsetState_MAX                   = 5,
};

// Enum DeadByDaylight.ECameraFadeState
// NumValues: 0x0005
enum class ECameraFadeState : uint8
{
	FadedIn                                  = 0,
	FadingOut                                = 1,
	FadedOut                                 = 2,
	FadingIn                                 = 3,
	ECameraFadeState_MAX                     = 4,
};

// Enum DeadByDaylight.EManualZoomType
// NumValues: 0x0004
enum class EManualZoomType : uint8
{
	None                                     = 0,
	TargetZoomValue                          = 1,
	CurveFloatProgression                    = 2,
	EManualZoomType_MAX                      = 3,
};

// Enum DeadByDaylight.EDBDCameraSocketID
// NumValues: 0x0007
enum class EDBDCameraSocketID : uint8
{
	VE_None                                  = 0,
	VE_Default                               = 1,
	VE_Killcam                               = 2,
	VE_Reaction                              = 3,
	VE_Struggle                              = 4,
	VE_Sacrifice                             = 5,
	VE_MAX                                   = 6,
};

// Enum DeadByDaylight.EEscapeType
// NumValues: 0x0004
enum class EEscapeType : uint8
{
	Escape_ExitGate                          = 0,
	Escape_Hatch                             = 1,
	Escape_KillerDisconnect                  = 2,
	Escape_MAX                               = 3,
};

// Enum DeadByDaylight.ERewardTrackId
// NumValues: 0x0004
enum class ERewardTrackId : uint8
{
	Free                                     = 0,
	Premium                                  = 1,
	None                                     = 2,
	ERewardTrackId_MAX                       = 3,
};

// Enum DeadByDaylight.EChallengeStatus
// NumValues: 0x0005
enum class EChallengeStatus : uint8
{
	Closed                                   = 0,
	Completed                                = 1,
	Open                                     = 2,
	Error                                    = 3,
	EChallengeStatus_MAX                     = 4,
};

// Enum DeadByDaylight.ECharacterToolItemType
// NumValues: 0x0005
enum class ECharacterToolItemType : uint8
{
	None                                     = 0,
	Outfit                                   = 1,
	OutfitPiece                              = 2,
	Charm                                    = 3,
	ECharacterToolItemType_MAX               = 4,
};

// Enum DeadByDaylight.ECharacterCameraViewType
// NumValues: 0x0004
enum class ECharacterCameraViewType : uint8
{
	None                                     = 0,
	Character                                = 1,
	Outfit                                   = 2,
	ECharacterCameraViewType_MAX             = 3,
};

// Enum DeadByDaylight.EChargeableInteractionBarType
// NumValues: 0x0003
enum class EChargeableInteractionBarType : uint8
{
	VE_Normal                                = 0,
	VE_ProgressPips                          = 1,
	VE_MAX                                   = 2,
};

// Enum DeadByDaylight.EChargeableInteractionPriority
// NumValues: 0x0005
enum class EChargeableInteractionPriority : uint8
{
	VE_External                              = 0,
	VE_Item                                  = 1,
	VE_Self                                  = 2,
	VE_None                                  = 3,
	VE_MAX                                   = 4,
};

// Enum DeadByDaylight.ECharmCategory
// NumValues: 0x000B
enum class ECharmCategory : uint8
{
	None                                     = 0,
	Small                                    = 1,
	Medium                                   = 2,
	Big                                      = 3,
	Short                                    = 4,
	Wide                                     = 5,
	Chibi                                    = 6,
	Square                                   = 7,
	Tablet                                   = 8,
	Perk                                     = 9,
	ECharmCategory_MAX                       = 10,
};

// Enum DeadByDaylight.EAudioDimensionType
// NumValues: 0x0004
enum class EAudioDimensionType : uint8
{
	None                                     = 0,
	TwoDimension                             = 1,
	ThreeDimension                           = 2,
	EAudioDimensionType_MAX                  = 3,
};

// Enum DeadByDaylight.EPerkTokenSoundStrategy
// NumValues: 0x0004
enum class EPerkTokenSoundStrategy : uint8
{
	NoSound                                  = 0,
	SoundOnEveryTokenChange                  = 1,
	SoundOnReachMaxTokens                    = 2,
	EPerkTokenSoundStrategy_MAX              = 3,
};

// Enum DeadByDaylight.ECollisionZoneShape
// NumValues: 0x0004
enum class ECollisionZoneShape : uint8
{
	Box                                      = 0,
	Capsule                                  = 1,
	Sphere                                   = 2,
	ECollisionZoneShape_MAX                  = 3,
};

// Enum DeadByDaylight.EContext
// NumValues: 0x004B
enum class EContext : uint8
{
	None                                     = 0,
	ArchiveIntro                             = 1,
	ArchiveCompendium                        = 2,
	ArchiveRift                              = 3,
	ArchiveTome                              = 4,
	BloodWeb                                 = 5,
	Character                                = 6,
	Consent                                  = 7,
	Credits                                  = 8,
	Customization                            = 9,
	GameFlowOff                              = 10,
	Hud                                      = 11,
	LightSensitivity                         = 12,
	Loading                                  = 13,
	Loadout                                  = 14,
	LobbyCharacters                          = 15,
	LobbyOff                                 = 16,
	LobbySidePanel                           = 17,
	Onboarding                               = 18,
	RoleSelection                            = 19,
	SpecialEventLoading                      = 20,
	Spectate                                 = 21,
	Splash                                   = 22,
	Store                                    = 23,
	StoreBundles                             = 24,
	StoreKillers                             = 25,
	StoreSurvivors                           = 26,
	StoreCollections                         = 27,
	StoreFeatured                            = 28,
	StoreSpecials                            = 29,
	Tally                                    = 30,
	Tutorial                                 = 31,
	UMGLoading                               = 32,
	UMGMainMenu                              = 33,
	ArchivePassPurchasePopup                 = 34,
	ArchiveTierPurchasePopup                 = 35,
	DailyRewardsPopup                        = 36,
	FearMarketPopup                          = 37,
	FriendSearchPopup                        = 38,
	GenericRefreshingPopup                   = 39,
	NewContentPopup                          = 40,
	ReportPlayerPopup                        = 41,
	SeasonEndPopup                           = 42,
	SeasonEndRankRewardsPopup                = 43,
	UnlockPersonalPerksPopup                 = 44,
	MarketingInvitationPopup                 = 45,
	NewActiveTomePopup                       = 46,
	ReportFeedbackPopup                      = 47,
	RewardPopup                              = 48,
	StoreUnlockConfirmationPopup             = 49,
	UMGArchivePassPurchasePopup              = 50,
	UMGArchiveTierPurchasePopup              = 51,
	UMGCurrencyConversionPopup               = 52,
	UMGDailyRitualsPopup                     = 53,
	UMGFearMarketPopup                       = 54,
	UMGFriendSearchPopup                     = 55,
	UMGGenericPopup                          = 56,
	UMGGenericTextInputPopup                 = 57,
	UMGProcessingPopup                       = 58,
	UMGProgressionSystemInfoPopup            = 59,
	UMGSeasonEndRankRewardsPopup             = 60,
	UMGUnlockPersonalPerksPopup              = 61,
	ChallengesMenu                           = 62,
	ProfileMenu                              = 63,
	EventEntryOverlay                        = 64,
	ShrineOfSecrets                          = 65,
	Inbox                                    = 66,
	News                                     = 67,
	AnimationPreview                         = 68,
	AuricCells                               = 69,
	Cinematic                                = 70,
	LoadoutMenu                              = 71,
	Settings                                 = 72,
	Count                                    = 73,
	EContext_MAX                             = 74,
};

// Enum DeadByDaylight.ECrossPromoCampaignsLoadResult
// NumValues: 0x0004
enum class ECrossPromoCampaignsLoadResult : uint8
{
	Loaded                                   = 0,
	Cached                                   = 1,
	Error                                    = 2,
	ECrossPromoCampaignsLoadResult_MAX       = 3,
};

// Enum DeadByDaylight.EOwnership
// NumValues: 0x0004
enum class EOwnership : uint8
{
	Owned                                    = 0,
	NotOwned                                 = 1,
	Any                                      = 2,
	EOwnership_MAX                           = 3,
};

// Enum DeadByDaylight.EItemDomain
// NumValues: 0x0005
enum class EItemDomain : uint8
{
	Store                                    = 0,
	EventStore                               = 1,
	Local                                    = 2,
	Any                                      = 3,
	EItemDomain_MAX                          = 4,
};

// Enum DeadByDaylight.EHudEditorDragAxisOption
// NumValues: 0x0004
enum class EHudEditorDragAxisOption : uint8
{
	PositiveSide                             = 0,
	NegativeSide                             = 1,
	BothSide                                 = 2,
	EHudEditorDragAxisOption_MAX             = 3,
};

// Enum DeadByDaylight.EUMGDailyRewardWidgetState
// NumValues: 0x0009
enum class EUMGDailyRewardWidgetState : uint8
{
	Unknown                                  = 0,
	Locked                                   = 1,
	ReadyToCollect                           = 2,
	NewlyCollected                           = 3,
	Collected                                = 4,
	MysteryLocked                            = 5,
	MysteryReadyToDiscover                   = 6,
	MysteryNewlyDiscovered                   = 7,
	EUMGDailyRewardWidgetState_MAX           = 8,
};

// Enum DeadByDaylight.EAIMovementPriority
// NumValues: 0x0007
enum class EAIMovementPriority : uint8
{
	Min                                      = 0,
	SuppressFootsteps                        = 10,
	ConversionDefault                        = 50,
	NavLinkOverride                          = 100,
	DangerObject                             = 120,
	SpecialAction                            = 150,
	EAIMovementPriority_MAX                  = 151,
};

// Enum DeadByDaylight.EAITerrorLevel
// NumValues: 0x0008
enum class EAITerrorLevel : uint8
{
	None                                     = 0,
	Low                                      = 1,
	Min                                      = 1,
	Medium                                   = 2,
	High                                     = 3,
	VeryHigh                                 = 4,
	Max                                      = 4,
	EAITerrorLevel_MAX                       = 5,
};

// Enum DeadByDaylight.ECharacterMovementTypes
// NumValues: 0x0004
enum class ECharacterMovementTypes : uint8
{
	Normal                                   = 0,
	Run                                      = 1,
	Crouch                                   = 2,
	ECharacterMovementTypes_MAX              = 3,
};

// Enum DeadByDaylight.EAIDifficultyLevel
// NumValues: 0x0009
enum class EAIDifficultyLevel : uint8
{
	VeryEasy                                 = 0,
	Easy                                     = 1,
	Medium                                   = 2,
	Hard                                     = 3,
	Suggested                                = 4,
	Random                                   = 5,
	None                                     = 6,
	Max                                      = 6,
	EAIDifficultyLevel_MAX                   = 7,
};

// Enum DeadByDaylight.EPawnInputPressTypes
// NumValues: 0x0015
enum class EPawnInputPressTypes : uint8
{
	None                                     = 0,
	FastInteract                             = 1,
	Interact                                 = 2,
	Struggle                                 = 3,
	Slash                                    = 4,
	Attack                                   = 5,
	Action                                   = 6,
	SecondaryAction                          = 7,
	UseItem                                  = 8,
	DropItem                                 = 9,
	Gesture01                                = 10,
	Gesture02                                = 11,
	Gesture03                                = 12,
	Gesture04                                = 13,
	Run                                      = 14,
	RunningFastInteraction                   = 15,
	AbilityTwo                               = 16,
	CancelMinigame                           = 17,
	AbilityTwoCrouch                         = 18,
	EventAbility                             = 19,
	EPawnInputPressTypes_MAX                 = 20,
};

// Enum DeadByDaylight.EInLockerSkillsContext
// NumValues: 0x0004
enum class EInLockerSkillsContext : uint8
{
	None                                     = 0,
	Goal                                     = 1,
	OutOfTerrorRadius                        = 2,
	EInLockerSkillsContext_MAX               = 3,
};

// Enum DeadByDaylight.EAIDodgeType
// NumValues: 0x0004
enum class EAIDodgeType : uint8
{
	FORWARD_SIDE_STEP                        = 0,
	SIDE_STEP                                = 1,
	BACKWARD_SIDE_STEP                       = 2,
	EAIDodgeType_MAX                         = 3,
};

// Enum DeadByDaylight.EAIDodgeTechnique
// NumValues: 0x0003
enum class EAIDodgeTechnique : uint8
{
	SpecialAttack_Dodge_KeepDistance         = 0,
	SpecialAttack_Dodge_SimultaneousProjectiles = 1,
	SpecialAttack_Dodge_MAX                  = 2,
};

// Enum DeadByDaylight.EKillerAttackType
// NumValues: 0x0004
enum class EKillerAttackType : uint8
{
	None                                     = 0,
	MeleeAttack                              = 1,
	SpecialAttack                            = 2,
	EKillerAttackType_MAX                    = 3,
};

// Enum DeadByDaylight.ECustomMovementMode
// NumValues: 0x0003
enum class ECustomMovementMode : uint8
{
	CUSTOM_MOVE_None                         = 0,
	CUSTOM_MOVE_Snapping                     = 1,
	CUSTOM_MOVE_MAX                          = 2,
};

// Enum DeadByDaylight.EDangerTraverseState
// NumValues: 0x0006
enum class EDangerTraverseState : uint8
{
	SAFE                                     = 0,
	WAIT                                     = 1,
	TRAVERSE_CROUCH                          = 2,
	TRAVERSE_RUN                             = 3,
	UNDODGEABLE                              = 4,
	EDangerTraverseState_MAX                 = 5,
};

// Enum DeadByDaylight.EDangerTraversePriority
// NumValues: 0x0004
enum class EDangerTraversePriority : uint8
{
	Low                                      = 0,
	Medium                                   = 1,
	High                                     = 2,
	EDangerTraversePriority_MAX              = 3,
};

// Enum DeadByDaylight.ESurvivorFleePathStrategy
// NumValues: 0x0004
enum class ESurvivorFleePathStrategy : uint8
{
	None                                     = 0,
	HideFromLos                              = 1,
	LeaveTrajectory                          = 2,
	ESurvivorFleePathStrategy_MAX            = 3,
};

// Enum DeadByDaylight.EDiceRollType
// NumValues: 0x0007
enum class EDiceRollType : uint8
{
	VE_EscapeHook                            = 0,
	VE_EscapeTrap                            = 1,
	VE_TrapInflictsDying                     = 2,
	VE_TriggerSkillCheck                     = 3,
	VE_TriggerFootNoise                      = 4,
	VE_TriggerCrowAlert                      = 5,
	VE_MAX                                   = 6,
};

// Enum DeadByDaylight.EDisconnectErrors
// NumValues: 0x001B
enum class EDisconnectErrors : uint8
{
	None                                     = 0,
	SteamAuthFailure                         = 1,
	SteamAuthFailureKickedFromServer         = 2,
	EACServerValidationFailure               = 3,
	EACValidationFailureKickedFromServer     = 4,
	EACClientNotRunning                      = 5,
	EACClientIntegrityViolation              = 6,
	PlayerRemovedOnSuspend                   = 7,
	LostConnectionToHost                     = 8,
	LostConnectionToProfileService           = 9,
	MirrorsUnscheduledSessionDestruction     = 10,
	SessionKilledByMirrors                   = 11,
	UnableToSaveProfileAfterRetries          = 12,
	UnableToGetPlayerLevel                   = 13,
	UnableToEarnPlayerXp                     = 14,
	UnableToUpdatePips                       = 15,
	UnableToUpdateRatings                    = 16,
	ClientProviderAuthenticationFailed       = 17,
	UnableToSyncCachedCurrency               = 18,
	OwnershipValidationFailure               = 19,
	UnableToUpdateEndOfMatchInfo             = 20,
	TravelFailure                            = 21,
	SessionKilledByServerLost                = 22,
	SessionKilledByServerTimeout             = 23,
	SessionKilledByClientLostNetwork         = 24,
	PlayerRemovedMatchingKiller              = 25,
	EDisconnectErrors_MAX                    = 26,
};

// Enum DeadByDaylight.EDBDEasyAntiCheatInitStatus
// NumValues: 0x0005
enum class EDBDEasyAntiCheatInitStatus : uint8
{
	Uninitialized                            = 0,
	Initialized                              = 1,
	Error_FailedToInit                       = 2,
	Error_UserIsBanned                       = 3,
	EDBDEasyAntiCheatInitStatus_MAX          = 4,
};

// Enum DeadByDaylight.EEmblemEvaluation
// NumValues: 0x0003
enum class EEmblemEvaluation : uint8
{
	Authority                                = 0,
	Local                                    = 1,
	EEmblemEvaluation_MAX                    = 2,
};

// Enum DeadByDaylight.EEmblemQuality
// NumValues: 0x0007
enum class EEmblemQuality : uint8
{
	None                                     = 0,
	Bronze                                   = 1,
	Silver                                   = 2,
	Gold                                     = 3,
	Iridescent                               = 4,
	Count                                    = 5,
	EEmblemQuality_MAX                       = 6,
};

// Enum DeadByDaylight.EEmblemProgressionType
// NumValues: 0x002A
enum class EEmblemProgressionType : uint8
{
	SurvivorLightbringerStartingValue        = 0,
	SurvivorLightbringerGeneratorRepair      = 1,
	SurvivorLightbringerTotemCleanse         = 2,
	SurvivorLightbringerKillerDiversion      = 3,
	SurvivorLightbringerExitGameOpen         = 4,
	SurvivorUnbrokenTimeAlive                = 5,
	SurvivorBenevolentStartingValue          = 6,
	SurvivorBenevolentHealing                = 7,
	SurvivorBenevolentHooked                 = 8,
	SurvivorBenevolentUnhook                 = 9,
	SurvivorBenevolentPerformUnhook          = 10,
	SurvivorBenevolentSaveFromKiller         = 11,
	SurvivorBenevolentUnsafeUnhook           = 12,
	SurvivorBenevolentHitWhileCarrying       = 13,
	SurvivorEvaderStartingValue              = 14,
	SurvivorEvaderSneaking                   = 15,
	SurvivorEvaderChaseWon                   = 16,
	SurvivorEvaderChaseLost                  = 17,
	SurvivorEvaderPalletStun                 = 18,
	KillerGatekeeperStartingValue            = 19,
	KillerGatekeeperGeneratorDefense         = 20,
	KillerGatekeeperGatesClosed              = 21,
	KillerDevoutStartingValue                = 22,
	KillerDevoutSacrifice                    = 23,
	KillerDevoutDisconnect                   = 24,
	KillerDevoutMoris                        = 25,
	KillerDevoutAllSurvivorsHooked           = 26,
	KillerDevoutHooksBonus                   = 27,
	KillerMaliciousStartingValue             = 28,
	KillerMaliciousInjuries                  = 29,
	KillerMaliciousHookStages                = 30,
	KillerMaliciousInjuriesHealed            = 31,
	KillerMaliciousEscapeGrasp               = 32,
	KillerMaliciousDisconnect                = 33,
	KillerChaserStartingValue                = 34,
	KillerChaserSurvivorFound                = 35,
	KillerChaserSurvivorLost                 = 36,
	KillerChaserHit                          = 37,
	KillerChaserChaseWon                     = 38,
	KillerChaserProximityToHookPenalty       = 39,
	Invalid                                  = 40,
	EEmblemProgressionType_MAX               = 41,
};

// Enum DeadByDaylight.EErrorCodes
// NumValues: 0x002C
enum class EErrorCodes : uint16
{
	None                                     = 0,
	SavefileDeserializationFailure           = 100,
	SavefileDecryptionFailure                = 101,
	SavefileEmpty                            = 102,
	SavefileBadPlayerId                      = 103,
	SavefileEmptyPlayerUID                   = 104,
	SavefileInvalidUniqueNetID               = 105,
	SavefileInvalidPlayerState               = 106,
	SavefileBackendError                     = 107,
	KrakenRankError                          = 108,
	KrakenRatingsError                       = 109,
	SavefileKrakenPlayerForbidden            = 110,
	SyncCachedCurrencyError                  = 111,
	CurrencyTransactionError                 = 112,
	StateDownloadFailed                      = 113,
	StatcacheDecryptionFailed                = 114,
	SavefilePlayerLoadUIDMismatch            = 115,
	SavefilePlayerStateUIDMismatch           = 116,
	CharacterMigrationGetError               = 130,
	CharacterMigrationGetError_BadProfile    = 131,
	SavefileEncryptionFailure                = 200,
	SaveFailedInvalidData                    = 201,
	SaveFailedInvalidJSON                    = 202,
	SaveFailedDecodeDataString               = 203,
	SaveFailedCompressDataString             = 204,
	SaveFailedEncryptString                  = 205,
	StatcacheEncryptionFailed                = 206,
	SaveFailedCloudErrorTimeout              = 300,
	JsonToPersistenDataFailed                = 301,
	SaveFailedCloudErrorAfterRetries         = 302,
	StateUploadFailed                        = 303,
	GetPlayerLevelRequestError               = 400,
	EarnPlayerXpRequestError                 = 401,
	EarnPlayerXpParamError                   = 402,
	EndOfMatchError                          = 403,
	OnboardingFailGet                        = 410,
	OnboardingFailUpdate                     = 411,
	OnboardingFailRequest                    = 412,
	MatchCancelledPlayerLeftDuringLoading    = 500,
	MatchCancelledInvalidPlayerRoles         = 501,
	MatchCancelledLoadingTimeout             = 502,
	PakValidationFailed                      = 600,
	KrakenSdkMismatch                        = 601,
	EErrorCodes_MAX                          = 602,
};

// Enum DeadByDaylight.EQuitGameReason
// NumValues: 0x0006
enum class EQuitGameReason : uint8
{
	None                                     = 0,
	Logout                                   = 1,
	Suspend                                  = 2,
	Shutdown                                 = 3,
	Count                                    = 4,
	EQuitGameReason_MAX                      = 5,
};

// Enum DeadByDaylight.ELevelLoadingSteps
// NumValues: 0x0012
enum class ELevelLoadingSteps : uint8
{
	Invalid                                  = 0,
	WaitingForProceduralLevelBuilder         = 1,
	WaitingForPlayersToBeSpawned             = 2,
	WaitingForAIPawnToBeSpawned              = 3,
	WaitingForKillerSpecificStateComponentLogic = 4,
	WaitingForMapSpecificComponentLogic      = 5,
	WaitingForAssetPreloader                 = 6,
	WaitingForLoadoutAndTheme                = 7,
	WaitingForPIAToBeSpawnedAndInitialized   = 8,
	WaitingForNavmeshComputation             = 9,
	WaitingForMutatorsComponentLogic         = 10,
	WaitingForAIInitialization               = 11,
	SetGameLoadedAndReadyToPlay              = 12,
	WaitingForIntroToBeDone                  = 13,
	LoadingCompleted                         = 14,
	FirstLoadingStep                         = 1,
	Count                                    = 14,
	ELevelLoadingSteps_MAX                   = 15,
};

// Enum DeadByDaylight.ELoadProgress
// NumValues: 0x0070
enum class ELoadProgress : uint8
{
	NotStarted                               = 0,
	Init                                     = 1,
	SetupPIE                                 = 2,
	ArtificialDelay                          = 3,
	DisconnectingPresencePlugin              = 4,
	ValidateOnlineSubsystem                  = 5,
	CheckingPlatformService                  = 6,
	SecondAccountLoginCheck                  = 7,
	ConnectingToMirrors                      = 8,
	StartEAC                                 = 9,
	LoadingAuthInfo                          = 10,
	LoadingBackendConfigs                    = 11,
	SetupRichPresence                        = 12,
	LoadingBackendTunables                   = 13,
	ApplyingCDNPatch                         = 14,
	AquiringExternalAuthentication           = 15,
	LoadingPlayerIndependentShopData         = 16,
	LicenseCache                             = 17,
	LoadingExperiments                       = 18,
	LoadingEvents                            = 19,
	LoadingBonusPointEvents                  = 20,
	LoadingEventTrackerObjectives            = 21,
	LoadingInventory                         = 22,
	LoadingCinematics                        = 23,
	SyncingOwnedCharacters                   = 24,
	LoadingProfile                           = 25,
	LoadingMirrorCurrencies                  = 26,
	LoadingWallet                            = 27,
	LoadingConsent                           = 28,
	LoadingGameConfigs                       = 29,
	LoadingCharacterXPTables                 = 30,
	CheckingPendingTransactions              = 31,
	LoadingContentSchedule                   = 32,
	LoadingNews                              = 33,
	SendingAnalytics                         = 34,
	LoadingDailyRituals                      = 35,
	LoadingLimitedTimeGameModes              = 36,
	ReconcilingEventCurrencies               = 37,
	CalculatingLatencies                     = 38,
	ValidateData                             = 39,
	ValidatingClientVersion                  = 40,
	CheckingNeedForCurrencyMigration         = 41,
	MigratingCurrenciesToMirror              = 42,
	SyncingFriendsList                       = 43,
	Complete                                 = 44,
	Locating                                 = 45,
	InitializingRTMConnection                = 46,
	LoadingStreamVideoData                   = 47,
	CollectingFreeCatalogItems               = 48,
	DownloadDynamicContent                   = 49,
	LoadingMysteryBoxes                      = 50,
	CheckingMobilePendingTransactions        = 51,
	LoadMarketingBanners                     = 52,
	LoadingSubscriptionStatus                = 53,
	RequestingTrackingAuthorization          = 54,
	LoadingCrossPromoCampaignsContent        = 55,
	LoadingExperimentalFeatures              = 56,
	LoadingMatchIncentives                   = 57,
	LoadingLoadoutPresets                    = 58,
	LoadingCustomizationPresets              = 59,
	LoadingMarketingConsentData              = 60,
	LoadingBackendCharacterData              = 61,
	LoadingPrestige                          = 62,
	UpdatingPlatformStoreContent             = 63,
	UpdatingOwnedContent                     = 64,
	LoadingShrine                            = 65,
	LoadingReportFeedback                    = 66,
	CheckingAutoLoginStatus                  = 67,
	ValidatingUserLogin                      = 68,
	ValidatingPrivileges                     = 69,
	QueryingAchievements                     = 70,
	UpdatingChatPrivilege                    = 71,
	CheckingPlatformServices                 = 72,
	RequestingOnlineContextCreation          = 73,
	RequestingAuthenticationCode             = 74,
	SetupBackendEndpoint                     = 75,
	SettingProviderPlayerName                = 76,
	SettingBackendPlayerName                 = 77,
	LoadingBlocklist                         = 78,
	LoadingEquippedPlayerCard                = 79,
	LoadingMessages                          = 80,
	LoadingInbox                             = 81,
	ClaimingMessages                         = 82,
	UpdatingCrossplayPrivilege               = 83,
	RequestingTrial                          = 84,
	CheckingApplication                      = 85,
	CheckingControllerAction                 = 86,
	ReportingAvailableContent                = 87,
	LoadingStatCache                         = 88,
	LoadingPips                              = 89,
	LoadingPlayerStats                       = 90,
	SetupEnvironmentStats                    = 91,
	ProccessingShopErrors                    = 92,
	LoadingBackendData                       = 93,
	LoadingOnboarding                        = 94,
	InitializingShaders                      = 95,
	GrantingCrossPromoItems                  = 96,
	UpdatingGifts                            = 97,
	UpdatingKeplerGiftAction                 = 98,
	SettingNetworkInterface                  = 99,
	LoadingChallenges                        = 100,
	ValidatingKrakenSDKVersion               = 101,
	LoadingCollectionsData                   = 102,
	LoadingRecommendationsData               = 103,
	CheckingSoftBan                          = 104,
	UpdatingSpecialPacks                     = 105,
	CheckingCustomIcons                      = 106,
	FilterCustomizationDuplicates            = 107,
	LoadingGameConfigsDS                     = 108,
	LoadingCatalog                           = 109,
	LoadingS3PrestigeData                    = 110,
	ELoadProgress_MAX                        = 111,
};

// Enum DeadByDaylight.EActivePlayerBitmask
// NumValues: 0x0006
enum class EActivePlayerBitmask : uint8
{
	HumanPlayer                              = 1,
	RegularBot                               = 2,
	ReplacementBot                           = 4,
	AllBots                                  = 6,
	All                                      = 7,
	EActivePlayerBitmask_MAX                 = 8,
};

// Enum DeadByDaylight.EGameIntroSteps
// NumValues: 0x0004
enum class EGameIntroSteps : uint8
{
	Idling                                   = 0,
	PlayingIntro                             = 1,
	LoopingCamView                           = 2,
	EGameIntroSteps_MAX                      = 3,
};

// Enum DeadByDaylight.EProceduralDebugMode
// NumValues: 0x0006
enum class EProceduralDebugMode : uint8
{
	None                                     = 0,
	NoMap                                    = 1,
	TilesSmall                               = 2,
	TilesBig                                 = 3,
	Count                                    = 4,
	EProceduralDebugMode_MAX                 = 5,
};

// Enum DeadByDaylight.EAIEvadeLoopSides
// NumValues: 0x0004
enum class EAIEvadeLoopSides : uint8
{
	Left                                     = 0,
	Right                                    = 1,
	Count                                    = 2,
	EAIEvadeLoopSides_MAX                    = 3,
};

// Enum DeadByDaylight.ECharacterStance
// NumValues: 0x0004
enum class ECharacterStance : uint8
{
	VE_Stand                                 = 0,
	VE_Crouch                                = 1,
	VE_Crawl                                 = 2,
	VE_MAX                                   = 3,
};

// Enum DeadByDaylight.EPlayerMovementDirection
// NumValues: 0x0005
enum class EPlayerMovementDirection : uint8
{
	Left                                     = 0,
	Right                                    = 1,
	Forward                                  = 2,
	Backward                                 = 3,
	EPlayerMovementDirection_MAX             = 4,
};

// Enum DeadByDaylight.EAuthoritativeMovementFlag
// NumValues: 0x000A
enum class EAuthoritativeMovementFlag : uint8
{
	INTERACTION                              = 0,
	SLASHED                                  = 1,
	CHEAT                                    = 2,
	DROPPED                                  = 3,
	NOPUSH                                   = 4,
	INTERACTIONNOPUSH                        = 5,
	DREAMWORLD_NOSLASHERCOLLISION            = 6,
	NOPUSHFORCED                             = 7,
	COUNT                                    = 8,
	EAuthoritativeMovementFlag_MAX           = 9,
};

// Enum DeadByDaylight.EPlayerGameplayEventType
// NumValues: 0x0004
enum class EPlayerGameplayEventType : uint8
{
	VE_UnhookedOther                         = 0,
	VE_UntrappedOther                        = 1,
	VE_HealedOther                           = 2,
	VE_MAX                                   = 3,
};

// Enum DeadByDaylight.EBotReplacementState
// NumValues: 0x0004
enum class EBotReplacementState : uint8
{
	NotReplacedWithBot                       = 0,
	BeingReplacedWithBot                     = 1,
	ReplacedWithBot                          = 2,
	EBotReplacementState_MAX                 = 3,
};

// Enum DeadByDaylight.EVisibleMenuActorType
// NumValues: 0x0005
enum class EVisibleMenuActorType : uint8
{
	None                                     = 0,
	Pawn                                     = 1,
	Hook                                     = 2,
	Charm                                    = 3,
	EVisibleMenuActorType_MAX                = 4,
};

// Enum DeadByDaylight.EDBDSRState
// NumValues: 0x0005
enum class EDBDSRState : uint8
{
	NotInitialized                           = 0,
	Processing                               = 1,
	FinishSuccess                            = 2,
	FinishFail                               = 3,
	EDBDSRState_MAX                          = 4,
};

// Enum DeadByDaylight.EDBDSRItemType
// NumValues: 0x0008
enum class EDBDSRItemType : uint8
{
	None                                     = 0,
	Badge                                    = 1,
	Charm                                    = 2,
	Outfit                                   = 3,
	OutfitPiece                              = 4,
	Currency                                 = 5,
	Progression                              = 6,
	EDBDSRItemType_MAX                       = 7,
};

// Enum DeadByDaylight.EToastInputType
// NumValues: 0x0004
enum class EToastInputType : uint8
{
	Toast_Accept                             = 0,
	Toast_Reject                             = 1,
	Toast_Close                              = 2,
	Toast_MAX                                = 3,
};

// Enum DeadByDaylight.EShadowSystem
// NumValues: 0x0003
enum class EShadowSystem : uint8
{
	CascadedShadowMap                        = 0,
	AdaptiveShadowMap                        = 1,
	EShadowSystem_MAX                        = 2,
};

// Enum DeadByDaylight.DBDScalabilityLevel
// NumValues: 0x0006
enum class EDBDScalabilityLevel : uint8
{
	LOW                                      = 0,
	MEDIUM                                   = 1,
	HIGH                                     = 2,
	EPIC                                     = 3,
	ULTRA                                    = 4,
	DBDScalabilityLevel_MAX                  = 5,
};

// Enum DeadByDaylight.EDSKickOutReason
// NumValues: 0x0005
enum class EDSKickOutReason : uint8
{
	DSCharacter_Validation                   = 0,
	DSCharacterClass_KillerReachedMax        = 1,
	DSLoadoutItem_Validation                 = 2,
	DSCharacter_Ownership_Validation         = 3,
	EDSKickOutReason_MAX                     = 4,
};

// Enum DeadByDaylight.EDisplayStandActorType
// NumValues: 0x0005
enum class EDisplayStandActorType : uint8
{
	None                                     = 0,
	Character                                = 1,
	Hook                                     = 2,
	Charm                                    = 3,
	EDisplayStandActorType_MAX               = 4,
};

// Enum DeadByDaylight.EDisplayStandMeatHookOverrideType
// NumValues: 0x0003
enum class EDisplayStandMeatHookOverrideType : uint32
{
	ForCharacter                             = 0,
	ForEvent                                 = 1,
	EDisplayStandMeatHookOverrideType_MAX    = 2,
};

// Enum DeadByDaylight.EDoctorAbilityType
// NumValues: 0x0004
enum class EDoctorAbilityType : uint8
{
	VE_ShockTherapy                          = 0,
	VE_StaticBlast                           = 1,
	VE_None                                  = 2,
	VE_MAX                                   = 3,
};

// Enum DeadByDaylight.EDoctorAbilityPhase
// NumValues: 0x0004
enum class EDoctorAbilityPhase : uint8
{
	VE_Charging                              = 0,
	VE_Firing                                = 1,
	VE_None                                  = 2,
	VE_MAX                                   = 3,
};

// Enum DeadByDaylight.EEndGameScenarioTrigger
// NumValues: 0x0005
enum class EEndGameScenarioTrigger : uint8
{
	ClosedHatch                              = 0,
	OpenedGate                               = 1,
	CheatUsed                                = 2,
	NotActivated                             = 3,
	EEndGameScenarioTrigger_MAX              = 4,
};

// Enum DeadByDaylight.EEnergyTypeEnum
// NumValues: 0x0004
enum class EEnergyTypeEnum : uint8
{
	EInvalid                                 = 0,
	EBattery                                 = 1,
	EHealth                                  = 2,
	EEnergyTypeEnum_MAX                      = 3,
};

// Enum DeadByDaylight.EErrorEventType
// NumValues: 0x0008
enum class EErrorEventType : uint8
{
	FailedToCalculateRankProgress            = 0,
	FailedToEarnPlayerXp                     = 1,
	FailedToGrandBloodPoints                 = 2,
	FailedToSyncWalletChanges                = 3,
	InvalidLobbyId                           = 4,
	InvalidGameState                         = 5,
	InvalidSessionId                         = 6,
	EErrorEventType_MAX                      = 7,
};

// Enum DeadByDaylight.EEscapeDoorActivationMode
// NumValues: 0x0003
enum class EEscapeDoorActivationMode : uint8
{
	Standard                                 = 0,
	Tutorial                                 = 1,
	EEscapeDoorActivationMode_MAX            = 2,
};

// Enum DeadByDaylight.EConditionSubject
// NumValues: 0x0003
enum class EConditionSubject : uint8
{
	Instigator                               = 0,
	Target                                   = 1,
	EConditionSubject_MAX                    = 2,
};

// Enum DeadByDaylight.EEventItemContentType
// NumValues: 0x000C
enum class EEventItemContentType : uint8
{
	None                                     = 0,
	Cells                                    = 1,
	Character                                = 2,
	Customization                            = 3,
	NameChangeCard                           = 4,
	FreeTicket                               = 5,
	OtherCurrency                            = 6,
	Item                                     = 7,
	Addon                                    = 8,
	Offering                                 = 9,
	Count                                    = 10,
	EEventItemContentType_MAX                = 11,
};

// Enum DeadByDaylight.ELoadoutType
// NumValues: 0x0004
enum class ELoadoutType : uint8
{
	Item                                     = 0,
	Perk                                     = 1,
	Offering                                 = 2,
	ELoadoutType_MAX                         = 3,
};

// Enum DeadByDaylight.FlickeringLightType
// NumValues: 0x0004
enum class EFlickeringLightType : uint32
{
	Point                                    = 0,
	Rect                                     = 1,
	Spot                                     = 2,
	FlickeringLightType_MAX                  = 3,
};

// Enum DeadByDaylight.EFriendUIRichPresence
// NumValues: 0x0007
enum class EFriendUIRichPresence : uint8
{
	Undefined                                = 0,
	InMenus                                  = 1,
	InLobby                                  = 2,
	InMatch                                  = 3,
	Connected                                = 4,
	Closing                                  = 5,
	EFriendUIRichPresence_MAX                = 6,
};

// Enum DeadByDaylight.EFriendUIStatus
// NumValues: 0x0008
enum class EFriendUIStatus : uint8
{
	Offline                                  = 0,
	Online                                   = 1,
	PlayingDBD                               = 2,
	PendingSentRequest                       = 3,
	PendingReceivedRequest                   = 4,
	NotFriend                                = 5,
	Self                                     = 6,
	EFriendUIStatus_MAX                      = 7,
};

// Enum DeadByDaylight.ETileClassType
// NumValues: 0x0006
enum class ETileClassType : uint8
{
	None                                     = 0,
	Normal                                   = 1,
	Border                                   = 2,
	Escape                                   = 3,
	Count                                    = 4,
	ETileClassType_MAX                       = 5,
};

// Enum DeadByDaylight.EGameFlowStep
// NumValues: 0x000B
enum class EGameFlowStep : uint8
{
	None                                     = 0,
	InGameIntro                              = 1,
	InGame                                   = 2,
	OfflineLobby                             = 3,
	OfflineTally                             = 4,
	OnlineLobby                              = 5,
	SplashScreen                             = 6,
	PartyLobby                               = 7,
	Store                                    = 8,
	MainMenu                                 = 9,
	EGameFlowStep_MAX                        = 10,
};

// Enum DeadByDaylight.EWorldFlowEvent
// NumValues: 0x000C
enum class EWorldFlowEvent : uint8
{
	None                                     = 0,
	GameLevelLoaded                          = 1,
	LoadingGameLevel                         = 2,
	GameIntroCompleted                       = 3,
	LoadingOfflineParadise                   = 4,
	LoadingOnlineLobbyLevel                  = 5,
	OfflineLobbyMapLoaded                    = 6,
	OfflineParadiseLoaded                    = 7,
	OnlineLobbyMapLoaded                     = 8,
	StartScreenMapLoaded                     = 9,
	LoadingSplashScreen                      = 10,
	EWorldFlowEvent_MAX                      = 11,
};

// Enum DeadByDaylight.EUIFlowEvent
// NumValues: 0x000C
enum class EUIFlowEvent : uint8
{
	None                                     = 0,
	AtlantaMainMenuScreenReady               = 1,
	AtlantaNavigationScreenReady             = 2,
	InGameHudReady                           = 3,
	LoadingScreenReady                       = 4,
	OnlineLobbyScreenReady                   = 5,
	MainMenuScreenReady                      = 6,
	SplashScreenReady                        = 7,
	TallyScreenReady                         = 8,
	PartyLobbyScreenReady                    = 9,
	StoreScreenReady                         = 10,
	EUIFlowEvent_MAX                         = 11,
};

// Enum DeadByDaylight.EFlowTransitionType
// NumValues: 0x0007
enum class EFlowTransitionType : uint8
{
	Tally                                    = 0,
	OnlineLobby                              = 1,
	PartyLobby                               = 2,
	Splash                                   = 3,
	MainMenu                                 = 4,
	None                                     = 5,
	EFlowTransitionType_MAX                  = 6,
};

// Enum DeadByDaylight.EActivatedGenerators_ObjectiveCountType
// NumValues: 0x0005
enum class EActivatedGenerators_ObjectiveCountType : uint8
{
	Invalid                                  = 0,
	Static                                   = 1,
	Players                                  = 2,
	All                                      = 3,
	EActivatedGenerators_MAX                 = 4,
};

// Enum DeadByDaylight.EGameplayModifierSource
// NumValues: 0x0009
enum class EGameplayModifierSource : uint8
{
	VE_Perk                                  = 0,
	VE_StatusEffect                          = 1,
	VE_Item                                  = 2,
	VE_ItemAddon                             = 3,
	VE_All                                   = 4,
	VE_PerkOrStatusEffect                    = 5,
	VE_PerkStatusOrAddon                     = 6,
	VE_Skill                                 = 7,
	VE_MAX                                   = 8,
};

// Enum DeadByDaylight.EGameTypeModifierName
// NumValues: 0x0050
enum class EGameTypeModifierName : uint8
{
	Invalid                                  = 0,
	AllowsAchievementProgression             = 1,
	AllowsBloodpointGain                     = 2,
	AllowsItemAddons                         = 3,
	AllowsProgression                        = 4,
	CanTransitionToStore                     = 5,
	CanUseBetaFeatures                       = 6,
	CanZoomOnCharms                          = 7,
	CreatesSession                           = 8,
	IsMultiplayer                            = 9,
	KeepsItemAfterGame                       = 10,
	LocksPerksUntilProgression               = 11,
	MenuNavigationDataHasRoleSuffix          = 12,
	RequiresKillerOfflineLobby               = 13,
	SendsAnalyticsForBotPlayer               = 14,
	SendsGameStartEvent                      = 15,
	SendsHookedAnalytics                     = 16,
	SupportsCommentator                      = 17,
	SupportsGameplaySpawners                 = 18,
	SupportsMatchIncentives                  = 19,
	SupportsMatchmakingBan                   = 20,
	SupportsObsession                        = 21,
	UsesMatchmaking                          = 22,
	AllowsUsingLastChocolateBox              = 23,
	RequiresDSValidation                     = 24,
	SpawnsBasementTile                       = 25,
	RequiresLobbyCharacterOwnershipValidation = 26,
	AllowsChangingRole                       = 27,
	AllowsLoadout                            = 28,
	AllowsQuestProgression                   = 29,
	CanDisableFogOverrides                   = 30,
	CanUseActiveSpecialEvent                 = 31,
	ForcesDefaultCustomization               = 32,
	HasMatchRules                            = 33,
	IsABotMatchType                          = 34,
	IsLimitedTimeExperience                  = 35,
	ModifiesGamePreset                       = 36,
	PartySupportsBothRoles                   = 37,
	PerksAreMaximumLevel                     = 38,
	RequiresDataBackup                       = 39,
	SendsExtraOnboardingAnalytics            = 40,
	SupportsBots                             = 41,
	SupportsSecretBots                       = 42,
	UsesCharacterClass                       = 43,
	UsesOnlineModeLoadout                    = 44,
	UsesCustomCustomizationPreset            = 45,
	DisablesLicensedCustomization            = 46,
	AlwaysSpawnKillersTogether               = 47,
	AlwaysSpawnSurvivorsTogether             = 48,
	AlwaysSpawnSurvivorsFarthestFromKiller   = 49,
	AllowsAllEventItems                      = 50,
	AllowsEventItemsInChests                 = 51,
	MaxAllowedObservers                      = 52,
	MaxKillersToStartMatch                   = 53,
	MaxSurvivorsToStartMatch                 = 54,
	MinKillersToStartMatch                   = 55,
	MinSurvivorsToStartMatch                 = 56,
	MaxBotReplacementKillersDuringMapLoading = 57,
	MaxBotReplacementSurvivorsDuringMapLoading = 58,
	NumLoadoutPresets                        = 59,
	InGameChestCountModifier                 = 60,
	GeneratorCount                           = 61,
	EscapeHatchCount                         = 62,
	EscapeDoorCount                          = 63,
	DefaultBotSightRange                     = 64,
	AllowsLoadoutItemAddons                  = 65,
	AllowsLoadoutItems                       = 66,
	AllowsLoadoutOfferings                   = 67,
	AllowsLoadoutPerks                       = 68,
	AudioGroupState                          = 69,
	LevelLightingOverride                    = 70,
	MenuNavigationDataPrefix                 = 71,
	ChocolateBoxPoolType                     = 72,
	DisabledInventory                        = 73,
	DisabledPanelTabs                        = 74,
	ChocolateBoxCategories                   = 75,
	PrespecifiedChocolateBoxIds              = 76,
	AllowExtraItemsInChests                  = 77,
	DisallowItemsInChests                    = 78,
	EGameTypeModifierName_MAX                = 79,
};

// Enum DeadByDaylight.EFlexibleTunableType
// NumValues: 0x0006
enum class EFlexibleTunableType : uint8
{
	BooleanTunable                           = 0,
	FloatTunable                             = 1,
	IntTunable                               = 2,
	StringTunable                            = 3,
	StringArrayTunable                       = 4,
	EFlexibleTunableType_MAX                 = 5,
};

// Enum DeadByDaylight.EGateType
// NumValues: 0x0003
enum class EGateType : uint8
{
	VE_AndGate                               = 0,
	VE_TimerGate                             = 1,
	VE_MAX                                   = 2,
};

// Enum DeadByDaylight.EGestureID
// NumValues: 0x0003
enum class EGestureID : uint8
{
	POINT                                    = 0,
	COME                                     = 1,
	EGestureID_MAX                           = 2,
};

// Enum DeadByDaylight.EHatchState
// NumValues: 0x0005
enum class EHatchState : uint8
{
	Hidden                                   = 0,
	DefaultClose                             = 1,
	Opened                                   = 2,
	ForcedClose                              = 3,
	EHatchState_MAX                          = 4,
};

// Enum DeadByDaylight.EHookType
// NumValues: 0x0004
enum class EHookType : uint8
{
	Hook                                     = 0,
	DeathBed                                 = 1,
	None                                     = 2,
	EHookType_MAX                            = 3,
};

// Enum DeadByDaylight.EHookDrainStage
// NumValues: 0x0006
enum class EHookDrainStage : uint8
{
	None                                     = 0,
	Idle                                     = 1,
	Struggle                                 = 2,
	Sacrifice                                = 3,
	Count                                    = 4,
	EHookDrainStage_MAX                      = 5,
};

// Enum DeadByDaylight.EndSessionAction
// NumValues: 0x0003
enum class EndSessionAction : uint8
{
	Restart                                  = 0,
	Shutdown                                 = 1,
	EndSessionAction_MAX                     = 2,
};

// Enum DeadByDaylight.EKeyBindingsCategories
// NumValues: 0x0006
enum class EKeyBindingsCategories : uint64
{
	None                                     = 18446744073709551615,
	Movement                                 = 0,
	Interactions                             = 1,
	Camera                                   = 2,
	Gestures                                 = 3,
	EKeyBindingsCategories_MAX               = 4,
};

// Enum DeadByDaylight.EKeyBindingsType
// NumValues: 0x0028
enum class EKeyBindingsType : uint64
{
	None                                     = 18446744073709551615,
	Run                                      = 0,
	Crouch                                   = 1,
	UseItem                                  = 2,
	DropItemSurvivor                         = 3,
	PickUpItem                               = 4,
	ActionSurvivor                           = 5,
	SecondaryActionSurvivor                  = 6,
	AbilitySurvivor                          = 7,
	AbilityTwoSurvivor                       = 8,
	EventAbilitySurvivor                     = 9,
	Gesture1                                 = 10,
	Gesture2                                 = 11,
	WiggleRightSkillCheck                    = 12,
	WiggleLeftSkillCheck                     = 13,
	Attack                                   = 14,
	Power                                    = 15,
	SecondaryPower                           = 16,
	EventAbilityKiller                       = 17,
	DropSurvivor                             = 18,
	PickUp                                   = 19,
	Aim                                      = 20,
	ForwardSurvivor                          = 21,
	BackSurvivor                             = 22,
	LeftSurvivor                             = 23,
	RightSurvivor                            = 24,
	CameraUpSurvivor                         = 25,
	CameraDownSurvivor                       = 26,
	CameraLeftSurvivor                       = 27,
	CameraRightSurvivor                      = 28,
	ForwardKiller                            = 29,
	BackKiller                               = 30,
	LeftKiller                               = 31,
	RightKiller                              = 32,
	AimKiller                                = 33,
	CameraUpKiller                           = 34,
	CameraDownKiller                         = 35,
	CameraLeftKiller                         = 36,
	CameraRightKiller                        = 37,
	EKeyBindingsType_MAX                     = 38,
};

// Enum DeadByDaylight.EFPVTransitionStrategy
// NumValues: 0x0003
enum class EFPVTransitionStrategy : uint8
{
	TurnInvisible                            = 0,
	SquishTorsoBackward                      = 1,
	EFPVTransitionStrategy_MAX               = 2,
};

// Enum DeadByDaylight.ELevelBuildingState
// NumValues: 0x0017
enum class ELevelBuildingState : uint8
{
	NotInitialized                           = 0,
	WaitingForInitialSync                    = 1,
	SyncSeeds                                = 2,
	GetAvailableItems                        = 3,
	PendingGettingItems                      = 4,
	GettingLevelsDone                        = 5,
	PendingPremadeMapStreaming               = 6,
	GetAvailableEventSpawnables              = 7,
	GetThemedTiles                           = 8,
	PendingGettingTiles                      = 9,
	SpawnEscapeTiles                         = 10,
	SpawnBasementTile                        = 11,
	SpawnOutOfWorldTiles                     = 12,
	SpawningLevelTiles                       = 13,
	SpawnInterTileElements                   = 14,
	PendingInterTileElementsSpawning         = 15,
	SpawningActors                           = 16,
	SpawningMultiPassActors                  = 17,
	AttachParentActors                       = 18,
	StallingForRemotes                       = 19,
	BuildingDone                             = 20,
	BuildingStateCount                       = 21,
	ELevelBuildingState_MAX                  = 22,
};

// Enum DeadByDaylight.ELevelBuilderStepState
// NumValues: 0x0005
enum class ELevelBuilderStepState : uint8
{
	Failed                                   = 0,
	Pending                                  = 1,
	Complete                                 = 2,
	Skipped                                  = 3,
	ELevelBuilderStepState_MAX               = 4,
};

// Enum DeadByDaylight.EPlayerDataType
// NumValues: 0x0005
enum class EPlayerDataType : uint8
{
	None                                     = 0,
	PlayerState                              = 1,
	SocialPartyMember                        = 2,
	BotPartyMember                           = 3,
	EPlayerDataType_MAX                      = 4,
};

// Enum DeadByDaylight.ELobbyWaitStopReason
// NumValues: 0x0004
enum class ELobbyWaitStopReason : uint8
{
	StartMatchWait                           = 0,
	PlayerCancelled                          = 1,
	Unknown                                  = 2,
	ELobbyWaitStopReason_MAX                 = 3,
};

// Enum DeadByDaylight.EMapActorCategory
// NumValues: 0x0007
enum class EMapActorCategory : uint8
{
	None                                     = 0,
	Objective                                = 1,
	Chest                                    = 2,
	BlackLock                                = 3,
	KillerObject                             = 4,
	ExitGate                                 = 5,
	EMapActorCategory_MAX                    = 6,
};

// Enum DeadByDaylight.EQuadrant
// NumValues: 0x0006
enum class EQuadrant : uint8
{
	BottomRight                              = 0,
	BottomLeft                               = 1,
	TopLeft                                  = 2,
	TopRight                                 = 3,
	Count                                    = 4,
	EQuadrant_MAX                            = 5,
};

// Enum DeadByDaylight.EQuadrantSpawnType
// NumValues: 0x0008
enum class EQuadrantSpawnType : uint8
{
	L_Shape                                  = 0,
	Square                                   = 1,
	Rect_X                                   = 2,
	Rect_Y                                   = 3,
	Rect                                     = 4,
	None                                     = 5,
	Count                                    = 6,
	EQuadrantSpawnType_MAX                   = 7,
};

// Enum DeadByDaylight.EBasementType
// NumValues: 0x0006
enum class EBasementType : uint8
{
	None                                     = 0,
	Basic                                    = 1,
	MainBuilding                             = 2,
	Shack                                    = 3,
	Count                                    = 4,
	EBasementType_MAX                        = 5,
};

// Enum DeadByDaylight.EDirection
// NumValues: 0x0009
enum class EDirection : uint8
{
	Up                                       = 0,
	Down                                     = 1,
	Left                                     = 2,
	Right                                    = 3,
	UpLeft                                   = 4,
	UpRight                                  = 5,
	DownLeft                                 = 6,
	DownRight                                = 7,
	EDirection_MAX                           = 8,
};

// Enum DeadByDaylight.ETileType
// NumValues: 0x000A
enum class ETileType : uint8
{
	None                                     = 0,
	Blocker                                  = 1,
	Any                                      = 2,
	Forest                                   = 3,
	Building                                 = 4,
	Maze                                     = 5,
	Landmark                                 = 6,
	Signature                                = 7,
	Count                                    = 8,
	ETileType_MAX                            = 9,
};

// Enum DeadByDaylight.EDensity
// NumValues: 0x0007
enum class EDensity : uint8
{
	Unspecified                              = 0,
	Light                                    = 1,
	Moderate                                 = 2,
	Heavy                                    = 3,
	Empty                                    = 4,
	Count                                    = 5,
	EDensity_MAX                             = 6,
};

// Enum DeadByDaylight.EPathType
// NumValues: 0x000B
enum class EPathType : uint8
{
	None                                     = 0,
	Straight                                 = 1,
	DeadEnd                                  = 2,
	Corner                                   = 3,
	Crossroads                               = 4,
	TJunction                                = 5,
	OrientationOnly                          = 6,
	Unspecified                              = 7,
	OrientedCrossroads                       = 8,
	Count                                    = 9,
	EPathType_MAX                            = 10,
};

// Enum DeadByDaylight.ETileVariation
// NumValues: 0x0007
enum class ETileVariation : uint8
{
	None                                     = 0,
	BlueTag                                  = 1,
	PinkTag                                  = 2,
	YellowTag                                = 3,
	GreenTag                                 = 4,
	Empty                                    = 5,
	ETileVariation_MAX                       = 6,
};

// Enum DeadByDaylight.EQuadDirection
// NumValues: 0x0007
enum class EQuadDirection : uint8
{
	None                                     = 0,
	Up                                       = 1,
	Down                                     = 2,
	Left                                     = 3,
	Right                                    = 4,
	Empty                                    = 5,
	EQuadDirection_MAX                       = 6,
};

// Enum DeadByDaylight.EQueueingState
// NumValues: 0x0007
enum class EQueueingState : uint8
{
	None                                     = 0,
	Queueing                                 = 1,
	MatchCreated                             = 2,
	MatchOpened                              = 3,
	WaitingForTransactions                   = 4,
	Complete                                 = 5,
	EQueueingState_MAX                       = 6,
};

// Enum DeadByDaylight.EPlayerAnimState
// NumValues: 0x0005
enum class EPlayerAnimState : uint8
{
	VE_Default                               = 0,
	VE_Injured                               = 1,
	VE_InjuredCrouch                         = 2,
	VE_Crouch                                = 3,
	VE_MAX                                   = 4,
};

// Enum DeadByDaylight.EMysteryBoxCurrencyType
// NumValues: 0x0005
enum class EMysteryBoxCurrencyType : uint8
{
	BloodPoints                              = 0,
	BonusBloodPoints                         = 1,
	FearTokens                               = 2,
	Cells                                    = 3,
	EMysteryBoxCurrencyType_MAX              = 4,
};

// Enum DeadByDaylight.EGuidedState
// NumValues: 0x0012
enum class EGuidedState : uint8
{
	VE_None                                  = 0,
	VE_PrepBeingKilled                       = 1,
	VE_BeingKilled                           = 2,
	VE_PrepGuidedAction                      = 3,
	VE_BeingHelpedOffHookFront               = 4,
	VE_BeingPickedUp                         = 5,
	VE_BeingPutDown                          = 6,
	VE_BeingCarried                          = 7,
	VE_BeingPutOnHook                        = 8,
	VE_BeingHealed                           = 9,
	VE_BeingPulledFromCloset                 = 10,
	VE_BeingHelpedFromTrap                   = 11,
	VE_AttachReverseBearTrap                 = 12,
	VE_BeingMended                           = 13,
	VE_BeingInjectedWithSerum                = 14,
	VE_CarriedByK29Rush                      = 15,
	VE_BeingCleansedOfK29Infection           = 16,
	VE_MAX                                   = 17,
};

// Enum DeadByDaylight.EOfferingCombinationResult
// NumValues: 0x0006
enum class EOfferingCombinationResult : uint8
{
	None                                     = 0,
	Stacked                                  = 1,
	CoConsummed                              = 2,
	Overruling                               = 3,
	Cancelled                                = 4,
	EOfferingCombinationResult_MAX           = 5,
};

// Enum DeadByDaylight.EOfferingType
// NumValues: 0x0013
enum class EOfferingType : uint8
{
	None                                     = 0,
	Atmosphere                               = 1,
	Lighting                                 = 2,
	Points                                   = 3,
	Zone                                     = 4,
	Position                                 = 5,
	Chest                                    = 6,
	Hook                                     = 7,
	Protection                               = 8,
	Hatch                                    = 9,
	Odds                                     = 10,
	Killing                                  = 11,
	World                                    = 12,
	Luck                                     = 13,
	Killer                                   = 14,
	ProceduralGeneration                     = 15,
	CharacterXP                              = 16,
	Count                                    = 17,
	EOfferingType_MAX                        = 18,
};

// Enum DeadByDaylight.EOfferingCategory
// NumValues: 0x000A
enum class EOfferingCategory : uint8
{
	None                                     = 0,
	Bloodpoints                              = 1,
	Mapmods                                  = 2,
	Realms                                   = 3,
	Shrouds                                  = 4,
	Wards                                    = 5,
	CharacterXP                              = 6,
	Luck                                     = 7,
	Moris                                    = 8,
	EOfferingCategory_MAX                    = 9,
};

// Enum DeadByDaylight.EOfferingEffectType
// NumValues: 0x003D
enum class EOfferingEffectType : uint8
{
	Invalid                                  = 0,
	SlasherPointsAll                         = 1,
	PointsBrutality                          = 2,
	PointsDeviouness                         = 3,
	PointsSacrice                            = 4,
	PointsHunting                            = 5,
	CamperPointsAll                          = 6,
	PointsObjective                          = 7,
	PointsSurvival                           = 8,
	PointsAltruism                           = 9,
	PointsBoldness                           = 10,
	SurvivorCharacterXP                      = 11,
	KillerCharacterXP                        = 12,
	CamperItemLostPrevention                 = 13,
	KillerItemLostPrevention                 = 14,
	Luck                                     = 15,
	IndustrialThemeSelectionModifier         = 16,
	JunkyardThemeSelectionModifier           = 17,
	FarmThemeSelectionModifier               = 18,
	SwampThemeSelectionModifier              = 19,
	MapModifier                              = 20,
	ChestCountModifier                       = 21,
	PortableHookCountModifier                = 22,
	LairCountModifier                        = 23,
	PlayerGrouping                           = 24,
	FarKiller                                = 25,
	KillAllowedModifier                      = 26,
	LightingModification                     = 27,
	FogModification                          = 28,
	LivingWorldObjectCountModifier           = 29,
	LivingWorldObjectMultModifier            = 30,
	SuburbsThemeSelectionModifier            = 31,
	AsylumThemeSelectionModifier             = 32,
	KillerSelectionModifier                  = 33,
	HospitalThemeSelectionModifier           = 34,
	KillAllowedAfterStrugglePhase            = 35,
	BorealThemeSelectionModifier             = 36,
	SpringwoodThemeSelectionModifier         = 37,
	FinlandThemeSelectionModifier            = 38,
	JapaneseCountrySideSelectionModifier     = 39,
	KenyaThemeSelectionModifier              = 40,
	QatarThemeSelectionModifier              = 41,
	UkraineThemeSelectionModifier            = 42,
	WalesThemeSelectionModifier              = 43,
	CancelThemeSelectionModifier             = 44,
	BasementMainBuildingModifier             = 45,
	BasementShackModifier                    = 46,
	HatchMainBuildingModifier                = 47,
	HatchShackModifier                       = 48,
	EclipseThemeSelectionModifier            = 49,
	IonThemeSelectionModifier                = 50,
	MeteorThemeSelectionModifier             = 51,
	QuantumThemeSelectionModifier            = 52,
	UmbraThemeSelectionModifier              = 53,
	WormholeThemeSelectionModifier           = 54,
	SpecialEvent                             = 55,
	SpecialEventTallyBonus                   = 56,
	SpecialEventActionSpeed                  = 57,
	ObjectSubsitution                        = 58,
	ObjectAddition                           = 59,
	EOfferingEffectType_MAX                  = 60,
};

// Enum DeadByDaylight.EOfferingSequenceState
// NumValues: 0x000D
enum class EOfferingSequenceState : uint8
{
	SmokeIn                                  = 0,
	FadeOut                                  = 1,
	FadeIn                                   = 2,
	NotInitialized                           = 3,
	Idle                                     = 4,
	Init                                     = 5,
	InitDone                                 = 6,
	Reveal                                   = 7,
	RevealDone                               = 8,
	ShowInteraction                          = 9,
	Finalize                                 = 10,
	Done                                     = 11,
	EOfferingSequenceState_MAX               = 12,
};

// Enum DeadByDaylight.EOfflineLobbyState
// NumValues: 0x0006
enum class EOfflineLobbyState : uint8
{
	None                                     = 0,
	MainMenu                                 = 1,
	Store                                    = 2,
	PartyLobby                               = 3,
	Archives                                 = 4,
	EOfflineLobbyState_MAX                   = 5,
};

// Enum DeadByDaylight.EOniAttackType
// NumValues: 0x0005
enum class EOniAttackType : uint8
{
	VE_NotDemonMode                          = 0,
	VE_DemonBasicAttack                      = 1,
	VE_DemonPowerAttack                      = 2,
	VE_DemonDashAttack                       = 3,
	VE_MAX                                   = 4,
};

// Enum DeadByDaylight.EOnlineOperation
// NumValues: 0x000A
enum class EOnlineOperation : uint8
{
	None                                     = 0,
	HostGame                                 = 1,
	EndingSession                            = 2,
	DestroyingSession                        = 3,
	PreparingJoinGame                        = 4,
	JoinGame                                 = 5,
	JoinCancelled                            = 6,
	OnlineCheck                              = 7,
	CancellingMatchmaking                    = 8,
	EOnlineOperation_MAX                     = 9,
};

// Enum DeadByDaylight.EJoinSessionFailureType
// NumValues: 0x000A
enum class EJoinSessionFailureType : uint8
{
	None                                     = 0,
	JoiningAlreadyStartedGame                = 1,
	JoiningPrivateGame                       = 2,
	JoiningAlreadyFullGame                   = 3,
	JoiningInvitation                        = 4,
	JoiningFailedOnDisconnect                = 5,
	JoiningHostUnreachable                   = 6,
	JoiningIncompatibleServer                = 7,
	MatchmakingInfoExpired                   = 8,
	EJoinSessionFailureType_MAX              = 9,
};

// Enum DeadByDaylight.EOverlayMode
// NumValues: 0x0005
enum class EOverlayMode : uint8
{
	Default                                  = 0,
	TrialOrTally                             = 1,
	TutorialLevel                            = 2,
	TutorialBotMatch                         = 3,
	EOverlayMode_MAX                         = 4,
};

// Enum DeadByDaylight.EPalletSide
// NumValues: 0x0004
enum class EPalletSide : uint8
{
	None                                     = 0,
	Left                                     = 1,
	Right                                    = 2,
	EPalletSide_MAX                          = 3,
};

// Enum DeadByDaylight.EPerkArchetype
// NumValues: 0x0007
enum class EPerkArchetype : uint8
{
	Default                                  = 0,
	Hex                                      = 1,
	Boon                                     = 2,
	ScourgeHook                              = 3,
	Teamwork                                 = 4,
	Manifestation                            = 5,
	EPerkArchetype_MAX                       = 6,
};

// Enum DeadByDaylight.EPerkCategory
// NumValues: 0x0011
enum class EPerkCategory : uint8
{
	None                                     = 0,
	Navigation                               = 1,
	Perception                               = 2,
	Safeguard                                = 3,
	Concealment                              = 4,
	Strategy                                 = 5,
	Support                                  = 6,
	Adaptation                               = 7,
	Chasing                                  = 8,
	Tracking                                 = 9,
	Cruelty                                  = 10,
	Trickery                                 = 11,
	Obstruction                              = 12,
	Hinderance                               = 13,
	Enhancement                              = 14,
	Any                                      = 15,
	EPerkCategory_MAX                        = 16,
};

// Enum DeadByDaylight.EPerspectiveActivationCondition
// NumValues: 0x0004
enum class EPerspectiveActivationCondition : uint8
{
	LocallyControlled                        = 0,
	LocallyObserved                          = 1,
	NotLocallyObserved                       = 2,
	EPerspectiveActivationCondition_MAX      = 3,
};

// Enum DeadByDaylight.EFullProfileSaveLocation
// NumValues: 0x000A
enum class EFullProfileSaveLocation : uint8
{
	LeavingOfflineLobby                      = 0,
	LeavingOnlineLobby                       = 1,
	EnteringTally                            = 2,
	OnSuspend                                = 3,
	OnQuit                                   = 4,
	OnSettingsChanged                        = 5,
	OnFlagChanged                            = 6,
	CheatEntered                             = 7,
	IISMigrateCharacterData                  = 8,
	EFullProfileSaveLocation_MAX             = 9,
};

// Enum DeadByDaylight.ESaveGameFailureType
// NumValues: 0x0007
enum class ESaveGameFailureType : uint8
{
	None                                     = 0,
	InvalidPlayerID                          = 1,
	InvalidGameInstance                      = 2,
	NoServerConnection                       = 3,
	UserNotSignedIn                          = 4,
	Unknown                                  = 5,
	ESaveGameFailureType_MAX                 = 6,
};

// Enum DeadByDaylight.EInteractionValidationState
// NumValues: 0x0007
enum class EInteractionValidationState : uint8
{
	None                                     = 0,
	Predicted                                = 1,
	Authorized                               = 2,
	DeniedByRaceCondition                    = 3,
	DeniedByTimeout                          = 4,
	DeniedByError                            = 5,
	EInteractionValidationState_MAX          = 6,
};

// Enum DeadByDaylight.ERequestState
// NumValues: 0x0005
enum class ERequestState : uint8
{
	VE_None                                  = 0,
	VE_Pending                               = 1,
	VE_Success                               = 2,
	VE_Fail                                  = 3,
	VE_MAX                                   = 4,
};

// Enum DeadByDaylight.ESecondaryActionRequestTypes
// NumValues: 0x0004
enum class ESecondaryActionRequestTypes : uint8
{
	None                                     = 0,
	SecondaryActionRequested                 = 1,
	SecondaryActionRequestedFromCancel       = 2,
	ESecondaryActionRequestTypes_MAX         = 3,
};

// Enum DeadByDaylight.EPowerWidgetPresentationTier
// NumValues: 0x0005
enum class EPowerWidgetPresentationTier : uint8
{
	None                                     = 0,
	Primary                                  = 1,
	Secondary                                = 2,
	Tertiary                                 = 3,
	EPowerWidgetPresentationTier_MAX         = 4,
};

// Enum DeadByDaylight.EPreLevelGenerationModifierType
// NumValues: 0x0003
enum class EPreLevelGenerationModifierType : uint8
{
	None                                     = 0,
	ModifyKillerObjectCount                  = 1,
	EPreLevelGenerationModifierType_MAX      = 2,
};

// Enum DeadByDaylight.EPrestigeRewardType
// NumValues: 0x0004
enum class EPrestigeRewardType : uint8
{
	None                                     = 0,
	Customization                            = 1,
	Perk                                     = 2,
	EPrestigeRewardType_MAX                  = 3,
};

// Enum DeadByDaylight.EscapeStrategyType
// NumValues: 0x0004
enum class EscapeStrategyType : uint8
{
	EscapeDoor                               = 0,
	EscapeHatch                              = 1,
	Count                                    = 2,
	EscapeStrategyType_MAX                   = 3,
};

// Enum DeadByDaylight.ESurvivorGrouping
// NumValues: 0x0007
enum class ESurvivorGrouping : uint8
{
	Invalid                                  = 0,
	Separated                                = 1,
	Grouped2_2                               = 2,
	Grouped3_1                               = 3,
	Grouped4_0                               = 4,
	Grouped8_0                               = 8,
	ESurvivorGrouping_MAX                    = 9,
};

// Enum DeadByDaylight.EPromoPackContentType
// NumValues: 0x000C
enum class EPromoPackContentType : uint8
{
	None                                     = 0,
	Item                                     = 1,
	Addon                                    = 2,
	Offering                                 = 3,
	Character                                = 4,
	Customization                            = 5,
	Bonus                                    = 6,
	BloodPoints                              = 7,
	IridescentShards                         = 8,
	FreeTicket                               = 9,
	Count                                    = 10,
	EPromoPackContentType_MAX                = 11,
};

// Enum DeadByDaylight.EChallengeQuestParameterEditorType
// NumValues: 0x0007
enum class EChallengeQuestParameterEditorType : uint8
{
	Default                                  = 0,
	Target                                   = 1,
	Rarity                                   = 2,
	TierSize                                 = 3,
	EmblemQuality                            = 4,
	ScoreCategory                            = 5,
	EChallengeQuestParameterEditorType_MAX   = 6,
};

// Enum DeadByDaylight.EQuestCondition
// NumValues: 0x0012
enum class EQuestCondition : uint8
{
	Role                                     = 0,
	Character                                = 1,
	Map                                      = 2,
	Theme                                    = 3,
	Item                                     = 4,
	ItemCategory                             = 5,
	ItemAddOn                                = 6,
	Offering                                 = 7,
	Customization                            = 8,
	Perk                                     = 9,
	ExclusivePerk                            = 10,
	RandomPerks                              = 11,
	GameTypes                                = 12,
	ChallengeSetId                           = 13,
	ChallengeIds                             = 14,
	Class                                    = 15,
	None                                     = 255,
	EQuestCondition_MAX                      = 256,
};

// Enum DeadByDaylight.EQuestTargetValue
// NumValues: 0x0006
enum class EQuestTargetValue : uint8
{
	Me                                       = 0,
	MeOrOther                                = 1,
	Other                                    = 2,
	Any                                      = 3,
	None                                     = 255,
	EQuestTargetValue_MAX                    = 256,
};

// Enum DeadByDaylight.EQuestTierSizeValue
// NumValues: 0x0005
enum class EQuestTierSizeValue : uint8
{
	Small                                    = 0,
	Medium                                   = 1,
	Large                                    = 2,
	None                                     = 255,
	EQuestTierSizeValue_MAX                  = 256,
};

// Enum DeadByDaylight.EConditionNeedsType
// NumValues: 0x0003
enum class EConditionNeedsType : uint8
{
	AllTrue                                  = 0,
	AnyTrue                                  = 1,
	EConditionNeedsType_MAX                  = 2,
};

// Enum DeadByDaylight.ERandomPerkPoolType
// NumValues: 0x0004
enum class ERandomPerkPoolType : uint8
{
	AllPerks                                 = 0,
	PlayerOwnedPerks                         = 1,
	PrespecifiedPerks                        = 2,
	ERandomPerkPoolType_MAX                  = 3,
};

// Enum DeadByDaylight.ERefundSource
// NumValues: 0x0006
enum class ERefundSource : uint8
{
	None                                     = 0,
	BloodMarket                              = 1,
	DailyCalendar                            = 2,
	PromoPack                                = 3,
	Count                                    = 4,
	ERefundSource_MAX                        = 5,
};

// Enum DeadByDaylight.ESaveGameErrorCategory
// NumValues: 0x0006
enum class ESaveGameErrorCategory : uint8
{
	EvaluateDisconnectPenalty                = 0,
	SaveGameSaveError                        = 1,
	SaveGameUnreadable                       = 2,
	SaveGameValidation                       = 3,
	SaveFailed                               = 4,
	ESaveGameErrorCategory_MAX               = 5,
};

// Enum DeadByDaylight.EScreenType
// NumValues: 0x0004
enum class EScreenType : uint8
{
	EScaleformScreen                         = 0,
	EUMGScreen                               = 1,
	EMixedScaleformUMG                       = 2,
	EScreenType_MAX                          = 3,
};

// Enum DeadByDaylight.EScreenshotToolTargetCategory
// NumValues: 0x0006
enum class EScreenshotToolTargetCategory : uint8
{
	None                                     = 0,
	Piece                                    = 1,
	TwoPieces                                = 2,
	Outfit                                   = 3,
	Charm                                    = 4,
	EScreenshotToolTargetCategory_MAX        = 5,
};

// Enum DeadByDaylight.EScreenshotToolTargetSubCategory
// NumValues: 0x0007
enum class EScreenshotToolTargetSubCategory : uint8
{
	None                                     = 0,
	Id                                       = 1,
	CharacterId                              = 2,
	OutfitId                                 = 3,
	GenderRole                               = 4,
	Category                                 = 5,
	EScreenshotToolTargetSubCategory_MAX     = 6,
};

// Enum DeadByDaylight.EScreenshotToolState
// NumValues: 0x0009
enum class EScreenshotToolState : uint8
{
	None                                     = 0,
	PrepareBatch                             = 1,
	GenerateIcons                            = 2,
	GenerateAssets                           = 3,
	SaveAndCheckout                          = 4,
	FinishSuccess                            = 5,
	FinishFail                               = 6,
	FinishCancel                             = 7,
	EScreenshotToolState_MAX                 = 8,
};

// Enum DeadByDaylight.EScreenshotToolBatchType
// NumValues: 0x000E
enum class EScreenshotToolBatchType : uint8
{
	SelectedItemOrOutfit                     = 0,
	SelectedItemOrOutfitSeparated            = 1,
	SelectedCharacterItems                   = 2,
	SelectedCharacterOutfits                 = 3,
	SelectedCharacterAndCategory             = 4,
	ItemsMissingIcon                         = 5,
	OutfitMissingIcon                        = 6,
	CharmsMissingIcon                        = 7,
	PerkCharmsMissingIcon                    = 8,
	AllItems                                 = 9,
	AllOutfits                               = 10,
	AllCharms                                = 11,
	AllPerkCharms                            = 12,
	EScreenshotToolBatchType_MAX             = 13,
};

// Enum DeadByDaylight.EManifestationTarget
// NumValues: 0x0009
enum class EManifestationTarget : uint8
{
	AllPlayers                               = 0,
	AllSurvivors                             = 1,
	AllRitualContributers                    = 2,
	PerkEquipedSurvivors                     = 3,
	OnlyOwner                                = 4,
	AllExceptOwner                           = 5,
	Slasher                                  = 6,
	None                                     = 7,
	EManifestationTarget_MAX                 = 8,
};

// Enum DeadByDaylight.SettingsType
// NumValues: 0x000A
enum class ESettingsType : uint64
{
	None                                     = 18446744073709551615,
	Button                                   = 0,
	PlayerId                                 = 1,
	NumericStepper                           = 2,
	Dropdown                                 = 3,
	ColorBar                                 = 4,
	TextStepper                              = 5,
	BoolTextStepper                          = 6,
	Checkbox                                 = 7,
	SettingsType_MAX                         = 8,
};

// Enum DeadByDaylight.SettingsCategory
// NumValues: 0x000A
enum class ESettingsCategory : uint64
{
	None                                     = 18446744073709551615,
	General                                  = 0,
	Accessibility                            = 1,
	Beta                                     = 2,
	Online                                   = 3,
	Graphics                                 = 4,
	Audio                                    = 5,
	Controls                                 = 6,
	Atlanta                                  = 7,
	SettingsCategory_MAX                     = 8,
};

// Enum DeadByDaylight.SettingsSubCategory
// NumValues: 0x0015
enum class ESettingsSubCategory : uint64
{
	None                                     = 18446744073709551615,
	Language                                 = 0,
	Tutorial                                 = 1,
	Privacy                                  = 2,
	Accessibility                            = 3,
	InGameText                               = 4,
	ColorBlindMode                           = 5,
	MotionSickness                           = 6,
	Social                                   = 7,
	GameplayPrivacy                          = 8,
	Graphics                                 = 9,
	PostProcess                              = 10,
	UIHud                                    = 11,
	ChallengesNotification                   = 12,
	ChallengesCompletion                     = 13,
	Audio                                    = 14,
	CommonControls                           = 15,
	SurvivorControls                         = 16,
	KillerControls                           = 17,
	Atlanta                                  = 18,
	SettingsSubCategory_MAX                  = 19,
};

// Enum DeadByDaylight.SettingsId
// NumValues: 0x0051
enum class ESettingsId : uint64
{
	None                                     = 18446744073709551615,
	Language                                 = 0,
	RevokeConsent                            = 1,
	RevokeMarketingConsent                   = 2,
	BhvrAccount                              = 3,
	FogCommunications                        = 4,
	AllowCrossplayGeneric                    = 5,
	AllowCrossplayLive                       = 6,
	AutoDeclineFriendRequests                = 7,
	PlayerId                                 = 8,
	PartyPrivacy                             = 9,
	FieldOfView                              = 10,
	Quality                                  = 11,
	AutoAdjust                               = 12,
	Resolution                               = 13,
	ScreenResolution                         = 14,
	RenderSize                               = 15,
	FullScreen                               = 16,
	HUDConstrainedAspectRatio                = 17,
	VSync                                    = 18,
	AntiAliasingMode                         = 19,
	EnableFSR                                = 20,
	SharpnessValue                           = 21,
	XeSSMode                                 = 22,
	MenuScaleFactor                          = 23,
	HudScaleFactor                           = 24,
	SkillCheckScaleFactor                    = 25,
	LargeText                                = 26,
	BloodwebInteractionBehaviour             = 27,
	TerrorRadiusVisualFeedback               = 28,
	HUDPlayerNamesVisibility                 = 29,
	HUDKillerHookCountVisibility             = 30,
	HUDScoreEventsVisibility                 = 31,
	HUDUseItemPickupPopupAbridgedVersion     = 32,
	LegacyPrestigePortraits                  = 33,
	ArchivesChallengeProgression             = 34,
	DailyChallengeProgression                = 35,
	WeeklyChallengeProgression               = 36,
	EventChallengeProgression                = 37,
	AllChallengeProgression                  = 38,
	PlayerCardAnimationBehaviour             = 39,
	MainVolume                               = 40,
	MenuMusicVolume                          = 41,
	Headphones                               = 42,
	MuteOnFocusLost                          = 43,
	AllowCopyrightedMusic                    = 44,
	InvertYAxis                              = 45,
	SurvivorMouseSensitivity                 = 46,
	SurvivorControllerSensitivity            = 47,
	KillerMouseSensitivity                   = 48,
	KillerControllerSensitivity              = 49,
	SurvivorToggleInteractions               = 50,
	KillerToggleInteractions                 = 51,
	SprintToCancel                           = 52,
	ColorBarPalette                          = 53,
	ColorBlindMode                           = 54,
	ColorBlindModeIntensity                  = 55,
	BeginnerMode                             = 56,
	Subtitles                                = 57,
	SubtitlesBackgroundOpacity               = 58,
	SubtitlesSize                            = 59,
	IsAnonymousMode                          = 60,
	HideYourName                             = 61,
	HideOtherNames                           = 62,
	HiddenMatchmakingDelay                   = 63,
	SurvivorCameraSensitivity                = 64,
	KillerCameraSensitivity                  = 65,
	MenuMusicVolumeOn                        = 66,
	MainVolumeOn                             = 67,
	AimAssist                                = 68,
	SurvivorQuickTurn                        = 69,
	KillerQuickTurn                          = 70,
	FPSLimit                                 = 71,
	AutoQuality                              = 72,
	ControlType                              = 73,
	CustomizedControls                       = 74,
	DynamicResolution                        = 75,
	InvertYAxisSurvivor                      = 76,
	BetaWiggleSkillCheck                     = 77,
	HapticsVibrationPS5                      = 78,
	SettingsId_MAX                           = 79,
};

// Enum DeadByDaylight.EShopLoadProgress
// NumValues: 0x0008
enum class EShopLoadProgress : uint8
{
	None                                     = 0,
	LoadCatalog                              = 1,
	LoadCurrencyPacks                        = 2,
	PlatformStoreCatalog                     = 3,
	Inventory                                = 4,
	Wallet                                   = 5,
	FeaturedPageContent                      = 6,
	EShopLoadProgress_MAX                    = 7,
};

// Enum DeadByDaylight.ECatalogStatus
// NumValues: 0x0004
enum class ECatalogStatus : uint8
{
	NotReady                                 = 0,
	Updating                                 = 1,
	Fetched                                  = 2,
	ECatalogStatus_MAX                       = 3,
};

// Enum DeadByDaylight.EStoreUITag
// NumValues: 0x0005
enum class EStoreUITag : uint8
{
	None                                     = 0,
	Sale                                     = 1,
	New                                      = 2,
	LimitedTime                              = 3,
	EStoreUITag_MAX                          = 4,
};

// Enum DeadByDaylight.ESkillCategory
// NumValues: 0x0006
enum class ESkillCategory : uint8
{
	None                                     = 0,
	Team                                     = 1,
	Aura                                     = 2,
	Passive                                  = 3,
	Innate                                   = 4,
	ESkillCategory_MAX                       = 5,
};

// Enum DeadByDaylight.ESoftBanReason
// NumValues: 0x0008
enum class ESoftBanReason : uint64
{
	Invalid                                  = 18446744073709551615,
	Harassment                               = 0,
	Griefing                                 = 1,
	Exploits                                 = 2,
	Unsportsmanlike                          = 3,
	Chargeback                               = 4,
	Count                                    = 5,
	ESoftBanReason_MAX                       = 6,
};

// Enum DeadByDaylight.ESpawnerStrategyType
// NumValues: 0x0004
enum class ESpawnerStrategyType : uint8
{
	None                                     = 0,
	NoAccumulation                           = 1,
	LimitAccumulation                        = 2,
	ESpawnerStrategyType_MAX                 = 3,
};

// Enum DeadByDaylight.EGiftSpecialAction
// NumValues: 0x0003
enum class EGiftSpecialAction : uint8
{
	None                                     = 0,
	KeplerGift                               = 1,
	EGiftSpecialAction_MAX                   = 2,
};

// Enum DeadByDaylight.ESpecialEventGameMode
// NumValues: 0x0004
enum class ESpecialEventGameMode : uint8
{
	Progression                              = 0,
	Counter                                  = 1,
	Collection                               = 2,
	ESpecialEventGameMode_MAX                = 3,
};

// Enum DeadByDaylight.ESpecialEventDependency
// NumValues: 0x0003
enum class ESpecialEventDependency : uint8
{
	None                                     = 0,
	Archives                                 = 1,
	ESpecialEventDependency_MAX              = 2,
};

// Enum DeadByDaylight.ESpecialEventBloodwebChestCondition
// NumValues: 0x0004
enum class ESpecialEventBloodwebChestCondition : uint8
{
	Default                                  = 0,
	All                                      = 1,
	WithEventItem                            = 2,
	ESpecialEventBloodwebChestCondition_MAX  = 3,
};

// Enum DeadByDaylight.ESpecialEventMainMenuType
// NumValues: 0x0004
enum class ESpecialEventMainMenuType : uint8
{
	GameMode                                 = 0,
	LimitedTimeEvent                         = 1,
	Modifier                                 = 2,
	ESpecialEventMainMenuType_MAX            = 3,
};

// Enum DeadByDaylight.ESpecialEventStatus
// NumValues: 0x0004
enum class ESpecialEventStatus : uint8
{
	Inactive                                 = 0,
	ActiveMain                               = 1,
	ActivePost                               = 2,
	ESpecialEventStatus_MAX                  = 3,
};

// Enum DeadByDaylight.ELoadCompleteState
// NumValues: 0x0045
enum class ELoadCompleteState : uint8
{
	InProgress                               = 0,
	Success                                  = 1,
	ReloginRequested                         = 2,
	FailedEAC                                = 3,
	FailedRecoverable                        = 4,
	FailedRecoverableProfileLoad             = 5,
	FailedRecoverableWindowsStoreAndXboxLiveAccountNotMatching = 6,
	FailedUnequipedDisableditems             = 7,
	FailedBlocking                           = 8,
	FailedBlockingNoDBDServer                = 9,
	FailedBlockingNotConnected               = 10,
	FailedBlockedNoNetworkConnection         = 11,
	FailedBlockingSharedAuthenticationFailed = 12,
	FailedBlockingPlatformNotAuthenticated   = 13,
	FailedBlockingPlatformSubsystemNotInitialized = 14,
	FailedBlockingOnlinePresenceNotInitialized = 15,
	FailedBlockingPlatformNetUniqueIdInvalid = 16,
	FailedBlockingInvalidLocalPlayer         = 17,
	FailedBlockingInvalidGameObjects         = 18,
	FailedBlockingInvalidSDA                 = 19,
	FailedBlockingInvalidClientVersion       = 20,
	FailedBlockingInvalidAtlantaClientVersion = 21,
	FailedBlockingWindowsStoreAccountNotLoggedIn = 22,
	FailedBlockingSSLCACert                  = 23,
	FailedBlockingUserCancelled              = 24,
	FailedBlockingCDNFailure                 = 25,
	FailedBlockingCDNContentError            = 26,
	FailedBlockingCDNCantFindContentToDownload = 27,
	FailedBlockingCDNNoPatchForCurrentPlatformAndVersion = 28,
	FailedBlockingCDNNotEnoughDiskSpace      = 29,
	FailedBlockingCDNFailureToRetrieveContent = 30,
	FailedRecoverableCDNUserCancelled        = 31,
	FailedBlockingVersionFileError           = 32,
	FailedBlockingRTMConnection              = 33,
	FailedBlockingMaxTrialsReached           = 34,
	FailedBlockingMirrorsHealthCheckFailed   = 35,
	FailedBlockingTutorialRewardsFetchFailed = 36,
	FailedBlockingUserBanned                 = 37,
	FailedRetrieveStoreItem                  = 38,
	FailedControllerConnnection              = 39,
	FailedProfileSignedIn                    = 40,
	FailedBlockingMandatoryConsent           = 41,
	FailedInvalidGamepadState                = 42,
	FailedInvalidEventService                = 43,
	FailedInvalidIdentityService             = 44,
	FailedSoftBan                            = 45,
	FailedAuthenticationOnBoot               = 46,
	FailedPlatformUnexpectedError            = 47,
	FailedAgeRestriction                     = 48,
	FailedRequiredPatchAvailable             = 49,
	FailedRequiredSystemUpdate               = 50,
	FailedOnlinePlayRestricted               = 51,
	FailedUnknownPrivilege                   = 52,
	FailedInvalidOnlineSubsystem             = 53,
	FailedSettingProviderPlayerName          = 54,
	FailedSettingBackendPlayerName           = 55,
	FailedSyncBlockList                      = 56,
	FailedTrialApplication                   = 57,
	FailedUserNotDefined                     = 58,
	FailedInvalidNetId                       = 59,
	FailedInvalidSessionInterface            = 60,
	FailedContextRequestError                = 61,
	FailedPlatformServiceBusy                = 62,
	FailedPlatformServiceUnavailable         = 63,
	FailedPlatformInvalidResources           = 64,
	FailedPlatformUnknownError               = 65,
	FailedAuthenticationCode                 = 66,
	FailedAccountType                        = 67,
	ELoadCompleteState_MAX                   = 68,
};

// Enum DeadByDaylight.EExternalEffectSource
// NumValues: 0x0006
enum class EExternalEffectSource : uint8
{
	None                                     = 0,
	Perk                                     = 1,
	Skill                                    = 2,
	Addon                                    = 3,
	Power                                    = 4,
	EExternalEffectSource_MAX                = 5,
};

// Enum DeadByDaylight.EStoreCollectionsLoadResult
// NumValues: 0x0004
enum class EStoreCollectionsLoadResult : uint8
{
	Loaded                                   = 0,
	Cached                                   = 1,
	Error                                    = 2,
	EStoreCollectionsLoadResult_MAX          = 3,
};

// Enum DeadByDaylight.EInteractionStorerRole
// NumValues: 0x0006
enum class EInteractionStorerRole : uint8
{
	None                                     = 0,
	AuthorityAndAutonomousProxy              = 1,
	ClientAndAutonomousProxy                 = 2,
	AuthorityAndSimulatedProxy               = 3,
	ClientAndSimulatedProxy                  = 4,
	EInteractionStorerRole_MAX               = 5,
};

// Enum DeadByDaylight.EStoreFeaturedCardRecommendationType
// NumValues: 0x0004
enum class EStoreFeaturedCardRecommendationType : uint32
{
	ChapterPack                              = 0,
	SpecialPack                              = 1,
	CrossPromotion                           = 2,
	EStoreFeaturedCardRecommendationType_MAX = 3,
};

// Enum DeadByDaylight.EStorefrontState
// NumValues: 0x000B
enum class EStorefrontState : uint8
{
	None                                     = 0,
	Character                                = 1,
	Currency                                 = 2,
	Customization                            = 3,
	Featured                                 = 4,
	PromoPacks                               = 5,
	ShrineOfSecrets                          = 6,
	Subscriptions                            = 7,
	LandingPage                              = 8,
	Count                                    = 9,
	EStorefrontState_MAX                     = 10,
};

// Enum DeadByDaylight.EStoreRecommendationCustomizationItemCategories
// NumValues: 0x0003
enum class EStoreRecommendationCustomizationItemCategories : uint32
{
	Outfit                                   = 0,
	Item                                     = 1,
	EStoreRecommendationCustomizationItemCategories_MAX = 2,
};

// Enum DeadByDaylight.EStoreRecommendationsLoadResult
// NumValues: 0x0004
enum class EStoreRecommendationsLoadResult : uint8
{
	Loaded                                   = 0,
	Cached                                   = 1,
	Error                                    = 2,
	EStoreRecommendationsLoadResult_MAX      = 3,
};

// Enum DeadByDaylight.FStoreRecurringSpecialPackType
// NumValues: 0x0003
enum class EFStoreRecurringSpecialPackType : uint8
{
	Daily                                    = 0,
	Weekly                                   = 1,
	FStoreRecurringSpecialPackType_MAX       = 2,
};

// Enum DeadByDaylight.EStoreSpecialPackItemType
// NumValues: 0x0007
enum class EStoreSpecialPackItemType : uint8
{
	Customization                            = 0,
	Character                                = 1,
	Currency                                 = 2,
	RiftPass                                 = 3,
	RiftTier                                 = 4,
	Outfit                                   = 5,
	EStoreSpecialPackItemType_MAX            = 6,
};

// Enum DeadByDaylight.EStoreSpecialPackAvailabilityDate
// NumValues: 0x0004
enum class EStoreSpecialPackAvailabilityDate : uint8
{
	Permanent                                = 0,
	StartDate                                = 1,
	EndDate                                  = 2,
	EStoreSpecialPackAvailabilityDate_MAX    = 3,
};

// Enum DeadByDaylight.EStoreSpecialPackImageType
// NumValues: 0x0003
enum class EStoreSpecialPackImageType : uint8
{
	ComposedImage                            = 0,
	StaticImage                              = 1,
	EStoreSpecialPackImageType_MAX           = 2,
};

// Enum DeadByDaylight.ESubscriptionRewardType
// NumValues: 0x000B
enum class ESubscriptionRewardType : uint8
{
	None                                     = 0,
	Item                                     = 1,
	AddOn                                    = 2,
	Offering                                 = 3,
	FreeTicket                               = 4,
	AuricCells                               = 5,
	BloodPoints                              = 6,
	IridescentShards                         = 7,
	Customization                            = 8,
	Character                                = 9,
	ESubscriptionRewardType_MAX              = 10,
};

// Enum DeadByDaylight.ETrapRemovedReason
// NumValues: 0x0006
enum class ETrapRemovedReason : uint8
{
	KillerInteraction                        = 0,
	LifetimeExpired                          = 1,
	EndPlay                                  = 2,
	InteractableInvalidated                  = 3,
	OwnerLeft                                = 4,
	ETrapRemovedReason_MAX                   = 5,
};

// Enum DeadByDaylight.ETeachableStatus
// NumValues: 0x0005
enum class ETeachableStatus : uint8
{
	Unknown                                  = 0,
	Locked                                   = 1,
	AvailableInShrine                        = 2,
	Checked                                  = 3,
	ETeachableStatus_MAX                     = 4,
};

// Enum DeadByDaylight.ETrapBombState
// NumValues: 0x0005
enum class ETrapBombState : uint8
{
	Idle                                     = 0,
	Activating                               = 1,
	ActivatedLeft                            = 2,
	ActivatedRight                           = 3,
	ETrapBombState_MAX                       = 4,
};

// Enum DeadByDaylight.EUIControllerType
// NumValues: 0x0003
enum class EUIControllerType : uint8
{
	KeyboardMouse                            = 0,
	GamePad                                  = 1,
	EUIControllerType_MAX                    = 2,
};

// Enum DeadByDaylight.EOverlayButtonOptions
// NumValues: 0x0004
enum class EOverlayButtonOptions : uint8
{
	HIDDEN                                   = 0,
	DISABLED                                 = 1,
	ENABLED                                  = 2,
	EOverlayButtonOptions_MAX                = 3,
};

// Enum DeadByDaylight.ENewContentType
// NumValues: 0x0008
enum class ENewContentType : uint8
{
	FEATURED_CONTENT                         = 1,
	NEW_CONTENT                              = 2,
	PATCH_NOTES                              = 3,
	DEV_MESSAGES                             = 4,
	EVENTS                                   = 5,
	SALE                                     = 6,
	COMMUNITY                                = 7,
	ENewContentType_MAX                      = 8,
};

// Enum DeadByDaylight.EInventoryGridFormat
// NumValues: 0x0005
enum class EInventoryGridFormat : uint8
{
	DEFAULT                                  = 0,
	DIAMOND                                  = 1,
	HONEYCOMB                                = 2,
	CHARACTER_CLASS                          = 3,
	EInventoryGridFormat_MAX                 = 4,
};

// Enum DeadByDaylight.EUIPanelTab
// NumValues: 0x0006
enum class EUIPanelTab : uint8
{
	CHARACTERS_LIST                          = 0,
	LOADOUT                                  = 1,
	BLOODWEB                                 = 2,
	CUSTOMIZE                                = 3,
	LOBBY                                    = 4,
	EUIPanelTab_MAX                          = 5,
};

// Enum DeadByDaylight.ELegalTermsStatus
// NumValues: 0x0004
enum class ELegalTermsStatus : uint8
{
	None                                     = 0,
	Accepted                                 = 1,
	Declined                                 = 2,
	ELegalTermsStatus_MAX                    = 3,
};

// Enum DeadByDaylight.EPromptPriority
// NumValues: 0x0005
enum class EPromptPriority : uint8
{
	Tutorial                                 = 0,
	High                                     = 1,
	Medium                                   = 2,
	Low                                      = 3,
	EPromptPriority_MAX                      = 4,
};

// Enum DeadByDaylight.ENotificationStyle
// NumValues: 0x0004
enum class ENotificationStyle : uint8
{
	None                                     = 0,
	Game                                     = 1,
	Tutorial                                 = 2,
	ENotificationStyle_MAX                   = 3,
};

// Enum DeadByDaylight.EPromptType
// NumValues: 0x0005
enum class EPromptType : uint8
{
	None                                     = 0,
	ExitsPowered                             = 1,
	HatchSpawned                             = 2,
	HatchOpened                              = 3,
	EPromptType_MAX                          = 4,
};

// Enum DeadByDaylight.ELeaveLobbyReason
// NumValues: 0x000C
enum class ELeaveLobbyReason : uint8
{
	ENone                                    = 0,
	ENetworkDisconnect                       = 1,
	EProfileOffline                          = 2,
	EAppSuspended                            = 3,
	EInternetDisconnect                      = 4,
	EHostDisconnect                          = 5,
	EDLCInstalled                            = 6,
	ETrialExtensionExpired                   = 7,
	EPartyManagementError                    = 8,
	EGameTypeExpired                         = 9,
	ENegativeCurrencyBalance                 = 10,
	ELeaveLobbyReason_MAX                    = 11,
};

// Enum DeadByDaylight.ECustomerSupportLanguages
// NumValues: 0x000E
enum class ECustomerSupportLanguages : uint8
{
	None                                     = 0,
	De                                       = 1,
	En                                       = 2,
	Ja                                       = 3,
	Ru                                       = 4,
	Es                                       = 5,
	Fr                                       = 6,
	It                                       = 7,
	Ko                                       = 8,
	Pl                                       = 9,
	Pt                                       = 10,
	Th                                       = 11,
	Zh                                       = 12,
	ECustomerSupportLanguages_MAX            = 13,
};

// Enum DeadByDaylight.EForumLanguages
// NumValues: 0x0006
enum class EForumLanguages : uint8
{
	None                                     = 0,
	De                                       = 1,
	En                                       = 2,
	Ja                                       = 3,
	Ru                                       = 4,
	EForumLanguages_MAX                      = 5,
};

// Enum DeadByDaylight.EButtonType
// NumValues: 0x0008
enum class EButtonType : uint8
{
	None                                     = 0,
	AttackButton                             = 1,
	PowerButton                              = 2,
	CancelButton                             = 3,
	SettingsButton                           = 4,
	SecondaryActionButton                    = 5,
	PowerAttackJoystick                      = 6,
	EButtonType_MAX                          = 7,
};

// Enum DeadByDaylight.ELinkedVomitState
// NumValues: 0x0004
enum class ELinkedVomitState : uint8
{
	Idle                                     = 0,
	Charging                                 = 1,
	Vomiting                                 = 2,
	ELinkedVomitState_MAX                    = 3,
};

// ScriptStruct DeadByDaylight.OperationConditionsReplicatedData
// 0x0018 (0x0018 - 0x0000)
struct FOperationConditionsReplicatedData final
{
public:
	TArray<class UEventDrivenModifierCondition*>  Conditions;                                        // 0x0000(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          AuthorityDataSet;                                  // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOperationConditionsReplicatedData) == 0x000008, "Wrong alignment on FOperationConditionsReplicatedData");
static_assert(sizeof(FOperationConditionsReplicatedData) == 0x000018, "Wrong size on FOperationConditionsReplicatedData");
static_assert(offsetof(FOperationConditionsReplicatedData, Conditions) == 0x000000, "Member 'FOperationConditionsReplicatedData::Conditions' has a wrong offset!");
static_assert(offsetof(FOperationConditionsReplicatedData, AuthorityDataSet) == 0x000010, "Member 'FOperationConditionsReplicatedData::AuthorityDataSet' has a wrong offset!");

// ScriptStruct DeadByDaylight.ActorSpawnerProperties
// 0x0040 (0x0040 - 0x0000)
struct FActorSpawnerProperties final
{
public:
	TSoftClassPtr<class UClass>                   SceneElement;                                      // 0x0000(0x0038)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FActorSpawnerProperties) == 0x000008, "Wrong alignment on FActorSpawnerProperties");
static_assert(sizeof(FActorSpawnerProperties) == 0x000040, "Wrong size on FActorSpawnerProperties");
static_assert(offsetof(FActorSpawnerProperties, SceneElement) == 0x000000, "Member 'FActorSpawnerProperties::SceneElement' has a wrong offset!");
static_assert(offsetof(FActorSpawnerProperties, Weight) == 0x000038, "Member 'FActorSpawnerProperties::Weight' has a wrong offset!");

// ScriptStruct DeadByDaylight.CombinedExperimentData
// 0x0001 (0x0001 - 0x0000)
struct FCombinedExperimentData final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCombinedExperimentData) == 0x000001, "Wrong alignment on FCombinedExperimentData");
static_assert(sizeof(FCombinedExperimentData) == 0x000001, "Wrong size on FCombinedExperimentData");

// ScriptStruct DeadByDaylight.AnimationMapping
// 0x0050 (0x0058 - 0x0008)
struct FAnimationMapping final : public FDBDTableRowBase
{
public:
	TSoftObjectPtr<class UAnimMontage>            MontageAsset;                                      // 0x0008(0x0038)(Edit, BlueprintVisible, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FName>                           Tags;                                              // 0x0040(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UAnimMontage*                           _montage;                                          // 0x0050(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FAnimationMapping) == 0x000008, "Wrong alignment on FAnimationMapping");
static_assert(sizeof(FAnimationMapping) == 0x000058, "Wrong size on FAnimationMapping");
static_assert(offsetof(FAnimationMapping, MontageAsset) == 0x000008, "Member 'FAnimationMapping::MontageAsset' has a wrong offset!");
static_assert(offsetof(FAnimationMapping, Tags) == 0x000040, "Member 'FAnimationMapping::Tags' has a wrong offset!");
static_assert(offsetof(FAnimationMapping, _montage) == 0x000050, "Member 'FAnimationMapping::_montage' has a wrong offset!");

// ScriptStruct DeadByDaylight.AnimationMappingRow
// 0x0010 (0x0018 - 0x0008)
struct FAnimationMappingRow final : public FDBDTableRowBase
{
public:
	TArray<struct FAnimationMapping>              Mappings;                                          // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimationMappingRow) == 0x000008, "Wrong alignment on FAnimationMappingRow");
static_assert(sizeof(FAnimationMappingRow) == 0x000018, "Wrong size on FAnimationMappingRow");
static_assert(offsetof(FAnimationMappingRow, Mappings) == 0x000008, "Member 'FAnimationMappingRow::Mappings' has a wrong offset!");

// ScriptStruct DeadByDaylight.ElementSubstitutions
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FElementSubstitutions
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FElementSubstitutions) == 0x000008, "Wrong alignment on FElementSubstitutions");
static_assert(sizeof(FElementSubstitutions) == 0x000010, "Wrong size on FElementSubstitutions");

// ScriptStruct DeadByDaylight.SpawnPopulationHandler
// 0x0118 (0x0118 - 0x0000)
struct FSpawnPopulationHandler final
{
public:
	uint8                                         Pad_0[0x108];                                      // 0x0000(0x0108)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class USceneComponent*>                _allAvailableSpawners;                             // 0x0108(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FSpawnPopulationHandler) == 0x000008, "Wrong alignment on FSpawnPopulationHandler");
static_assert(sizeof(FSpawnPopulationHandler) == 0x000118, "Wrong size on FSpawnPopulationHandler");
static_assert(offsetof(FSpawnPopulationHandler, _allAvailableSpawners) == 0x000108, "Member 'FSpawnPopulationHandler::_allAvailableSpawners' has a wrong offset!");

// ScriptStruct DeadByDaylight.MenuCameraContextInfo
// 0x0014 (0x0014 - 0x0000)
struct FMenuCameraContextInfo final
{
public:
	int32                                         CharacterId;                                       // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   OutfitId;                                          // 0x0004(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseLocalCharacterData;                             // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMenuCameraContextInfo) == 0x000004, "Wrong alignment on FMenuCameraContextInfo");
static_assert(sizeof(FMenuCameraContextInfo) == 0x000014, "Wrong size on FMenuCameraContextInfo");
static_assert(offsetof(FMenuCameraContextInfo, CharacterId) == 0x000000, "Member 'FMenuCameraContextInfo::CharacterId' has a wrong offset!");
static_assert(offsetof(FMenuCameraContextInfo, OutfitId) == 0x000004, "Member 'FMenuCameraContextInfo::OutfitId' has a wrong offset!");
static_assert(offsetof(FMenuCameraContextInfo, UseLocalCharacterData) == 0x000010, "Member 'FMenuCameraContextInfo::UseLocalCharacterData' has a wrong offset!");

// ScriptStruct DeadByDaylight.GameNotificationData
// 0x0020 (0x0028 - 0x0008)
struct FGameNotificationData final : public FDBDTableRowBase
{
public:
	EPromptType                                   PromptType;                                        // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPromptPriority                               Priority;                                          // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Content;                                           // 0x0010(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameNotificationData) == 0x000008, "Wrong alignment on FGameNotificationData");
static_assert(sizeof(FGameNotificationData) == 0x000028, "Wrong size on FGameNotificationData");
static_assert(offsetof(FGameNotificationData, PromptType) == 0x000008, "Member 'FGameNotificationData::PromptType' has a wrong offset!");
static_assert(offsetof(FGameNotificationData, Priority) == 0x000009, "Member 'FGameNotificationData::Priority' has a wrong offset!");
static_assert(offsetof(FGameNotificationData, Content) == 0x000010, "Member 'FGameNotificationData::Content' has a wrong offset!");

// ScriptStruct DeadByDaylight.MenuCameraTransitionParams
// 0x0020 (0x0020 - 0x0000)
struct FMenuCameraTransitionParams final
{
public:
	EDBDCameraViewType                            View;                                              // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Duration;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Locked;                                            // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMenuCameraContextInfo                 Context;                                           // 0x000C(0x0014)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMenuCameraTransitionParams) == 0x000004, "Wrong alignment on FMenuCameraTransitionParams");
static_assert(sizeof(FMenuCameraTransitionParams) == 0x000020, "Wrong size on FMenuCameraTransitionParams");
static_assert(offsetof(FMenuCameraTransitionParams, View) == 0x000000, "Member 'FMenuCameraTransitionParams::View' has a wrong offset!");
static_assert(offsetof(FMenuCameraTransitionParams, Duration) == 0x000004, "Member 'FMenuCameraTransitionParams::Duration' has a wrong offset!");
static_assert(offsetof(FMenuCameraTransitionParams, Locked) == 0x000008, "Member 'FMenuCameraTransitionParams::Locked' has a wrong offset!");
static_assert(offsetof(FMenuCameraTransitionParams, Context) == 0x00000C, "Member 'FMenuCameraTransitionParams::Context' has a wrong offset!");

// ScriptStruct DeadByDaylight.FreeToPlayData
// 0x0030 (0x0030 - 0x0000)
struct FFreeToPlayData final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Start;                                             // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 End;                                               // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FFreeToPlayData) == 0x000008, "Wrong alignment on FFreeToPlayData");
static_assert(sizeof(FFreeToPlayData) == 0x000030, "Wrong size on FFreeToPlayData");
static_assert(offsetof(FFreeToPlayData, Start) == 0x000010, "Member 'FFreeToPlayData::Start' has a wrong offset!");
static_assert(offsetof(FFreeToPlayData, End) == 0x000020, "Member 'FFreeToPlayData::End' has a wrong offset!");

// ScriptStruct DeadByDaylight.ActorVariationElements
// 0x0040 (0x0040 - 0x0000)
struct FActorVariationElements final
{
public:
	ETileVariation                                Type;                                              // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   Element;                                           // 0x0008(0x0038)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FActorVariationElements) == 0x000008, "Wrong alignment on FActorVariationElements");
static_assert(sizeof(FActorVariationElements) == 0x000040, "Wrong size on FActorVariationElements");
static_assert(offsetof(FActorVariationElements, Type) == 0x000000, "Member 'FActorVariationElements::Type' has a wrong offset!");
static_assert(offsetof(FActorVariationElements, Element) == 0x000008, "Member 'FActorVariationElements::Element' has a wrong offset!");

// ScriptStruct DeadByDaylight.LegacySavedDailyRitualInstance
// 0x0078 (0x0078 - 0x0000)
struct FLegacySavedDailyRitualInstance final
{
public:
	class FName                                   RitualKey;                                         // 0x0000(0x000C)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 CharacterIDs;                                      // 0x0010(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	TArray<EPlayerRole>                           Roles;                                             // 0x0020(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	float                                         Progress;                                          // 0x0030(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Threshold;                                         // 0x0034(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Tolerance;                                         // 0x0038(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DisplayThreshold;                                  // 0x003C(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExpReward;                                         // 0x0040(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Active;                                            // 0x0044(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Rewarded;                                          // 0x0045(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          StateChanged;                                      // 0x0046(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_47[0x1];                                       // 0x0047(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              DateAssigned;                                      // 0x0048(0x0008)(ZeroConstructor, SaveGame, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NbGameElapsed;                                     // 0x0050(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EDBDScoreTypes>                        TrackedEvents;                                     // 0x0058(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPrivate)
	TArray<struct FGameplayTag>                   TrackedGameEvents;                                 // 0x0068(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FLegacySavedDailyRitualInstance) == 0x000008, "Wrong alignment on FLegacySavedDailyRitualInstance");
static_assert(sizeof(FLegacySavedDailyRitualInstance) == 0x000078, "Wrong size on FLegacySavedDailyRitualInstance");
static_assert(offsetof(FLegacySavedDailyRitualInstance, RitualKey) == 0x000000, "Member 'FLegacySavedDailyRitualInstance::RitualKey' has a wrong offset!");
static_assert(offsetof(FLegacySavedDailyRitualInstance, CharacterIDs) == 0x000010, "Member 'FLegacySavedDailyRitualInstance::CharacterIDs' has a wrong offset!");
static_assert(offsetof(FLegacySavedDailyRitualInstance, Roles) == 0x000020, "Member 'FLegacySavedDailyRitualInstance::Roles' has a wrong offset!");
static_assert(offsetof(FLegacySavedDailyRitualInstance, Progress) == 0x000030, "Member 'FLegacySavedDailyRitualInstance::Progress' has a wrong offset!");
static_assert(offsetof(FLegacySavedDailyRitualInstance, Threshold) == 0x000034, "Member 'FLegacySavedDailyRitualInstance::Threshold' has a wrong offset!");
static_assert(offsetof(FLegacySavedDailyRitualInstance, Tolerance) == 0x000038, "Member 'FLegacySavedDailyRitualInstance::Tolerance' has a wrong offset!");
static_assert(offsetof(FLegacySavedDailyRitualInstance, DisplayThreshold) == 0x00003C, "Member 'FLegacySavedDailyRitualInstance::DisplayThreshold' has a wrong offset!");
static_assert(offsetof(FLegacySavedDailyRitualInstance, ExpReward) == 0x000040, "Member 'FLegacySavedDailyRitualInstance::ExpReward' has a wrong offset!");
static_assert(offsetof(FLegacySavedDailyRitualInstance, Active) == 0x000044, "Member 'FLegacySavedDailyRitualInstance::Active' has a wrong offset!");
static_assert(offsetof(FLegacySavedDailyRitualInstance, Rewarded) == 0x000045, "Member 'FLegacySavedDailyRitualInstance::Rewarded' has a wrong offset!");
static_assert(offsetof(FLegacySavedDailyRitualInstance, StateChanged) == 0x000046, "Member 'FLegacySavedDailyRitualInstance::StateChanged' has a wrong offset!");
static_assert(offsetof(FLegacySavedDailyRitualInstance, DateAssigned) == 0x000048, "Member 'FLegacySavedDailyRitualInstance::DateAssigned' has a wrong offset!");
static_assert(offsetof(FLegacySavedDailyRitualInstance, NbGameElapsed) == 0x000050, "Member 'FLegacySavedDailyRitualInstance::NbGameElapsed' has a wrong offset!");
static_assert(offsetof(FLegacySavedDailyRitualInstance, TrackedEvents) == 0x000058, "Member 'FLegacySavedDailyRitualInstance::TrackedEvents' has a wrong offset!");
static_assert(offsetof(FLegacySavedDailyRitualInstance, TrackedGameEvents) == 0x000068, "Member 'FLegacySavedDailyRitualInstance::TrackedGameEvents' has a wrong offset!");

// ScriptStruct DeadByDaylight.SavedDailyRitualContainerV7
// 0x0040 (0x0040 - 0x0000)
struct FSavedDailyRitualContainerV7 final
{
public:
	class FString                                 LastRitualReceivedDate;                            // 0x0000(0x0010)(ZeroConstructor, SaveGame, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LastRitualPopupDate;                               // 0x0010(0x0010)(ZeroConstructor, SaveGame, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LastRitualDismissedDate;                           // 0x0020(0x0010)(ZeroConstructor, SaveGame, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FLegacySavedDailyRitualInstance> Rituals;                                           // 0x0030(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSavedDailyRitualContainerV7) == 0x000008, "Wrong alignment on FSavedDailyRitualContainerV7");
static_assert(sizeof(FSavedDailyRitualContainerV7) == 0x000040, "Wrong size on FSavedDailyRitualContainerV7");
static_assert(offsetof(FSavedDailyRitualContainerV7, LastRitualReceivedDate) == 0x000000, "Member 'FSavedDailyRitualContainerV7::LastRitualReceivedDate' has a wrong offset!");
static_assert(offsetof(FSavedDailyRitualContainerV7, LastRitualPopupDate) == 0x000010, "Member 'FSavedDailyRitualContainerV7::LastRitualPopupDate' has a wrong offset!");
static_assert(offsetof(FSavedDailyRitualContainerV7, LastRitualDismissedDate) == 0x000020, "Member 'FSavedDailyRitualContainerV7::LastRitualDismissedDate' has a wrong offset!");
static_assert(offsetof(FSavedDailyRitualContainerV7, Rituals) == 0x000030, "Member 'FSavedDailyRitualContainerV7::Rituals' has a wrong offset!");

// ScriptStruct DeadByDaylight.InteractionArray
// 0x0010 (0x0010 - 0x0000)
struct FInteractionArray final
{
public:
	TArray<TWeakObjectPtr<class UInteractionDefinition>> _interactions;                                     // 0x0000(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FInteractionArray) == 0x000008, "Wrong alignment on FInteractionArray");
static_assert(sizeof(FInteractionArray) == 0x000010, "Wrong size on FInteractionArray");
static_assert(offsetof(FInteractionArray, _interactions) == 0x000000, "Member 'FInteractionArray::_interactions' has a wrong offset!");

// ScriptStruct DeadByDaylight.MysteryBoxReward
// 0x0014 (0x0014 - 0x0000)
struct FMysteryBoxReward final
{
public:
	ERewardType                                   Type;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMysteryBoxCurrencyType                       CurrencyType;                                      // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EProgressionType                              ProgressionType;                                   // 0x0002(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x1];                                        // 0x0003(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Amount;                                            // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Weighting;                                         // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMysteryBoxCurrencyType                       FallbackCurrencyType;                              // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         FallbackAmount;                                    // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMysteryBoxReward) == 0x000004, "Wrong alignment on FMysteryBoxReward");
static_assert(sizeof(FMysteryBoxReward) == 0x000014, "Wrong size on FMysteryBoxReward");
static_assert(offsetof(FMysteryBoxReward, Type) == 0x000000, "Member 'FMysteryBoxReward::Type' has a wrong offset!");
static_assert(offsetof(FMysteryBoxReward, CurrencyType) == 0x000001, "Member 'FMysteryBoxReward::CurrencyType' has a wrong offset!");
static_assert(offsetof(FMysteryBoxReward, ProgressionType) == 0x000002, "Member 'FMysteryBoxReward::ProgressionType' has a wrong offset!");
static_assert(offsetof(FMysteryBoxReward, Amount) == 0x000004, "Member 'FMysteryBoxReward::Amount' has a wrong offset!");
static_assert(offsetof(FMysteryBoxReward, Weighting) == 0x000008, "Member 'FMysteryBoxReward::Weighting' has a wrong offset!");
static_assert(offsetof(FMysteryBoxReward, FallbackCurrencyType) == 0x00000C, "Member 'FMysteryBoxReward::FallbackCurrencyType' has a wrong offset!");
static_assert(offsetof(FMysteryBoxReward, FallbackAmount) == 0x000010, "Member 'FMysteryBoxReward::FallbackAmount' has a wrong offset!");

// ScriptStruct DeadByDaylight.MysteryBoxEntry
// 0x0030 (0x0048 - 0x0018)
struct FMysteryBoxEntry final : public FDBDTableRowBaseWithId
{
public:
	class FString                                 Campaign;                                          // 0x0018(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              ActiveFromDate;                                    // 0x0028(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              ActiveToDate;                                      // 0x0030(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FMysteryBoxReward>              PossibleRewards;                                   // 0x0038(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMysteryBoxEntry) == 0x000008, "Wrong alignment on FMysteryBoxEntry");
static_assert(sizeof(FMysteryBoxEntry) == 0x000048, "Wrong size on FMysteryBoxEntry");
static_assert(offsetof(FMysteryBoxEntry, Campaign) == 0x000018, "Member 'FMysteryBoxEntry::Campaign' has a wrong offset!");
static_assert(offsetof(FMysteryBoxEntry, ActiveFromDate) == 0x000028, "Member 'FMysteryBoxEntry::ActiveFromDate' has a wrong offset!");
static_assert(offsetof(FMysteryBoxEntry, ActiveToDate) == 0x000030, "Member 'FMysteryBoxEntry::ActiveToDate' has a wrong offset!");
static_assert(offsetof(FMysteryBoxEntry, PossibleRewards) == 0x000038, "Member 'FMysteryBoxEntry::PossibleRewards' has a wrong offset!");

// ScriptStruct DeadByDaylight.DamageData
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FDamageData final
{
public:
	bool                                          _damagedWithoutChangingRegressionState;            // 0x0000(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isRegressing;                                     // 0x0001(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isIntense;                                        // 0x0002(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3[0x1];                                        // 0x0003(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class ADBDPlayer>              _lastDamageChangeSource;                           // 0x0004(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C[0x14];                                       // 0x000C(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDamageData) == 0x000008, "Wrong alignment on FDamageData");
static_assert(sizeof(FDamageData) == 0x000020, "Wrong size on FDamageData");
static_assert(offsetof(FDamageData, _damagedWithoutChangingRegressionState) == 0x000000, "Member 'FDamageData::_damagedWithoutChangingRegressionState' has a wrong offset!");
static_assert(offsetof(FDamageData, _isRegressing) == 0x000001, "Member 'FDamageData::_isRegressing' has a wrong offset!");
static_assert(offsetof(FDamageData, _isIntense) == 0x000002, "Member 'FDamageData::_isIntense' has a wrong offset!");
static_assert(offsetof(FDamageData, _lastDamageChangeSource) == 0x000004, "Member 'FDamageData::_lastDamageChangeSource' has a wrong offset!");

// ScriptStruct DeadByDaylight.InteractionRequest
// 0x0018 (0x0018 - 0x0000)
struct FInteractionRequest final
{
public:
	class UInteractionDefinition*                 _interaction;                                      // 0x0000(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ADBDPlayer*                             _requester;                                        // 0x0010(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FInteractionRequest) == 0x000008, "Wrong alignment on FInteractionRequest");
static_assert(sizeof(FInteractionRequest) == 0x000018, "Wrong size on FInteractionRequest");
static_assert(offsetof(FInteractionRequest, _interaction) == 0x000000, "Member 'FInteractionRequest::_interaction' has a wrong offset!");
static_assert(offsetof(FInteractionRequest, _requester) == 0x000010, "Member 'FInteractionRequest::_requester' has a wrong offset!");

// ScriptStruct DeadByDaylight.GamePresetData
// 0x0090 (0x0090 - 0x0000)
struct FGamePresetData final
{
public:
	TArray<uint8>                                 _mapAvailabilities;                                // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<uint8>                                 _perkAvailabilities;                               // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<uint8>                                 _offeringAvailabilities;                           // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<uint8>                                 _itemAvailabilities;                               // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<uint8>                                 _itemAddonAvailabilities;                          // 0x0040(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<uint8>                                 _customizationItemAvailabilities;                  // 0x0050(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<uint8>                                 _characterAvailabilities;                          // 0x0060(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	bool                                          _allowDlcContent;                                  // 0x0070(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _privateMatch;                                     // 0x0071(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_72[0x6];                                       // 0x0072(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCustomGameBotsData                    _botsData;                                         // 0x0078(0x0018)(NativeAccessSpecifierPrivate)
};
static_assert(alignof(FGamePresetData) == 0x000008, "Wrong alignment on FGamePresetData");
static_assert(sizeof(FGamePresetData) == 0x000090, "Wrong size on FGamePresetData");
static_assert(offsetof(FGamePresetData, _mapAvailabilities) == 0x000000, "Member 'FGamePresetData::_mapAvailabilities' has a wrong offset!");
static_assert(offsetof(FGamePresetData, _perkAvailabilities) == 0x000010, "Member 'FGamePresetData::_perkAvailabilities' has a wrong offset!");
static_assert(offsetof(FGamePresetData, _offeringAvailabilities) == 0x000020, "Member 'FGamePresetData::_offeringAvailabilities' has a wrong offset!");
static_assert(offsetof(FGamePresetData, _itemAvailabilities) == 0x000030, "Member 'FGamePresetData::_itemAvailabilities' has a wrong offset!");
static_assert(offsetof(FGamePresetData, _itemAddonAvailabilities) == 0x000040, "Member 'FGamePresetData::_itemAddonAvailabilities' has a wrong offset!");
static_assert(offsetof(FGamePresetData, _customizationItemAvailabilities) == 0x000050, "Member 'FGamePresetData::_customizationItemAvailabilities' has a wrong offset!");
static_assert(offsetof(FGamePresetData, _characterAvailabilities) == 0x000060, "Member 'FGamePresetData::_characterAvailabilities' has a wrong offset!");
static_assert(offsetof(FGamePresetData, _allowDlcContent) == 0x000070, "Member 'FGamePresetData::_allowDlcContent' has a wrong offset!");
static_assert(offsetof(FGamePresetData, _privateMatch) == 0x000071, "Member 'FGamePresetData::_privateMatch' has a wrong offset!");
static_assert(offsetof(FGamePresetData, _botsData) == 0x000078, "Member 'FGamePresetData::_botsData' has a wrong offset!");

// ScriptStruct DeadByDaylight.ArmIKSensorDatum
// 0x0040 (0x0040 - 0x0000)
struct alignas(0x08) FArmIKSensorDatum final
{
public:
	class FName                                   ShoulderBoneName;                                  // 0x0000(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x34];                                       // 0x000C(0x0034)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FArmIKSensorDatum) == 0x000008, "Wrong alignment on FArmIKSensorDatum");
static_assert(sizeof(FArmIKSensorDatum) == 0x000040, "Wrong size on FArmIKSensorDatum");
static_assert(offsetof(FArmIKSensorDatum, ShoulderBoneName) == 0x000000, "Member 'FArmIKSensorDatum::ShoulderBoneName' has a wrong offset!");

// ScriptStruct DeadByDaylight.DBDTimer
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x08) FDBDTimer
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _startTime;                                        // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _startTimeDirty;                                   // 0x000C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFloat_NetQuantize8                    _timeLeft;                                         // 0x0010(0x0008)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          _replicateTimeLeft;                                // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_19[0xB];                                       // 0x0019(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _interpSpeed;                                      // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FDBDTimer) == 0x000008, "Wrong alignment on FDBDTimer");
static_assert(sizeof(FDBDTimer) == 0x000028, "Wrong size on FDBDTimer");
static_assert(offsetof(FDBDTimer, _startTime) == 0x000008, "Member 'FDBDTimer::_startTime' has a wrong offset!");
static_assert(offsetof(FDBDTimer, _startTimeDirty) == 0x00000C, "Member 'FDBDTimer::_startTimeDirty' has a wrong offset!");
static_assert(offsetof(FDBDTimer, _timeLeft) == 0x000010, "Member 'FDBDTimer::_timeLeft' has a wrong offset!");
static_assert(offsetof(FDBDTimer, _replicateTimeLeft) == 0x000018, "Member 'FDBDTimer::_replicateTimeLeft' has a wrong offset!");
static_assert(offsetof(FDBDTimer, _interpSpeed) == 0x000024, "Member 'FDBDTimer::_interpSpeed' has a wrong offset!");

// ScriptStruct DeadByDaylight.MenuCameraViewSettings
// 0x000C (0x000C - 0x0000)
struct FMenuCameraViewSettings final
{
public:
	float                                         FieldOfView;                                       // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AspectRatio;                                       // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ConstrainAspectRatio;                              // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseFieldOfViewForLOD;                              // 0x0009(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMenuCameraViewSettings) == 0x000004, "Wrong alignment on FMenuCameraViewSettings");
static_assert(sizeof(FMenuCameraViewSettings) == 0x00000C, "Wrong size on FMenuCameraViewSettings");
static_assert(offsetof(FMenuCameraViewSettings, FieldOfView) == 0x000000, "Member 'FMenuCameraViewSettings::FieldOfView' has a wrong offset!");
static_assert(offsetof(FMenuCameraViewSettings, AspectRatio) == 0x000004, "Member 'FMenuCameraViewSettings::AspectRatio' has a wrong offset!");
static_assert(offsetof(FMenuCameraViewSettings, ConstrainAspectRatio) == 0x000008, "Member 'FMenuCameraViewSettings::ConstrainAspectRatio' has a wrong offset!");
static_assert(offsetof(FMenuCameraViewSettings, UseFieldOfViewForLOD) == 0x000009, "Member 'FMenuCameraViewSettings::UseFieldOfViewForLOD' has a wrong offset!");

// ScriptStruct DeadByDaylight.Dependency
// 0x0098 (0x0098 - 0x0000)
struct FDependency final
{
public:
	ETileSpawnPointType                           Type;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        AssetReference;                                    // 0x0008(0x0028)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AActor>                     Object;                                            // 0x0030(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          Unique;                                            // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Count;                                             // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _spawnConditionsName;                              // 0x0040(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _elementTag;                                       // 0x004C(0x000C)(Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _allowFallback;                                    // 0x0058(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_59[0x3];                                       // 0x0059(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _spawnOrder;                                       // 0x005C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftClassPtr<class UClass>                   _iterativeWeightAdjustmentStrategyClass;           // 0x0060(0x0038)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FDependency) == 0x000008, "Wrong alignment on FDependency");
static_assert(sizeof(FDependency) == 0x000098, "Wrong size on FDependency");
static_assert(offsetof(FDependency, Type) == 0x000000, "Member 'FDependency::Type' has a wrong offset!");
static_assert(offsetof(FDependency, AssetReference) == 0x000008, "Member 'FDependency::AssetReference' has a wrong offset!");
static_assert(offsetof(FDependency, Object) == 0x000030, "Member 'FDependency::Object' has a wrong offset!");
static_assert(offsetof(FDependency, Unique) == 0x000038, "Member 'FDependency::Unique' has a wrong offset!");
static_assert(offsetof(FDependency, Count) == 0x00003C, "Member 'FDependency::Count' has a wrong offset!");
static_assert(offsetof(FDependency, _spawnConditionsName) == 0x000040, "Member 'FDependency::_spawnConditionsName' has a wrong offset!");
static_assert(offsetof(FDependency, _elementTag) == 0x00004C, "Member 'FDependency::_elementTag' has a wrong offset!");
static_assert(offsetof(FDependency, _allowFallback) == 0x000058, "Member 'FDependency::_allowFallback' has a wrong offset!");
static_assert(offsetof(FDependency, _spawnOrder) == 0x00005C, "Member 'FDependency::_spawnOrder' has a wrong offset!");
static_assert(offsetof(FDependency, _iterativeWeightAdjustmentStrategyClass) == 0x000060, "Member 'FDependency::_iterativeWeightAdjustmentStrategyClass' has a wrong offset!");

// ScriptStruct DeadByDaylight.BuiltLevelData
// 0x00B8 (0x00B8 - 0x0000)
struct FBuiltLevelData final
{
public:
	class FName                                   ThemeName;                                         // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ThemeWeather;                                      // 0x000C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AudioStateThemes;                                  // 0x0018(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AudioStateWeather;                                 // 0x0024(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AudioThemeEvent;                                   // 0x0030(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AudioLimitPointEvent;                              // 0x003C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAkAudioBank>            AudioThemeSoundBank;                               // 0x0048(0x0038)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MapName;                                           // 0x0080(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGameType                                     GameType;                                          // 0x0090(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x3];                                       // 0x0091(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TileCount;                                         // 0x0094(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FDependency>                    Dependencies;                                      // 0x0098(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   SpecialEventId;                                    // 0x00A8(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B4[0x4];                                       // 0x00B4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBuiltLevelData) == 0x000008, "Wrong alignment on FBuiltLevelData");
static_assert(sizeof(FBuiltLevelData) == 0x0000B8, "Wrong size on FBuiltLevelData");
static_assert(offsetof(FBuiltLevelData, ThemeName) == 0x000000, "Member 'FBuiltLevelData::ThemeName' has a wrong offset!");
static_assert(offsetof(FBuiltLevelData, ThemeWeather) == 0x00000C, "Member 'FBuiltLevelData::ThemeWeather' has a wrong offset!");
static_assert(offsetof(FBuiltLevelData, AudioStateThemes) == 0x000018, "Member 'FBuiltLevelData::AudioStateThemes' has a wrong offset!");
static_assert(offsetof(FBuiltLevelData, AudioStateWeather) == 0x000024, "Member 'FBuiltLevelData::AudioStateWeather' has a wrong offset!");
static_assert(offsetof(FBuiltLevelData, AudioThemeEvent) == 0x000030, "Member 'FBuiltLevelData::AudioThemeEvent' has a wrong offset!");
static_assert(offsetof(FBuiltLevelData, AudioLimitPointEvent) == 0x00003C, "Member 'FBuiltLevelData::AudioLimitPointEvent' has a wrong offset!");
static_assert(offsetof(FBuiltLevelData, AudioThemeSoundBank) == 0x000048, "Member 'FBuiltLevelData::AudioThemeSoundBank' has a wrong offset!");
static_assert(offsetof(FBuiltLevelData, MapName) == 0x000080, "Member 'FBuiltLevelData::MapName' has a wrong offset!");
static_assert(offsetof(FBuiltLevelData, GameType) == 0x000090, "Member 'FBuiltLevelData::GameType' has a wrong offset!");
static_assert(offsetof(FBuiltLevelData, TileCount) == 0x000094, "Member 'FBuiltLevelData::TileCount' has a wrong offset!");
static_assert(offsetof(FBuiltLevelData, Dependencies) == 0x000098, "Member 'FBuiltLevelData::Dependencies' has a wrong offset!");
static_assert(offsetof(FBuiltLevelData, SpecialEventId) == 0x0000A8, "Member 'FBuiltLevelData::SpecialEventId' has a wrong offset!");

// ScriptStruct DeadByDaylight.ArchiveRewardsData
// 0x0078 (0x0078 - 0x0000)
struct FArchiveRewardsData final
{
public:
	int32                                         XpRequirement;                                     // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StarsEarnedPerLevel;                               // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PreStartDate;                                      // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 StartDate;                                         // 0x0018(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 EndDate;                                           // 0x0028(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PostEndDate;                                       // 0x0038(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x30];                                      // 0x0048(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FArchiveRewardsData) == 0x000008, "Wrong alignment on FArchiveRewardsData");
static_assert(sizeof(FArchiveRewardsData) == 0x000078, "Wrong size on FArchiveRewardsData");
static_assert(offsetof(FArchiveRewardsData, XpRequirement) == 0x000000, "Member 'FArchiveRewardsData::XpRequirement' has a wrong offset!");
static_assert(offsetof(FArchiveRewardsData, StarsEarnedPerLevel) == 0x000004, "Member 'FArchiveRewardsData::StarsEarnedPerLevel' has a wrong offset!");
static_assert(offsetof(FArchiveRewardsData, PreStartDate) == 0x000008, "Member 'FArchiveRewardsData::PreStartDate' has a wrong offset!");
static_assert(offsetof(FArchiveRewardsData, StartDate) == 0x000018, "Member 'FArchiveRewardsData::StartDate' has a wrong offset!");
static_assert(offsetof(FArchiveRewardsData, EndDate) == 0x000028, "Member 'FArchiveRewardsData::EndDate' has a wrong offset!");
static_assert(offsetof(FArchiveRewardsData, PostEndDate) == 0x000038, "Member 'FArchiveRewardsData::PostEndDate' has a wrong offset!");

// ScriptStruct DeadByDaylight.SelectedOffering
// 0x0010 (0x0010 - 0x0000)
struct FSelectedOffering final
{
public:
	int32                                         OwnerId;                                           // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   OfferingName;                                      // 0x0004(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSelectedOffering) == 0x000004, "Wrong alignment on FSelectedOffering");
static_assert(sizeof(FSelectedOffering) == 0x000010, "Wrong size on FSelectedOffering");
static_assert(offsetof(FSelectedOffering, OwnerId) == 0x000000, "Member 'FSelectedOffering::OwnerId' has a wrong offset!");
static_assert(offsetof(FSelectedOffering, OfferingName) == 0x000004, "Member 'FSelectedOffering::OfferingName' has a wrong offset!");

// ScriptStruct DeadByDaylight.ItemUIData
// 0x0138 (0x0138 - 0x0000)
struct FItemUIData final
{
public:
	class FText                                   DisplayName;                                       // 0x0000(0x0018)(Edit, NativeAccessSpecifierPrivate)
	class FText                                   Description;                                       // 0x0018(0x0018)(Edit, NativeAccessSpecifierPrivate)
	class FText                                   InGameDescription;                                 // 0x0030(0x0018)(Edit, NativeAccessSpecifierPrivate)
	TArray<class FString>                         IconFilePathList;                                  // 0x0048(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<TSoftObjectPtr<class UTexture2D>>      IconAssetList;                                     // 0x0058(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	class FString                                 SecondaryIcon;                                     // 0x0068(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftClassPtr<class UClass>                   AnimatedWidgetRef;                                 // 0x0078(0x0038)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FCustomTransformation                  CustomTransformation;                              // 0x00B0(0x0028)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	uint32                                        PlatformsUnlicensedNameOverride;                   // 0x00D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint32                                        PlatformsUnlicensedDescriptionOverride;            // 0x00DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint32                                        PlatformsForIconUnlicensedFilePathListOverride;    // 0x00E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E4[0x4];                                       // 0x00E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         IconUnlicensedFilePathListOverride;                // 0x00E8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	bool                                          LicenseExpirationOverride;                         // 0x00F8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F9[0x7];                                       // 0x00F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DisplayNameUnlicensedOverride;                     // 0x0100(0x0018)(Edit, NativeAccessSpecifierPrivate)
	class FText                                   DescriptionUnlicensedOverride;                     // 0x0118(0x0018)(Edit, NativeAccessSpecifierPrivate)
	int32                                         AssociatedCharacterIndex;                          // 0x0130(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_134[0x4];                                      // 0x0134(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FItemUIData) == 0x000008, "Wrong alignment on FItemUIData");
static_assert(sizeof(FItemUIData) == 0x000138, "Wrong size on FItemUIData");
static_assert(offsetof(FItemUIData, DisplayName) == 0x000000, "Member 'FItemUIData::DisplayName' has a wrong offset!");
static_assert(offsetof(FItemUIData, Description) == 0x000018, "Member 'FItemUIData::Description' has a wrong offset!");
static_assert(offsetof(FItemUIData, InGameDescription) == 0x000030, "Member 'FItemUIData::InGameDescription' has a wrong offset!");
static_assert(offsetof(FItemUIData, IconFilePathList) == 0x000048, "Member 'FItemUIData::IconFilePathList' has a wrong offset!");
static_assert(offsetof(FItemUIData, IconAssetList) == 0x000058, "Member 'FItemUIData::IconAssetList' has a wrong offset!");
static_assert(offsetof(FItemUIData, SecondaryIcon) == 0x000068, "Member 'FItemUIData::SecondaryIcon' has a wrong offset!");
static_assert(offsetof(FItemUIData, AnimatedWidgetRef) == 0x000078, "Member 'FItemUIData::AnimatedWidgetRef' has a wrong offset!");
static_assert(offsetof(FItemUIData, CustomTransformation) == 0x0000B0, "Member 'FItemUIData::CustomTransformation' has a wrong offset!");
static_assert(offsetof(FItemUIData, PlatformsUnlicensedNameOverride) == 0x0000D8, "Member 'FItemUIData::PlatformsUnlicensedNameOverride' has a wrong offset!");
static_assert(offsetof(FItemUIData, PlatformsUnlicensedDescriptionOverride) == 0x0000DC, "Member 'FItemUIData::PlatformsUnlicensedDescriptionOverride' has a wrong offset!");
static_assert(offsetof(FItemUIData, PlatformsForIconUnlicensedFilePathListOverride) == 0x0000E0, "Member 'FItemUIData::PlatformsForIconUnlicensedFilePathListOverride' has a wrong offset!");
static_assert(offsetof(FItemUIData, IconUnlicensedFilePathListOverride) == 0x0000E8, "Member 'FItemUIData::IconUnlicensedFilePathListOverride' has a wrong offset!");
static_assert(offsetof(FItemUIData, LicenseExpirationOverride) == 0x0000F8, "Member 'FItemUIData::LicenseExpirationOverride' has a wrong offset!");
static_assert(offsetof(FItemUIData, DisplayNameUnlicensedOverride) == 0x000100, "Member 'FItemUIData::DisplayNameUnlicensedOverride' has a wrong offset!");
static_assert(offsetof(FItemUIData, DescriptionUnlicensedOverride) == 0x000118, "Member 'FItemUIData::DescriptionUnlicensedOverride' has a wrong offset!");
static_assert(offsetof(FItemUIData, AssociatedCharacterIndex) == 0x000130, "Member 'FItemUIData::AssociatedCharacterIndex' has a wrong offset!");

// ScriptStruct DeadByDaylight.ItemAvailability
// 0x0048 (0x0048 - 0x0000)
struct FItemAvailability final
{
public:
	EItemAvailability                             ItemAvailability;                                  // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DLCId;                                             // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class FString>                         AdditionalDlcIds;                                  // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	int32                                         CloudInventoryId;                                  // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CommunityId;                                       // 0x0030(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isLicensed;                                       // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FItemAvailability) == 0x000008, "Wrong alignment on FItemAvailability");
static_assert(sizeof(FItemAvailability) == 0x000048, "Wrong size on FItemAvailability");
static_assert(offsetof(FItemAvailability, ItemAvailability) == 0x000000, "Member 'FItemAvailability::ItemAvailability' has a wrong offset!");
static_assert(offsetof(FItemAvailability, DLCId) == 0x000008, "Member 'FItemAvailability::DLCId' has a wrong offset!");
static_assert(offsetof(FItemAvailability, AdditionalDlcIds) == 0x000018, "Member 'FItemAvailability::AdditionalDlcIds' has a wrong offset!");
static_assert(offsetof(FItemAvailability, CloudInventoryId) == 0x000028, "Member 'FItemAvailability::CloudInventoryId' has a wrong offset!");
static_assert(offsetof(FItemAvailability, CommunityId) == 0x000030, "Member 'FItemAvailability::CommunityId' has a wrong offset!");
static_assert(offsetof(FItemAvailability, _isLicensed) == 0x000040, "Member 'FItemAvailability::_isLicensed' has a wrong offset!");

// ScriptStruct DeadByDaylight.CustomizationData
// 0x01C8 (0x01D0 - 0x0008)
struct FCustomizationData : public FDBDTableRowBase
{
public:
	int32                                         AssociatedCharacter;                               // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerRole                                   AssociatedRole;                                    // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemRarity                                   Rarity;                                            // 0x000D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECustomizationModifier                        Prefix;                                            // 0x000E(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F[0x1];                                        // 0x000F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FItemUIData                            UIData;                                            // 0x0010(0x0138)(Edit, NativeAccessSpecifierPublic)
	struct FItemAvailability                      Availability;                                      // 0x0148(0x0048)(Edit, NativeAccessSpecifierPublic)
	class FString                                 InclusionVersion;                                  // 0x0190(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CustomizationId;                                   // 0x01A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FText>                           SearchTags;                                        // 0x01B0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C0[0x10];                                     // 0x01C0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCustomizationData) == 0x000008, "Wrong alignment on FCustomizationData");
static_assert(sizeof(FCustomizationData) == 0x0001D0, "Wrong size on FCustomizationData");
static_assert(offsetof(FCustomizationData, AssociatedCharacter) == 0x000008, "Member 'FCustomizationData::AssociatedCharacter' has a wrong offset!");
static_assert(offsetof(FCustomizationData, AssociatedRole) == 0x00000C, "Member 'FCustomizationData::AssociatedRole' has a wrong offset!");
static_assert(offsetof(FCustomizationData, Rarity) == 0x00000D, "Member 'FCustomizationData::Rarity' has a wrong offset!");
static_assert(offsetof(FCustomizationData, Prefix) == 0x00000E, "Member 'FCustomizationData::Prefix' has a wrong offset!");
static_assert(offsetof(FCustomizationData, UIData) == 0x000010, "Member 'FCustomizationData::UIData' has a wrong offset!");
static_assert(offsetof(FCustomizationData, Availability) == 0x000148, "Member 'FCustomizationData::Availability' has a wrong offset!");
static_assert(offsetof(FCustomizationData, InclusionVersion) == 0x000190, "Member 'FCustomizationData::InclusionVersion' has a wrong offset!");
static_assert(offsetof(FCustomizationData, CustomizationId) == 0x0001A0, "Member 'FCustomizationData::CustomizationId' has a wrong offset!");
static_assert(offsetof(FCustomizationData, SearchTags) == 0x0001B0, "Member 'FCustomizationData::SearchTags' has a wrong offset!");

// ScriptStruct DeadByDaylight.UnlockSaveStatCondition
// 0x0014 (0x0014 - 0x0000)
struct FUnlockSaveStatCondition final
{
public:
	class FName                                   StatName;                                          // 0x0000(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ValueRequired;                                     // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsCharacterSpecific;                               // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUnlockSaveStatCondition) == 0x000004, "Wrong alignment on FUnlockSaveStatCondition");
static_assert(sizeof(FUnlockSaveStatCondition) == 0x000014, "Wrong size on FUnlockSaveStatCondition");
static_assert(offsetof(FUnlockSaveStatCondition, StatName) == 0x000000, "Member 'FUnlockSaveStatCondition::StatName' has a wrong offset!");
static_assert(offsetof(FUnlockSaveStatCondition, ValueRequired) == 0x00000C, "Member 'FUnlockSaveStatCondition::ValueRequired' has a wrong offset!");
static_assert(offsetof(FUnlockSaveStatCondition, IsCharacterSpecific) == 0x000010, "Member 'FUnlockSaveStatCondition::IsCharacterSpecific' has a wrong offset!");

// ScriptStruct DeadByDaylight.MaterialReplacerData
// 0x0070 (0x0070 - 0x0000)
struct FMaterialReplacerData final
{
public:
	TSoftObjectPtr<class UMaterialInterface>      From;                                              // 0x0000(0x0038)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UMaterialInterface>      To;                                                // 0x0038(0x0038)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMaterialReplacerData) == 0x000008, "Wrong alignment on FMaterialReplacerData");
static_assert(sizeof(FMaterialReplacerData) == 0x000070, "Wrong size on FMaterialReplacerData");
static_assert(offsetof(FMaterialReplacerData, From) == 0x000000, "Member 'FMaterialReplacerData::From' has a wrong offset!");
static_assert(offsetof(FMaterialReplacerData, To) == 0x000038, "Member 'FMaterialReplacerData::To' has a wrong offset!");

// ScriptStruct DeadByDaylight.MaterialReplacerArray
// 0x0010 (0x0010 - 0x0000)
struct FMaterialReplacerArray final
{
public:
	TArray<struct FMaterialReplacerData>          MaterialsMap;                                      // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMaterialReplacerArray) == 0x000008, "Wrong alignment on FMaterialReplacerArray");
static_assert(sizeof(FMaterialReplacerArray) == 0x000010, "Wrong size on FMaterialReplacerArray");
static_assert(offsetof(FMaterialReplacerArray, MaterialsMap) == 0x000000, "Member 'FMaterialReplacerArray::MaterialsMap' has a wrong offset!");

// ScriptStruct DeadByDaylight.ConditionalMaterialReplacer
// 0x0060 (0x0060 - 0x0000)
struct FConditionalMaterialReplacer final
{
public:
	class FName                                   ItemTag;                                           // 0x0000(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, struct FMaterialReplacerArray> ConditionalMaterials;                              // 0x0010(0x0050)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FConditionalMaterialReplacer) == 0x000008, "Wrong alignment on FConditionalMaterialReplacer");
static_assert(sizeof(FConditionalMaterialReplacer) == 0x000060, "Wrong size on FConditionalMaterialReplacer");
static_assert(offsetof(FConditionalMaterialReplacer, ItemTag) == 0x000000, "Member 'FConditionalMaterialReplacer::ItemTag' has a wrong offset!");
static_assert(offsetof(FConditionalMaterialReplacer, ConditionalMaterials) == 0x000010, "Member 'FConditionalMaterialReplacer::ConditionalMaterials' has a wrong offset!");

// ScriptStruct DeadByDaylight.TextureReplacerData
// 0x0080 (0x0080 - 0x0000)
struct FTextureReplacerData final
{
public:
	TSoftObjectPtr<class UMaterialInterface>      BaseMaterial;                                      // 0x0000(0x0038)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              ReplacementTexture;                                // 0x0038(0x0038)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TextureParameterName;                              // 0x0070(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExplicitMaterialSlot;                              // 0x007C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTextureReplacerData) == 0x000008, "Wrong alignment on FTextureReplacerData");
static_assert(sizeof(FTextureReplacerData) == 0x000080, "Wrong size on FTextureReplacerData");
static_assert(offsetof(FTextureReplacerData, BaseMaterial) == 0x000000, "Member 'FTextureReplacerData::BaseMaterial' has a wrong offset!");
static_assert(offsetof(FTextureReplacerData, ReplacementTexture) == 0x000038, "Member 'FTextureReplacerData::ReplacementTexture' has a wrong offset!");
static_assert(offsetof(FTextureReplacerData, TextureParameterName) == 0x000070, "Member 'FTextureReplacerData::TextureParameterName' has a wrong offset!");
static_assert(offsetof(FTextureReplacerData, ExplicitMaterialSlot) == 0x00007C, "Member 'FTextureReplacerData::ExplicitMaterialSlot' has a wrong offset!");

// ScriptStruct DeadByDaylight.BPAttachementSocketData
// 0x00F0 (0x00F0 - 0x0000)
struct FBPAttachementSocketData final
{
public:
	TSoftClassPtr<class UClass>                   AccessoryBlueprint;                                // 0x0000(0x0038)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           SkeletalMesh;                                      // 0x0038(0x0038)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SocketName;                                        // 0x0070(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMaterialReplacerData>          MaterialsMap;                                      // 0x0080(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FConditionalMaterialReplacer           ConditionalMaterialReplacer;                       // 0x0090(0x0060)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBPAttachementSocketData) == 0x000008, "Wrong alignment on FBPAttachementSocketData");
static_assert(sizeof(FBPAttachementSocketData) == 0x0000F0, "Wrong size on FBPAttachementSocketData");
static_assert(offsetof(FBPAttachementSocketData, AccessoryBlueprint) == 0x000000, "Member 'FBPAttachementSocketData::AccessoryBlueprint' has a wrong offset!");
static_assert(offsetof(FBPAttachementSocketData, SkeletalMesh) == 0x000038, "Member 'FBPAttachementSocketData::SkeletalMesh' has a wrong offset!");
static_assert(offsetof(FBPAttachementSocketData, SocketName) == 0x000070, "Member 'FBPAttachementSocketData::SocketName' has a wrong offset!");
static_assert(offsetof(FBPAttachementSocketData, MaterialsMap) == 0x000080, "Member 'FBPAttachementSocketData::MaterialsMap' has a wrong offset!");
static_assert(offsetof(FBPAttachementSocketData, ConditionalMaterialReplacer) == 0x000090, "Member 'FBPAttachementSocketData::ConditionalMaterialReplacer' has a wrong offset!");

// ScriptStruct DeadByDaylight.CustomSoundFXData
// 0x0018 (0x0018 - 0x0000)
struct FCustomSoundFXData final
{
public:
	EAudioCustomizationCategory                   AudioCategory;                                     // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SwitchState;                                       // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCustomSoundFXData) == 0x000008, "Wrong alignment on FCustomSoundFXData");
static_assert(sizeof(FCustomSoundFXData) == 0x000018, "Wrong size on FCustomSoundFXData");
static_assert(offsetof(FCustomSoundFXData, AudioCategory) == 0x000000, "Member 'FCustomSoundFXData::AudioCategory' has a wrong offset!");
static_assert(offsetof(FCustomSoundFXData, SwitchState) == 0x000008, "Member 'FCustomSoundFXData::SwitchState' has a wrong offset!");

// ScriptStruct DeadByDaylight.CustomAnimData
// 0x0070 (0x0070 - 0x0000)
struct FCustomAnimData final
{
public:
	TSoftClassPtr<class UClass>                   MenuAnimationBlueprint;                            // 0x0000(0x0038)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   InGameAnimationBlueprint;                          // 0x0038(0x0038)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCustomAnimData) == 0x000008, "Wrong alignment on FCustomAnimData");
static_assert(sizeof(FCustomAnimData) == 0x000070, "Wrong size on FCustomAnimData");
static_assert(offsetof(FCustomAnimData, MenuAnimationBlueprint) == 0x000000, "Member 'FCustomAnimData::MenuAnimationBlueprint' has a wrong offset!");
static_assert(offsetof(FCustomAnimData, InGameAnimationBlueprint) == 0x000038, "Member 'FCustomAnimData::InGameAnimationBlueprint' has a wrong offset!");

// ScriptStruct DeadByDaylight.CustomizationItemData
// 0x0270 (0x0440 - 0x01D0)
struct FCustomizationItemData final : public FCustomizationData
{
public:
	ECustomizationCategory                        Category;                                          // 0x01D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D1[0x7];                                      // 0x01D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class USkeletalMesh>           ItemMesh;                                          // 0x01D8(0x0038)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   AnimClass;                                         // 0x0210(0x0038)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   ItemBlueprint;                                     // 0x0248(0x0038)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FMaterialReplacerData>          MaterialsMap;                                      // 0x0280(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FConditionalMaterialReplacer           ConditionalMaterialReplacer;                       // 0x0290(0x0060)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FTextureReplacerData>           TexturesMap;                                       // 0x02F0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           SkeletalComponentTags;                             // 0x0300(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  CosmeticOverrideSemanticTags;                      // 0x0310(0x0020)(Edit, NativeAccessSpecifierPublic)
	class FText                                   CollectionName;                                    // 0x0330(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   CollectionDescription;                             // 0x0348(0x0018)(Edit, NativeAccessSpecifierPublic)
	TArray<class FText>                           AssociatedCharacterSearchTags;                     // 0x0360(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         PrestigeUlockLevel;                                // 0x0370(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_374[0x4];                                      // 0x0374(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 PrestigeUnlockDate;                                // 0x0378(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EventID;                                           // 0x0388(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECharmCategory                                CharmCategory;                                     // 0x0394(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_395[0x3];                                      // 0x0395(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBPAttachementSocketData>       SocketAttachements;                                // 0x0398(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FUnlockSaveStatCondition>       UnlockingConditions;                               // 0x03A8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          IsInStore;                                         // 0x03B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsInNonViolentBuild;                               // 0x03B9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsEntitledByDefault;                               // 0x03BA(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3BB[0x1];                                      // 0x03BB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        PlatformExclusiveFlag;                             // 0x03BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FCustomSoundFXData>             CustomSFXs;                                        // 0x03C0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FCustomAnimData                        AnimationData;                                     // 0x03D0(0x0070)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCustomizationItemData) == 0x000008, "Wrong alignment on FCustomizationItemData");
static_assert(sizeof(FCustomizationItemData) == 0x000440, "Wrong size on FCustomizationItemData");
static_assert(offsetof(FCustomizationItemData, Category) == 0x0001D0, "Member 'FCustomizationItemData::Category' has a wrong offset!");
static_assert(offsetof(FCustomizationItemData, ItemMesh) == 0x0001D8, "Member 'FCustomizationItemData::ItemMesh' has a wrong offset!");
static_assert(offsetof(FCustomizationItemData, AnimClass) == 0x000210, "Member 'FCustomizationItemData::AnimClass' has a wrong offset!");
static_assert(offsetof(FCustomizationItemData, ItemBlueprint) == 0x000248, "Member 'FCustomizationItemData::ItemBlueprint' has a wrong offset!");
static_assert(offsetof(FCustomizationItemData, MaterialsMap) == 0x000280, "Member 'FCustomizationItemData::MaterialsMap' has a wrong offset!");
static_assert(offsetof(FCustomizationItemData, ConditionalMaterialReplacer) == 0x000290, "Member 'FCustomizationItemData::ConditionalMaterialReplacer' has a wrong offset!");
static_assert(offsetof(FCustomizationItemData, TexturesMap) == 0x0002F0, "Member 'FCustomizationItemData::TexturesMap' has a wrong offset!");
static_assert(offsetof(FCustomizationItemData, SkeletalComponentTags) == 0x000300, "Member 'FCustomizationItemData::SkeletalComponentTags' has a wrong offset!");
static_assert(offsetof(FCustomizationItemData, CosmeticOverrideSemanticTags) == 0x000310, "Member 'FCustomizationItemData::CosmeticOverrideSemanticTags' has a wrong offset!");
static_assert(offsetof(FCustomizationItemData, CollectionName) == 0x000330, "Member 'FCustomizationItemData::CollectionName' has a wrong offset!");
static_assert(offsetof(FCustomizationItemData, CollectionDescription) == 0x000348, "Member 'FCustomizationItemData::CollectionDescription' has a wrong offset!");
static_assert(offsetof(FCustomizationItemData, AssociatedCharacterSearchTags) == 0x000360, "Member 'FCustomizationItemData::AssociatedCharacterSearchTags' has a wrong offset!");
static_assert(offsetof(FCustomizationItemData, PrestigeUlockLevel) == 0x000370, "Member 'FCustomizationItemData::PrestigeUlockLevel' has a wrong offset!");
static_assert(offsetof(FCustomizationItemData, PrestigeUnlockDate) == 0x000378, "Member 'FCustomizationItemData::PrestigeUnlockDate' has a wrong offset!");
static_assert(offsetof(FCustomizationItemData, EventID) == 0x000388, "Member 'FCustomizationItemData::EventID' has a wrong offset!");
static_assert(offsetof(FCustomizationItemData, CharmCategory) == 0x000394, "Member 'FCustomizationItemData::CharmCategory' has a wrong offset!");
static_assert(offsetof(FCustomizationItemData, SocketAttachements) == 0x000398, "Member 'FCustomizationItemData::SocketAttachements' has a wrong offset!");
static_assert(offsetof(FCustomizationItemData, UnlockingConditions) == 0x0003A8, "Member 'FCustomizationItemData::UnlockingConditions' has a wrong offset!");
static_assert(offsetof(FCustomizationItemData, IsInStore) == 0x0003B8, "Member 'FCustomizationItemData::IsInStore' has a wrong offset!");
static_assert(offsetof(FCustomizationItemData, IsInNonViolentBuild) == 0x0003B9, "Member 'FCustomizationItemData::IsInNonViolentBuild' has a wrong offset!");
static_assert(offsetof(FCustomizationItemData, IsEntitledByDefault) == 0x0003BA, "Member 'FCustomizationItemData::IsEntitledByDefault' has a wrong offset!");
static_assert(offsetof(FCustomizationItemData, PlatformExclusiveFlag) == 0x0003BC, "Member 'FCustomizationItemData::PlatformExclusiveFlag' has a wrong offset!");
static_assert(offsetof(FCustomizationItemData, CustomSFXs) == 0x0003C0, "Member 'FCustomizationItemData::CustomSFXs' has a wrong offset!");
static_assert(offsetof(FCustomizationItemData, AnimationData) == 0x0003D0, "Member 'FCustomizationItemData::AnimationData' has a wrong offset!");

// ScriptStruct DeadByDaylight.BloodwebNodesPerRingDistribution
// 0x0008 (0x0010 - 0x0008)
struct FBloodwebNodesPerRingDistribution final : public FDBDTableRowBase
{
public:
	int32                                         MinCount;                                          // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxCount;                                          // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBloodwebNodesPerRingDistribution) == 0x000008, "Wrong alignment on FBloodwebNodesPerRingDistribution");
static_assert(sizeof(FBloodwebNodesPerRingDistribution) == 0x000010, "Wrong size on FBloodwebNodesPerRingDistribution");
static_assert(offsetof(FBloodwebNodesPerRingDistribution, MinCount) == 0x000008, "Member 'FBloodwebNodesPerRingDistribution::MinCount' has a wrong offset!");
static_assert(offsetof(FBloodwebNodesPerRingDistribution, MaxCount) == 0x00000C, "Member 'FBloodwebNodesPerRingDistribution::MaxCount' has a wrong offset!");

// ScriptStruct DeadByDaylight.OnMovementCacheStruct
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FOnMovementCacheStruct final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOnMovementCacheStruct) == 0x000008, "Wrong alignment on FOnMovementCacheStruct");
static_assert(sizeof(FOnMovementCacheStruct) == 0x000018, "Wrong size on FOnMovementCacheStruct");

// ScriptStruct DeadByDaylight.DataTableDropdown
// 0x0030 (0x0030 - 0x0000)
struct FDataTableDropdown
{
public:
	class FName                                   RowValue;                                          // 0x0000(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DataTableName;                                     // 0x0010(0x0010)(Edit, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   ColumnName;                                        // 0x0020(0x000C)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDataTableDropdown) == 0x000008, "Wrong alignment on FDataTableDropdown");
static_assert(sizeof(FDataTableDropdown) == 0x000030, "Wrong size on FDataTableDropdown");
static_assert(offsetof(FDataTableDropdown, RowValue) == 0x000000, "Member 'FDataTableDropdown::RowValue' has a wrong offset!");
static_assert(offsetof(FDataTableDropdown, DataTableName) == 0x000010, "Member 'FDataTableDropdown::DataTableName' has a wrong offset!");
static_assert(offsetof(FDataTableDropdown, ColumnName) == 0x000020, "Member 'FDataTableDropdown::ColumnName' has a wrong offset!");

// ScriptStruct DeadByDaylight.EventSpawnablePositionDropdown
// 0x0000 (0x0030 - 0x0030)
struct FEventSpawnablePositionDropdown final : public FDataTableDropdown
{
};
static_assert(alignof(FEventSpawnablePositionDropdown) == 0x000008, "Wrong alignment on FEventSpawnablePositionDropdown");
static_assert(sizeof(FEventSpawnablePositionDropdown) == 0x000030, "Wrong size on FEventSpawnablePositionDropdown");

// ScriptStruct DeadByDaylight.OfferingData
// 0x0018 (0x0018 - 0x0000)
struct FOfferingData final
{
public:
	bool                                          OfferingReady;                                     // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSelectedOffering>              Offerings;                                         // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOfferingData) == 0x000008, "Wrong alignment on FOfferingData");
static_assert(sizeof(FOfferingData) == 0x000018, "Wrong size on FOfferingData");
static_assert(offsetof(FOfferingData, OfferingReady) == 0x000000, "Member 'FOfferingData::OfferingReady' has a wrong offset!");
static_assert(offsetof(FOfferingData, Offerings) == 0x000008, "Member 'FOfferingData::Offerings' has a wrong offset!");

// ScriptStruct DeadByDaylight.CharacterLoadoutPreset
// 0x0048 (0x0048 - 0x0000)
struct FCharacterLoadoutPreset final
{
public:
	class FName                                   PowerOrItem;                                       // 0x0000(0x000C)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           Addons;                                            // 0x0010(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	TArray<class FName>                           Perks;                                             // 0x0020(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	class FName                                   Favor;                                             // 0x0030(0x000C)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CharacterClass;                                    // 0x003C(0x000C)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterLoadoutPreset) == 0x000008, "Wrong alignment on FCharacterLoadoutPreset");
static_assert(sizeof(FCharacterLoadoutPreset) == 0x000048, "Wrong size on FCharacterLoadoutPreset");
static_assert(offsetof(FCharacterLoadoutPreset, PowerOrItem) == 0x000000, "Member 'FCharacterLoadoutPreset::PowerOrItem' has a wrong offset!");
static_assert(offsetof(FCharacterLoadoutPreset, Addons) == 0x000010, "Member 'FCharacterLoadoutPreset::Addons' has a wrong offset!");
static_assert(offsetof(FCharacterLoadoutPreset, Perks) == 0x000020, "Member 'FCharacterLoadoutPreset::Perks' has a wrong offset!");
static_assert(offsetof(FCharacterLoadoutPreset, Favor) == 0x000030, "Member 'FCharacterLoadoutPreset::Favor' has a wrong offset!");
static_assert(offsetof(FCharacterLoadoutPreset, CharacterClass) == 0x00003C, "Member 'FCharacterLoadoutPreset::CharacterClass' has a wrong offset!");

// ScriptStruct DeadByDaylight.CharacterLoadoutPresetsList
// 0x0018 (0x0018 - 0x0000)
struct FCharacterLoadoutPresetsList final
{
public:
	int32                                         CharacterId;                                       // 0x0000(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ActivePreset;                                      // 0x0004(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FCharacterLoadoutPreset>        Presets;                                           // 0x0008(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterLoadoutPresetsList) == 0x000008, "Wrong alignment on FCharacterLoadoutPresetsList");
static_assert(sizeof(FCharacterLoadoutPresetsList) == 0x000018, "Wrong size on FCharacterLoadoutPresetsList");
static_assert(offsetof(FCharacterLoadoutPresetsList, CharacterId) == 0x000000, "Member 'FCharacterLoadoutPresetsList::CharacterId' has a wrong offset!");
static_assert(offsetof(FCharacterLoadoutPresetsList, ActivePreset) == 0x000004, "Member 'FCharacterLoadoutPresetsList::ActivePreset' has a wrong offset!");
static_assert(offsetof(FCharacterLoadoutPresetsList, Presets) == 0x000008, "Member 'FCharacterLoadoutPresetsList::Presets' has a wrong offset!");

// ScriptStruct DeadByDaylight.LoadoutPresetsDataForGameType
// 0x0010 (0x0010 - 0x0000)
struct FLoadoutPresetsDataForGameType final
{
public:
	TArray<struct FCharacterLoadoutPresetsList>   CharacterLoadoutPresetsList;                       // 0x0000(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLoadoutPresetsDataForGameType) == 0x000008, "Wrong alignment on FLoadoutPresetsDataForGameType");
static_assert(sizeof(FLoadoutPresetsDataForGameType) == 0x000010, "Wrong size on FLoadoutPresetsDataForGameType");
static_assert(offsetof(FLoadoutPresetsDataForGameType, CharacterLoadoutPresetsList) == 0x000000, "Member 'FLoadoutPresetsDataForGameType::CharacterLoadoutPresetsList' has a wrong offset!");

// ScriptStruct DeadByDaylight.ConsentDefinitionData
// 0x0050 (0x0050 - 0x0000)
struct FConsentDefinitionData final
{
public:
	class FString                                 ID;                                                // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         Platform;                                          // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         Sku;                                               // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          Sku_IsSet;                                         // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         Language;                                          // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          NeedAcceptance;                                    // 0x0048(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsMandatory;                                       // 0x0049(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A[0x6];                                       // 0x004A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FConsentDefinitionData) == 0x000008, "Wrong alignment on FConsentDefinitionData");
static_assert(sizeof(FConsentDefinitionData) == 0x000050, "Wrong size on FConsentDefinitionData");
static_assert(offsetof(FConsentDefinitionData, ID) == 0x000000, "Member 'FConsentDefinitionData::ID' has a wrong offset!");
static_assert(offsetof(FConsentDefinitionData, Platform) == 0x000010, "Member 'FConsentDefinitionData::Platform' has a wrong offset!");
static_assert(offsetof(FConsentDefinitionData, Sku) == 0x000020, "Member 'FConsentDefinitionData::Sku' has a wrong offset!");
static_assert(offsetof(FConsentDefinitionData, Sku_IsSet) == 0x000030, "Member 'FConsentDefinitionData::Sku_IsSet' has a wrong offset!");
static_assert(offsetof(FConsentDefinitionData, Language) == 0x000038, "Member 'FConsentDefinitionData::Language' has a wrong offset!");
static_assert(offsetof(FConsentDefinitionData, NeedAcceptance) == 0x000048, "Member 'FConsentDefinitionData::NeedAcceptance' has a wrong offset!");
static_assert(offsetof(FConsentDefinitionData, IsMandatory) == 0x000049, "Member 'FConsentDefinitionData::IsMandatory' has a wrong offset!");

// ScriptStruct DeadByDaylight.ParentItemIDs
// 0x0018 (0x0018 - 0x0000)
struct FParentItemIDs final
{
public:
	bool                                          MatchAnyItemID;                                    // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           ItemIds;                                           // 0x0008(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FParentItemIDs) == 0x000008, "Wrong alignment on FParentItemIDs");
static_assert(sizeof(FParentItemIDs) == 0x000018, "Wrong size on FParentItemIDs");
static_assert(offsetof(FParentItemIDs, MatchAnyItemID) == 0x000000, "Member 'FParentItemIDs::MatchAnyItemID' has a wrong offset!");
static_assert(offsetof(FParentItemIDs, ItemIds) == 0x000008, "Member 'FParentItemIDs::ItemIds' has a wrong offset!");

// ScriptStruct DeadByDaylight.BaseItemData
// 0x01E8 (0x01F0 - 0x0008)
struct FBaseItemData : public FDBDTableRowBase
{
public:
	EInventoryItemType                            Type;                                              // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FItemUIData                            UIData;                                            // 0x0010(0x0138)(Edit, NativeAccessSpecifierPublic)
	class FText                                   GenericDisplayName;                                // 0x0148(0x0018)(Edit, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   ItemBlueprint;                                     // 0x0160(0x0038)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDBDPrimaryDataAsset>    AssetData;                                         // 0x0198(0x0038)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ItemId;                                            // 0x01D0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1E0[0x10];                                     // 0x01E0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBaseItemData) == 0x000008, "Wrong alignment on FBaseItemData");
static_assert(sizeof(FBaseItemData) == 0x0001F0, "Wrong size on FBaseItemData");
static_assert(offsetof(FBaseItemData, Type) == 0x000008, "Member 'FBaseItemData::Type' has a wrong offset!");
static_assert(offsetof(FBaseItemData, UIData) == 0x000010, "Member 'FBaseItemData::UIData' has a wrong offset!");
static_assert(offsetof(FBaseItemData, GenericDisplayName) == 0x000148, "Member 'FBaseItemData::GenericDisplayName' has a wrong offset!");
static_assert(offsetof(FBaseItemData, ItemBlueprint) == 0x000160, "Member 'FBaseItemData::ItemBlueprint' has a wrong offset!");
static_assert(offsetof(FBaseItemData, AssetData) == 0x000198, "Member 'FBaseItemData::AssetData' has a wrong offset!");
static_assert(offsetof(FBaseItemData, ItemId) == 0x0001D0, "Member 'FBaseItemData::ItemId' has a wrong offset!");

// ScriptStruct DeadByDaylight.ItemData
// 0x00B0 (0x02A0 - 0x01F0)
struct FItemData : public FBaseItemData
{
public:
	TSoftObjectPtr<class USkeletalMesh>           ItemMesh;                                          // 0x01F0(0x0038)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DisplayItemMeshInLobby;                            // 0x0228(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemHandPosition                             HandPosition;                                      // 0x0229(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerRole                                   Role;                                              // 0x022A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemRarity                                   Rarity;                                            // 0x022B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Inventory;                                         // 0x022C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Chest;                                             // 0x022D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EKillerAbilities                              RequiredKillerAbility;                             // 0x022E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22F[0x1];                                      // 0x022F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FItemAvailability                      Availability;                                      // 0x0230(0x0048)(Edit, NativeAccessSpecifierPublic)
	bool                                          IsInNonViolentBuild;                               // 0x0278(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AntiDLC;                                           // 0x0279(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Bloodweb;                                          // 0x027A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanKeepInLoadout;                                  // 0x027B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsBotSupported;                                    // 0x027C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27D[0x3];                                      // 0x027D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   EventID;                                           // 0x0280(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanUseOnlyInEventQueue;                            // 0x028C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanUseAfterEventEnd;                               // 0x028D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELoadoutItemType                              ItemType;                                          // 0x028E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28F[0x1];                                      // 0x028F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FText>                           SearchTags;                                        // 0x0290(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FItemData) == 0x000008, "Wrong alignment on FItemData");
static_assert(sizeof(FItemData) == 0x0002A0, "Wrong size on FItemData");
static_assert(offsetof(FItemData, ItemMesh) == 0x0001F0, "Member 'FItemData::ItemMesh' has a wrong offset!");
static_assert(offsetof(FItemData, DisplayItemMeshInLobby) == 0x000228, "Member 'FItemData::DisplayItemMeshInLobby' has a wrong offset!");
static_assert(offsetof(FItemData, HandPosition) == 0x000229, "Member 'FItemData::HandPosition' has a wrong offset!");
static_assert(offsetof(FItemData, Role) == 0x00022A, "Member 'FItemData::Role' has a wrong offset!");
static_assert(offsetof(FItemData, Rarity) == 0x00022B, "Member 'FItemData::Rarity' has a wrong offset!");
static_assert(offsetof(FItemData, Inventory) == 0x00022C, "Member 'FItemData::Inventory' has a wrong offset!");
static_assert(offsetof(FItemData, Chest) == 0x00022D, "Member 'FItemData::Chest' has a wrong offset!");
static_assert(offsetof(FItemData, RequiredKillerAbility) == 0x00022E, "Member 'FItemData::RequiredKillerAbility' has a wrong offset!");
static_assert(offsetof(FItemData, Availability) == 0x000230, "Member 'FItemData::Availability' has a wrong offset!");
static_assert(offsetof(FItemData, IsInNonViolentBuild) == 0x000278, "Member 'FItemData::IsInNonViolentBuild' has a wrong offset!");
static_assert(offsetof(FItemData, AntiDLC) == 0x000279, "Member 'FItemData::AntiDLC' has a wrong offset!");
static_assert(offsetof(FItemData, Bloodweb) == 0x00027A, "Member 'FItemData::Bloodweb' has a wrong offset!");
static_assert(offsetof(FItemData, CanKeepInLoadout) == 0x00027B, "Member 'FItemData::CanKeepInLoadout' has a wrong offset!");
static_assert(offsetof(FItemData, IsBotSupported) == 0x00027C, "Member 'FItemData::IsBotSupported' has a wrong offset!");
static_assert(offsetof(FItemData, EventID) == 0x000280, "Member 'FItemData::EventID' has a wrong offset!");
static_assert(offsetof(FItemData, CanUseOnlyInEventQueue) == 0x00028C, "Member 'FItemData::CanUseOnlyInEventQueue' has a wrong offset!");
static_assert(offsetof(FItemData, CanUseAfterEventEnd) == 0x00028D, "Member 'FItemData::CanUseAfterEventEnd' has a wrong offset!");
static_assert(offsetof(FItemData, ItemType) == 0x00028E, "Member 'FItemData::ItemType' has a wrong offset!");
static_assert(offsetof(FItemData, SearchTags) == 0x000290, "Member 'FItemData::SearchTags' has a wrong offset!");

// ScriptStruct DeadByDaylight.ItemAddonProperties
// 0x0060 (0x0300 - 0x02A0)
struct FItemAddonProperties final : public FItemData
{
public:
	TSoftClassPtr<class UClass>                   ItemAddonBlueprint;                                // 0x02A0(0x0038)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FParentItemIDs                         ParentItem;                                        // 0x02D8(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<class FName>                           PreLevelGenerationModifierID;                      // 0x02F0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FItemAddonProperties) == 0x000008, "Wrong alignment on FItemAddonProperties");
static_assert(sizeof(FItemAddonProperties) == 0x000300, "Wrong size on FItemAddonProperties");
static_assert(offsetof(FItemAddonProperties, ItemAddonBlueprint) == 0x0002A0, "Member 'FItemAddonProperties::ItemAddonBlueprint' has a wrong offset!");
static_assert(offsetof(FItemAddonProperties, ParentItem) == 0x0002D8, "Member 'FItemAddonProperties::ParentItem' has a wrong offset!");
static_assert(offsetof(FItemAddonProperties, PreLevelGenerationModifierID) == 0x0002F0, "Member 'FItemAddonProperties::PreLevelGenerationModifierID' has a wrong offset!");

// ScriptStruct DeadByDaylight.RewardResponseItem
// 0x0030 (0x0030 - 0x0000)
struct FRewardResponseItem final
{
public:
	class FString                                 Type;                                              // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Type_IsSet;                                        // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ID;                                                // 0x0018(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Amount;                                            // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRewardResponseItem) == 0x000008, "Wrong alignment on FRewardResponseItem");
static_assert(sizeof(FRewardResponseItem) == 0x000030, "Wrong size on FRewardResponseItem");
static_assert(offsetof(FRewardResponseItem, Type) == 0x000000, "Member 'FRewardResponseItem::Type' has a wrong offset!");
static_assert(offsetof(FRewardResponseItem, Type_IsSet) == 0x000010, "Member 'FRewardResponseItem::Type_IsSet' has a wrong offset!");
static_assert(offsetof(FRewardResponseItem, ID) == 0x000018, "Member 'FRewardResponseItem::ID' has a wrong offset!");
static_assert(offsetof(FRewardResponseItem, Amount) == 0x000028, "Member 'FRewardResponseItem::Amount' has a wrong offset!");

// ScriptStruct DeadByDaylight.RewardTrackTierData
// 0x0038 (0x0038 - 0x0000)
struct FRewardTrackTierData final
{
public:
	uint32                                        TierId;                                            // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        TierGroup;                                         // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FRewardResponseItem>            Free;                                              // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          Free_IsSet;                                        // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRewardResponseItem>            Premium;                                           // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          Premium_IsSet;                                     // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRewardTrackTierData) == 0x000008, "Wrong alignment on FRewardTrackTierData");
static_assert(sizeof(FRewardTrackTierData) == 0x000038, "Wrong size on FRewardTrackTierData");
static_assert(offsetof(FRewardTrackTierData, TierId) == 0x000000, "Member 'FRewardTrackTierData::TierId' has a wrong offset!");
static_assert(offsetof(FRewardTrackTierData, TierGroup) == 0x000004, "Member 'FRewardTrackTierData::TierGroup' has a wrong offset!");
static_assert(offsetof(FRewardTrackTierData, Free) == 0x000008, "Member 'FRewardTrackTierData::Free' has a wrong offset!");
static_assert(offsetof(FRewardTrackTierData, Free_IsSet) == 0x000018, "Member 'FRewardTrackTierData::Free_IsSet' has a wrong offset!");
static_assert(offsetof(FRewardTrackTierData, Premium) == 0x000020, "Member 'FRewardTrackTierData::Premium' has a wrong offset!");
static_assert(offsetof(FRewardTrackTierData, Premium_IsSet) == 0x000030, "Member 'FRewardTrackTierData::Premium_IsSet' has a wrong offset!");

// ScriptStruct DeadByDaylight.RewardTrackData
// 0x0028 (0x0028 - 0x0000)
struct FRewardTrackData final
{
public:
	TArray<struct FRewardTrackTierData>           TierInfo;                                          // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint32                                        Requirement;                                       // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x14];                                      // 0x0014(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRewardTrackData) == 0x000008, "Wrong alignment on FRewardTrackData");
static_assert(sizeof(FRewardTrackData) == 0x000028, "Wrong size on FRewardTrackData");
static_assert(offsetof(FRewardTrackData, TierInfo) == 0x000000, "Member 'FRewardTrackData::TierInfo' has a wrong offset!");
static_assert(offsetof(FRewardTrackData, Requirement) == 0x000010, "Member 'FRewardTrackData::Requirement' has a wrong offset!");

// ScriptStruct DeadByDaylight.ScreenshotViewSetting
// 0x0028 (0x0028 - 0x0000)
struct FScreenshotViewSetting final
{
public:
	float                                         Distance;                                          // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LateralOffset;                                     // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeightOffset;                                      // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CharacterYaw;                                      // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CharacterRoll;                                     // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CharacterPitch;                                    // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraPitch;                                       // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SocketName;                                        // 0x001C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FScreenshotViewSetting) == 0x000004, "Wrong alignment on FScreenshotViewSetting");
static_assert(sizeof(FScreenshotViewSetting) == 0x000028, "Wrong size on FScreenshotViewSetting");
static_assert(offsetof(FScreenshotViewSetting, Distance) == 0x000000, "Member 'FScreenshotViewSetting::Distance' has a wrong offset!");
static_assert(offsetof(FScreenshotViewSetting, LateralOffset) == 0x000004, "Member 'FScreenshotViewSetting::LateralOffset' has a wrong offset!");
static_assert(offsetof(FScreenshotViewSetting, HeightOffset) == 0x000008, "Member 'FScreenshotViewSetting::HeightOffset' has a wrong offset!");
static_assert(offsetof(FScreenshotViewSetting, CharacterYaw) == 0x00000C, "Member 'FScreenshotViewSetting::CharacterYaw' has a wrong offset!");
static_assert(offsetof(FScreenshotViewSetting, CharacterRoll) == 0x000010, "Member 'FScreenshotViewSetting::CharacterRoll' has a wrong offset!");
static_assert(offsetof(FScreenshotViewSetting, CharacterPitch) == 0x000014, "Member 'FScreenshotViewSetting::CharacterPitch' has a wrong offset!");
static_assert(offsetof(FScreenshotViewSetting, CameraPitch) == 0x000018, "Member 'FScreenshotViewSetting::CameraPitch' has a wrong offset!");
static_assert(offsetof(FScreenshotViewSetting, SocketName) == 0x00001C, "Member 'FScreenshotViewSetting::SocketName' has a wrong offset!");

// ScriptStruct DeadByDaylight.ScoreEventData
// 0x0018 (0x0018 - 0x0000)
struct FScoreEventData final
{
public:
	class AActor*                                 Target;                                            // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PercentToAward;                                    // 0x0008(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                CustomObjectParameter;                             // 0x0010(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FScoreEventData) == 0x000008, "Wrong alignment on FScoreEventData");
static_assert(sizeof(FScoreEventData) == 0x000018, "Wrong size on FScoreEventData");
static_assert(offsetof(FScoreEventData, Target) == 0x000000, "Member 'FScoreEventData::Target' has a wrong offset!");
static_assert(offsetof(FScoreEventData, PercentToAward) == 0x000008, "Member 'FScoreEventData::PercentToAward' has a wrong offset!");
static_assert(offsetof(FScoreEventData, CustomObjectParameter) == 0x000010, "Member 'FScoreEventData::CustomObjectParameter' has a wrong offset!");

// ScriptStruct DeadByDaylight.SavedStatsData
// 0x0014 (0x0014 - 0x0000)
struct FSavedStatsData final
{
public:
	uint32                                        Version;                                           // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Name;                                              // 0x0004(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSavedStatsData) == 0x000004, "Wrong alignment on FSavedStatsData");
static_assert(sizeof(FSavedStatsData) == 0x000014, "Wrong size on FSavedStatsData");
static_assert(offsetof(FSavedStatsData, Version) == 0x000000, "Member 'FSavedStatsData::Version' has a wrong offset!");
static_assert(offsetof(FSavedStatsData, Name) == 0x000004, "Member 'FSavedStatsData::Name' has a wrong offset!");
static_assert(offsetof(FSavedStatsData, Value) == 0x000010, "Member 'FSavedStatsData::Value' has a wrong offset!");

// ScriptStruct DeadByDaylight.NotificationHistoryElement
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x04) FNotificationHistoryElement final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNotificationHistoryElement) == 0x000004, "Wrong alignment on FNotificationHistoryElement");
static_assert(sizeof(FNotificationHistoryElement) == 0x000018, "Wrong size on FNotificationHistoryElement");

// ScriptStruct DeadByDaylight.AnimationPreviewCharacterRequest
// 0x00E0 (0x00E0 - 0x0000)
struct FAnimationPreviewCharacterRequest final
{
public:
	EPlayerRole                                   Role;                                              // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CharacterId;                                       // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   CharacterClass;                                    // 0x0008(0x0038)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FEquippedPlayerCustomization           Customization;                                     // 0x0040(0x0038)(NativeAccessSpecifierPublic)
	uint8                                         Pad_78[0x8];                                       // 0x0078(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             SpawnTransform;                                    // 0x0080(0x0060)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimationPreviewCharacterRequest) == 0x000010, "Wrong alignment on FAnimationPreviewCharacterRequest");
static_assert(sizeof(FAnimationPreviewCharacterRequest) == 0x0000E0, "Wrong size on FAnimationPreviewCharacterRequest");
static_assert(offsetof(FAnimationPreviewCharacterRequest, Role) == 0x000000, "Member 'FAnimationPreviewCharacterRequest::Role' has a wrong offset!");
static_assert(offsetof(FAnimationPreviewCharacterRequest, CharacterId) == 0x000004, "Member 'FAnimationPreviewCharacterRequest::CharacterId' has a wrong offset!");
static_assert(offsetof(FAnimationPreviewCharacterRequest, CharacterClass) == 0x000008, "Member 'FAnimationPreviewCharacterRequest::CharacterClass' has a wrong offset!");
static_assert(offsetof(FAnimationPreviewCharacterRequest, Customization) == 0x000040, "Member 'FAnimationPreviewCharacterRequest::Customization' has a wrong offset!");
static_assert(offsetof(FAnimationPreviewCharacterRequest, SpawnTransform) == 0x000080, "Member 'FAnimationPreviewCharacterRequest::SpawnTransform' has a wrong offset!");

// ScriptStruct DeadByDaylight.InteractionPlayerProperties
// 0x0078 (0x0078 - 0x0000)
struct FInteractionPlayerProperties final
{
public:
	struct FVector_NetQuantize                    PlayerPositionAtStart;                             // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               PlayerRotationAtStart;                             // 0x0018(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class ADBDPlayer>              Requester;                                         // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize                    SnapPositionAtStart;                               // 0x0038(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               SnapRotationAtStart;                               // 0x0050(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         SnapDistanceAtStart;                               // 0x0068(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SnapTimeAtStart;                                   // 0x006C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShouldSnapPosition;                                // 0x0070(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShouldSweepOnFinalSnap;                            // 0x0071(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_72[0x6];                                       // 0x0072(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FInteractionPlayerProperties) == 0x000008, "Wrong alignment on FInteractionPlayerProperties");
static_assert(sizeof(FInteractionPlayerProperties) == 0x000078, "Wrong size on FInteractionPlayerProperties");
static_assert(offsetof(FInteractionPlayerProperties, PlayerPositionAtStart) == 0x000000, "Member 'FInteractionPlayerProperties::PlayerPositionAtStart' has a wrong offset!");
static_assert(offsetof(FInteractionPlayerProperties, PlayerRotationAtStart) == 0x000018, "Member 'FInteractionPlayerProperties::PlayerRotationAtStart' has a wrong offset!");
static_assert(offsetof(FInteractionPlayerProperties, Requester) == 0x000030, "Member 'FInteractionPlayerProperties::Requester' has a wrong offset!");
static_assert(offsetof(FInteractionPlayerProperties, SnapPositionAtStart) == 0x000038, "Member 'FInteractionPlayerProperties::SnapPositionAtStart' has a wrong offset!");
static_assert(offsetof(FInteractionPlayerProperties, SnapRotationAtStart) == 0x000050, "Member 'FInteractionPlayerProperties::SnapRotationAtStart' has a wrong offset!");
static_assert(offsetof(FInteractionPlayerProperties, SnapDistanceAtStart) == 0x000068, "Member 'FInteractionPlayerProperties::SnapDistanceAtStart' has a wrong offset!");
static_assert(offsetof(FInteractionPlayerProperties, SnapTimeAtStart) == 0x00006C, "Member 'FInteractionPlayerProperties::SnapTimeAtStart' has a wrong offset!");
static_assert(offsetof(FInteractionPlayerProperties, ShouldSnapPosition) == 0x000070, "Member 'FInteractionPlayerProperties::ShouldSnapPosition' has a wrong offset!");
static_assert(offsetof(FInteractionPlayerProperties, ShouldSweepOnFinalSnap) == 0x000071, "Member 'FInteractionPlayerProperties::ShouldSweepOnFinalSnap' has a wrong offset!");

// ScriptStruct DeadByDaylight.ItemVfxLoadingData
// 0x0010 (0x0010 - 0x0000)
struct FItemVfxLoadingData final
{
public:
	class AItemVfx*                               ItemVfx;                                           // 0x0000(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FItemVfxLoadingData) == 0x000008, "Wrong alignment on FItemVfxLoadingData");
static_assert(sizeof(FItemVfxLoadingData) == 0x000010, "Wrong size on FItemVfxLoadingData");
static_assert(offsetof(FItemVfxLoadingData, ItemVfx) == 0x000000, "Member 'FItemVfxLoadingData::ItemVfx' has a wrong offset!");

// ScriptStruct DeadByDaylight.EffectCameraTypeSettings
// 0x0003 (0x0003 - 0x0000)
struct FEffectCameraTypeSettings final
{
public:
	ECustomizationCategory                        Category;                                          // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          VisibilityInFirstPerson;                           // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          VisibilityInThirdPerson;                           // 0x0002(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEffectCameraTypeSettings) == 0x000001, "Wrong alignment on FEffectCameraTypeSettings");
static_assert(sizeof(FEffectCameraTypeSettings) == 0x000003, "Wrong size on FEffectCameraTypeSettings");
static_assert(offsetof(FEffectCameraTypeSettings, Category) == 0x000000, "Member 'FEffectCameraTypeSettings::Category' has a wrong offset!");
static_assert(offsetof(FEffectCameraTypeSettings, VisibilityInFirstPerson) == 0x000001, "Member 'FEffectCameraTypeSettings::VisibilityInFirstPerson' has a wrong offset!");
static_assert(offsetof(FEffectCameraTypeSettings, VisibilityInThirdPerson) == 0x000002, "Member 'FEffectCameraTypeSettings::VisibilityInThirdPerson' has a wrong offset!");

// ScriptStruct DeadByDaylight.CharacterCustomizationPreset
// 0x0038 (0x0038 - 0x0000)
struct FCharacterCustomizationPreset final
{
public:
	class FName                                   Head;                                              // 0x0000(0x000C)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TorsoOrBody;                                       // 0x000C(0x000C)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LegsOrWeapon;                                      // 0x0018(0x000C)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCharmIdSlot>                   Charms;                                            // 0x0028(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterCustomizationPreset) == 0x000008, "Wrong alignment on FCharacterCustomizationPreset");
static_assert(sizeof(FCharacterCustomizationPreset) == 0x000038, "Wrong size on FCharacterCustomizationPreset");
static_assert(offsetof(FCharacterCustomizationPreset, Head) == 0x000000, "Member 'FCharacterCustomizationPreset::Head' has a wrong offset!");
static_assert(offsetof(FCharacterCustomizationPreset, TorsoOrBody) == 0x00000C, "Member 'FCharacterCustomizationPreset::TorsoOrBody' has a wrong offset!");
static_assert(offsetof(FCharacterCustomizationPreset, LegsOrWeapon) == 0x000018, "Member 'FCharacterCustomizationPreset::LegsOrWeapon' has a wrong offset!");
static_assert(offsetof(FCharacterCustomizationPreset, Charms) == 0x000028, "Member 'FCharacterCustomizationPreset::Charms' has a wrong offset!");

// ScriptStruct DeadByDaylight.CharacterCustomizationPresetsList
// 0x0018 (0x0018 - 0x0000)
struct FCharacterCustomizationPresetsList final
{
public:
	int32                                         CharacterId;                                       // 0x0000(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ActivePreset;                                      // 0x0004(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FCharacterCustomizationPreset>  Presets;                                           // 0x0008(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterCustomizationPresetsList) == 0x000008, "Wrong alignment on FCharacterCustomizationPresetsList");
static_assert(sizeof(FCharacterCustomizationPresetsList) == 0x000018, "Wrong size on FCharacterCustomizationPresetsList");
static_assert(offsetof(FCharacterCustomizationPresetsList, CharacterId) == 0x000000, "Member 'FCharacterCustomizationPresetsList::CharacterId' has a wrong offset!");
static_assert(offsetof(FCharacterCustomizationPresetsList, ActivePreset) == 0x000004, "Member 'FCharacterCustomizationPresetsList::ActivePreset' has a wrong offset!");
static_assert(offsetof(FCharacterCustomizationPresetsList, Presets) == 0x000008, "Member 'FCharacterCustomizationPresetsList::Presets' has a wrong offset!");

// ScriptStruct DeadByDaylight.CustomizationPresetsDataForGameType
// 0x0010 (0x0010 - 0x0000)
struct FCustomizationPresetsDataForGameType final
{
public:
	TArray<struct FCharacterCustomizationPresetsList> CharacterCustomizationPresetsList;                 // 0x0000(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCustomizationPresetsDataForGameType) == 0x000008, "Wrong alignment on FCustomizationPresetsDataForGameType");
static_assert(sizeof(FCustomizationPresetsDataForGameType) == 0x000010, "Wrong size on FCustomizationPresetsDataForGameType");
static_assert(offsetof(FCustomizationPresetsDataForGameType, CharacterCustomizationPresetsList) == 0x000000, "Member 'FCustomizationPresetsDataForGameType::CharacterCustomizationPresetsList' has a wrong offset!");

// ScriptStruct DeadByDaylight.ArchivesQuestCondition
// 0x0020 (0x0020 - 0x0000)
struct FArchivesQuestCondition final
{
public:
	class FString                                 Key;                                               // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         Value;                                             // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FArchivesQuestCondition) == 0x000008, "Wrong alignment on FArchivesQuestCondition");
static_assert(sizeof(FArchivesQuestCondition) == 0x000020, "Wrong size on FArchivesQuestCondition");
static_assert(offsetof(FArchivesQuestCondition, Key) == 0x000000, "Member 'FArchivesQuestCondition::Key' has a wrong offset!");
static_assert(offsetof(FArchivesQuestCondition, Value) == 0x000010, "Member 'FArchivesQuestCondition::Value' has a wrong offset!");

// ScriptStruct DeadByDaylight.ArchivesQuestEvent
// 0x0040 (0x0040 - 0x0000)
struct FArchivesQuestEvent final
{
public:
	class FString                                 QuestEventId;                                      // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Repetition;                                        // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Parameters;                                        // 0x0018(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Operation;                                         // 0x0028(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Parameters_IsSet;                                  // 0x0038(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Operation_IsSet;                                   // 0x0039(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x6];                                       // 0x003A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FArchivesQuestEvent) == 0x000008, "Wrong alignment on FArchivesQuestEvent");
static_assert(sizeof(FArchivesQuestEvent) == 0x000040, "Wrong size on FArchivesQuestEvent");
static_assert(offsetof(FArchivesQuestEvent, QuestEventId) == 0x000000, "Member 'FArchivesQuestEvent::QuestEventId' has a wrong offset!");
static_assert(offsetof(FArchivesQuestEvent, Repetition) == 0x000010, "Member 'FArchivesQuestEvent::Repetition' has a wrong offset!");
static_assert(offsetof(FArchivesQuestEvent, Parameters) == 0x000018, "Member 'FArchivesQuestEvent::Parameters' has a wrong offset!");
static_assert(offsetof(FArchivesQuestEvent, Operation) == 0x000028, "Member 'FArchivesQuestEvent::Operation' has a wrong offset!");
static_assert(offsetof(FArchivesQuestEvent, Parameters_IsSet) == 0x000038, "Member 'FArchivesQuestEvent::Parameters_IsSet' has a wrong offset!");
static_assert(offsetof(FArchivesQuestEvent, Operation_IsSet) == 0x000039, "Member 'FArchivesQuestEvent::Operation_IsSet' has a wrong offset!");

// ScriptStruct DeadByDaylight.ArchivesQuestSpecialBehaviour
// 0x0028 (0x0028 - 0x0000)
struct FArchivesQuestSpecialBehaviour final
{
public:
	class FString                                 ID;                                                // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Params;                                            // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Params_IsSet;                                      // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FArchivesQuestSpecialBehaviour) == 0x000008, "Wrong alignment on FArchivesQuestSpecialBehaviour");
static_assert(sizeof(FArchivesQuestSpecialBehaviour) == 0x000028, "Wrong size on FArchivesQuestSpecialBehaviour");
static_assert(offsetof(FArchivesQuestSpecialBehaviour, ID) == 0x000000, "Member 'FArchivesQuestSpecialBehaviour::ID' has a wrong offset!");
static_assert(offsetof(FArchivesQuestSpecialBehaviour, Params) == 0x000010, "Member 'FArchivesQuestSpecialBehaviour::Params' has a wrong offset!");
static_assert(offsetof(FArchivesQuestSpecialBehaviour, Params_IsSet) == 0x000020, "Member 'FArchivesQuestSpecialBehaviour::Params_IsSet' has a wrong offset!");

// ScriptStruct DeadByDaylight.ArchivesObjective
// 0x0060 (0x0060 - 0x0000)
struct FArchivesObjective final
{
public:
	class FString                                 ObjectiveId;                                       // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ObjectiveId_IsSet;                                 // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IncrementWithEventRepetitions;                     // 0x0011(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x2];                                       // 0x0012(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NeededProgression;                                 // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FArchivesQuestCondition>        Conditions;                                        // 0x0018(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          Conditions_IsSet;                                  // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FArchivesQuestEvent>            QuestEvent;                                        // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          QuestEvent_IsSet;                                  // 0x0040(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FArchivesQuestSpecialBehaviour> SpecialBehaviours;                                 // 0x0048(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          SpecialBehaviours_IsSet;                           // 0x0058(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsCommunityObjective;                              // 0x0059(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsCommunityObjective_IsSet;                        // 0x005A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5B[0x5];                                       // 0x005B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FArchivesObjective) == 0x000008, "Wrong alignment on FArchivesObjective");
static_assert(sizeof(FArchivesObjective) == 0x000060, "Wrong size on FArchivesObjective");
static_assert(offsetof(FArchivesObjective, ObjectiveId) == 0x000000, "Member 'FArchivesObjective::ObjectiveId' has a wrong offset!");
static_assert(offsetof(FArchivesObjective, ObjectiveId_IsSet) == 0x000010, "Member 'FArchivesObjective::ObjectiveId_IsSet' has a wrong offset!");
static_assert(offsetof(FArchivesObjective, IncrementWithEventRepetitions) == 0x000011, "Member 'FArchivesObjective::IncrementWithEventRepetitions' has a wrong offset!");
static_assert(offsetof(FArchivesObjective, NeededProgression) == 0x000014, "Member 'FArchivesObjective::NeededProgression' has a wrong offset!");
static_assert(offsetof(FArchivesObjective, Conditions) == 0x000018, "Member 'FArchivesObjective::Conditions' has a wrong offset!");
static_assert(offsetof(FArchivesObjective, Conditions_IsSet) == 0x000028, "Member 'FArchivesObjective::Conditions_IsSet' has a wrong offset!");
static_assert(offsetof(FArchivesObjective, QuestEvent) == 0x000030, "Member 'FArchivesObjective::QuestEvent' has a wrong offset!");
static_assert(offsetof(FArchivesObjective, QuestEvent_IsSet) == 0x000040, "Member 'FArchivesObjective::QuestEvent_IsSet' has a wrong offset!");
static_assert(offsetof(FArchivesObjective, SpecialBehaviours) == 0x000048, "Member 'FArchivesObjective::SpecialBehaviours' has a wrong offset!");
static_assert(offsetof(FArchivesObjective, SpecialBehaviours_IsSet) == 0x000058, "Member 'FArchivesObjective::SpecialBehaviours_IsSet' has a wrong offset!");
static_assert(offsetof(FArchivesObjective, IsCommunityObjective) == 0x000059, "Member 'FArchivesObjective::IsCommunityObjective' has a wrong offset!");
static_assert(offsetof(FArchivesObjective, IsCommunityObjective_IsSet) == 0x00005A, "Member 'FArchivesObjective::IsCommunityObjective_IsSet' has a wrong offset!");

// ScriptStruct DeadByDaylight.AIDetectedStimulus
// 0x00E8 (0x00E8 - 0x0000)
struct FAIDetectedStimulus final
{
public:
	TWeakObjectPtr<class AActor>                  Instigator;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0008(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0020(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Velocity;                                          // 0x0038(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LastHasBeenSeenLocation;                           // 0x0050(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LastHasBeenSeenDirection;                          // 0x0068(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastHasBeenSeenTime;                               // 0x0080(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NextHasBeenSeenUpdateTime;                         // 0x0084(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AtTime;                                            // 0x0088(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Tag;                                               // 0x008C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_98[0x50];                                      // 0x0098(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIDetectedStimulus) == 0x000008, "Wrong alignment on FAIDetectedStimulus");
static_assert(sizeof(FAIDetectedStimulus) == 0x0000E8, "Wrong size on FAIDetectedStimulus");
static_assert(offsetof(FAIDetectedStimulus, Instigator) == 0x000000, "Member 'FAIDetectedStimulus::Instigator' has a wrong offset!");
static_assert(offsetof(FAIDetectedStimulus, Location) == 0x000008, "Member 'FAIDetectedStimulus::Location' has a wrong offset!");
static_assert(offsetof(FAIDetectedStimulus, Rotation) == 0x000020, "Member 'FAIDetectedStimulus::Rotation' has a wrong offset!");
static_assert(offsetof(FAIDetectedStimulus, Velocity) == 0x000038, "Member 'FAIDetectedStimulus::Velocity' has a wrong offset!");
static_assert(offsetof(FAIDetectedStimulus, LastHasBeenSeenLocation) == 0x000050, "Member 'FAIDetectedStimulus::LastHasBeenSeenLocation' has a wrong offset!");
static_assert(offsetof(FAIDetectedStimulus, LastHasBeenSeenDirection) == 0x000068, "Member 'FAIDetectedStimulus::LastHasBeenSeenDirection' has a wrong offset!");
static_assert(offsetof(FAIDetectedStimulus, LastHasBeenSeenTime) == 0x000080, "Member 'FAIDetectedStimulus::LastHasBeenSeenTime' has a wrong offset!");
static_assert(offsetof(FAIDetectedStimulus, NextHasBeenSeenUpdateTime) == 0x000084, "Member 'FAIDetectedStimulus::NextHasBeenSeenUpdateTime' has a wrong offset!");
static_assert(offsetof(FAIDetectedStimulus, AtTime) == 0x000088, "Member 'FAIDetectedStimulus::AtTime' has a wrong offset!");
static_assert(offsetof(FAIDetectedStimulus, Tag) == 0x00008C, "Member 'FAIDetectedStimulus::Tag' has a wrong offset!");

// ScriptStruct DeadByDaylight.AccessoryLoadingData
// 0x00F8 (0x00F8 - 0x0000)
struct FAccessoryLoadingData final
{
public:
	uint8                                         Pad_0[0xF0];                                       // 0x0000(0x00F0)(Fixing Size After Last Property [ Dumper-7 ])
	class UAccessory*                             Accessory;                                         // 0x00F0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAccessoryLoadingData) == 0x000008, "Wrong alignment on FAccessoryLoadingData");
static_assert(sizeof(FAccessoryLoadingData) == 0x0000F8, "Wrong size on FAccessoryLoadingData");
static_assert(offsetof(FAccessoryLoadingData, Accessory) == 0x0000F0, "Member 'FAccessoryLoadingData::Accessory' has a wrong offset!");

// ScriptStruct DeadByDaylight.CamperHealResult
// 0x0018 (0x0018 - 0x0000)
struct FCamperHealResult final
{
public:
	ECamperDamageState                            PreviousDamageState;                               // 0x0000(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECamperDamageState                            CurrentDamageState;                                // 0x0001(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         HealAmount;                                        // 0x0004(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ADBDPlayer*>                     Healers;                                           // 0x0008(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCamperHealResult) == 0x000008, "Wrong alignment on FCamperHealResult");
static_assert(sizeof(FCamperHealResult) == 0x000018, "Wrong size on FCamperHealResult");
static_assert(offsetof(FCamperHealResult, PreviousDamageState) == 0x000000, "Member 'FCamperHealResult::PreviousDamageState' has a wrong offset!");
static_assert(offsetof(FCamperHealResult, CurrentDamageState) == 0x000001, "Member 'FCamperHealResult::CurrentDamageState' has a wrong offset!");
static_assert(offsetof(FCamperHealResult, HealAmount) == 0x000004, "Member 'FCamperHealResult::HealAmount' has a wrong offset!");
static_assert(offsetof(FCamperHealResult, Healers) == 0x000008, "Member 'FCamperHealResult::Healers' has a wrong offset!");

// ScriptStruct DeadByDaylight.CharacterToolSpawnParameters
// 0x0003 (0x0003 - 0x0000)
struct FCharacterToolSpawnParameters final
{
public:
	bool                                          IsAnimated;                                        // 0x0000(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShowPower;                                         // 0x0001(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseMasterPoseForItems;                             // 0x0002(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterToolSpawnParameters) == 0x000001, "Wrong alignment on FCharacterToolSpawnParameters");
static_assert(sizeof(FCharacterToolSpawnParameters) == 0x000003, "Wrong size on FCharacterToolSpawnParameters");
static_assert(offsetof(FCharacterToolSpawnParameters, IsAnimated) == 0x000000, "Member 'FCharacterToolSpawnParameters::IsAnimated' has a wrong offset!");
static_assert(offsetof(FCharacterToolSpawnParameters, ShowPower) == 0x000001, "Member 'FCharacterToolSpawnParameters::ShowPower' has a wrong offset!");
static_assert(offsetof(FCharacterToolSpawnParameters, UseMasterPoseForItems) == 0x000002, "Member 'FCharacterToolSpawnParameters::UseMasterPoseForItems' has a wrong offset!");

// ScriptStruct DeadByDaylight.PalletPushSettings
// 0x0002 (0x0002 - 0x0000)
struct FPalletPushSettings final
{
public:
	bool                                          IgnorePlayerExecutingPulldown;                     // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPalletPushSideStrategy                       PalletPushSideStrategy;                            // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPalletPushSettings) == 0x000001, "Wrong alignment on FPalletPushSettings");
static_assert(sizeof(FPalletPushSettings) == 0x000002, "Wrong size on FPalletPushSettings");
static_assert(offsetof(FPalletPushSettings, IgnorePlayerExecutingPulldown) == 0x000000, "Member 'FPalletPushSettings::IgnorePlayerExecutingPulldown' has a wrong offset!");
static_assert(offsetof(FPalletPushSettings, PalletPushSideStrategy) == 0x000001, "Member 'FPalletPushSettings::PalletPushSideStrategy' has a wrong offset!");

// ScriptStruct DeadByDaylight.GameplayNotificationData
// 0x0058 (0x0058 - 0x0000)
struct FGameplayNotificationData final
{
public:
	class FName                                   SourceID;                                          // 0x0000(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EInventoryItemType                            SourceType;                                        // 0x000C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SourceIconIndex;                                   // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SourceLevel;                                       // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   EffectId;                                          // 0x0018(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 EffectIconFilePath;                                // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EStatusEffectType                             EffectType;                                        // 0x0038(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   EffectDisplayName;                                 // 0x0040(0x0018)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FGameplayNotificationData) == 0x000008, "Wrong alignment on FGameplayNotificationData");
static_assert(sizeof(FGameplayNotificationData) == 0x000058, "Wrong size on FGameplayNotificationData");
static_assert(offsetof(FGameplayNotificationData, SourceID) == 0x000000, "Member 'FGameplayNotificationData::SourceID' has a wrong offset!");
static_assert(offsetof(FGameplayNotificationData, SourceType) == 0x00000C, "Member 'FGameplayNotificationData::SourceType' has a wrong offset!");
static_assert(offsetof(FGameplayNotificationData, SourceIconIndex) == 0x000010, "Member 'FGameplayNotificationData::SourceIconIndex' has a wrong offset!");
static_assert(offsetof(FGameplayNotificationData, SourceLevel) == 0x000014, "Member 'FGameplayNotificationData::SourceLevel' has a wrong offset!");
static_assert(offsetof(FGameplayNotificationData, EffectId) == 0x000018, "Member 'FGameplayNotificationData::EffectId' has a wrong offset!");
static_assert(offsetof(FGameplayNotificationData, EffectIconFilePath) == 0x000028, "Member 'FGameplayNotificationData::EffectIconFilePath' has a wrong offset!");
static_assert(offsetof(FGameplayNotificationData, EffectType) == 0x000038, "Member 'FGameplayNotificationData::EffectType' has a wrong offset!");
static_assert(offsetof(FGameplayNotificationData, EffectDisplayName) == 0x000040, "Member 'FGameplayNotificationData::EffectDisplayName' has a wrong offset!");

// ScriptStruct DeadByDaylight.ArchiveDefinition
// 0x00D8 (0x00F0 - 0x0018)
struct FArchiveDefinition final : public FDBDTableRowBaseWithId
{
public:
	int32                                         Number;                                            // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Title;                                             // 0x0020(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0038(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FString                                 PurchasePassPicturePath;                           // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PurchaseTierPicturePath;                           // 0x0060(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   PurchasePassPopupMessage;                          // 0x0070(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	EArchivesEventStyle                           EventStyle;                                        // 0x0088(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UTexture2D>              StoryBookMarkTexture;                              // 0x0090(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 StyleFrameLabel;                                   // 0x00C8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 EventStoryLabel;                                   // 0x00D8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseLimitedTimeEventSkin;                           // 0x00E8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E9[0x7];                                       // 0x00E9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FArchiveDefinition) == 0x000008, "Wrong alignment on FArchiveDefinition");
static_assert(sizeof(FArchiveDefinition) == 0x0000F0, "Wrong size on FArchiveDefinition");
static_assert(offsetof(FArchiveDefinition, Number) == 0x000018, "Member 'FArchiveDefinition::Number' has a wrong offset!");
static_assert(offsetof(FArchiveDefinition, Title) == 0x000020, "Member 'FArchiveDefinition::Title' has a wrong offset!");
static_assert(offsetof(FArchiveDefinition, Description) == 0x000038, "Member 'FArchiveDefinition::Description' has a wrong offset!");
static_assert(offsetof(FArchiveDefinition, PurchasePassPicturePath) == 0x000050, "Member 'FArchiveDefinition::PurchasePassPicturePath' has a wrong offset!");
static_assert(offsetof(FArchiveDefinition, PurchaseTierPicturePath) == 0x000060, "Member 'FArchiveDefinition::PurchaseTierPicturePath' has a wrong offset!");
static_assert(offsetof(FArchiveDefinition, PurchasePassPopupMessage) == 0x000070, "Member 'FArchiveDefinition::PurchasePassPopupMessage' has a wrong offset!");
static_assert(offsetof(FArchiveDefinition, EventStyle) == 0x000088, "Member 'FArchiveDefinition::EventStyle' has a wrong offset!");
static_assert(offsetof(FArchiveDefinition, StoryBookMarkTexture) == 0x000090, "Member 'FArchiveDefinition::StoryBookMarkTexture' has a wrong offset!");
static_assert(offsetof(FArchiveDefinition, StyleFrameLabel) == 0x0000C8, "Member 'FArchiveDefinition::StyleFrameLabel' has a wrong offset!");
static_assert(offsetof(FArchiveDefinition, EventStoryLabel) == 0x0000D8, "Member 'FArchiveDefinition::EventStoryLabel' has a wrong offset!");
static_assert(offsetof(FArchiveDefinition, UseLimitedTimeEventSkin) == 0x0000E8, "Member 'FArchiveDefinition::UseLimitedTimeEventSkin' has a wrong offset!");

// ScriptStruct DeadByDaylight.AIGameModeFilter
// 0x0020 (0x0020 - 0x0000)
struct FAIGameModeFilter final
{
public:
	TArray<class FName>                           SpecialEventIds;                                   // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<EGameType>                             GameTypes;                                         // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIGameModeFilter) == 0x000008, "Wrong alignment on FAIGameModeFilter");
static_assert(sizeof(FAIGameModeFilter) == 0x000020, "Wrong size on FAIGameModeFilter");
static_assert(offsetof(FAIGameModeFilter, SpecialEventIds) == 0x000000, "Member 'FAIGameModeFilter::SpecialEventIds' has a wrong offset!");
static_assert(offsetof(FAIGameModeFilter, GameTypes) == 0x000010, "Member 'FAIGameModeFilter::GameTypes' has a wrong offset!");

// ScriptStruct DeadByDaylight.AICamperDodgeTunableRowData
// 0x0088 (0x0090 - 0x0008)
struct FAICamperDodgeTunableRowData final : public FDBDTableRowBase
{
public:
	int32                                         CharacterId;                                       // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AttackGameEvent;                                   // 0x000C(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAIGameModeFilter                      GameModeFilter;                                    // 0x0018(0x0020)(Edit, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0038(0x0018)(Edit, NativeAccessSpecifierPublic)
	EAIDodgeType                                  BestDodgeType;                                     // 0x0050(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EAIDodgeTechnique>                     DodgeTechniques;                                   // 0x0058(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          RequireInSight;                                    // 0x0068(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RequireAttackState;                                // 0x0069(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6A[0x2];                                       // 0x006A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Duration;                                          // 0x006C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReactionTime;                                      // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReactionTimeVariance;                              // 0x0074(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExtraReactionTimeAtMaxRange;                       // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExtraReactionTimeWhenHidden;                       // 0x007C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Range;                                             // 0x0080(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttackPlusSurvivorHalfWidth;                       // 0x0084(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FieldOfView;                                       // 0x0088(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseOtherPositionInsteadOfKiller;                   // 0x008C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8D[0x3];                                       // 0x008D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAICamperDodgeTunableRowData) == 0x000008, "Wrong alignment on FAICamperDodgeTunableRowData");
static_assert(sizeof(FAICamperDodgeTunableRowData) == 0x000090, "Wrong size on FAICamperDodgeTunableRowData");
static_assert(offsetof(FAICamperDodgeTunableRowData, CharacterId) == 0x000008, "Member 'FAICamperDodgeTunableRowData::CharacterId' has a wrong offset!");
static_assert(offsetof(FAICamperDodgeTunableRowData, AttackGameEvent) == 0x00000C, "Member 'FAICamperDodgeTunableRowData::AttackGameEvent' has a wrong offset!");
static_assert(offsetof(FAICamperDodgeTunableRowData, GameModeFilter) == 0x000018, "Member 'FAICamperDodgeTunableRowData::GameModeFilter' has a wrong offset!");
static_assert(offsetof(FAICamperDodgeTunableRowData, Description) == 0x000038, "Member 'FAICamperDodgeTunableRowData::Description' has a wrong offset!");
static_assert(offsetof(FAICamperDodgeTunableRowData, BestDodgeType) == 0x000050, "Member 'FAICamperDodgeTunableRowData::BestDodgeType' has a wrong offset!");
static_assert(offsetof(FAICamperDodgeTunableRowData, DodgeTechniques) == 0x000058, "Member 'FAICamperDodgeTunableRowData::DodgeTechniques' has a wrong offset!");
static_assert(offsetof(FAICamperDodgeTunableRowData, RequireInSight) == 0x000068, "Member 'FAICamperDodgeTunableRowData::RequireInSight' has a wrong offset!");
static_assert(offsetof(FAICamperDodgeTunableRowData, RequireAttackState) == 0x000069, "Member 'FAICamperDodgeTunableRowData::RequireAttackState' has a wrong offset!");
static_assert(offsetof(FAICamperDodgeTunableRowData, Duration) == 0x00006C, "Member 'FAICamperDodgeTunableRowData::Duration' has a wrong offset!");
static_assert(offsetof(FAICamperDodgeTunableRowData, ReactionTime) == 0x000070, "Member 'FAICamperDodgeTunableRowData::ReactionTime' has a wrong offset!");
static_assert(offsetof(FAICamperDodgeTunableRowData, ReactionTimeVariance) == 0x000074, "Member 'FAICamperDodgeTunableRowData::ReactionTimeVariance' has a wrong offset!");
static_assert(offsetof(FAICamperDodgeTunableRowData, ExtraReactionTimeAtMaxRange) == 0x000078, "Member 'FAICamperDodgeTunableRowData::ExtraReactionTimeAtMaxRange' has a wrong offset!");
static_assert(offsetof(FAICamperDodgeTunableRowData, ExtraReactionTimeWhenHidden) == 0x00007C, "Member 'FAICamperDodgeTunableRowData::ExtraReactionTimeWhenHidden' has a wrong offset!");
static_assert(offsetof(FAICamperDodgeTunableRowData, Range) == 0x000080, "Member 'FAICamperDodgeTunableRowData::Range' has a wrong offset!");
static_assert(offsetof(FAICamperDodgeTunableRowData, AttackPlusSurvivorHalfWidth) == 0x000084, "Member 'FAICamperDodgeTunableRowData::AttackPlusSurvivorHalfWidth' has a wrong offset!");
static_assert(offsetof(FAICamperDodgeTunableRowData, FieldOfView) == 0x000088, "Member 'FAICamperDodgeTunableRowData::FieldOfView' has a wrong offset!");
static_assert(offsetof(FAICamperDodgeTunableRowData, UseOtherPositionInsteadOfKiller) == 0x00008C, "Member 'FAICamperDodgeTunableRowData::UseOtherPositionInsteadOfKiller' has a wrong offset!");

// ScriptStruct DeadByDaylight.SkillProperties
// 0x0050 (0x02F0 - 0x02A0)
struct FSkillProperties final : public FItemData
{
public:
	TSoftObjectPtr<class USkillData>              SkillData;                                         // 0x02A0(0x0038)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESkillCategory                                SkillCategory;                                     // 0x02D8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsUnlockable;                                      // 0x02D9(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsCommonToRole;                                    // 0x02DA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2DB[0x15];                                     // 0x02DB(0x0015)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSkillProperties) == 0x000008, "Wrong alignment on FSkillProperties");
static_assert(sizeof(FSkillProperties) == 0x0002F0, "Wrong size on FSkillProperties");
static_assert(offsetof(FSkillProperties, SkillData) == 0x0002A0, "Member 'FSkillProperties::SkillData' has a wrong offset!");
static_assert(offsetof(FSkillProperties, SkillCategory) == 0x0002D8, "Member 'FSkillProperties::SkillCategory' has a wrong offset!");
static_assert(offsetof(FSkillProperties, IsUnlockable) == 0x0002D9, "Member 'FSkillProperties::IsUnlockable' has a wrong offset!");
static_assert(offsetof(FSkillProperties, IsCommonToRole) == 0x0002DA, "Member 'FSkillProperties::IsCommonToRole' has a wrong offset!");

// ScriptStruct DeadByDaylight.RoleDropdown
// 0x0002 (0x0002 - 0x0000)
struct FRoleDropdown
{
public:
	bool                                          ShowRoleSelection;                                 // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerRole                                   Role;                                              // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRoleDropdown) == 0x000001, "Wrong alignment on FRoleDropdown");
static_assert(sizeof(FRoleDropdown) == 0x000002, "Wrong size on FRoleDropdown");
static_assert(offsetof(FRoleDropdown, ShowRoleSelection) == 0x000000, "Member 'FRoleDropdown::ShowRoleSelection' has a wrong offset!");
static_assert(offsetof(FRoleDropdown, Role) == 0x000001, "Member 'FRoleDropdown::Role' has a wrong offset!");

// ScriptStruct DeadByDaylight.CharacterDropdown
// 0x0006 (0x0008 - 0x0002)
struct FCharacterDropdown : public FRoleDropdown
{
public:
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CharacterId;                                       // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterDropdown) == 0x000004, "Wrong alignment on FCharacterDropdown");
static_assert(sizeof(FCharacterDropdown) == 0x000008, "Wrong size on FCharacterDropdown");
static_assert(offsetof(FCharacterDropdown, CharacterId) == 0x000004, "Member 'FCharacterDropdown::CharacterId' has a wrong offset!");

// ScriptStruct DeadByDaylight.TargetFocusTimer
// 0x0038 (0x0038 - 0x0000)
struct FTargetFocusTimer final
{
public:
	class ACamperPlayer*                          _camper;                                           // 0x0000(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTimer                              _cooldownTimer;                                    // 0x0008(0x0028)(NativeAccessSpecifierPrivate)
	float                                         _totalTime;                                        // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTargetFocusTimer) == 0x000008, "Wrong alignment on FTargetFocusTimer");
static_assert(sizeof(FTargetFocusTimer) == 0x000038, "Wrong size on FTargetFocusTimer");
static_assert(offsetof(FTargetFocusTimer, _camper) == 0x000000, "Member 'FTargetFocusTimer::_camper' has a wrong offset!");
static_assert(offsetof(FTargetFocusTimer, _cooldownTimer) == 0x000008, "Member 'FTargetFocusTimer::_cooldownTimer' has a wrong offset!");
static_assert(offsetof(FTargetFocusTimer, _totalTime) == 0x000030, "Member 'FTargetFocusTimer::_totalTime' has a wrong offset!");

// ScriptStruct DeadByDaylight.CustomizedMeshPart
// 0x0048 (0x0048 - 0x0000)
struct FCustomizedMeshPart final
{
public:
	ECustomizationCategory                        Category;                                          // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDataTableDropdown                     DefaultItemId;                                     // 0x0008(0x0030)(Edit, NativeAccessSpecifierPublic)
	class FName                                   SocketName;                                        // 0x0038(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCustomizedMeshPart) == 0x000008, "Wrong alignment on FCustomizedMeshPart");
static_assert(sizeof(FCustomizedMeshPart) == 0x000048, "Wrong size on FCustomizedMeshPart");
static_assert(offsetof(FCustomizedMeshPart, Category) == 0x000000, "Member 'FCustomizedMeshPart::Category' has a wrong offset!");
static_assert(offsetof(FCustomizedMeshPart, DefaultItemId) == 0x000008, "Member 'FCustomizedMeshPart::DefaultItemId' has a wrong offset!");
static_assert(offsetof(FCustomizedMeshPart, SocketName) == 0x000038, "Member 'FCustomizedMeshPart::SocketName' has a wrong offset!");

// ScriptStruct DeadByDaylight.ScoreEventRewards
// 0x0018 (0x0018 - 0x0000)
struct FScoreEventRewards final
{
public:
	int32                                         Weight;                                            // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRewardResponseItem>            Rewards;                                           // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FScoreEventRewards) == 0x000008, "Wrong alignment on FScoreEventRewards");
static_assert(sizeof(FScoreEventRewards) == 0x000018, "Wrong size on FScoreEventRewards");
static_assert(offsetof(FScoreEventRewards, Weight) == 0x000000, "Member 'FScoreEventRewards::Weight' has a wrong offset!");
static_assert(offsetof(FScoreEventRewards, Rewards) == 0x000008, "Member 'FScoreEventRewards::Rewards' has a wrong offset!");

// ScriptStruct DeadByDaylight.AtlantaOnBoardingData
// 0x0040 (0x0048 - 0x0008)
struct FAtlantaOnBoardingData final : public FDBDTableRowBase
{
public:
	class FName                                   OnBoardingID;                                      // 0x0008(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Title;                                             // 0x0018(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0030(0x0018)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAtlantaOnBoardingData) == 0x000008, "Wrong alignment on FAtlantaOnBoardingData");
static_assert(sizeof(FAtlantaOnBoardingData) == 0x000048, "Wrong size on FAtlantaOnBoardingData");
static_assert(offsetof(FAtlantaOnBoardingData, OnBoardingID) == 0x000008, "Member 'FAtlantaOnBoardingData::OnBoardingID' has a wrong offset!");
static_assert(offsetof(FAtlantaOnBoardingData, Title) == 0x000018, "Member 'FAtlantaOnBoardingData::Title' has a wrong offset!");
static_assert(offsetof(FAtlantaOnBoardingData, Description) == 0x000030, "Member 'FAtlantaOnBoardingData::Description' has a wrong offset!");

// ScriptStruct DeadByDaylight.FearMarketItemInstance
// 0x0030 (0x0030 - 0x0000)
struct alignas(0x08) FFearMarketItemInstance final
{
public:
	class FName                                   ItemId;                                            // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BloodpointConversion;                              // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Purchased;                                         // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DiscountPercentage;                                // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x18];                                      // 0x0018(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFearMarketItemInstance) == 0x000008, "Wrong alignment on FFearMarketItemInstance");
static_assert(sizeof(FFearMarketItemInstance) == 0x000030, "Wrong size on FFearMarketItemInstance");
static_assert(offsetof(FFearMarketItemInstance, ItemId) == 0x000000, "Member 'FFearMarketItemInstance::ItemId' has a wrong offset!");
static_assert(offsetof(FFearMarketItemInstance, BloodpointConversion) == 0x00000C, "Member 'FFearMarketItemInstance::BloodpointConversion' has a wrong offset!");
static_assert(offsetof(FFearMarketItemInstance, Purchased) == 0x000010, "Member 'FFearMarketItemInstance::Purchased' has a wrong offset!");
static_assert(offsetof(FFearMarketItemInstance, DiscountPercentage) == 0x000014, "Member 'FFearMarketItemInstance::DiscountPercentage' has a wrong offset!");

// ScriptStruct DeadByDaylight.FearMarketOfferingInstance
// 0x0020 (0x0020 - 0x0000)
struct FFearMarketOfferingInstance final
{
public:
	TArray<struct FFearMarketItemInstance>        ObjectsForSale;                                    // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FDateTime                              Starttime;                                         // 0x0010(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              EndTime;                                           // 0x0018(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFearMarketOfferingInstance) == 0x000008, "Wrong alignment on FFearMarketOfferingInstance");
static_assert(sizeof(FFearMarketOfferingInstance) == 0x000020, "Wrong size on FFearMarketOfferingInstance");
static_assert(offsetof(FFearMarketOfferingInstance, ObjectsForSale) == 0x000000, "Member 'FFearMarketOfferingInstance::ObjectsForSale' has a wrong offset!");
static_assert(offsetof(FFearMarketOfferingInstance, Starttime) == 0x000010, "Member 'FFearMarketOfferingInstance::Starttime' has a wrong offset!");
static_assert(offsetof(FFearMarketOfferingInstance, EndTime) == 0x000018, "Member 'FFearMarketOfferingInstance::EndTime' has a wrong offset!");

// ScriptStruct DeadByDaylight.ArrayOfATile
// 0x0010 (0x0010 - 0x0000)
struct FArrayOfATile final
{
public:
	TArray<class ATile*>                          ArrayOfTiles;                                      // 0x0000(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FArrayOfATile) == 0x000008, "Wrong alignment on FArrayOfATile");
static_assert(sizeof(FArrayOfATile) == 0x000010, "Wrong size on FArrayOfATile");
static_assert(offsetof(FArrayOfATile, ArrayOfTiles) == 0x000000, "Member 'FArrayOfATile::ArrayOfTiles' has a wrong offset!");

// ScriptStruct DeadByDaylight.AITunableParameter
// 0x0060 (0x0060 - 0x0000)
struct alignas(0x08) FAITunableParameter final
{
public:
	float                                         DefaultValue;                                      // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TunableName;                                       // 0x0004(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x50];                                      // 0x0010(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAITunableParameter) == 0x000008, "Wrong alignment on FAITunableParameter");
static_assert(sizeof(FAITunableParameter) == 0x000060, "Wrong size on FAITunableParameter");
static_assert(offsetof(FAITunableParameter, DefaultValue) == 0x000000, "Member 'FAITunableParameter::DefaultValue' has a wrong offset!");
static_assert(offsetof(FAITunableParameter, TunableName) == 0x000004, "Member 'FAITunableParameter::TunableName' has a wrong offset!");

// ScriptStruct DeadByDaylight.ManagedGameplayElementsPopulation
// 0x0050 (0x0050 - 0x0000)
struct FManagedGameplayElementsPopulation final
{
public:
	EGameplayElementType                          Type;                                              // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   GameplayElementBlueprint;                          // 0x0008(0x0038)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinDistance;                                       // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinPopulation;                                     // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxPopulation;                                     // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FManagedGameplayElementsPopulation) == 0x000008, "Wrong alignment on FManagedGameplayElementsPopulation");
static_assert(sizeof(FManagedGameplayElementsPopulation) == 0x000050, "Wrong size on FManagedGameplayElementsPopulation");
static_assert(offsetof(FManagedGameplayElementsPopulation, Type) == 0x000000, "Member 'FManagedGameplayElementsPopulation::Type' has a wrong offset!");
static_assert(offsetof(FManagedGameplayElementsPopulation, GameplayElementBlueprint) == 0x000008, "Member 'FManagedGameplayElementsPopulation::GameplayElementBlueprint' has a wrong offset!");
static_assert(offsetof(FManagedGameplayElementsPopulation, MinDistance) == 0x000040, "Member 'FManagedGameplayElementsPopulation::MinDistance' has a wrong offset!");
static_assert(offsetof(FManagedGameplayElementsPopulation, MinPopulation) == 0x000044, "Member 'FManagedGameplayElementsPopulation::MinPopulation' has a wrong offset!");
static_assert(offsetof(FManagedGameplayElementsPopulation, MaxPopulation) == 0x000048, "Member 'FManagedGameplayElementsPopulation::MaxPopulation' has a wrong offset!");

// ScriptStruct DeadByDaylight.ArchivesNodeCoordinates
// 0x0010 (0x0010 - 0x0000)
struct FArchivesNodeCoordinates final
{
public:
	double                                        X;                                                 // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        Y;                                                 // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FArchivesNodeCoordinates) == 0x000008, "Wrong alignment on FArchivesNodeCoordinates");
static_assert(sizeof(FArchivesNodeCoordinates) == 0x000010, "Wrong size on FArchivesNodeCoordinates");
static_assert(offsetof(FArchivesNodeCoordinates, X) == 0x000000, "Member 'FArchivesNodeCoordinates::X' has a wrong offset!");
static_assert(offsetof(FArchivesNodeCoordinates, Y) == 0x000008, "Member 'FArchivesNodeCoordinates::Y' has a wrong offset!");

// ScriptStruct DeadByDaylight.PerkDropdown
// 0x000E (0x0010 - 0x0002)
struct FPerkDropdown : public FRoleDropdown
{
public:
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   PerkId;                                            // 0x0004(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPerkDropdown) == 0x000004, "Wrong alignment on FPerkDropdown");
static_assert(sizeof(FPerkDropdown) == 0x000010, "Wrong size on FPerkDropdown");
static_assert(offsetof(FPerkDropdown, PerkId) == 0x000004, "Member 'FPerkDropdown::PerkId' has a wrong offset!");

// ScriptStruct DeadByDaylight.GameEventData
// 0x0030 (0x0030 - 0x0000)
struct FGameEventData final
{
public:
	class ADBDPlayer*                             Instigator;                                        // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Target;                                            // 0x0008(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CustomValue;                                       // 0x0010(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                CustomObjectParameter;                             // 0x0018(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CustomIntValue;                                    // 0x0020(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           CustomGameplayTag;                                 // 0x0024(0x000C)(BlueprintVisible, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameEventData) == 0x000008, "Wrong alignment on FGameEventData");
static_assert(sizeof(FGameEventData) == 0x000030, "Wrong size on FGameEventData");
static_assert(offsetof(FGameEventData, Instigator) == 0x000000, "Member 'FGameEventData::Instigator' has a wrong offset!");
static_assert(offsetof(FGameEventData, Target) == 0x000008, "Member 'FGameEventData::Target' has a wrong offset!");
static_assert(offsetof(FGameEventData, CustomValue) == 0x000010, "Member 'FGameEventData::CustomValue' has a wrong offset!");
static_assert(offsetof(FGameEventData, CustomObjectParameter) == 0x000018, "Member 'FGameEventData::CustomObjectParameter' has a wrong offset!");
static_assert(offsetof(FGameEventData, CustomIntValue) == 0x000020, "Member 'FGameEventData::CustomIntValue' has a wrong offset!");
static_assert(offsetof(FGameEventData, CustomGameplayTag) == 0x000024, "Member 'FGameEventData::CustomGameplayTag' has a wrong offset!");

// ScriptStruct DeadByDaylight.SpecialBehaviourObjectsInfo
// 0x0014 (0x0014 - 0x0000)
struct FSpecialBehaviourObjectsInfo final
{
public:
	class FName                                   SpecialBehaviourId;                                // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AmountRequired;                                    // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TimesInteractedWith;                               // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpecialBehaviourObjectsInfo) == 0x000004, "Wrong alignment on FSpecialBehaviourObjectsInfo");
static_assert(sizeof(FSpecialBehaviourObjectsInfo) == 0x000014, "Wrong size on FSpecialBehaviourObjectsInfo");
static_assert(offsetof(FSpecialBehaviourObjectsInfo, SpecialBehaviourId) == 0x000000, "Member 'FSpecialBehaviourObjectsInfo::SpecialBehaviourId' has a wrong offset!");
static_assert(offsetof(FSpecialBehaviourObjectsInfo, AmountRequired) == 0x00000C, "Member 'FSpecialBehaviourObjectsInfo::AmountRequired' has a wrong offset!");
static_assert(offsetof(FSpecialBehaviourObjectsInfo, TimesInteractedWith) == 0x000010, "Member 'FSpecialBehaviourObjectsInfo::TimesInteractedWith' has a wrong offset!");

// ScriptStruct DeadByDaylight.TypeFlexibleTunable
// 0x0030 (0x0038 - 0x0008)
struct FTypeFlexibleTunable final : public FDBDTableRowBase
{
public:
	EFlexibleTunableType                          SetType;                                           // 0x0008(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _boolValue;                                        // 0x0009(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _floatValue;                                       // 0x000C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _intValue;                                         // 0x0010(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 _stringValue;                                      // 0x0018(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         _arrayValue;                                       // 0x0028(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTypeFlexibleTunable) == 0x000008, "Wrong alignment on FTypeFlexibleTunable");
static_assert(sizeof(FTypeFlexibleTunable) == 0x000038, "Wrong size on FTypeFlexibleTunable");
static_assert(offsetof(FTypeFlexibleTunable, SetType) == 0x000008, "Member 'FTypeFlexibleTunable::SetType' has a wrong offset!");
static_assert(offsetof(FTypeFlexibleTunable, _boolValue) == 0x000009, "Member 'FTypeFlexibleTunable::_boolValue' has a wrong offset!");
static_assert(offsetof(FTypeFlexibleTunable, _floatValue) == 0x00000C, "Member 'FTypeFlexibleTunable::_floatValue' has a wrong offset!");
static_assert(offsetof(FTypeFlexibleTunable, _intValue) == 0x000010, "Member 'FTypeFlexibleTunable::_intValue' has a wrong offset!");
static_assert(offsetof(FTypeFlexibleTunable, _stringValue) == 0x000018, "Member 'FTypeFlexibleTunable::_stringValue' has a wrong offset!");
static_assert(offsetof(FTypeFlexibleTunable, _arrayValue) == 0x000028, "Member 'FTypeFlexibleTunable::_arrayValue' has a wrong offset!");

// ScriptStruct DeadByDaylight.GameTypeSettings
// 0x0120 (0x0128 - 0x0008)
struct FGameTypeSettings final : public FDBDTableRowBase
{
public:
	EGameType                                     GameType;                                          // 0x0008(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DisplayTitle;                                      // 0x0010(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<EGameTypeModifierName, struct FTypeFlexibleTunable> Modifiers;                                         // 0x0028(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UMutatorData>            MutatorData;                                       // 0x0078(0x0038)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLoadout                               LockedKillerLoadout;                               // 0x00B0(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FLoadout                               LockedSurvivorLoadout;                             // 0x00D0(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDBDTunableOverrides>    TunableOverrides;                                  // 0x00F0(0x0038)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameTypeSettings) == 0x000008, "Wrong alignment on FGameTypeSettings");
static_assert(sizeof(FGameTypeSettings) == 0x000128, "Wrong size on FGameTypeSettings");
static_assert(offsetof(FGameTypeSettings, GameType) == 0x000008, "Member 'FGameTypeSettings::GameType' has a wrong offset!");
static_assert(offsetof(FGameTypeSettings, DisplayTitle) == 0x000010, "Member 'FGameTypeSettings::DisplayTitle' has a wrong offset!");
static_assert(offsetof(FGameTypeSettings, Modifiers) == 0x000028, "Member 'FGameTypeSettings::Modifiers' has a wrong offset!");
static_assert(offsetof(FGameTypeSettings, MutatorData) == 0x000078, "Member 'FGameTypeSettings::MutatorData' has a wrong offset!");
static_assert(offsetof(FGameTypeSettings, LockedKillerLoadout) == 0x0000B0, "Member 'FGameTypeSettings::LockedKillerLoadout' has a wrong offset!");
static_assert(offsetof(FGameTypeSettings, LockedSurvivorLoadout) == 0x0000D0, "Member 'FGameTypeSettings::LockedSurvivorLoadout' has a wrong offset!");
static_assert(offsetof(FGameTypeSettings, TunableOverrides) == 0x0000F0, "Member 'FGameTypeSettings::TunableOverrides' has a wrong offset!");

// ScriptStruct DeadByDaylight.SpecialBehaviourSpawnableComponent
// 0x0050 (0x0050 - 0x0000)
struct FSpecialBehaviourSpawnableComponent final
{
public:
	TSoftClassPtr<class UClass>                   Component;                                         // 0x0000(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShouldSpawnOnSurvivor;                             // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShouldSpawnOnKiller;                               // 0x0039(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShouldSpawnOnGameState;                            // 0x003A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B[0x5];                                       // 0x003B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftClassPtr<class UClass>>           ShouldSpawnOnPlayerClasses;                        // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpecialBehaviourSpawnableComponent) == 0x000008, "Wrong alignment on FSpecialBehaviourSpawnableComponent");
static_assert(sizeof(FSpecialBehaviourSpawnableComponent) == 0x000050, "Wrong size on FSpecialBehaviourSpawnableComponent");
static_assert(offsetof(FSpecialBehaviourSpawnableComponent, Component) == 0x000000, "Member 'FSpecialBehaviourSpawnableComponent::Component' has a wrong offset!");
static_assert(offsetof(FSpecialBehaviourSpawnableComponent, ShouldSpawnOnSurvivor) == 0x000038, "Member 'FSpecialBehaviourSpawnableComponent::ShouldSpawnOnSurvivor' has a wrong offset!");
static_assert(offsetof(FSpecialBehaviourSpawnableComponent, ShouldSpawnOnKiller) == 0x000039, "Member 'FSpecialBehaviourSpawnableComponent::ShouldSpawnOnKiller' has a wrong offset!");
static_assert(offsetof(FSpecialBehaviourSpawnableComponent, ShouldSpawnOnGameState) == 0x00003A, "Member 'FSpecialBehaviourSpawnableComponent::ShouldSpawnOnGameState' has a wrong offset!");
static_assert(offsetof(FSpecialBehaviourSpawnableComponent, ShouldSpawnOnPlayerClasses) == 0x000040, "Member 'FSpecialBehaviourSpawnableComponent::ShouldSpawnOnPlayerClasses' has a wrong offset!");

// ScriptStruct DeadByDaylight.ReflectionCaptureTwoStates
// 0x0030 (0x0030 - 0x0000)
struct FReflectionCaptureTwoStates final
{
public:
	struct FComponentReference                    ComponentReference;                                // 0x0000(0x0030)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FReflectionCaptureTwoStates) == 0x000008, "Wrong alignment on FReflectionCaptureTwoStates");
static_assert(sizeof(FReflectionCaptureTwoStates) == 0x000030, "Wrong size on FReflectionCaptureTwoStates");
static_assert(offsetof(FReflectionCaptureTwoStates, ComponentReference) == 0x000000, "Member 'FReflectionCaptureTwoStates::ComponentReference' has a wrong offset!");

// ScriptStruct DeadByDaylight.AnimationPreviewCharacter
// 0x0010 (0x0010 - 0x0000)
struct FAnimationPreviewCharacter final
{
public:
	EPlayerRole                                   Role;                                              // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class APawn*                                  SpawnedCharacter;                                  // 0x0008(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimationPreviewCharacter) == 0x000008, "Wrong alignment on FAnimationPreviewCharacter");
static_assert(sizeof(FAnimationPreviewCharacter) == 0x000010, "Wrong size on FAnimationPreviewCharacter");
static_assert(offsetof(FAnimationPreviewCharacter, Role) == 0x000000, "Member 'FAnimationPreviewCharacter::Role' has a wrong offset!");
static_assert(offsetof(FAnimationPreviewCharacter, SpawnedCharacter) == 0x000008, "Member 'FAnimationPreviewCharacter::SpawnedCharacter' has a wrong offset!");

// ScriptStruct DeadByDaylight.CosmeticPieceMeshLoadingData
// 0x0448 (0x0448 - 0x0000)
struct FCosmeticPieceMeshLoadingData final
{
public:
	uint8                                         Pad_0[0x440];                                      // 0x0000(0x0440)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMesh*                          SkeletalMesh;                                      // 0x0440(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCosmeticPieceMeshLoadingData) == 0x000008, "Wrong alignment on FCosmeticPieceMeshLoadingData");
static_assert(sizeof(FCosmeticPieceMeshLoadingData) == 0x000448, "Wrong size on FCosmeticPieceMeshLoadingData");
static_assert(offsetof(FCosmeticPieceMeshLoadingData, SkeletalMesh) == 0x000440, "Member 'FCosmeticPieceMeshLoadingData::SkeletalMesh' has a wrong offset!");

// ScriptStruct DeadByDaylight.ArchiveQuestObjectiveDefinition
// 0x0048 (0x0060 - 0x0018)
struct FArchiveQuestObjectiveDefinition final : public FDBDTableRowBaseWithId
{
public:
	class FText                                   Description;                                       // 0x0018(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   RulesDescription;                                  // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	EQuestProgressionType                         ProgressionType;                                   // 0x0048(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           DescriptionParameters;                             // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FArchiveQuestObjectiveDefinition) == 0x000008, "Wrong alignment on FArchiveQuestObjectiveDefinition");
static_assert(sizeof(FArchiveQuestObjectiveDefinition) == 0x000060, "Wrong size on FArchiveQuestObjectiveDefinition");
static_assert(offsetof(FArchiveQuestObjectiveDefinition, Description) == 0x000018, "Member 'FArchiveQuestObjectiveDefinition::Description' has a wrong offset!");
static_assert(offsetof(FArchiveQuestObjectiveDefinition, RulesDescription) == 0x000030, "Member 'FArchiveQuestObjectiveDefinition::RulesDescription' has a wrong offset!");
static_assert(offsetof(FArchiveQuestObjectiveDefinition, ProgressionType) == 0x000048, "Member 'FArchiveQuestObjectiveDefinition::ProgressionType' has a wrong offset!");
static_assert(offsetof(FArchiveQuestObjectiveDefinition, DescriptionParameters) == 0x000050, "Member 'FArchiveQuestObjectiveDefinition::DescriptionParameters' has a wrong offset!");

// ScriptStruct DeadByDaylight.EventSpawnableSpawnRequirements
// 0x0038 (0x0038 - 0x0000)
struct FEventSpawnableSpawnRequirements final
{
public:
	struct FDataTableDropdown                     Size;                                              // 0x0000(0x0030)(Edit, NativeAccessSpecifierPublic)
	int32                                         MinSpawnNumber;                                    // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxSpawnNumber;                                    // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEventSpawnableSpawnRequirements) == 0x000008, "Wrong alignment on FEventSpawnableSpawnRequirements");
static_assert(sizeof(FEventSpawnableSpawnRequirements) == 0x000038, "Wrong size on FEventSpawnableSpawnRequirements");
static_assert(offsetof(FEventSpawnableSpawnRequirements, Size) == 0x000000, "Member 'FEventSpawnableSpawnRequirements::Size' has a wrong offset!");
static_assert(offsetof(FEventSpawnableSpawnRequirements, MinSpawnNumber) == 0x000030, "Member 'FEventSpawnableSpawnRequirements::MinSpawnNumber' has a wrong offset!");
static_assert(offsetof(FEventSpawnableSpawnRequirements, MaxSpawnNumber) == 0x000034, "Member 'FEventSpawnableSpawnRequirements::MaxSpawnNumber' has a wrong offset!");

// ScriptStruct DeadByDaylight.AttackDelegatePair
// 0x0010 (0x0010 - 0x0000)
struct FAttackDelegatePair final
{
public:
	class UDBDAttack*                             _attack;                                           // 0x0000(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAttackDelegatePair) == 0x000008, "Wrong alignment on FAttackDelegatePair");
static_assert(sizeof(FAttackDelegatePair) == 0x000010, "Wrong size on FAttackDelegatePair");
static_assert(offsetof(FAttackDelegatePair, _attack) == 0x000000, "Member 'FAttackDelegatePair::_attack' has a wrong offset!");

// ScriptStruct DeadByDaylight.OutlineColourConfiguration
// 0x0010 (0x0010 - 0x0000)
struct FOutlineColourConfiguration final
{
public:
	struct FLinearColor                           ColourValue;                                       // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOutlineColourConfiguration) == 0x000004, "Wrong alignment on FOutlineColourConfiguration");
static_assert(sizeof(FOutlineColourConfiguration) == 0x000010, "Wrong size on FOutlineColourConfiguration");
static_assert(offsetof(FOutlineColourConfiguration, ColourValue) == 0x000000, "Member 'FOutlineColourConfiguration::ColourValue' has a wrong offset!");

// ScriptStruct DeadByDaylight.AnimationPreviewProp
// 0x0008 (0x0008 - 0x0000)
struct FAnimationPreviewProp final
{
public:
	class AActor*                                 SpawnedProp;                                       // 0x0000(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimationPreviewProp) == 0x000008, "Wrong alignment on FAnimationPreviewProp");
static_assert(sizeof(FAnimationPreviewProp) == 0x000008, "Wrong size on FAnimationPreviewProp");
static_assert(offsetof(FAnimationPreviewProp, SpawnedProp) == 0x000000, "Member 'FAnimationPreviewProp::SpawnedProp' has a wrong offset!");

// ScriptStruct DeadByDaylight.SecondaryInteractionProperties
// 0x0038 (0x0038 - 0x0000)
struct FSecondaryInteractionProperties final
{
public:
	class FString                                 SecondaryInteractionID;                            // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInputInteractionType                         SecondaryInteractionInputType;                     // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   SecondaryInteractionDescriptionText;               // 0x0018(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          ShouldShow;                                        // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSecondaryInteractionProperties) == 0x000008, "Wrong alignment on FSecondaryInteractionProperties");
static_assert(sizeof(FSecondaryInteractionProperties) == 0x000038, "Wrong size on FSecondaryInteractionProperties");
static_assert(offsetof(FSecondaryInteractionProperties, SecondaryInteractionID) == 0x000000, "Member 'FSecondaryInteractionProperties::SecondaryInteractionID' has a wrong offset!");
static_assert(offsetof(FSecondaryInteractionProperties, SecondaryInteractionInputType) == 0x000010, "Member 'FSecondaryInteractionProperties::SecondaryInteractionInputType' has a wrong offset!");
static_assert(offsetof(FSecondaryInteractionProperties, SecondaryInteractionDescriptionText) == 0x000018, "Member 'FSecondaryInteractionProperties::SecondaryInteractionDescriptionText' has a wrong offset!");
static_assert(offsetof(FSecondaryInteractionProperties, ShouldShow) == 0x000030, "Member 'FSecondaryInteractionProperties::ShouldShow' has a wrong offset!");

// ScriptStruct DeadByDaylight.SnappingData
// 0x0040 (0x0040 - 0x0000)
struct FSnappingData final
{
public:
	bool                                          DoSnapPosition;                                    // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DoSnapRotation;                                    // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DoSnapRoll;                                        // 0x0002(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseZCoord;                                         // 0x0003(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SweepOnFinalSnap;                                  // 0x0004(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                TargetPosition;                                    // 0x0008(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               TargetRotation;                                    // 0x0020(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSnappingData) == 0x000008, "Wrong alignment on FSnappingData");
static_assert(sizeof(FSnappingData) == 0x000040, "Wrong size on FSnappingData");
static_assert(offsetof(FSnappingData, DoSnapPosition) == 0x000000, "Member 'FSnappingData::DoSnapPosition' has a wrong offset!");
static_assert(offsetof(FSnappingData, DoSnapRotation) == 0x000001, "Member 'FSnappingData::DoSnapRotation' has a wrong offset!");
static_assert(offsetof(FSnappingData, DoSnapRoll) == 0x000002, "Member 'FSnappingData::DoSnapRoll' has a wrong offset!");
static_assert(offsetof(FSnappingData, UseZCoord) == 0x000003, "Member 'FSnappingData::UseZCoord' has a wrong offset!");
static_assert(offsetof(FSnappingData, SweepOnFinalSnap) == 0x000004, "Member 'FSnappingData::SweepOnFinalSnap' has a wrong offset!");
static_assert(offsetof(FSnappingData, TargetPosition) == 0x000008, "Member 'FSnappingData::TargetPosition' has a wrong offset!");
static_assert(offsetof(FSnappingData, TargetRotation) == 0x000020, "Member 'FSnappingData::TargetRotation' has a wrong offset!");
static_assert(offsetof(FSnappingData, Duration) == 0x000038, "Member 'FSnappingData::Duration' has a wrong offset!");

// ScriptStruct DeadByDaylight.QuestEventDefinition
// 0x0050 (0x0068 - 0x0018)
struct FQuestEventDefinition final : public FDBDTableRowBaseWithId
{
public:
	TArray<struct FGameplayTag>                   TrackedGameEvents;                                 // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   QuestEventEvaluator;                               // 0x0028(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EvaluatorIsClientOnly;                             // 0x0060(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FQuestEventDefinition) == 0x000008, "Wrong alignment on FQuestEventDefinition");
static_assert(sizeof(FQuestEventDefinition) == 0x000068, "Wrong size on FQuestEventDefinition");
static_assert(offsetof(FQuestEventDefinition, TrackedGameEvents) == 0x000018, "Member 'FQuestEventDefinition::TrackedGameEvents' has a wrong offset!");
static_assert(offsetof(FQuestEventDefinition, QuestEventEvaluator) == 0x000028, "Member 'FQuestEventDefinition::QuestEventEvaluator' has a wrong offset!");
static_assert(offsetof(FQuestEventDefinition, EvaluatorIsClientOnly) == 0x000060, "Member 'FQuestEventDefinition::EvaluatorIsClientOnly' has a wrong offset!");

// ScriptStruct DeadByDaylight.ShopTransactionVirtualCurrencyParameters
// 0x0028 (0x0028 - 0x0000)
struct FShopTransactionVirtualCurrencyParameters final
{
public:
	int32                                         VirtualCurrencyAmount;                             // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 VirtualCurrencyName;                               // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 VirtualCurrencyType;                               // 0x0018(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FShopTransactionVirtualCurrencyParameters) == 0x000008, "Wrong alignment on FShopTransactionVirtualCurrencyParameters");
static_assert(sizeof(FShopTransactionVirtualCurrencyParameters) == 0x000028, "Wrong size on FShopTransactionVirtualCurrencyParameters");
static_assert(offsetof(FShopTransactionVirtualCurrencyParameters, VirtualCurrencyAmount) == 0x000000, "Member 'FShopTransactionVirtualCurrencyParameters::VirtualCurrencyAmount' has a wrong offset!");
static_assert(offsetof(FShopTransactionVirtualCurrencyParameters, VirtualCurrencyName) == 0x000008, "Member 'FShopTransactionVirtualCurrencyParameters::VirtualCurrencyName' has a wrong offset!");
static_assert(offsetof(FShopTransactionVirtualCurrencyParameters, VirtualCurrencyType) == 0x000018, "Member 'FShopTransactionVirtualCurrencyParameters::VirtualCurrencyType' has a wrong offset!");

// ScriptStruct DeadByDaylight.ShopTransactionVirtualCurrency
// 0x0028 (0x0028 - 0x0000)
struct FShopTransactionVirtualCurrency final
{
public:
	struct FShopTransactionVirtualCurrencyParameters VirtualCurrency;                                   // 0x0000(0x0028)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FShopTransactionVirtualCurrency) == 0x000008, "Wrong alignment on FShopTransactionVirtualCurrency");
static_assert(sizeof(FShopTransactionVirtualCurrency) == 0x000028, "Wrong size on FShopTransactionVirtualCurrency");
static_assert(offsetof(FShopTransactionVirtualCurrency, VirtualCurrency) == 0x000000, "Member 'FShopTransactionVirtualCurrency::VirtualCurrency' has a wrong offset!");

// ScriptStruct DeadByDaylight.ShopTransactionCurrencyProducts
// 0x0010 (0x0010 - 0x0000)
struct FShopTransactionCurrencyProducts final
{
public:
	TArray<struct FShopTransactionVirtualCurrency> VirtualCurrencies;                                 // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FShopTransactionCurrencyProducts) == 0x000008, "Wrong alignment on FShopTransactionCurrencyProducts");
static_assert(sizeof(FShopTransactionCurrencyProducts) == 0x000010, "Wrong size on FShopTransactionCurrencyProducts");
static_assert(offsetof(FShopTransactionCurrencyProducts, VirtualCurrencies) == 0x000000, "Member 'FShopTransactionCurrencyProducts::VirtualCurrencies' has a wrong offset!");

// ScriptStruct DeadByDaylight.AkObservedPlayerSoundLoop
// 0x0018 (0x0040 - 0x0028)
struct FAkObservedPlayerSoundLoop final : public FAkSoundLoop
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UPlayerPerspectiveComponent> _perspectiveComponent;                             // 0x0038(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FAkObservedPlayerSoundLoop) == 0x000008, "Wrong alignment on FAkObservedPlayerSoundLoop");
static_assert(sizeof(FAkObservedPlayerSoundLoop) == 0x000040, "Wrong size on FAkObservedPlayerSoundLoop");
static_assert(offsetof(FAkObservedPlayerSoundLoop, _perspectiveComponent) == 0x000038, "Member 'FAkObservedPlayerSoundLoop::_perspectiveComponent' has a wrong offset!");

// ScriptStruct DeadByDaylight.FreeToPlayEventData
// 0x0030 (0x0030 - 0x0000)
struct FFreeToPlayEventData final
{
public:
	struct FFreeToPlayData                        Event;                                             // 0x0000(0x0030)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FFreeToPlayEventData) == 0x000008, "Wrong alignment on FFreeToPlayEventData");
static_assert(sizeof(FFreeToPlayEventData) == 0x000030, "Wrong size on FFreeToPlayEventData");
static_assert(offsetof(FFreeToPlayEventData, Event) == 0x000000, "Member 'FFreeToPlayEventData::Event' has a wrong offset!");

// ScriptStruct DeadByDaylight.AnimationPreviewPropRequest
// 0x00A0 (0x00A0 - 0x0000)
struct FAnimationPreviewPropRequest final
{
public:
	TSoftClassPtr<class UClass>                   PropClass;                                         // 0x0000(0x0038)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             SpawnTransform;                                    // 0x0040(0x0060)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimationPreviewPropRequest) == 0x000010, "Wrong alignment on FAnimationPreviewPropRequest");
static_assert(sizeof(FAnimationPreviewPropRequest) == 0x0000A0, "Wrong size on FAnimationPreviewPropRequest");
static_assert(offsetof(FAnimationPreviewPropRequest, PropClass) == 0x000000, "Member 'FAnimationPreviewPropRequest::PropClass' has a wrong offset!");
static_assert(offsetof(FAnimationPreviewPropRequest, SpawnTransform) == 0x000040, "Member 'FAnimationPreviewPropRequest::SpawnTransform' has a wrong offset!");

// ScriptStruct DeadByDaylight.AtlantaTutorialLevelData
// 0x0068 (0x0070 - 0x0008)
struct FAtlantaTutorialLevelData final : public FDBDTableRowBase
{
public:
	class FName                                   ID;                                                // 0x0008(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Title;                                             // 0x0018(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0030(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FString                                 IconPath;                                          // 0x0048(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MapName;                                           // 0x0058(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsKillerTutorial;                                  // 0x0068(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAtlantaTutorialLevelData) == 0x000008, "Wrong alignment on FAtlantaTutorialLevelData");
static_assert(sizeof(FAtlantaTutorialLevelData) == 0x000070, "Wrong size on FAtlantaTutorialLevelData");
static_assert(offsetof(FAtlantaTutorialLevelData, ID) == 0x000008, "Member 'FAtlantaTutorialLevelData::ID' has a wrong offset!");
static_assert(offsetof(FAtlantaTutorialLevelData, Title) == 0x000018, "Member 'FAtlantaTutorialLevelData::Title' has a wrong offset!");
static_assert(offsetof(FAtlantaTutorialLevelData, Description) == 0x000030, "Member 'FAtlantaTutorialLevelData::Description' has a wrong offset!");
static_assert(offsetof(FAtlantaTutorialLevelData, IconPath) == 0x000048, "Member 'FAtlantaTutorialLevelData::IconPath' has a wrong offset!");
static_assert(offsetof(FAtlantaTutorialLevelData, MapName) == 0x000058, "Member 'FAtlantaTutorialLevelData::MapName' has a wrong offset!");
static_assert(offsetof(FAtlantaTutorialLevelData, IsKillerTutorial) == 0x000068, "Member 'FAtlantaTutorialLevelData::IsKillerTutorial' has a wrong offset!");

// ScriptStruct DeadByDaylight.AIRoll
// 0x00C8 (0x00C8 - 0x0000)
struct FAIRoll final
{
public:
	struct FAITunableParameter                    Random;                                            // 0x0000(0x0060)(Edit, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    OnFailCooldown;                                    // 0x0060(0x0060)(Edit, NativeAccessSpecifierPublic)
	uint8                                         Pad_C0[0x8];                                       // 0x00C0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIRoll) == 0x000008, "Wrong alignment on FAIRoll");
static_assert(sizeof(FAIRoll) == 0x0000C8, "Wrong size on FAIRoll");
static_assert(offsetof(FAIRoll, Random) == 0x000000, "Member 'FAIRoll::Random' has a wrong offset!");
static_assert(offsetof(FAIRoll, OnFailCooldown) == 0x000060, "Member 'FAIRoll::OnFailCooldown' has a wrong offset!");

// ScriptStruct DeadByDaylight.CharacterClassDropdown
// 0x000E (0x0010 - 0x0002)
struct FCharacterClassDropdown final : public FRoleDropdown
{
public:
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CharacterClassID;                                  // 0x0004(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterClassDropdown) == 0x000004, "Wrong alignment on FCharacterClassDropdown");
static_assert(sizeof(FCharacterClassDropdown) == 0x000010, "Wrong size on FCharacterClassDropdown");
static_assert(offsetof(FCharacterClassDropdown, CharacterClassID) == 0x000004, "Member 'FCharacterClassDropdown::CharacterClassID' has a wrong offset!");

// ScriptStruct DeadByDaylight.PrestigeIconData
// 0x0040 (0x0048 - 0x0008)
struct FPrestigeIconData final : public FDBDTableRowBase
{
public:
	EPlayerRole                                   PlayerRole;                                        // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PrestigeLevel;                                     // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              Icon;                                              // 0x0010(0x0038)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPrestigeIconData) == 0x000008, "Wrong alignment on FPrestigeIconData");
static_assert(sizeof(FPrestigeIconData) == 0x000048, "Wrong size on FPrestigeIconData");
static_assert(offsetof(FPrestigeIconData, PlayerRole) == 0x000008, "Member 'FPrestigeIconData::PlayerRole' has a wrong offset!");
static_assert(offsetof(FPrestigeIconData, PrestigeLevel) == 0x00000C, "Member 'FPrestigeIconData::PrestigeLevel' has a wrong offset!");
static_assert(offsetof(FPrestigeIconData, Icon) == 0x000010, "Member 'FPrestigeIconData::Icon' has a wrong offset!");

// ScriptStruct DeadByDaylight.PerkIdDropdown
// 0x0000 (0x0010 - 0x0010)
struct FPerkIdDropdown final : public FPerkDropdown
{
};
static_assert(alignof(FPerkIdDropdown) == 0x000004, "Wrong alignment on FPerkIdDropdown");
static_assert(sizeof(FPerkIdDropdown) == 0x000010, "Wrong size on FPerkIdDropdown");

// ScriptStruct DeadByDaylight.ClippedActor
// 0x0060 (0x0060 - 0x0000)
struct FClippedActor final
{
public:
	TArray<TWeakObjectPtr<class UPrimitiveComponent>> DisplayComponents;                                 // 0x0000(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<class UPrimitiveComponent*, TWeakObjectPtr<class UPrimitiveComponent>> CollidingPrimitives;                               // 0x0010(0x0050)(ExportObject, Transient, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FClippedActor) == 0x000008, "Wrong alignment on FClippedActor");
static_assert(sizeof(FClippedActor) == 0x000060, "Wrong size on FClippedActor");
static_assert(offsetof(FClippedActor, DisplayComponents) == 0x000000, "Member 'FClippedActor::DisplayComponents' has a wrong offset!");
static_assert(offsetof(FClippedActor, CollidingPrimitives) == 0x000010, "Member 'FClippedActor::CollidingPrimitives' has a wrong offset!");

// ScriptStruct DeadByDaylight.SpawnerElement
// 0x0010 (0x0010 - 0x0000)
struct FSpawnerElement final
{
public:
	TArray<struct FActorSpawnerProperties>        ObjectsToBeSpawned;                                // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpawnerElement) == 0x000008, "Wrong alignment on FSpawnerElement");
static_assert(sizeof(FSpawnerElement) == 0x000010, "Wrong size on FSpawnerElement");
static_assert(offsetof(FSpawnerElement, ObjectsToBeSpawned) == 0x000000, "Member 'FSpawnerElement::ObjectsToBeSpawned' has a wrong offset!");

// ScriptStruct DeadByDaylight.AddonDropdown
// 0x000E (0x0010 - 0x0002)
struct FAddonDropdown final : public FRoleDropdown
{
public:
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AddonID;                                           // 0x0004(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAddonDropdown) == 0x000004, "Wrong alignment on FAddonDropdown");
static_assert(sizeof(FAddonDropdown) == 0x000010, "Wrong size on FAddonDropdown");
static_assert(offsetof(FAddonDropdown, AddonID) == 0x000004, "Member 'FAddonDropdown::AddonID' has a wrong offset!");

// ScriptStruct DeadByDaylight.FadedMesh
// 0x0010 (0x0010 - 0x0000)
struct FFadedMesh final
{
public:
	class UMeshComponent*                         Mesh;                                              // 0x0000(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OcclusionRefreshInterval;                          // 0x0008(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFadedMesh) == 0x000008, "Wrong alignment on FFadedMesh");
static_assert(sizeof(FFadedMesh) == 0x000010, "Wrong size on FFadedMesh");
static_assert(offsetof(FFadedMesh, Mesh) == 0x000000, "Member 'FFadedMesh::Mesh' has a wrong offset!");
static_assert(offsetof(FFadedMesh, OcclusionRefreshInterval) == 0x000008, "Member 'FFadedMesh::OcclusionRefreshInterval' has a wrong offset!");

// ScriptStruct DeadByDaylight.AITrailEvent
// 0x0038 (0x0038 - 0x0000)
struct FAITrailEvent final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Starttime;                                         // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndTime;                                           // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Instigator;                                        // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           IgnoreOnPerkTag;                                   // 0x0028(0x000C)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGenericTeamId                         TeamIdentifier;                                    // 0x0034(0x0001)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAITrailEvent) == 0x000008, "Wrong alignment on FAITrailEvent");
static_assert(sizeof(FAITrailEvent) == 0x000038, "Wrong size on FAITrailEvent");
static_assert(offsetof(FAITrailEvent, Location) == 0x000000, "Member 'FAITrailEvent::Location' has a wrong offset!");
static_assert(offsetof(FAITrailEvent, Starttime) == 0x000018, "Member 'FAITrailEvent::Starttime' has a wrong offset!");
static_assert(offsetof(FAITrailEvent, EndTime) == 0x00001C, "Member 'FAITrailEvent::EndTime' has a wrong offset!");
static_assert(offsetof(FAITrailEvent, Instigator) == 0x000020, "Member 'FAITrailEvent::Instigator' has a wrong offset!");
static_assert(offsetof(FAITrailEvent, IgnoreOnPerkTag) == 0x000028, "Member 'FAITrailEvent::IgnoreOnPerkTag' has a wrong offset!");
static_assert(offsetof(FAITrailEvent, TeamIdentifier) == 0x000034, "Member 'FAITrailEvent::TeamIdentifier' has a wrong offset!");

// ScriptStruct DeadByDaylight.AIUnclearNoiseEvent
// 0x0040 (0x0040 - 0x0000)
struct FAIUnclearNoiseEvent final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                NoiseLocation;                                     // 0x0008(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Loudness;                                          // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRange;                                          // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Instigator;                                        // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Tag;                                               // 0x0030(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGenericTeamId                         TeamIdentifier;                                    // 0x003C(0x0001)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIUnclearNoiseEvent) == 0x000008, "Wrong alignment on FAIUnclearNoiseEvent");
static_assert(sizeof(FAIUnclearNoiseEvent) == 0x000040, "Wrong size on FAIUnclearNoiseEvent");
static_assert(offsetof(FAIUnclearNoiseEvent, NoiseLocation) == 0x000008, "Member 'FAIUnclearNoiseEvent::NoiseLocation' has a wrong offset!");
static_assert(offsetof(FAIUnclearNoiseEvent, Loudness) == 0x000020, "Member 'FAIUnclearNoiseEvent::Loudness' has a wrong offset!");
static_assert(offsetof(FAIUnclearNoiseEvent, MaxRange) == 0x000024, "Member 'FAIUnclearNoiseEvent::MaxRange' has a wrong offset!");
static_assert(offsetof(FAIUnclearNoiseEvent, Instigator) == 0x000028, "Member 'FAIUnclearNoiseEvent::Instigator' has a wrong offset!");
static_assert(offsetof(FAIUnclearNoiseEvent, Tag) == 0x000030, "Member 'FAIUnclearNoiseEvent::Tag' has a wrong offset!");
static_assert(offsetof(FAIUnclearNoiseEvent, TeamIdentifier) == 0x00003C, "Member 'FAIUnclearNoiseEvent::TeamIdentifier' has a wrong offset!");

// ScriptStruct DeadByDaylight.Tile2Data
// 0x0078 (0x0080 - 0x0008)
struct FTile2Data final : public FTableRowBase
{
public:
	class FString                                 TileName;                                          // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinimumSpacing;                                    // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaximumSpacing;                                    // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DiagonalSpacing;                                   // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TypeSpacing;                                       // 0x0021(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x2];                                       // 0x0022(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaximumCount;                                      // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntPoint                              Dimension;                                         // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EscapeStrategyType>                    AvailableEscapeTypes;                              // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	ETileType                                     Type;                                              // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETileClassType                                TileClassType;                                     // 0x0041(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDensity                                      Density;                                           // 0x0042(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPathType                                     Path;                                              // 0x0043(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Number;                                            // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          PlaceHolder;                                       // 0x0048(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Replacement;                                       // 0x0049(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A[0x2];                                       // 0x004A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SpawnPriorityTier;                                 // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        Weight;                                            // 0x0050(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Coord;                                             // 0x0058(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EQuadrantSpawnType                            QuadrantSpawnType;                                 // 0x0068(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBasementType                                 BasementType;                                      // 0x0069(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6A[0x6];                                       // 0x006A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EGameplayElementType>                  AvailableGameplayElementTypes;                     // 0x0070(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTile2Data) == 0x000008, "Wrong alignment on FTile2Data");
static_assert(sizeof(FTile2Data) == 0x000080, "Wrong size on FTile2Data");
static_assert(offsetof(FTile2Data, TileName) == 0x000008, "Member 'FTile2Data::TileName' has a wrong offset!");
static_assert(offsetof(FTile2Data, MinimumSpacing) == 0x000018, "Member 'FTile2Data::MinimumSpacing' has a wrong offset!");
static_assert(offsetof(FTile2Data, MaximumSpacing) == 0x00001C, "Member 'FTile2Data::MaximumSpacing' has a wrong offset!");
static_assert(offsetof(FTile2Data, DiagonalSpacing) == 0x000020, "Member 'FTile2Data::DiagonalSpacing' has a wrong offset!");
static_assert(offsetof(FTile2Data, TypeSpacing) == 0x000021, "Member 'FTile2Data::TypeSpacing' has a wrong offset!");
static_assert(offsetof(FTile2Data, MaximumCount) == 0x000024, "Member 'FTile2Data::MaximumCount' has a wrong offset!");
static_assert(offsetof(FTile2Data, Dimension) == 0x000028, "Member 'FTile2Data::Dimension' has a wrong offset!");
static_assert(offsetof(FTile2Data, AvailableEscapeTypes) == 0x000030, "Member 'FTile2Data::AvailableEscapeTypes' has a wrong offset!");
static_assert(offsetof(FTile2Data, Type) == 0x000040, "Member 'FTile2Data::Type' has a wrong offset!");
static_assert(offsetof(FTile2Data, TileClassType) == 0x000041, "Member 'FTile2Data::TileClassType' has a wrong offset!");
static_assert(offsetof(FTile2Data, Density) == 0x000042, "Member 'FTile2Data::Density' has a wrong offset!");
static_assert(offsetof(FTile2Data, Path) == 0x000043, "Member 'FTile2Data::Path' has a wrong offset!");
static_assert(offsetof(FTile2Data, Number) == 0x000044, "Member 'FTile2Data::Number' has a wrong offset!");
static_assert(offsetof(FTile2Data, PlaceHolder) == 0x000048, "Member 'FTile2Data::PlaceHolder' has a wrong offset!");
static_assert(offsetof(FTile2Data, Replacement) == 0x000049, "Member 'FTile2Data::Replacement' has a wrong offset!");
static_assert(offsetof(FTile2Data, SpawnPriorityTier) == 0x00004C, "Member 'FTile2Data::SpawnPriorityTier' has a wrong offset!");
static_assert(offsetof(FTile2Data, Weight) == 0x000050, "Member 'FTile2Data::Weight' has a wrong offset!");
static_assert(offsetof(FTile2Data, Coord) == 0x000058, "Member 'FTile2Data::Coord' has a wrong offset!");
static_assert(offsetof(FTile2Data, QuadrantSpawnType) == 0x000068, "Member 'FTile2Data::QuadrantSpawnType' has a wrong offset!");
static_assert(offsetof(FTile2Data, BasementType) == 0x000069, "Member 'FTile2Data::BasementType' has a wrong offset!");
static_assert(offsetof(FTile2Data, AvailableGameplayElementTypes) == 0x000070, "Member 'FTile2Data::AvailableGameplayElementTypes' has a wrong offset!");

// ScriptStruct DeadByDaylight.AnimationPreviewRequest
// 0x0058 (0x0058 - 0x0000)
struct FAnimationPreviewRequest final
{
public:
	EAnimationPreviewType                         Type;                                              // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAnimationPreviewCharacterRequest> CharactersToUse;                                   // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FAnimationPreviewPropRequest>   PropsToUse;                                        // 0x0018(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0x30];                                      // 0x0028(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimationPreviewRequest) == 0x000008, "Wrong alignment on FAnimationPreviewRequest");
static_assert(sizeof(FAnimationPreviewRequest) == 0x000058, "Wrong size on FAnimationPreviewRequest");
static_assert(offsetof(FAnimationPreviewRequest, Type) == 0x000000, "Member 'FAnimationPreviewRequest::Type' has a wrong offset!");
static_assert(offsetof(FAnimationPreviewRequest, CharactersToUse) == 0x000008, "Member 'FAnimationPreviewRequest::CharactersToUse' has a wrong offset!");
static_assert(offsetof(FAnimationPreviewRequest, PropsToUse) == 0x000018, "Member 'FAnimationPreviewRequest::PropsToUse' has a wrong offset!");

// ScriptStruct DeadByDaylight.AnimBudgeterGameConfig
// 0x0028 (0x0028 - 0x0000)
struct FAnimBudgeterGameConfig final
{
public:
	bool                                          Enabled;                                           // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Ps4Budget;                                         // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Ps5Budget;                                         // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         XboxOneBudget;                                     // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         XsxBudget;                                         // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SwitchBudget;                                      // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 SteamBudgets;                                      // 0x0018(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimBudgeterGameConfig) == 0x000008, "Wrong alignment on FAnimBudgeterGameConfig");
static_assert(sizeof(FAnimBudgeterGameConfig) == 0x000028, "Wrong size on FAnimBudgeterGameConfig");
static_assert(offsetof(FAnimBudgeterGameConfig, Enabled) == 0x000000, "Member 'FAnimBudgeterGameConfig::Enabled' has a wrong offset!");
static_assert(offsetof(FAnimBudgeterGameConfig, Ps4Budget) == 0x000004, "Member 'FAnimBudgeterGameConfig::Ps4Budget' has a wrong offset!");
static_assert(offsetof(FAnimBudgeterGameConfig, Ps5Budget) == 0x000008, "Member 'FAnimBudgeterGameConfig::Ps5Budget' has a wrong offset!");
static_assert(offsetof(FAnimBudgeterGameConfig, XboxOneBudget) == 0x00000C, "Member 'FAnimBudgeterGameConfig::XboxOneBudget' has a wrong offset!");
static_assert(offsetof(FAnimBudgeterGameConfig, XsxBudget) == 0x000010, "Member 'FAnimBudgeterGameConfig::XsxBudget' has a wrong offset!");
static_assert(offsetof(FAnimBudgeterGameConfig, SwitchBudget) == 0x000014, "Member 'FAnimBudgeterGameConfig::SwitchBudget' has a wrong offset!");
static_assert(offsetof(FAnimBudgeterGameConfig, SteamBudgets) == 0x000018, "Member 'FAnimBudgeterGameConfig::SteamBudgets' has a wrong offset!");

// ScriptStruct DeadByDaylight.GenerationParams
// 0x0038 (0x0038 - 0x0000)
struct FGenerationParams final
{
public:
	int32                                         Seed;                                              // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 MapName;                                           // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGameType                                     GameType;                                          // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SpecialEventId;                                    // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerCount;                                       // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGenerationParams) == 0x000008, "Wrong alignment on FGenerationParams");
static_assert(sizeof(FGenerationParams) == 0x000038, "Wrong size on FGenerationParams");
static_assert(offsetof(FGenerationParams, Seed) == 0x000000, "Member 'FGenerationParams::Seed' has a wrong offset!");
static_assert(offsetof(FGenerationParams, MapName) == 0x000008, "Member 'FGenerationParams::MapName' has a wrong offset!");
static_assert(offsetof(FGenerationParams, GameType) == 0x000018, "Member 'FGenerationParams::GameType' has a wrong offset!");
static_assert(offsetof(FGenerationParams, SpecialEventId) == 0x000020, "Member 'FGenerationParams::SpecialEventId' has a wrong offset!");
static_assert(offsetof(FGenerationParams, PlayerCount) == 0x000030, "Member 'FGenerationParams::PlayerCount' has a wrong offset!");

// ScriptStruct DeadByDaylight.ArchiveS3Journal
// 0x0008 (0x0008 - 0x0000)
struct FArchiveS3Journal final
{
public:
	int32                                         Nodes;                                             // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StartingPages;                                     // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FArchiveS3Journal) == 0x000004, "Wrong alignment on FArchiveS3Journal");
static_assert(sizeof(FArchiveS3Journal) == 0x000008, "Wrong size on FArchiveS3Journal");
static_assert(offsetof(FArchiveS3Journal, Nodes) == 0x000000, "Member 'FArchiveS3Journal::Nodes' has a wrong offset!");
static_assert(offsetof(FArchiveS3Journal, StartingPages) == 0x000004, "Member 'FArchiveS3Journal::StartingPages' has a wrong offset!");

// ScriptStruct DeadByDaylight.ArchiveNodeDefinition
// 0x0050 (0x0068 - 0x0018)
struct FArchiveNodeDefinition final : public FDBDTableRowBaseWithId
{
public:
	class FText                                   DisplayName;                                       // 0x0018(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FString                                 IconPath;                                          // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerRole                                   PlayerRole;                                        // 0x0058(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x3];                                       // 0x0059(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CinematicId;                                       // 0x005C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FArchiveNodeDefinition) == 0x000008, "Wrong alignment on FArchiveNodeDefinition");
static_assert(sizeof(FArchiveNodeDefinition) == 0x000068, "Wrong size on FArchiveNodeDefinition");
static_assert(offsetof(FArchiveNodeDefinition, DisplayName) == 0x000018, "Member 'FArchiveNodeDefinition::DisplayName' has a wrong offset!");
static_assert(offsetof(FArchiveNodeDefinition, Description) == 0x000030, "Member 'FArchiveNodeDefinition::Description' has a wrong offset!");
static_assert(offsetof(FArchiveNodeDefinition, IconPath) == 0x000048, "Member 'FArchiveNodeDefinition::IconPath' has a wrong offset!");
static_assert(offsetof(FArchiveNodeDefinition, PlayerRole) == 0x000058, "Member 'FArchiveNodeDefinition::PlayerRole' has a wrong offset!");
static_assert(offsetof(FArchiveNodeDefinition, CinematicId) == 0x00005C, "Member 'FArchiveNodeDefinition::CinematicId' has a wrong offset!");

// ScriptStruct DeadByDaylight.ArchiveQuestSpecialBehaviour
// 0x0040 (0x0058 - 0x0018)
struct FArchiveQuestSpecialBehaviour final : public FDBDTableRowBaseWithId
{
public:
	class FText                                   Description;                                       // 0x0018(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	EContextualType                               Type;                                              // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SpawnObjectId;                                     // 0x0034(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAdditiveBehaviour                            AdditiveBehaviour;                                 // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStackingBehaviours                           StackableBehaviour;                                // 0x0041(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOwnershipBehaviour                           OwnershipBehaviour;                                // 0x0042(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_43[0x1];                                       // 0x0043(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SpawnQuantity;                                     // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSpecialBehaviourSpawnableComponent> SpawnableComponents;                               // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FArchiveQuestSpecialBehaviour) == 0x000008, "Wrong alignment on FArchiveQuestSpecialBehaviour");
static_assert(sizeof(FArchiveQuestSpecialBehaviour) == 0x000058, "Wrong size on FArchiveQuestSpecialBehaviour");
static_assert(offsetof(FArchiveQuestSpecialBehaviour, Description) == 0x000018, "Member 'FArchiveQuestSpecialBehaviour::Description' has a wrong offset!");
static_assert(offsetof(FArchiveQuestSpecialBehaviour, Type) == 0x000030, "Member 'FArchiveQuestSpecialBehaviour::Type' has a wrong offset!");
static_assert(offsetof(FArchiveQuestSpecialBehaviour, SpawnObjectId) == 0x000034, "Member 'FArchiveQuestSpecialBehaviour::SpawnObjectId' has a wrong offset!");
static_assert(offsetof(FArchiveQuestSpecialBehaviour, AdditiveBehaviour) == 0x000040, "Member 'FArchiveQuestSpecialBehaviour::AdditiveBehaviour' has a wrong offset!");
static_assert(offsetof(FArchiveQuestSpecialBehaviour, StackableBehaviour) == 0x000041, "Member 'FArchiveQuestSpecialBehaviour::StackableBehaviour' has a wrong offset!");
static_assert(offsetof(FArchiveQuestSpecialBehaviour, OwnershipBehaviour) == 0x000042, "Member 'FArchiveQuestSpecialBehaviour::OwnershipBehaviour' has a wrong offset!");
static_assert(offsetof(FArchiveQuestSpecialBehaviour, SpawnQuantity) == 0x000044, "Member 'FArchiveQuestSpecialBehaviour::SpawnQuantity' has a wrong offset!");
static_assert(offsetof(FArchiveQuestSpecialBehaviour, SpawnableComponents) == 0x000048, "Member 'FArchiveQuestSpecialBehaviour::SpawnableComponents' has a wrong offset!");

// ScriptStruct DeadByDaylight.ArchivesConfig
// 0x0004 (0x0004 - 0x0000)
struct FArchivesConfig final
{
public:
	int32                                         CommunityNodeRefreshInterval;                      // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FArchivesConfig) == 0x000004, "Wrong alignment on FArchivesConfig");
static_assert(sizeof(FArchivesConfig) == 0x000004, "Wrong size on FArchivesConfig");
static_assert(offsetof(FArchivesConfig, CommunityNodeRefreshInterval) == 0x000000, "Member 'FArchivesConfig::CommunityNodeRefreshInterval' has a wrong offset!");

// ScriptStruct DeadByDaylight.InteractionProficiencyData
// 0x0010 (0x0010 - 0x0000)
struct FInteractionProficiencyData final
{
public:
	bool                                          IsActive;                                          // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Level;                                             // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EStatusEffectType                             ProficiencyType;                                   // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Value;                                             // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FInteractionProficiencyData) == 0x000004, "Wrong alignment on FInteractionProficiencyData");
static_assert(sizeof(FInteractionProficiencyData) == 0x000010, "Wrong size on FInteractionProficiencyData");
static_assert(offsetof(FInteractionProficiencyData, IsActive) == 0x000000, "Member 'FInteractionProficiencyData::IsActive' has a wrong offset!");
static_assert(offsetof(FInteractionProficiencyData, Level) == 0x000004, "Member 'FInteractionProficiencyData::Level' has a wrong offset!");
static_assert(offsetof(FInteractionProficiencyData, ProficiencyType) == 0x000008, "Member 'FInteractionProficiencyData::ProficiencyType' has a wrong offset!");
static_assert(offsetof(FInteractionProficiencyData, Value) == 0x00000C, "Member 'FInteractionProficiencyData::Value' has a wrong offset!");

// ScriptStruct DeadByDaylight.PlayerDataForQuestConditions
// 0x00A0 (0x00A0 - 0x0000)
struct alignas(0x08) FPlayerDataForQuestConditions final
{
public:
	uint8                                         Pad_0[0xA0];                                       // 0x0000(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerDataForQuestConditions) == 0x000008, "Wrong alignment on FPlayerDataForQuestConditions");
static_assert(sizeof(FPlayerDataForQuestConditions) == 0x0000A0, "Wrong size on FPlayerDataForQuestConditions");

// ScriptStruct DeadByDaylight.BonusTierTooltipVisibility
// 0x0018 (0x0018 - 0x0000)
struct FBonusTierTooltipVisibility final
{
public:
	class FString                                 ArchiveId;                                         // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsVisible;                                         // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBonusTierTooltipVisibility) == 0x000008, "Wrong alignment on FBonusTierTooltipVisibility");
static_assert(sizeof(FBonusTierTooltipVisibility) == 0x000018, "Wrong size on FBonusTierTooltipVisibility");
static_assert(offsetof(FBonusTierTooltipVisibility, ArchiveId) == 0x000000, "Member 'FBonusTierTooltipVisibility::ArchiveId' has a wrong offset!");
static_assert(offsetof(FBonusTierTooltipVisibility, IsVisible) == 0x000010, "Member 'FBonusTierTooltipVisibility::IsVisible' has a wrong offset!");

// ScriptStruct DeadByDaylight.HitValidationRecorder
// 0x0004 (0x0004 - 0x0000)
struct FHitValidationRecorder final
{
public:
	float                                         CacheTimespan;                                     // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHitValidationRecorder) == 0x000004, "Wrong alignment on FHitValidationRecorder");
static_assert(sizeof(FHitValidationRecorder) == 0x000004, "Wrong size on FHitValidationRecorder");
static_assert(offsetof(FHitValidationRecorder, CacheTimespan) == 0x000000, "Member 'FHitValidationRecorder::CacheTimespan' has a wrong offset!");

// ScriptStruct DeadByDaylight.HitValidationValidator
// 0x0018 (0x0018 - 0x0000)
struct FHitValidationValidator final
{
public:
	float                                         CapsuleInflation;                                  // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaximumDistance;                                   // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Name;                                              // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHitValidationValidator) == 0x000008, "Wrong alignment on FHitValidationValidator");
static_assert(sizeof(FHitValidationValidator) == 0x000018, "Wrong size on FHitValidationValidator");
static_assert(offsetof(FHitValidationValidator, CapsuleInflation) == 0x000000, "Member 'FHitValidationValidator::CapsuleInflation' has a wrong offset!");
static_assert(offsetof(FHitValidationValidator, MaximumDistance) == 0x000004, "Member 'FHitValidationValidator::MaximumDistance' has a wrong offset!");
static_assert(offsetof(FHitValidationValidator, Name) == 0x000008, "Member 'FHitValidationValidator::Name' has a wrong offset!");

// ScriptStruct DeadByDaylight.HitValidationGameConfig
// 0x0018 (0x0018 - 0x0000)
struct FHitValidationGameConfig final
{
public:
	bool                                          Enable;                                            // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnableCollisionCheck;                              // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitValidationRecorder                 Recorder;                                          // 0x0004(0x0004)(NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FHitValidationValidator>        Validators;                                        // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHitValidationGameConfig) == 0x000008, "Wrong alignment on FHitValidationGameConfig");
static_assert(sizeof(FHitValidationGameConfig) == 0x000018, "Wrong size on FHitValidationGameConfig");
static_assert(offsetof(FHitValidationGameConfig, Enable) == 0x000000, "Member 'FHitValidationGameConfig::Enable' has a wrong offset!");
static_assert(offsetof(FHitValidationGameConfig, EnableCollisionCheck) == 0x000001, "Member 'FHitValidationGameConfig::EnableCollisionCheck' has a wrong offset!");
static_assert(offsetof(FHitValidationGameConfig, Recorder) == 0x000004, "Member 'FHitValidationGameConfig::Recorder' has a wrong offset!");
static_assert(offsetof(FHitValidationGameConfig, Validators) == 0x000008, "Member 'FHitValidationGameConfig::Validators' has a wrong offset!");

// ScriptStruct DeadByDaylight.ArchivesNodeDefinition
// 0x00C8 (0x00C8 - 0x0000)
struct FArchivesNodeDefinition final
{
public:
	class FString                                 ClientInfoId;                                      // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FArchivesNodeCoordinates               Coordinates;                                       // 0x0010(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         Neighbors;                                         // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 NodeType;                                          // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FString, struct FArchivesObjective> Objectives;                                        // 0x0040(0x0050)(NativeAccessSpecifierPublic)
	bool                                          Objectives_IsSet;                                  // 0x0090(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         Journal;                                           // 0x0098(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          Journal_IsSet;                                     // 0x00A8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRewardResponseItem>            Reward;                                            // 0x00B0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          Reward_IsSet;                                      // 0x00C0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C1[0x7];                                       // 0x00C1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FArchivesNodeDefinition) == 0x000008, "Wrong alignment on FArchivesNodeDefinition");
static_assert(sizeof(FArchivesNodeDefinition) == 0x0000C8, "Wrong size on FArchivesNodeDefinition");
static_assert(offsetof(FArchivesNodeDefinition, ClientInfoId) == 0x000000, "Member 'FArchivesNodeDefinition::ClientInfoId' has a wrong offset!");
static_assert(offsetof(FArchivesNodeDefinition, Coordinates) == 0x000010, "Member 'FArchivesNodeDefinition::Coordinates' has a wrong offset!");
static_assert(offsetof(FArchivesNodeDefinition, Neighbors) == 0x000020, "Member 'FArchivesNodeDefinition::Neighbors' has a wrong offset!");
static_assert(offsetof(FArchivesNodeDefinition, NodeType) == 0x000030, "Member 'FArchivesNodeDefinition::NodeType' has a wrong offset!");
static_assert(offsetof(FArchivesNodeDefinition, Objectives) == 0x000040, "Member 'FArchivesNodeDefinition::Objectives' has a wrong offset!");
static_assert(offsetof(FArchivesNodeDefinition, Objectives_IsSet) == 0x000090, "Member 'FArchivesNodeDefinition::Objectives_IsSet' has a wrong offset!");
static_assert(offsetof(FArchivesNodeDefinition, Journal) == 0x000098, "Member 'FArchivesNodeDefinition::Journal' has a wrong offset!");
static_assert(offsetof(FArchivesNodeDefinition, Journal_IsSet) == 0x0000A8, "Member 'FArchivesNodeDefinition::Journal_IsSet' has a wrong offset!");
static_assert(offsetof(FArchivesNodeDefinition, Reward) == 0x0000B0, "Member 'FArchivesNodeDefinition::Reward' has a wrong offset!");
static_assert(offsetof(FArchivesNodeDefinition, Reward_IsSet) == 0x0000C0, "Member 'FArchivesNodeDefinition::Reward_IsSet' has a wrong offset!");

// ScriptStruct DeadByDaylight.StoryLevel
// 0x00E0 (0x00E0 - 0x0000)
struct FStoryLevel final
{
public:
	TArray<class FString>                         Start;                                             // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         End;                                               // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 StartDate;                                         // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FString, struct FArchivesNodeDefinition> Nodes;                                             // 0x0030(0x0050)(NativeAccessSpecifierPublic)
	TArray<struct FRewardResponseItem>            EndNodeRewards;                                    // 0x0080(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          EndNodeRewards_IsSet;                              // 0x0090(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRewardResponseItem>            LevelRewards;                                      // 0x0098(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          LevelRewards_IsSet;                                // 0x00A8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRewardResponseItem>            TaskRewards;                                       // 0x00B0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          TaskRewards_IsSet;                                 // 0x00C0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C1[0x7];                                       // 0x00C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRewardResponseItem>            ChallengeRewards;                                  // 0x00C8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          ChallengeRewards_IsSet;                            // 0x00D8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D9[0x7];                                       // 0x00D9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStoryLevel) == 0x000008, "Wrong alignment on FStoryLevel");
static_assert(sizeof(FStoryLevel) == 0x0000E0, "Wrong size on FStoryLevel");
static_assert(offsetof(FStoryLevel, Start) == 0x000000, "Member 'FStoryLevel::Start' has a wrong offset!");
static_assert(offsetof(FStoryLevel, End) == 0x000010, "Member 'FStoryLevel::End' has a wrong offset!");
static_assert(offsetof(FStoryLevel, StartDate) == 0x000020, "Member 'FStoryLevel::StartDate' has a wrong offset!");
static_assert(offsetof(FStoryLevel, Nodes) == 0x000030, "Member 'FStoryLevel::Nodes' has a wrong offset!");
static_assert(offsetof(FStoryLevel, EndNodeRewards) == 0x000080, "Member 'FStoryLevel::EndNodeRewards' has a wrong offset!");
static_assert(offsetof(FStoryLevel, EndNodeRewards_IsSet) == 0x000090, "Member 'FStoryLevel::EndNodeRewards_IsSet' has a wrong offset!");
static_assert(offsetof(FStoryLevel, LevelRewards) == 0x000098, "Member 'FStoryLevel::LevelRewards' has a wrong offset!");
static_assert(offsetof(FStoryLevel, LevelRewards_IsSet) == 0x0000A8, "Member 'FStoryLevel::LevelRewards_IsSet' has a wrong offset!");
static_assert(offsetof(FStoryLevel, TaskRewards) == 0x0000B0, "Member 'FStoryLevel::TaskRewards' has a wrong offset!");
static_assert(offsetof(FStoryLevel, TaskRewards_IsSet) == 0x0000C0, "Member 'FStoryLevel::TaskRewards_IsSet' has a wrong offset!");
static_assert(offsetof(FStoryLevel, ChallengeRewards) == 0x0000C8, "Member 'FStoryLevel::ChallengeRewards' has a wrong offset!");
static_assert(offsetof(FStoryLevel, ChallengeRewards_IsSet) == 0x0000D8, "Member 'FStoryLevel::ChallengeRewards_IsSet' has a wrong offset!");

// ScriptStruct DeadByDaylight.ArchivesMapFromS3
// 0x0040 (0x0040 - 0x0000)
struct FArchivesMapFromS3 final
{
public:
	TArray<struct FStoryLevel>                    Level;                                             // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 RiftId;                                            // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RiftId_IsSet;                                      // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SpecialEventId;                                    // 0x0028(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SpecialEventId_IsSet;                              // 0x0038(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NewTomePopup;                                      // 0x0039(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NewTomePopup_IsSet;                                // 0x003A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B[0x5];                                       // 0x003B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FArchivesMapFromS3) == 0x000008, "Wrong alignment on FArchivesMapFromS3");
static_assert(sizeof(FArchivesMapFromS3) == 0x000040, "Wrong size on FArchivesMapFromS3");
static_assert(offsetof(FArchivesMapFromS3, Level) == 0x000000, "Member 'FArchivesMapFromS3::Level' has a wrong offset!");
static_assert(offsetof(FArchivesMapFromS3, RiftId) == 0x000010, "Member 'FArchivesMapFromS3::RiftId' has a wrong offset!");
static_assert(offsetof(FArchivesMapFromS3, RiftId_IsSet) == 0x000020, "Member 'FArchivesMapFromS3::RiftId_IsSet' has a wrong offset!");
static_assert(offsetof(FArchivesMapFromS3, SpecialEventId) == 0x000028, "Member 'FArchivesMapFromS3::SpecialEventId' has a wrong offset!");
static_assert(offsetof(FArchivesMapFromS3, SpecialEventId_IsSet) == 0x000038, "Member 'FArchivesMapFromS3::SpecialEventId_IsSet' has a wrong offset!");
static_assert(offsetof(FArchivesMapFromS3, NewTomePopup) == 0x000039, "Member 'FArchivesMapFromS3::NewTomePopup' has a wrong offset!");
static_assert(offsetof(FArchivesMapFromS3, NewTomePopup_IsSet) == 0x00003A, "Member 'FArchivesMapFromS3::NewTomePopup_IsSet' has a wrong offset!");

// ScriptStruct DeadByDaylight.ItemAddonInitializationData
// 0x0002 (0x0002 - 0x0000)
struct FItemAddonInitializationData final
{
public:
	EInventoryItemType                            InventoryItemType;                                 // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AuthorityDataSet;                                  // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FItemAddonInitializationData) == 0x000001, "Wrong alignment on FItemAddonInitializationData");
static_assert(sizeof(FItemAddonInitializationData) == 0x000002, "Wrong size on FItemAddonInitializationData");
static_assert(offsetof(FItemAddonInitializationData, InventoryItemType) == 0x000000, "Member 'FItemAddonInitializationData::InventoryItemType' has a wrong offset!");
static_assert(offsetof(FItemAddonInitializationData, AuthorityDataSet) == 0x000001, "Member 'FItemAddonInitializationData::AuthorityDataSet' has a wrong offset!");

// ScriptStruct DeadByDaylight.KillerSpecificComponentsData
// 0x0048 (0x0050 - 0x0008)
struct FKillerSpecificComponentsData final : public FDBDTableRowBase
{
public:
	struct FGameplayTag                           KillerPresenceTag;                                 // 0x0008(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   KillerSpecificComponent;                           // 0x0018(0x0038)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FKillerSpecificComponentsData) == 0x000008, "Wrong alignment on FKillerSpecificComponentsData");
static_assert(sizeof(FKillerSpecificComponentsData) == 0x000050, "Wrong size on FKillerSpecificComponentsData");
static_assert(offsetof(FKillerSpecificComponentsData, KillerPresenceTag) == 0x000008, "Member 'FKillerSpecificComponentsData::KillerPresenceTag' has a wrong offset!");
static_assert(offsetof(FKillerSpecificComponentsData, KillerSpecificComponent) == 0x000018, "Member 'FKillerSpecificComponentsData::KillerSpecificComponent' has a wrong offset!");

// ScriptStruct DeadByDaylight.DisabledItemData
// 0x0018 (0x0018 - 0x0000)
struct FDisabledItemData final
{
public:
	TArray<class FString>                         GameTypes;                                         // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          GameTypes_IsSet;                                   // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDisabledItemData) == 0x000008, "Wrong alignment on FDisabledItemData");
static_assert(sizeof(FDisabledItemData) == 0x000018, "Wrong size on FDisabledItemData");
static_assert(offsetof(FDisabledItemData, GameTypes) == 0x000000, "Member 'FDisabledItemData::GameTypes' has a wrong offset!");
static_assert(offsetof(FDisabledItemData, GameTypes_IsSet) == 0x000010, "Member 'FDisabledItemData::GameTypes_IsSet' has a wrong offset!");

// ScriptStruct DeadByDaylight.AssetLibraryLoader
// 0x0028 (0x0028 - 0x0000)
struct FAssetLibraryLoader final
{
public:
	class UAssetLibrary*                          AssetLibrary;                                      // 0x0000(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x20];                                       // 0x0008(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAssetLibraryLoader) == 0x000008, "Wrong alignment on FAssetLibraryLoader");
static_assert(sizeof(FAssetLibraryLoader) == 0x000028, "Wrong size on FAssetLibraryLoader");
static_assert(offsetof(FAssetLibraryLoader, AssetLibrary) == 0x000000, "Member 'FAssetLibraryLoader::AssetLibrary' has a wrong offset!");

// ScriptStruct DeadByDaylight.KillerPOVSurvivorAimOffsetOverrideData
// 0x0038 (0x0040 - 0x0008)
struct FKillerPOVSurvivorAimOffsetOverrideData final : public FDBDTableRowBase
{
public:
	struct FGameplayTag                           PresenceTag;                                       // 0x0008(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _heightOffset;                                     // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            _offsetPercentagePerDotProductCurve;               // 0x0018(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FGameplayTag>                   _conditionalTagsRequired;                          // 0x0020(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FGameplayTag>                   ConditionalTagsPreventing;                         // 0x0030(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FKillerPOVSurvivorAimOffsetOverrideData) == 0x000008, "Wrong alignment on FKillerPOVSurvivorAimOffsetOverrideData");
static_assert(sizeof(FKillerPOVSurvivorAimOffsetOverrideData) == 0x000040, "Wrong size on FKillerPOVSurvivorAimOffsetOverrideData");
static_assert(offsetof(FKillerPOVSurvivorAimOffsetOverrideData, PresenceTag) == 0x000008, "Member 'FKillerPOVSurvivorAimOffsetOverrideData::PresenceTag' has a wrong offset!");
static_assert(offsetof(FKillerPOVSurvivorAimOffsetOverrideData, _heightOffset) == 0x000014, "Member 'FKillerPOVSurvivorAimOffsetOverrideData::_heightOffset' has a wrong offset!");
static_assert(offsetof(FKillerPOVSurvivorAimOffsetOverrideData, _offsetPercentagePerDotProductCurve) == 0x000018, "Member 'FKillerPOVSurvivorAimOffsetOverrideData::_offsetPercentagePerDotProductCurve' has a wrong offset!");
static_assert(offsetof(FKillerPOVSurvivorAimOffsetOverrideData, _conditionalTagsRequired) == 0x000020, "Member 'FKillerPOVSurvivorAimOffsetOverrideData::_conditionalTagsRequired' has a wrong offset!");
static_assert(offsetof(FKillerPOVSurvivorAimOffsetOverrideData, ConditionalTagsPreventing) == 0x000030, "Member 'FKillerPOVSurvivorAimOffsetOverrideData::ConditionalTagsPreventing' has a wrong offset!");

// ScriptStruct DeadByDaylight.AssignedPerkProperties
// 0x0014 (0x0014 - 0x0000)
struct FAssignedPerkProperties final
{
public:
	class FName                                   PerkId;                                            // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PerkLevel;                                         // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsTeachable;                                       // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAssignedPerkProperties) == 0x000004, "Wrong alignment on FAssignedPerkProperties");
static_assert(sizeof(FAssignedPerkProperties) == 0x000014, "Wrong size on FAssignedPerkProperties");
static_assert(offsetof(FAssignedPerkProperties, PerkId) == 0x000000, "Member 'FAssignedPerkProperties::PerkId' has a wrong offset!");
static_assert(offsetof(FAssignedPerkProperties, PerkLevel) == 0x00000C, "Member 'FAssignedPerkProperties::PerkLevel' has a wrong offset!");
static_assert(offsetof(FAssignedPerkProperties, IsTeachable) == 0x000010, "Member 'FAssignedPerkProperties::IsTeachable' has a wrong offset!");

// ScriptStruct DeadByDaylight.DeviceProfiles
// 0x0038 (0x0040 - 0x0008)
struct FDeviceProfiles final : public FDBDTableRowBase
{
public:
	class FText                                   Cpu;                                               // 0x0008(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   GPU;                                               // 0x0020(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         Quality;                                           // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDeviceProfiles) == 0x000008, "Wrong alignment on FDeviceProfiles");
static_assert(sizeof(FDeviceProfiles) == 0x000040, "Wrong size on FDeviceProfiles");
static_assert(offsetof(FDeviceProfiles, Cpu) == 0x000008, "Member 'FDeviceProfiles::Cpu' has a wrong offset!");
static_assert(offsetof(FDeviceProfiles, GPU) == 0x000020, "Member 'FDeviceProfiles::GPU' has a wrong offset!");
static_assert(offsetof(FDeviceProfiles, Quality) == 0x000038, "Member 'FDeviceProfiles::Quality' has a wrong offset!");

// ScriptStruct DeadByDaylight.AtlantaRewardUIData
// 0x0060 (0x0060 - 0x0000)
struct FAtlantaRewardUIData final
{
public:
	class FName                                   ID;                                                // 0x0000(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAtlantaRewardType                            Type;                                              // 0x000C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Quantity;                                          // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 IconFilePath;                                      // 0x0018(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECurrencyType                                 Currency;                                          // 0x0028(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemRarity                                   Rarity;                                            // 0x0029(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x6];                                       // 0x002A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DisplayName;                                       // 0x0030(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0048(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAtlantaRewardUIData) == 0x000008, "Wrong alignment on FAtlantaRewardUIData");
static_assert(sizeof(FAtlantaRewardUIData) == 0x000060, "Wrong size on FAtlantaRewardUIData");
static_assert(offsetof(FAtlantaRewardUIData, ID) == 0x000000, "Member 'FAtlantaRewardUIData::ID' has a wrong offset!");
static_assert(offsetof(FAtlantaRewardUIData, Type) == 0x00000C, "Member 'FAtlantaRewardUIData::Type' has a wrong offset!");
static_assert(offsetof(FAtlantaRewardUIData, Quantity) == 0x000010, "Member 'FAtlantaRewardUIData::Quantity' has a wrong offset!");
static_assert(offsetof(FAtlantaRewardUIData, IconFilePath) == 0x000018, "Member 'FAtlantaRewardUIData::IconFilePath' has a wrong offset!");
static_assert(offsetof(FAtlantaRewardUIData, Currency) == 0x000028, "Member 'FAtlantaRewardUIData::Currency' has a wrong offset!");
static_assert(offsetof(FAtlantaRewardUIData, Rarity) == 0x000029, "Member 'FAtlantaRewardUIData::Rarity' has a wrong offset!");
static_assert(offsetof(FAtlantaRewardUIData, DisplayName) == 0x000030, "Member 'FAtlantaRewardUIData::DisplayName' has a wrong offset!");
static_assert(offsetof(FAtlantaRewardUIData, Description) == 0x000048, "Member 'FAtlantaRewardUIData::Description' has a wrong offset!");

// ScriptStruct DeadByDaylight.ParadiseData
// 0x0058 (0x0058 - 0x0000)
struct alignas(0x08) FParadiseData final
{
public:
	uint8                                         Pad_0[0x58];                                       // 0x0000(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FParadiseData) == 0x000008, "Wrong alignment on FParadiseData");
static_assert(sizeof(FParadiseData) == 0x000058, "Wrong size on FParadiseData");

// ScriptStruct DeadByDaylight.AtlantaSubRitualUIData
// 0x0018 (0x0018 - 0x0000)
struct FAtlantaSubRitualUIData final
{
public:
	class FString                                 Description;                                       // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TargetNumber;                                      // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentNumber;                                     // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAtlantaSubRitualUIData) == 0x000008, "Wrong alignment on FAtlantaSubRitualUIData");
static_assert(sizeof(FAtlantaSubRitualUIData) == 0x000018, "Wrong size on FAtlantaSubRitualUIData");
static_assert(offsetof(FAtlantaSubRitualUIData, Description) == 0x000000, "Member 'FAtlantaSubRitualUIData::Description' has a wrong offset!");
static_assert(offsetof(FAtlantaSubRitualUIData, TargetNumber) == 0x000010, "Member 'FAtlantaSubRitualUIData::TargetNumber' has a wrong offset!");
static_assert(offsetof(FAtlantaSubRitualUIData, CurrentNumber) == 0x000014, "Member 'FAtlantaSubRitualUIData::CurrentNumber' has a wrong offset!");

// ScriptStruct DeadByDaylight.AtlantaRitualRewardUIData
// 0x0020 (0x0020 - 0x0000)
struct FAtlantaRitualRewardUIData final
{
public:
	EAtlantaRitualRewardUIType                    Type;                                              // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Quantity;                                          // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 IconFilePath;                                      // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemRarity                                   Rarity;                                            // 0x0018(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAtlantaRitualRewardUIData) == 0x000008, "Wrong alignment on FAtlantaRitualRewardUIData");
static_assert(sizeof(FAtlantaRitualRewardUIData) == 0x000020, "Wrong size on FAtlantaRitualRewardUIData");
static_assert(offsetof(FAtlantaRitualRewardUIData, Type) == 0x000000, "Member 'FAtlantaRitualRewardUIData::Type' has a wrong offset!");
static_assert(offsetof(FAtlantaRitualRewardUIData, Quantity) == 0x000004, "Member 'FAtlantaRitualRewardUIData::Quantity' has a wrong offset!");
static_assert(offsetof(FAtlantaRitualRewardUIData, IconFilePath) == 0x000008, "Member 'FAtlantaRitualRewardUIData::IconFilePath' has a wrong offset!");
static_assert(offsetof(FAtlantaRitualRewardUIData, Rarity) == 0x000018, "Member 'FAtlantaRitualRewardUIData::Rarity' has a wrong offset!");

// ScriptStruct DeadByDaylight.ItemTypeData
// 0x0140 (0x0148 - 0x0008)
struct FItemTypeData final : public FDBDTableRowBase
{
public:
	ELoadoutItemType                              ItemType;                                          // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FItemUIData                            UIData;                                            // 0x0010(0x0138)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FItemTypeData) == 0x000008, "Wrong alignment on FItemTypeData");
static_assert(sizeof(FItemTypeData) == 0x000148, "Wrong size on FItemTypeData");
static_assert(offsetof(FItemTypeData, ItemType) == 0x000008, "Member 'FItemTypeData::ItemType' has a wrong offset!");
static_assert(offsetof(FItemTypeData, UIData) == 0x000010, "Member 'FItemTypeData::UIData' has a wrong offset!");

// ScriptStruct DeadByDaylight.AtlantaRitualUIData
// 0x0068 (0x0068 - 0x0000)
struct FAtlantaRitualUIData final
{
public:
	int32                                         ID;                                                // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAltantaRitualUIType                          Type;                                              // 0x0004(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Title;                                             // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Description;                                       // 0x0018(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 IconFilePath;                                      // 0x0028(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsNew;                                             // 0x0038(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsClaimed;                                         // 0x0039(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x2];                                       // 0x003A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ProgressPercentage;                                // 0x003C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RefreshPrice;                                      // 0x0040(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAtlantaRitualRewardUIData>     Rewards;                                           // 0x0048(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FAtlantaSubRitualUIData>        SubRituals;                                        // 0x0058(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAtlantaRitualUIData) == 0x000008, "Wrong alignment on FAtlantaRitualUIData");
static_assert(sizeof(FAtlantaRitualUIData) == 0x000068, "Wrong size on FAtlantaRitualUIData");
static_assert(offsetof(FAtlantaRitualUIData, ID) == 0x000000, "Member 'FAtlantaRitualUIData::ID' has a wrong offset!");
static_assert(offsetof(FAtlantaRitualUIData, Type) == 0x000004, "Member 'FAtlantaRitualUIData::Type' has a wrong offset!");
static_assert(offsetof(FAtlantaRitualUIData, Title) == 0x000008, "Member 'FAtlantaRitualUIData::Title' has a wrong offset!");
static_assert(offsetof(FAtlantaRitualUIData, Description) == 0x000018, "Member 'FAtlantaRitualUIData::Description' has a wrong offset!");
static_assert(offsetof(FAtlantaRitualUIData, IconFilePath) == 0x000028, "Member 'FAtlantaRitualUIData::IconFilePath' has a wrong offset!");
static_assert(offsetof(FAtlantaRitualUIData, IsNew) == 0x000038, "Member 'FAtlantaRitualUIData::IsNew' has a wrong offset!");
static_assert(offsetof(FAtlantaRitualUIData, IsClaimed) == 0x000039, "Member 'FAtlantaRitualUIData::IsClaimed' has a wrong offset!");
static_assert(offsetof(FAtlantaRitualUIData, ProgressPercentage) == 0x00003C, "Member 'FAtlantaRitualUIData::ProgressPercentage' has a wrong offset!");
static_assert(offsetof(FAtlantaRitualUIData, RefreshPrice) == 0x000040, "Member 'FAtlantaRitualUIData::RefreshPrice' has a wrong offset!");
static_assert(offsetof(FAtlantaRitualUIData, Rewards) == 0x000048, "Member 'FAtlantaRitualUIData::Rewards' has a wrong offset!");
static_assert(offsetof(FAtlantaRitualUIData, SubRituals) == 0x000058, "Member 'FAtlantaRitualUIData::SubRituals' has a wrong offset!");

// ScriptStruct DeadByDaylight.AtlantaRitualsUIScreenData
// 0x0030 (0x0030 - 0x0000)
struct FAtlantaRitualsUIScreenData final
{
public:
	struct FDateTime                              DailyRefreshTime;                                  // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              WeeklyRefreshTime;                                 // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FAtlantaRitualUIData>           DailyRituals;                                      // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FAtlantaRitualUIData>           WeeklyRituals;                                     // 0x0020(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAtlantaRitualsUIScreenData) == 0x000008, "Wrong alignment on FAtlantaRitualsUIScreenData");
static_assert(sizeof(FAtlantaRitualsUIScreenData) == 0x000030, "Wrong size on FAtlantaRitualsUIScreenData");
static_assert(offsetof(FAtlantaRitualsUIScreenData, DailyRefreshTime) == 0x000000, "Member 'FAtlantaRitualsUIScreenData::DailyRefreshTime' has a wrong offset!");
static_assert(offsetof(FAtlantaRitualsUIScreenData, WeeklyRefreshTime) == 0x000008, "Member 'FAtlantaRitualsUIScreenData::WeeklyRefreshTime' has a wrong offset!");
static_assert(offsetof(FAtlantaRitualsUIScreenData, DailyRituals) == 0x000010, "Member 'FAtlantaRitualsUIScreenData::DailyRituals' has a wrong offset!");
static_assert(offsetof(FAtlantaRitualsUIScreenData, WeeklyRituals) == 0x000020, "Member 'FAtlantaRitualsUIScreenData::WeeklyRituals' has a wrong offset!");

// ScriptStruct DeadByDaylight.LightingSpecifics
// 0x0070 (0x0070 - 0x0000)
struct FLightingSpecifics final
{
public:
	TSoftClassPtr<class UClass>                   LightBlueprint;                                    // 0x0000(0x0038)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAmbianceManagerDataAsset> LightAmbiance;                                     // 0x0038(0x0038)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLightingSpecifics) == 0x000008, "Wrong alignment on FLightingSpecifics");
static_assert(sizeof(FLightingSpecifics) == 0x000070, "Wrong size on FLightingSpecifics");
static_assert(offsetof(FLightingSpecifics, LightBlueprint) == 0x000000, "Member 'FLightingSpecifics::LightBlueprint' has a wrong offset!");
static_assert(offsetof(FLightingSpecifics, LightAmbiance) == 0x000038, "Member 'FLightingSpecifics::LightAmbiance' has a wrong offset!");

// ScriptStruct DeadByDaylight.SceneLightingDescription
// 0x0128 (0x0130 - 0x0008)
struct FSceneLightingDescription final : public FDBDTableRowBase
{
public:
	class FName                                   ThemeName;                                         // 0x0008(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseAmbianceManager;                                // 0x0014(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLightingSpecifics                     LightingDetailsLowMedium;                          // 0x0018(0x0070)(Edit, NativeAccessSpecifierPublic)
	struct FLightingSpecifics                     LightingDetailsHighUltra;                          // 0x0088(0x0070)(Edit, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTextureCube>            TextureCube;                                       // 0x00F8(0x0038)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSceneLightingDescription) == 0x000008, "Wrong alignment on FSceneLightingDescription");
static_assert(sizeof(FSceneLightingDescription) == 0x000130, "Wrong size on FSceneLightingDescription");
static_assert(offsetof(FSceneLightingDescription, ThemeName) == 0x000008, "Member 'FSceneLightingDescription::ThemeName' has a wrong offset!");
static_assert(offsetof(FSceneLightingDescription, UseAmbianceManager) == 0x000014, "Member 'FSceneLightingDescription::UseAmbianceManager' has a wrong offset!");
static_assert(offsetof(FSceneLightingDescription, LightingDetailsLowMedium) == 0x000018, "Member 'FSceneLightingDescription::LightingDetailsLowMedium' has a wrong offset!");
static_assert(offsetof(FSceneLightingDescription, LightingDetailsHighUltra) == 0x000088, "Member 'FSceneLightingDescription::LightingDetailsHighUltra' has a wrong offset!");
static_assert(offsetof(FSceneLightingDescription, TextureCube) == 0x0000F8, "Member 'FSceneLightingDescription::TextureCube' has a wrong offset!");

// ScriptStruct DeadByDaylight.AtlantaTutorialEndReward
// 0x0020 (0x0028 - 0x0008)
struct FAtlantaTutorialEndReward final : public FDBDTableRowBase
{
public:
	int32                                         BloodpointReward;                                  // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AuricCellsRewards;                                 // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FearTokensReward;                                  // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           CharactersRewards;                                 // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAtlantaTutorialEndReward) == 0x000008, "Wrong alignment on FAtlantaTutorialEndReward");
static_assert(sizeof(FAtlantaTutorialEndReward) == 0x000028, "Wrong size on FAtlantaTutorialEndReward");
static_assert(offsetof(FAtlantaTutorialEndReward, BloodpointReward) == 0x000008, "Member 'FAtlantaTutorialEndReward::BloodpointReward' has a wrong offset!");
static_assert(offsetof(FAtlantaTutorialEndReward, AuricCellsRewards) == 0x00000C, "Member 'FAtlantaTutorialEndReward::AuricCellsRewards' has a wrong offset!");
static_assert(offsetof(FAtlantaTutorialEndReward, FearTokensReward) == 0x000010, "Member 'FAtlantaTutorialEndReward::FearTokensReward' has a wrong offset!");
static_assert(offsetof(FAtlantaTutorialEndReward, CharactersRewards) == 0x000018, "Member 'FAtlantaTutorialEndReward::CharactersRewards' has a wrong offset!");

// ScriptStruct DeadByDaylight.SubstitutionElements
// 0x0070 (0x0070 - 0x0000)
struct FSubstitutionElements final
{
public:
	TSoftClassPtr<class UClass>                   _elementToReplace;                                 // 0x0000(0x0038)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftClassPtr<class UClass>                   _elementToReplaceWith;                             // 0x0038(0x0038)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FSubstitutionElements) == 0x000008, "Wrong alignment on FSubstitutionElements");
static_assert(sizeof(FSubstitutionElements) == 0x000070, "Wrong size on FSubstitutionElements");
static_assert(offsetof(FSubstitutionElements, _elementToReplace) == 0x000000, "Member 'FSubstitutionElements::_elementToReplace' has a wrong offset!");
static_assert(offsetof(FSubstitutionElements, _elementToReplaceWith) == 0x000038, "Member 'FSubstitutionElements::_elementToReplaceWith' has a wrong offset!");

// ScriptStruct DeadByDaylight.GameplayElementSubstitutions
// 0x0018 (0x0028 - 0x0010)
struct FGameplayElementSubstitutions final : public FElementSubstitutions
{
public:
	TArray<struct FSubstitutionElements>          _replacements;                                     // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPrivate)
	EGameplayElementType                          _type;                                             // 0x0020(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayElementSubstitutions) == 0x000008, "Wrong alignment on FGameplayElementSubstitutions");
static_assert(sizeof(FGameplayElementSubstitutions) == 0x000028, "Wrong size on FGameplayElementSubstitutions");
static_assert(offsetof(FGameplayElementSubstitutions, _replacements) == 0x000010, "Member 'FGameplayElementSubstitutions::_replacements' has a wrong offset!");
static_assert(offsetof(FGameplayElementSubstitutions, _type) == 0x000020, "Member 'FGameplayElementSubstitutions::_type' has a wrong offset!");

// ScriptStruct DeadByDaylight.DependencyElementSubstitutions
// 0x0018 (0x0028 - 0x0010)
struct FDependencyElementSubstitutions final : public FElementSubstitutions
{
public:
	TArray<struct FSubstitutionElements>          _replacements;                                     // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPrivate)
	ETileSpawnPointType                           _type;                                             // 0x0020(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDependencyElementSubstitutions) == 0x000008, "Wrong alignment on FDependencyElementSubstitutions");
static_assert(sizeof(FDependencyElementSubstitutions) == 0x000028, "Wrong size on FDependencyElementSubstitutions");
static_assert(offsetof(FDependencyElementSubstitutions, _replacements) == 0x000010, "Member 'FDependencyElementSubstitutions::_replacements' has a wrong offset!");
static_assert(offsetof(FDependencyElementSubstitutions, _type) == 0x000020, "Member 'FDependencyElementSubstitutions::_type' has a wrong offset!");

// ScriptStruct DeadByDaylight.TileSubstitutions
// 0x0010 (0x0010 - 0x0000)
struct FTileSubstitutions final
{
public:
	TArray<struct FSubstitutionElements>          _replacements;                                     // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FTileSubstitutions) == 0x000008, "Wrong alignment on FTileSubstitutions");
static_assert(sizeof(FTileSubstitutions) == 0x000010, "Wrong size on FTileSubstitutions");
static_assert(offsetof(FTileSubstitutions, _replacements) == 0x000000, "Member 'FTileSubstitutions::_replacements' has a wrong offset!");

// ScriptStruct DeadByDaylight.OutOfWorldTileData
// 0x0050 (0x0050 - 0x0000)
struct FOutOfWorldTileData final
{
public:
	struct FVector                                _spawnLocation;                                    // 0x0000(0x0018)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftClassPtr<class UClass>                   _tileClass;                                        // 0x0018(0x0038)(Edit, DisableEditOnTemplate, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FOutOfWorldTileData) == 0x000008, "Wrong alignment on FOutOfWorldTileData");
static_assert(sizeof(FOutOfWorldTileData) == 0x000050, "Wrong size on FOutOfWorldTileData");
static_assert(offsetof(FOutOfWorldTileData, _spawnLocation) == 0x000000, "Member 'FOutOfWorldTileData::_spawnLocation' has a wrong offset!");
static_assert(offsetof(FOutOfWorldTileData, _tileClass) == 0x000018, "Member 'FOutOfWorldTileData::_tileClass' has a wrong offset!");

// ScriptStruct DeadByDaylight.DependencyElementAddition
// 0x0088 (0x0088 - 0x0000)
struct FDependencyElementAddition final
{
public:
	TSoftClassPtr<class UClass>                   _object;                                           // 0x0000(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ETileSpawnPointType                           _type;                                             // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _numberToAdd;                                      // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         _spawnOrder;                                       // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDataTableDropdown                     _elementSpawnConditionsName;                       // 0x0048(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPrivate)
	struct FGameplayTag                           _elementTag;                                       // 0x0078(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _allowFallback;                                    // 0x0084(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_85[0x3];                                       // 0x0085(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDependencyElementAddition) == 0x000008, "Wrong alignment on FDependencyElementAddition");
static_assert(sizeof(FDependencyElementAddition) == 0x000088, "Wrong size on FDependencyElementAddition");
static_assert(offsetof(FDependencyElementAddition, _object) == 0x000000, "Member 'FDependencyElementAddition::_object' has a wrong offset!");
static_assert(offsetof(FDependencyElementAddition, _type) == 0x000038, "Member 'FDependencyElementAddition::_type' has a wrong offset!");
static_assert(offsetof(FDependencyElementAddition, _numberToAdd) == 0x00003C, "Member 'FDependencyElementAddition::_numberToAdd' has a wrong offset!");
static_assert(offsetof(FDependencyElementAddition, _spawnOrder) == 0x000040, "Member 'FDependencyElementAddition::_spawnOrder' has a wrong offset!");
static_assert(offsetof(FDependencyElementAddition, _elementSpawnConditionsName) == 0x000048, "Member 'FDependencyElementAddition::_elementSpawnConditionsName' has a wrong offset!");
static_assert(offsetof(FDependencyElementAddition, _elementTag) == 0x000078, "Member 'FDependencyElementAddition::_elementTag' has a wrong offset!");
static_assert(offsetof(FDependencyElementAddition, _allowFallback) == 0x000084, "Member 'FDependencyElementAddition::_allowFallback' has a wrong offset!");

// ScriptStruct DeadByDaylight.GameplayElementAddition
// 0x0048 (0x0048 - 0x0000)
struct FGameplayElementAddition final
{
public:
	TSoftClassPtr<class UClass>                   _elementToAdd;                                     // 0x0000(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EGameplayElementType                          _spawnerType;                                      // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _numberToAdd;                                      // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _numberToAddAffectedByOffering;                    // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayElementAddition) == 0x000008, "Wrong alignment on FGameplayElementAddition");
static_assert(sizeof(FGameplayElementAddition) == 0x000048, "Wrong size on FGameplayElementAddition");
static_assert(offsetof(FGameplayElementAddition, _elementToAdd) == 0x000000, "Member 'FGameplayElementAddition::_elementToAdd' has a wrong offset!");
static_assert(offsetof(FGameplayElementAddition, _spawnerType) == 0x000038, "Member 'FGameplayElementAddition::_spawnerType' has a wrong offset!");
static_assert(offsetof(FGameplayElementAddition, _numberToAdd) == 0x00003C, "Member 'FGameplayElementAddition::_numberToAdd' has a wrong offset!");
static_assert(offsetof(FGameplayElementAddition, _numberToAddAffectedByOffering) == 0x000040, "Member 'FGameplayElementAddition::_numberToAddAffectedByOffering' has a wrong offset!");

// ScriptStruct DeadByDaylight.EventSubstitionData
// 0x0088 (0x0090 - 0x0008)
struct FEventSubstitionData final : public FDBDTableRowBase
{
public:
	class FName                                   _name;                                             // 0x0008(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _allowSubstitutionInKYF;                           // 0x0014(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _baseNumOfSubstitutionPerGroup;                    // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameplayElementSubstitutions>  _gameplaySubstitutionElements;                     // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FDependencyElementSubstitutions> _dependencySubstitutionElements;                   // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPrivate)
	struct FTileSubstitutions                     _tileSubstitutions;                                // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPrivate)
	TArray<struct FOutOfWorldTileData>            _outOfWorldTiles;                                  // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPrivate)
	class FString                                 _eventTileSuffix;                                  // 0x0060(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FDependencyElementAddition>     _dependencyElementAdditions;                       // 0x0070(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FGameplayElementAddition>       _gameplayElementAdditions;                         // 0x0080(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FEventSubstitionData) == 0x000008, "Wrong alignment on FEventSubstitionData");
static_assert(sizeof(FEventSubstitionData) == 0x000090, "Wrong size on FEventSubstitionData");
static_assert(offsetof(FEventSubstitionData, _name) == 0x000008, "Member 'FEventSubstitionData::_name' has a wrong offset!");
static_assert(offsetof(FEventSubstitionData, _allowSubstitutionInKYF) == 0x000014, "Member 'FEventSubstitionData::_allowSubstitutionInKYF' has a wrong offset!");
static_assert(offsetof(FEventSubstitionData, _baseNumOfSubstitutionPerGroup) == 0x000018, "Member 'FEventSubstitionData::_baseNumOfSubstitutionPerGroup' has a wrong offset!");
static_assert(offsetof(FEventSubstitionData, _gameplaySubstitutionElements) == 0x000020, "Member 'FEventSubstitionData::_gameplaySubstitutionElements' has a wrong offset!");
static_assert(offsetof(FEventSubstitionData, _dependencySubstitutionElements) == 0x000030, "Member 'FEventSubstitionData::_dependencySubstitutionElements' has a wrong offset!");
static_assert(offsetof(FEventSubstitionData, _tileSubstitutions) == 0x000040, "Member 'FEventSubstitionData::_tileSubstitutions' has a wrong offset!");
static_assert(offsetof(FEventSubstitionData, _outOfWorldTiles) == 0x000050, "Member 'FEventSubstitionData::_outOfWorldTiles' has a wrong offset!");
static_assert(offsetof(FEventSubstitionData, _eventTileSuffix) == 0x000060, "Member 'FEventSubstitionData::_eventTileSuffix' has a wrong offset!");
static_assert(offsetof(FEventSubstitionData, _dependencyElementAdditions) == 0x000070, "Member 'FEventSubstitionData::_dependencyElementAdditions' has a wrong offset!");
static_assert(offsetof(FEventSubstitionData, _gameplayElementAdditions) == 0x000080, "Member 'FEventSubstitionData::_gameplayElementAdditions' has a wrong offset!");

// ScriptStruct DeadByDaylight.TutorialNotificationData
// 0x00B8 (0x00C0 - 0x0008)
struct FTutorialNotificationData : public FDBDTableRowBase
{
public:
	class FText                                   Title;                                             // 0x0008(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0020(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FString                                 IconPath;                                          // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              Icon;                                              // 0x0048(0x0038)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              Image;                                             // 0x0080(0x0038)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsShowAnalyticEnabled;                             // 0x00B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B9[0x7];                                       // 0x00B9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTutorialNotificationData) == 0x000008, "Wrong alignment on FTutorialNotificationData");
static_assert(sizeof(FTutorialNotificationData) == 0x0000C0, "Wrong size on FTutorialNotificationData");
static_assert(offsetof(FTutorialNotificationData, Title) == 0x000008, "Member 'FTutorialNotificationData::Title' has a wrong offset!");
static_assert(offsetof(FTutorialNotificationData, Description) == 0x000020, "Member 'FTutorialNotificationData::Description' has a wrong offset!");
static_assert(offsetof(FTutorialNotificationData, IconPath) == 0x000038, "Member 'FTutorialNotificationData::IconPath' has a wrong offset!");
static_assert(offsetof(FTutorialNotificationData, Icon) == 0x000048, "Member 'FTutorialNotificationData::Icon' has a wrong offset!");
static_assert(offsetof(FTutorialNotificationData, Image) == 0x000080, "Member 'FTutorialNotificationData::Image' has a wrong offset!");
static_assert(offsetof(FTutorialNotificationData, IsShowAnalyticEnabled) == 0x0000B8, "Member 'FTutorialNotificationData::IsShowAnalyticEnabled' has a wrong offset!");

// ScriptStruct DeadByDaylight.AtlantaTutorialNotificationData
// 0x0010 (0x00D0 - 0x00C0)
struct FAtlantaTutorialNotificationData final : public FTutorialNotificationData
{
public:
	TArray<TSoftObjectPtr<class UPaperSprite>>    Textures;                                          // 0x00C0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAtlantaTutorialNotificationData) == 0x000008, "Wrong alignment on FAtlantaTutorialNotificationData");
static_assert(sizeof(FAtlantaTutorialNotificationData) == 0x0000D0, "Wrong size on FAtlantaTutorialNotificationData");
static_assert(offsetof(FAtlantaTutorialNotificationData, Textures) == 0x0000C0, "Member 'FAtlantaTutorialNotificationData::Textures' has a wrong offset!");

// ScriptStruct DeadByDaylight.AtlantaTutorialTallyData
// 0x0020 (0x0020 - 0x0000)
struct FAtlantaTutorialTallyData final
{
public:
	bool                                          IsKiller;                                          // 0x0000(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          FirstTimeCompleted;                                // 0x0001(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         BloodpointsScore;                                  // 0x0004(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AuricCells;                                        // 0x0008(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FearTokens;                                        // 0x000C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           Characters;                                        // 0x0010(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAtlantaTutorialTallyData) == 0x000008, "Wrong alignment on FAtlantaTutorialTallyData");
static_assert(sizeof(FAtlantaTutorialTallyData) == 0x000020, "Wrong size on FAtlantaTutorialTallyData");
static_assert(offsetof(FAtlantaTutorialTallyData, IsKiller) == 0x000000, "Member 'FAtlantaTutorialTallyData::IsKiller' has a wrong offset!");
static_assert(offsetof(FAtlantaTutorialTallyData, FirstTimeCompleted) == 0x000001, "Member 'FAtlantaTutorialTallyData::FirstTimeCompleted' has a wrong offset!");
static_assert(offsetof(FAtlantaTutorialTallyData, BloodpointsScore) == 0x000004, "Member 'FAtlantaTutorialTallyData::BloodpointsScore' has a wrong offset!");
static_assert(offsetof(FAtlantaTutorialTallyData, AuricCells) == 0x000008, "Member 'FAtlantaTutorialTallyData::AuricCells' has a wrong offset!");
static_assert(offsetof(FAtlantaTutorialTallyData, FearTokens) == 0x00000C, "Member 'FAtlantaTutorialTallyData::FearTokens' has a wrong offset!");
static_assert(offsetof(FAtlantaTutorialTallyData, Characters) == 0x000010, "Member 'FAtlantaTutorialTallyData::Characters' has a wrong offset!");

// ScriptStruct DeadByDaylight.AttackEventTypeDetails
// 0x0028 (0x0030 - 0x0008)
struct FAttackEventTypeDetails final : public FDBDTableRowBase
{
public:
	struct FGameplayTag                           GameplayTag;                                       // 0x0008(0x000C)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttackEventType                              AttackEventType;                                   // 0x0014(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanBeProtective;                                   // 0x0015(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16[0x2];                                       // 0x0016(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AssociatedCharacter;                               // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Description;                                       // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAttackEventTypeDetails) == 0x000008, "Wrong alignment on FAttackEventTypeDetails");
static_assert(sizeof(FAttackEventTypeDetails) == 0x000030, "Wrong size on FAttackEventTypeDetails");
static_assert(offsetof(FAttackEventTypeDetails, GameplayTag) == 0x000008, "Member 'FAttackEventTypeDetails::GameplayTag' has a wrong offset!");
static_assert(offsetof(FAttackEventTypeDetails, AttackEventType) == 0x000014, "Member 'FAttackEventTypeDetails::AttackEventType' has a wrong offset!");
static_assert(offsetof(FAttackEventTypeDetails, CanBeProtective) == 0x000015, "Member 'FAttackEventTypeDetails::CanBeProtective' has a wrong offset!");
static_assert(offsetof(FAttackEventTypeDetails, AssociatedCharacter) == 0x000018, "Member 'FAttackEventTypeDetails::AssociatedCharacter' has a wrong offset!");
static_assert(offsetof(FAttackEventTypeDetails, Description) == 0x000020, "Member 'FAttackEventTypeDetails::Description' has a wrong offset!");

// ScriptStruct DeadByDaylight.FilesInformation
// 0x0068 (0x0068 - 0x0000)
struct FFilesInformation final
{
public:
	int32                                         OnDiskPakCount;                                    // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExpectedPakCount;                                  // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PakMountCount;                                     // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OnDiskUcasCount;                                   // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExpectedUcasCount;                                 // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SignedPakDelta;                                    // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EncryptionDelta;                                   // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FlagReaderCheckSignature;                          // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FlagWorkerCheckSignature;                          // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int64>                                 OnDiskPakSizes;                                    // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int64>                                 ExpectedPakSizes;                                  // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int64>                                 OnDiskUcasSizes;                                   // 0x0048(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int64>                                 ExpectedUcasSizes;                                 // 0x0058(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFilesInformation) == 0x000008, "Wrong alignment on FFilesInformation");
static_assert(sizeof(FFilesInformation) == 0x000068, "Wrong size on FFilesInformation");
static_assert(offsetof(FFilesInformation, OnDiskPakCount) == 0x000000, "Member 'FFilesInformation::OnDiskPakCount' has a wrong offset!");
static_assert(offsetof(FFilesInformation, ExpectedPakCount) == 0x000004, "Member 'FFilesInformation::ExpectedPakCount' has a wrong offset!");
static_assert(offsetof(FFilesInformation, PakMountCount) == 0x000008, "Member 'FFilesInformation::PakMountCount' has a wrong offset!");
static_assert(offsetof(FFilesInformation, OnDiskUcasCount) == 0x00000C, "Member 'FFilesInformation::OnDiskUcasCount' has a wrong offset!");
static_assert(offsetof(FFilesInformation, ExpectedUcasCount) == 0x000010, "Member 'FFilesInformation::ExpectedUcasCount' has a wrong offset!");
static_assert(offsetof(FFilesInformation, SignedPakDelta) == 0x000014, "Member 'FFilesInformation::SignedPakDelta' has a wrong offset!");
static_assert(offsetof(FFilesInformation, EncryptionDelta) == 0x000018, "Member 'FFilesInformation::EncryptionDelta' has a wrong offset!");
static_assert(offsetof(FFilesInformation, FlagReaderCheckSignature) == 0x00001C, "Member 'FFilesInformation::FlagReaderCheckSignature' has a wrong offset!");
static_assert(offsetof(FFilesInformation, FlagWorkerCheckSignature) == 0x000020, "Member 'FFilesInformation::FlagWorkerCheckSignature' has a wrong offset!");
static_assert(offsetof(FFilesInformation, OnDiskPakSizes) == 0x000028, "Member 'FFilesInformation::OnDiskPakSizes' has a wrong offset!");
static_assert(offsetof(FFilesInformation, ExpectedPakSizes) == 0x000038, "Member 'FFilesInformation::ExpectedPakSizes' has a wrong offset!");
static_assert(offsetof(FFilesInformation, OnDiskUcasSizes) == 0x000048, "Member 'FFilesInformation::OnDiskUcasSizes' has a wrong offset!");
static_assert(offsetof(FFilesInformation, ExpectedUcasSizes) == 0x000058, "Member 'FFilesInformation::ExpectedUcasSizes' has a wrong offset!");

// ScriptStruct DeadByDaylight.AttackHitResult
// 0x0088 (0x0088 - 0x0000)
struct FAttackHitResult final
{
public:
	class ADBDPlayer*                             Attacker;                                          // 0x0000(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ADBDPlayer*                             Target;                                            // 0x0008(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDBDAttack*                             Attack;                                            // 0x0010(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsBasicAttack;                                     // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CosmeticOnly;                                      // 0x0019(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x6E];                                      // 0x001A(0x006E)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAttackHitResult) == 0x000008, "Wrong alignment on FAttackHitResult");
static_assert(sizeof(FAttackHitResult) == 0x000088, "Wrong size on FAttackHitResult");
static_assert(offsetof(FAttackHitResult, Attacker) == 0x000000, "Member 'FAttackHitResult::Attacker' has a wrong offset!");
static_assert(offsetof(FAttackHitResult, Target) == 0x000008, "Member 'FAttackHitResult::Target' has a wrong offset!");
static_assert(offsetof(FAttackHitResult, Attack) == 0x000010, "Member 'FAttackHitResult::Attack' has a wrong offset!");
static_assert(offsetof(FAttackHitResult, IsBasicAttack) == 0x000018, "Member 'FAttackHitResult::IsBasicAttack' has a wrong offset!");
static_assert(offsetof(FAttackHitResult, CosmeticOnly) == 0x000019, "Member 'FAttackHitResult::CosmeticOnly' has a wrong offset!");

// ScriptStruct DeadByDaylight.AvailableInteractionCalculator
// 0x01E8 (0x01E8 - 0x0000)
struct FAvailableInteractionCalculator final
{
public:
	uint8                                         Pad_0[0x68];                                       // 0x0000(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class UInteractionDefinition*>           _interactions;                                     // 0x0068(0x0050)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B8[0x118];                                     // 0x00B8(0x0118)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _fullEvaluationFrequency;                          // 0x01D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         _maxFramesForFullEvaluation;                       // 0x01D4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _secondsBetweenNullReferenceCleanup;               // 0x01D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1DC[0xC];                                      // 0x01DC(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAvailableInteractionCalculator) == 0x000008, "Wrong alignment on FAvailableInteractionCalculator");
static_assert(sizeof(FAvailableInteractionCalculator) == 0x0001E8, "Wrong size on FAvailableInteractionCalculator");
static_assert(offsetof(FAvailableInteractionCalculator, _interactions) == 0x000068, "Member 'FAvailableInteractionCalculator::_interactions' has a wrong offset!");
static_assert(offsetof(FAvailableInteractionCalculator, _fullEvaluationFrequency) == 0x0001D0, "Member 'FAvailableInteractionCalculator::_fullEvaluationFrequency' has a wrong offset!");
static_assert(offsetof(FAvailableInteractionCalculator, _maxFramesForFullEvaluation) == 0x0001D4, "Member 'FAvailableInteractionCalculator::_maxFramesForFullEvaluation' has a wrong offset!");
static_assert(offsetof(FAvailableInteractionCalculator, _secondsBetweenNullReferenceCleanup) == 0x0001D8, "Member 'FAvailableInteractionCalculator::_secondsBetweenNullReferenceCleanup' has a wrong offset!");

// ScriptStruct DeadByDaylight.BackendCinematicsContentData
// 0x0048 (0x0048 - 0x0000)
struct FBackendCinematicsContentData final
{
public:
	class FString                                 ID;                                                // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          AllowSkip;                                         // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 StartDate;                                         // 0x0018(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 EndDate;                                           // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBackendCinematicsContentData) == 0x000008, "Wrong alignment on FBackendCinematicsContentData");
static_assert(sizeof(FBackendCinematicsContentData) == 0x000048, "Wrong size on FBackendCinematicsContentData");
static_assert(offsetof(FBackendCinematicsContentData, ID) == 0x000000, "Member 'FBackendCinematicsContentData::ID' has a wrong offset!");
static_assert(offsetof(FBackendCinematicsContentData, AllowSkip) == 0x000010, "Member 'FBackendCinematicsContentData::AllowSkip' has a wrong offset!");
static_assert(offsetof(FBackendCinematicsContentData, StartDate) == 0x000018, "Member 'FBackendCinematicsContentData::StartDate' has a wrong offset!");
static_assert(offsetof(FBackendCinematicsContentData, EndDate) == 0x000030, "Member 'FBackendCinematicsContentData::EndDate' has a wrong offset!");

// ScriptStruct DeadByDaylight.BackendCinematicsContent
// 0x0010 (0x0010 - 0x0000)
struct FBackendCinematicsContent final
{
public:
	TArray<struct FBackendCinematicsContentData>  Cinematics;                                        // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FBackendCinematicsContent) == 0x000008, "Wrong alignment on FBackendCinematicsContent");
static_assert(sizeof(FBackendCinematicsContent) == 0x000010, "Wrong size on FBackendCinematicsContent");
static_assert(offsetof(FBackendCinematicsContent, Cinematics) == 0x000000, "Member 'FBackendCinematicsContent::Cinematics' has a wrong offset!");

// ScriptStruct DeadByDaylight.BalanceToolOverrideEntry
// 0x0030 (0x0030 - 0x0000)
struct FBalanceToolOverrideEntry final
{
public:
	class FString                                 DbName;                                            // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 RowName;                                           // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Value;                                             // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBalanceToolOverrideEntry) == 0x000008, "Wrong alignment on FBalanceToolOverrideEntry");
static_assert(sizeof(FBalanceToolOverrideEntry) == 0x000030, "Wrong size on FBalanceToolOverrideEntry");
static_assert(offsetof(FBalanceToolOverrideEntry, DbName) == 0x000000, "Member 'FBalanceToolOverrideEntry::DbName' has a wrong offset!");
static_assert(offsetof(FBalanceToolOverrideEntry, RowName) == 0x000010, "Member 'FBalanceToolOverrideEntry::RowName' has a wrong offset!");
static_assert(offsetof(FBalanceToolOverrideEntry, Value) == 0x000020, "Member 'FBalanceToolOverrideEntry::Value' has a wrong offset!");

// ScriptStruct DeadByDaylight.BalanceToolGameConfig
// 0x0010 (0x0010 - 0x0000)
struct FBalanceToolGameConfig final
{
public:
	TArray<struct FBalanceToolOverrideEntry>      Overrides;                                         // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBalanceToolGameConfig) == 0x000008, "Wrong alignment on FBalanceToolGameConfig");
static_assert(sizeof(FBalanceToolGameConfig) == 0x000010, "Wrong size on FBalanceToolGameConfig");
static_assert(offsetof(FBalanceToolGameConfig, Overrides) == 0x000000, "Member 'FBalanceToolGameConfig::Overrides' has a wrong offset!");

// ScriptStruct DeadByDaylight.RitualEvent
// 0x0030 (0x0030 - 0x0000)
struct FRitualEvent final
{
public:
	EDBDScoreTypes                                ScoreType;                                         // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           GameEventType;                                     // 0x0004(0x000C)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Amount;                                            // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ADBDPlayer*                             Instigator;                                        // 0x0018(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ADBDPlayerState*                        InstigatorPlayerState;                             // 0x0020(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Target;                                            // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRitualEvent) == 0x000008, "Wrong alignment on FRitualEvent");
static_assert(sizeof(FRitualEvent) == 0x000030, "Wrong size on FRitualEvent");
static_assert(offsetof(FRitualEvent, ScoreType) == 0x000000, "Member 'FRitualEvent::ScoreType' has a wrong offset!");
static_assert(offsetof(FRitualEvent, GameEventType) == 0x000004, "Member 'FRitualEvent::GameEventType' has a wrong offset!");
static_assert(offsetof(FRitualEvent, Amount) == 0x000010, "Member 'FRitualEvent::Amount' has a wrong offset!");
static_assert(offsetof(FRitualEvent, Instigator) == 0x000018, "Member 'FRitualEvent::Instigator' has a wrong offset!");
static_assert(offsetof(FRitualEvent, InstigatorPlayerState) == 0x000020, "Member 'FRitualEvent::InstigatorPlayerState' has a wrong offset!");
static_assert(offsetof(FRitualEvent, Target) == 0x000028, "Member 'FRitualEvent::Target' has a wrong offset!");

// ScriptStruct DeadByDaylight.CoreRitualsTunables
// 0x0004 (0x0004 - 0x0000)
struct FCoreRitualsTunables final
{
public:
	int32                                         MaxRituals;                                        // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCoreRitualsTunables) == 0x000004, "Wrong alignment on FCoreRitualsTunables");
static_assert(sizeof(FCoreRitualsTunables) == 0x000004, "Wrong size on FCoreRitualsTunables");
static_assert(offsetof(FCoreRitualsTunables, MaxRituals) == 0x000000, "Member 'FCoreRitualsTunables::MaxRituals' has a wrong offset!");

// ScriptStruct DeadByDaylight.CoreRitualsDifficulty
// 0x0020 (0x0020 - 0x0000)
struct FCoreRitualsDifficulty final
{
public:
	float                                         Threshold;                                         // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Tolerance;                                         // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DisplayThreshold;                                  // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRewardResponseItem>            Rewards;                                           // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCoreRitualsDifficulty) == 0x000008, "Wrong alignment on FCoreRitualsDifficulty");
static_assert(sizeof(FCoreRitualsDifficulty) == 0x000020, "Wrong size on FCoreRitualsDifficulty");
static_assert(offsetof(FCoreRitualsDifficulty, Threshold) == 0x000000, "Member 'FCoreRitualsDifficulty::Threshold' has a wrong offset!");
static_assert(offsetof(FCoreRitualsDifficulty, Tolerance) == 0x000004, "Member 'FCoreRitualsDifficulty::Tolerance' has a wrong offset!");
static_assert(offsetof(FCoreRitualsDifficulty, DisplayThreshold) == 0x000008, "Member 'FCoreRitualsDifficulty::DisplayThreshold' has a wrong offset!");
static_assert(offsetof(FCoreRitualsDifficulty, Rewards) == 0x000010, "Member 'FCoreRitualsDifficulty::Rewards' has a wrong offset!");

// ScriptStruct DeadByDaylight.CoreRitualsEntry
// 0x0020 (0x0020 - 0x0000)
struct FCoreRitualsEntry final
{
public:
	class FString                                 ID;                                                // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FCoreRitualsDifficulty>         Difficulty;                                        // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCoreRitualsEntry) == 0x000008, "Wrong alignment on FCoreRitualsEntry");
static_assert(sizeof(FCoreRitualsEntry) == 0x000020, "Wrong size on FCoreRitualsEntry");
static_assert(offsetof(FCoreRitualsEntry, ID) == 0x000000, "Member 'FCoreRitualsEntry::ID' has a wrong offset!");
static_assert(offsetof(FCoreRitualsEntry, Difficulty) == 0x000010, "Member 'FCoreRitualsEntry::Difficulty' has a wrong offset!");

// ScriptStruct DeadByDaylight.CoreRitualsContent
// 0x0018 (0x0018 - 0x0000)
struct FCoreRitualsContent final
{
public:
	struct FCoreRitualsTunables                   Config;                                            // 0x0000(0x0004)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCoreRitualsEntry>              Data;                                              // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCoreRitualsContent) == 0x000008, "Wrong alignment on FCoreRitualsContent");
static_assert(sizeof(FCoreRitualsContent) == 0x000018, "Wrong size on FCoreRitualsContent");
static_assert(offsetof(FCoreRitualsContent, Config) == 0x000000, "Member 'FCoreRitualsContent::Config' has a wrong offset!");
static_assert(offsetof(FCoreRitualsContent, Data) == 0x000008, "Member 'FCoreRitualsContent::Data' has a wrong offset!");

// ScriptStruct DeadByDaylight.BlindPackData
// 0x0000 (0x01F0 - 0x01F0)
struct FBlindPackData final : public FBaseItemData
{
};
static_assert(alignof(FBlindPackData) == 0x000008, "Wrong alignment on FBlindPackData");
static_assert(sizeof(FBlindPackData) == 0x0001F0, "Wrong size on FBlindPackData");

// ScriptStruct DeadByDaylight.DailyRitualInstance
// 0x0078 (0x0078 - 0x0000)
struct FDailyRitualInstance final
{
public:
	class FString                                 RitualId;                                          // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EDBDScoreTypes>                        TrackedEvents;                                     // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FGameplayTag>                   TrackedGameEvents;                                 // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 CharacterIDs;                                      // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<EPlayerRole>                           Roles;                                             // 0x0040(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         Progress;                                          // 0x0050(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Threshold;                                         // 0x0054(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Tolerance;                                         // 0x0058(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DisplayThreshold;                                  // 0x005C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExpReward;                                         // 0x0060(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Active;                                            // 0x0064(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsTemporary;                                       // 0x0065(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_66[0x2];                                       // 0x0066(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              DateAssigned;                                      // 0x0068(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URitualEvaluatorBase*                   Evaluator;                                         // 0x0070(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDailyRitualInstance) == 0x000008, "Wrong alignment on FDailyRitualInstance");
static_assert(sizeof(FDailyRitualInstance) == 0x000078, "Wrong size on FDailyRitualInstance");
static_assert(offsetof(FDailyRitualInstance, RitualId) == 0x000000, "Member 'FDailyRitualInstance::RitualId' has a wrong offset!");
static_assert(offsetof(FDailyRitualInstance, TrackedEvents) == 0x000010, "Member 'FDailyRitualInstance::TrackedEvents' has a wrong offset!");
static_assert(offsetof(FDailyRitualInstance, TrackedGameEvents) == 0x000020, "Member 'FDailyRitualInstance::TrackedGameEvents' has a wrong offset!");
static_assert(offsetof(FDailyRitualInstance, CharacterIDs) == 0x000030, "Member 'FDailyRitualInstance::CharacterIDs' has a wrong offset!");
static_assert(offsetof(FDailyRitualInstance, Roles) == 0x000040, "Member 'FDailyRitualInstance::Roles' has a wrong offset!");
static_assert(offsetof(FDailyRitualInstance, Progress) == 0x000050, "Member 'FDailyRitualInstance::Progress' has a wrong offset!");
static_assert(offsetof(FDailyRitualInstance, Threshold) == 0x000054, "Member 'FDailyRitualInstance::Threshold' has a wrong offset!");
static_assert(offsetof(FDailyRitualInstance, Tolerance) == 0x000058, "Member 'FDailyRitualInstance::Tolerance' has a wrong offset!");
static_assert(offsetof(FDailyRitualInstance, DisplayThreshold) == 0x00005C, "Member 'FDailyRitualInstance::DisplayThreshold' has a wrong offset!");
static_assert(offsetof(FDailyRitualInstance, ExpReward) == 0x000060, "Member 'FDailyRitualInstance::ExpReward' has a wrong offset!");
static_assert(offsetof(FDailyRitualInstance, Active) == 0x000064, "Member 'FDailyRitualInstance::Active' has a wrong offset!");
static_assert(offsetof(FDailyRitualInstance, IsTemporary) == 0x000065, "Member 'FDailyRitualInstance::IsTemporary' has a wrong offset!");
static_assert(offsetof(FDailyRitualInstance, DateAssigned) == 0x000068, "Member 'FDailyRitualInstance::DateAssigned' has a wrong offset!");
static_assert(offsetof(FDailyRitualInstance, Evaluator) == 0x000070, "Member 'FDailyRitualInstance::Evaluator' has a wrong offset!");

// ScriptStruct DeadByDaylight.DailyRitualContainer
// 0x0028 (0x0028 - 0x0000)
struct FDailyRitualContainer final
{
public:
	struct FDateTime                              LastRitualReceivedDate;                            // 0x0000(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              LastRitualPopupDate;                               // 0x0008(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              LastRitualDismissedDate;                           // 0x0010(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FDailyRitualInstance>           Rituals;                                           // 0x0018(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDailyRitualContainer) == 0x000008, "Wrong alignment on FDailyRitualContainer");
static_assert(sizeof(FDailyRitualContainer) == 0x000028, "Wrong size on FDailyRitualContainer");
static_assert(offsetof(FDailyRitualContainer, LastRitualReceivedDate) == 0x000000, "Member 'FDailyRitualContainer::LastRitualReceivedDate' has a wrong offset!");
static_assert(offsetof(FDailyRitualContainer, LastRitualPopupDate) == 0x000008, "Member 'FDailyRitualContainer::LastRitualPopupDate' has a wrong offset!");
static_assert(offsetof(FDailyRitualContainer, LastRitualDismissedDate) == 0x000010, "Member 'FDailyRitualContainer::LastRitualDismissedDate' has a wrong offset!");
static_assert(offsetof(FDailyRitualContainer, Rituals) == 0x000018, "Member 'FDailyRitualContainer::Rituals' has a wrong offset!");

// ScriptStruct DeadByDaylight.PlayerBlockData
// 0x0018 (0x0018 - 0x0000)
struct FPlayerBlockData final
{
public:
	class ADBDPlayer*                             BlockedPlayer;                                     // 0x0000(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           BlockStyle;                                        // 0x0008(0x000C)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerBlockData) == 0x000008, "Wrong alignment on FPlayerBlockData");
static_assert(sizeof(FPlayerBlockData) == 0x000018, "Wrong size on FPlayerBlockData");
static_assert(offsetof(FPlayerBlockData, BlockedPlayer) == 0x000000, "Member 'FPlayerBlockData::BlockedPlayer' has a wrong offset!");
static_assert(offsetof(FPlayerBlockData, BlockStyle) == 0x000008, "Member 'FPlayerBlockData::BlockStyle' has a wrong offset!");

// ScriptStruct DeadByDaylight.BlockableReplicatedDatum
// 0x0020 (0x0020 - 0x0000)
struct FBlockableReplicatedDatum final
{
public:
	TArray<TWeakObjectPtr<class UObject>>         Sources;                                           // 0x0000(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<struct FPlayerBlockData>               BlockedPlayersData;                                // 0x0010(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBlockableReplicatedDatum) == 0x000008, "Wrong alignment on FBlockableReplicatedDatum");
static_assert(sizeof(FBlockableReplicatedDatum) == 0x000020, "Wrong size on FBlockableReplicatedDatum");
static_assert(offsetof(FBlockableReplicatedDatum, Sources) == 0x000000, "Member 'FBlockableReplicatedDatum::Sources' has a wrong offset!");
static_assert(offsetof(FBlockableReplicatedDatum, BlockedPlayersData) == 0x000010, "Member 'FBlockableReplicatedDatum::BlockedPlayersData' has a wrong offset!");

// ScriptStruct DeadByDaylight.CurrencyConversion
// 0x0050 (0x0050 - 0x0000)
struct FCurrencyConversion final
{
public:
	TMap<ECurrencyType, float>                    AmountInOtherCurrency;                             // 0x0000(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCurrencyConversion) == 0x000008, "Wrong alignment on FCurrencyConversion");
static_assert(sizeof(FCurrencyConversion) == 0x000050, "Wrong size on FCurrencyConversion");
static_assert(offsetof(FCurrencyConversion, AmountInOtherCurrency) == 0x000000, "Member 'FCurrencyConversion::AmountInOtherCurrency' has a wrong offset!");

// ScriptStruct DeadByDaylight.BloodstoreRowUnlockThreshold
// 0x0008 (0x0010 - 0x0008)
struct FBloodstoreRowUnlockThreshold final : public FDBDTableRowBase
{
public:
	int32                                         PreviousRowPurchasedItemsCount;                    // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBloodstoreRowUnlockThreshold) == 0x000008, "Wrong alignment on FBloodstoreRowUnlockThreshold");
static_assert(sizeof(FBloodstoreRowUnlockThreshold) == 0x000010, "Wrong size on FBloodstoreRowUnlockThreshold");
static_assert(offsetof(FBloodstoreRowUnlockThreshold, PreviousRowPurchasedItemsCount) == 0x000008, "Member 'FBloodstoreRowUnlockThreshold::PreviousRowPurchasedItemsCount' has a wrong offset!");

// ScriptStruct DeadByDaylight.BloodwebChest
// 0x0030 (0x0038 - 0x0008)
struct FBloodwebChest final : public FDBDTableRowBase
{
public:
	class FName                                   ID;                                                // 0x0008(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EventID;                                           // 0x0014(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGameType                                     GameType;                                          // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBloodchestType                               ChestType;                                         // 0x0021(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemRarity                                   Rarity;                                            // 0x0022(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23[0x5];                                       // 0x0023(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 GivenItemRarity;                                   // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBloodwebChest) == 0x000008, "Wrong alignment on FBloodwebChest");
static_assert(sizeof(FBloodwebChest) == 0x000038, "Wrong size on FBloodwebChest");
static_assert(offsetof(FBloodwebChest, ID) == 0x000008, "Member 'FBloodwebChest::ID' has a wrong offset!");
static_assert(offsetof(FBloodwebChest, EventID) == 0x000014, "Member 'FBloodwebChest::EventID' has a wrong offset!");
static_assert(offsetof(FBloodwebChest, GameType) == 0x000020, "Member 'FBloodwebChest::GameType' has a wrong offset!");
static_assert(offsetof(FBloodwebChest, ChestType) == 0x000021, "Member 'FBloodwebChest::ChestType' has a wrong offset!");
static_assert(offsetof(FBloodwebChest, Rarity) == 0x000022, "Member 'FBloodwebChest::Rarity' has a wrong offset!");
static_assert(offsetof(FBloodwebChest, GivenItemRarity) == 0x000028, "Member 'FBloodwebChest::GivenItemRarity' has a wrong offset!");

// ScriptStruct DeadByDaylight.BloodwebContentTypePerRingDistribution
// 0x0058 (0x0060 - 0x0008)
struct FBloodwebContentTypePerRingDistribution final : public FDBDTableRowBase
{
public:
	int32                                         PerkPerRingMinCount;                               // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PerkPerRingMaxCount;                               // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PerkPerRingWeight;                                 // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OfferingPerRingMinCount;                           // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OfferingPerRingMaxCount;                           // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OfferingPerRingWeight;                             // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemPerRingMinCount;                               // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemPerRingMaxCount;                               // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemPerRingWeight;                                 // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AddOnPerRingMinCount;                              // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AddOnPerRingMaxCount;                              // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AddOnPerRingWeight;                                // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ChestPerRingMinCount;                              // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ChestPerRingMaxCount;                              // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ChestPerRingWeight;                                // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PerksPackPerRingMinCount;                          // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PerksPackPerRingMaxCount;                          // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PerksPackPerRingWeight;                            // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IridiscentShardsPackPerRingMinCount;               // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IridiscentShardsPackPerRingMaxCount;               // 0x0054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IridiscentShardsPackPerRingWeight;                 // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBloodwebContentTypePerRingDistribution) == 0x000008, "Wrong alignment on FBloodwebContentTypePerRingDistribution");
static_assert(sizeof(FBloodwebContentTypePerRingDistribution) == 0x000060, "Wrong size on FBloodwebContentTypePerRingDistribution");
static_assert(offsetof(FBloodwebContentTypePerRingDistribution, PerkPerRingMinCount) == 0x000008, "Member 'FBloodwebContentTypePerRingDistribution::PerkPerRingMinCount' has a wrong offset!");
static_assert(offsetof(FBloodwebContentTypePerRingDistribution, PerkPerRingMaxCount) == 0x00000C, "Member 'FBloodwebContentTypePerRingDistribution::PerkPerRingMaxCount' has a wrong offset!");
static_assert(offsetof(FBloodwebContentTypePerRingDistribution, PerkPerRingWeight) == 0x000010, "Member 'FBloodwebContentTypePerRingDistribution::PerkPerRingWeight' has a wrong offset!");
static_assert(offsetof(FBloodwebContentTypePerRingDistribution, OfferingPerRingMinCount) == 0x000014, "Member 'FBloodwebContentTypePerRingDistribution::OfferingPerRingMinCount' has a wrong offset!");
static_assert(offsetof(FBloodwebContentTypePerRingDistribution, OfferingPerRingMaxCount) == 0x000018, "Member 'FBloodwebContentTypePerRingDistribution::OfferingPerRingMaxCount' has a wrong offset!");
static_assert(offsetof(FBloodwebContentTypePerRingDistribution, OfferingPerRingWeight) == 0x00001C, "Member 'FBloodwebContentTypePerRingDistribution::OfferingPerRingWeight' has a wrong offset!");
static_assert(offsetof(FBloodwebContentTypePerRingDistribution, ItemPerRingMinCount) == 0x000020, "Member 'FBloodwebContentTypePerRingDistribution::ItemPerRingMinCount' has a wrong offset!");
static_assert(offsetof(FBloodwebContentTypePerRingDistribution, ItemPerRingMaxCount) == 0x000024, "Member 'FBloodwebContentTypePerRingDistribution::ItemPerRingMaxCount' has a wrong offset!");
static_assert(offsetof(FBloodwebContentTypePerRingDistribution, ItemPerRingWeight) == 0x000028, "Member 'FBloodwebContentTypePerRingDistribution::ItemPerRingWeight' has a wrong offset!");
static_assert(offsetof(FBloodwebContentTypePerRingDistribution, AddOnPerRingMinCount) == 0x00002C, "Member 'FBloodwebContentTypePerRingDistribution::AddOnPerRingMinCount' has a wrong offset!");
static_assert(offsetof(FBloodwebContentTypePerRingDistribution, AddOnPerRingMaxCount) == 0x000030, "Member 'FBloodwebContentTypePerRingDistribution::AddOnPerRingMaxCount' has a wrong offset!");
static_assert(offsetof(FBloodwebContentTypePerRingDistribution, AddOnPerRingWeight) == 0x000034, "Member 'FBloodwebContentTypePerRingDistribution::AddOnPerRingWeight' has a wrong offset!");
static_assert(offsetof(FBloodwebContentTypePerRingDistribution, ChestPerRingMinCount) == 0x000038, "Member 'FBloodwebContentTypePerRingDistribution::ChestPerRingMinCount' has a wrong offset!");
static_assert(offsetof(FBloodwebContentTypePerRingDistribution, ChestPerRingMaxCount) == 0x00003C, "Member 'FBloodwebContentTypePerRingDistribution::ChestPerRingMaxCount' has a wrong offset!");
static_assert(offsetof(FBloodwebContentTypePerRingDistribution, ChestPerRingWeight) == 0x000040, "Member 'FBloodwebContentTypePerRingDistribution::ChestPerRingWeight' has a wrong offset!");
static_assert(offsetof(FBloodwebContentTypePerRingDistribution, PerksPackPerRingMinCount) == 0x000044, "Member 'FBloodwebContentTypePerRingDistribution::PerksPackPerRingMinCount' has a wrong offset!");
static_assert(offsetof(FBloodwebContentTypePerRingDistribution, PerksPackPerRingMaxCount) == 0x000048, "Member 'FBloodwebContentTypePerRingDistribution::PerksPackPerRingMaxCount' has a wrong offset!");
static_assert(offsetof(FBloodwebContentTypePerRingDistribution, PerksPackPerRingWeight) == 0x00004C, "Member 'FBloodwebContentTypePerRingDistribution::PerksPackPerRingWeight' has a wrong offset!");
static_assert(offsetof(FBloodwebContentTypePerRingDistribution, IridiscentShardsPackPerRingMinCount) == 0x000050, "Member 'FBloodwebContentTypePerRingDistribution::IridiscentShardsPackPerRingMinCount' has a wrong offset!");
static_assert(offsetof(FBloodwebContentTypePerRingDistribution, IridiscentShardsPackPerRingMaxCount) == 0x000054, "Member 'FBloodwebContentTypePerRingDistribution::IridiscentShardsPackPerRingMaxCount' has a wrong offset!");
static_assert(offsetof(FBloodwebContentTypePerRingDistribution, IridiscentShardsPackPerRingWeight) == 0x000058, "Member 'FBloodwebContentTypePerRingDistribution::IridiscentShardsPackPerRingWeight' has a wrong offset!");

// ScriptStruct DeadByDaylight.BloodwebCostModifier
// 0x0008 (0x0010 - 0x0008)
struct FBloodwebCostModifier final : public FDBDTableRowBase
{
public:
	EBloodwebNodeContentType                      Type;                                              // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CostModifier;                                      // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBloodwebCostModifier) == 0x000008, "Wrong alignment on FBloodwebCostModifier");
static_assert(sizeof(FBloodwebCostModifier) == 0x000010, "Wrong size on FBloodwebCostModifier");
static_assert(offsetof(FBloodwebCostModifier, Type) == 0x000008, "Member 'FBloodwebCostModifier::Type' has a wrong offset!");
static_assert(offsetof(FBloodwebCostModifier, CostModifier) == 0x00000C, "Member 'FBloodwebCostModifier::CostModifier' has a wrong offset!");

// ScriptStruct DeadByDaylight.BlockingNode
// 0x0018 (0x0018 - 0x0000)
struct FBlockingNode final
{
public:
	class FString                                 ID;                                                // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BlockingCount;                                     // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBlockingNode) == 0x000008, "Wrong alignment on FBlockingNode");
static_assert(sizeof(FBlockingNode) == 0x000018, "Wrong size on FBlockingNode");
static_assert(offsetof(FBlockingNode, ID) == 0x000000, "Member 'FBlockingNode::ID' has a wrong offset!");
static_assert(offsetof(FBlockingNode, BlockingCount) == 0x000010, "Member 'FBlockingNode::BlockingCount' has a wrong offset!");

// ScriptStruct DeadByDaylight.BloodwebRingComposition
// 0x0018 (0x0018 - 0x0000)
struct FBloodwebRingComposition final
{
public:
	int32                                         EntityStartingRound;                               // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 NodeCountPerRing;                                  // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBloodwebRingComposition) == 0x000008, "Wrong alignment on FBloodwebRingComposition");
static_assert(sizeof(FBloodwebRingComposition) == 0x000018, "Wrong size on FBloodwebRingComposition");
static_assert(offsetof(FBloodwebRingComposition, EntityStartingRound) == 0x000000, "Member 'FBloodwebRingComposition::EntityStartingRound' has a wrong offset!");
static_assert(offsetof(FBloodwebRingComposition, NodeCountPerRing) == 0x000008, "Member 'FBloodwebRingComposition::NodeCountPerRing' has a wrong offset!");

// ScriptStruct DeadByDaylight.CrossPromoPlatformSpecificContentRuntimeData
// 0x0088 (0x0088 - 0x0000)
struct FCrossPromoPlatformSpecificContentRuntimeData final
{
public:
	ECrossPromoMediaResourceLinkType              LinkType;                                          // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 LinkURI;                                           // 0x0008(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSoftObjectPath>                ImagesUri;                                         // 0x0018(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<struct FSoftObjectPath>                VideosUri;                                         // 0x0028(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        KeyArtImagePath;                                   // 0x0038(0x0028)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ButtonLabel;                                       // 0x0060(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 InstructionText;                                   // 0x0070(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_80[0x8];                                       // 0x0080(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCrossPromoPlatformSpecificContentRuntimeData) == 0x000008, "Wrong alignment on FCrossPromoPlatformSpecificContentRuntimeData");
static_assert(sizeof(FCrossPromoPlatformSpecificContentRuntimeData) == 0x000088, "Wrong size on FCrossPromoPlatformSpecificContentRuntimeData");
static_assert(offsetof(FCrossPromoPlatformSpecificContentRuntimeData, LinkType) == 0x000000, "Member 'FCrossPromoPlatformSpecificContentRuntimeData::LinkType' has a wrong offset!");
static_assert(offsetof(FCrossPromoPlatformSpecificContentRuntimeData, LinkURI) == 0x000008, "Member 'FCrossPromoPlatformSpecificContentRuntimeData::LinkURI' has a wrong offset!");
static_assert(offsetof(FCrossPromoPlatformSpecificContentRuntimeData, ImagesUri) == 0x000018, "Member 'FCrossPromoPlatformSpecificContentRuntimeData::ImagesUri' has a wrong offset!");
static_assert(offsetof(FCrossPromoPlatformSpecificContentRuntimeData, VideosUri) == 0x000028, "Member 'FCrossPromoPlatformSpecificContentRuntimeData::VideosUri' has a wrong offset!");
static_assert(offsetof(FCrossPromoPlatformSpecificContentRuntimeData, KeyArtImagePath) == 0x000038, "Member 'FCrossPromoPlatformSpecificContentRuntimeData::KeyArtImagePath' has a wrong offset!");
static_assert(offsetof(FCrossPromoPlatformSpecificContentRuntimeData, ButtonLabel) == 0x000060, "Member 'FCrossPromoPlatformSpecificContentRuntimeData::ButtonLabel' has a wrong offset!");
static_assert(offsetof(FCrossPromoPlatformSpecificContentRuntimeData, InstructionText) == 0x000070, "Member 'FCrossPromoPlatformSpecificContentRuntimeData::InstructionText' has a wrong offset!");

// ScriptStruct DeadByDaylight.CrossPromoSingleCampaignRuntimeData
// 0x0098 (0x0098 - 0x0000)
struct FCrossPromoSingleCampaignRuntimeData final
{
public:
	struct FDateTime                              ActiveFromDate;                                    // 0x0000(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              ActiveToDate;                                      // 0x0008(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Title;                                             // 0x0010(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Message;                                           // 0x0020(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        MaxViews;                                          // 0x0030(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DaysBetweenViews;                                  // 0x0034(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         SegmentationTags;                                  // 0x0038(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TMap<class FString, struct FCrossPromoPlatformSpecificContentRuntimeData> PlatformSpecificContent;                           // 0x0048(0x0050)(Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCrossPromoSingleCampaignRuntimeData) == 0x000008, "Wrong alignment on FCrossPromoSingleCampaignRuntimeData");
static_assert(sizeof(FCrossPromoSingleCampaignRuntimeData) == 0x000098, "Wrong size on FCrossPromoSingleCampaignRuntimeData");
static_assert(offsetof(FCrossPromoSingleCampaignRuntimeData, ActiveFromDate) == 0x000000, "Member 'FCrossPromoSingleCampaignRuntimeData::ActiveFromDate' has a wrong offset!");
static_assert(offsetof(FCrossPromoSingleCampaignRuntimeData, ActiveToDate) == 0x000008, "Member 'FCrossPromoSingleCampaignRuntimeData::ActiveToDate' has a wrong offset!");
static_assert(offsetof(FCrossPromoSingleCampaignRuntimeData, Title) == 0x000010, "Member 'FCrossPromoSingleCampaignRuntimeData::Title' has a wrong offset!");
static_assert(offsetof(FCrossPromoSingleCampaignRuntimeData, Message) == 0x000020, "Member 'FCrossPromoSingleCampaignRuntimeData::Message' has a wrong offset!");
static_assert(offsetof(FCrossPromoSingleCampaignRuntimeData, MaxViews) == 0x000030, "Member 'FCrossPromoSingleCampaignRuntimeData::MaxViews' has a wrong offset!");
static_assert(offsetof(FCrossPromoSingleCampaignRuntimeData, DaysBetweenViews) == 0x000034, "Member 'FCrossPromoSingleCampaignRuntimeData::DaysBetweenViews' has a wrong offset!");
static_assert(offsetof(FCrossPromoSingleCampaignRuntimeData, SegmentationTags) == 0x000038, "Member 'FCrossPromoSingleCampaignRuntimeData::SegmentationTags' has a wrong offset!");
static_assert(offsetof(FCrossPromoSingleCampaignRuntimeData, PlatformSpecificContent) == 0x000048, "Member 'FCrossPromoSingleCampaignRuntimeData::PlatformSpecificContent' has a wrong offset!");

// ScriptStruct DeadByDaylight.BloodwebRarityCost
// 0x0028 (0x0028 - 0x0000)
struct FBloodwebRarityCost final
{
public:
	int32                                         Artifact;                                          // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Common;                                            // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Legendary;                                         // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Rare;                                              // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SpecialEvent;                                      // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Spectral;                                          // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Teachable;                                         // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UltraRare;                                         // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Uncommon;                                          // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         VeryRare;                                          // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBloodwebRarityCost) == 0x000004, "Wrong alignment on FBloodwebRarityCost");
static_assert(sizeof(FBloodwebRarityCost) == 0x000028, "Wrong size on FBloodwebRarityCost");
static_assert(offsetof(FBloodwebRarityCost, Artifact) == 0x000000, "Member 'FBloodwebRarityCost::Artifact' has a wrong offset!");
static_assert(offsetof(FBloodwebRarityCost, Common) == 0x000004, "Member 'FBloodwebRarityCost::Common' has a wrong offset!");
static_assert(offsetof(FBloodwebRarityCost, Legendary) == 0x000008, "Member 'FBloodwebRarityCost::Legendary' has a wrong offset!");
static_assert(offsetof(FBloodwebRarityCost, Rare) == 0x00000C, "Member 'FBloodwebRarityCost::Rare' has a wrong offset!");
static_assert(offsetof(FBloodwebRarityCost, SpecialEvent) == 0x000010, "Member 'FBloodwebRarityCost::SpecialEvent' has a wrong offset!");
static_assert(offsetof(FBloodwebRarityCost, Spectral) == 0x000014, "Member 'FBloodwebRarityCost::Spectral' has a wrong offset!");
static_assert(offsetof(FBloodwebRarityCost, Teachable) == 0x000018, "Member 'FBloodwebRarityCost::Teachable' has a wrong offset!");
static_assert(offsetof(FBloodwebRarityCost, UltraRare) == 0x00001C, "Member 'FBloodwebRarityCost::UltraRare' has a wrong offset!");
static_assert(offsetof(FBloodwebRarityCost, Uncommon) == 0x000020, "Member 'FBloodwebRarityCost::Uncommon' has a wrong offset!");
static_assert(offsetof(FBloodwebRarityCost, VeryRare) == 0x000024, "Member 'FBloodwebRarityCost::VeryRare' has a wrong offset!");

// ScriptStruct DeadByDaylight.BloodwebTypeCostModifiers
// 0x0014 (0x0014 - 0x0000)
struct FBloodwebTypeCostModifiers final
{
public:
	float                                         Addon;                                             // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Chest;                                             // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Items;                                             // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Offerings;                                         // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Perks;                                             // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBloodwebTypeCostModifiers) == 0x000004, "Wrong alignment on FBloodwebTypeCostModifiers");
static_assert(sizeof(FBloodwebTypeCostModifiers) == 0x000014, "Wrong size on FBloodwebTypeCostModifiers");
static_assert(offsetof(FBloodwebTypeCostModifiers, Addon) == 0x000000, "Member 'FBloodwebTypeCostModifiers::Addon' has a wrong offset!");
static_assert(offsetof(FBloodwebTypeCostModifiers, Chest) == 0x000004, "Member 'FBloodwebTypeCostModifiers::Chest' has a wrong offset!");
static_assert(offsetof(FBloodwebTypeCostModifiers, Items) == 0x000008, "Member 'FBloodwebTypeCostModifiers::Items' has a wrong offset!");
static_assert(offsetof(FBloodwebTypeCostModifiers, Offerings) == 0x00000C, "Member 'FBloodwebTypeCostModifiers::Offerings' has a wrong offset!");
static_assert(offsetof(FBloodwebTypeCostModifiers, Perks) == 0x000010, "Member 'FBloodwebTypeCostModifiers::Perks' has a wrong offset!");

// ScriptStruct DeadByDaylight.CoreRitualsBackendData
// 0x0028 (0x0030 - 0x0008)
struct FCoreRitualsBackendData final : public FDBDTableRowBase
{
public:
	int32                                         DifficultyThreshold;                               // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DifficultyTolerance;                               // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DifficultyDisplayThreshold;                        // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERewardType                                   DifficultyRewardsType;                             // 0x0014(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DifficultyRewardsAmount;                           // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECurrencyType                                 DifficultyRewardsId;                               // 0x001C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 RitualId;                                          // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FCoreRitualsBackendData) == 0x000008, "Wrong alignment on FCoreRitualsBackendData");
static_assert(sizeof(FCoreRitualsBackendData) == 0x000030, "Wrong size on FCoreRitualsBackendData");
static_assert(offsetof(FCoreRitualsBackendData, DifficultyThreshold) == 0x000008, "Member 'FCoreRitualsBackendData::DifficultyThreshold' has a wrong offset!");
static_assert(offsetof(FCoreRitualsBackendData, DifficultyTolerance) == 0x00000C, "Member 'FCoreRitualsBackendData::DifficultyTolerance' has a wrong offset!");
static_assert(offsetof(FCoreRitualsBackendData, DifficultyDisplayThreshold) == 0x000010, "Member 'FCoreRitualsBackendData::DifficultyDisplayThreshold' has a wrong offset!");
static_assert(offsetof(FCoreRitualsBackendData, DifficultyRewardsType) == 0x000014, "Member 'FCoreRitualsBackendData::DifficultyRewardsType' has a wrong offset!");
static_assert(offsetof(FCoreRitualsBackendData, DifficultyRewardsAmount) == 0x000018, "Member 'FCoreRitualsBackendData::DifficultyRewardsAmount' has a wrong offset!");
static_assert(offsetof(FCoreRitualsBackendData, DifficultyRewardsId) == 0x00001C, "Member 'FCoreRitualsBackendData::DifficultyRewardsId' has a wrong offset!");
static_assert(offsetof(FCoreRitualsBackendData, RitualId) == 0x000020, "Member 'FCoreRitualsBackendData::RitualId' has a wrong offset!");

// ScriptStruct DeadByDaylight.BloodwebChestProbability
// 0x0020 (0x0020 - 0x0000)
struct FBloodwebChestProbability final
{
public:
	class FString                                 ID;                                                // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ChestRarity;                                       // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBloodwebChestProbability) == 0x000008, "Wrong alignment on FBloodwebChestProbability");
static_assert(sizeof(FBloodwebChestProbability) == 0x000020, "Wrong size on FBloodwebChestProbability");
static_assert(offsetof(FBloodwebChestProbability, ID) == 0x000000, "Member 'FBloodwebChestProbability::ID' has a wrong offset!");
static_assert(offsetof(FBloodwebChestProbability, ChestRarity) == 0x000010, "Member 'FBloodwebChestProbability::ChestRarity' has a wrong offset!");

// ScriptStruct DeadByDaylight.BloodwebEventChestProbability
// 0x0020 (0x0020 - 0x0000)
struct FBloodwebEventChestProbability final
{
public:
	class FString                                 EventID;                                           // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FBloodwebChestProbability>      Chests;                                            // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBloodwebEventChestProbability) == 0x000008, "Wrong alignment on FBloodwebEventChestProbability");
static_assert(sizeof(FBloodwebEventChestProbability) == 0x000020, "Wrong size on FBloodwebEventChestProbability");
static_assert(offsetof(FBloodwebEventChestProbability, EventID) == 0x000000, "Member 'FBloodwebEventChestProbability::EventID' has a wrong offset!");
static_assert(offsetof(FBloodwebEventChestProbability, Chests) == 0x000010, "Member 'FBloodwebEventChestProbability::Chests' has a wrong offset!");

// ScriptStruct DeadByDaylight.CurrencyUIData
// 0x0060 (0x0068 - 0x0008)
struct FCurrencyUIData final : public FDBDTableRowBase
{
public:
	ECurrencyType                                 CurrencyType;                                      // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Description;                                       // 0x0010(0x0018)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPublic)
	class FText                                   DisplayName;                                       // 0x0028(0x0018)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPublic)
	class FString                                 IconPath;                                          // 0x0040(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSlateColor                            CurrencyColorTheme;                                // 0x0050(0x0014)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCurrencyUIData) == 0x000008, "Wrong alignment on FCurrencyUIData");
static_assert(sizeof(FCurrencyUIData) == 0x000068, "Wrong size on FCurrencyUIData");
static_assert(offsetof(FCurrencyUIData, CurrencyType) == 0x000008, "Member 'FCurrencyUIData::CurrencyType' has a wrong offset!");
static_assert(offsetof(FCurrencyUIData, Description) == 0x000010, "Member 'FCurrencyUIData::Description' has a wrong offset!");
static_assert(offsetof(FCurrencyUIData, DisplayName) == 0x000028, "Member 'FCurrencyUIData::DisplayName' has a wrong offset!");
static_assert(offsetof(FCurrencyUIData, IconPath) == 0x000040, "Member 'FCurrencyUIData::IconPath' has a wrong offset!");
static_assert(offsetof(FCurrencyUIData, CurrencyColorTheme) == 0x000050, "Member 'FCurrencyUIData::CurrencyColorTheme' has a wrong offset!");

// ScriptStruct DeadByDaylight.BloodwebGenerationRulesData
// 0x0070 (0x0070 - 0x0000)
struct FBloodwebGenerationRulesData final
{
public:
	TArray<struct FBloodwebRingComposition>       RingComposition;                                   // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FBloodwebRarityCost                    RarityCost;                                        // 0x0010(0x0028)(NoDestructor, NativeAccessSpecifierPublic)
	struct FBloodwebTypeCostModifiers             TypeCostModifiers;                                 // 0x0038(0x0014)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBloodwebChestProbability>      ChestProbability;                                  // 0x0050(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FBloodwebEventChestProbability> EventChestProbability;                             // 0x0060(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBloodwebGenerationRulesData) == 0x000008, "Wrong alignment on FBloodwebGenerationRulesData");
static_assert(sizeof(FBloodwebGenerationRulesData) == 0x000070, "Wrong size on FBloodwebGenerationRulesData");
static_assert(offsetof(FBloodwebGenerationRulesData, RingComposition) == 0x000000, "Member 'FBloodwebGenerationRulesData::RingComposition' has a wrong offset!");
static_assert(offsetof(FBloodwebGenerationRulesData, RarityCost) == 0x000010, "Member 'FBloodwebGenerationRulesData::RarityCost' has a wrong offset!");
static_assert(offsetof(FBloodwebGenerationRulesData, TypeCostModifiers) == 0x000038, "Member 'FBloodwebGenerationRulesData::TypeCostModifiers' has a wrong offset!");
static_assert(offsetof(FBloodwebGenerationRulesData, ChestProbability) == 0x000050, "Member 'FBloodwebGenerationRulesData::ChestProbability' has a wrong offset!");
static_assert(offsetof(FBloodwebGenerationRulesData, EventChestProbability) == 0x000060, "Member 'FBloodwebGenerationRulesData::EventChestProbability' has a wrong offset!");

// ScriptStruct DeadByDaylight.BloodwebMandatoryContentByLevel
// 0x0028 (0x0030 - 0x0008)
struct FBloodwebMandatoryContentByLevel final : public FDBDTableRowBase
{
public:
	int32                                         Level;                                             // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ForcedItem01;                                      // 0x000C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ForcedItem02;                                      // 0x0018(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ForcedItem03;                                      // 0x0024(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBloodwebMandatoryContentByLevel) == 0x000008, "Wrong alignment on FBloodwebMandatoryContentByLevel");
static_assert(sizeof(FBloodwebMandatoryContentByLevel) == 0x000030, "Wrong size on FBloodwebMandatoryContentByLevel");
static_assert(offsetof(FBloodwebMandatoryContentByLevel, Level) == 0x000008, "Member 'FBloodwebMandatoryContentByLevel::Level' has a wrong offset!");
static_assert(offsetof(FBloodwebMandatoryContentByLevel, ForcedItem01) == 0x00000C, "Member 'FBloodwebMandatoryContentByLevel::ForcedItem01' has a wrong offset!");
static_assert(offsetof(FBloodwebMandatoryContentByLevel, ForcedItem02) == 0x000018, "Member 'FBloodwebMandatoryContentByLevel::ForcedItem02' has a wrong offset!");
static_assert(offsetof(FBloodwebMandatoryContentByLevel, ForcedItem03) == 0x000024, "Member 'FBloodwebMandatoryContentByLevel::ForcedItem03' has a wrong offset!");

// ScriptStruct DeadByDaylight.AccessNode
// 0x0018 (0x0018 - 0x0000)
struct FAccessNode final
{
public:
	class FString                                 ID;                                                // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AccessCost;                                        // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAccessNode) == 0x000008, "Wrong alignment on FAccessNode");
static_assert(sizeof(FAccessNode) == 0x000018, "Wrong size on FAccessNode");
static_assert(offsetof(FAccessNode, ID) == 0x000000, "Member 'FAccessNode::ID' has a wrong offset!");
static_assert(offsetof(FAccessNode, AccessCost) == 0x000010, "Member 'FAccessNode::AccessCost' has a wrong offset!");

// ScriptStruct DeadByDaylight.BloodwebNodeProperties
// 0x0020 (0x0020 - 0x0000)
struct FBloodwebNodeProperties final
{
public:
	EBloodwebNodeContentType                      ContentType;                                       // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemRarity                                   Rarity;                                            // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         Tags;                                              // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         CharacterId;                                       // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBloodwebNodeProperties) == 0x000008, "Wrong alignment on FBloodwebNodeProperties");
static_assert(sizeof(FBloodwebNodeProperties) == 0x000020, "Wrong size on FBloodwebNodeProperties");
static_assert(offsetof(FBloodwebNodeProperties, ContentType) == 0x000000, "Member 'FBloodwebNodeProperties::ContentType' has a wrong offset!");
static_assert(offsetof(FBloodwebNodeProperties, Rarity) == 0x000001, "Member 'FBloodwebNodeProperties::Rarity' has a wrong offset!");
static_assert(offsetof(FBloodwebNodeProperties, Tags) == 0x000008, "Member 'FBloodwebNodeProperties::Tags' has a wrong offset!");
static_assert(offsetof(FBloodwebNodeProperties, CharacterId) == 0x000018, "Member 'FBloodwebNodeProperties::CharacterId' has a wrong offset!");

// ScriptStruct DeadByDaylight.CustomizationDuplication
// 0x0018 (0x0018 - 0x0000)
struct FCustomizationDuplication final
{
public:
	class FName                                   OriginalId;                                        // 0x0000(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DuplicatedId;                                      // 0x000C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCustomizationDuplication) == 0x000004, "Wrong alignment on FCustomizationDuplication");
static_assert(sizeof(FCustomizationDuplication) == 0x000018, "Wrong size on FCustomizationDuplication");
static_assert(offsetof(FCustomizationDuplication, OriginalId) == 0x000000, "Member 'FCustomizationDuplication::OriginalId' has a wrong offset!");
static_assert(offsetof(FCustomizationDuplication, DuplicatedId) == 0x00000C, "Member 'FCustomizationDuplication::DuplicatedId' has a wrong offset!");

// ScriptStruct DeadByDaylight.CustomizationDuplicationDB
// 0x0020 (0x0028 - 0x0008)
struct FCustomizationDuplicationDB final : public FDBDTableRowBase
{
public:
	TArray<struct FCustomizationDuplication>      CustomizationDuplications;                         // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCustomizationDuplication>      OutfitDuplications;                                // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCustomizationDuplicationDB) == 0x000008, "Wrong alignment on FCustomizationDuplicationDB");
static_assert(sizeof(FCustomizationDuplicationDB) == 0x000028, "Wrong size on FCustomizationDuplicationDB");
static_assert(offsetof(FCustomizationDuplicationDB, CustomizationDuplications) == 0x000008, "Member 'FCustomizationDuplicationDB::CustomizationDuplications' has a wrong offset!");
static_assert(offsetof(FCustomizationDuplicationDB, OutfitDuplications) == 0x000018, "Member 'FCustomizationDuplicationDB::OutfitDuplications' has a wrong offset!");

// ScriptStruct DeadByDaylight.BloodwebNodeGate
// 0x0000 (0x0008 - 0x0008)
struct FBloodwebNodeGate final : public FDBDTableRowBase
{
};
static_assert(alignof(FBloodwebNodeGate) == 0x000008, "Wrong alignment on FBloodwebNodeGate");
static_assert(sizeof(FBloodwebNodeGate) == 0x000008, "Wrong size on FBloodwebNodeGate");

// ScriptStruct DeadByDaylight.RarityPerRingDistribution
// 0x0030 (0x0030 - 0x0000)
struct FRarityPerRingDistribution final
{
public:
	TArray<int32>                                 WeightList;                                        // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 MinCountList;                                      // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 MaxCountList;                                      // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRarityPerRingDistribution) == 0x000008, "Wrong alignment on FRarityPerRingDistribution");
static_assert(sizeof(FRarityPerRingDistribution) == 0x000030, "Wrong size on FRarityPerRingDistribution");
static_assert(offsetof(FRarityPerRingDistribution, WeightList) == 0x000000, "Member 'FRarityPerRingDistribution::WeightList' has a wrong offset!");
static_assert(offsetof(FRarityPerRingDistribution, MinCountList) == 0x000010, "Member 'FRarityPerRingDistribution::MinCountList' has a wrong offset!");
static_assert(offsetof(FRarityPerRingDistribution, MaxCountList) == 0x000020, "Member 'FRarityPerRingDistribution::MaxCountList' has a wrong offset!");

// ScriptStruct DeadByDaylight.CurrencyPackData
// 0x0008 (0x02A8 - 0x02A0)
struct FCurrencyPackData final : public FItemData
{
public:
	ECurrencyType                                 CurrencyType;                                      // 0x02A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A1[0x7];                                      // 0x02A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCurrencyPackData) == 0x000008, "Wrong alignment on FCurrencyPackData");
static_assert(sizeof(FCurrencyPackData) == 0x0002A8, "Wrong size on FCurrencyPackData");
static_assert(offsetof(FCurrencyPackData, CurrencyType) == 0x0002A0, "Member 'FCurrencyPackData::CurrencyType' has a wrong offset!");

// ScriptStruct DeadByDaylight.RarityPerWebDistribution
// 0x000C (0x000C - 0x0000)
struct FRarityPerWebDistribution final
{
public:
	int32                                         Weight;                                            // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinCount;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxCount;                                          // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRarityPerWebDistribution) == 0x000004, "Wrong alignment on FRarityPerWebDistribution");
static_assert(sizeof(FRarityPerWebDistribution) == 0x00000C, "Wrong size on FRarityPerWebDistribution");
static_assert(offsetof(FRarityPerWebDistribution, Weight) == 0x000000, "Member 'FRarityPerWebDistribution::Weight' has a wrong offset!");
static_assert(offsetof(FRarityPerWebDistribution, MinCount) == 0x000004, "Member 'FRarityPerWebDistribution::MinCount' has a wrong offset!");
static_assert(offsetof(FRarityPerWebDistribution, MaxCount) == 0x000008, "Member 'FRarityPerWebDistribution::MaxCount' has a wrong offset!");

// ScriptStruct DeadByDaylight.ContentPerRingDistribution
// 0x0030 (0x0030 - 0x0000)
struct FContentPerRingDistribution final
{
public:
	TArray<int32>                                 WeightList;                                        // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 MinCountList;                                      // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 MaxCountList;                                      // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FContentPerRingDistribution) == 0x000008, "Wrong alignment on FContentPerRingDistribution");
static_assert(sizeof(FContentPerRingDistribution) == 0x000030, "Wrong size on FContentPerRingDistribution");
static_assert(offsetof(FContentPerRingDistribution, WeightList) == 0x000000, "Member 'FContentPerRingDistribution::WeightList' has a wrong offset!");
static_assert(offsetof(FContentPerRingDistribution, MinCountList) == 0x000010, "Member 'FContentPerRingDistribution::MinCountList' has a wrong offset!");
static_assert(offsetof(FContentPerRingDistribution, MaxCountList) == 0x000020, "Member 'FContentPerRingDistribution::MaxCountList' has a wrong offset!");

// ScriptStruct DeadByDaylight.ContentPerWebDistribution
// 0x0010 (0x0010 - 0x0000)
struct FContentPerWebDistribution final
{
public:
	int32                                         CumulativeWeight;                                  // 0x0000(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Weight;                                            // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinCount;                                          // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxCount;                                          // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FContentPerWebDistribution) == 0x000004, "Wrong alignment on FContentPerWebDistribution");
static_assert(sizeof(FContentPerWebDistribution) == 0x000010, "Wrong size on FContentPerWebDistribution");
static_assert(offsetof(FContentPerWebDistribution, CumulativeWeight) == 0x000000, "Member 'FContentPerWebDistribution::CumulativeWeight' has a wrong offset!");
static_assert(offsetof(FContentPerWebDistribution, Weight) == 0x000004, "Member 'FContentPerWebDistribution::Weight' has a wrong offset!");
static_assert(offsetof(FContentPerWebDistribution, MinCount) == 0x000008, "Member 'FContentPerWebDistribution::MinCount' has a wrong offset!");
static_assert(offsetof(FContentPerWebDistribution, MaxCount) == 0x00000C, "Member 'FContentPerWebDistribution::MaxCount' has a wrong offset!");

// ScriptStruct DeadByDaylight.BloodwebNode
// 0x0090 (0x0090 - 0x0000)
struct FBloodwebNode final
{
public:
	struct FBloodwebNodeProperties                Properties;                                        // 0x0000(0x0020)(NativeAccessSpecifierPublic)
	TArray<struct FBloodwebNodeGate>              Gates;                                             // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	EBloodwebNodeState                            State;                                             // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 NodeId;                                            // 0x0038(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ContentId;                                         // 0x0048(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBloodwebChest                         BloodwebChest;                                     // 0x0058(0x0038)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FBloodwebNode) == 0x000008, "Wrong alignment on FBloodwebNode");
static_assert(sizeof(FBloodwebNode) == 0x000090, "Wrong size on FBloodwebNode");
static_assert(offsetof(FBloodwebNode, Properties) == 0x000000, "Member 'FBloodwebNode::Properties' has a wrong offset!");
static_assert(offsetof(FBloodwebNode, Gates) == 0x000020, "Member 'FBloodwebNode::Gates' has a wrong offset!");
static_assert(offsetof(FBloodwebNode, State) == 0x000030, "Member 'FBloodwebNode::State' has a wrong offset!");
static_assert(offsetof(FBloodwebNode, NodeId) == 0x000038, "Member 'FBloodwebNode::NodeId' has a wrong offset!");
static_assert(offsetof(FBloodwebNode, ContentId) == 0x000048, "Member 'FBloodwebNode::ContentId' has a wrong offset!");
static_assert(offsetof(FBloodwebNode, BloodwebChest) == 0x000058, "Member 'FBloodwebNode::BloodwebChest' has a wrong offset!");

// ScriptStruct DeadByDaylight.DailyRewardData
// 0x0040 (0x0040 - 0x0000)
struct FDailyRewardData final
{
public:
	EAtlantaRewardType                            RewardType;                                        // 0x0000(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CurrencyAmount;                                    // 0x0004(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 IconPath;                                          // 0x0008(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ParentIconPath;                                    // 0x0018(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ItemName;                                          // 0x0028(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Index;                                             // 0x0038(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsMarkedSpecial;                                   // 0x003C(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemRarity                                   ItemRarity;                                        // 0x003D(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EUMGDailyRewardWidgetState                    State;                                             // 0x003E(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3F[0x1];                                       // 0x003F(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDailyRewardData) == 0x000008, "Wrong alignment on FDailyRewardData");
static_assert(sizeof(FDailyRewardData) == 0x000040, "Wrong size on FDailyRewardData");
static_assert(offsetof(FDailyRewardData, RewardType) == 0x000000, "Member 'FDailyRewardData::RewardType' has a wrong offset!");
static_assert(offsetof(FDailyRewardData, CurrencyAmount) == 0x000004, "Member 'FDailyRewardData::CurrencyAmount' has a wrong offset!");
static_assert(offsetof(FDailyRewardData, IconPath) == 0x000008, "Member 'FDailyRewardData::IconPath' has a wrong offset!");
static_assert(offsetof(FDailyRewardData, ParentIconPath) == 0x000018, "Member 'FDailyRewardData::ParentIconPath' has a wrong offset!");
static_assert(offsetof(FDailyRewardData, ItemName) == 0x000028, "Member 'FDailyRewardData::ItemName' has a wrong offset!");
static_assert(offsetof(FDailyRewardData, Index) == 0x000038, "Member 'FDailyRewardData::Index' has a wrong offset!");
static_assert(offsetof(FDailyRewardData, IsMarkedSpecial) == 0x00003C, "Member 'FDailyRewardData::IsMarkedSpecial' has a wrong offset!");
static_assert(offsetof(FDailyRewardData, ItemRarity) == 0x00003D, "Member 'FDailyRewardData::ItemRarity' has a wrong offset!");
static_assert(offsetof(FDailyRewardData, State) == 0x00003E, "Member 'FDailyRewardData::State' has a wrong offset!");

// ScriptStruct DeadByDaylight.BloodwebNodeCost
// 0x0008 (0x0010 - 0x0008)
struct FBloodwebNodeCost final : public FDBDTableRowBase
{
public:
	EItemRarity                                   Rarity;                                            // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Cost;                                              // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBloodwebNodeCost) == 0x000008, "Wrong alignment on FBloodwebNodeCost");
static_assert(sizeof(FBloodwebNodeCost) == 0x000010, "Wrong size on FBloodwebNodeCost");
static_assert(offsetof(FBloodwebNodeCost, Rarity) == 0x000008, "Member 'FBloodwebNodeCost::Rarity' has a wrong offset!");
static_assert(offsetof(FBloodwebNodeCost, Cost) == 0x00000C, "Member 'FBloodwebNodeCost::Cost' has a wrong offset!");

// ScriptStruct DeadByDaylight.BloodwebNodeRarityCost
// 0x0008 (0x0010 - 0x0008)
struct FBloodwebNodeRarityCost final : public FDBDTableRowBase
{
public:
	EItemRarity                                   Rarity;                                            // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Cost;                                              // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBloodwebNodeRarityCost) == 0x000008, "Wrong alignment on FBloodwebNodeRarityCost");
static_assert(sizeof(FBloodwebNodeRarityCost) == 0x000010, "Wrong size on FBloodwebNodeRarityCost");
static_assert(offsetof(FBloodwebNodeRarityCost, Rarity) == 0x000008, "Member 'FBloodwebNodeRarityCost::Rarity' has a wrong offset!");
static_assert(offsetof(FBloodwebNodeRarityCost, Cost) == 0x00000C, "Member 'FBloodwebNodeRarityCost::Cost' has a wrong offset!");

// ScriptStruct DeadByDaylight.TutorialObjective
// 0x0020 (0x0028 - 0x0008)
struct FTutorialObjective final : public FDBDTableRowBase
{
public:
	class FText                                   Description;                                       // 0x0008(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          IsCompletionAnalyticEnabled;                       // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInteractionPromptType                        InteractionPromptType;                             // 0x0021(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETutorialObjectivePlayerActionMapping         PlayerAction;                                      // 0x0022(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInteractionPromptType                        SecondaryInteractionPromptType;                    // 0x0023(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETutorialObjectivePlayerActionMapping         SecondaryPlayerAction;                             // 0x0024(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTutorialObjective) == 0x000008, "Wrong alignment on FTutorialObjective");
static_assert(sizeof(FTutorialObjective) == 0x000028, "Wrong size on FTutorialObjective");
static_assert(offsetof(FTutorialObjective, Description) == 0x000008, "Member 'FTutorialObjective::Description' has a wrong offset!");
static_assert(offsetof(FTutorialObjective, IsCompletionAnalyticEnabled) == 0x000020, "Member 'FTutorialObjective::IsCompletionAnalyticEnabled' has a wrong offset!");
static_assert(offsetof(FTutorialObjective, InteractionPromptType) == 0x000021, "Member 'FTutorialObjective::InteractionPromptType' has a wrong offset!");
static_assert(offsetof(FTutorialObjective, PlayerAction) == 0x000022, "Member 'FTutorialObjective::PlayerAction' has a wrong offset!");
static_assert(offsetof(FTutorialObjective, SecondaryInteractionPromptType) == 0x000023, "Member 'FTutorialObjective::SecondaryInteractionPromptType' has a wrong offset!");
static_assert(offsetof(FTutorialObjective, SecondaryPlayerAction) == 0x000024, "Member 'FTutorialObjective::SecondaryPlayerAction' has a wrong offset!");

// ScriptStruct DeadByDaylight.BloodWebRingPersistentData
// 0x0010 (0x0010 - 0x0000)
struct FBloodWebRingPersistentData final
{
public:
	TArray<struct FBloodwebNode>                  NodeData;                                          // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBloodWebRingPersistentData) == 0x000008, "Wrong alignment on FBloodWebRingPersistentData");
static_assert(sizeof(FBloodWebRingPersistentData) == 0x000010, "Wrong size on FBloodWebRingPersistentData");
static_assert(offsetof(FBloodWebRingPersistentData, NodeData) == 0x000000, "Member 'FBloodWebRingPersistentData::NodeData' has a wrong offset!");

// ScriptStruct DeadByDaylight.BloodWebPersistentData
// 0x0050 (0x0050 - 0x0000)
struct FBloodWebPersistentData final
{
public:
	int32                                         VersionNumber;                                     // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FBloodWebRingPersistentData>    RingData;                                          // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           Paths;                                             // 0x0018(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 EntityCurrentNode;                                 // 0x0028(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              GenerationDate;                                    // 0x0038(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Seed;                                              // 0x0040(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBloodWebPersistentData) == 0x000008, "Wrong alignment on FBloodWebPersistentData");
static_assert(sizeof(FBloodWebPersistentData) == 0x000050, "Wrong size on FBloodWebPersistentData");
static_assert(offsetof(FBloodWebPersistentData, VersionNumber) == 0x000000, "Member 'FBloodWebPersistentData::VersionNumber' has a wrong offset!");
static_assert(offsetof(FBloodWebPersistentData, Level) == 0x000004, "Member 'FBloodWebPersistentData::Level' has a wrong offset!");
static_assert(offsetof(FBloodWebPersistentData, RingData) == 0x000008, "Member 'FBloodWebPersistentData::RingData' has a wrong offset!");
static_assert(offsetof(FBloodWebPersistentData, Paths) == 0x000018, "Member 'FBloodWebPersistentData::Paths' has a wrong offset!");
static_assert(offsetof(FBloodWebPersistentData, EntityCurrentNode) == 0x000028, "Member 'FBloodWebPersistentData::EntityCurrentNode' has a wrong offset!");
static_assert(offsetof(FBloodWebPersistentData, GenerationDate) == 0x000038, "Member 'FBloodWebPersistentData::GenerationDate' has a wrong offset!");
static_assert(offsetof(FBloodWebPersistentData, Seed) == 0x000040, "Member 'FBloodWebPersistentData::Seed' has a wrong offset!");

// ScriptStruct DeadByDaylight.BloodwebPrestigeModifiers
// 0x0020 (0x0028 - 0x0008)
struct FBloodwebPrestigeModifiers final : public FDBDTableRowBase
{
public:
	float                                         CommonItemProbabilityModifier;                     // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UncommonItemProbabilityModifier;                   // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RareItemProbabilityModifier;                       // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VeryRareItemProbabilityModifier;                   // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UltraRareItemProbabilityModifier;                  // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArtifactItemProbabilityModifier;                   // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpectralItemProbabilityModifier;                   // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LegendaryItemProbabilityModifier;                  // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBloodwebPrestigeModifiers) == 0x000008, "Wrong alignment on FBloodwebPrestigeModifiers");
static_assert(sizeof(FBloodwebPrestigeModifiers) == 0x000028, "Wrong size on FBloodwebPrestigeModifiers");
static_assert(offsetof(FBloodwebPrestigeModifiers, CommonItemProbabilityModifier) == 0x000008, "Member 'FBloodwebPrestigeModifiers::CommonItemProbabilityModifier' has a wrong offset!");
static_assert(offsetof(FBloodwebPrestigeModifiers, UncommonItemProbabilityModifier) == 0x00000C, "Member 'FBloodwebPrestigeModifiers::UncommonItemProbabilityModifier' has a wrong offset!");
static_assert(offsetof(FBloodwebPrestigeModifiers, RareItemProbabilityModifier) == 0x000010, "Member 'FBloodwebPrestigeModifiers::RareItemProbabilityModifier' has a wrong offset!");
static_assert(offsetof(FBloodwebPrestigeModifiers, VeryRareItemProbabilityModifier) == 0x000014, "Member 'FBloodwebPrestigeModifiers::VeryRareItemProbabilityModifier' has a wrong offset!");
static_assert(offsetof(FBloodwebPrestigeModifiers, UltraRareItemProbabilityModifier) == 0x000018, "Member 'FBloodwebPrestigeModifiers::UltraRareItemProbabilityModifier' has a wrong offset!");
static_assert(offsetof(FBloodwebPrestigeModifiers, ArtifactItemProbabilityModifier) == 0x00001C, "Member 'FBloodwebPrestigeModifiers::ArtifactItemProbabilityModifier' has a wrong offset!");
static_assert(offsetof(FBloodwebPrestigeModifiers, SpectralItemProbabilityModifier) == 0x000020, "Member 'FBloodwebPrestigeModifiers::SpectralItemProbabilityModifier' has a wrong offset!");
static_assert(offsetof(FBloodwebPrestigeModifiers, LegendaryItemProbabilityModifier) == 0x000024, "Member 'FBloodwebPrestigeModifiers::LegendaryItemProbabilityModifier' has a wrong offset!");

// ScriptStruct DeadByDaylight.BloodwebProgressionValue
// 0x00E8 (0x00F0 - 0x0008)
struct FBloodwebProgressionValue final : public FDBDTableRowBase
{
public:
	int32                                         InnerRingNodeCount;                                // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MiddleRingNodeCount;                               // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OuterRingNodeCount;                                // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Common_MinCount;                                   // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Common_MaxCount;                                   // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Uncommon_MinCount;                                 // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Uncommon_MaxCount;                                 // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Rare_MinCount;                                     // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Rare_MaxCount;                                     // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         VeryRare_MinCount;                                 // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         VeryRare_MaxCount;                                 // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UltraRare_MinCount;                                // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UltraRare_MaxCount;                                // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Artifact_MinCount;                                 // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Artifact_MaxCount;                                 // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Spectral_MinCount;                                 // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Spectral_MaxCount;                                 // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SpecialEvent_MinCount;                             // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SpecialEvent_MaxCount;                             // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Legendary_MinCount;                                // 0x0054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Legendary_MaxCount;                                // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InnerRingCommonItemProbability;                    // 0x005C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MiddleRingCommonItemProbability;                   // 0x0060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OuterRingCommonItemProbability;                    // 0x0064(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InnerRingUncommonItemProbability;                  // 0x0068(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MiddleRingUncommonItemProbability;                 // 0x006C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OuterRingUncommonItemProbability;                  // 0x0070(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InnerRingRareItemProbability;                      // 0x0074(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MiddleRingRareItemProbability;                     // 0x0078(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OuterRingRareItemProbability;                      // 0x007C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InnerRingVeryRareItemProbability;                  // 0x0080(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MiddleRingVeryRareItemProbability;                 // 0x0084(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OuterRingVeryRareItemProbability;                  // 0x0088(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InnerRingUltraRareItemProbability;                 // 0x008C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MiddleRingUltraRareItemProbability;                // 0x0090(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OuterRingUltraRareItemProbability;                 // 0x0094(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InnerRingArtifactItemProbability;                  // 0x0098(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MiddleRingArtifactItemProbability;                 // 0x009C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OuterRingArtifactItemProbability;                  // 0x00A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InnerRingSpectralItemProbability;                  // 0x00A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MiddleRingSpectralItemProbability;                 // 0x00A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OuterRingSpectralItemProbability;                  // 0x00AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InnerRingSpecialEventItemProbability;              // 0x00B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MiddleRingSpecialEventItemProbability;             // 0x00B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OuterRingSpecialEventItemProbability;              // 0x00B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InnerRingLegendaryItemProbability;                 // 0x00BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MiddleRingLegendaryItemProbability;                // 0x00C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OuterRingLegendaryItemProbability;                 // 0x00C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InnerRingEpicItemProbability;                      // 0x00C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MiddleRingEpicItemProbability;                     // 0x00CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OuterRingEpicItemProbability;                      // 0x00D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InnerRingSuperEpicItemProbability;                 // 0x00D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MiddleRingSuperEpicItemProbability;                // 0x00D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OuterRingSuperEpicItemProbability;                 // 0x00DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InnerRingUltraEpicItemProbability;                 // 0x00E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MiddleRingUltraEpicItemProbability;                // 0x00E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OuterRingUltraEpicItemProbability;                 // 0x00E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EntityStartingRound;                               // 0x00EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBloodwebProgressionValue) == 0x000008, "Wrong alignment on FBloodwebProgressionValue");
static_assert(sizeof(FBloodwebProgressionValue) == 0x0000F0, "Wrong size on FBloodwebProgressionValue");
static_assert(offsetof(FBloodwebProgressionValue, InnerRingNodeCount) == 0x000008, "Member 'FBloodwebProgressionValue::InnerRingNodeCount' has a wrong offset!");
static_assert(offsetof(FBloodwebProgressionValue, MiddleRingNodeCount) == 0x00000C, "Member 'FBloodwebProgressionValue::MiddleRingNodeCount' has a wrong offset!");
static_assert(offsetof(FBloodwebProgressionValue, OuterRingNodeCount) == 0x000010, "Member 'FBloodwebProgressionValue::OuterRingNodeCount' has a wrong offset!");
static_assert(offsetof(FBloodwebProgressionValue, Common_MinCount) == 0x000014, "Member 'FBloodwebProgressionValue::Common_MinCount' has a wrong offset!");
static_assert(offsetof(FBloodwebProgressionValue, Common_MaxCount) == 0x000018, "Member 'FBloodwebProgressionValue::Common_MaxCount' has a wrong offset!");
static_assert(offsetof(FBloodwebProgressionValue, Uncommon_MinCount) == 0x00001C, "Member 'FBloodwebProgressionValue::Uncommon_MinCount' has a wrong offset!");
static_assert(offsetof(FBloodwebProgressionValue, Uncommon_MaxCount) == 0x000020, "Member 'FBloodwebProgressionValue::Uncommon_MaxCount' has a wrong offset!");
static_assert(offsetof(FBloodwebProgressionValue, Rare_MinCount) == 0x000024, "Member 'FBloodwebProgressionValue::Rare_MinCount' has a wrong offset!");
static_assert(offsetof(FBloodwebProgressionValue, Rare_MaxCount) == 0x000028, "Member 'FBloodwebProgressionValue::Rare_MaxCount' has a wrong offset!");
static_assert(offsetof(FBloodwebProgressionValue, VeryRare_MinCount) == 0x00002C, "Member 'FBloodwebProgressionValue::VeryRare_MinCount' has a wrong offset!");
static_assert(offsetof(FBloodwebProgressionValue, VeryRare_MaxCount) == 0x000030, "Member 'FBloodwebProgressionValue::VeryRare_MaxCount' has a wrong offset!");
static_assert(offsetof(FBloodwebProgressionValue, UltraRare_MinCount) == 0x000034, "Member 'FBloodwebProgressionValue::UltraRare_MinCount' has a wrong offset!");
static_assert(offsetof(FBloodwebProgressionValue, UltraRare_MaxCount) == 0x000038, "Member 'FBloodwebProgressionValue::UltraRare_MaxCount' has a wrong offset!");
static_assert(offsetof(FBloodwebProgressionValue, Artifact_MinCount) == 0x00003C, "Member 'FBloodwebProgressionValue::Artifact_MinCount' has a wrong offset!");
static_assert(offsetof(FBloodwebProgressionValue, Artifact_MaxCount) == 0x000040, "Member 'FBloodwebProgressionValue::Artifact_MaxCount' has a wrong offset!");
static_assert(offsetof(FBloodwebProgressionValue, Spectral_MinCount) == 0x000044, "Member 'FBloodwebProgressionValue::Spectral_MinCount' has a wrong offset!");
static_assert(offsetof(FBloodwebProgressionValue, Spectral_MaxCount) == 0x000048, "Member 'FBloodwebProgressionValue::Spectral_MaxCount' has a wrong offset!");
static_assert(offsetof(FBloodwebProgressionValue, SpecialEvent_MinCount) == 0x00004C, "Member 'FBloodwebProgressionValue::SpecialEvent_MinCount' has a wrong offset!");
static_assert(offsetof(FBloodwebProgressionValue, SpecialEvent_MaxCount) == 0x000050, "Member 'FBloodwebProgressionValue::SpecialEvent_MaxCount' has a wrong offset!");
static_assert(offsetof(FBloodwebProgressionValue, Legendary_MinCount) == 0x000054, "Member 'FBloodwebProgressionValue::Legendary_MinCount' has a wrong offset!");
static_assert(offsetof(FBloodwebProgressionValue, Legendary_MaxCount) == 0x000058, "Member 'FBloodwebProgressionValue::Legendary_MaxCount' has a wrong offset!");
static_assert(offsetof(FBloodwebProgressionValue, InnerRingCommonItemProbability) == 0x00005C, "Member 'FBloodwebProgressionValue::InnerRingCommonItemProbability' has a wrong offset!");
static_assert(offsetof(FBloodwebProgressionValue, MiddleRingCommonItemProbability) == 0x000060, "Member 'FBloodwebProgressionValue::MiddleRingCommonItemProbability' has a wrong offset!");
static_assert(offsetof(FBloodwebProgressionValue, OuterRingCommonItemProbability) == 0x000064, "Member 'FBloodwebProgressionValue::OuterRingCommonItemProbability' has a wrong offset!");
static_assert(offsetof(FBloodwebProgressionValue, InnerRingUncommonItemProbability) == 0x000068, "Member 'FBloodwebProgressionValue::InnerRingUncommonItemProbability' has a wrong offset!");
static_assert(offsetof(FBloodwebProgressionValue, MiddleRingUncommonItemProbability) == 0x00006C, "Member 'FBloodwebProgressionValue::MiddleRingUncommonItemProbability' has a wrong offset!");
static_assert(offsetof(FBloodwebProgressionValue, OuterRingUncommonItemProbability) == 0x000070, "Member 'FBloodwebProgressionValue::OuterRingUncommonItemProbability' has a wrong offset!");
static_assert(offsetof(FBloodwebProgressionValue, InnerRingRareItemProbability) == 0x000074, "Member 'FBloodwebProgressionValue::InnerRingRareItemProbability' has a wrong offset!");
static_assert(offsetof(FBloodwebProgressionValue, MiddleRingRareItemProbability) == 0x000078, "Member 'FBloodwebProgressionValue::MiddleRingRareItemProbability' has a wrong offset!");
static_assert(offsetof(FBloodwebProgressionValue, OuterRingRareItemProbability) == 0x00007C, "Member 'FBloodwebProgressionValue::OuterRingRareItemProbability' has a wrong offset!");
static_assert(offsetof(FBloodwebProgressionValue, InnerRingVeryRareItemProbability) == 0x000080, "Member 'FBloodwebProgressionValue::InnerRingVeryRareItemProbability' has a wrong offset!");
static_assert(offsetof(FBloodwebProgressionValue, MiddleRingVeryRareItemProbability) == 0x000084, "Member 'FBloodwebProgressionValue::MiddleRingVeryRareItemProbability' has a wrong offset!");
static_assert(offsetof(FBloodwebProgressionValue, OuterRingVeryRareItemProbability) == 0x000088, "Member 'FBloodwebProgressionValue::OuterRingVeryRareItemProbability' has a wrong offset!");
static_assert(offsetof(FBloodwebProgressionValue, InnerRingUltraRareItemProbability) == 0x00008C, "Member 'FBloodwebProgressionValue::InnerRingUltraRareItemProbability' has a wrong offset!");
static_assert(offsetof(FBloodwebProgressionValue, MiddleRingUltraRareItemProbability) == 0x000090, "Member 'FBloodwebProgressionValue::MiddleRingUltraRareItemProbability' has a wrong offset!");
static_assert(offsetof(FBloodwebProgressionValue, OuterRingUltraRareItemProbability) == 0x000094, "Member 'FBloodwebProgressionValue::OuterRingUltraRareItemProbability' has a wrong offset!");
static_assert(offsetof(FBloodwebProgressionValue, InnerRingArtifactItemProbability) == 0x000098, "Member 'FBloodwebProgressionValue::InnerRingArtifactItemProbability' has a wrong offset!");
static_assert(offsetof(FBloodwebProgressionValue, MiddleRingArtifactItemProbability) == 0x00009C, "Member 'FBloodwebProgressionValue::MiddleRingArtifactItemProbability' has a wrong offset!");
static_assert(offsetof(FBloodwebProgressionValue, OuterRingArtifactItemProbability) == 0x0000A0, "Member 'FBloodwebProgressionValue::OuterRingArtifactItemProbability' has a wrong offset!");
static_assert(offsetof(FBloodwebProgressionValue, InnerRingSpectralItemProbability) == 0x0000A4, "Member 'FBloodwebProgressionValue::InnerRingSpectralItemProbability' has a wrong offset!");
static_assert(offsetof(FBloodwebProgressionValue, MiddleRingSpectralItemProbability) == 0x0000A8, "Member 'FBloodwebProgressionValue::MiddleRingSpectralItemProbability' has a wrong offset!");
static_assert(offsetof(FBloodwebProgressionValue, OuterRingSpectralItemProbability) == 0x0000AC, "Member 'FBloodwebProgressionValue::OuterRingSpectralItemProbability' has a wrong offset!");
static_assert(offsetof(FBloodwebProgressionValue, InnerRingSpecialEventItemProbability) == 0x0000B0, "Member 'FBloodwebProgressionValue::InnerRingSpecialEventItemProbability' has a wrong offset!");
static_assert(offsetof(FBloodwebProgressionValue, MiddleRingSpecialEventItemProbability) == 0x0000B4, "Member 'FBloodwebProgressionValue::MiddleRingSpecialEventItemProbability' has a wrong offset!");
static_assert(offsetof(FBloodwebProgressionValue, OuterRingSpecialEventItemProbability) == 0x0000B8, "Member 'FBloodwebProgressionValue::OuterRingSpecialEventItemProbability' has a wrong offset!");
static_assert(offsetof(FBloodwebProgressionValue, InnerRingLegendaryItemProbability) == 0x0000BC, "Member 'FBloodwebProgressionValue::InnerRingLegendaryItemProbability' has a wrong offset!");
static_assert(offsetof(FBloodwebProgressionValue, MiddleRingLegendaryItemProbability) == 0x0000C0, "Member 'FBloodwebProgressionValue::MiddleRingLegendaryItemProbability' has a wrong offset!");
static_assert(offsetof(FBloodwebProgressionValue, OuterRingLegendaryItemProbability) == 0x0000C4, "Member 'FBloodwebProgressionValue::OuterRingLegendaryItemProbability' has a wrong offset!");
static_assert(offsetof(FBloodwebProgressionValue, InnerRingEpicItemProbability) == 0x0000C8, "Member 'FBloodwebProgressionValue::InnerRingEpicItemProbability' has a wrong offset!");
static_assert(offsetof(FBloodwebProgressionValue, MiddleRingEpicItemProbability) == 0x0000CC, "Member 'FBloodwebProgressionValue::MiddleRingEpicItemProbability' has a wrong offset!");
static_assert(offsetof(FBloodwebProgressionValue, OuterRingEpicItemProbability) == 0x0000D0, "Member 'FBloodwebProgressionValue::OuterRingEpicItemProbability' has a wrong offset!");
static_assert(offsetof(FBloodwebProgressionValue, InnerRingSuperEpicItemProbability) == 0x0000D4, "Member 'FBloodwebProgressionValue::InnerRingSuperEpicItemProbability' has a wrong offset!");
static_assert(offsetof(FBloodwebProgressionValue, MiddleRingSuperEpicItemProbability) == 0x0000D8, "Member 'FBloodwebProgressionValue::MiddleRingSuperEpicItemProbability' has a wrong offset!");
static_assert(offsetof(FBloodwebProgressionValue, OuterRingSuperEpicItemProbability) == 0x0000DC, "Member 'FBloodwebProgressionValue::OuterRingSuperEpicItemProbability' has a wrong offset!");
static_assert(offsetof(FBloodwebProgressionValue, InnerRingUltraEpicItemProbability) == 0x0000E0, "Member 'FBloodwebProgressionValue::InnerRingUltraEpicItemProbability' has a wrong offset!");
static_assert(offsetof(FBloodwebProgressionValue, MiddleRingUltraEpicItemProbability) == 0x0000E4, "Member 'FBloodwebProgressionValue::MiddleRingUltraEpicItemProbability' has a wrong offset!");
static_assert(offsetof(FBloodwebProgressionValue, OuterRingUltraEpicItemProbability) == 0x0000E8, "Member 'FBloodwebProgressionValue::OuterRingUltraEpicItemProbability' has a wrong offset!");
static_assert(offsetof(FBloodwebProgressionValue, EntityStartingRound) == 0x0000EC, "Member 'FBloodwebProgressionValue::EntityStartingRound' has a wrong offset!");

// ScriptStruct DeadByDaylight.BloodwebRarityPerRingDistribution
// 0x0090 (0x0098 - 0x0008)
struct FBloodwebRarityPerRingDistribution final : public FDBDTableRowBase
{
public:
	int32                                         CommonMinCount;                                    // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CommonMaxCount;                                    // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CommonWeight;                                      // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UncommonMinCount;                                  // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UncommonMaxCount;                                  // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UncommonWeight;                                    // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RareMinCount;                                      // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RareMaxCount;                                      // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RareWeight;                                        // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         VeryRareMinCount;                                  // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         VeryRareMaxCount;                                  // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         VeryRareWeight;                                    // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UltraRareMinCount;                                 // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UltraRareMaxCount;                                 // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UltraRareWeight;                                   // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ArtefactMinCount;                                  // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ArtefactMaxCount;                                  // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ArtefactWeight;                                    // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SpectralMinCount;                                  // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SpectralMaxCount;                                  // 0x0054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SpectralWeight;                                    // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SpecialEventMinCount;                              // 0x005C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SpecialEventMaxCount;                              // 0x0060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SpecialEventWeight;                                // 0x0064(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LegendaryMinCount;                                 // 0x0068(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LegendaryMaxCount;                                 // 0x006C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LegendaryWeight;                                   // 0x0070(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EpicMinCount;                                      // 0x0074(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EpicMaxCount;                                      // 0x0078(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EpicWeight;                                        // 0x007C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SuperEpicMinCount;                                 // 0x0080(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SuperEpicMaxCount;                                 // 0x0084(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SuperEpicWeight;                                   // 0x0088(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UltraEpicMinCount;                                 // 0x008C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UltraEpicMaxCount;                                 // 0x0090(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UltraEpicWeight;                                   // 0x0094(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBloodwebRarityPerRingDistribution) == 0x000008, "Wrong alignment on FBloodwebRarityPerRingDistribution");
static_assert(sizeof(FBloodwebRarityPerRingDistribution) == 0x000098, "Wrong size on FBloodwebRarityPerRingDistribution");
static_assert(offsetof(FBloodwebRarityPerRingDistribution, CommonMinCount) == 0x000008, "Member 'FBloodwebRarityPerRingDistribution::CommonMinCount' has a wrong offset!");
static_assert(offsetof(FBloodwebRarityPerRingDistribution, CommonMaxCount) == 0x00000C, "Member 'FBloodwebRarityPerRingDistribution::CommonMaxCount' has a wrong offset!");
static_assert(offsetof(FBloodwebRarityPerRingDistribution, CommonWeight) == 0x000010, "Member 'FBloodwebRarityPerRingDistribution::CommonWeight' has a wrong offset!");
static_assert(offsetof(FBloodwebRarityPerRingDistribution, UncommonMinCount) == 0x000014, "Member 'FBloodwebRarityPerRingDistribution::UncommonMinCount' has a wrong offset!");
static_assert(offsetof(FBloodwebRarityPerRingDistribution, UncommonMaxCount) == 0x000018, "Member 'FBloodwebRarityPerRingDistribution::UncommonMaxCount' has a wrong offset!");
static_assert(offsetof(FBloodwebRarityPerRingDistribution, UncommonWeight) == 0x00001C, "Member 'FBloodwebRarityPerRingDistribution::UncommonWeight' has a wrong offset!");
static_assert(offsetof(FBloodwebRarityPerRingDistribution, RareMinCount) == 0x000020, "Member 'FBloodwebRarityPerRingDistribution::RareMinCount' has a wrong offset!");
static_assert(offsetof(FBloodwebRarityPerRingDistribution, RareMaxCount) == 0x000024, "Member 'FBloodwebRarityPerRingDistribution::RareMaxCount' has a wrong offset!");
static_assert(offsetof(FBloodwebRarityPerRingDistribution, RareWeight) == 0x000028, "Member 'FBloodwebRarityPerRingDistribution::RareWeight' has a wrong offset!");
static_assert(offsetof(FBloodwebRarityPerRingDistribution, VeryRareMinCount) == 0x00002C, "Member 'FBloodwebRarityPerRingDistribution::VeryRareMinCount' has a wrong offset!");
static_assert(offsetof(FBloodwebRarityPerRingDistribution, VeryRareMaxCount) == 0x000030, "Member 'FBloodwebRarityPerRingDistribution::VeryRareMaxCount' has a wrong offset!");
static_assert(offsetof(FBloodwebRarityPerRingDistribution, VeryRareWeight) == 0x000034, "Member 'FBloodwebRarityPerRingDistribution::VeryRareWeight' has a wrong offset!");
static_assert(offsetof(FBloodwebRarityPerRingDistribution, UltraRareMinCount) == 0x000038, "Member 'FBloodwebRarityPerRingDistribution::UltraRareMinCount' has a wrong offset!");
static_assert(offsetof(FBloodwebRarityPerRingDistribution, UltraRareMaxCount) == 0x00003C, "Member 'FBloodwebRarityPerRingDistribution::UltraRareMaxCount' has a wrong offset!");
static_assert(offsetof(FBloodwebRarityPerRingDistribution, UltraRareWeight) == 0x000040, "Member 'FBloodwebRarityPerRingDistribution::UltraRareWeight' has a wrong offset!");
static_assert(offsetof(FBloodwebRarityPerRingDistribution, ArtefactMinCount) == 0x000044, "Member 'FBloodwebRarityPerRingDistribution::ArtefactMinCount' has a wrong offset!");
static_assert(offsetof(FBloodwebRarityPerRingDistribution, ArtefactMaxCount) == 0x000048, "Member 'FBloodwebRarityPerRingDistribution::ArtefactMaxCount' has a wrong offset!");
static_assert(offsetof(FBloodwebRarityPerRingDistribution, ArtefactWeight) == 0x00004C, "Member 'FBloodwebRarityPerRingDistribution::ArtefactWeight' has a wrong offset!");
static_assert(offsetof(FBloodwebRarityPerRingDistribution, SpectralMinCount) == 0x000050, "Member 'FBloodwebRarityPerRingDistribution::SpectralMinCount' has a wrong offset!");
static_assert(offsetof(FBloodwebRarityPerRingDistribution, SpectralMaxCount) == 0x000054, "Member 'FBloodwebRarityPerRingDistribution::SpectralMaxCount' has a wrong offset!");
static_assert(offsetof(FBloodwebRarityPerRingDistribution, SpectralWeight) == 0x000058, "Member 'FBloodwebRarityPerRingDistribution::SpectralWeight' has a wrong offset!");
static_assert(offsetof(FBloodwebRarityPerRingDistribution, SpecialEventMinCount) == 0x00005C, "Member 'FBloodwebRarityPerRingDistribution::SpecialEventMinCount' has a wrong offset!");
static_assert(offsetof(FBloodwebRarityPerRingDistribution, SpecialEventMaxCount) == 0x000060, "Member 'FBloodwebRarityPerRingDistribution::SpecialEventMaxCount' has a wrong offset!");
static_assert(offsetof(FBloodwebRarityPerRingDistribution, SpecialEventWeight) == 0x000064, "Member 'FBloodwebRarityPerRingDistribution::SpecialEventWeight' has a wrong offset!");
static_assert(offsetof(FBloodwebRarityPerRingDistribution, LegendaryMinCount) == 0x000068, "Member 'FBloodwebRarityPerRingDistribution::LegendaryMinCount' has a wrong offset!");
static_assert(offsetof(FBloodwebRarityPerRingDistribution, LegendaryMaxCount) == 0x00006C, "Member 'FBloodwebRarityPerRingDistribution::LegendaryMaxCount' has a wrong offset!");
static_assert(offsetof(FBloodwebRarityPerRingDistribution, LegendaryWeight) == 0x000070, "Member 'FBloodwebRarityPerRingDistribution::LegendaryWeight' has a wrong offset!");
static_assert(offsetof(FBloodwebRarityPerRingDistribution, EpicMinCount) == 0x000074, "Member 'FBloodwebRarityPerRingDistribution::EpicMinCount' has a wrong offset!");
static_assert(offsetof(FBloodwebRarityPerRingDistribution, EpicMaxCount) == 0x000078, "Member 'FBloodwebRarityPerRingDistribution::EpicMaxCount' has a wrong offset!");
static_assert(offsetof(FBloodwebRarityPerRingDistribution, EpicWeight) == 0x00007C, "Member 'FBloodwebRarityPerRingDistribution::EpicWeight' has a wrong offset!");
static_assert(offsetof(FBloodwebRarityPerRingDistribution, SuperEpicMinCount) == 0x000080, "Member 'FBloodwebRarityPerRingDistribution::SuperEpicMinCount' has a wrong offset!");
static_assert(offsetof(FBloodwebRarityPerRingDistribution, SuperEpicMaxCount) == 0x000084, "Member 'FBloodwebRarityPerRingDistribution::SuperEpicMaxCount' has a wrong offset!");
static_assert(offsetof(FBloodwebRarityPerRingDistribution, SuperEpicWeight) == 0x000088, "Member 'FBloodwebRarityPerRingDistribution::SuperEpicWeight' has a wrong offset!");
static_assert(offsetof(FBloodwebRarityPerRingDistribution, UltraEpicMinCount) == 0x00008C, "Member 'FBloodwebRarityPerRingDistribution::UltraEpicMinCount' has a wrong offset!");
static_assert(offsetof(FBloodwebRarityPerRingDistribution, UltraEpicMaxCount) == 0x000090, "Member 'FBloodwebRarityPerRingDistribution::UltraEpicMaxCount' has a wrong offset!");
static_assert(offsetof(FBloodwebRarityPerRingDistribution, UltraEpicWeight) == 0x000094, "Member 'FBloodwebRarityPerRingDistribution::UltraEpicWeight' has a wrong offset!");

// ScriptStruct DeadByDaylight.AttackSubstateRequestResult
// 0x0003 (0x0003 - 0x0000)
struct FAttackSubstateRequestResult final
{
public:
	bool                                          IsValid;                                           // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttackSubstate                               RequestedNextSubstate;                             // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttackSubstate                               ServerNextSubstate;                                // 0x0002(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAttackSubstateRequestResult) == 0x000001, "Wrong alignment on FAttackSubstateRequestResult");
static_assert(sizeof(FAttackSubstateRequestResult) == 0x000003, "Wrong size on FAttackSubstateRequestResult");
static_assert(offsetof(FAttackSubstateRequestResult, IsValid) == 0x000000, "Member 'FAttackSubstateRequestResult::IsValid' has a wrong offset!");
static_assert(offsetof(FAttackSubstateRequestResult, RequestedNextSubstate) == 0x000001, "Member 'FAttackSubstateRequestResult::RequestedNextSubstate' has a wrong offset!");
static_assert(offsetof(FAttackSubstateRequestResult, ServerNextSubstate) == 0x000002, "Member 'FAttackSubstateRequestResult::ServerNextSubstate' has a wrong offset!");

// ScriptStruct DeadByDaylight.BloodDecal
// 0x006C (0x006C - 0x0000)
struct alignas(0x04) FBloodDecal final
{
public:
	uint8                                         Pad_0[0x6C];                                       // 0x0000(0x006C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBloodDecal) == 0x000004, "Wrong alignment on FBloodDecal");
static_assert(sizeof(FBloodDecal) == 0x00006C, "Wrong size on FBloodDecal");

// ScriptStruct DeadByDaylight.DBDPerPlatformInt
// 0x0004 (0x0004 - 0x0000)
struct FDBDPerPlatformInt final
{
public:
	struct FPerPlatformInt                        Value;                                             // 0x0000(0x0004)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDBDPerPlatformInt) == 0x000004, "Wrong alignment on FDBDPerPlatformInt");
static_assert(sizeof(FDBDPerPlatformInt) == 0x000004, "Wrong size on FDBDPerPlatformInt");
static_assert(offsetof(FDBDPerPlatformInt, Value) == 0x000000, "Member 'FDBDPerPlatformInt::Value' has a wrong offset!");

// ScriptStruct DeadByDaylight.DBDPerPlatformFloat
// 0x0004 (0x0004 - 0x0000)
struct FDBDPerPlatformFloat final
{
public:
	struct FPerPlatformFloat                      Value;                                             // 0x0000(0x0004)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDBDPerPlatformFloat) == 0x000004, "Wrong alignment on FDBDPerPlatformFloat");
static_assert(sizeof(FDBDPerPlatformFloat) == 0x000004, "Wrong size on FDBDPerPlatformFloat");
static_assert(offsetof(FDBDPerPlatformFloat, Value) == 0x000000, "Member 'FDBDPerPlatformFloat::Value' has a wrong offset!");

// ScriptStruct DeadByDaylight.BonusPointEventsItemData
// 0x00A0 (0x00A0 - 0x0000)
struct FBonusPointEventsItemData final
{
public:
	class FString                                 EventTitle;                                        // 0x0000(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 EventDescription;                                  // 0x0010(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          EventDescription_IsSet;                            // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        EventType;                                         // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	double                                        Multiplier;                                        // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 Starttime;                                         // 0x0030(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 EndTime;                                           // 0x0040(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_50[0x50];                                      // 0x0050(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBonusPointEventsItemData) == 0x000008, "Wrong alignment on FBonusPointEventsItemData");
static_assert(sizeof(FBonusPointEventsItemData) == 0x0000A0, "Wrong size on FBonusPointEventsItemData");
static_assert(offsetof(FBonusPointEventsItemData, EventTitle) == 0x000000, "Member 'FBonusPointEventsItemData::EventTitle' has a wrong offset!");
static_assert(offsetof(FBonusPointEventsItemData, EventDescription) == 0x000010, "Member 'FBonusPointEventsItemData::EventDescription' has a wrong offset!");
static_assert(offsetof(FBonusPointEventsItemData, EventDescription_IsSet) == 0x000020, "Member 'FBonusPointEventsItemData::EventDescription_IsSet' has a wrong offset!");
static_assert(offsetof(FBonusPointEventsItemData, EventType) == 0x000024, "Member 'FBonusPointEventsItemData::EventType' has a wrong offset!");
static_assert(offsetof(FBonusPointEventsItemData, Multiplier) == 0x000028, "Member 'FBonusPointEventsItemData::Multiplier' has a wrong offset!");
static_assert(offsetof(FBonusPointEventsItemData, Starttime) == 0x000030, "Member 'FBonusPointEventsItemData::Starttime' has a wrong offset!");
static_assert(offsetof(FBonusPointEventsItemData, EndTime) == 0x000040, "Member 'FBonusPointEventsItemData::EndTime' has a wrong offset!");

// ScriptStruct DeadByDaylight.AIHasPerkCondition
// 0x0038 (0x0038 - 0x0000)
struct FAIHasPerkCondition final
{
public:
	struct FDataTableDropdown                     PerkId;                                            // 0x0000(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	bool                                          CompareDisplayPercent;                             // 0x0030(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EArithmeticKeyOperation                       DisplayPercentQuery;                               // 0x0031(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x2];                                       // 0x0032(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DisplayPercentValue;                               // 0x0034(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIHasPerkCondition) == 0x000008, "Wrong alignment on FAIHasPerkCondition");
static_assert(sizeof(FAIHasPerkCondition) == 0x000038, "Wrong size on FAIHasPerkCondition");
static_assert(offsetof(FAIHasPerkCondition, PerkId) == 0x000000, "Member 'FAIHasPerkCondition::PerkId' has a wrong offset!");
static_assert(offsetof(FAIHasPerkCondition, CompareDisplayPercent) == 0x000030, "Member 'FAIHasPerkCondition::CompareDisplayPercent' has a wrong offset!");
static_assert(offsetof(FAIHasPerkCondition, DisplayPercentQuery) == 0x000031, "Member 'FAIHasPerkCondition::DisplayPercentQuery' has a wrong offset!");
static_assert(offsetof(FAIHasPerkCondition, DisplayPercentValue) == 0x000034, "Member 'FAIHasPerkCondition::DisplayPercentValue' has a wrong offset!");

// ScriptStruct DeadByDaylight.BonusPointEventsData
// 0x0010 (0x0010 - 0x0000)
struct FBonusPointEventsData final
{
public:
	TArray<struct FBonusPointEventsItemData>      BonusPointEvents;                                  // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBonusPointEventsData) == 0x000008, "Wrong alignment on FBonusPointEventsData");
static_assert(sizeof(FBonusPointEventsData) == 0x000010, "Wrong size on FBonusPointEventsData");
static_assert(offsetof(FBonusPointEventsData, BonusPointEvents) == 0x000000, "Member 'FBonusPointEventsData::BonusPointEvents' has a wrong offset!");

// ScriptStruct DeadByDaylight.BorderElements
// 0x0018 (0x0018 - 0x0000)
struct FBorderElements final
{
public:
	EDirection                                    Direction;                                         // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UActorSpawner*>                  Elements;                                          // 0x0008(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBorderElements) == 0x000008, "Wrong alignment on FBorderElements");
static_assert(sizeof(FBorderElements) == 0x000018, "Wrong size on FBorderElements");
static_assert(offsetof(FBorderElements, Direction) == 0x000000, "Member 'FBorderElements::Direction' has a wrong offset!");
static_assert(offsetof(FBorderElements, Elements) == 0x000008, "Member 'FBorderElements::Elements' has a wrong offset!");

// ScriptStruct DeadByDaylight.SavedCharacterLevelData
// 0x0018 (0x0018 - 0x0000)
struct FSavedCharacterLevelData final
{
public:
	int32                                         Level;                                             // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasPerksBeenSelected;                              // 0x0004(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasPerkSelectionBeenGenerated;                     // 0x0005(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAssignedPerkProperties>        PerkSelection;                                     // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSavedCharacterLevelData) == 0x000008, "Wrong alignment on FSavedCharacterLevelData");
static_assert(sizeof(FSavedCharacterLevelData) == 0x000018, "Wrong size on FSavedCharacterLevelData");
static_assert(offsetof(FSavedCharacterLevelData, Level) == 0x000000, "Member 'FSavedCharacterLevelData::Level' has a wrong offset!");
static_assert(offsetof(FSavedCharacterLevelData, HasPerksBeenSelected) == 0x000004, "Member 'FSavedCharacterLevelData::HasPerksBeenSelected' has a wrong offset!");
static_assert(offsetof(FSavedCharacterLevelData, HasPerkSelectionBeenGenerated) == 0x000005, "Member 'FSavedCharacterLevelData::HasPerkSelectionBeenGenerated' has a wrong offset!");
static_assert(offsetof(FSavedCharacterLevelData, PerkSelection) == 0x000008, "Member 'FSavedCharacterLevelData::PerkSelection' has a wrong offset!");

// ScriptStruct DeadByDaylight.BorderElements2
// 0x0018 (0x0018 - 0x0000)
struct FBorderElements2 final
{
public:
	EDirection                                    Direction;                                         // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         Elements;                                          // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBorderElements2) == 0x000008, "Wrong alignment on FBorderElements2");
static_assert(sizeof(FBorderElements2) == 0x000018, "Wrong size on FBorderElements2");
static_assert(offsetof(FBorderElements2, Direction) == 0x000000, "Member 'FBorderElements2::Direction' has a wrong offset!");
static_assert(offsetof(FBorderElements2, Elements) == 0x000008, "Member 'FBorderElements2::Elements' has a wrong offset!");

// ScriptStruct DeadByDaylight.BotMatchConfig
// 0x0020 (0x0020 - 0x0000)
struct FBotMatchConfig final
{
public:
	TArray<class FString>                         DSPlatformSBM;                                     // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         DSPlatformTutorialBotMatch;                        // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBotMatchConfig) == 0x000008, "Wrong alignment on FBotMatchConfig");
static_assert(sizeof(FBotMatchConfig) == 0x000020, "Wrong size on FBotMatchConfig");
static_assert(offsetof(FBotMatchConfig, DSPlatformSBM) == 0x000000, "Member 'FBotMatchConfig::DSPlatformSBM' has a wrong offset!");
static_assert(offsetof(FBotMatchConfig, DSPlatformTutorialBotMatch) == 0x000010, "Member 'FBotMatchConfig::DSPlatformTutorialBotMatch' has a wrong offset!");

// ScriptStruct DeadByDaylight.AuthenticationInfo
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FAuthenticationInfo final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAuthenticationInfo) == 0x000008, "Wrong alignment on FAuthenticationInfo");
static_assert(sizeof(FAuthenticationInfo) == 0x000018, "Wrong size on FAuthenticationInfo");

// ScriptStruct DeadByDaylight.BundleData
// 0x0148 (0x0148 - 0x0000)
struct FBundleData final
{
public:
	class FName                                   ID;                                                // 0x0000(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FItemUIData                            UIData;                                            // 0x0010(0x0138)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBundleData) == 0x000008, "Wrong alignment on FBundleData");
static_assert(sizeof(FBundleData) == 0x000148, "Wrong size on FBundleData");
static_assert(offsetof(FBundleData, ID) == 0x000000, "Member 'FBundleData::ID' has a wrong offset!");
static_assert(offsetof(FBundleData, UIData) == 0x000010, "Member 'FBundleData::UIData' has a wrong offset!");

// ScriptStruct DeadByDaylight.CameraAttachment
// 0x0018 (0x0018 - 0x0000)
struct FCameraAttachment final
{
public:
	class USceneComponent*                        Parent;                                            // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x10];                                       // 0x0008(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCameraAttachment) == 0x000008, "Wrong alignment on FCameraAttachment");
static_assert(sizeof(FCameraAttachment) == 0x000018, "Wrong size on FCameraAttachment");
static_assert(offsetof(FCameraAttachment, Parent) == 0x000000, "Member 'FCameraAttachment::Parent' has a wrong offset!");

// ScriptStruct DeadByDaylight.CamperDamageResult
// 0x0060 (0x0060 - 0x0000)
struct FCamperDamageResult final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 DamageSource;                                      // 0x0010(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACharacter*                             DamagePlayerOwner;                                 // 0x0018(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0x8];                                       // 0x0020(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UGameplayModifierContainer*             KOPreventedSource;                                 // 0x0028(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30[0x30];                                      // 0x0030(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCamperDamageResult) == 0x000008, "Wrong alignment on FCamperDamageResult");
static_assert(sizeof(FCamperDamageResult) == 0x000060, "Wrong size on FCamperDamageResult");
static_assert(offsetof(FCamperDamageResult, DamageSource) == 0x000010, "Member 'FCamperDamageResult::DamageSource' has a wrong offset!");
static_assert(offsetof(FCamperDamageResult, DamagePlayerOwner) == 0x000018, "Member 'FCamperDamageResult::DamagePlayerOwner' has a wrong offset!");
static_assert(offsetof(FCamperDamageResult, KOPreventedSource) == 0x000028, "Member 'FCamperDamageResult::KOPreventedSource' has a wrong offset!");

// ScriptStruct DeadByDaylight.ManagedMaterialGroup
// 0x0030 (0x0030 - 0x0000)
struct FManagedMaterialGroup final
{
public:
	class UObject*                                Source;                                            // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Group;                                             // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void()>                             Condition;                                         // 0x0018(0x0014)(Edit, BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FManagedMaterialGroup) == 0x000008, "Wrong alignment on FManagedMaterialGroup");
static_assert(sizeof(FManagedMaterialGroup) == 0x000030, "Wrong size on FManagedMaterialGroup");
static_assert(offsetof(FManagedMaterialGroup, Source) == 0x000000, "Member 'FManagedMaterialGroup::Source' has a wrong offset!");
static_assert(offsetof(FManagedMaterialGroup, Group) == 0x000008, "Member 'FManagedMaterialGroup::Group' has a wrong offset!");
static_assert(offsetof(FManagedMaterialGroup, Condition) == 0x000018, "Member 'FManagedMaterialGroup::Condition' has a wrong offset!");

// ScriptStruct DeadByDaylight.WebPath
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x08) FWebPath final
{
public:
	uint8                                         Pad_0[0x28];                                       // 0x0000(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWebPath) == 0x000008, "Wrong alignment on FWebPath");
static_assert(sizeof(FWebPath) == 0x000028, "Wrong size on FWebPath");

// ScriptStruct DeadByDaylight.TierInfoData
// 0x0038 (0x0038 - 0x0000)
struct FTierInfoData final
{
public:
	TArray<struct FRewardResponseItem>            Free;                                              // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          Free_IsSet;                                        // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRewardResponseItem>            Premium;                                           // 0x0018(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          Premium_IsSet;                                     // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NeededPoints;                                      // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TierGroup;                                         // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TierId;                                            // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTierInfoData) == 0x000008, "Wrong alignment on FTierInfoData");
static_assert(sizeof(FTierInfoData) == 0x000038, "Wrong size on FTierInfoData");
static_assert(offsetof(FTierInfoData, Free) == 0x000000, "Member 'FTierInfoData::Free' has a wrong offset!");
static_assert(offsetof(FTierInfoData, Free_IsSet) == 0x000010, "Member 'FTierInfoData::Free_IsSet' has a wrong offset!");
static_assert(offsetof(FTierInfoData, Premium) == 0x000018, "Member 'FTierInfoData::Premium' has a wrong offset!");
static_assert(offsetof(FTierInfoData, Premium_IsSet) == 0x000028, "Member 'FTierInfoData::Premium_IsSet' has a wrong offset!");
static_assert(offsetof(FTierInfoData, NeededPoints) == 0x00002C, "Member 'FTierInfoData::NeededPoints' has a wrong offset!");
static_assert(offsetof(FTierInfoData, TierGroup) == 0x000030, "Member 'FTierInfoData::TierGroup' has a wrong offset!");
static_assert(offsetof(FTierInfoData, TierId) == 0x000034, "Member 'FTierInfoData::TierId' has a wrong offset!");

// ScriptStruct DeadByDaylight.SelectableTileSpawnPoint
// 0x0030 (0x0030 - 0x0000)
struct FSelectableTileSpawnPoint final
{
public:
	struct FComponentReference                    ComponentReference;                                // 0x0000(0x0030)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FSelectableTileSpawnPoint) == 0x000008, "Wrong alignment on FSelectableTileSpawnPoint");
static_assert(sizeof(FSelectableTileSpawnPoint) == 0x000030, "Wrong size on FSelectableTileSpawnPoint");
static_assert(offsetof(FSelectableTileSpawnPoint, ComponentReference) == 0x000000, "Member 'FSelectableTileSpawnPoint::ComponentReference' has a wrong offset!");

// ScriptStruct DeadByDaylight.ChallengeRewardTrackerData
// 0x0068 (0x0068 - 0x0000)
struct FChallengeRewardTrackerData final
{
public:
	class FString                                 StartDate;                                         // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 EndDate;                                           // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PassLinkToTomeId;                                  // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          PassLinkToTomeId_IsSet;                            // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTierInfoData>                  TierInfo;                                          // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x20];                                      // 0x0048(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FChallengeRewardTrackerData) == 0x000008, "Wrong alignment on FChallengeRewardTrackerData");
static_assert(sizeof(FChallengeRewardTrackerData) == 0x000068, "Wrong size on FChallengeRewardTrackerData");
static_assert(offsetof(FChallengeRewardTrackerData, StartDate) == 0x000000, "Member 'FChallengeRewardTrackerData::StartDate' has a wrong offset!");
static_assert(offsetof(FChallengeRewardTrackerData, EndDate) == 0x000010, "Member 'FChallengeRewardTrackerData::EndDate' has a wrong offset!");
static_assert(offsetof(FChallengeRewardTrackerData, PassLinkToTomeId) == 0x000020, "Member 'FChallengeRewardTrackerData::PassLinkToTomeId' has a wrong offset!");
static_assert(offsetof(FChallengeRewardTrackerData, PassLinkToTomeId_IsSet) == 0x000030, "Member 'FChallengeRewardTrackerData::PassLinkToTomeId_IsSet' has a wrong offset!");
static_assert(offsetof(FChallengeRewardTrackerData, TierInfo) == 0x000038, "Member 'FChallengeRewardTrackerData::TierInfo' has a wrong offset!");

// ScriptStruct DeadByDaylight.AtlantaCustomizedHudSettings
// 0x0050 (0x0050 - 0x0000)
struct FAtlantaCustomizedHudSettings final
{
public:
	struct FGameplayTag                           ID;                                                // 0x0000(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              NormalizedOffset;                                  // 0x0010(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RenderOpacity;                                     // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Version;                                           // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  OverlapWrapperIds;                                 // 0x0030(0x0020)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FAtlantaCustomizedHudSettings) == 0x000008, "Wrong alignment on FAtlantaCustomizedHudSettings");
static_assert(sizeof(FAtlantaCustomizedHudSettings) == 0x000050, "Wrong size on FAtlantaCustomizedHudSettings");
static_assert(offsetof(FAtlantaCustomizedHudSettings, ID) == 0x000000, "Member 'FAtlantaCustomizedHudSettings::ID' has a wrong offset!");
static_assert(offsetof(FAtlantaCustomizedHudSettings, NormalizedOffset) == 0x000010, "Member 'FAtlantaCustomizedHudSettings::NormalizedOffset' has a wrong offset!");
static_assert(offsetof(FAtlantaCustomizedHudSettings, Scale) == 0x000020, "Member 'FAtlantaCustomizedHudSettings::Scale' has a wrong offset!");
static_assert(offsetof(FAtlantaCustomizedHudSettings, RenderOpacity) == 0x000024, "Member 'FAtlantaCustomizedHudSettings::RenderOpacity' has a wrong offset!");
static_assert(offsetof(FAtlantaCustomizedHudSettings, Version) == 0x000028, "Member 'FAtlantaCustomizedHudSettings::Version' has a wrong offset!");
static_assert(offsetof(FAtlantaCustomizedHudSettings, OverlapWrapperIds) == 0x000030, "Member 'FAtlantaCustomizedHudSettings::OverlapWrapperIds' has a wrong offset!");

// ScriptStruct DeadByDaylight.RewardItem
// 0x0040 (0x0040 - 0x0000)
struct FRewardItem final
{
public:
	ERewardType                                   Type;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CustomizationId;                                   // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CharacterId;                                       // 0x0018(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Amount;                                            // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECurrencyType                                 CurrencyId;                                        // 0x002C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ProgressionId;                                     // 0x0030(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRewardItem) == 0x000008, "Wrong alignment on FRewardItem");
static_assert(sizeof(FRewardItem) == 0x000040, "Wrong size on FRewardItem");
static_assert(offsetof(FRewardItem, Type) == 0x000000, "Member 'FRewardItem::Type' has a wrong offset!");
static_assert(offsetof(FRewardItem, CustomizationId) == 0x000008, "Member 'FRewardItem::CustomizationId' has a wrong offset!");
static_assert(offsetof(FRewardItem, CharacterId) == 0x000018, "Member 'FRewardItem::CharacterId' has a wrong offset!");
static_assert(offsetof(FRewardItem, Amount) == 0x000028, "Member 'FRewardItem::Amount' has a wrong offset!");
static_assert(offsetof(FRewardItem, CurrencyId) == 0x00002C, "Member 'FRewardItem::CurrencyId' has a wrong offset!");
static_assert(offsetof(FRewardItem, ProgressionId) == 0x000030, "Member 'FRewardItem::ProgressionId' has a wrong offset!");

// ScriptStruct DeadByDaylight.TrackItem
// 0x0108 (0x0108 - 0x0000)
struct FTrackItem final
{
public:
	ERewardTrackId                                TrackId;                                           // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRewardItem                            Rewards[0x4];                                      // 0x0008(0x0040)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTrackItem) == 0x000008, "Wrong alignment on FTrackItem");
static_assert(sizeof(FTrackItem) == 0x000108, "Wrong size on FTrackItem");
static_assert(offsetof(FTrackItem, TrackId) == 0x000000, "Member 'FTrackItem::TrackId' has a wrong offset!");
static_assert(offsetof(FTrackItem, Rewards) == 0x000008, "Member 'FTrackItem::Rewards' has a wrong offset!");

// ScriptStruct DeadByDaylight.CharacterSavedInventoryData
// 0x0010 (0x0010 - 0x0000)
struct FCharacterSavedInventoryData final
{
public:
	uint32                                        Version;                                           // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Name;                                              // 0x0004(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterSavedInventoryData) == 0x000004, "Wrong alignment on FCharacterSavedInventoryData");
static_assert(sizeof(FCharacterSavedInventoryData) == 0x000010, "Wrong size on FCharacterSavedInventoryData");
static_assert(offsetof(FCharacterSavedInventoryData, Version) == 0x000000, "Member 'FCharacterSavedInventoryData::Version' has a wrong offset!");
static_assert(offsetof(FCharacterSavedInventoryData, Name) == 0x000004, "Member 'FCharacterSavedInventoryData::Name' has a wrong offset!");

// ScriptStruct DeadByDaylight.TrackerTierItem
// 0x0218 (0x0218 - 0x0000)
struct FTrackerTierItem final
{
public:
	int32                                         TierId;                                            // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NeededPoints;                                      // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTrackItem                             TrackTier[0x2];                                    // 0x0008(0x0108)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTrackerTierItem) == 0x000008, "Wrong alignment on FTrackerTierItem");
static_assert(sizeof(FTrackerTierItem) == 0x000218, "Wrong size on FTrackerTierItem");
static_assert(offsetof(FTrackerTierItem, TierId) == 0x000000, "Member 'FTrackerTierItem::TierId' has a wrong offset!");
static_assert(offsetof(FTrackerTierItem, NeededPoints) == 0x000004, "Member 'FTrackerTierItem::NeededPoints' has a wrong offset!");
static_assert(offsetof(FTrackerTierItem, TrackTier) == 0x000008, "Member 'FTrackerTierItem::TrackTier' has a wrong offset!");

// ScriptStruct DeadByDaylight.RewardTierGroupItem
// 0x0008 (0x0008 - 0x0000)
struct FRewardTierGroupItem final
{
public:
	int32                                         ID;                                                // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxTierId;                                         // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRewardTierGroupItem) == 0x000004, "Wrong alignment on FRewardTierGroupItem");
static_assert(sizeof(FRewardTierGroupItem) == 0x000008, "Wrong size on FRewardTierGroupItem");
static_assert(offsetof(FRewardTierGroupItem, ID) == 0x000000, "Member 'FRewardTierGroupItem::ID' has a wrong offset!");
static_assert(offsetof(FRewardTierGroupItem, MaxTierId) == 0x000004, "Member 'FRewardTierGroupItem::MaxTierId' has a wrong offset!");

// ScriptStruct DeadByDaylight.StaticMeshAutoBatch
// 0x0040 (0x0040 - 0x0000)
struct FStaticMeshAutoBatch final
{
public:
	class UStaticMesh*                            StaticMesh;                                        // 0x0000(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x28];                                       // 0x0008(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UStaticMeshComponent*>           StaticMeshComponents;                              // 0x0030(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStaticMeshAutoBatch) == 0x000008, "Wrong alignment on FStaticMeshAutoBatch");
static_assert(sizeof(FStaticMeshAutoBatch) == 0x000040, "Wrong size on FStaticMeshAutoBatch");
static_assert(offsetof(FStaticMeshAutoBatch, StaticMesh) == 0x000000, "Member 'FStaticMeshAutoBatch::StaticMesh' has a wrong offset!");
static_assert(offsetof(FStaticMeshAutoBatch, StaticMeshComponents) == 0x000030, "Member 'FStaticMeshAutoBatch::StaticMeshComponents' has a wrong offset!");

// ScriptStruct DeadByDaylight.CostItem
// 0x0008 (0x0008 - 0x0000)
struct FCostItem final
{
public:
	int32                                         Amount;                                            // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECurrencyType                                 CurrencyId;                                        // 0x0004(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCostItem) == 0x000004, "Wrong alignment on FCostItem");
static_assert(sizeof(FCostItem) == 0x000008, "Wrong size on FCostItem");
static_assert(offsetof(FCostItem, Amount) == 0x000000, "Member 'FCostItem::Amount' has a wrong offset!");
static_assert(offsetof(FCostItem, CurrencyId) == 0x000004, "Member 'FCostItem::CurrencyId' has a wrong offset!");

// ScriptStruct DeadByDaylight.ChallengeRewardTrackersEditorData
// 0x0058 (0x0060 - 0x0008)
struct FChallengeRewardTrackersEditorData final : public FDBDTableRowBase
{
public:
	class FString                                 ID;                                                // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PassLinkToTomeId;                                  // 0x0018(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              StartDate;                                         // 0x0028(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              EndDate;                                           // 0x0030(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCostItem                              UnlockTierCost;                                    // 0x0038(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FRewardTierGroupItem                   TierGroup[0x2];                                    // 0x0040(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FTrackerTierItem>               Tiers;                                             // 0x0050(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FChallengeRewardTrackersEditorData) == 0x000008, "Wrong alignment on FChallengeRewardTrackersEditorData");
static_assert(sizeof(FChallengeRewardTrackersEditorData) == 0x000060, "Wrong size on FChallengeRewardTrackersEditorData");
static_assert(offsetof(FChallengeRewardTrackersEditorData, ID) == 0x000008, "Member 'FChallengeRewardTrackersEditorData::ID' has a wrong offset!");
static_assert(offsetof(FChallengeRewardTrackersEditorData, PassLinkToTomeId) == 0x000018, "Member 'FChallengeRewardTrackersEditorData::PassLinkToTomeId' has a wrong offset!");
static_assert(offsetof(FChallengeRewardTrackersEditorData, StartDate) == 0x000028, "Member 'FChallengeRewardTrackersEditorData::StartDate' has a wrong offset!");
static_assert(offsetof(FChallengeRewardTrackersEditorData, EndDate) == 0x000030, "Member 'FChallengeRewardTrackersEditorData::EndDate' has a wrong offset!");
static_assert(offsetof(FChallengeRewardTrackersEditorData, UnlockTierCost) == 0x000038, "Member 'FChallengeRewardTrackersEditorData::UnlockTierCost' has a wrong offset!");
static_assert(offsetof(FChallengeRewardTrackersEditorData, TierGroup) == 0x000040, "Member 'FChallengeRewardTrackersEditorData::TierGroup' has a wrong offset!");
static_assert(offsetof(FChallengeRewardTrackersEditorData, Tiers) == 0x000050, "Member 'FChallengeRewardTrackersEditorData::Tiers' has a wrong offset!");

// ScriptStruct DeadByDaylight.SpawnInfo
// 0x00B0 (0x00B0 - 0x0000)
struct FSpawnInfo final
{
public:
	class UClass*                                 ActorClass;                                        // 0x0000(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Transform;                                         // 0x0010(0x0060)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttachSocket;                                      // 0x0070(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 AttachParentName;                                  // 0x0080(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UClass*                                 AttachParentClass;                                 // 0x0090(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           Tags;                                              // 0x0098(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSpawnInfo) == 0x000010, "Wrong alignment on FSpawnInfo");
static_assert(sizeof(FSpawnInfo) == 0x0000B0, "Wrong size on FSpawnInfo");
static_assert(offsetof(FSpawnInfo, ActorClass) == 0x000000, "Member 'FSpawnInfo::ActorClass' has a wrong offset!");
static_assert(offsetof(FSpawnInfo, Transform) == 0x000010, "Member 'FSpawnInfo::Transform' has a wrong offset!");
static_assert(offsetof(FSpawnInfo, AttachSocket) == 0x000070, "Member 'FSpawnInfo::AttachSocket' has a wrong offset!");
static_assert(offsetof(FSpawnInfo, AttachParentName) == 0x000080, "Member 'FSpawnInfo::AttachParentName' has a wrong offset!");
static_assert(offsetof(FSpawnInfo, AttachParentClass) == 0x000090, "Member 'FSpawnInfo::AttachParentClass' has a wrong offset!");
static_assert(offsetof(FSpawnInfo, Tags) == 0x000098, "Member 'FSpawnInfo::Tags' has a wrong offset!");

// ScriptStruct DeadByDaylight.SpecialBehaviourItem
// 0x0020 (0x0020 - 0x0000)
struct FSpecialBehaviourItem final
{
public:
	class FString                                 ID;                                                // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Parameters;                                        // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpecialBehaviourItem) == 0x000008, "Wrong alignment on FSpecialBehaviourItem");
static_assert(sizeof(FSpecialBehaviourItem) == 0x000020, "Wrong size on FSpecialBehaviourItem");
static_assert(offsetof(FSpecialBehaviourItem, ID) == 0x000000, "Member 'FSpecialBehaviourItem::ID' has a wrong offset!");
static_assert(offsetof(FSpecialBehaviourItem, Parameters) == 0x000010, "Member 'FSpecialBehaviourItem::Parameters' has a wrong offset!");

// ScriptStruct DeadByDaylight.ChallengeConditionItem
// 0x0018 (0x0018 - 0x0000)
struct FChallengeConditionItem final
{
public:
	EQuestCondition                               Key;                                               // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Value;                                             // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FChallengeConditionItem) == 0x000008, "Wrong alignment on FChallengeConditionItem");
static_assert(sizeof(FChallengeConditionItem) == 0x000018, "Wrong size on FChallengeConditionItem");
static_assert(offsetof(FChallengeConditionItem, Key) == 0x000000, "Member 'FChallengeConditionItem::Key' has a wrong offset!");
static_assert(offsetof(FChallengeConditionItem, Value) == 0x000008, "Member 'FChallengeConditionItem::Value' has a wrong offset!");

// ScriptStruct DeadByDaylight.ChallengeQuestParameter
// 0x0028 (0x0028 - 0x0000)
struct FChallengeQuestParameter final
{
public:
	class FString                                 Type;                                              // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Value;                                             // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EQuestTargetValue                             TargetValue;                                       // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEmblemQuality                                EmblemQualityValue;                                // 0x0021(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemRarity                                   RarityValue;                                       // 0x0022(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EQuestTierSizeValue                           TierSizeValue;                                     // 0x0023(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDBDScoreCategory                             ScoreCategoryValue;                                // 0x0024(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EChallengeQuestParameterEditorType            EditorType;                                        // 0x0025(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26[0x2];                                       // 0x0026(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FChallengeQuestParameter) == 0x000008, "Wrong alignment on FChallengeQuestParameter");
static_assert(sizeof(FChallengeQuestParameter) == 0x000028, "Wrong size on FChallengeQuestParameter");
static_assert(offsetof(FChallengeQuestParameter, Type) == 0x000000, "Member 'FChallengeQuestParameter::Type' has a wrong offset!");
static_assert(offsetof(FChallengeQuestParameter, Value) == 0x000010, "Member 'FChallengeQuestParameter::Value' has a wrong offset!");
static_assert(offsetof(FChallengeQuestParameter, TargetValue) == 0x000020, "Member 'FChallengeQuestParameter::TargetValue' has a wrong offset!");
static_assert(offsetof(FChallengeQuestParameter, EmblemQualityValue) == 0x000021, "Member 'FChallengeQuestParameter::EmblemQualityValue' has a wrong offset!");
static_assert(offsetof(FChallengeQuestParameter, RarityValue) == 0x000022, "Member 'FChallengeQuestParameter::RarityValue' has a wrong offset!");
static_assert(offsetof(FChallengeQuestParameter, TierSizeValue) == 0x000023, "Member 'FChallengeQuestParameter::TierSizeValue' has a wrong offset!");
static_assert(offsetof(FChallengeQuestParameter, ScoreCategoryValue) == 0x000024, "Member 'FChallengeQuestParameter::ScoreCategoryValue' has a wrong offset!");
static_assert(offsetof(FChallengeQuestParameter, EditorType) == 0x000025, "Member 'FChallengeQuestParameter::EditorType' has a wrong offset!");

// ScriptStruct DeadByDaylight.QuestEventItem
// 0x0028 (0x0028 - 0x0000)
struct FQuestEventItem final
{
public:
	class FString                                 QuestEventId;                                      // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Repetition;                                        // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EQuestOperationType                           Operation;                                         // 0x0014(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FChallengeQuestParameter>       Parameters;                                        // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FQuestEventItem) == 0x000008, "Wrong alignment on FQuestEventItem");
static_assert(sizeof(FQuestEventItem) == 0x000028, "Wrong size on FQuestEventItem");
static_assert(offsetof(FQuestEventItem, QuestEventId) == 0x000000, "Member 'FQuestEventItem::QuestEventId' has a wrong offset!");
static_assert(offsetof(FQuestEventItem, Repetition) == 0x000010, "Member 'FQuestEventItem::Repetition' has a wrong offset!");
static_assert(offsetof(FQuestEventItem, Operation) == 0x000014, "Member 'FQuestEventItem::Operation' has a wrong offset!");
static_assert(offsetof(FQuestEventItem, Parameters) == 0x000018, "Member 'FQuestEventItem::Parameters' has a wrong offset!");

// ScriptStruct DeadByDaylight.QuestItem
// 0x00E0 (0x00E0 - 0x0000)
struct FQuestItem final
{
public:
	class FString                                 ClientObjectiveId;                                 // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ClientObjectiveInfo;                               // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CountMatch;                                        // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxProgressionPerPlayer;                           // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NeededProgression;                                 // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<int32>                                   NeededProgressions;                                // 0x0030(0x0050)(Edit, NativeAccessSpecifierPublic)
	struct FSpecialBehaviourItem                  SpecialBehaviour;                                  // 0x0080(0x0020)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FChallengeConditionItem>        Conditions;                                        // 0x00A0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FQuestEventItem                        QuestEvent;                                        // 0x00B0(0x0028)(Edit, NativeAccessSpecifierPublic)
	EArchiveNodeType                              QuestType;                                         // 0x00D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EChallengeType                                Type;                                              // 0x00D9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsCommunityObjective;                              // 0x00DA(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DB[0x5];                                       // 0x00DB(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FQuestItem) == 0x000008, "Wrong alignment on FQuestItem");
static_assert(sizeof(FQuestItem) == 0x0000E0, "Wrong size on FQuestItem");
static_assert(offsetof(FQuestItem, ClientObjectiveId) == 0x000000, "Member 'FQuestItem::ClientObjectiveId' has a wrong offset!");
static_assert(offsetof(FQuestItem, ClientObjectiveInfo) == 0x000010, "Member 'FQuestItem::ClientObjectiveInfo' has a wrong offset!");
static_assert(offsetof(FQuestItem, CountMatch) == 0x000020, "Member 'FQuestItem::CountMatch' has a wrong offset!");
static_assert(offsetof(FQuestItem, MaxProgressionPerPlayer) == 0x000024, "Member 'FQuestItem::MaxProgressionPerPlayer' has a wrong offset!");
static_assert(offsetof(FQuestItem, NeededProgression) == 0x000028, "Member 'FQuestItem::NeededProgression' has a wrong offset!");
static_assert(offsetof(FQuestItem, NeededProgressions) == 0x000030, "Member 'FQuestItem::NeededProgressions' has a wrong offset!");
static_assert(offsetof(FQuestItem, SpecialBehaviour) == 0x000080, "Member 'FQuestItem::SpecialBehaviour' has a wrong offset!");
static_assert(offsetof(FQuestItem, Conditions) == 0x0000A0, "Member 'FQuestItem::Conditions' has a wrong offset!");
static_assert(offsetof(FQuestItem, QuestEvent) == 0x0000B0, "Member 'FQuestItem::QuestEvent' has a wrong offset!");
static_assert(offsetof(FQuestItem, QuestType) == 0x0000D8, "Member 'FQuestItem::QuestType' has a wrong offset!");
static_assert(offsetof(FQuestItem, Type) == 0x0000D9, "Member 'FQuestItem::Type' has a wrong offset!");
static_assert(offsetof(FQuestItem, IsCommunityObjective) == 0x0000DA, "Member 'FQuestItem::IsCommunityObjective' has a wrong offset!");

// ScriptStruct DeadByDaylight.ChallengesEditorData
// 0x02F0 (0x02F8 - 0x0008)
struct FChallengesEditorData final : public FDBDTableRowBase
{
public:
	class FString                                 ID;                                                // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   TitleStringId;                                     // 0x0018(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   DescriptionStringId;                               // 0x0030(0x0018)(Edit, NativeAccessSpecifierPublic)
	EChallengeType                                Type;                                              // 0x0048(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsRecurring;                                       // 0x0049(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A[0x2];                                       // 0x004A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LifetimeInDays;                                    // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RewardPoints;                                      // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsCommunityObjective;                              // 0x0054(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_55[0x3];                                       // 0x0055(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuestItem                             Quest;                                             // 0x0058(0x00E0)(Edit, NativeAccessSpecifierPublic)
	struct FQuestItem                             Quests[0x2];                                       // 0x0138(0x00E0)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FChallengesEditorData) == 0x000008, "Wrong alignment on FChallengesEditorData");
static_assert(sizeof(FChallengesEditorData) == 0x0002F8, "Wrong size on FChallengesEditorData");
static_assert(offsetof(FChallengesEditorData, ID) == 0x000008, "Member 'FChallengesEditorData::ID' has a wrong offset!");
static_assert(offsetof(FChallengesEditorData, TitleStringId) == 0x000018, "Member 'FChallengesEditorData::TitleStringId' has a wrong offset!");
static_assert(offsetof(FChallengesEditorData, DescriptionStringId) == 0x000030, "Member 'FChallengesEditorData::DescriptionStringId' has a wrong offset!");
static_assert(offsetof(FChallengesEditorData, Type) == 0x000048, "Member 'FChallengesEditorData::Type' has a wrong offset!");
static_assert(offsetof(FChallengesEditorData, IsRecurring) == 0x000049, "Member 'FChallengesEditorData::IsRecurring' has a wrong offset!");
static_assert(offsetof(FChallengesEditorData, LifetimeInDays) == 0x00004C, "Member 'FChallengesEditorData::LifetimeInDays' has a wrong offset!");
static_assert(offsetof(FChallengesEditorData, RewardPoints) == 0x000050, "Member 'FChallengesEditorData::RewardPoints' has a wrong offset!");
static_assert(offsetof(FChallengesEditorData, IsCommunityObjective) == 0x000054, "Member 'FChallengesEditorData::IsCommunityObjective' has a wrong offset!");
static_assert(offsetof(FChallengesEditorData, Quest) == 0x000058, "Member 'FChallengesEditorData::Quest' has a wrong offset!");
static_assert(offsetof(FChallengesEditorData, Quests) == 0x000138, "Member 'FChallengesEditorData::Quests' has a wrong offset!");

// ScriptStruct DeadByDaylight.ArchivesVignetteEntry
// 0x0078 (0x0080 - 0x0008)
struct FArchivesVignetteEntry final : public FDBDTableRowBase
{
public:
	class FText                                   Title;                                             // 0x0008(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   Text;                                              // 0x0020(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          HasAudio;                                          // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UTexture2D>              RewardImage;                                       // 0x0040(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PreviewTextureOffset;                              // 0x0078(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FArchivesVignetteEntry) == 0x000008, "Wrong alignment on FArchivesVignetteEntry");
static_assert(sizeof(FArchivesVignetteEntry) == 0x000080, "Wrong size on FArchivesVignetteEntry");
static_assert(offsetof(FArchivesVignetteEntry, Title) == 0x000008, "Member 'FArchivesVignetteEntry::Title' has a wrong offset!");
static_assert(offsetof(FArchivesVignetteEntry, Text) == 0x000020, "Member 'FArchivesVignetteEntry::Text' has a wrong offset!");
static_assert(offsetof(FArchivesVignetteEntry, HasAudio) == 0x000038, "Member 'FArchivesVignetteEntry::HasAudio' has a wrong offset!");
static_assert(offsetof(FArchivesVignetteEntry, RewardImage) == 0x000040, "Member 'FArchivesVignetteEntry::RewardImage' has a wrong offset!");
static_assert(offsetof(FArchivesVignetteEntry, PreviewTextureOffset) == 0x000078, "Member 'FArchivesVignetteEntry::PreviewTextureOffset' has a wrong offset!");

// ScriptStruct DeadByDaylight.DailyRitualPossibleCharacters
// 0x0030 (0x0030 - 0x0000)
struct FDailyRitualPossibleCharacters final
{
public:
	TArray<int32>                                 CharacterIDs;                                      // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<EPlayerRole>                           Roles;                                             // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<EPlayerRole>                           SelectOneCharacterFromRoles;                       // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDailyRitualPossibleCharacters) == 0x000008, "Wrong alignment on FDailyRitualPossibleCharacters");
static_assert(sizeof(FDailyRitualPossibleCharacters) == 0x000030, "Wrong size on FDailyRitualPossibleCharacters");
static_assert(offsetof(FDailyRitualPossibleCharacters, CharacterIDs) == 0x000000, "Member 'FDailyRitualPossibleCharacters::CharacterIDs' has a wrong offset!");
static_assert(offsetof(FDailyRitualPossibleCharacters, Roles) == 0x000010, "Member 'FDailyRitualPossibleCharacters::Roles' has a wrong offset!");
static_assert(offsetof(FDailyRitualPossibleCharacters, SelectOneCharacterFromRoles) == 0x000020, "Member 'FDailyRitualPossibleCharacters::SelectOneCharacterFromRoles' has a wrong offset!");

// ScriptStruct DeadByDaylight.DailyRitualDefinition
// 0x00D8 (0x00E0 - 0x0008)
struct FDailyRitualDefinition final : public FDBDTableRowBase
{
public:
	class FString                                 RitualId;                                          // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   DisplayName;                                       // 0x0018(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FString                                 IconPath;                                          // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDailyRitualPossibleCharacters         PossibleCharacters;                                // 0x0058(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<EDBDScoreTypes>                        TrackedEvents;                                     // 0x0088(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FGameplayTag>                   TrackedGameEvents;                                 // 0x0098(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   Evaluator;                                         // 0x00A8(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDailyRitualDefinition) == 0x000008, "Wrong alignment on FDailyRitualDefinition");
static_assert(sizeof(FDailyRitualDefinition) == 0x0000E0, "Wrong size on FDailyRitualDefinition");
static_assert(offsetof(FDailyRitualDefinition, RitualId) == 0x000008, "Member 'FDailyRitualDefinition::RitualId' has a wrong offset!");
static_assert(offsetof(FDailyRitualDefinition, DisplayName) == 0x000018, "Member 'FDailyRitualDefinition::DisplayName' has a wrong offset!");
static_assert(offsetof(FDailyRitualDefinition, Description) == 0x000030, "Member 'FDailyRitualDefinition::Description' has a wrong offset!");
static_assert(offsetof(FDailyRitualDefinition, IconPath) == 0x000048, "Member 'FDailyRitualDefinition::IconPath' has a wrong offset!");
static_assert(offsetof(FDailyRitualDefinition, PossibleCharacters) == 0x000058, "Member 'FDailyRitualDefinition::PossibleCharacters' has a wrong offset!");
static_assert(offsetof(FDailyRitualDefinition, TrackedEvents) == 0x000088, "Member 'FDailyRitualDefinition::TrackedEvents' has a wrong offset!");
static_assert(offsetof(FDailyRitualDefinition, TrackedGameEvents) == 0x000098, "Member 'FDailyRitualDefinition::TrackedGameEvents' has a wrong offset!");
static_assert(offsetof(FDailyRitualDefinition, Evaluator) == 0x0000A8, "Member 'FDailyRitualDefinition::Evaluator' has a wrong offset!");

// ScriptStruct DeadByDaylight.CharacterDataEntitlementScope
// 0x0030 (0x0030 - 0x0000)
struct FCharacterDataEntitlementScope final
{
public:
	class FString                                 ScopeType;                                         // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ScopeValue;                                        // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              StartDate;                                         // 0x0020(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              EndDate;                                           // 0x0028(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterDataEntitlementScope) == 0x000008, "Wrong alignment on FCharacterDataEntitlementScope");
static_assert(sizeof(FCharacterDataEntitlementScope) == 0x000030, "Wrong size on FCharacterDataEntitlementScope");
static_assert(offsetof(FCharacterDataEntitlementScope, ScopeType) == 0x000000, "Member 'FCharacterDataEntitlementScope::ScopeType' has a wrong offset!");
static_assert(offsetof(FCharacterDataEntitlementScope, ScopeValue) == 0x000010, "Member 'FCharacterDataEntitlementScope::ScopeValue' has a wrong offset!");
static_assert(offsetof(FCharacterDataEntitlementScope, StartDate) == 0x000020, "Member 'FCharacterDataEntitlementScope::StartDate' has a wrong offset!");
static_assert(offsetof(FCharacterDataEntitlementScope, EndDate) == 0x000028, "Member 'FCharacterDataEntitlementScope::EndDate' has a wrong offset!");

// ScriptStruct DeadByDaylight.QuestEventData
// 0x0050 (0x0050 - 0x0000)
struct FQuestEventData final
{
public:
	class FString                                 QuestEventId;                                      // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          QuestEventId_IsSet;                                // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Repetition;                                        // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Repetition_IsSet;                                  // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Parameters;                                        // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Parameters_IsSet;                                  // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Operation;                                         // 0x0038(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Operation_IsSet;                                   // 0x0048(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FQuestEventData) == 0x000008, "Wrong alignment on FQuestEventData");
static_assert(sizeof(FQuestEventData) == 0x000050, "Wrong size on FQuestEventData");
static_assert(offsetof(FQuestEventData, QuestEventId) == 0x000000, "Member 'FQuestEventData::QuestEventId' has a wrong offset!");
static_assert(offsetof(FQuestEventData, QuestEventId_IsSet) == 0x000010, "Member 'FQuestEventData::QuestEventId_IsSet' has a wrong offset!");
static_assert(offsetof(FQuestEventData, Repetition) == 0x000014, "Member 'FQuestEventData::Repetition' has a wrong offset!");
static_assert(offsetof(FQuestEventData, Repetition_IsSet) == 0x000018, "Member 'FQuestEventData::Repetition_IsSet' has a wrong offset!");
static_assert(offsetof(FQuestEventData, Parameters) == 0x000020, "Member 'FQuestEventData::Parameters' has a wrong offset!");
static_assert(offsetof(FQuestEventData, Parameters_IsSet) == 0x000030, "Member 'FQuestEventData::Parameters_IsSet' has a wrong offset!");
static_assert(offsetof(FQuestEventData, Operation) == 0x000038, "Member 'FQuestEventData::Operation' has a wrong offset!");
static_assert(offsetof(FQuestEventData, Operation_IsSet) == 0x000048, "Member 'FQuestEventData::Operation_IsSet' has a wrong offset!");

// ScriptStruct DeadByDaylight.QuestConditionData
// 0x0020 (0x0020 - 0x0000)
struct FQuestConditionData final
{
public:
	class FString                                 Key;                                               // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         Value;                                             // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FQuestConditionData) == 0x000008, "Wrong alignment on FQuestConditionData");
static_assert(sizeof(FQuestConditionData) == 0x000020, "Wrong size on FQuestConditionData");
static_assert(offsetof(FQuestConditionData, Key) == 0x000000, "Member 'FQuestConditionData::Key' has a wrong offset!");
static_assert(offsetof(FQuestConditionData, Value) == 0x000010, "Member 'FQuestConditionData::Value' has a wrong offset!");

// ScriptStruct DeadByDaylight.OfferingTypeTexture
// 0x0038 (0x0038 - 0x0000)
struct FOfferingTypeTexture final
{
public:
	class FName                                   Type;                                              // 0x0000(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        TextureBack;                                       // 0x0010(0x0028)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOfferingTypeTexture) == 0x000008, "Wrong alignment on FOfferingTypeTexture");
static_assert(sizeof(FOfferingTypeTexture) == 0x000038, "Wrong size on FOfferingTypeTexture");
static_assert(offsetof(FOfferingTypeTexture, Type) == 0x000000, "Member 'FOfferingTypeTexture::Type' has a wrong offset!");
static_assert(offsetof(FOfferingTypeTexture, TextureBack) == 0x000010, "Member 'FOfferingTypeTexture::TextureBack' has a wrong offset!");

// ScriptStruct DeadByDaylight.PlayerSavedProfileCumulativeData
// 0x0048 (0x0048 - 0x0000)
struct FPlayerSavedProfileCumulativeData final
{
public:
	bool                                          FirstTimePlaying;                                  // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CumulativeMatches;                                 // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CumulativeMatchesLeft;                             // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CumulativeMatchesAsSurvivor;                       // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CumulativeMatchesLeftAsSurvivor;                   // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CumulativeMatchesAsKiller;                         // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CumulativeMatchesLeftAsKiller;                     // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CumulativeMatchesAsSurvivorNoFriends;              // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CumulativeMatchesAsKillerNoFriends;                // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              LastMatchTimestamp;                                // 0x0028(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              LastSessionTimestamp;                              // 0x0030(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CumulativeSessions;                                // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimespan                              CumulativePlaytime;                                // 0x0040(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerSavedProfileCumulativeData) == 0x000008, "Wrong alignment on FPlayerSavedProfileCumulativeData");
static_assert(sizeof(FPlayerSavedProfileCumulativeData) == 0x000048, "Wrong size on FPlayerSavedProfileCumulativeData");
static_assert(offsetof(FPlayerSavedProfileCumulativeData, FirstTimePlaying) == 0x000000, "Member 'FPlayerSavedProfileCumulativeData::FirstTimePlaying' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileCumulativeData, CumulativeMatches) == 0x000004, "Member 'FPlayerSavedProfileCumulativeData::CumulativeMatches' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileCumulativeData, CumulativeMatchesLeft) == 0x000008, "Member 'FPlayerSavedProfileCumulativeData::CumulativeMatchesLeft' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileCumulativeData, CumulativeMatchesAsSurvivor) == 0x00000C, "Member 'FPlayerSavedProfileCumulativeData::CumulativeMatchesAsSurvivor' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileCumulativeData, CumulativeMatchesLeftAsSurvivor) == 0x000010, "Member 'FPlayerSavedProfileCumulativeData::CumulativeMatchesLeftAsSurvivor' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileCumulativeData, CumulativeMatchesAsKiller) == 0x000014, "Member 'FPlayerSavedProfileCumulativeData::CumulativeMatchesAsKiller' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileCumulativeData, CumulativeMatchesLeftAsKiller) == 0x000018, "Member 'FPlayerSavedProfileCumulativeData::CumulativeMatchesLeftAsKiller' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileCumulativeData, CumulativeMatchesAsSurvivorNoFriends) == 0x00001C, "Member 'FPlayerSavedProfileCumulativeData::CumulativeMatchesAsSurvivorNoFriends' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileCumulativeData, CumulativeMatchesAsKillerNoFriends) == 0x000020, "Member 'FPlayerSavedProfileCumulativeData::CumulativeMatchesAsKillerNoFriends' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileCumulativeData, LastMatchTimestamp) == 0x000028, "Member 'FPlayerSavedProfileCumulativeData::LastMatchTimestamp' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileCumulativeData, LastSessionTimestamp) == 0x000030, "Member 'FPlayerSavedProfileCumulativeData::LastSessionTimestamp' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileCumulativeData, CumulativeSessions) == 0x000038, "Member 'FPlayerSavedProfileCumulativeData::CumulativeSessions' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileCumulativeData, CumulativePlaytime) == 0x000040, "Member 'FPlayerSavedProfileCumulativeData::CumulativePlaytime' has a wrong offset!");

// ScriptStruct DeadByDaylight.QuestSpecialBehaviourData
// 0x0028 (0x0028 - 0x0000)
struct FQuestSpecialBehaviourData final
{
public:
	class FString                                 ID;                                                // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Params;                                            // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Params_IsSet;                                      // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FQuestSpecialBehaviourData) == 0x000008, "Wrong alignment on FQuestSpecialBehaviourData");
static_assert(sizeof(FQuestSpecialBehaviourData) == 0x000028, "Wrong size on FQuestSpecialBehaviourData");
static_assert(offsetof(FQuestSpecialBehaviourData, ID) == 0x000000, "Member 'FQuestSpecialBehaviourData::ID' has a wrong offset!");
static_assert(offsetof(FQuestSpecialBehaviourData, Params) == 0x000010, "Member 'FQuestSpecialBehaviourData::Params' has a wrong offset!");
static_assert(offsetof(FQuestSpecialBehaviourData, Params_IsSet) == 0x000020, "Member 'FQuestSpecialBehaviourData::Params_IsSet' has a wrong offset!");

// ScriptStruct DeadByDaylight.ChallengeObjectiveData
// 0x0078 (0x0078 - 0x0000)
struct FChallengeObjectiveData final
{
public:
	class FString                                 ObjectiveId;                                       // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ObjectiveInfo;                                     // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IncrementWithEventRepetitions;                     // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 NeededProgression;                                 // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FQuestConditionData>            Conditions;                                        // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FQuestEventData>                QuestEvent;                                        // 0x0048(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          QuestEvent_IsSet;                                  // 0x0058(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FQuestSpecialBehaviourData>     SpecialBehaviours;                                 // 0x0060(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          SpecialBehaviours_IsSet;                           // 0x0070(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsCommunityObjective;                              // 0x0071(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_72[0x2];                                       // 0x0072(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxProgressionPerPlayer;                           // 0x0074(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FChallengeObjectiveData) == 0x000008, "Wrong alignment on FChallengeObjectiveData");
static_assert(sizeof(FChallengeObjectiveData) == 0x000078, "Wrong size on FChallengeObjectiveData");
static_assert(offsetof(FChallengeObjectiveData, ObjectiveId) == 0x000000, "Member 'FChallengeObjectiveData::ObjectiveId' has a wrong offset!");
static_assert(offsetof(FChallengeObjectiveData, ObjectiveInfo) == 0x000010, "Member 'FChallengeObjectiveData::ObjectiveInfo' has a wrong offset!");
static_assert(offsetof(FChallengeObjectiveData, IncrementWithEventRepetitions) == 0x000020, "Member 'FChallengeObjectiveData::IncrementWithEventRepetitions' has a wrong offset!");
static_assert(offsetof(FChallengeObjectiveData, NeededProgression) == 0x000028, "Member 'FChallengeObjectiveData::NeededProgression' has a wrong offset!");
static_assert(offsetof(FChallengeObjectiveData, Conditions) == 0x000038, "Member 'FChallengeObjectiveData::Conditions' has a wrong offset!");
static_assert(offsetof(FChallengeObjectiveData, QuestEvent) == 0x000048, "Member 'FChallengeObjectiveData::QuestEvent' has a wrong offset!");
static_assert(offsetof(FChallengeObjectiveData, QuestEvent_IsSet) == 0x000058, "Member 'FChallengeObjectiveData::QuestEvent_IsSet' has a wrong offset!");
static_assert(offsetof(FChallengeObjectiveData, SpecialBehaviours) == 0x000060, "Member 'FChallengeObjectiveData::SpecialBehaviours' has a wrong offset!");
static_assert(offsetof(FChallengeObjectiveData, SpecialBehaviours_IsSet) == 0x000070, "Member 'FChallengeObjectiveData::SpecialBehaviours_IsSet' has a wrong offset!");
static_assert(offsetof(FChallengeObjectiveData, IsCommunityObjective) == 0x000071, "Member 'FChallengeObjectiveData::IsCommunityObjective' has a wrong offset!");
static_assert(offsetof(FChallengeObjectiveData, MaxProgressionPerPlayer) == 0x000074, "Member 'FChallengeObjectiveData::MaxProgressionPerPlayer' has a wrong offset!");

// ScriptStruct DeadByDaylight.CharmDropdown
// 0x000E (0x0010 - 0x0002)
struct FCharmDropdown final : public FRoleDropdown
{
public:
	bool                                          ShowCharmSelection;                                // 0x0002(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShowCommonCharms;                                  // 0x0003(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CharmId;                                           // 0x0004(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharmDropdown) == 0x000004, "Wrong alignment on FCharmDropdown");
static_assert(sizeof(FCharmDropdown) == 0x000010, "Wrong size on FCharmDropdown");
static_assert(offsetof(FCharmDropdown, ShowCharmSelection) == 0x000002, "Member 'FCharmDropdown::ShowCharmSelection' has a wrong offset!");
static_assert(offsetof(FCharmDropdown, ShowCommonCharms) == 0x000003, "Member 'FCharmDropdown::ShowCommonCharms' has a wrong offset!");
static_assert(offsetof(FCharmDropdown, CharmId) == 0x000004, "Member 'FCharmDropdown::CharmId' has a wrong offset!");

// ScriptStruct DeadByDaylight.DebugLoadoutPerk
// 0x0014 (0x0014 - 0x0000)
struct FDebugLoadoutPerk final
{
public:
	struct FPerkDropdown                          PerkDropdown;                                      // 0x0000(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         PerkLevel;                                         // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDebugLoadoutPerk) == 0x000004, "Wrong alignment on FDebugLoadoutPerk");
static_assert(sizeof(FDebugLoadoutPerk) == 0x000014, "Wrong size on FDebugLoadoutPerk");
static_assert(offsetof(FDebugLoadoutPerk, PerkDropdown) == 0x000000, "Member 'FDebugLoadoutPerk::PerkDropdown' has a wrong offset!");
static_assert(offsetof(FDebugLoadoutPerk, PerkLevel) == 0x000010, "Member 'FDebugLoadoutPerk::PerkLevel' has a wrong offset!");

// ScriptStruct DeadByDaylight.DebugLoadoutAddon
// 0x0010 (0x0010 - 0x0000)
struct FDebugLoadoutAddon final
{
public:
	struct FAddonDropdown                         AddonDropdown;                                     // 0x0000(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDebugLoadoutAddon) == 0x000004, "Wrong alignment on FDebugLoadoutAddon");
static_assert(sizeof(FDebugLoadoutAddon) == 0x000010, "Wrong size on FDebugLoadoutAddon");
static_assert(offsetof(FDebugLoadoutAddon, AddonDropdown) == 0x000000, "Member 'FDebugLoadoutAddon::AddonDropdown' has a wrong offset!");

// ScriptStruct DeadByDaylight.CharacterCustomizationDropdown
// 0x0054 (0x005C - 0x0008)
struct FCharacterCustomizationDropdown final : public FCharacterDropdown
{
public:
	class FName                                   OutfitId;                                          // 0x0008(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SurvivorHead;                                      // 0x0014(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SurvivorTorso;                                     // 0x0020(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SurvivorLegs;                                      // 0x002C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   KillerHead;                                        // 0x0038(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   KillerBody;                                        // 0x0044(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   KillerWeapon;                                      // 0x0050(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterCustomizationDropdown) == 0x000004, "Wrong alignment on FCharacterCustomizationDropdown");
static_assert(sizeof(FCharacterCustomizationDropdown) == 0x00005C, "Wrong size on FCharacterCustomizationDropdown");
static_assert(offsetof(FCharacterCustomizationDropdown, OutfitId) == 0x000008, "Member 'FCharacterCustomizationDropdown::OutfitId' has a wrong offset!");
static_assert(offsetof(FCharacterCustomizationDropdown, SurvivorHead) == 0x000014, "Member 'FCharacterCustomizationDropdown::SurvivorHead' has a wrong offset!");
static_assert(offsetof(FCharacterCustomizationDropdown, SurvivorTorso) == 0x000020, "Member 'FCharacterCustomizationDropdown::SurvivorTorso' has a wrong offset!");
static_assert(offsetof(FCharacterCustomizationDropdown, SurvivorLegs) == 0x00002C, "Member 'FCharacterCustomizationDropdown::SurvivorLegs' has a wrong offset!");
static_assert(offsetof(FCharacterCustomizationDropdown, KillerHead) == 0x000038, "Member 'FCharacterCustomizationDropdown::KillerHead' has a wrong offset!");
static_assert(offsetof(FCharacterCustomizationDropdown, KillerBody) == 0x000044, "Member 'FCharacterCustomizationDropdown::KillerBody' has a wrong offset!");
static_assert(offsetof(FCharacterCustomizationDropdown, KillerWeapon) == 0x000050, "Member 'FCharacterCustomizationDropdown::KillerWeapon' has a wrong offset!");

// ScriptStruct DeadByDaylight.OfferingDropdown
// 0x000E (0x0010 - 0x0002)
struct FOfferingDropdown final : public FRoleDropdown
{
public:
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   OfferingID;                                        // 0x0004(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOfferingDropdown) == 0x000004, "Wrong alignment on FOfferingDropdown");
static_assert(sizeof(FOfferingDropdown) == 0x000010, "Wrong size on FOfferingDropdown");
static_assert(offsetof(FOfferingDropdown, OfferingID) == 0x000004, "Member 'FOfferingDropdown::OfferingID' has a wrong offset!");

// ScriptStruct DeadByDaylight.SlasherLoadout
// 0x00D0 (0x00D0 - 0x0000)
struct FSlasherLoadout final
{
public:
	struct FCharmDropdown                         Slot0_CharmID;                                     // 0x0000(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FCharmDropdown                         Slot1_CharmID;                                     // 0x0010(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FCharmDropdown                         Slot2_CharmID;                                     // 0x0020(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FDebugLoadoutPerk>              Perks;                                             // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FDebugLoadoutAddon>             PowerAddonIDs;                                     // 0x0040(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FCharacterCustomizationDropdown        Slasher;                                           // 0x0050(0x005C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FOfferingDropdown                      Offering;                                          // 0x00AC(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FCharacterClassDropdown                CharacterClass;                                    // 0x00BC(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_CC[0x4];                                       // 0x00CC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSlasherLoadout) == 0x000008, "Wrong alignment on FSlasherLoadout");
static_assert(sizeof(FSlasherLoadout) == 0x0000D0, "Wrong size on FSlasherLoadout");
static_assert(offsetof(FSlasherLoadout, Slot0_CharmID) == 0x000000, "Member 'FSlasherLoadout::Slot0_CharmID' has a wrong offset!");
static_assert(offsetof(FSlasherLoadout, Slot1_CharmID) == 0x000010, "Member 'FSlasherLoadout::Slot1_CharmID' has a wrong offset!");
static_assert(offsetof(FSlasherLoadout, Slot2_CharmID) == 0x000020, "Member 'FSlasherLoadout::Slot2_CharmID' has a wrong offset!");
static_assert(offsetof(FSlasherLoadout, Perks) == 0x000030, "Member 'FSlasherLoadout::Perks' has a wrong offset!");
static_assert(offsetof(FSlasherLoadout, PowerAddonIDs) == 0x000040, "Member 'FSlasherLoadout::PowerAddonIDs' has a wrong offset!");
static_assert(offsetof(FSlasherLoadout, Slasher) == 0x000050, "Member 'FSlasherLoadout::Slasher' has a wrong offset!");
static_assert(offsetof(FSlasherLoadout, Offering) == 0x0000AC, "Member 'FSlasherLoadout::Offering' has a wrong offset!");
static_assert(offsetof(FSlasherLoadout, CharacterClass) == 0x0000BC, "Member 'FSlasherLoadout::CharacterClass' has a wrong offset!");

// ScriptStruct DeadByDaylight.ChallengeData
// 0x00F0 (0x00F0 - 0x0000)
struct FChallengeData final
{
public:
	class FString                                 ID;                                                // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TitleStringId;                                     // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TitleStringId_IsSet;                               // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DescriptionStringId;                               // 0x0028(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DescriptionStringId_IsSet;                         // 0x0038(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LifetimeInDays;                                    // 0x003C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          LifetimeInDays_IsSet;                              // 0x0040(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, struct FChallengeObjectiveData> Objectives;                                        // 0x0048(0x0050)(NativeAccessSpecifierPublic)
	int32                                         RewardPoints;                                      // 0x0098(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RewardPoints_IsSet;                                // 0x009C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9D[0x3];                                       // 0x009D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRewardResponseItem>            Rewards;                                           // 0x00A0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          Rewards_IsSet;                                     // 0x00B0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0x7];                                       // 0x00B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Type;                                              // 0x00B8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 StartDate;                                         // 0x00C8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 EndDate;                                           // 0x00D8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerRole                                   RoleType;                                          // 0x00E8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RoleType_IsSet;                                    // 0x00E9(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EA[0x6];                                       // 0x00EA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FChallengeData) == 0x000008, "Wrong alignment on FChallengeData");
static_assert(sizeof(FChallengeData) == 0x0000F0, "Wrong size on FChallengeData");
static_assert(offsetof(FChallengeData, ID) == 0x000000, "Member 'FChallengeData::ID' has a wrong offset!");
static_assert(offsetof(FChallengeData, TitleStringId) == 0x000010, "Member 'FChallengeData::TitleStringId' has a wrong offset!");
static_assert(offsetof(FChallengeData, TitleStringId_IsSet) == 0x000020, "Member 'FChallengeData::TitleStringId_IsSet' has a wrong offset!");
static_assert(offsetof(FChallengeData, DescriptionStringId) == 0x000028, "Member 'FChallengeData::DescriptionStringId' has a wrong offset!");
static_assert(offsetof(FChallengeData, DescriptionStringId_IsSet) == 0x000038, "Member 'FChallengeData::DescriptionStringId_IsSet' has a wrong offset!");
static_assert(offsetof(FChallengeData, LifetimeInDays) == 0x00003C, "Member 'FChallengeData::LifetimeInDays' has a wrong offset!");
static_assert(offsetof(FChallengeData, LifetimeInDays_IsSet) == 0x000040, "Member 'FChallengeData::LifetimeInDays_IsSet' has a wrong offset!");
static_assert(offsetof(FChallengeData, Objectives) == 0x000048, "Member 'FChallengeData::Objectives' has a wrong offset!");
static_assert(offsetof(FChallengeData, RewardPoints) == 0x000098, "Member 'FChallengeData::RewardPoints' has a wrong offset!");
static_assert(offsetof(FChallengeData, RewardPoints_IsSet) == 0x00009C, "Member 'FChallengeData::RewardPoints_IsSet' has a wrong offset!");
static_assert(offsetof(FChallengeData, Rewards) == 0x0000A0, "Member 'FChallengeData::Rewards' has a wrong offset!");
static_assert(offsetof(FChallengeData, Rewards_IsSet) == 0x0000B0, "Member 'FChallengeData::Rewards_IsSet' has a wrong offset!");
static_assert(offsetof(FChallengeData, Type) == 0x0000B8, "Member 'FChallengeData::Type' has a wrong offset!");
static_assert(offsetof(FChallengeData, StartDate) == 0x0000C8, "Member 'FChallengeData::StartDate' has a wrong offset!");
static_assert(offsetof(FChallengeData, EndDate) == 0x0000D8, "Member 'FChallengeData::EndDate' has a wrong offset!");
static_assert(offsetof(FChallengeData, RoleType) == 0x0000E8, "Member 'FChallengeData::RoleType' has a wrong offset!");
static_assert(offsetof(FChallengeData, RoleType_IsSet) == 0x0000E9, "Member 'FChallengeData::RoleType_IsSet' has a wrong offset!");

// ScriptStruct DeadByDaylight.ChallengeSetData
// 0x0120 (0x0120 - 0x0000)
struct FChallengeSetData final
{
public:
	EChallengeSetType                             Type;                                              // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Type_IsSet;                                        // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 StartDate;                                         // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 EndDate;                                           // 0x0018(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 RewardTrackerId;                                   // 0x0028(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RewardTrackerId_IsSet;                             // 0x0038(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxCount;                                          // 0x003C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MaxCount_IsSet;                                    // 0x0040(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FChallengeData>                 Challenges;                                        // 0x0048(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 TabIconPath;                                       // 0x0058(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TabIconPath_IsSet;                                 // 0x0068(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 TabTitleStringId;                                  // 0x0070(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TabOrder;                                          // 0x0080(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_84[0x4];                                       // 0x0084(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 HeaderIconPath;                                    // 0x0088(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HeaderIconPath_IsSet;                              // 0x0098(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 HeaderTitleStringId;                               // 0x00A0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HeaderTitleStringId_IsSet;                         // 0x00B0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0x7];                                       // 0x00B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 HeaderSubtitleStringId;                            // 0x00B8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HeaderSubtitleStringId_IsSet;                      // 0x00C8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C9[0x7];                                       // 0x00C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 AdditionalInfoStringId;                            // 0x00D0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AdditionalInfoStringId_IsSet;                      // 0x00E0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E1[0x7];                                       // 0x00E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 EventID;                                           // 0x00E8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EventId_IsSet;                                     // 0x00F8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F9[0x27];                                      // 0x00F9(0x0027)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FChallengeSetData) == 0x000008, "Wrong alignment on FChallengeSetData");
static_assert(sizeof(FChallengeSetData) == 0x000120, "Wrong size on FChallengeSetData");
static_assert(offsetof(FChallengeSetData, Type) == 0x000000, "Member 'FChallengeSetData::Type' has a wrong offset!");
static_assert(offsetof(FChallengeSetData, Type_IsSet) == 0x000001, "Member 'FChallengeSetData::Type_IsSet' has a wrong offset!");
static_assert(offsetof(FChallengeSetData, StartDate) == 0x000008, "Member 'FChallengeSetData::StartDate' has a wrong offset!");
static_assert(offsetof(FChallengeSetData, EndDate) == 0x000018, "Member 'FChallengeSetData::EndDate' has a wrong offset!");
static_assert(offsetof(FChallengeSetData, RewardTrackerId) == 0x000028, "Member 'FChallengeSetData::RewardTrackerId' has a wrong offset!");
static_assert(offsetof(FChallengeSetData, RewardTrackerId_IsSet) == 0x000038, "Member 'FChallengeSetData::RewardTrackerId_IsSet' has a wrong offset!");
static_assert(offsetof(FChallengeSetData, MaxCount) == 0x00003C, "Member 'FChallengeSetData::MaxCount' has a wrong offset!");
static_assert(offsetof(FChallengeSetData, MaxCount_IsSet) == 0x000040, "Member 'FChallengeSetData::MaxCount_IsSet' has a wrong offset!");
static_assert(offsetof(FChallengeSetData, Challenges) == 0x000048, "Member 'FChallengeSetData::Challenges' has a wrong offset!");
static_assert(offsetof(FChallengeSetData, TabIconPath) == 0x000058, "Member 'FChallengeSetData::TabIconPath' has a wrong offset!");
static_assert(offsetof(FChallengeSetData, TabIconPath_IsSet) == 0x000068, "Member 'FChallengeSetData::TabIconPath_IsSet' has a wrong offset!");
static_assert(offsetof(FChallengeSetData, TabTitleStringId) == 0x000070, "Member 'FChallengeSetData::TabTitleStringId' has a wrong offset!");
static_assert(offsetof(FChallengeSetData, TabOrder) == 0x000080, "Member 'FChallengeSetData::TabOrder' has a wrong offset!");
static_assert(offsetof(FChallengeSetData, HeaderIconPath) == 0x000088, "Member 'FChallengeSetData::HeaderIconPath' has a wrong offset!");
static_assert(offsetof(FChallengeSetData, HeaderIconPath_IsSet) == 0x000098, "Member 'FChallengeSetData::HeaderIconPath_IsSet' has a wrong offset!");
static_assert(offsetof(FChallengeSetData, HeaderTitleStringId) == 0x0000A0, "Member 'FChallengeSetData::HeaderTitleStringId' has a wrong offset!");
static_assert(offsetof(FChallengeSetData, HeaderTitleStringId_IsSet) == 0x0000B0, "Member 'FChallengeSetData::HeaderTitleStringId_IsSet' has a wrong offset!");
static_assert(offsetof(FChallengeSetData, HeaderSubtitleStringId) == 0x0000B8, "Member 'FChallengeSetData::HeaderSubtitleStringId' has a wrong offset!");
static_assert(offsetof(FChallengeSetData, HeaderSubtitleStringId_IsSet) == 0x0000C8, "Member 'FChallengeSetData::HeaderSubtitleStringId_IsSet' has a wrong offset!");
static_assert(offsetof(FChallengeSetData, AdditionalInfoStringId) == 0x0000D0, "Member 'FChallengeSetData::AdditionalInfoStringId' has a wrong offset!");
static_assert(offsetof(FChallengeSetData, AdditionalInfoStringId_IsSet) == 0x0000E0, "Member 'FChallengeSetData::AdditionalInfoStringId_IsSet' has a wrong offset!");
static_assert(offsetof(FChallengeSetData, EventID) == 0x0000E8, "Member 'FChallengeSetData::EventID' has a wrong offset!");
static_assert(offsetof(FChallengeSetData, EventId_IsSet) == 0x0000F8, "Member 'FChallengeSetData::EventId_IsSet' has a wrong offset!");

// ScriptStruct DeadByDaylight.UIViewFlagSaveData
// 0x00F8 (0x00F8 - 0x0000)
struct FUIViewFlagSaveData final
{
public:
	TMap<class FString, bool>                     CharactersFirstBloodweb;                           // 0x0000(0x0050)(SaveGame, NativeAccessSpecifierPrivate)
	bool                                          BloodwebCenterButtonUnlocked;                      // 0x0050(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, bool>                     ArchiveStoryHasBeenSeenStatus;                     // 0x0058(0x0050)(SaveGame, NativeAccessSpecifierPrivate)
	TMap<class FString, bool>                     ArchiveNewTomeAnimationHasBeenSeenStatus;          // 0x00A8(0x0050)(SaveGame, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FUIViewFlagSaveData) == 0x000008, "Wrong alignment on FUIViewFlagSaveData");
static_assert(sizeof(FUIViewFlagSaveData) == 0x0000F8, "Wrong size on FUIViewFlagSaveData");
static_assert(offsetof(FUIViewFlagSaveData, CharactersFirstBloodweb) == 0x000000, "Member 'FUIViewFlagSaveData::CharactersFirstBloodweb' has a wrong offset!");
static_assert(offsetof(FUIViewFlagSaveData, BloodwebCenterButtonUnlocked) == 0x000050, "Member 'FUIViewFlagSaveData::BloodwebCenterButtonUnlocked' has a wrong offset!");
static_assert(offsetof(FUIViewFlagSaveData, ArchiveStoryHasBeenSeenStatus) == 0x000058, "Member 'FUIViewFlagSaveData::ArchiveStoryHasBeenSeenStatus' has a wrong offset!");
static_assert(offsetof(FUIViewFlagSaveData, ArchiveNewTomeAnimationHasBeenSeenStatus) == 0x0000A8, "Member 'FUIViewFlagSaveData::ArchiveNewTomeAnimationHasBeenSeenStatus' has a wrong offset!");

// ScriptStruct DeadByDaylight.ChallengeRewardsData
// 0x0020 (0x0020 - 0x0000)
struct FChallengeRewardsData final
{
public:
	class FString                                 ChallengeId;                                       // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FRewardItem>                    Rewards;                                           // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FChallengeRewardsData) == 0x000008, "Wrong alignment on FChallengeRewardsData");
static_assert(sizeof(FChallengeRewardsData) == 0x000020, "Wrong size on FChallengeRewardsData");
static_assert(offsetof(FChallengeRewardsData, ChallengeId) == 0x000000, "Member 'FChallengeRewardsData::ChallengeId' has a wrong offset!");
static_assert(offsetof(FChallengeRewardsData, Rewards) == 0x000010, "Member 'FChallengeRewardsData::Rewards' has a wrong offset!");

// ScriptStruct DeadByDaylight.ChallengeListItem
// 0x0030 (0x0030 - 0x0000)
struct FChallengeListItem final
{
public:
	TArray<struct FChallengeRewardsData>          Challenges;                                        // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         LifetimeInDaysOverride;                            // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RewardPointsOverride;                              // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              ListStartDate;                                     // 0x0018(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              ListEndDate;                                       // 0x0020(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EChallengeSetType                             Type;                                              // 0x0028(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FChallengeListItem) == 0x000008, "Wrong alignment on FChallengeListItem");
static_assert(sizeof(FChallengeListItem) == 0x000030, "Wrong size on FChallengeListItem");
static_assert(offsetof(FChallengeListItem, Challenges) == 0x000000, "Member 'FChallengeListItem::Challenges' has a wrong offset!");
static_assert(offsetof(FChallengeListItem, LifetimeInDaysOverride) == 0x000010, "Member 'FChallengeListItem::LifetimeInDaysOverride' has a wrong offset!");
static_assert(offsetof(FChallengeListItem, RewardPointsOverride) == 0x000014, "Member 'FChallengeListItem::RewardPointsOverride' has a wrong offset!");
static_assert(offsetof(FChallengeListItem, ListStartDate) == 0x000018, "Member 'FChallengeListItem::ListStartDate' has a wrong offset!");
static_assert(offsetof(FChallengeListItem, ListEndDate) == 0x000020, "Member 'FChallengeListItem::ListEndDate' has a wrong offset!");
static_assert(offsetof(FChallengeListItem, Type) == 0x000028, "Member 'FChallengeListItem::Type' has a wrong offset!");

// ScriptStruct DeadByDaylight.ChallengeSetEditorData
// 0x0110 (0x0118 - 0x0008)
struct FChallengeSetEditorData final : public FDBDTableRowBase
{
public:
	class FString                                 ID;                                                // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TabOrder;                                          // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   TabTitleStringId;                                  // 0x0020(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        TabIconPath;                                       // 0x0038(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   HeaderTitleStringId;                               // 0x0060(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        HeaderIconPath;                                    // 0x0078(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   HeaderSubtitleStringId;                            // 0x00A0(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   AdditionalInfoStringId;                            // 0x00B8(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FString                                 RewardTrackerId;                                   // 0x00D0(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 EventID;                                           // 0x00E0(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              SetStartDate;                                      // 0x00F0(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              SetEndDate;                                        // 0x00F8(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RecurringMaxCount;                                 // 0x0100(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EChallengeSetType                             Type;                                              // 0x0104(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_105[0x3];                                      // 0x0105(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FChallengeListItem>             ChallengeLists;                                    // 0x0108(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FChallengeSetEditorData) == 0x000008, "Wrong alignment on FChallengeSetEditorData");
static_assert(sizeof(FChallengeSetEditorData) == 0x000118, "Wrong size on FChallengeSetEditorData");
static_assert(offsetof(FChallengeSetEditorData, ID) == 0x000008, "Member 'FChallengeSetEditorData::ID' has a wrong offset!");
static_assert(offsetof(FChallengeSetEditorData, TabOrder) == 0x000018, "Member 'FChallengeSetEditorData::TabOrder' has a wrong offset!");
static_assert(offsetof(FChallengeSetEditorData, TabTitleStringId) == 0x000020, "Member 'FChallengeSetEditorData::TabTitleStringId' has a wrong offset!");
static_assert(offsetof(FChallengeSetEditorData, TabIconPath) == 0x000038, "Member 'FChallengeSetEditorData::TabIconPath' has a wrong offset!");
static_assert(offsetof(FChallengeSetEditorData, HeaderTitleStringId) == 0x000060, "Member 'FChallengeSetEditorData::HeaderTitleStringId' has a wrong offset!");
static_assert(offsetof(FChallengeSetEditorData, HeaderIconPath) == 0x000078, "Member 'FChallengeSetEditorData::HeaderIconPath' has a wrong offset!");
static_assert(offsetof(FChallengeSetEditorData, HeaderSubtitleStringId) == 0x0000A0, "Member 'FChallengeSetEditorData::HeaderSubtitleStringId' has a wrong offset!");
static_assert(offsetof(FChallengeSetEditorData, AdditionalInfoStringId) == 0x0000B8, "Member 'FChallengeSetEditorData::AdditionalInfoStringId' has a wrong offset!");
static_assert(offsetof(FChallengeSetEditorData, RewardTrackerId) == 0x0000D0, "Member 'FChallengeSetEditorData::RewardTrackerId' has a wrong offset!");
static_assert(offsetof(FChallengeSetEditorData, EventID) == 0x0000E0, "Member 'FChallengeSetEditorData::EventID' has a wrong offset!");
static_assert(offsetof(FChallengeSetEditorData, SetStartDate) == 0x0000F0, "Member 'FChallengeSetEditorData::SetStartDate' has a wrong offset!");
static_assert(offsetof(FChallengeSetEditorData, SetEndDate) == 0x0000F8, "Member 'FChallengeSetEditorData::SetEndDate' has a wrong offset!");
static_assert(offsetof(FChallengeSetEditorData, RecurringMaxCount) == 0x000100, "Member 'FChallengeSetEditorData::RecurringMaxCount' has a wrong offset!");
static_assert(offsetof(FChallengeSetEditorData, Type) == 0x000104, "Member 'FChallengeSetEditorData::Type' has a wrong offset!");
static_assert(offsetof(FChallengeSetEditorData, ChallengeLists) == 0x000108, "Member 'FChallengeSetEditorData::ChallengeLists' has a wrong offset!");

// ScriptStruct DeadByDaylight.RarityTexture
// 0x0038 (0x0038 - 0x0000)
struct FRarityTexture final
{
public:
	class FName                                   Type;                                              // 0x0000(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemRarity                                   Rarity;                                            // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        Texture;                                           // 0x0010(0x0028)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRarityTexture) == 0x000008, "Wrong alignment on FRarityTexture");
static_assert(sizeof(FRarityTexture) == 0x000038, "Wrong size on FRarityTexture");
static_assert(offsetof(FRarityTexture, Type) == 0x000000, "Member 'FRarityTexture::Type' has a wrong offset!");
static_assert(offsetof(FRarityTexture, Rarity) == 0x00000C, "Member 'FRarityTexture::Rarity' has a wrong offset!");
static_assert(offsetof(FRarityTexture, Texture) == 0x000010, "Member 'FRarityTexture::Texture' has a wrong offset!");

// ScriptStruct DeadByDaylight.SavedSeenPopupData
// 0x0018 (0x0018 - 0x0000)
struct FSavedSeenPopupData final
{
public:
	struct FDateTime                              LastSeenDate;                                      // 0x0000(0x0008)(ZeroConstructor, SaveGame, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LastSeenCumulativeSession;                         // 0x0008(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TimesSeen;                                         // 0x000C(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NeverShowAgain;                                    // 0x0010(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSavedSeenPopupData) == 0x000008, "Wrong alignment on FSavedSeenPopupData");
static_assert(sizeof(FSavedSeenPopupData) == 0x000018, "Wrong size on FSavedSeenPopupData");
static_assert(offsetof(FSavedSeenPopupData, LastSeenDate) == 0x000000, "Member 'FSavedSeenPopupData::LastSeenDate' has a wrong offset!");
static_assert(offsetof(FSavedSeenPopupData, LastSeenCumulativeSession) == 0x000008, "Member 'FSavedSeenPopupData::LastSeenCumulativeSession' has a wrong offset!");
static_assert(offsetof(FSavedSeenPopupData, TimesSeen) == 0x00000C, "Member 'FSavedSeenPopupData::TimesSeen' has a wrong offset!");
static_assert(offsetof(FSavedSeenPopupData, NeverShowAgain) == 0x000010, "Member 'FSavedSeenPopupData::NeverShowAgain' has a wrong offset!");

// ScriptStruct DeadByDaylight.OnScreenDebugInfo
// 0x0048 (0x0048 - 0x0000)
struct FOnScreenDebugInfo final
{
public:
	class FString                                 Message;                                           // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 Color;                                             // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	uint64                                        Key;                                               // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeToDisplay;                                     // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsDrawDebug;                                       // 0x0024(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                DrawDebugLocation;                                 // 0x0028(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOnScreenDebugInfo) == 0x000008, "Wrong alignment on FOnScreenDebugInfo");
static_assert(sizeof(FOnScreenDebugInfo) == 0x000048, "Wrong size on FOnScreenDebugInfo");
static_assert(offsetof(FOnScreenDebugInfo, Message) == 0x000000, "Member 'FOnScreenDebugInfo::Message' has a wrong offset!");
static_assert(offsetof(FOnScreenDebugInfo, Color) == 0x000010, "Member 'FOnScreenDebugInfo::Color' has a wrong offset!");
static_assert(offsetof(FOnScreenDebugInfo, Key) == 0x000018, "Member 'FOnScreenDebugInfo::Key' has a wrong offset!");
static_assert(offsetof(FOnScreenDebugInfo, TimeToDisplay) == 0x000020, "Member 'FOnScreenDebugInfo::TimeToDisplay' has a wrong offset!");
static_assert(offsetof(FOnScreenDebugInfo, IsDrawDebug) == 0x000024, "Member 'FOnScreenDebugInfo::IsDrawDebug' has a wrong offset!");
static_assert(offsetof(FOnScreenDebugInfo, DrawDebugLocation) == 0x000028, "Member 'FOnScreenDebugInfo::DrawDebugLocation' has a wrong offset!");

// ScriptStruct DeadByDaylight.SaveDataBase
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FSaveDataBase
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         VersionNumber;                                     // 0x0008(0x0004)(ZeroConstructor, SaveGame, NoClear, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSaveDataBase) == 0x000008, "Wrong alignment on FSaveDataBase");
static_assert(sizeof(FSaveDataBase) == 0x000010, "Wrong size on FSaveDataBase");
static_assert(offsetof(FSaveDataBase, VersionNumber) == 0x000008, "Member 'FSaveDataBase::VersionNumber' has a wrong offset!");

// ScriptStruct DeadByDaylight.SeenChallengeDataSaved
// 0x0050 (0x0060 - 0x0010)
struct FSeenChallengeDataSaved final : public FSaveDataBase
{
public:
	TMap<class FString, class FString>            SeenChallengeSets;                                 // 0x0010(0x0050)(SaveGame, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSeenChallengeDataSaved) == 0x000008, "Wrong alignment on FSeenChallengeDataSaved");
static_assert(sizeof(FSeenChallengeDataSaved) == 0x000060, "Wrong size on FSeenChallengeDataSaved");
static_assert(offsetof(FSeenChallengeDataSaved, SeenChallengeSets) == 0x000010, "Member 'FSeenChallengeDataSaved::SeenChallengeSets' has a wrong offset!");

// ScriptStruct DeadByDaylight.CharacterAnimationAssetDropdown
// 0x0018 (0x0018 - 0x0000)
struct FCharacterAnimationAssetDropdown
{
public:
	bool                                          IsAnimBP;                                          // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 AnimAsset;                                         // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterAnimationAssetDropdown) == 0x000008, "Wrong alignment on FCharacterAnimationAssetDropdown");
static_assert(sizeof(FCharacterAnimationAssetDropdown) == 0x000018, "Wrong size on FCharacterAnimationAssetDropdown");
static_assert(offsetof(FCharacterAnimationAssetDropdown, IsAnimBP) == 0x000000, "Member 'FCharacterAnimationAssetDropdown::IsAnimBP' has a wrong offset!");
static_assert(offsetof(FCharacterAnimationAssetDropdown, AnimAsset) == 0x000008, "Member 'FCharacterAnimationAssetDropdown::AnimAsset' has a wrong offset!");

// ScriptStruct DeadByDaylight.EmblemProgressionDescriptionByQuality
// 0x0020 (0x0020 - 0x0000)
struct FEmblemProgressionDescriptionByQuality final
{
public:
	EEmblemQuality                                EmblemQuality;                                     // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Description;                                       // 0x0008(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEmblemProgressionDescriptionByQuality) == 0x000008, "Wrong alignment on FEmblemProgressionDescriptionByQuality");
static_assert(sizeof(FEmblemProgressionDescriptionByQuality) == 0x000020, "Wrong size on FEmblemProgressionDescriptionByQuality");
static_assert(offsetof(FEmblemProgressionDescriptionByQuality, EmblemQuality) == 0x000000, "Member 'FEmblemProgressionDescriptionByQuality::EmblemQuality' has a wrong offset!");
static_assert(offsetof(FEmblemProgressionDescriptionByQuality, Description) == 0x000008, "Member 'FEmblemProgressionDescriptionByQuality::Description' has a wrong offset!");

// ScriptStruct DeadByDaylight.CharacterAnimationAssetOutfitOverride
// 0x0028 (0x0040 - 0x0018)
struct FCharacterAnimationAssetOutfitOverride final : public FCharacterAnimationAssetDropdown
{
public:
	class FName                                   OutfitId;                                          // 0x0018(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCharacterAnimationAssetDropdown       IndividualPiecesAnim;                              // 0x0028(0x0018)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterAnimationAssetOutfitOverride) == 0x000008, "Wrong alignment on FCharacterAnimationAssetOutfitOverride");
static_assert(sizeof(FCharacterAnimationAssetOutfitOverride) == 0x000040, "Wrong size on FCharacterAnimationAssetOutfitOverride");
static_assert(offsetof(FCharacterAnimationAssetOutfitOverride, OutfitId) == 0x000018, "Member 'FCharacterAnimationAssetOutfitOverride::OutfitId' has a wrong offset!");
static_assert(offsetof(FCharacterAnimationAssetOutfitOverride, IndividualPiecesAnim) == 0x000028, "Member 'FCharacterAnimationAssetOutfitOverride::IndividualPiecesAnim' has a wrong offset!");

// ScriptStruct DeadByDaylight.CharacterAnimationDropdownData
// 0x0018 (0x0018 - 0x0000)
struct FCharacterAnimationDropdownData final
{
public:
	bool                                          IsAnimBP;                                          // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 AnimAsset;                                         // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterAnimationDropdownData) == 0x000008, "Wrong alignment on FCharacterAnimationDropdownData");
static_assert(sizeof(FCharacterAnimationDropdownData) == 0x000018, "Wrong size on FCharacterAnimationDropdownData");
static_assert(offsetof(FCharacterAnimationDropdownData, IsAnimBP) == 0x000000, "Member 'FCharacterAnimationDropdownData::IsAnimBP' has a wrong offset!");
static_assert(offsetof(FCharacterAnimationDropdownData, AnimAsset) == 0x000008, "Member 'FCharacterAnimationDropdownData::AnimAsset' has a wrong offset!");

// ScriptStruct DeadByDaylight.LevelUpDetails
// 0x0050 (0x0058 - 0x0008)
struct FLevelUpDetails final : public FDBDTableRowBase
{
public:
	int32                                         Level;                                             // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Prestige;                                          // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Title;                                             // 0x0010(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0028(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FName                                   ItemId;                                            // 0x0040(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInventoryItemType                            ItemType;                                          // 0x004C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AssociatedCharacter;                               // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLevelUpDetails) == 0x000008, "Wrong alignment on FLevelUpDetails");
static_assert(sizeof(FLevelUpDetails) == 0x000058, "Wrong size on FLevelUpDetails");
static_assert(offsetof(FLevelUpDetails, Level) == 0x000008, "Member 'FLevelUpDetails::Level' has a wrong offset!");
static_assert(offsetof(FLevelUpDetails, Prestige) == 0x00000C, "Member 'FLevelUpDetails::Prestige' has a wrong offset!");
static_assert(offsetof(FLevelUpDetails, Title) == 0x000010, "Member 'FLevelUpDetails::Title' has a wrong offset!");
static_assert(offsetof(FLevelUpDetails, Description) == 0x000028, "Member 'FLevelUpDetails::Description' has a wrong offset!");
static_assert(offsetof(FLevelUpDetails, ItemId) == 0x000040, "Member 'FLevelUpDetails::ItemId' has a wrong offset!");
static_assert(offsetof(FLevelUpDetails, ItemType) == 0x00004C, "Member 'FLevelUpDetails::ItemType' has a wrong offset!");
static_assert(offsetof(FLevelUpDetails, AssociatedCharacter) == 0x000050, "Member 'FLevelUpDetails::AssociatedCharacter' has a wrong offset!");

// ScriptStruct DeadByDaylight.RoleItemCategoryDropdown
// 0x0004 (0x000C - 0x0008)
struct FRoleItemCategoryDropdown : public FCharacterDropdown
{
public:
	bool                                          IncludeOutfits;                                    // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IncludeNone;                                       // 0x0009(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECustomizationCategory                        Category;                                          // 0x000A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B[0x1];                                        // 0x000B(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRoleItemCategoryDropdown) == 0x000004, "Wrong alignment on FRoleItemCategoryDropdown");
static_assert(sizeof(FRoleItemCategoryDropdown) == 0x00000C, "Wrong size on FRoleItemCategoryDropdown");
static_assert(offsetof(FRoleItemCategoryDropdown, IncludeOutfits) == 0x000008, "Member 'FRoleItemCategoryDropdown::IncludeOutfits' has a wrong offset!");
static_assert(offsetof(FRoleItemCategoryDropdown, IncludeNone) == 0x000009, "Member 'FRoleItemCategoryDropdown::IncludeNone' has a wrong offset!");
static_assert(offsetof(FRoleItemCategoryDropdown, Category) == 0x00000A, "Member 'FRoleItemCategoryDropdown::Category' has a wrong offset!");

// ScriptStruct DeadByDaylight.CharacterAnimationDropdown
// 0x002C (0x0038 - 0x000C)
struct FCharacterAnimationDropdown final : public FRoleItemCategoryDropdown
{
public:
	bool                                          IncludeAllAnimations;                              // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsAnimBP;                                          // 0x000D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E[0x2];                                        // 0x000E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 AnimAsset;                                         // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCharacterAnimationDropdownData        AnimRest;                                          // 0x0020(0x0018)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterAnimationDropdown) == 0x000008, "Wrong alignment on FCharacterAnimationDropdown");
static_assert(sizeof(FCharacterAnimationDropdown) == 0x000038, "Wrong size on FCharacterAnimationDropdown");
static_assert(offsetof(FCharacterAnimationDropdown, IncludeAllAnimations) == 0x00000C, "Member 'FCharacterAnimationDropdown::IncludeAllAnimations' has a wrong offset!");
static_assert(offsetof(FCharacterAnimationDropdown, IsAnimBP) == 0x00000D, "Member 'FCharacterAnimationDropdown::IsAnimBP' has a wrong offset!");
static_assert(offsetof(FCharacterAnimationDropdown, AnimAsset) == 0x000010, "Member 'FCharacterAnimationDropdown::AnimAsset' has a wrong offset!");
static_assert(offsetof(FCharacterAnimationDropdown, AnimRest) == 0x000020, "Member 'FCharacterAnimationDropdown::AnimRest' has a wrong offset!");

// ScriptStruct DeadByDaylight.DBDQueueTimeInfo
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x04) FDBDQueueTimeInfo final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDBDQueueTimeInfo) == 0x000004, "Wrong alignment on FDBDQueueTimeInfo");
static_assert(sizeof(FDBDQueueTimeInfo) == 0x000018, "Wrong size on FDBDQueueTimeInfo");

// ScriptStruct DeadByDaylight.OfferingEffect
// 0x0028 (0x0028 - 0x0000)
struct FOfferingEffect final
{
public:
	EOfferingEffectType                           Type;                                              // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           Tags;                                              // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   Value;                                             // 0x0018(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Modifier;                                          // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOfferingEffect) == 0x000008, "Wrong alignment on FOfferingEffect");
static_assert(sizeof(FOfferingEffect) == 0x000028, "Wrong size on FOfferingEffect");
static_assert(offsetof(FOfferingEffect, Type) == 0x000000, "Member 'FOfferingEffect::Type' has a wrong offset!");
static_assert(offsetof(FOfferingEffect, Tags) == 0x000008, "Member 'FOfferingEffect::Tags' has a wrong offset!");
static_assert(offsetof(FOfferingEffect, Value) == 0x000018, "Member 'FOfferingEffect::Value' has a wrong offset!");
static_assert(offsetof(FOfferingEffect, Modifier) == 0x000024, "Member 'FOfferingEffect::Modifier' has a wrong offset!");

// ScriptStruct DeadByDaylight.PerkLevelText
// 0x0028 (0x0028 - 0x0000)
struct FPerkLevelText final
{
public:
	TArray<class FString>                         Tunables;                                          // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class FText                                   TextOverride;                                      // 0x0010(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPerkLevelText) == 0x000008, "Wrong alignment on FPerkLevelText");
static_assert(sizeof(FPerkLevelText) == 0x000028, "Wrong size on FPerkLevelText");
static_assert(offsetof(FPerkLevelText, Tunables) == 0x000000, "Member 'FPerkLevelText::Tunables' has a wrong offset!");
static_assert(offsetof(FPerkLevelText, TextOverride) == 0x000010, "Member 'FPerkLevelText::TextOverride' has a wrong offset!");

// ScriptStruct DeadByDaylight.PerkProperties
// 0x0100 (0x03A0 - 0x02A0)
struct FPerkProperties final : public FItemData
{
public:
	TArray<class FName>                           Tags;                                              // 0x02A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FOfferingEffect>                Effects;                                           // 0x02B0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         AssociatedPlayerIndex;                             // 0x02C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MandatoryOnBloodweblevel;                          // 0x02C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TeachableOnBloodweblevel;                          // 0x02C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AtlantaTeachableLevel;                             // 0x02CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EPerkCategory>                         PerkCategory;                                      // 0x02D0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	EPerkArchetype                                PerkArchetype;                                     // 0x02E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E1[0x7];                                      // 0x02E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   PerkBlueprint;                                     // 0x02E8(0x0038)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EItemRarity>                           PerkLevelRarity;                                   // 0x0320(0x0010)(Edit, EditFixedSize, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPerkLevelText>                 PerkLevelTunables;                                 // 0x0330(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class FText                                   PerkLevel1Description;                             // 0x0340(0x0018)(Edit, EditFixedSize, NativeAccessSpecifierPublic)
	class FText                                   PerkLevel2Description;                             // 0x0358(0x0018)(Edit, EditFixedSize, NativeAccessSpecifierPublic)
	class FText                                   PerkLevel3Description;                             // 0x0370(0x0018)(Edit, EditFixedSize, NativeAccessSpecifierPublic)
	TArray<class FString>                         AtlantaActivatableInteractionIDs;                  // 0x0388(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          AtlantaLowPriority;                                // 0x0398(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_399[0x7];                                      // 0x0399(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPerkProperties) == 0x000008, "Wrong alignment on FPerkProperties");
static_assert(sizeof(FPerkProperties) == 0x0003A0, "Wrong size on FPerkProperties");
static_assert(offsetof(FPerkProperties, Tags) == 0x0002A0, "Member 'FPerkProperties::Tags' has a wrong offset!");
static_assert(offsetof(FPerkProperties, Effects) == 0x0002B0, "Member 'FPerkProperties::Effects' has a wrong offset!");
static_assert(offsetof(FPerkProperties, AssociatedPlayerIndex) == 0x0002C0, "Member 'FPerkProperties::AssociatedPlayerIndex' has a wrong offset!");
static_assert(offsetof(FPerkProperties, MandatoryOnBloodweblevel) == 0x0002C4, "Member 'FPerkProperties::MandatoryOnBloodweblevel' has a wrong offset!");
static_assert(offsetof(FPerkProperties, TeachableOnBloodweblevel) == 0x0002C8, "Member 'FPerkProperties::TeachableOnBloodweblevel' has a wrong offset!");
static_assert(offsetof(FPerkProperties, AtlantaTeachableLevel) == 0x0002CC, "Member 'FPerkProperties::AtlantaTeachableLevel' has a wrong offset!");
static_assert(offsetof(FPerkProperties, PerkCategory) == 0x0002D0, "Member 'FPerkProperties::PerkCategory' has a wrong offset!");
static_assert(offsetof(FPerkProperties, PerkArchetype) == 0x0002E0, "Member 'FPerkProperties::PerkArchetype' has a wrong offset!");
static_assert(offsetof(FPerkProperties, PerkBlueprint) == 0x0002E8, "Member 'FPerkProperties::PerkBlueprint' has a wrong offset!");
static_assert(offsetof(FPerkProperties, PerkLevelRarity) == 0x000320, "Member 'FPerkProperties::PerkLevelRarity' has a wrong offset!");
static_assert(offsetof(FPerkProperties, PerkLevelTunables) == 0x000330, "Member 'FPerkProperties::PerkLevelTunables' has a wrong offset!");
static_assert(offsetof(FPerkProperties, PerkLevel1Description) == 0x000340, "Member 'FPerkProperties::PerkLevel1Description' has a wrong offset!");
static_assert(offsetof(FPerkProperties, PerkLevel2Description) == 0x000358, "Member 'FPerkProperties::PerkLevel2Description' has a wrong offset!");
static_assert(offsetof(FPerkProperties, PerkLevel3Description) == 0x000370, "Member 'FPerkProperties::PerkLevel3Description' has a wrong offset!");
static_assert(offsetof(FPerkProperties, AtlantaActivatableInteractionIDs) == 0x000388, "Member 'FPerkProperties::AtlantaActivatableInteractionIDs' has a wrong offset!");
static_assert(offsetof(FPerkProperties, AtlantaLowPriority) == 0x000398, "Member 'FPerkProperties::AtlantaLowPriority' has a wrong offset!");

// ScriptStruct DeadByDaylight.EACClientInfo
// 0x0038 (0x0038 - 0x0000)
struct alignas(0x08) FEACClientInfo final
{
public:
	uint8                                         Pad_0[0x38];                                       // 0x0000(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEACClientInfo) == 0x000008, "Wrong alignment on FEACClientInfo");
static_assert(sizeof(FEACClientInfo) == 0x000038, "Wrong size on FEACClientInfo");

// ScriptStruct DeadByDaylight.CharacterClassProperties
// 0x0010 (0x02B0 - 0x02A0)
struct FCharacterClassProperties final : public FItemData
{
public:
	TArray<class FName>                           Skills;                                            // 0x02A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterClassProperties) == 0x000008, "Wrong alignment on FCharacterClassProperties");
static_assert(sizeof(FCharacterClassProperties) == 0x0002B0, "Wrong size on FCharacterClassProperties");
static_assert(offsetof(FCharacterClassProperties, Skills) == 0x0002A0, "Member 'FCharacterClassProperties::Skills' has a wrong offset!");

// ScriptStruct DeadByDaylight.Offering
// 0x02D8 (0x02D8 - 0x0000)
struct alignas(0x08) FOffering final
{
public:
	uint8                                         Pad_0[0x2D8];                                      // 0x0000(0x02D8)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOffering) == 0x000008, "Wrong alignment on FOffering");
static_assert(sizeof(FOffering) == 0x0002D8, "Wrong size on FOffering");

// ScriptStruct DeadByDaylight.CharacterCustomizationDataTable
// 0x0040 (0x0048 - 0x0008)
struct FCharacterCustomizationDataTable final : public FDBDTableRowBase
{
public:
	int32                                         CharacterIndex;                                    // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UDataTable>              CustomizationStoreDB;                              // 0x0010(0x0038)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterCustomizationDataTable) == 0x000008, "Wrong alignment on FCharacterCustomizationDataTable");
static_assert(sizeof(FCharacterCustomizationDataTable) == 0x000048, "Wrong size on FCharacterCustomizationDataTable");
static_assert(offsetof(FCharacterCustomizationDataTable, CharacterIndex) == 0x000008, "Member 'FCharacterCustomizationDataTable::CharacterIndex' has a wrong offset!");
static_assert(offsetof(FCharacterCustomizationDataTable, CustomizationStoreDB) == 0x000010, "Member 'FCharacterCustomizationDataTable::CustomizationStoreDB' has a wrong offset!");

// ScriptStruct DeadByDaylight.DBDFoliageInstance
// 0x0080 (0x0080 - 0x0000)
struct FDBDFoliageInstance final
{
public:
	int32                                         BaseID;                                            // 0x0000(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  ProceduralGuid;                                    // 0x0004(0x0010)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Location;                                          // 0x0018(0x0018)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0030(0x0018)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               PreAlignRotation;                                  // 0x0048(0x0018)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                DrawScale3D;                                       // 0x0060(0x0018)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZOffset;                                           // 0x0078(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        Flags;                                             // 0x007C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDBDFoliageInstance) == 0x000008, "Wrong alignment on FDBDFoliageInstance");
static_assert(sizeof(FDBDFoliageInstance) == 0x000080, "Wrong size on FDBDFoliageInstance");
static_assert(offsetof(FDBDFoliageInstance, BaseID) == 0x000000, "Member 'FDBDFoliageInstance::BaseID' has a wrong offset!");
static_assert(offsetof(FDBDFoliageInstance, ProceduralGuid) == 0x000004, "Member 'FDBDFoliageInstance::ProceduralGuid' has a wrong offset!");
static_assert(offsetof(FDBDFoliageInstance, Location) == 0x000018, "Member 'FDBDFoliageInstance::Location' has a wrong offset!");
static_assert(offsetof(FDBDFoliageInstance, Rotation) == 0x000030, "Member 'FDBDFoliageInstance::Rotation' has a wrong offset!");
static_assert(offsetof(FDBDFoliageInstance, PreAlignRotation) == 0x000048, "Member 'FDBDFoliageInstance::PreAlignRotation' has a wrong offset!");
static_assert(offsetof(FDBDFoliageInstance, DrawScale3D) == 0x000060, "Member 'FDBDFoliageInstance::DrawScale3D' has a wrong offset!");
static_assert(offsetof(FDBDFoliageInstance, ZOffset) == 0x000078, "Member 'FDBDFoliageInstance::ZOffset' has a wrong offset!");
static_assert(offsetof(FDBDFoliageInstance, Flags) == 0x00007C, "Member 'FDBDFoliageInstance::Flags' has a wrong offset!");

// ScriptStruct DeadByDaylight.DBDFoliageInfo
// 0x0018 (0x0018 - 0x0000)
struct FDBDFoliageInfo final
{
public:
	class UFoliageType*                           FoliageType;                                       // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FDBDFoliageInstance>            Instances;                                         // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDBDFoliageInfo) == 0x000008, "Wrong alignment on FDBDFoliageInfo");
static_assert(sizeof(FDBDFoliageInfo) == 0x000018, "Wrong size on FDBDFoliageInfo");
static_assert(offsetof(FDBDFoliageInfo, FoliageType) == 0x000000, "Member 'FDBDFoliageInfo::FoliageType' has a wrong offset!");
static_assert(offsetof(FDBDFoliageInfo, Instances) == 0x000008, "Member 'FDBDFoliageInfo::Instances' has a wrong offset!");

// ScriptStruct DeadByDaylight.CustomizationPresetListId
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x04) FCustomizationPresetListId final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCustomizationPresetListId) == 0x000004, "Wrong alignment on FCustomizationPresetListId");
static_assert(sizeof(FCustomizationPresetListId) == 0x000008, "Wrong size on FCustomizationPresetListId");

// ScriptStruct DeadByDaylight.EmblemProgressionID
// 0x0030 (0x0030 - 0x0000)
struct FEmblemProgressionID final
{
public:
	EEmblemProgressionType                        EmblemProgressionType;                             // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DefaultDescription;                                // 0x0008(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FEmblemProgressionDescriptionByQuality> DescriptionsByQuality;                             // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEmblemProgressionID) == 0x000008, "Wrong alignment on FEmblemProgressionID");
static_assert(sizeof(FEmblemProgressionID) == 0x000030, "Wrong size on FEmblemProgressionID");
static_assert(offsetof(FEmblemProgressionID, EmblemProgressionType) == 0x000000, "Member 'FEmblemProgressionID::EmblemProgressionType' has a wrong offset!");
static_assert(offsetof(FEmblemProgressionID, DefaultDescription) == 0x000008, "Member 'FEmblemProgressionID::DefaultDescription' has a wrong offset!");
static_assert(offsetof(FEmblemProgressionID, DescriptionsByQuality) == 0x000020, "Member 'FEmblemProgressionID::DescriptionsByQuality' has a wrong offset!");

// ScriptStruct DeadByDaylight.DBDEmblemDefinition
// 0x00B0 (0x00B8 - 0x0008)
struct FDBDEmblemDefinition final : public FDBDTableRowBase
{
public:
	class FName                                   ID;                                                // 0x0008(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Name;                                              // 0x0018(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0030(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<EPlayerRole>                           Roles;                                             // 0x0048(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   CustomEmblem;                                      // 0x0058(0x0038)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         IconFilePaths;                                     // 0x0090(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	EEmblemEvaluation                             EmblemEvaluation;                                  // 0x00A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Enabled;                                           // 0x00A1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A2[0x6];                                       // 0x00A2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FEmblemProgressionID>           EmblemProgressionData;                             // 0x00A8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDBDEmblemDefinition) == 0x000008, "Wrong alignment on FDBDEmblemDefinition");
static_assert(sizeof(FDBDEmblemDefinition) == 0x0000B8, "Wrong size on FDBDEmblemDefinition");
static_assert(offsetof(FDBDEmblemDefinition, ID) == 0x000008, "Member 'FDBDEmblemDefinition::ID' has a wrong offset!");
static_assert(offsetof(FDBDEmblemDefinition, Name) == 0x000018, "Member 'FDBDEmblemDefinition::Name' has a wrong offset!");
static_assert(offsetof(FDBDEmblemDefinition, Description) == 0x000030, "Member 'FDBDEmblemDefinition::Description' has a wrong offset!");
static_assert(offsetof(FDBDEmblemDefinition, Roles) == 0x000048, "Member 'FDBDEmblemDefinition::Roles' has a wrong offset!");
static_assert(offsetof(FDBDEmblemDefinition, CustomEmblem) == 0x000058, "Member 'FDBDEmblemDefinition::CustomEmblem' has a wrong offset!");
static_assert(offsetof(FDBDEmblemDefinition, IconFilePaths) == 0x000090, "Member 'FDBDEmblemDefinition::IconFilePaths' has a wrong offset!");
static_assert(offsetof(FDBDEmblemDefinition, EmblemEvaluation) == 0x0000A0, "Member 'FDBDEmblemDefinition::EmblemEvaluation' has a wrong offset!");
static_assert(offsetof(FDBDEmblemDefinition, Enabled) == 0x0000A1, "Member 'FDBDEmblemDefinition::Enabled' has a wrong offset!");
static_assert(offsetof(FDBDEmblemDefinition, EmblemProgressionData) == 0x0000A8, "Member 'FDBDEmblemDefinition::EmblemProgressionData' has a wrong offset!");

// ScriptStruct DeadByDaylight.ReportedPlayerData
// 0x0040 (0x0040 - 0x0000)
struct FReportedPlayerData final
{
public:
	class FString                                 PlatformAccountId;                                 // 0x0000(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MirrorsId;                                         // 0x0010(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerRole                                   PlayerRole;                                        // 0x0020(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 PlayerName;                                        // 0x0028(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EProviderFlag                                 PlayerPlatform;                                    // 0x0038(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FReportedPlayerData) == 0x000008, "Wrong alignment on FReportedPlayerData");
static_assert(sizeof(FReportedPlayerData) == 0x000040, "Wrong size on FReportedPlayerData");
static_assert(offsetof(FReportedPlayerData, PlatformAccountId) == 0x000000, "Member 'FReportedPlayerData::PlatformAccountId' has a wrong offset!");
static_assert(offsetof(FReportedPlayerData, MirrorsId) == 0x000010, "Member 'FReportedPlayerData::MirrorsId' has a wrong offset!");
static_assert(offsetof(FReportedPlayerData, PlayerRole) == 0x000020, "Member 'FReportedPlayerData::PlayerRole' has a wrong offset!");
static_assert(offsetof(FReportedPlayerData, PlayerName) == 0x000028, "Member 'FReportedPlayerData::PlayerName' has a wrong offset!");
static_assert(offsetof(FReportedPlayerData, PlayerPlatform) == 0x000038, "Member 'FReportedPlayerData::PlayerPlatform' has a wrong offset!");

// ScriptStruct DeadByDaylight.DBDEACReportContext
// 0x0050 (0x0050 - 0x0000)
struct FDBDEACReportContext final
{
public:
	class FString                                 DBDReportReason;                                   // 0x0000(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FReportedPlayerData                    ReportedPlayerData;                                // 0x0010(0x0040)(Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDBDEACReportContext) == 0x000008, "Wrong alignment on FDBDEACReportContext");
static_assert(sizeof(FDBDEACReportContext) == 0x000050, "Wrong size on FDBDEACReportContext");
static_assert(offsetof(FDBDEACReportContext, DBDReportReason) == 0x000000, "Member 'FDBDEACReportContext::DBDReportReason' has a wrong offset!");
static_assert(offsetof(FDBDEACReportContext, ReportedPlayerData) == 0x000010, "Member 'FDBDEACReportContext::ReportedPlayerData' has a wrong offset!");

// ScriptStruct DeadByDaylight.SlideShowDescription
// 0x0060 (0x0068 - 0x0008)
struct FSlideShowDescription final : public FDBDTableRowBase
{
public:
	class FName                                   ID;                                                // 0x0008(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Overview;                                          // 0x0018(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   Playstyle;                                         // 0x0030(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FString                                 ImageFilePath;                                     // 0x0048(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EPerkCategory>                         PerkCategory;                                      // 0x0058(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSlideShowDescription) == 0x000008, "Wrong alignment on FSlideShowDescription");
static_assert(sizeof(FSlideShowDescription) == 0x000068, "Wrong size on FSlideShowDescription");
static_assert(offsetof(FSlideShowDescription, ID) == 0x000008, "Member 'FSlideShowDescription::ID' has a wrong offset!");
static_assert(offsetof(FSlideShowDescription, Overview) == 0x000018, "Member 'FSlideShowDescription::Overview' has a wrong offset!");
static_assert(offsetof(FSlideShowDescription, Playstyle) == 0x000030, "Member 'FSlideShowDescription::Playstyle' has a wrong offset!");
static_assert(offsetof(FSlideShowDescription, ImageFilePath) == 0x000048, "Member 'FSlideShowDescription::ImageFilePath' has a wrong offset!");
static_assert(offsetof(FSlideShowDescription, PerkCategory) == 0x000058, "Member 'FSlideShowDescription::PerkCategory' has a wrong offset!");

// ScriptStruct DeadByDaylight.CharacterDescription
// 0x0278 (0x0280 - 0x0008)
struct FCharacterDescription final : public FDBDTableRowBase
{
public:
	int32                                         CharacterIndex;                                    // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CharacterCodename;                                 // 0x000C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerRole                                   Role;                                              // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECharacterDifficulty                          Difficulty;                                        // 0x0019(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x6];                                       // 0x001A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DisplayName;                                       // 0x0020(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   BackStory;                                         // 0x0038(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   Biography;                                         // 0x0050(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FName                                   IconFilePath;                                      // 0x0068(0x000C)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             HudIcon;                                           // 0x0078(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BackgroundImagePath;                               // 0x0080(0x000C)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCustomizedMeshPart>            CustomizationDescription;                          // 0x0090(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 ChapterDlcId;                                      // 0x00A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         AdditionalDlcIds;                                  // 0x00B0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          AvailableIfDlcInstalled;                           // 0x00C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C1[0x3];                                       // 0x00C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DebugName;                                         // 0x00C4(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsInChunk0;                                        // 0x00D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsAvailableInNonViolentBuild;                      // 0x00D1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D2[0x2];                                       // 0x00D2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        PlatformExclusiveFlag;                             // 0x00D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   GamePawn;                                          // 0x00D8(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   MenuPawn;                                          // 0x0110(0x0038)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsDefaultItemSpawnableInParadise;                  // 0x0148(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_149[0x3];                                      // 0x0149(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DefaultItem;                                       // 0x014C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DefaultPerk;                                       // 0x0158(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGender                                       Gender;                                            // 0x0164(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_165[0x3];                                      // 0x0165(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EKillerAbilities>                      KillerAbilities;                                   // 0x0168(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FDataTableProxy                        TunableDB;                                         // 0x0178(0x0040)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	EKillerHeight                                 KillerHeight;                                      // 0x01B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B9[0x7];                                      // 0x01B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlideShowDescription                  SlideShowDescriptions;                             // 0x01C0(0x0068)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          HideStoreCustomizations;                           // 0x0228(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_229[0x7];                                      // 0x0229(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FText>                           SearchTags;                                        // 0x0230(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 DefaultCharacterClass;                             // 0x0240(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           CustomizationCategories;                           // 0x0250(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Config, Protected, NativeAccessSpecifierProtected)
	class FString                                 CharacterId;                                       // 0x0260(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_270[0x10];                                     // 0x0270(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCharacterDescription) == 0x000008, "Wrong alignment on FCharacterDescription");
static_assert(sizeof(FCharacterDescription) == 0x000280, "Wrong size on FCharacterDescription");
static_assert(offsetof(FCharacterDescription, CharacterIndex) == 0x000008, "Member 'FCharacterDescription::CharacterIndex' has a wrong offset!");
static_assert(offsetof(FCharacterDescription, CharacterCodename) == 0x00000C, "Member 'FCharacterDescription::CharacterCodename' has a wrong offset!");
static_assert(offsetof(FCharacterDescription, Role) == 0x000018, "Member 'FCharacterDescription::Role' has a wrong offset!");
static_assert(offsetof(FCharacterDescription, Difficulty) == 0x000019, "Member 'FCharacterDescription::Difficulty' has a wrong offset!");
static_assert(offsetof(FCharacterDescription, DisplayName) == 0x000020, "Member 'FCharacterDescription::DisplayName' has a wrong offset!");
static_assert(offsetof(FCharacterDescription, BackStory) == 0x000038, "Member 'FCharacterDescription::BackStory' has a wrong offset!");
static_assert(offsetof(FCharacterDescription, Biography) == 0x000050, "Member 'FCharacterDescription::Biography' has a wrong offset!");
static_assert(offsetof(FCharacterDescription, IconFilePath) == 0x000068, "Member 'FCharacterDescription::IconFilePath' has a wrong offset!");
static_assert(offsetof(FCharacterDescription, HudIcon) == 0x000078, "Member 'FCharacterDescription::HudIcon' has a wrong offset!");
static_assert(offsetof(FCharacterDescription, BackgroundImagePath) == 0x000080, "Member 'FCharacterDescription::BackgroundImagePath' has a wrong offset!");
static_assert(offsetof(FCharacterDescription, CustomizationDescription) == 0x000090, "Member 'FCharacterDescription::CustomizationDescription' has a wrong offset!");
static_assert(offsetof(FCharacterDescription, ChapterDlcId) == 0x0000A0, "Member 'FCharacterDescription::ChapterDlcId' has a wrong offset!");
static_assert(offsetof(FCharacterDescription, AdditionalDlcIds) == 0x0000B0, "Member 'FCharacterDescription::AdditionalDlcIds' has a wrong offset!");
static_assert(offsetof(FCharacterDescription, AvailableIfDlcInstalled) == 0x0000C0, "Member 'FCharacterDescription::AvailableIfDlcInstalled' has a wrong offset!");
static_assert(offsetof(FCharacterDescription, DebugName) == 0x0000C4, "Member 'FCharacterDescription::DebugName' has a wrong offset!");
static_assert(offsetof(FCharacterDescription, IsInChunk0) == 0x0000D0, "Member 'FCharacterDescription::IsInChunk0' has a wrong offset!");
static_assert(offsetof(FCharacterDescription, IsAvailableInNonViolentBuild) == 0x0000D1, "Member 'FCharacterDescription::IsAvailableInNonViolentBuild' has a wrong offset!");
static_assert(offsetof(FCharacterDescription, PlatformExclusiveFlag) == 0x0000D4, "Member 'FCharacterDescription::PlatformExclusiveFlag' has a wrong offset!");
static_assert(offsetof(FCharacterDescription, GamePawn) == 0x0000D8, "Member 'FCharacterDescription::GamePawn' has a wrong offset!");
static_assert(offsetof(FCharacterDescription, MenuPawn) == 0x000110, "Member 'FCharacterDescription::MenuPawn' has a wrong offset!");
static_assert(offsetof(FCharacterDescription, IsDefaultItemSpawnableInParadise) == 0x000148, "Member 'FCharacterDescription::IsDefaultItemSpawnableInParadise' has a wrong offset!");
static_assert(offsetof(FCharacterDescription, DefaultItem) == 0x00014C, "Member 'FCharacterDescription::DefaultItem' has a wrong offset!");
static_assert(offsetof(FCharacterDescription, DefaultPerk) == 0x000158, "Member 'FCharacterDescription::DefaultPerk' has a wrong offset!");
static_assert(offsetof(FCharacterDescription, Gender) == 0x000164, "Member 'FCharacterDescription::Gender' has a wrong offset!");
static_assert(offsetof(FCharacterDescription, KillerAbilities) == 0x000168, "Member 'FCharacterDescription::KillerAbilities' has a wrong offset!");
static_assert(offsetof(FCharacterDescription, TunableDB) == 0x000178, "Member 'FCharacterDescription::TunableDB' has a wrong offset!");
static_assert(offsetof(FCharacterDescription, KillerHeight) == 0x0001B8, "Member 'FCharacterDescription::KillerHeight' has a wrong offset!");
static_assert(offsetof(FCharacterDescription, SlideShowDescriptions) == 0x0001C0, "Member 'FCharacterDescription::SlideShowDescriptions' has a wrong offset!");
static_assert(offsetof(FCharacterDescription, HideStoreCustomizations) == 0x000228, "Member 'FCharacterDescription::HideStoreCustomizations' has a wrong offset!");
static_assert(offsetof(FCharacterDescription, SearchTags) == 0x000230, "Member 'FCharacterDescription::SearchTags' has a wrong offset!");
static_assert(offsetof(FCharacterDescription, DefaultCharacterClass) == 0x000240, "Member 'FCharacterDescription::DefaultCharacterClass' has a wrong offset!");
static_assert(offsetof(FCharacterDescription, CustomizationCategories) == 0x000250, "Member 'FCharacterDescription::CustomizationCategories' has a wrong offset!");
static_assert(offsetof(FCharacterDescription, CharacterId) == 0x000260, "Member 'FCharacterDescription::CharacterId' has a wrong offset!");

// ScriptStruct DeadByDaylight.PlayerRoleRankData
// 0x0010 (0x0010 - 0x0000)
struct FPlayerRoleRankData final
{
public:
	EPlayerRole                                   PlayerRole;                                        // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Rank;                                              // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PipsRequiredForNextRank;                           // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ActivePips;                                        // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerRoleRankData) == 0x000004, "Wrong alignment on FPlayerRoleRankData");
static_assert(sizeof(FPlayerRoleRankData) == 0x000010, "Wrong size on FPlayerRoleRankData");
static_assert(offsetof(FPlayerRoleRankData, PlayerRole) == 0x000000, "Member 'FPlayerRoleRankData::PlayerRole' has a wrong offset!");
static_assert(offsetof(FPlayerRoleRankData, Rank) == 0x000004, "Member 'FPlayerRoleRankData::Rank' has a wrong offset!");
static_assert(offsetof(FPlayerRoleRankData, PipsRequiredForNextRank) == 0x000008, "Member 'FPlayerRoleRankData::PipsRequiredForNextRank' has a wrong offset!");
static_assert(offsetof(FPlayerRoleRankData, ActivePips) == 0x00000C, "Member 'FPlayerRoleRankData::ActivePips' has a wrong offset!");

// ScriptStruct DeadByDaylight.LegacySavedBloodwebNodeProperties
// 0x0018 (0x0018 - 0x0000)
struct FLegacySavedBloodwebNodeProperties final
{
public:
	EBloodwebNodeContentType                      ContentType;                                       // 0x0000(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemRarity                                   Rarity;                                            // 0x0001(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         Tags;                                              // 0x0008(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLegacySavedBloodwebNodeProperties) == 0x000008, "Wrong alignment on FLegacySavedBloodwebNodeProperties");
static_assert(sizeof(FLegacySavedBloodwebNodeProperties) == 0x000018, "Wrong size on FLegacySavedBloodwebNodeProperties");
static_assert(offsetof(FLegacySavedBloodwebNodeProperties, ContentType) == 0x000000, "Member 'FLegacySavedBloodwebNodeProperties::ContentType' has a wrong offset!");
static_assert(offsetof(FLegacySavedBloodwebNodeProperties, Rarity) == 0x000001, "Member 'FLegacySavedBloodwebNodeProperties::Rarity' has a wrong offset!");
static_assert(offsetof(FLegacySavedBloodwebNodeProperties, Tags) == 0x000008, "Member 'FLegacySavedBloodwebNodeProperties::Tags' has a wrong offset!");

// ScriptStruct DeadByDaylight.LegacySavedBloodwebNodeGate
// 0x0020 (0x0020 - 0x0000)
struct FLegacySavedBloodwebNodeGate final
{
public:
	class FName                                   Description;                                       // 0x0000(0x000C)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemRarity                                   Rarity;                                            // 0x000C(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerRole                                   Role;                                              // 0x000D(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBloodwebNodeGateTypes                        GateType;                                          // 0x000E(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F[0x1];                                        // 0x000F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Param;                                             // 0x0010(0x0010)(ZeroConstructor, SaveGame, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLegacySavedBloodwebNodeGate) == 0x000008, "Wrong alignment on FLegacySavedBloodwebNodeGate");
static_assert(sizeof(FLegacySavedBloodwebNodeGate) == 0x000020, "Wrong size on FLegacySavedBloodwebNodeGate");
static_assert(offsetof(FLegacySavedBloodwebNodeGate, Description) == 0x000000, "Member 'FLegacySavedBloodwebNodeGate::Description' has a wrong offset!");
static_assert(offsetof(FLegacySavedBloodwebNodeGate, Rarity) == 0x00000C, "Member 'FLegacySavedBloodwebNodeGate::Rarity' has a wrong offset!");
static_assert(offsetof(FLegacySavedBloodwebNodeGate, Role) == 0x00000D, "Member 'FLegacySavedBloodwebNodeGate::Role' has a wrong offset!");
static_assert(offsetof(FLegacySavedBloodwebNodeGate, GateType) == 0x00000E, "Member 'FLegacySavedBloodwebNodeGate::GateType' has a wrong offset!");
static_assert(offsetof(FLegacySavedBloodwebNodeGate, Param) == 0x000010, "Member 'FLegacySavedBloodwebNodeGate::Param' has a wrong offset!");

// ScriptStruct DeadByDaylight.LegacySavedBloodwebChest
// 0x0030 (0x0030 - 0x0000)
struct FLegacySavedBloodwebChest final
{
public:
	class FName                                   ID;                                                // 0x0000(0x000C)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EventID;                                           // 0x000C(0x000C)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemRarity                                   Rarity;                                            // 0x0018(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 GivenItemRarity;                                   // 0x0020(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLegacySavedBloodwebChest) == 0x000008, "Wrong alignment on FLegacySavedBloodwebChest");
static_assert(sizeof(FLegacySavedBloodwebChest) == 0x000030, "Wrong size on FLegacySavedBloodwebChest");
static_assert(offsetof(FLegacySavedBloodwebChest, ID) == 0x000000, "Member 'FLegacySavedBloodwebChest::ID' has a wrong offset!");
static_assert(offsetof(FLegacySavedBloodwebChest, EventID) == 0x00000C, "Member 'FLegacySavedBloodwebChest::EventID' has a wrong offset!");
static_assert(offsetof(FLegacySavedBloodwebChest, Rarity) == 0x000018, "Member 'FLegacySavedBloodwebChest::Rarity' has a wrong offset!");
static_assert(offsetof(FLegacySavedBloodwebChest, GivenItemRarity) == 0x000020, "Member 'FLegacySavedBloodwebChest::GivenItemRarity' has a wrong offset!");

// ScriptStruct DeadByDaylight.LegacySavedBloodwebNode
// 0x0080 (0x0080 - 0x0000)
struct FLegacySavedBloodwebNode final
{
public:
	struct FLegacySavedBloodwebNodeProperties     Properties;                                        // 0x0000(0x0018)(SaveGame, NativeAccessSpecifierPublic)
	TArray<struct FLegacySavedBloodwebNodeGate>   Gates;                                             // 0x0018(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	EBloodwebNodeState                            State;                                             // 0x0028(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 NodeId;                                            // 0x0030(0x0010)(ZeroConstructor, SaveGame, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ContentId;                                         // 0x0040(0x000C)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLegacySavedBloodwebChest              BloodwebChest;                                     // 0x0050(0x0030)(SaveGame, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLegacySavedBloodwebNode) == 0x000008, "Wrong alignment on FLegacySavedBloodwebNode");
static_assert(sizeof(FLegacySavedBloodwebNode) == 0x000080, "Wrong size on FLegacySavedBloodwebNode");
static_assert(offsetof(FLegacySavedBloodwebNode, Properties) == 0x000000, "Member 'FLegacySavedBloodwebNode::Properties' has a wrong offset!");
static_assert(offsetof(FLegacySavedBloodwebNode, Gates) == 0x000018, "Member 'FLegacySavedBloodwebNode::Gates' has a wrong offset!");
static_assert(offsetof(FLegacySavedBloodwebNode, State) == 0x000028, "Member 'FLegacySavedBloodwebNode::State' has a wrong offset!");
static_assert(offsetof(FLegacySavedBloodwebNode, NodeId) == 0x000030, "Member 'FLegacySavedBloodwebNode::NodeId' has a wrong offset!");
static_assert(offsetof(FLegacySavedBloodwebNode, ContentId) == 0x000040, "Member 'FLegacySavedBloodwebNode::ContentId' has a wrong offset!");
static_assert(offsetof(FLegacySavedBloodwebNode, BloodwebChest) == 0x000050, "Member 'FLegacySavedBloodwebNode::BloodwebChest' has a wrong offset!");

// ScriptStruct DeadByDaylight.LegacySavedBloodWebRingPersistentData
// 0x0010 (0x0010 - 0x0000)
struct FLegacySavedBloodWebRingPersistentData final
{
public:
	TArray<struct FLegacySavedBloodwebNode>       NodeData;                                          // 0x0000(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLegacySavedBloodWebRingPersistentData) == 0x000008, "Wrong alignment on FLegacySavedBloodWebRingPersistentData");
static_assert(sizeof(FLegacySavedBloodWebRingPersistentData) == 0x000010, "Wrong size on FLegacySavedBloodWebRingPersistentData");
static_assert(offsetof(FLegacySavedBloodWebRingPersistentData, NodeData) == 0x000000, "Member 'FLegacySavedBloodWebRingPersistentData::NodeData' has a wrong offset!");

// ScriptStruct DeadByDaylight.CharacterDescriptionOverride
// 0x0110 (0x0118 - 0x0008)
struct FCharacterDescriptionOverride final : public FDBDTableRowBase
{
public:
	class FName                                   OverrideId;                                        // 0x0008(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   OverrideDebugName;                                 // 0x0014(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           RequiredItemIds;                                   // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class FText                                   DisplayNameOverride;                               // 0x0030(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              HudIconOverride;                                   // 0x0048(0x0038)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   MenuBlueprint;                                     // 0x0080(0x0038)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   GameBlueprint;                                     // 0x00B8(0x0038)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   IconFilePathOverride;                              // 0x00F0(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MoriVideoOverrideId;                               // 0x00FC(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 InclusionVersion;                                  // 0x0108(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterDescriptionOverride) == 0x000008, "Wrong alignment on FCharacterDescriptionOverride");
static_assert(sizeof(FCharacterDescriptionOverride) == 0x000118, "Wrong size on FCharacterDescriptionOverride");
static_assert(offsetof(FCharacterDescriptionOverride, OverrideId) == 0x000008, "Member 'FCharacterDescriptionOverride::OverrideId' has a wrong offset!");
static_assert(offsetof(FCharacterDescriptionOverride, OverrideDebugName) == 0x000014, "Member 'FCharacterDescriptionOverride::OverrideDebugName' has a wrong offset!");
static_assert(offsetof(FCharacterDescriptionOverride, RequiredItemIds) == 0x000020, "Member 'FCharacterDescriptionOverride::RequiredItemIds' has a wrong offset!");
static_assert(offsetof(FCharacterDescriptionOverride, DisplayNameOverride) == 0x000030, "Member 'FCharacterDescriptionOverride::DisplayNameOverride' has a wrong offset!");
static_assert(offsetof(FCharacterDescriptionOverride, HudIconOverride) == 0x000048, "Member 'FCharacterDescriptionOverride::HudIconOverride' has a wrong offset!");
static_assert(offsetof(FCharacterDescriptionOverride, MenuBlueprint) == 0x000080, "Member 'FCharacterDescriptionOverride::MenuBlueprint' has a wrong offset!");
static_assert(offsetof(FCharacterDescriptionOverride, GameBlueprint) == 0x0000B8, "Member 'FCharacterDescriptionOverride::GameBlueprint' has a wrong offset!");
static_assert(offsetof(FCharacterDescriptionOverride, IconFilePathOverride) == 0x0000F0, "Member 'FCharacterDescriptionOverride::IconFilePathOverride' has a wrong offset!");
static_assert(offsetof(FCharacterDescriptionOverride, MoriVideoOverrideId) == 0x0000FC, "Member 'FCharacterDescriptionOverride::MoriVideoOverrideId' has a wrong offset!");
static_assert(offsetof(FCharacterDescriptionOverride, InclusionVersion) == 0x000108, "Member 'FCharacterDescriptionOverride::InclusionVersion' has a wrong offset!");

// ScriptStruct DeadByDaylight.CharacterLevelData
// 0x0020 (0x0020 - 0x0000)
struct FCharacterLevelData final
{
public:
	int32                                         Level;                                             // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExperienceToNextLevel;                             // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsComplete;                                        // 0x0008(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasPerksBeenSelected;                              // 0x0009(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAssignedPerkProperties>        PerkSelection;                                     // 0x0010(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterLevelData) == 0x000008, "Wrong alignment on FCharacterLevelData");
static_assert(sizeof(FCharacterLevelData) == 0x000020, "Wrong size on FCharacterLevelData");
static_assert(offsetof(FCharacterLevelData, Level) == 0x000000, "Member 'FCharacterLevelData::Level' has a wrong offset!");
static_assert(offsetof(FCharacterLevelData, ExperienceToNextLevel) == 0x000004, "Member 'FCharacterLevelData::ExperienceToNextLevel' has a wrong offset!");
static_assert(offsetof(FCharacterLevelData, IsComplete) == 0x000008, "Member 'FCharacterLevelData::IsComplete' has a wrong offset!");
static_assert(offsetof(FCharacterLevelData, HasPerksBeenSelected) == 0x000009, "Member 'FCharacterLevelData::HasPerksBeenSelected' has a wrong offset!");
static_assert(offsetof(FCharacterLevelData, PerkSelection) == 0x000010, "Member 'FCharacterLevelData::PerkSelection' has a wrong offset!");

// ScriptStruct DeadByDaylight.LegacySavedPlayerLoadoutData
// 0x00B0 (0x00B0 - 0x0000)
struct FLegacySavedPlayerLoadoutData final
{
public:
	class FName                                   Item;                                              // 0x0000(0x000C)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           ItemAddOns;                                        // 0x0010(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	TArray<class FName>                           CamperPerks;                                       // 0x0020(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	TArray<int32>                                 CamperPerkLevels;                                  // 0x0030(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	class FName                                   CamperFavor;                                       // 0x0040(0x000C)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CamperCharacterClass;                              // 0x004C(0x000C)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Power;                                             // 0x0058(0x000C)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           PowerAddOns;                                       // 0x0068(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	TArray<class FName>                           SlasherPerks;                                      // 0x0078(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	TArray<int32>                                 SlasherPerkLevels;                                 // 0x0088(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	class FName                                   SlasherFavor;                                      // 0x0098(0x000C)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SlasherCharacterClass;                             // 0x00A4(0x000C)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLegacySavedPlayerLoadoutData) == 0x000008, "Wrong alignment on FLegacySavedPlayerLoadoutData");
static_assert(sizeof(FLegacySavedPlayerLoadoutData) == 0x0000B0, "Wrong size on FLegacySavedPlayerLoadoutData");
static_assert(offsetof(FLegacySavedPlayerLoadoutData, Item) == 0x000000, "Member 'FLegacySavedPlayerLoadoutData::Item' has a wrong offset!");
static_assert(offsetof(FLegacySavedPlayerLoadoutData, ItemAddOns) == 0x000010, "Member 'FLegacySavedPlayerLoadoutData::ItemAddOns' has a wrong offset!");
static_assert(offsetof(FLegacySavedPlayerLoadoutData, CamperPerks) == 0x000020, "Member 'FLegacySavedPlayerLoadoutData::CamperPerks' has a wrong offset!");
static_assert(offsetof(FLegacySavedPlayerLoadoutData, CamperPerkLevels) == 0x000030, "Member 'FLegacySavedPlayerLoadoutData::CamperPerkLevels' has a wrong offset!");
static_assert(offsetof(FLegacySavedPlayerLoadoutData, CamperFavor) == 0x000040, "Member 'FLegacySavedPlayerLoadoutData::CamperFavor' has a wrong offset!");
static_assert(offsetof(FLegacySavedPlayerLoadoutData, CamperCharacterClass) == 0x00004C, "Member 'FLegacySavedPlayerLoadoutData::CamperCharacterClass' has a wrong offset!");
static_assert(offsetof(FLegacySavedPlayerLoadoutData, Power) == 0x000058, "Member 'FLegacySavedPlayerLoadoutData::Power' has a wrong offset!");
static_assert(offsetof(FLegacySavedPlayerLoadoutData, PowerAddOns) == 0x000068, "Member 'FLegacySavedPlayerLoadoutData::PowerAddOns' has a wrong offset!");
static_assert(offsetof(FLegacySavedPlayerLoadoutData, SlasherPerks) == 0x000078, "Member 'FLegacySavedPlayerLoadoutData::SlasherPerks' has a wrong offset!");
static_assert(offsetof(FLegacySavedPlayerLoadoutData, SlasherPerkLevels) == 0x000088, "Member 'FLegacySavedPlayerLoadoutData::SlasherPerkLevels' has a wrong offset!");
static_assert(offsetof(FLegacySavedPlayerLoadoutData, SlasherFavor) == 0x000098, "Member 'FLegacySavedPlayerLoadoutData::SlasherFavor' has a wrong offset!");
static_assert(offsetof(FLegacySavedPlayerLoadoutData, SlasherCharacterClass) == 0x0000A4, "Member 'FLegacySavedPlayerLoadoutData::SlasherCharacterClass' has a wrong offset!");

// ScriptStruct DeadByDaylight.LoadoutPresetListId
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x04) FLoadoutPresetListId final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLoadoutPresetListId) == 0x000004, "Wrong alignment on FLoadoutPresetListId");
static_assert(sizeof(FLoadoutPresetListId) == 0x000008, "Wrong size on FLoadoutPresetListId");

// ScriptStruct DeadByDaylight.GameEventForwarderInfo
// 0x0020 (0x0020 - 0x0000)
struct FGameEventForwarderInfo final
{
public:
	TArray<struct FGameplayTag>                   GameEventsToRegister;                              // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ForwardedEvent;                                    // 0x0010(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameEventForwarderInfo) == 0x000008, "Wrong alignment on FGameEventForwarderInfo");
static_assert(sizeof(FGameEventForwarderInfo) == 0x000020, "Wrong size on FGameEventForwarderInfo");
static_assert(offsetof(FGameEventForwarderInfo, GameEventsToRegister) == 0x000000, "Member 'FGameEventForwarderInfo::GameEventsToRegister' has a wrong offset!");
static_assert(offsetof(FGameEventForwarderInfo, ForwardedEvent) == 0x000010, "Member 'FGameEventForwarderInfo::ForwardedEvent' has a wrong offset!");

// ScriptStruct DeadByDaylight.PlayerReadyStatusData
// 0x000C (0x000C - 0x0000)
struct FPlayerReadyStatusData final
{
public:
	int32                                         PlayerId;                                          // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SlotIndex;                                         // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsReady;                                           // 0x0008(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsSlasher;                                         // 0x0009(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsLocalPlayer;                                     // 0x000A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B[0x1];                                        // 0x000B(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerReadyStatusData) == 0x000004, "Wrong alignment on FPlayerReadyStatusData");
static_assert(sizeof(FPlayerReadyStatusData) == 0x00000C, "Wrong size on FPlayerReadyStatusData");
static_assert(offsetof(FPlayerReadyStatusData, PlayerId) == 0x000000, "Member 'FPlayerReadyStatusData::PlayerId' has a wrong offset!");
static_assert(offsetof(FPlayerReadyStatusData, SlotIndex) == 0x000004, "Member 'FPlayerReadyStatusData::SlotIndex' has a wrong offset!");
static_assert(offsetof(FPlayerReadyStatusData, IsReady) == 0x000008, "Member 'FPlayerReadyStatusData::IsReady' has a wrong offset!");
static_assert(offsetof(FPlayerReadyStatusData, IsSlasher) == 0x000009, "Member 'FPlayerReadyStatusData::IsSlasher' has a wrong offset!");
static_assert(offsetof(FPlayerReadyStatusData, IsLocalPlayer) == 0x00000A, "Member 'FPlayerReadyStatusData::IsLocalPlayer' has a wrong offset!");

// ScriptStruct DeadByDaylight.CharacterOverrideDropdown
// 0x000C (0x0014 - 0x0008)
struct FCharacterOverrideDropdown final : public FCharacterDropdown
{
public:
	class FName                                   OverrideId;                                        // 0x0008(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterOverrideDropdown) == 0x000004, "Wrong alignment on FCharacterOverrideDropdown");
static_assert(sizeof(FCharacterOverrideDropdown) == 0x000014, "Wrong size on FCharacterOverrideDropdown");
static_assert(offsetof(FCharacterOverrideDropdown, OverrideId) == 0x000008, "Member 'FCharacterOverrideDropdown::OverrideId' has a wrong offset!");

// ScriptStruct DeadByDaylight.HudEditorDragFromParentAxisLimit
// 0x0014 (0x0014 - 0x0000)
struct FHudEditorDragFromParentAxisLimit final
{
public:
	bool                                          Enable;                                            // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHudEditorDragAxisOption                      AxisOption;                                        // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinDragDistance;                                   // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ScaleMinDragDistanceWithParent;                    // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxDragDistance;                                   // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ScaleMaxDragDistanceWithParent;                    // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHudEditorDragFromParentAxisLimit) == 0x000004, "Wrong alignment on FHudEditorDragFromParentAxisLimit");
static_assert(sizeof(FHudEditorDragFromParentAxisLimit) == 0x000014, "Wrong size on FHudEditorDragFromParentAxisLimit");
static_assert(offsetof(FHudEditorDragFromParentAxisLimit, Enable) == 0x000000, "Member 'FHudEditorDragFromParentAxisLimit::Enable' has a wrong offset!");
static_assert(offsetof(FHudEditorDragFromParentAxisLimit, AxisOption) == 0x000001, "Member 'FHudEditorDragFromParentAxisLimit::AxisOption' has a wrong offset!");
static_assert(offsetof(FHudEditorDragFromParentAxisLimit, MinDragDistance) == 0x000004, "Member 'FHudEditorDragFromParentAxisLimit::MinDragDistance' has a wrong offset!");
static_assert(offsetof(FHudEditorDragFromParentAxisLimit, ScaleMinDragDistanceWithParent) == 0x000008, "Member 'FHudEditorDragFromParentAxisLimit::ScaleMinDragDistanceWithParent' has a wrong offset!");
static_assert(offsetof(FHudEditorDragFromParentAxisLimit, MaxDragDistance) == 0x00000C, "Member 'FHudEditorDragFromParentAxisLimit::MaxDragDistance' has a wrong offset!");
static_assert(offsetof(FHudEditorDragFromParentAxisLimit, ScaleMaxDragDistanceWithParent) == 0x000010, "Member 'FHudEditorDragFromParentAxisLimit::ScaleMaxDragDistanceWithParent' has a wrong offset!");

// ScriptStruct DeadByDaylight.CharacterSlideData
// 0x0068 (0x0068 - 0x0000)
struct FCharacterSlideData final
{
public:
	class FString                                 DisplayName;                                       // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Overview;                                          // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Playstyle;                                         // 0x0020(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerRole                                   Role;                                              // 0x0030(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ImageFilePath;                                     // 0x0038(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EPerkCategory>                         SurvivorPerkCategories;                            // 0x0048(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	class FString                                 KillerPowerIconPath;                               // 0x0058(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterSlideData) == 0x000008, "Wrong alignment on FCharacterSlideData");
static_assert(sizeof(FCharacterSlideData) == 0x000068, "Wrong size on FCharacterSlideData");
static_assert(offsetof(FCharacterSlideData, DisplayName) == 0x000000, "Member 'FCharacterSlideData::DisplayName' has a wrong offset!");
static_assert(offsetof(FCharacterSlideData, Overview) == 0x000010, "Member 'FCharacterSlideData::Overview' has a wrong offset!");
static_assert(offsetof(FCharacterSlideData, Playstyle) == 0x000020, "Member 'FCharacterSlideData::Playstyle' has a wrong offset!");
static_assert(offsetof(FCharacterSlideData, Role) == 0x000030, "Member 'FCharacterSlideData::Role' has a wrong offset!");
static_assert(offsetof(FCharacterSlideData, ImageFilePath) == 0x000038, "Member 'FCharacterSlideData::ImageFilePath' has a wrong offset!");
static_assert(offsetof(FCharacterSlideData, SurvivorPerkCategories) == 0x000048, "Member 'FCharacterSlideData::SurvivorPerkCategories' has a wrong offset!");
static_assert(offsetof(FCharacterSlideData, KillerPowerIconPath) == 0x000058, "Member 'FCharacterSlideData::KillerPowerIconPath' has a wrong offset!");

// ScriptStruct DeadByDaylight.PrestigeData
// 0x0008 (0x0008 - 0x0000)
struct FPrestigeData final
{
public:
	int32                                         Level;                                             // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Progress;                                          // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPrestigeData) == 0x000004, "Wrong alignment on FPrestigeData");
static_assert(sizeof(FPrestigeData) == 0x000008, "Wrong size on FPrestigeData");
static_assert(offsetof(FPrestigeData, Level) == 0x000000, "Member 'FPrestigeData::Level' has a wrong offset!");
static_assert(offsetof(FPrestigeData, Progress) == 0x000004, "Member 'FPrestigeData::Progress' has a wrong offset!");

// ScriptStruct DeadByDaylight.PurchaseCurrencyData
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FPurchaseCurrencyData final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	ECurrencyType                                 CurrencyType;                                      // 0x0008(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Price;                                             // 0x000C(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DiscountPercentage;                                // 0x0010(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsAffordable;                                      // 0x0014(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0xB];                                       // 0x0015(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPurchaseCurrencyData) == 0x000008, "Wrong alignment on FPurchaseCurrencyData");
static_assert(sizeof(FPurchaseCurrencyData) == 0x000020, "Wrong size on FPurchaseCurrencyData");
static_assert(offsetof(FPurchaseCurrencyData, CurrencyType) == 0x000008, "Member 'FPurchaseCurrencyData::CurrencyType' has a wrong offset!");
static_assert(offsetof(FPurchaseCurrencyData, Price) == 0x00000C, "Member 'FPurchaseCurrencyData::Price' has a wrong offset!");
static_assert(offsetof(FPurchaseCurrencyData, DiscountPercentage) == 0x000010, "Member 'FPurchaseCurrencyData::DiscountPercentage' has a wrong offset!");
static_assert(offsetof(FPurchaseCurrencyData, IsAffordable) == 0x000014, "Member 'FPurchaseCurrencyData::IsAffordable' has a wrong offset!");

// ScriptStruct DeadByDaylight.SpecialEventUIInfo
// 0x0060 (0x0060 - 0x0000)
struct FSpecialEventUIInfo final
{
public:
	class FString                                 EventID;                                           // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 EventBannerFrameLabel;                             // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 EventThemeFrameLabel;                              // 0x0020(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   EventName;                                         // 0x0030(0x0018)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPublic)
	bool                                          IsPastEvent;                                       // 0x0048(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsLTE;                                             // 0x0049(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A[0x6];                                       // 0x004A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 BloodwebCollectSoundEvent;                         // 0x0050(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpecialEventUIInfo) == 0x000008, "Wrong alignment on FSpecialEventUIInfo");
static_assert(sizeof(FSpecialEventUIInfo) == 0x000060, "Wrong size on FSpecialEventUIInfo");
static_assert(offsetof(FSpecialEventUIInfo, EventID) == 0x000000, "Member 'FSpecialEventUIInfo::EventID' has a wrong offset!");
static_assert(offsetof(FSpecialEventUIInfo, EventBannerFrameLabel) == 0x000010, "Member 'FSpecialEventUIInfo::EventBannerFrameLabel' has a wrong offset!");
static_assert(offsetof(FSpecialEventUIInfo, EventThemeFrameLabel) == 0x000020, "Member 'FSpecialEventUIInfo::EventThemeFrameLabel' has a wrong offset!");
static_assert(offsetof(FSpecialEventUIInfo, EventName) == 0x000030, "Member 'FSpecialEventUIInfo::EventName' has a wrong offset!");
static_assert(offsetof(FSpecialEventUIInfo, IsPastEvent) == 0x000048, "Member 'FSpecialEventUIInfo::IsPastEvent' has a wrong offset!");
static_assert(offsetof(FSpecialEventUIInfo, IsLTE) == 0x000049, "Member 'FSpecialEventUIInfo::IsLTE' has a wrong offset!");
static_assert(offsetof(FSpecialEventUIInfo, BloodwebCollectSoundEvent) == 0x000050, "Member 'FSpecialEventUIInfo::BloodwebCollectSoundEvent' has a wrong offset!");

// ScriptStruct DeadByDaylight.CharacterSlotData
// 0x01A0 (0x01A0 - 0x0000)
struct FCharacterSlotData final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ID;                                                // 0x0008(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CharacterIndex;                                    // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 IconFilePath;                                      // 0x0018(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 BackgroundImagePath;                               // 0x0028(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   DisplayName;                                       // 0x0038(0x0018)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPublic)
	class FText                                   BackStory;                                         // 0x0050(0x0018)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPublic)
	class FText                                   Biography;                                         // 0x0068(0x0018)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPublic)
	class FString                                 DLCId;                                             // 0x0080(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DLCTitle;                                          // 0x0090(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PackId;                                            // 0x00A0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PackTitle;                                         // 0x00B0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x00C0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrestigeData                          PrestigeData;                                      // 0x00C4(0x0008)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, NativeAccessSpecifierPublic)
	ECharacterDifficulty                          Difficulty;                                        // 0x00CC(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CD[0x3];                                       // 0x00CD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DifficultyName;                                    // 0x00D0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsUnlocked;                                        // 0x00E0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsDLCPurchasable;                                  // 0x00E1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsDLCValid;                                        // 0x00E2(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E3[0x5];                                       // 0x00E3(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPurchaseCurrencyData>          PurchaseDataList;                                  // 0x00E8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	int32                                         ItemsOwned;                                        // 0x00F8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TotalItems;                                        // 0x00FC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NewItemsCount;                                     // 0x0100(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShowNew;                                           // 0x0104(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsDlcLockedKiller;                                 // 0x0105(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_106[0x2];                                      // 0x0106(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSpecialEventUIInfo                    EventInfo;                                         // 0x0108(0x0060)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPublic)
	bool                                          IsEnabled;                                         // 0x0168(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDisabledItemOption                           DisabledItemOption;                                // 0x0169(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16A[0x6];                                      // 0x016A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          HasNonSelectedPerks;                               // 0x0170(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerRole                                   PlayerRole;                                        // 0x0171(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_172[0x6];                                      // 0x0172(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 RemainingTimeItem;                                 // 0x0178(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 RemainingTimeDiscount;                             // 0x0188(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumChars;                                          // 0x0198(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19C[0x4];                                      // 0x019C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCharacterSlotData) == 0x000008, "Wrong alignment on FCharacterSlotData");
static_assert(sizeof(FCharacterSlotData) == 0x0001A0, "Wrong size on FCharacterSlotData");
static_assert(offsetof(FCharacterSlotData, ID) == 0x000008, "Member 'FCharacterSlotData::ID' has a wrong offset!");
static_assert(offsetof(FCharacterSlotData, CharacterIndex) == 0x000014, "Member 'FCharacterSlotData::CharacterIndex' has a wrong offset!");
static_assert(offsetof(FCharacterSlotData, IconFilePath) == 0x000018, "Member 'FCharacterSlotData::IconFilePath' has a wrong offset!");
static_assert(offsetof(FCharacterSlotData, BackgroundImagePath) == 0x000028, "Member 'FCharacterSlotData::BackgroundImagePath' has a wrong offset!");
static_assert(offsetof(FCharacterSlotData, DisplayName) == 0x000038, "Member 'FCharacterSlotData::DisplayName' has a wrong offset!");
static_assert(offsetof(FCharacterSlotData, BackStory) == 0x000050, "Member 'FCharacterSlotData::BackStory' has a wrong offset!");
static_assert(offsetof(FCharacterSlotData, Biography) == 0x000068, "Member 'FCharacterSlotData::Biography' has a wrong offset!");
static_assert(offsetof(FCharacterSlotData, DLCId) == 0x000080, "Member 'FCharacterSlotData::DLCId' has a wrong offset!");
static_assert(offsetof(FCharacterSlotData, DLCTitle) == 0x000090, "Member 'FCharacterSlotData::DLCTitle' has a wrong offset!");
static_assert(offsetof(FCharacterSlotData, PackId) == 0x0000A0, "Member 'FCharacterSlotData::PackId' has a wrong offset!");
static_assert(offsetof(FCharacterSlotData, PackTitle) == 0x0000B0, "Member 'FCharacterSlotData::PackTitle' has a wrong offset!");
static_assert(offsetof(FCharacterSlotData, Level) == 0x0000C0, "Member 'FCharacterSlotData::Level' has a wrong offset!");
static_assert(offsetof(FCharacterSlotData, PrestigeData) == 0x0000C4, "Member 'FCharacterSlotData::PrestigeData' has a wrong offset!");
static_assert(offsetof(FCharacterSlotData, Difficulty) == 0x0000CC, "Member 'FCharacterSlotData::Difficulty' has a wrong offset!");
static_assert(offsetof(FCharacterSlotData, DifficultyName) == 0x0000D0, "Member 'FCharacterSlotData::DifficultyName' has a wrong offset!");
static_assert(offsetof(FCharacterSlotData, IsUnlocked) == 0x0000E0, "Member 'FCharacterSlotData::IsUnlocked' has a wrong offset!");
static_assert(offsetof(FCharacterSlotData, IsDLCPurchasable) == 0x0000E1, "Member 'FCharacterSlotData::IsDLCPurchasable' has a wrong offset!");
static_assert(offsetof(FCharacterSlotData, IsDLCValid) == 0x0000E2, "Member 'FCharacterSlotData::IsDLCValid' has a wrong offset!");
static_assert(offsetof(FCharacterSlotData, PurchaseDataList) == 0x0000E8, "Member 'FCharacterSlotData::PurchaseDataList' has a wrong offset!");
static_assert(offsetof(FCharacterSlotData, ItemsOwned) == 0x0000F8, "Member 'FCharacterSlotData::ItemsOwned' has a wrong offset!");
static_assert(offsetof(FCharacterSlotData, TotalItems) == 0x0000FC, "Member 'FCharacterSlotData::TotalItems' has a wrong offset!");
static_assert(offsetof(FCharacterSlotData, NewItemsCount) == 0x000100, "Member 'FCharacterSlotData::NewItemsCount' has a wrong offset!");
static_assert(offsetof(FCharacterSlotData, ShowNew) == 0x000104, "Member 'FCharacterSlotData::ShowNew' has a wrong offset!");
static_assert(offsetof(FCharacterSlotData, IsDlcLockedKiller) == 0x000105, "Member 'FCharacterSlotData::IsDlcLockedKiller' has a wrong offset!");
static_assert(offsetof(FCharacterSlotData, EventInfo) == 0x000108, "Member 'FCharacterSlotData::EventInfo' has a wrong offset!");
static_assert(offsetof(FCharacterSlotData, IsEnabled) == 0x000168, "Member 'FCharacterSlotData::IsEnabled' has a wrong offset!");
static_assert(offsetof(FCharacterSlotData, DisabledItemOption) == 0x000169, "Member 'FCharacterSlotData::DisabledItemOption' has a wrong offset!");
static_assert(offsetof(FCharacterSlotData, HasNonSelectedPerks) == 0x000170, "Member 'FCharacterSlotData::HasNonSelectedPerks' has a wrong offset!");
static_assert(offsetof(FCharacterSlotData, PlayerRole) == 0x000171, "Member 'FCharacterSlotData::PlayerRole' has a wrong offset!");
static_assert(offsetof(FCharacterSlotData, RemainingTimeItem) == 0x000178, "Member 'FCharacterSlotData::RemainingTimeItem' has a wrong offset!");
static_assert(offsetof(FCharacterSlotData, RemainingTimeDiscount) == 0x000188, "Member 'FCharacterSlotData::RemainingTimeDiscount' has a wrong offset!");
static_assert(offsetof(FCharacterSlotData, NumChars) == 0x000198, "Member 'FCharacterSlotData::NumChars' has a wrong offset!");

// ScriptStruct DeadByDaylight.LegacyPlayerSavedProfileDataShared
// 0x0040 (0x0040 - 0x0000)
struct FLegacyPlayerSavedProfileDataShared final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 PlayerName;                                        // 0x0008(0x0010)(ZeroConstructor, SaveGame, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SelectedCamperIndex;                               // 0x0018(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SelectedSlasherIndex;                              // 0x001C(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           SelectedCharacterCustomization;                    // 0x0020(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	int32                                         SlasherSkulls;                                     // 0x0030(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CamperSkulls;                                      // 0x0034(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CamperStreak;                                      // 0x0038(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLegacyPlayerSavedProfileDataShared) == 0x000008, "Wrong alignment on FLegacyPlayerSavedProfileDataShared");
static_assert(sizeof(FLegacyPlayerSavedProfileDataShared) == 0x000040, "Wrong size on FLegacyPlayerSavedProfileDataShared");
static_assert(offsetof(FLegacyPlayerSavedProfileDataShared, PlayerName) == 0x000008, "Member 'FLegacyPlayerSavedProfileDataShared::PlayerName' has a wrong offset!");
static_assert(offsetof(FLegacyPlayerSavedProfileDataShared, SelectedCamperIndex) == 0x000018, "Member 'FLegacyPlayerSavedProfileDataShared::SelectedCamperIndex' has a wrong offset!");
static_assert(offsetof(FLegacyPlayerSavedProfileDataShared, SelectedSlasherIndex) == 0x00001C, "Member 'FLegacyPlayerSavedProfileDataShared::SelectedSlasherIndex' has a wrong offset!");
static_assert(offsetof(FLegacyPlayerSavedProfileDataShared, SelectedCharacterCustomization) == 0x000020, "Member 'FLegacyPlayerSavedProfileDataShared::SelectedCharacterCustomization' has a wrong offset!");
static_assert(offsetof(FLegacyPlayerSavedProfileDataShared, SlasherSkulls) == 0x000030, "Member 'FLegacyPlayerSavedProfileDataShared::SlasherSkulls' has a wrong offset!");
static_assert(offsetof(FLegacyPlayerSavedProfileDataShared, CamperSkulls) == 0x000034, "Member 'FLegacyPlayerSavedProfileDataShared::CamperSkulls' has a wrong offset!");
static_assert(offsetof(FLegacyPlayerSavedProfileDataShared, CamperStreak) == 0x000038, "Member 'FLegacyPlayerSavedProfileDataShared::CamperStreak' has a wrong offset!");

// ScriptStruct DeadByDaylight.AIDifficultyTunableRowData
// 0x0010 (0x0018 - 0x0008)
struct FAIDifficultyTunableRowData final : public FDBDTableRowBase
{
public:
	float                                         VeryEasy;                                          // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Easy;                                              // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Medium;                                            // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Hard;                                              // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIDifficultyTunableRowData) == 0x000008, "Wrong alignment on FAIDifficultyTunableRowData");
static_assert(sizeof(FAIDifficultyTunableRowData) == 0x000018, "Wrong size on FAIDifficultyTunableRowData");
static_assert(offsetof(FAIDifficultyTunableRowData, VeryEasy) == 0x000008, "Member 'FAIDifficultyTunableRowData::VeryEasy' has a wrong offset!");
static_assert(offsetof(FAIDifficultyTunableRowData, Easy) == 0x00000C, "Member 'FAIDifficultyTunableRowData::Easy' has a wrong offset!");
static_assert(offsetof(FAIDifficultyTunableRowData, Medium) == 0x000010, "Member 'FAIDifficultyTunableRowData::Medium' has a wrong offset!");
static_assert(offsetof(FAIDifficultyTunableRowData, Hard) == 0x000014, "Member 'FAIDifficultyTunableRowData::Hard' has a wrong offset!");

// ScriptStruct DeadByDaylight.WalletUpdateTracker
// 0x0050 (0x0050 - 0x0000)
struct FWalletUpdateTracker final
{
public:
	TMap<class FString, int32>                    _walletChangeMap;                                  // 0x0000(0x0050)(NativeAccessSpecifierPrivate)
};
static_assert(alignof(FWalletUpdateTracker) == 0x000008, "Wrong alignment on FWalletUpdateTracker");
static_assert(sizeof(FWalletUpdateTracker) == 0x000050, "Wrong size on FWalletUpdateTracker");
static_assert(offsetof(FWalletUpdateTracker, _walletChangeMap) == 0x000000, "Member 'FWalletUpdateTracker::_walletChangeMap' has a wrong offset!");

// ScriptStruct DeadByDaylight.CharacterToolData
// 0x0080 (0x0080 - 0x0000)
struct FCharacterToolData final
{
public:
	EPlayerRole                                   Role;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CharacterId;                                       // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   OutfitId;                                          // 0x0008(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CharmId;                                           // 0x0014(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SurvivorHead;                                      // 0x0020(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SurvivorTorso;                                     // 0x002C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SurvivorLegs;                                      // 0x0038(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   KillerHead;                                        // 0x0044(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   KillerBody;                                        // 0x0050(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   KillerWeapon;                                      // 0x005C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsAnimBP;                                          // 0x0068(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 AnimAsset;                                         // 0x0070(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterToolData) == 0x000008, "Wrong alignment on FCharacterToolData");
static_assert(sizeof(FCharacterToolData) == 0x000080, "Wrong size on FCharacterToolData");
static_assert(offsetof(FCharacterToolData, Role) == 0x000000, "Member 'FCharacterToolData::Role' has a wrong offset!");
static_assert(offsetof(FCharacterToolData, CharacterId) == 0x000004, "Member 'FCharacterToolData::CharacterId' has a wrong offset!");
static_assert(offsetof(FCharacterToolData, OutfitId) == 0x000008, "Member 'FCharacterToolData::OutfitId' has a wrong offset!");
static_assert(offsetof(FCharacterToolData, CharmId) == 0x000014, "Member 'FCharacterToolData::CharmId' has a wrong offset!");
static_assert(offsetof(FCharacterToolData, SurvivorHead) == 0x000020, "Member 'FCharacterToolData::SurvivorHead' has a wrong offset!");
static_assert(offsetof(FCharacterToolData, SurvivorTorso) == 0x00002C, "Member 'FCharacterToolData::SurvivorTorso' has a wrong offset!");
static_assert(offsetof(FCharacterToolData, SurvivorLegs) == 0x000038, "Member 'FCharacterToolData::SurvivorLegs' has a wrong offset!");
static_assert(offsetof(FCharacterToolData, KillerHead) == 0x000044, "Member 'FCharacterToolData::KillerHead' has a wrong offset!");
static_assert(offsetof(FCharacterToolData, KillerBody) == 0x000050, "Member 'FCharacterToolData::KillerBody' has a wrong offset!");
static_assert(offsetof(FCharacterToolData, KillerWeapon) == 0x00005C, "Member 'FCharacterToolData::KillerWeapon' has a wrong offset!");
static_assert(offsetof(FCharacterToolData, IsAnimBP) == 0x000068, "Member 'FCharacterToolData::IsAnimBP' has a wrong offset!");
static_assert(offsetof(FCharacterToolData, AnimAsset) == 0x000070, "Member 'FCharacterToolData::AnimAsset' has a wrong offset!");

// ScriptStruct DeadByDaylight.CharacterToolItemData
// 0x0010 (0x0010 - 0x0000)
struct FCharacterToolItemData final
{
public:
	ECharacterToolItemType                        _type;                                             // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   _id;                                               // 0x0004(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FCharacterToolItemData) == 0x000004, "Wrong alignment on FCharacterToolItemData");
static_assert(sizeof(FCharacterToolItemData) == 0x000010, "Wrong size on FCharacterToolItemData");
static_assert(offsetof(FCharacterToolItemData, _type) == 0x000000, "Member 'FCharacterToolItemData::_type' has a wrong offset!");
static_assert(offsetof(FCharacterToolItemData, _id) == 0x000004, "Member 'FCharacterToolItemData::_id' has a wrong offset!");

// ScriptStruct DeadByDaylight.LegacySavedFearMarketItemInstance
// 0x0018 (0x0018 - 0x0000)
struct FLegacySavedFearMarketItemInstance final
{
public:
	class FName                                   ItemId;                                            // 0x0000(0x000C)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Cost;                                              // 0x000C(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BloodpointConversion;                              // 0x0010(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Purchased;                                         // 0x0014(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLegacySavedFearMarketItemInstance) == 0x000004, "Wrong alignment on FLegacySavedFearMarketItemInstance");
static_assert(sizeof(FLegacySavedFearMarketItemInstance) == 0x000018, "Wrong size on FLegacySavedFearMarketItemInstance");
static_assert(offsetof(FLegacySavedFearMarketItemInstance, ItemId) == 0x000000, "Member 'FLegacySavedFearMarketItemInstance::ItemId' has a wrong offset!");
static_assert(offsetof(FLegacySavedFearMarketItemInstance, Cost) == 0x00000C, "Member 'FLegacySavedFearMarketItemInstance::Cost' has a wrong offset!");
static_assert(offsetof(FLegacySavedFearMarketItemInstance, BloodpointConversion) == 0x000010, "Member 'FLegacySavedFearMarketItemInstance::BloodpointConversion' has a wrong offset!");
static_assert(offsetof(FLegacySavedFearMarketItemInstance, Purchased) == 0x000014, "Member 'FLegacySavedFearMarketItemInstance::Purchased' has a wrong offset!");

// ScriptStruct DeadByDaylight.LegacySavedFearMarketOfferingInstance
// 0x0020 (0x0020 - 0x0000)
struct FLegacySavedFearMarketOfferingInstance final
{
public:
	TArray<struct FLegacySavedFearMarketItemInstance> ObjectsForSale;                                    // 0x0000(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	struct FDateTime                              Starttime;                                         // 0x0010(0x0008)(ZeroConstructor, SaveGame, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              EndTime;                                           // 0x0018(0x0008)(ZeroConstructor, SaveGame, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLegacySavedFearMarketOfferingInstance) == 0x000008, "Wrong alignment on FLegacySavedFearMarketOfferingInstance");
static_assert(sizeof(FLegacySavedFearMarketOfferingInstance) == 0x000020, "Wrong size on FLegacySavedFearMarketOfferingInstance");
static_assert(offsetof(FLegacySavedFearMarketOfferingInstance, ObjectsForSale) == 0x000000, "Member 'FLegacySavedFearMarketOfferingInstance::ObjectsForSale' has a wrong offset!");
static_assert(offsetof(FLegacySavedFearMarketOfferingInstance, Starttime) == 0x000010, "Member 'FLegacySavedFearMarketOfferingInstance::Starttime' has a wrong offset!");
static_assert(offsetof(FLegacySavedFearMarketOfferingInstance, EndTime) == 0x000018, "Member 'FLegacySavedFearMarketOfferingInstance::EndTime' has a wrong offset!");

// ScriptStruct DeadByDaylight.CharacterViewTarget
// 0x0018 (0x0018 - 0x0000)
struct FCharacterViewTarget final
{
public:
	ECharacterCameraViewType                      Type;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 RawData;                                           // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterViewTarget) == 0x000008, "Wrong alignment on FCharacterViewTarget");
static_assert(sizeof(FCharacterViewTarget) == 0x000018, "Wrong size on FCharacterViewTarget");
static_assert(offsetof(FCharacterViewTarget, Type) == 0x000000, "Member 'FCharacterViewTarget::Type' has a wrong offset!");
static_assert(offsetof(FCharacterViewTarget, RawData) == 0x000008, "Member 'FCharacterViewTarget::RawData' has a wrong offset!");

// ScriptStruct DeadByDaylight.ChargeData
// 0x0010 (0x0010 - 0x0000)
struct FChargeData final
{
public:
	class AActor*                                 Instigator;                                        // 0x0000(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChargeAmount;                                      // 0x0008(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          BypassSkillCheckFail;                              // 0x000C(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsOneTimeIncrease;                                 // 0x000D(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E[0x2];                                        // 0x000E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FChargeData) == 0x000008, "Wrong alignment on FChargeData");
static_assert(sizeof(FChargeData) == 0x000010, "Wrong size on FChargeData");
static_assert(offsetof(FChargeData, Instigator) == 0x000000, "Member 'FChargeData::Instigator' has a wrong offset!");
static_assert(offsetof(FChargeData, ChargeAmount) == 0x000008, "Member 'FChargeData::ChargeAmount' has a wrong offset!");
static_assert(offsetof(FChargeData, BypassSkillCheckFail) == 0x00000C, "Member 'FChargeData::BypassSkillCheckFail' has a wrong offset!");
static_assert(offsetof(FChargeData, IsOneTimeIncrease) == 0x00000D, "Member 'FChargeData::IsOneTimeIncrease' has a wrong offset!");

// ScriptStruct DeadByDaylight.SessionInfos
// 0x0048 (0x0048 - 0x0000)
struct alignas(0x08) FSessionInfos final
{
public:
	uint8                                         Pad_0[0x48];                                       // 0x0000(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSessionInfos) == 0x000008, "Wrong alignment on FSessionInfos");
static_assert(sizeof(FSessionInfos) == 0x000048, "Wrong size on FSessionInfos");

// ScriptStruct DeadByDaylight.CharmAttacherAnimationTweak
// 0x0040 (0x0040 - 0x0000)
struct FCharmAttacherAnimationTweak final
{
public:
	TSubclassOf<class UAnimInstance>              OverrideAnimInstance;                              // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AttachPointTranslation;                            // 0x0008(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               AttachPointRotation;                               // 0x0020(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         ConstraintType;                                    // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MagicTweakingFloat;                                // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharmAttacherAnimationTweak) == 0x000008, "Wrong alignment on FCharmAttacherAnimationTweak");
static_assert(sizeof(FCharmAttacherAnimationTweak) == 0x000040, "Wrong size on FCharmAttacherAnimationTweak");
static_assert(offsetof(FCharmAttacherAnimationTweak, OverrideAnimInstance) == 0x000000, "Member 'FCharmAttacherAnimationTweak::OverrideAnimInstance' has a wrong offset!");
static_assert(offsetof(FCharmAttacherAnimationTweak, AttachPointTranslation) == 0x000008, "Member 'FCharmAttacherAnimationTweak::AttachPointTranslation' has a wrong offset!");
static_assert(offsetof(FCharmAttacherAnimationTweak, AttachPointRotation) == 0x000020, "Member 'FCharmAttacherAnimationTweak::AttachPointRotation' has a wrong offset!");
static_assert(offsetof(FCharmAttacherAnimationTweak, ConstraintType) == 0x000038, "Member 'FCharmAttacherAnimationTweak::ConstraintType' has a wrong offset!");
static_assert(offsetof(FCharmAttacherAnimationTweak, MagicTweakingFloat) == 0x00003C, "Member 'FCharmAttacherAnimationTweak::MagicTweakingFloat' has a wrong offset!");

// ScriptStruct DeadByDaylight.TypeFoliageToAutomateDensity
// 0x0078 (0x0078 - 0x0000)
struct FTypeFoliageToAutomateDensity final
{
public:
	TSoftObjectPtr<class UStaticMesh>             SourceMesh;                                        // 0x0000(0x0038)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UStaticMesh>             ReplacementMesh;                                   // 0x0038(0x0038)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGenerateOverlaps;                                 // 0x0070(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReceiveDecals;                                    // 0x0071(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECanBeCharacterBase                           bCanCharacterStepOn;                               // 0x0072(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDetailMode                                   DetailMode;                                        // 0x0073(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinimumFoliageRadius;                              // 0x0074(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTypeFoliageToAutomateDensity) == 0x000008, "Wrong alignment on FTypeFoliageToAutomateDensity");
static_assert(sizeof(FTypeFoliageToAutomateDensity) == 0x000078, "Wrong size on FTypeFoliageToAutomateDensity");
static_assert(offsetof(FTypeFoliageToAutomateDensity, SourceMesh) == 0x000000, "Member 'FTypeFoliageToAutomateDensity::SourceMesh' has a wrong offset!");
static_assert(offsetof(FTypeFoliageToAutomateDensity, ReplacementMesh) == 0x000038, "Member 'FTypeFoliageToAutomateDensity::ReplacementMesh' has a wrong offset!");
static_assert(offsetof(FTypeFoliageToAutomateDensity, bGenerateOverlaps) == 0x000070, "Member 'FTypeFoliageToAutomateDensity::bGenerateOverlaps' has a wrong offset!");
static_assert(offsetof(FTypeFoliageToAutomateDensity, bReceiveDecals) == 0x000071, "Member 'FTypeFoliageToAutomateDensity::bReceiveDecals' has a wrong offset!");
static_assert(offsetof(FTypeFoliageToAutomateDensity, bCanCharacterStepOn) == 0x000072, "Member 'FTypeFoliageToAutomateDensity::bCanCharacterStepOn' has a wrong offset!");
static_assert(offsetof(FTypeFoliageToAutomateDensity, DetailMode) == 0x000073, "Member 'FTypeFoliageToAutomateDensity::DetailMode' has a wrong offset!");
static_assert(offsetof(FTypeFoliageToAutomateDensity, MinimumFoliageRadius) == 0x000074, "Member 'FTypeFoliageToAutomateDensity::MinimumFoliageRadius' has a wrong offset!");

// ScriptStruct DeadByDaylight.CharmSlot
// 0x00D8 (0x00D8 - 0x0000)
struct FCharmSlot final
{
public:
	int32                                         SlotIndex;                                         // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   CharmAttacherClass;                                // 0x0008(0x0038)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCharmAttacherAnimationTweak           DefaultAnimationTweak;                             // 0x0040(0x0040)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	TMap<class FName, struct FCharmAttacherAnimationTweak> AnimationTweakByTag;                               // 0x0080(0x0050)(Edit, NativeAccessSpecifierPublic)
	class ACharmAttacher*                         CharmAttacherSpawned;                              // 0x00D0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharmSlot) == 0x000008, "Wrong alignment on FCharmSlot");
static_assert(sizeof(FCharmSlot) == 0x0000D8, "Wrong size on FCharmSlot");
static_assert(offsetof(FCharmSlot, SlotIndex) == 0x000000, "Member 'FCharmSlot::SlotIndex' has a wrong offset!");
static_assert(offsetof(FCharmSlot, CharmAttacherClass) == 0x000008, "Member 'FCharmSlot::CharmAttacherClass' has a wrong offset!");
static_assert(offsetof(FCharmSlot, DefaultAnimationTweak) == 0x000040, "Member 'FCharmSlot::DefaultAnimationTweak' has a wrong offset!");
static_assert(offsetof(FCharmSlot, AnimationTweakByTag) == 0x000080, "Member 'FCharmSlot::AnimationTweakByTag' has a wrong offset!");
static_assert(offsetof(FCharmSlot, CharmAttacherSpawned) == 0x0000D0, "Member 'FCharmSlot::CharmAttacherSpawned' has a wrong offset!");

// ScriptStruct DeadByDaylight.ChaseUpdateInfo
// 0x0048 (0x0048 - 0x0000)
struct FChaseUpdateInfo final
{
public:
	struct FTargetFocusTimer                      ChaseTimer;                                        // 0x0000(0x0038)(NativeAccessSpecifierPublic)
	float                                         SurvivorTravelDistance;                            // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KillerTravelDistance;                              // 0x003C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECamperDamageState                            ChaseStartHealthStatus;                            // 0x0040(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FChaseUpdateInfo) == 0x000008, "Wrong alignment on FChaseUpdateInfo");
static_assert(sizeof(FChaseUpdateInfo) == 0x000048, "Wrong size on FChaseUpdateInfo");
static_assert(offsetof(FChaseUpdateInfo, ChaseTimer) == 0x000000, "Member 'FChaseUpdateInfo::ChaseTimer' has a wrong offset!");
static_assert(offsetof(FChaseUpdateInfo, SurvivorTravelDistance) == 0x000038, "Member 'FChaseUpdateInfo::SurvivorTravelDistance' has a wrong offset!");
static_assert(offsetof(FChaseUpdateInfo, KillerTravelDistance) == 0x00003C, "Member 'FChaseUpdateInfo::KillerTravelDistance' has a wrong offset!");
static_assert(offsetof(FChaseUpdateInfo, ChaseStartHealthStatus) == 0x000040, "Member 'FChaseUpdateInfo::ChaseStartHealthStatus' has a wrong offset!");

// ScriptStruct DeadByDaylight.LegacySavedDailyRitualContainer
// 0x0018 (0x0018 - 0x0000)
struct FLegacySavedDailyRitualContainer final
{
public:
	struct FDateTime                              LastRitualReceivedDate;                            // 0x0000(0x0008)(ZeroConstructor, SaveGame, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FLegacySavedDailyRitualInstance> Rituals;                                           // 0x0008(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLegacySavedDailyRitualContainer) == 0x000008, "Wrong alignment on FLegacySavedDailyRitualContainer");
static_assert(sizeof(FLegacySavedDailyRitualContainer) == 0x000018, "Wrong size on FLegacySavedDailyRitualContainer");
static_assert(offsetof(FLegacySavedDailyRitualContainer, LastRitualReceivedDate) == 0x000000, "Member 'FLegacySavedDailyRitualContainer::LastRitualReceivedDate' has a wrong offset!");
static_assert(offsetof(FLegacySavedDailyRitualContainer, Rituals) == 0x000008, "Member 'FLegacySavedDailyRitualContainer::Rituals' has a wrong offset!");

// ScriptStruct DeadByDaylight.Cinematic
// 0x0078 (0x0078 - 0x0000)
struct alignas(0x08) FCinematic final
{
public:
	uint8                                         Pad_0[0x78];                                       // 0x0000(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCinematic) == 0x000008, "Wrong alignment on FCinematic");
static_assert(sizeof(FCinematic) == 0x000078, "Wrong size on FCinematic");

// ScriptStruct DeadByDaylight.StaticMeshesArrayForClip
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FStaticMeshesArrayForClip final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStaticMeshesArrayForClip) == 0x000008, "Wrong alignment on FStaticMeshesArrayForClip");
static_assert(sizeof(FStaticMeshesArrayForClip) == 0x000010, "Wrong size on FStaticMeshesArrayForClip");

// ScriptStruct DeadByDaylight.DBDOutlineRenderStrategySelector
// 0x0040 (0x0040 - 0x0000)
struct FDBDOutlineRenderStrategySelector final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 _actorForStrategy;                                 // 0x0008(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBaseOutlineRenderStrategy*             _selectedStrategy;                                 // 0x0010(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_18[0x28];                                      // 0x0018(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDBDOutlineRenderStrategySelector) == 0x000008, "Wrong alignment on FDBDOutlineRenderStrategySelector");
static_assert(sizeof(FDBDOutlineRenderStrategySelector) == 0x000040, "Wrong size on FDBDOutlineRenderStrategySelector");
static_assert(offsetof(FDBDOutlineRenderStrategySelector, _actorForStrategy) == 0x000008, "Member 'FDBDOutlineRenderStrategySelector::_actorForStrategy' has a wrong offset!");
static_assert(offsetof(FDBDOutlineRenderStrategySelector, _selectedStrategy) == 0x000010, "Member 'FDBDOutlineRenderStrategySelector::_selectedStrategy' has a wrong offset!");

// ScriptStruct DeadByDaylight.MaterialMapForClip
// 0x0020 (0x0028 - 0x0008)
struct FMaterialMapForClip final : public FDBDTableRowBase
{
public:
	class UMaterialInterface*                     SrcMaterial;                                       // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     DstMaterial;                                       // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UStaticMesh>>     StaticMeshToApply;                                 // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMaterialMapForClip) == 0x000008, "Wrong alignment on FMaterialMapForClip");
static_assert(sizeof(FMaterialMapForClip) == 0x000028, "Wrong size on FMaterialMapForClip");
static_assert(offsetof(FMaterialMapForClip, SrcMaterial) == 0x000008, "Member 'FMaterialMapForClip::SrcMaterial' has a wrong offset!");
static_assert(offsetof(FMaterialMapForClip, DstMaterial) == 0x000010, "Member 'FMaterialMapForClip::DstMaterial' has a wrong offset!");
static_assert(offsetof(FMaterialMapForClip, StaticMeshToApply) == 0x000018, "Member 'FMaterialMapForClip::StaticMeshToApply' has a wrong offset!");

// ScriptStruct DeadByDaylight.MaterialOriginalState
// 0x0018 (0x0018 - 0x0000)
struct FMaterialOriginalState final
{
public:
	class UMeshComponent*                         MeshWithChangedMaterials;                          // 0x0000(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UMaterialInterface*>             OriginalMaterial;                                  // 0x0008(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMaterialOriginalState) == 0x000008, "Wrong alignment on FMaterialOriginalState");
static_assert(sizeof(FMaterialOriginalState) == 0x000018, "Wrong size on FMaterialOriginalState");
static_assert(offsetof(FMaterialOriginalState, MeshWithChangedMaterials) == 0x000000, "Member 'FMaterialOriginalState::MeshWithChangedMaterials' has a wrong offset!");
static_assert(offsetof(FMaterialOriginalState, OriginalMaterial) == 0x000008, "Member 'FMaterialOriginalState::OriginalMaterial' has a wrong offset!");

// ScriptStruct DeadByDaylight.PlayerLoadoutData
// 0x00C0 (0x00C0 - 0x0000)
struct FPlayerLoadoutData final
{
public:
	class FName                                   Item;                                              // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           ItemAddOns;                                        // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           CamperPerks;                                       // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 CamperPerkLevels;                                  // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   CamperFavor;                                       // 0x0040(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CamperCharacterClass;                              // 0x004C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Power;                                             // 0x0058(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           PowerAddOns;                                       // 0x0068(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           SlasherPerks;                                      // 0x0078(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 SlasherPerkLevels;                                 // 0x0088(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   SlasherFavor;                                      // 0x0098(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SlasherCharacterClass;                             // 0x00A4(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EPerkCategory>                         RandomPerks;                                       // 0x00B0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerLoadoutData) == 0x000008, "Wrong alignment on FPlayerLoadoutData");
static_assert(sizeof(FPlayerLoadoutData) == 0x0000C0, "Wrong size on FPlayerLoadoutData");
static_assert(offsetof(FPlayerLoadoutData, Item) == 0x000000, "Member 'FPlayerLoadoutData::Item' has a wrong offset!");
static_assert(offsetof(FPlayerLoadoutData, ItemAddOns) == 0x000010, "Member 'FPlayerLoadoutData::ItemAddOns' has a wrong offset!");
static_assert(offsetof(FPlayerLoadoutData, CamperPerks) == 0x000020, "Member 'FPlayerLoadoutData::CamperPerks' has a wrong offset!");
static_assert(offsetof(FPlayerLoadoutData, CamperPerkLevels) == 0x000030, "Member 'FPlayerLoadoutData::CamperPerkLevels' has a wrong offset!");
static_assert(offsetof(FPlayerLoadoutData, CamperFavor) == 0x000040, "Member 'FPlayerLoadoutData::CamperFavor' has a wrong offset!");
static_assert(offsetof(FPlayerLoadoutData, CamperCharacterClass) == 0x00004C, "Member 'FPlayerLoadoutData::CamperCharacterClass' has a wrong offset!");
static_assert(offsetof(FPlayerLoadoutData, Power) == 0x000058, "Member 'FPlayerLoadoutData::Power' has a wrong offset!");
static_assert(offsetof(FPlayerLoadoutData, PowerAddOns) == 0x000068, "Member 'FPlayerLoadoutData::PowerAddOns' has a wrong offset!");
static_assert(offsetof(FPlayerLoadoutData, SlasherPerks) == 0x000078, "Member 'FPlayerLoadoutData::SlasherPerks' has a wrong offset!");
static_assert(offsetof(FPlayerLoadoutData, SlasherPerkLevels) == 0x000088, "Member 'FPlayerLoadoutData::SlasherPerkLevels' has a wrong offset!");
static_assert(offsetof(FPlayerLoadoutData, SlasherFavor) == 0x000098, "Member 'FPlayerLoadoutData::SlasherFavor' has a wrong offset!");
static_assert(offsetof(FPlayerLoadoutData, SlasherCharacterClass) == 0x0000A4, "Member 'FPlayerLoadoutData::SlasherCharacterClass' has a wrong offset!");
static_assert(offsetof(FPlayerLoadoutData, RandomPerks) == 0x0000B0, "Member 'FPlayerLoadoutData::RandomPerks' has a wrong offset!");

// ScriptStruct DeadByDaylight.PlayerSavedProfileDataShared
// 0x0068 (0x0068 - 0x0000)
struct FPlayerSavedProfileDataShared final
{
public:
	class FString                                 PlayerName;                                        // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SelectedCamperIndex;                               // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SelectedSlasherIndex;                              // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FEquippedPlayerCustomization           SelectedCharacterCustomization;                    // 0x0018(0x0038)(NativeAccessSpecifierPublic)
	int32                                         CamperStreak;                                      // 0x0050(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShowPortraitBorder;                                // 0x0054(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasActiveSubscription;                             // 0x0055(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_56[0x2];                                       // 0x0056(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 PlatformId;                                        // 0x0058(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FPlayerSavedProfileDataShared) == 0x000008, "Wrong alignment on FPlayerSavedProfileDataShared");
static_assert(sizeof(FPlayerSavedProfileDataShared) == 0x000068, "Wrong size on FPlayerSavedProfileDataShared");
static_assert(offsetof(FPlayerSavedProfileDataShared, PlayerName) == 0x000000, "Member 'FPlayerSavedProfileDataShared::PlayerName' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileDataShared, SelectedCamperIndex) == 0x000010, "Member 'FPlayerSavedProfileDataShared::SelectedCamperIndex' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileDataShared, SelectedSlasherIndex) == 0x000014, "Member 'FPlayerSavedProfileDataShared::SelectedSlasherIndex' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileDataShared, SelectedCharacterCustomization) == 0x000018, "Member 'FPlayerSavedProfileDataShared::SelectedCharacterCustomization' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileDataShared, CamperStreak) == 0x000050, "Member 'FPlayerSavedProfileDataShared::CamperStreak' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileDataShared, ShowPortraitBorder) == 0x000054, "Member 'FPlayerSavedProfileDataShared::ShowPortraitBorder' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileDataShared, HasActiveSubscription) == 0x000055, "Member 'FPlayerSavedProfileDataShared::HasActiveSubscription' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileDataShared, PlatformId) == 0x000058, "Member 'FPlayerSavedProfileDataShared::PlatformId' has a wrong offset!");

// ScriptStruct DeadByDaylight.DailyRitualSaveData
// 0x0008 (0x0008 - 0x0000)
struct FDailyRitualSaveData final
{
public:
	struct FDateTime                              LastRitualPopupDate;                               // 0x0000(0x0008)(ZeroConstructor, SaveGame, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDailyRitualSaveData) == 0x000008, "Wrong alignment on FDailyRitualSaveData");
static_assert(sizeof(FDailyRitualSaveData) == 0x000008, "Wrong size on FDailyRitualSaveData");
static_assert(offsetof(FDailyRitualSaveData, LastRitualPopupDate) == 0x000000, "Member 'FDailyRitualSaveData::LastRitualPopupDate' has a wrong offset!");

// ScriptStruct DeadByDaylight.SavedStoreFilters
// 0x0060 (0x0060 - 0x0000)
struct FSavedStoreFilters final
{
public:
	bool                                          IsAvailable;                                       // 0x0000(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsOwned;                                           // 0x0001(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EItemRarity, bool>                       RarityFilters;                                     // 0x0008(0x0050)(SaveGame, NativeAccessSpecifierPublic)
	ESortingOption                                SortingOption;                                     // 0x0058(0x0002)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESortingOrder                                 SortingOrder;                                      // 0x005A(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5B[0x5];                                       // 0x005B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSavedStoreFilters) == 0x000008, "Wrong alignment on FSavedStoreFilters");
static_assert(sizeof(FSavedStoreFilters) == 0x000060, "Wrong size on FSavedStoreFilters");
static_assert(offsetof(FSavedStoreFilters, IsAvailable) == 0x000000, "Member 'FSavedStoreFilters::IsAvailable' has a wrong offset!");
static_assert(offsetof(FSavedStoreFilters, IsOwned) == 0x000001, "Member 'FSavedStoreFilters::IsOwned' has a wrong offset!");
static_assert(offsetof(FSavedStoreFilters, RarityFilters) == 0x000008, "Member 'FSavedStoreFilters::RarityFilters' has a wrong offset!");
static_assert(offsetof(FSavedStoreFilters, SortingOption) == 0x000058, "Member 'FSavedStoreFilters::SortingOption' has a wrong offset!");
static_assert(offsetof(FSavedStoreFilters, SortingOrder) == 0x00005A, "Member 'FSavedStoreFilters::SortingOrder' has a wrong offset!");

// ScriptStruct DeadByDaylight.CharacterSavedProfileData
// 0x01C8 (0x01C8 - 0x0000)
struct FCharacterSavedProfileData final
{
public:
	int32                                         BloodWebLevel;                                     // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TimesConfronted;                                   // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FDateTime>                      PrestigeEarnedDates;                               // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FBloodWebPersistentData                BloodWebData;                                      // 0x0018(0x0050)(NativeAccessSpecifierPublic)
	struct FPlayerLoadoutData                     CharacterLoadoutData;                              // 0x0068(0x00C0)(NativeAccessSpecifierPublic)
	struct FEquippedPlayerCustomization           CurrentCustomization;                              // 0x0128(0x0038)(NativeAccessSpecifierPublic)
	TArray<class FName>                           UniquePerksAdded;                                  // 0x0160(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCharacterDataEntitlementScope> EntitlementScopes;                                 // 0x0170(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          CharacterBloodwebMigrationIsDone;                  // 0x0180(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_181[0x7];                                      // 0x0181(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCharacterSavedInventoryData>   InventoryData;                                     // 0x0188(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FSavedCharacterLevelData>       CharacterLevelData;                                // 0x0198(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FSavedStatsData>                StatProgression;                                   // 0x01A8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	int32                                         PrestigeLevel;                                     // 0x01B8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         LegacyPrestigeLevel;                               // 0x01BC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         CharacterExperience;                               // 0x01C0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1C4[0x4];                                      // 0x01C4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCharacterSavedProfileData) == 0x000008, "Wrong alignment on FCharacterSavedProfileData");
static_assert(sizeof(FCharacterSavedProfileData) == 0x0001C8, "Wrong size on FCharacterSavedProfileData");
static_assert(offsetof(FCharacterSavedProfileData, BloodWebLevel) == 0x000000, "Member 'FCharacterSavedProfileData::BloodWebLevel' has a wrong offset!");
static_assert(offsetof(FCharacterSavedProfileData, TimesConfronted) == 0x000004, "Member 'FCharacterSavedProfileData::TimesConfronted' has a wrong offset!");
static_assert(offsetof(FCharacterSavedProfileData, PrestigeEarnedDates) == 0x000008, "Member 'FCharacterSavedProfileData::PrestigeEarnedDates' has a wrong offset!");
static_assert(offsetof(FCharacterSavedProfileData, BloodWebData) == 0x000018, "Member 'FCharacterSavedProfileData::BloodWebData' has a wrong offset!");
static_assert(offsetof(FCharacterSavedProfileData, CharacterLoadoutData) == 0x000068, "Member 'FCharacterSavedProfileData::CharacterLoadoutData' has a wrong offset!");
static_assert(offsetof(FCharacterSavedProfileData, CurrentCustomization) == 0x000128, "Member 'FCharacterSavedProfileData::CurrentCustomization' has a wrong offset!");
static_assert(offsetof(FCharacterSavedProfileData, UniquePerksAdded) == 0x000160, "Member 'FCharacterSavedProfileData::UniquePerksAdded' has a wrong offset!");
static_assert(offsetof(FCharacterSavedProfileData, EntitlementScopes) == 0x000170, "Member 'FCharacterSavedProfileData::EntitlementScopes' has a wrong offset!");
static_assert(offsetof(FCharacterSavedProfileData, CharacterBloodwebMigrationIsDone) == 0x000180, "Member 'FCharacterSavedProfileData::CharacterBloodwebMigrationIsDone' has a wrong offset!");
static_assert(offsetof(FCharacterSavedProfileData, InventoryData) == 0x000188, "Member 'FCharacterSavedProfileData::InventoryData' has a wrong offset!");
static_assert(offsetof(FCharacterSavedProfileData, CharacterLevelData) == 0x000198, "Member 'FCharacterSavedProfileData::CharacterLevelData' has a wrong offset!");
static_assert(offsetof(FCharacterSavedProfileData, StatProgression) == 0x0001A8, "Member 'FCharacterSavedProfileData::StatProgression' has a wrong offset!");
static_assert(offsetof(FCharacterSavedProfileData, PrestigeLevel) == 0x0001B8, "Member 'FCharacterSavedProfileData::PrestigeLevel' has a wrong offset!");
static_assert(offsetof(FCharacterSavedProfileData, LegacyPrestigeLevel) == 0x0001BC, "Member 'FCharacterSavedProfileData::LegacyPrestigeLevel' has a wrong offset!");
static_assert(offsetof(FCharacterSavedProfileData, CharacterExperience) == 0x0001C0, "Member 'FCharacterSavedProfileData::CharacterExperience' has a wrong offset!");

// ScriptStruct DeadByDaylight.SpecialEventSavedData
// 0x0002 (0x0002 - 0x0000)
struct FSpecialEventSavedData final
{
public:
	bool                                          EventEntryScreenOpened;                            // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EventSplashScreenSeen;                             // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpecialEventSavedData) == 0x000001, "Wrong alignment on FSpecialEventSavedData");
static_assert(sizeof(FSpecialEventSavedData) == 0x000002, "Wrong size on FSpecialEventSavedData");
static_assert(offsetof(FSpecialEventSavedData, EventEntryScreenOpened) == 0x000000, "Member 'FSpecialEventSavedData::EventEntryScreenOpened' has a wrong offset!");
static_assert(offsetof(FSpecialEventSavedData, EventSplashScreenSeen) == 0x000001, "Member 'FSpecialEventSavedData::EventSplashScreenSeen' has a wrong offset!");

// ScriptStruct DeadByDaylight.ReleaseSavedData
// 0x0001 (0x0001 - 0x0000)
struct FReleaseSavedData final
{
public:
	bool                                          NewChapterPopupSeen;                               // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FReleaseSavedData) == 0x000001, "Wrong alignment on FReleaseSavedData");
static_assert(sizeof(FReleaseSavedData) == 0x000001, "Wrong size on FReleaseSavedData");
static_assert(offsetof(FReleaseSavedData, NewChapterPopupSeen) == 0x000000, "Member 'FReleaseSavedData::NewChapterPopupSeen' has a wrong offset!");

// ScriptStruct DeadByDaylight.PlayerSavedProfileDataLocal
// 0x0780 (0x0780 - 0x0000)
struct FPlayerSavedProfileDataLocal final
{
public:
	int32                                         Tokens;                                            // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           Offerings;                                         // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<class FName, bool>                       PageVisited;                                       // 0x0018(0x0050)(NativeAccessSpecifierPublic)
	TMap<class FName, bool>                       ChatVisible;                                       // 0x0068(0x0050)(NativeAccessSpecifierPublic)
	TMap<class FName, bool>                       OnboardingCompleted;                               // 0x00B8(0x0050)(NativeAccessSpecifierPublic)
	int32                                         ConsecutiveMatchStreak;                            // 0x0108(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Wins;                                              // 0x010C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Losses;                                            // 0x0110(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_114[0x4];                                      // 0x0114(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	uint64                                        CurrentSeasonTicks;                                // 0x0118(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDailyRitualSaveData                   DailyRitualSaveData;                               // 0x0120(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
	struct FUIViewFlagSaveData                    UIViewFlags;                                       // 0x0128(0x00F8)(NativeAccessSpecifierPublic)
	struct FFearMarketOfferingInstance            FearMarket;                                        // 0x0220(0x0020)(NativeAccessSpecifierPublic)
	struct FPlayerLoadoutData                     LastConnectedLoadout;                              // 0x0240(0x00C0)(NativeAccessSpecifierPublic)
	int32                                         LastConnectedCharacterIndex;                       // 0x0300(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_304[0x4];                                      // 0x0304(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              DisconnectPenaltyTime;                             // 0x0308(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              LastMatchEndTime;                                  // 0x0310(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              LastMatchStartTime;                                // 0x0318(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              LastKillerMatchEndTime;                            // 0x0320(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              LastSurvivorMatchEndTime;                          // 0x0328(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBloodWebPersistentData                BloodStoreKillers;                                 // 0x0330(0x0050)(NativeAccessSpecifierPublic)
	struct FBloodWebPersistentData                BloodStoreSurvivors;                               // 0x0380(0x0050)(NativeAccessSpecifierPublic)
	bool                                          CrossplayAllowed;                                  // 0x03D0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AutoDeclineFriendInvites;                          // 0x03D1(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D2[0x6];                                      // 0x03D2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCharacterCustomizationPresetsList> CharacterCustomizationPresets;                     // 0x03D8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<class FString, struct FCustomizationPresetsDataForGameType> CharacterCustomizationPresetsPerGameType;          // 0x03E8(0x0050)(NativeAccessSpecifierPublic)
	TArray<struct FCharacterLoadoutPresetsList>   CharacterLoadoutPresets;                           // 0x0438(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<class FString, struct FLoadoutPresetsDataForGameType> CharacterLoadoutPresetsPerGameType;                // 0x0448(0x0050)(NativeAccessSpecifierPublic)
	TMap<class FName, struct FSavedStoreFilters>  SavedStoreFilters;                                 // 0x0498(0x0050)(NativeAccessSpecifierPublic)
	struct FPlayerSavedProfileCumulativeData      _cumulativeData;                                   // 0x04E8(0x0048)(NoDestructor, NativeAccessSpecifierPrivate)
	TArray<struct FSavedStatsData>                _savedPlayerStats;                                 // 0x0530(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	bool                                          _hasBeenGivenKillerTutorialEndReward;              // 0x0540(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _hasBeenGivenSurvivorTutorialEndReward;            // 0x0541(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _hasSeenBloodpointsOnboardingCurrencyPopup;        // 0x0542(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _hasSeenAuricCellsOnboardingCurrencyPopup;         // 0x0543(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _hasSeenIridescentShardsOnboardingCurrencyPopup;   // 0x0544(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _hasSeenLightSensitivity;                          // 0x0545(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _hasSeenMainMenu;                                  // 0x0546(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_547[0x1];                                      // 0x0547(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, struct FCharacterSavedProfileData> _characterData;                                    // 0x0548(0x0050)(NativeAccessSpecifierPrivate)
	TMap<class FName, struct FSpecialEventSavedData> _specialEvent;                                     // 0x0598(0x0050)(NativeAccessSpecifierPrivate)
	TSet<class FName>                             _seenCinematics;                                   // 0x05E8(0x0050)(NativeAccessSpecifierPrivate)
	TSet<class FName>                             _seenFeatures;                                     // 0x0638(0x0050)(NativeAccessSpecifierPrivate)
	TSet<class FName>                             _seenSecretRewardPopups;                           // 0x0688(0x0050)(NativeAccessSpecifierPrivate)
	TMap<class FName, struct FSavedSeenPopupData> _seenPopupsData;                                   // 0x06D8(0x0050)(NativeAccessSpecifierPrivate)
	TMap<class FString, struct FReleaseSavedData> _releases;                                         // 0x0728(0x0050)(NativeAccessSpecifierPrivate)
	bool                                          _hasBeginnerTooltipsBeenDisabledAtLevel;           // 0x0778(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_779[0x7];                                      // 0x0779(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerSavedProfileDataLocal) == 0x000008, "Wrong alignment on FPlayerSavedProfileDataLocal");
static_assert(sizeof(FPlayerSavedProfileDataLocal) == 0x000780, "Wrong size on FPlayerSavedProfileDataLocal");
static_assert(offsetof(FPlayerSavedProfileDataLocal, Tokens) == 0x000000, "Member 'FPlayerSavedProfileDataLocal::Tokens' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileDataLocal, Offerings) == 0x000008, "Member 'FPlayerSavedProfileDataLocal::Offerings' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileDataLocal, PageVisited) == 0x000018, "Member 'FPlayerSavedProfileDataLocal::PageVisited' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileDataLocal, ChatVisible) == 0x000068, "Member 'FPlayerSavedProfileDataLocal::ChatVisible' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileDataLocal, OnboardingCompleted) == 0x0000B8, "Member 'FPlayerSavedProfileDataLocal::OnboardingCompleted' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileDataLocal, ConsecutiveMatchStreak) == 0x000108, "Member 'FPlayerSavedProfileDataLocal::ConsecutiveMatchStreak' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileDataLocal, Wins) == 0x00010C, "Member 'FPlayerSavedProfileDataLocal::Wins' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileDataLocal, Losses) == 0x000110, "Member 'FPlayerSavedProfileDataLocal::Losses' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileDataLocal, CurrentSeasonTicks) == 0x000118, "Member 'FPlayerSavedProfileDataLocal::CurrentSeasonTicks' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileDataLocal, DailyRitualSaveData) == 0x000120, "Member 'FPlayerSavedProfileDataLocal::DailyRitualSaveData' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileDataLocal, UIViewFlags) == 0x000128, "Member 'FPlayerSavedProfileDataLocal::UIViewFlags' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileDataLocal, FearMarket) == 0x000220, "Member 'FPlayerSavedProfileDataLocal::FearMarket' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileDataLocal, LastConnectedLoadout) == 0x000240, "Member 'FPlayerSavedProfileDataLocal::LastConnectedLoadout' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileDataLocal, LastConnectedCharacterIndex) == 0x000300, "Member 'FPlayerSavedProfileDataLocal::LastConnectedCharacterIndex' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileDataLocal, DisconnectPenaltyTime) == 0x000308, "Member 'FPlayerSavedProfileDataLocal::DisconnectPenaltyTime' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileDataLocal, LastMatchEndTime) == 0x000310, "Member 'FPlayerSavedProfileDataLocal::LastMatchEndTime' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileDataLocal, LastMatchStartTime) == 0x000318, "Member 'FPlayerSavedProfileDataLocal::LastMatchStartTime' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileDataLocal, LastKillerMatchEndTime) == 0x000320, "Member 'FPlayerSavedProfileDataLocal::LastKillerMatchEndTime' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileDataLocal, LastSurvivorMatchEndTime) == 0x000328, "Member 'FPlayerSavedProfileDataLocal::LastSurvivorMatchEndTime' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileDataLocal, BloodStoreKillers) == 0x000330, "Member 'FPlayerSavedProfileDataLocal::BloodStoreKillers' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileDataLocal, BloodStoreSurvivors) == 0x000380, "Member 'FPlayerSavedProfileDataLocal::BloodStoreSurvivors' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileDataLocal, CrossplayAllowed) == 0x0003D0, "Member 'FPlayerSavedProfileDataLocal::CrossplayAllowed' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileDataLocal, AutoDeclineFriendInvites) == 0x0003D1, "Member 'FPlayerSavedProfileDataLocal::AutoDeclineFriendInvites' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileDataLocal, CharacterCustomizationPresets) == 0x0003D8, "Member 'FPlayerSavedProfileDataLocal::CharacterCustomizationPresets' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileDataLocal, CharacterCustomizationPresetsPerGameType) == 0x0003E8, "Member 'FPlayerSavedProfileDataLocal::CharacterCustomizationPresetsPerGameType' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileDataLocal, CharacterLoadoutPresets) == 0x000438, "Member 'FPlayerSavedProfileDataLocal::CharacterLoadoutPresets' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileDataLocal, CharacterLoadoutPresetsPerGameType) == 0x000448, "Member 'FPlayerSavedProfileDataLocal::CharacterLoadoutPresetsPerGameType' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileDataLocal, SavedStoreFilters) == 0x000498, "Member 'FPlayerSavedProfileDataLocal::SavedStoreFilters' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileDataLocal, _cumulativeData) == 0x0004E8, "Member 'FPlayerSavedProfileDataLocal::_cumulativeData' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileDataLocal, _savedPlayerStats) == 0x000530, "Member 'FPlayerSavedProfileDataLocal::_savedPlayerStats' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileDataLocal, _hasBeenGivenKillerTutorialEndReward) == 0x000540, "Member 'FPlayerSavedProfileDataLocal::_hasBeenGivenKillerTutorialEndReward' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileDataLocal, _hasBeenGivenSurvivorTutorialEndReward) == 0x000541, "Member 'FPlayerSavedProfileDataLocal::_hasBeenGivenSurvivorTutorialEndReward' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileDataLocal, _hasSeenBloodpointsOnboardingCurrencyPopup) == 0x000542, "Member 'FPlayerSavedProfileDataLocal::_hasSeenBloodpointsOnboardingCurrencyPopup' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileDataLocal, _hasSeenAuricCellsOnboardingCurrencyPopup) == 0x000543, "Member 'FPlayerSavedProfileDataLocal::_hasSeenAuricCellsOnboardingCurrencyPopup' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileDataLocal, _hasSeenIridescentShardsOnboardingCurrencyPopup) == 0x000544, "Member 'FPlayerSavedProfileDataLocal::_hasSeenIridescentShardsOnboardingCurrencyPopup' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileDataLocal, _hasSeenLightSensitivity) == 0x000545, "Member 'FPlayerSavedProfileDataLocal::_hasSeenLightSensitivity' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileDataLocal, _hasSeenMainMenu) == 0x000546, "Member 'FPlayerSavedProfileDataLocal::_hasSeenMainMenu' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileDataLocal, _characterData) == 0x000548, "Member 'FPlayerSavedProfileDataLocal::_characterData' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileDataLocal, _specialEvent) == 0x000598, "Member 'FPlayerSavedProfileDataLocal::_specialEvent' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileDataLocal, _seenCinematics) == 0x0005E8, "Member 'FPlayerSavedProfileDataLocal::_seenCinematics' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileDataLocal, _seenFeatures) == 0x000638, "Member 'FPlayerSavedProfileDataLocal::_seenFeatures' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileDataLocal, _seenSecretRewardPopups) == 0x000688, "Member 'FPlayerSavedProfileDataLocal::_seenSecretRewardPopups' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileDataLocal, _seenPopupsData) == 0x0006D8, "Member 'FPlayerSavedProfileDataLocal::_seenPopupsData' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileDataLocal, _releases) == 0x000728, "Member 'FPlayerSavedProfileDataLocal::_releases' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileDataLocal, _hasBeginnerTooltipsBeenDisabledAtLevel) == 0x000778, "Member 'FPlayerSavedProfileDataLocal::_hasBeginnerTooltipsBeenDisabledAtLevel' has a wrong offset!");

// ScriptStruct DeadByDaylight.ConsoleUserSettings
// 0x00E8 (0x00E8 - 0x0000)
struct FConsoleUserSettings final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FInputActionKeyMapping>         ActionMappings;                                    // 0x0008(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	TArray<struct FInputAxisKeyMapping>           AxisMappings;                                      // 0x0018(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	int32                                         MenuScaleFactor;                                   // 0x0028(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HudScaleFactor;                                    // 0x002C(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SkillCheckScaleFactor;                             // 0x0030(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          LargeText;                                         // 0x0034(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          BloodwebInteractionBehaviour;                      // 0x0035(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TerrorRadiusVisualFeedback;                        // 0x0036(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_37[0x1];                                       // 0x0037(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         FieldOfView;                                       // 0x0038(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Gamma;                                             // 0x003C(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HUDPlayerNamesVisibility;                          // 0x0040(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HUDScoreEventsVisibility;                          // 0x0041(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HUDKillerHookCountVisibility;                      // 0x0042(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HUDUseItemPickupPopupAbridgedVersion;              // 0x0043(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SurvivorSpecificPingIcon;                          // 0x0044(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          LegacyPrestigePortraits;                           // 0x0045(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_46[0x2];                                       // 0x0046(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MainVolume;                                        // 0x0048(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MenuMusicVolume;                                   // 0x004C(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseHeadphones;                                     // 0x0050(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MuteOnFocusLost;                                   // 0x0051(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HapticsVibrationPS5;                               // 0x0052(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_53[0x1];                                       // 0x0053(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         KillerMouseSensitivity;                            // 0x0054(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SurvivorMouseSensitivity;                          // 0x0058(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         KillerControllerSensitivity;                       // 0x005C(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SurvivorControllerSensitivity;                     // 0x0060(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InvertY;                                           // 0x0064(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SurvivorInvertY;                                   // 0x0065(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          KillerToggleInteractions;                          // 0x0066(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SurvivorToggleInteractions;                        // 0x0067(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SprintToCancel;                                    // 0x0068(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x3];                                       // 0x0069(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         HighestWeightSeenNews;                             // 0x006C(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseAtlantaCustomizedHuds;                          // 0x0070(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseAtlantaSurvivorQuickTurn;                       // 0x0071(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseAtlantaKillerQuickTurn;                         // 0x0072(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_73[0x5];                                       // 0x0073(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAtlantaCustomizedHudSettings>  AtlantaCustomizedHuds;                             // 0x0078(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	bool                                          HasAcceptedCrossplayPopup;                         // 0x0088(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasAcceptedProgressionSystemInfoPopup;             // 0x0089(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8A[0x6];                                       // 0x008A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBonusTierTooltipVisibility            BonusTierTooltipVisibility;                        // 0x0090(0x0018)(SaveGame, NativeAccessSpecifierPublic)
	class FString                                 PartyPrivacyState;                                 // 0x00A8(0x0010)(ZeroConstructor, SaveGame, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ColorBlindMode;                                    // 0x00B8(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ColorBlindModeIntensity;                           // 0x00BC(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          BeginnerMode;                                      // 0x00C0(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          FogCommunications;                                 // 0x00C1(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Subtitles;                                         // 0x00C2(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C3[0x1];                                       // 0x00C3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SubtitlesBackgroundOpacity;                        // 0x00C4(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SubtitlesSize;                                     // 0x00C8(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsAnonymousMode;                                   // 0x00CC(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AllowCopyrightedMusic;                             // 0x00CD(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HideYourName;                                      // 0x00CE(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HideOtherNames;                                    // 0x00CF(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HiddenMatchmakingDelay;                            // 0x00D0(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasAcceptedHapticsVibrationPopup;                  // 0x00D1(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D2[0x2];                                       // 0x00D2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PlayerCardAnimationMode;                           // 0x00D4(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnableFSR;                                         // 0x00D8(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D9[0x3];                                       // 0x00D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SharpnessValue;                                    // 0x00DC(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ChallengeProgression;                              // 0x00E0(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DailyChallengeProgression;                         // 0x00E1(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          WeeklyChallengeProgression;                        // 0x00E2(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EventChallengeProgression;                         // 0x00E3(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AllChallengeProgression;                           // 0x00E4(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E5[0x3];                                       // 0x00E5(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FConsoleUserSettings) == 0x000008, "Wrong alignment on FConsoleUserSettings");
static_assert(sizeof(FConsoleUserSettings) == 0x0000E8, "Wrong size on FConsoleUserSettings");
static_assert(offsetof(FConsoleUserSettings, ActionMappings) == 0x000008, "Member 'FConsoleUserSettings::ActionMappings' has a wrong offset!");
static_assert(offsetof(FConsoleUserSettings, AxisMappings) == 0x000018, "Member 'FConsoleUserSettings::AxisMappings' has a wrong offset!");
static_assert(offsetof(FConsoleUserSettings, MenuScaleFactor) == 0x000028, "Member 'FConsoleUserSettings::MenuScaleFactor' has a wrong offset!");
static_assert(offsetof(FConsoleUserSettings, HudScaleFactor) == 0x00002C, "Member 'FConsoleUserSettings::HudScaleFactor' has a wrong offset!");
static_assert(offsetof(FConsoleUserSettings, SkillCheckScaleFactor) == 0x000030, "Member 'FConsoleUserSettings::SkillCheckScaleFactor' has a wrong offset!");
static_assert(offsetof(FConsoleUserSettings, LargeText) == 0x000034, "Member 'FConsoleUserSettings::LargeText' has a wrong offset!");
static_assert(offsetof(FConsoleUserSettings, BloodwebInteractionBehaviour) == 0x000035, "Member 'FConsoleUserSettings::BloodwebInteractionBehaviour' has a wrong offset!");
static_assert(offsetof(FConsoleUserSettings, TerrorRadiusVisualFeedback) == 0x000036, "Member 'FConsoleUserSettings::TerrorRadiusVisualFeedback' has a wrong offset!");
static_assert(offsetof(FConsoleUserSettings, FieldOfView) == 0x000038, "Member 'FConsoleUserSettings::FieldOfView' has a wrong offset!");
static_assert(offsetof(FConsoleUserSettings, Gamma) == 0x00003C, "Member 'FConsoleUserSettings::Gamma' has a wrong offset!");
static_assert(offsetof(FConsoleUserSettings, HUDPlayerNamesVisibility) == 0x000040, "Member 'FConsoleUserSettings::HUDPlayerNamesVisibility' has a wrong offset!");
static_assert(offsetof(FConsoleUserSettings, HUDScoreEventsVisibility) == 0x000041, "Member 'FConsoleUserSettings::HUDScoreEventsVisibility' has a wrong offset!");
static_assert(offsetof(FConsoleUserSettings, HUDKillerHookCountVisibility) == 0x000042, "Member 'FConsoleUserSettings::HUDKillerHookCountVisibility' has a wrong offset!");
static_assert(offsetof(FConsoleUserSettings, HUDUseItemPickupPopupAbridgedVersion) == 0x000043, "Member 'FConsoleUserSettings::HUDUseItemPickupPopupAbridgedVersion' has a wrong offset!");
static_assert(offsetof(FConsoleUserSettings, SurvivorSpecificPingIcon) == 0x000044, "Member 'FConsoleUserSettings::SurvivorSpecificPingIcon' has a wrong offset!");
static_assert(offsetof(FConsoleUserSettings, LegacyPrestigePortraits) == 0x000045, "Member 'FConsoleUserSettings::LegacyPrestigePortraits' has a wrong offset!");
static_assert(offsetof(FConsoleUserSettings, MainVolume) == 0x000048, "Member 'FConsoleUserSettings::MainVolume' has a wrong offset!");
static_assert(offsetof(FConsoleUserSettings, MenuMusicVolume) == 0x00004C, "Member 'FConsoleUserSettings::MenuMusicVolume' has a wrong offset!");
static_assert(offsetof(FConsoleUserSettings, UseHeadphones) == 0x000050, "Member 'FConsoleUserSettings::UseHeadphones' has a wrong offset!");
static_assert(offsetof(FConsoleUserSettings, MuteOnFocusLost) == 0x000051, "Member 'FConsoleUserSettings::MuteOnFocusLost' has a wrong offset!");
static_assert(offsetof(FConsoleUserSettings, HapticsVibrationPS5) == 0x000052, "Member 'FConsoleUserSettings::HapticsVibrationPS5' has a wrong offset!");
static_assert(offsetof(FConsoleUserSettings, KillerMouseSensitivity) == 0x000054, "Member 'FConsoleUserSettings::KillerMouseSensitivity' has a wrong offset!");
static_assert(offsetof(FConsoleUserSettings, SurvivorMouseSensitivity) == 0x000058, "Member 'FConsoleUserSettings::SurvivorMouseSensitivity' has a wrong offset!");
static_assert(offsetof(FConsoleUserSettings, KillerControllerSensitivity) == 0x00005C, "Member 'FConsoleUserSettings::KillerControllerSensitivity' has a wrong offset!");
static_assert(offsetof(FConsoleUserSettings, SurvivorControllerSensitivity) == 0x000060, "Member 'FConsoleUserSettings::SurvivorControllerSensitivity' has a wrong offset!");
static_assert(offsetof(FConsoleUserSettings, InvertY) == 0x000064, "Member 'FConsoleUserSettings::InvertY' has a wrong offset!");
static_assert(offsetof(FConsoleUserSettings, SurvivorInvertY) == 0x000065, "Member 'FConsoleUserSettings::SurvivorInvertY' has a wrong offset!");
static_assert(offsetof(FConsoleUserSettings, KillerToggleInteractions) == 0x000066, "Member 'FConsoleUserSettings::KillerToggleInteractions' has a wrong offset!");
static_assert(offsetof(FConsoleUserSettings, SurvivorToggleInteractions) == 0x000067, "Member 'FConsoleUserSettings::SurvivorToggleInteractions' has a wrong offset!");
static_assert(offsetof(FConsoleUserSettings, SprintToCancel) == 0x000068, "Member 'FConsoleUserSettings::SprintToCancel' has a wrong offset!");
static_assert(offsetof(FConsoleUserSettings, HighestWeightSeenNews) == 0x00006C, "Member 'FConsoleUserSettings::HighestWeightSeenNews' has a wrong offset!");
static_assert(offsetof(FConsoleUserSettings, UseAtlantaCustomizedHuds) == 0x000070, "Member 'FConsoleUserSettings::UseAtlantaCustomizedHuds' has a wrong offset!");
static_assert(offsetof(FConsoleUserSettings, UseAtlantaSurvivorQuickTurn) == 0x000071, "Member 'FConsoleUserSettings::UseAtlantaSurvivorQuickTurn' has a wrong offset!");
static_assert(offsetof(FConsoleUserSettings, UseAtlantaKillerQuickTurn) == 0x000072, "Member 'FConsoleUserSettings::UseAtlantaKillerQuickTurn' has a wrong offset!");
static_assert(offsetof(FConsoleUserSettings, AtlantaCustomizedHuds) == 0x000078, "Member 'FConsoleUserSettings::AtlantaCustomizedHuds' has a wrong offset!");
static_assert(offsetof(FConsoleUserSettings, HasAcceptedCrossplayPopup) == 0x000088, "Member 'FConsoleUserSettings::HasAcceptedCrossplayPopup' has a wrong offset!");
static_assert(offsetof(FConsoleUserSettings, HasAcceptedProgressionSystemInfoPopup) == 0x000089, "Member 'FConsoleUserSettings::HasAcceptedProgressionSystemInfoPopup' has a wrong offset!");
static_assert(offsetof(FConsoleUserSettings, BonusTierTooltipVisibility) == 0x000090, "Member 'FConsoleUserSettings::BonusTierTooltipVisibility' has a wrong offset!");
static_assert(offsetof(FConsoleUserSettings, PartyPrivacyState) == 0x0000A8, "Member 'FConsoleUserSettings::PartyPrivacyState' has a wrong offset!");
static_assert(offsetof(FConsoleUserSettings, ColorBlindMode) == 0x0000B8, "Member 'FConsoleUserSettings::ColorBlindMode' has a wrong offset!");
static_assert(offsetof(FConsoleUserSettings, ColorBlindModeIntensity) == 0x0000BC, "Member 'FConsoleUserSettings::ColorBlindModeIntensity' has a wrong offset!");
static_assert(offsetof(FConsoleUserSettings, BeginnerMode) == 0x0000C0, "Member 'FConsoleUserSettings::BeginnerMode' has a wrong offset!");
static_assert(offsetof(FConsoleUserSettings, FogCommunications) == 0x0000C1, "Member 'FConsoleUserSettings::FogCommunications' has a wrong offset!");
static_assert(offsetof(FConsoleUserSettings, Subtitles) == 0x0000C2, "Member 'FConsoleUserSettings::Subtitles' has a wrong offset!");
static_assert(offsetof(FConsoleUserSettings, SubtitlesBackgroundOpacity) == 0x0000C4, "Member 'FConsoleUserSettings::SubtitlesBackgroundOpacity' has a wrong offset!");
static_assert(offsetof(FConsoleUserSettings, SubtitlesSize) == 0x0000C8, "Member 'FConsoleUserSettings::SubtitlesSize' has a wrong offset!");
static_assert(offsetof(FConsoleUserSettings, IsAnonymousMode) == 0x0000CC, "Member 'FConsoleUserSettings::IsAnonymousMode' has a wrong offset!");
static_assert(offsetof(FConsoleUserSettings, AllowCopyrightedMusic) == 0x0000CD, "Member 'FConsoleUserSettings::AllowCopyrightedMusic' has a wrong offset!");
static_assert(offsetof(FConsoleUserSettings, HideYourName) == 0x0000CE, "Member 'FConsoleUserSettings::HideYourName' has a wrong offset!");
static_assert(offsetof(FConsoleUserSettings, HideOtherNames) == 0x0000CF, "Member 'FConsoleUserSettings::HideOtherNames' has a wrong offset!");
static_assert(offsetof(FConsoleUserSettings, HiddenMatchmakingDelay) == 0x0000D0, "Member 'FConsoleUserSettings::HiddenMatchmakingDelay' has a wrong offset!");
static_assert(offsetof(FConsoleUserSettings, HasAcceptedHapticsVibrationPopup) == 0x0000D1, "Member 'FConsoleUserSettings::HasAcceptedHapticsVibrationPopup' has a wrong offset!");
static_assert(offsetof(FConsoleUserSettings, PlayerCardAnimationMode) == 0x0000D4, "Member 'FConsoleUserSettings::PlayerCardAnimationMode' has a wrong offset!");
static_assert(offsetof(FConsoleUserSettings, EnableFSR) == 0x0000D8, "Member 'FConsoleUserSettings::EnableFSR' has a wrong offset!");
static_assert(offsetof(FConsoleUserSettings, SharpnessValue) == 0x0000DC, "Member 'FConsoleUserSettings::SharpnessValue' has a wrong offset!");
static_assert(offsetof(FConsoleUserSettings, ChallengeProgression) == 0x0000E0, "Member 'FConsoleUserSettings::ChallengeProgression' has a wrong offset!");
static_assert(offsetof(FConsoleUserSettings, DailyChallengeProgression) == 0x0000E1, "Member 'FConsoleUserSettings::DailyChallengeProgression' has a wrong offset!");
static_assert(offsetof(FConsoleUserSettings, WeeklyChallengeProgression) == 0x0000E2, "Member 'FConsoleUserSettings::WeeklyChallengeProgression' has a wrong offset!");
static_assert(offsetof(FConsoleUserSettings, EventChallengeProgression) == 0x0000E3, "Member 'FConsoleUserSettings::EventChallengeProgression' has a wrong offset!");
static_assert(offsetof(FConsoleUserSettings, AllChallengeProgression) == 0x0000E4, "Member 'FConsoleUserSettings::AllChallengeProgression' has a wrong offset!");

// ScriptStruct DeadByDaylight.PlayerSavedProfileData
// 0x08E0 (0x08E0 - 0x0000)
struct FPlayerSavedProfileData final
{
public:
	class FString                                 PlayerUID;                                         // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPlayerSavedProfileDataShared          SharedData;                                        // 0x0010(0x0068)(NativeAccessSpecifierPublic)
	struct FPlayerSavedProfileDataLocal           LocalData;                                         // 0x0078(0x0780)(NativeAccessSpecifierPublic)
	struct FConsoleUserSettings                   ConsoleUserSettings;                               // 0x07F8(0x00E8)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerSavedProfileData) == 0x000008, "Wrong alignment on FPlayerSavedProfileData");
static_assert(sizeof(FPlayerSavedProfileData) == 0x0008E0, "Wrong size on FPlayerSavedProfileData");
static_assert(offsetof(FPlayerSavedProfileData, PlayerUID) == 0x000000, "Member 'FPlayerSavedProfileData::PlayerUID' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileData, SharedData) == 0x000010, "Member 'FPlayerSavedProfileData::SharedData' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileData, LocalData) == 0x000078, "Member 'FPlayerSavedProfileData::LocalData' has a wrong offset!");
static_assert(offsetof(FPlayerSavedProfileData, ConsoleUserSettings) == 0x0007F8, "Member 'FPlayerSavedProfileData::ConsoleUserSettings' has a wrong offset!");

// ScriptStruct DeadByDaylight.LastPlayerLoadoutData
// 0x00C8 (0x00C8 - 0x0000)
struct alignas(0x08) FLastPlayerLoadoutData final
{
public:
	uint8                                         Pad_0[0xC8];                                       // 0x0000(0x00C8)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLastPlayerLoadoutData) == 0x000008, "Wrong alignment on FLastPlayerLoadoutData");
static_assert(sizeof(FLastPlayerLoadoutData) == 0x0000C8, "Wrong size on FLastPlayerLoadoutData");

// ScriptStruct DeadByDaylight.PlayerPersistentData
// 0x0BC8 (0x0BC8 - 0x0000)
struct FPlayerPersistentData final
{
public:
	EPlayerRole                                   GameRole;                                          // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPlayerLoadoutData                     StartingLoadout;                                   // 0x0008(0x00C0)(Transient, NativeAccessSpecifierPublic)
	struct FPlayerLoadoutData                     CurrentLoadout;                                    // 0x00C8(0x00C0)(Transient, NativeAccessSpecifierPublic)
	TMap<EGameType, struct FLastPlayerLoadoutData> LastLoadoutPerGameType;                            // 0x0188(0x0050)(Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D8[0xA0];                                     // 0x01D8(0x00A0)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPlayerSavedProfileData                SavedData;                                         // 0x0278(0x08E0)(NativeAccessSpecifierPublic)
	EPlatformFlag                                 PlayerPlatform;                                    // 0x0B58(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EProviderFlag                                 PlayerProvider;                                    // 0x0B5C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B60[0x48];                                     // 0x0B60(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 _equippedBanner;                                   // 0x0BA8(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 _equippedBadge;                                    // 0x0BB8(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FPlayerPersistentData) == 0x000008, "Wrong alignment on FPlayerPersistentData");
static_assert(sizeof(FPlayerPersistentData) == 0x000BC8, "Wrong size on FPlayerPersistentData");
static_assert(offsetof(FPlayerPersistentData, GameRole) == 0x000000, "Member 'FPlayerPersistentData::GameRole' has a wrong offset!");
static_assert(offsetof(FPlayerPersistentData, StartingLoadout) == 0x000008, "Member 'FPlayerPersistentData::StartingLoadout' has a wrong offset!");
static_assert(offsetof(FPlayerPersistentData, CurrentLoadout) == 0x0000C8, "Member 'FPlayerPersistentData::CurrentLoadout' has a wrong offset!");
static_assert(offsetof(FPlayerPersistentData, LastLoadoutPerGameType) == 0x000188, "Member 'FPlayerPersistentData::LastLoadoutPerGameType' has a wrong offset!");
static_assert(offsetof(FPlayerPersistentData, SavedData) == 0x000278, "Member 'FPlayerPersistentData::SavedData' has a wrong offset!");
static_assert(offsetof(FPlayerPersistentData, PlayerPlatform) == 0x000B58, "Member 'FPlayerPersistentData::PlayerPlatform' has a wrong offset!");
static_assert(offsetof(FPlayerPersistentData, PlayerProvider) == 0x000B5C, "Member 'FPlayerPersistentData::PlayerProvider' has a wrong offset!");
static_assert(offsetof(FPlayerPersistentData, _equippedBanner) == 0x000BA8, "Member 'FPlayerPersistentData::_equippedBanner' has a wrong offset!");
static_assert(offsetof(FPlayerPersistentData, _equippedBadge) == 0x000BB8, "Member 'FPlayerPersistentData::_equippedBadge' has a wrong offset!");

// ScriptStruct DeadByDaylight.CombinedPartyFriendData
// 0x0178 (0x0178 - 0x0000)
struct alignas(0x08) FCombinedPartyFriendData final
{
public:
	uint8                                         Pad_0[0x178];                                      // 0x0000(0x0178)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCombinedPartyFriendData) == 0x000008, "Wrong alignment on FCombinedPartyFriendData");
static_assert(sizeof(FCombinedPartyFriendData) == 0x000178, "Wrong size on FCombinedPartyFriendData");

// ScriptStruct DeadByDaylight.CombinedSpecialEventData
// 0x0430 (0x0430 - 0x0000)
struct alignas(0x08) FCombinedSpecialEventData final
{
public:
	uint8                                         Pad_0[0x430];                                      // 0x0000(0x0430)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCombinedSpecialEventData) == 0x000008, "Wrong alignment on FCombinedSpecialEventData");
static_assert(sizeof(FCombinedSpecialEventData) == 0x000430, "Wrong size on FCombinedSpecialEventData");

// ScriptStruct DeadByDaylight.AnimData
// 0x0001 (0x0001 - 0x0000)
struct FAnimData final
{
public:
	ECharacterStance                              Stance;                                            // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimData) == 0x000001, "Wrong alignment on FAnimData");
static_assert(sizeof(FAnimData) == 0x000001, "Wrong size on FAnimData");
static_assert(offsetof(FAnimData, Stance) == 0x000000, "Member 'FAnimData::Stance' has a wrong offset!");

// ScriptStruct DeadByDaylight.AkEventWithSubtitle
// 0x0038 (0x0038 - 0x0000)
struct FAkEventWithSubtitle final
{
public:
	class UAkAudioEvent*                          AudioEvent;                                        // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Weight;                                            // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasSubtitles;                                      // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCustomSoundFXData>             RequiredAudioSwitch;                               // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCustomSoundFXData>             ForbiddenAudioSwitch;                              // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint32                                        DelayMsBeforeSubtitles;                            // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SubtitleEventPriority;                             // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAkEventWithSubtitle) == 0x000008, "Wrong alignment on FAkEventWithSubtitle");
static_assert(sizeof(FAkEventWithSubtitle) == 0x000038, "Wrong size on FAkEventWithSubtitle");
static_assert(offsetof(FAkEventWithSubtitle, AudioEvent) == 0x000000, "Member 'FAkEventWithSubtitle::AudioEvent' has a wrong offset!");
static_assert(offsetof(FAkEventWithSubtitle, Weight) == 0x000008, "Member 'FAkEventWithSubtitle::Weight' has a wrong offset!");
static_assert(offsetof(FAkEventWithSubtitle, HasSubtitles) == 0x000009, "Member 'FAkEventWithSubtitle::HasSubtitles' has a wrong offset!");
static_assert(offsetof(FAkEventWithSubtitle, RequiredAudioSwitch) == 0x000010, "Member 'FAkEventWithSubtitle::RequiredAudioSwitch' has a wrong offset!");
static_assert(offsetof(FAkEventWithSubtitle, ForbiddenAudioSwitch) == 0x000020, "Member 'FAkEventWithSubtitle::ForbiddenAudioSwitch' has a wrong offset!");
static_assert(offsetof(FAkEventWithSubtitle, DelayMsBeforeSubtitles) == 0x000030, "Member 'FAkEventWithSubtitle::DelayMsBeforeSubtitles' has a wrong offset!");
static_assert(offsetof(FAkEventWithSubtitle, SubtitleEventPriority) == 0x000034, "Member 'FAkEventWithSubtitle::SubtitleEventPriority' has a wrong offset!");

// ScriptStruct DeadByDaylight.CommentatorAudioContext
// 0x0040 (0x0040 - 0x0000)
struct FCommentatorAudioContext final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAkEventWithSubtitle>           AudioEvents;                                       // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         PlayProbability;                                   // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInt32Range                            Delay;                                             // 0x0024(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         NumMatchesBeforeContextRepeat;                     // 0x0034(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         NumOccurencesBeforeEventRepeat;                    // 0x0035(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IgnoreCooldown;                                    // 0x0036(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShouldListenToGameEvent;                           // 0x0037(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerTeam                                   RequiredPlayerTeam;                                // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAudioDimensionType                           AudioDimensionType;                                // 0x0039(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SpawnCommentatorActor;                             // 0x003A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B[0x5];                                       // 0x003B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCommentatorAudioContext) == 0x000008, "Wrong alignment on FCommentatorAudioContext");
static_assert(sizeof(FCommentatorAudioContext) == 0x000040, "Wrong size on FCommentatorAudioContext");
static_assert(offsetof(FCommentatorAudioContext, AudioEvents) == 0x000010, "Member 'FCommentatorAudioContext::AudioEvents' has a wrong offset!");
static_assert(offsetof(FCommentatorAudioContext, PlayProbability) == 0x000020, "Member 'FCommentatorAudioContext::PlayProbability' has a wrong offset!");
static_assert(offsetof(FCommentatorAudioContext, Delay) == 0x000024, "Member 'FCommentatorAudioContext::Delay' has a wrong offset!");
static_assert(offsetof(FCommentatorAudioContext, NumMatchesBeforeContextRepeat) == 0x000034, "Member 'FCommentatorAudioContext::NumMatchesBeforeContextRepeat' has a wrong offset!");
static_assert(offsetof(FCommentatorAudioContext, NumOccurencesBeforeEventRepeat) == 0x000035, "Member 'FCommentatorAudioContext::NumOccurencesBeforeEventRepeat' has a wrong offset!");
static_assert(offsetof(FCommentatorAudioContext, IgnoreCooldown) == 0x000036, "Member 'FCommentatorAudioContext::IgnoreCooldown' has a wrong offset!");
static_assert(offsetof(FCommentatorAudioContext, ShouldListenToGameEvent) == 0x000037, "Member 'FCommentatorAudioContext::ShouldListenToGameEvent' has a wrong offset!");
static_assert(offsetof(FCommentatorAudioContext, RequiredPlayerTeam) == 0x000038, "Member 'FCommentatorAudioContext::RequiredPlayerTeam' has a wrong offset!");
static_assert(offsetof(FCommentatorAudioContext, AudioDimensionType) == 0x000039, "Member 'FCommentatorAudioContext::AudioDimensionType' has a wrong offset!");
static_assert(offsetof(FCommentatorAudioContext, SpawnCommentatorActor) == 0x00003A, "Member 'FCommentatorAudioContext::SpawnCommentatorActor' has a wrong offset!");

// ScriptStruct DeadByDaylight.OutlineConfig
// 0x0010 (0x0010 - 0x0000)
struct FOutlineConfig final
{
public:
	TArray<TSoftObjectPtr<class UMaterialInterface>> TranslucencyMaterials;                             // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOutlineConfig) == 0x000008, "Wrong alignment on FOutlineConfig");
static_assert(sizeof(FOutlineConfig) == 0x000010, "Wrong size on FOutlineConfig");
static_assert(offsetof(FOutlineConfig, TranslucencyMaterials) == 0x000000, "Member 'FOutlineConfig::TranslucencyMaterials' has a wrong offset!");

// ScriptStruct DeadByDaylight.CollisionZoneParams
// 0x0048 (0x0048 - 0x0000)
struct FCollisionZoneParams final
{
public:
	ECollisionZoneShape                           Type;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                BoxExtent;                                         // 0x0008(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LineThickness;                                     // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SphereRadius;                                      // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CapsuleHalfHeight;                                 // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CapsuleRadius;                                     // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCollisionProfileName                  CollisionProfile;                                  // 0x0030(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FColor                                 ShapeColor;                                        // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AllowModifyingCollisionProfile;                    // 0x0040(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCollisionZoneParams) == 0x000008, "Wrong alignment on FCollisionZoneParams");
static_assert(sizeof(FCollisionZoneParams) == 0x000048, "Wrong size on FCollisionZoneParams");
static_assert(offsetof(FCollisionZoneParams, Type) == 0x000000, "Member 'FCollisionZoneParams::Type' has a wrong offset!");
static_assert(offsetof(FCollisionZoneParams, BoxExtent) == 0x000008, "Member 'FCollisionZoneParams::BoxExtent' has a wrong offset!");
static_assert(offsetof(FCollisionZoneParams, LineThickness) == 0x000020, "Member 'FCollisionZoneParams::LineThickness' has a wrong offset!");
static_assert(offsetof(FCollisionZoneParams, SphereRadius) == 0x000024, "Member 'FCollisionZoneParams::SphereRadius' has a wrong offset!");
static_assert(offsetof(FCollisionZoneParams, CapsuleHalfHeight) == 0x000028, "Member 'FCollisionZoneParams::CapsuleHalfHeight' has a wrong offset!");
static_assert(offsetof(FCollisionZoneParams, CapsuleRadius) == 0x00002C, "Member 'FCollisionZoneParams::CapsuleRadius' has a wrong offset!");
static_assert(offsetof(FCollisionZoneParams, CollisionProfile) == 0x000030, "Member 'FCollisionZoneParams::CollisionProfile' has a wrong offset!");
static_assert(offsetof(FCollisionZoneParams, ShapeColor) == 0x00003C, "Member 'FCollisionZoneParams::ShapeColor' has a wrong offset!");
static_assert(offsetof(FCollisionZoneParams, AllowModifyingCollisionProfile) == 0x000040, "Member 'FCollisionZoneParams::AllowModifyingCollisionProfile' has a wrong offset!");

// ScriptStruct DeadByDaylight.PlayerFinishStats
// 0x0001 (0x0001 - 0x0000)
struct FPlayerFinishStats final
{
public:
	int8                                          NumberOfSurvivorsKilledOrSacrificed;               // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerFinishStats) == 0x000001, "Wrong alignment on FPlayerFinishStats");
static_assert(sizeof(FPlayerFinishStats) == 0x000001, "Wrong size on FPlayerFinishStats");
static_assert(offsetof(FPlayerFinishStats, NumberOfSurvivorsKilledOrSacrificed) == 0x000000, "Member 'FPlayerFinishStats::NumberOfSurvivorsKilledOrSacrificed' has a wrong offset!");

// ScriptStruct DeadByDaylight.ConsentContentVersionData
// 0x00C0 (0x00C0 - 0x0000)
struct FConsentContentVersionData final
{
public:
	class FString                                 Label;                                             // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         EntryDate;                                         // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FString, class FString>            Title;                                             // 0x0018(0x0050)(NativeAccessSpecifierPublic)
	TMap<class FString, class FString>            Content;                                           // 0x0068(0x0050)(NativeAccessSpecifierPublic)
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FConsentContentVersionData) == 0x000008, "Wrong alignment on FConsentContentVersionData");
static_assert(sizeof(FConsentContentVersionData) == 0x0000C0, "Wrong size on FConsentContentVersionData");
static_assert(offsetof(FConsentContentVersionData, Label) == 0x000000, "Member 'FConsentContentVersionData::Label' has a wrong offset!");
static_assert(offsetof(FConsentContentVersionData, EntryDate) == 0x000010, "Member 'FConsentContentVersionData::EntryDate' has a wrong offset!");
static_assert(offsetof(FConsentContentVersionData, Title) == 0x000018, "Member 'FConsentContentVersionData::Title' has a wrong offset!");
static_assert(offsetof(FConsentContentVersionData, Content) == 0x000068, "Member 'FConsentContentVersionData::Content' has a wrong offset!");

// ScriptStruct DeadByDaylight.ConsentContentData
// 0x0020 (0x0020 - 0x0000)
struct FConsentContentData final
{
public:
	class FString                                 ID;                                                // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FConsentContentVersionData>     Versions;                                          // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FConsentContentData) == 0x000008, "Wrong alignment on FConsentContentData");
static_assert(sizeof(FConsentContentData) == 0x000020, "Wrong size on FConsentContentData");
static_assert(offsetof(FConsentContentData, ID) == 0x000000, "Member 'FConsentContentData::ID' has a wrong offset!");
static_assert(offsetof(FConsentContentData, Versions) == 0x000010, "Member 'FConsentContentData::Versions' has a wrong offset!");

// ScriptStruct DeadByDaylight.ContentMetadata
// 0x0018 (0x0018 - 0x0000)
struct FContentMetadata final
{
public:
	bool                                          RebootClient;                                      // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DeploymentDate;                                    // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FContentMetadata) == 0x000008, "Wrong alignment on FContentMetadata");
static_assert(sizeof(FContentMetadata) == 0x000018, "Wrong size on FContentMetadata");
static_assert(offsetof(FContentMetadata, RebootClient) == 0x000000, "Member 'FContentMetadata::RebootClient' has a wrong offset!");
static_assert(offsetof(FContentMetadata, DeploymentDate) == 0x000008, "Member 'FContentMetadata::DeploymentDate' has a wrong offset!");

// ScriptStruct DeadByDaylight.ContentScheduleRecord
// 0x0158 (0x0158 - 0x0000)
struct FContentScheduleRecord final
{
public:
	int32                                         Priority;                                          // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Description;                                       // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Description_IsSet;                                 // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         GameModes;                                         // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          GameModes_IsSet;                                   // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 LinkedEventId;                                     // 0x0038(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          LinkedEventId_IsSet;                               // 0x0048(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, float>                    MapsThemeWeight;                                   // 0x0050(0x0050)(NativeAccessSpecifierPublic)
	bool                                          MapsThemeWeight_IsSet;                             // 0x00A0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, float>                    MapsWeight;                                        // 0x00A8(0x0050)(NativeAccessSpecifierPublic)
	bool                                          MapsWeight_IsSet;                                  // 0x00F8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F9[0x7];                                       // 0x00F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         FeaturedMap;                                       // 0x0100(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          FeaturedMap_IsSet;                                 // 0x0110(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_111[0x17];                                     // 0x0111(0x0017)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 StartDate;                                         // 0x0128(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          StartDate_IsSet;                                   // 0x0138(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_139[0x7];                                      // 0x0139(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 EndDate;                                           // 0x0140(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          EndDate_IsSet;                                     // 0x0150(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_151[0x7];                                      // 0x0151(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FContentScheduleRecord) == 0x000008, "Wrong alignment on FContentScheduleRecord");
static_assert(sizeof(FContentScheduleRecord) == 0x000158, "Wrong size on FContentScheduleRecord");
static_assert(offsetof(FContentScheduleRecord, Priority) == 0x000000, "Member 'FContentScheduleRecord::Priority' has a wrong offset!");
static_assert(offsetof(FContentScheduleRecord, Description) == 0x000008, "Member 'FContentScheduleRecord::Description' has a wrong offset!");
static_assert(offsetof(FContentScheduleRecord, Description_IsSet) == 0x000018, "Member 'FContentScheduleRecord::Description_IsSet' has a wrong offset!");
static_assert(offsetof(FContentScheduleRecord, GameModes) == 0x000020, "Member 'FContentScheduleRecord::GameModes' has a wrong offset!");
static_assert(offsetof(FContentScheduleRecord, GameModes_IsSet) == 0x000030, "Member 'FContentScheduleRecord::GameModes_IsSet' has a wrong offset!");
static_assert(offsetof(FContentScheduleRecord, LinkedEventId) == 0x000038, "Member 'FContentScheduleRecord::LinkedEventId' has a wrong offset!");
static_assert(offsetof(FContentScheduleRecord, LinkedEventId_IsSet) == 0x000048, "Member 'FContentScheduleRecord::LinkedEventId_IsSet' has a wrong offset!");
static_assert(offsetof(FContentScheduleRecord, MapsThemeWeight) == 0x000050, "Member 'FContentScheduleRecord::MapsThemeWeight' has a wrong offset!");
static_assert(offsetof(FContentScheduleRecord, MapsThemeWeight_IsSet) == 0x0000A0, "Member 'FContentScheduleRecord::MapsThemeWeight_IsSet' has a wrong offset!");
static_assert(offsetof(FContentScheduleRecord, MapsWeight) == 0x0000A8, "Member 'FContentScheduleRecord::MapsWeight' has a wrong offset!");
static_assert(offsetof(FContentScheduleRecord, MapsWeight_IsSet) == 0x0000F8, "Member 'FContentScheduleRecord::MapsWeight_IsSet' has a wrong offset!");
static_assert(offsetof(FContentScheduleRecord, FeaturedMap) == 0x000100, "Member 'FContentScheduleRecord::FeaturedMap' has a wrong offset!");
static_assert(offsetof(FContentScheduleRecord, FeaturedMap_IsSet) == 0x000110, "Member 'FContentScheduleRecord::FeaturedMap_IsSet' has a wrong offset!");
static_assert(offsetof(FContentScheduleRecord, StartDate) == 0x000128, "Member 'FContentScheduleRecord::StartDate' has a wrong offset!");
static_assert(offsetof(FContentScheduleRecord, StartDate_IsSet) == 0x000138, "Member 'FContentScheduleRecord::StartDate_IsSet' has a wrong offset!");
static_assert(offsetof(FContentScheduleRecord, EndDate) == 0x000140, "Member 'FContentScheduleRecord::EndDate' has a wrong offset!");
static_assert(offsetof(FContentScheduleRecord, EndDate_IsSet) == 0x000150, "Member 'FContentScheduleRecord::EndDate_IsSet' has a wrong offset!");

// ScriptStruct DeadByDaylight.ContentScheduleData
// 0x0020 (0x0020 - 0x0000)
struct FContentScheduleData final
{
public:
	TArray<struct FContentScheduleRecord>         Schedule;                                          // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x10];                                      // 0x0010(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FContentScheduleData) == 0x000008, "Wrong alignment on FContentScheduleData");
static_assert(sizeof(FContentScheduleData) == 0x000020, "Wrong size on FContentScheduleData");
static_assert(offsetof(FContentScheduleData, Schedule) == 0x000000, "Member 'FContentScheduleData::Schedule' has a wrong offset!");

// ScriptStruct DeadByDaylight.LookInputAxisScalingData
// 0x0040 (0x0040 - 0x0000)
struct FLookInputAxisScalingData final
{
public:
	struct FDBDTimer                              ScalingTimer;                                      // 0x0000(0x0028)(Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0x18];                                      // 0x0028(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLookInputAxisScalingData) == 0x000008, "Wrong alignment on FLookInputAxisScalingData");
static_assert(sizeof(FLookInputAxisScalingData) == 0x000040, "Wrong size on FLookInputAxisScalingData");
static_assert(offsetof(FLookInputAxisScalingData, ScalingTimer) == 0x000000, "Member 'FLookInputAxisScalingData::ScalingTimer' has a wrong offset!");

// ScriptStruct DeadByDaylight.ContextEventData
// 0x0070 (0x0070 - 0x0000)
struct FContextEventData final
{
public:
	class FString                                 ContextGroupName;                                  // 0x0000(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        ContextGroupUid;                                   // 0x0010(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 PreviousContextName;                               // 0x0018(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        PreviousContextUid;                                // 0x0028(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CurrentContextName;                                // 0x0030(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        CurrentContextUid;                                 // 0x0040(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 NextContextName;                                   // 0x0048(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        NextContextUid;                                    // 0x0058(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              Timestamp;                                         // 0x0060(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CurrentContextIsUMG;                               // 0x0068(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FContextEventData) == 0x000008, "Wrong alignment on FContextEventData");
static_assert(sizeof(FContextEventData) == 0x000070, "Wrong size on FContextEventData");
static_assert(offsetof(FContextEventData, ContextGroupName) == 0x000000, "Member 'FContextEventData::ContextGroupName' has a wrong offset!");
static_assert(offsetof(FContextEventData, ContextGroupUid) == 0x000010, "Member 'FContextEventData::ContextGroupUid' has a wrong offset!");
static_assert(offsetof(FContextEventData, PreviousContextName) == 0x000018, "Member 'FContextEventData::PreviousContextName' has a wrong offset!");
static_assert(offsetof(FContextEventData, PreviousContextUid) == 0x000028, "Member 'FContextEventData::PreviousContextUid' has a wrong offset!");
static_assert(offsetof(FContextEventData, CurrentContextName) == 0x000030, "Member 'FContextEventData::CurrentContextName' has a wrong offset!");
static_assert(offsetof(FContextEventData, CurrentContextUid) == 0x000040, "Member 'FContextEventData::CurrentContextUid' has a wrong offset!");
static_assert(offsetof(FContextEventData, NextContextName) == 0x000048, "Member 'FContextEventData::NextContextName' has a wrong offset!");
static_assert(offsetof(FContextEventData, NextContextUid) == 0x000058, "Member 'FContextEventData::NextContextUid' has a wrong offset!");
static_assert(offsetof(FContextEventData, Timestamp) == 0x000060, "Member 'FContextEventData::Timestamp' has a wrong offset!");
static_assert(offsetof(FContextEventData, CurrentContextIsUMG) == 0x000068, "Member 'FContextEventData::CurrentContextIsUMG' has a wrong offset!");

// ScriptStruct DeadByDaylight.SpecialEventBloodwebData
// 0x0001 (0x0001 - 0x0000)
struct FSpecialEventBloodwebData final
{
public:
	ESpecialEventBloodwebChestCondition           EventChestCondition;                               // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpecialEventBloodwebData) == 0x000001, "Wrong alignment on FSpecialEventBloodwebData");
static_assert(sizeof(FSpecialEventBloodwebData) == 0x000001, "Wrong size on FSpecialEventBloodwebData");
static_assert(offsetof(FSpecialEventBloodwebData, EventChestCondition) == 0x000000, "Member 'FSpecialEventBloodwebData::EventChestCondition' has a wrong offset!");

// ScriptStruct DeadByDaylight.CrossPromoCampaignsRuntimeData
// 0x0050 (0x0050 - 0x0000)
struct FCrossPromoCampaignsRuntimeData final
{
public:
	TMap<class FString, struct FCrossPromoSingleCampaignRuntimeData> Campaigns;                                         // 0x0000(0x0050)(Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCrossPromoCampaignsRuntimeData) == 0x000008, "Wrong alignment on FCrossPromoCampaignsRuntimeData");
static_assert(sizeof(FCrossPromoCampaignsRuntimeData) == 0x000050, "Wrong size on FCrossPromoCampaignsRuntimeData");
static_assert(offsetof(FCrossPromoCampaignsRuntimeData, Campaigns) == 0x000000, "Member 'FCrossPromoCampaignsRuntimeData::Campaigns' has a wrong offset!");

// ScriptStruct DeadByDaylight.CurrencyPurchaseData
// 0x0068 (0x0068 - 0x0000)
struct FCurrencyPurchaseData final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 IconPath;                                          // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CurrencyName;                                      // 0x0018(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CurrencyIcon;                                      // 0x0028(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrencyAmount;                                    // 0x0038(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DisplayedPrice;                                    // 0x0040(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BonusPercentage;                                   // 0x0050(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              BonusEndDate;                                      // 0x0058(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BasicCurrencyAmount;                               // 0x0060(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCurrencyPurchaseData) == 0x000008, "Wrong alignment on FCurrencyPurchaseData");
static_assert(sizeof(FCurrencyPurchaseData) == 0x000068, "Wrong size on FCurrencyPurchaseData");
static_assert(offsetof(FCurrencyPurchaseData, IconPath) == 0x000008, "Member 'FCurrencyPurchaseData::IconPath' has a wrong offset!");
static_assert(offsetof(FCurrencyPurchaseData, CurrencyName) == 0x000018, "Member 'FCurrencyPurchaseData::CurrencyName' has a wrong offset!");
static_assert(offsetof(FCurrencyPurchaseData, CurrencyIcon) == 0x000028, "Member 'FCurrencyPurchaseData::CurrencyIcon' has a wrong offset!");
static_assert(offsetof(FCurrencyPurchaseData, CurrencyAmount) == 0x000038, "Member 'FCurrencyPurchaseData::CurrencyAmount' has a wrong offset!");
static_assert(offsetof(FCurrencyPurchaseData, DisplayedPrice) == 0x000040, "Member 'FCurrencyPurchaseData::DisplayedPrice' has a wrong offset!");
static_assert(offsetof(FCurrencyPurchaseData, BonusPercentage) == 0x000050, "Member 'FCurrencyPurchaseData::BonusPercentage' has a wrong offset!");
static_assert(offsetof(FCurrencyPurchaseData, BonusEndDate) == 0x000058, "Member 'FCurrencyPurchaseData::BonusEndDate' has a wrong offset!");
static_assert(offsetof(FCurrencyPurchaseData, BasicCurrencyAmount) == 0x000060, "Member 'FCurrencyPurchaseData::BasicCurrencyAmount' has a wrong offset!");

// ScriptStruct DeadByDaylight.SpecialEventMilestoneRewards
// 0x0018 (0x0018 - 0x0000)
struct FSpecialEventMilestoneRewards final
{
public:
	int32                                         PointsCost;                                        // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRewardResponseItem>            Rewards;                                           // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpecialEventMilestoneRewards) == 0x000008, "Wrong alignment on FSpecialEventMilestoneRewards");
static_assert(sizeof(FSpecialEventMilestoneRewards) == 0x000018, "Wrong size on FSpecialEventMilestoneRewards");
static_assert(offsetof(FSpecialEventMilestoneRewards, PointsCost) == 0x000000, "Member 'FSpecialEventMilestoneRewards::PointsCost' has a wrong offset!");
static_assert(offsetof(FSpecialEventMilestoneRewards, Rewards) == 0x000008, "Member 'FSpecialEventMilestoneRewards::Rewards' has a wrong offset!");

// ScriptStruct DeadByDaylight.CustomizationCategoryData
// 0x0040 (0x0048 - 0x0008)
struct FCustomizationCategoryData final : public FDBDTableRowBase
{
public:
	class FName                                   ID;                                                // 0x0008(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECustomizationCategory                        Category;                                          // 0x0014(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 IconPath;                                          // 0x0018(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   DisplayName;                                       // 0x0028(0x0018)(Edit, NativeAccessSpecifierPublic)
	EPlayerRole                                   Role;                                              // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCustomizationCategoryData) == 0x000008, "Wrong alignment on FCustomizationCategoryData");
static_assert(sizeof(FCustomizationCategoryData) == 0x000048, "Wrong size on FCustomizationCategoryData");
static_assert(offsetof(FCustomizationCategoryData, ID) == 0x000008, "Member 'FCustomizationCategoryData::ID' has a wrong offset!");
static_assert(offsetof(FCustomizationCategoryData, Category) == 0x000014, "Member 'FCustomizationCategoryData::Category' has a wrong offset!");
static_assert(offsetof(FCustomizationCategoryData, IconPath) == 0x000018, "Member 'FCustomizationCategoryData::IconPath' has a wrong offset!");
static_assert(offsetof(FCustomizationCategoryData, DisplayName) == 0x000028, "Member 'FCustomizationCategoryData::DisplayName' has a wrong offset!");
static_assert(offsetof(FCustomizationCategoryData, Role) == 0x000040, "Member 'FCustomizationCategoryData::Role' has a wrong offset!");

// ScriptStruct DeadByDaylight.StoreSpecialPackItem
// 0x0058 (0x0058 - 0x0000)
struct FStoreSpecialPackItem final
{
public:
	EStoreSpecialPackItemType                     Type;                                              // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CustomizationId;                                   // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CharacterId;                                       // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TomeId;                                            // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 OutfitId;                                          // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECurrencyType                                 CurrencyId;                                        // 0x0048(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Amount;                                            // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IncludeInOwnership;                                // 0x0050(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IncludeInPricing;                                  // 0x0051(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasPriorityForPackImageComposition;                // 0x0052(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_53[0x5];                                       // 0x0053(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStoreSpecialPackItem) == 0x000008, "Wrong alignment on FStoreSpecialPackItem");
static_assert(sizeof(FStoreSpecialPackItem) == 0x000058, "Wrong size on FStoreSpecialPackItem");
static_assert(offsetof(FStoreSpecialPackItem, Type) == 0x000000, "Member 'FStoreSpecialPackItem::Type' has a wrong offset!");
static_assert(offsetof(FStoreSpecialPackItem, CustomizationId) == 0x000008, "Member 'FStoreSpecialPackItem::CustomizationId' has a wrong offset!");
static_assert(offsetof(FStoreSpecialPackItem, CharacterId) == 0x000018, "Member 'FStoreSpecialPackItem::CharacterId' has a wrong offset!");
static_assert(offsetof(FStoreSpecialPackItem, TomeId) == 0x000028, "Member 'FStoreSpecialPackItem::TomeId' has a wrong offset!");
static_assert(offsetof(FStoreSpecialPackItem, OutfitId) == 0x000038, "Member 'FStoreSpecialPackItem::OutfitId' has a wrong offset!");
static_assert(offsetof(FStoreSpecialPackItem, CurrencyId) == 0x000048, "Member 'FStoreSpecialPackItem::CurrencyId' has a wrong offset!");
static_assert(offsetof(FStoreSpecialPackItem, Amount) == 0x00004C, "Member 'FStoreSpecialPackItem::Amount' has a wrong offset!");
static_assert(offsetof(FStoreSpecialPackItem, IncludeInOwnership) == 0x000050, "Member 'FStoreSpecialPackItem::IncludeInOwnership' has a wrong offset!");
static_assert(offsetof(FStoreSpecialPackItem, IncludeInPricing) == 0x000051, "Member 'FStoreSpecialPackItem::IncludeInPricing' has a wrong offset!");
static_assert(offsetof(FStoreSpecialPackItem, HasPriorityForPackImageComposition) == 0x000052, "Member 'FStoreSpecialPackItem::HasPriorityForPackImageComposition' has a wrong offset!");

// ScriptStruct DeadByDaylight.StoreRecurringSpecialPackEntry
// 0x0088 (0x0088 - 0x0000)
struct FStoreRecurringSpecialPackEntry final
{
public:
	class FString                                 ID;                                                // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              StartDate;                                         // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              EndDate;                                           // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FStoreSpecialPackItem>          Content;                                           // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TSet<ECurrencyType>                           AvailableCurrencies;                               // 0x0030(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         Discount;                                          // 0x0080(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasPriorityForPackImageComposition;                // 0x0084(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_85[0x3];                                       // 0x0085(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStoreRecurringSpecialPackEntry) == 0x000008, "Wrong alignment on FStoreRecurringSpecialPackEntry");
static_assert(sizeof(FStoreRecurringSpecialPackEntry) == 0x000088, "Wrong size on FStoreRecurringSpecialPackEntry");
static_assert(offsetof(FStoreRecurringSpecialPackEntry, ID) == 0x000000, "Member 'FStoreRecurringSpecialPackEntry::ID' has a wrong offset!");
static_assert(offsetof(FStoreRecurringSpecialPackEntry, StartDate) == 0x000010, "Member 'FStoreRecurringSpecialPackEntry::StartDate' has a wrong offset!");
static_assert(offsetof(FStoreRecurringSpecialPackEntry, EndDate) == 0x000018, "Member 'FStoreRecurringSpecialPackEntry::EndDate' has a wrong offset!");
static_assert(offsetof(FStoreRecurringSpecialPackEntry, Content) == 0x000020, "Member 'FStoreRecurringSpecialPackEntry::Content' has a wrong offset!");
static_assert(offsetof(FStoreRecurringSpecialPackEntry, AvailableCurrencies) == 0x000030, "Member 'FStoreRecurringSpecialPackEntry::AvailableCurrencies' has a wrong offset!");
static_assert(offsetof(FStoreRecurringSpecialPackEntry, Discount) == 0x000080, "Member 'FStoreRecurringSpecialPackEntry::Discount' has a wrong offset!");
static_assert(offsetof(FStoreRecurringSpecialPackEntry, HasPriorityForPackImageComposition) == 0x000084, "Member 'FStoreRecurringSpecialPackEntry::HasPriorityForPackImageComposition' has a wrong offset!");

// ScriptStruct DeadByDaylight.StoreSpecialPackImageCompositionEditorData
// 0x0008 (0x0008 - 0x0000)
struct FStoreSpecialPackImageCompositionEditorData final
{
public:
	bool                                          OverrideDefaults;                                  // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStoreSpecialPackImageType                    Type;                                              // 0x0001(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxItemCount;                                      // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStoreSpecialPackImageCompositionEditorData) == 0x000004, "Wrong alignment on FStoreSpecialPackImageCompositionEditorData");
static_assert(sizeof(FStoreSpecialPackImageCompositionEditorData) == 0x000008, "Wrong size on FStoreSpecialPackImageCompositionEditorData");
static_assert(offsetof(FStoreSpecialPackImageCompositionEditorData, OverrideDefaults) == 0x000000, "Member 'FStoreSpecialPackImageCompositionEditorData::OverrideDefaults' has a wrong offset!");
static_assert(offsetof(FStoreSpecialPackImageCompositionEditorData, Type) == 0x000001, "Member 'FStoreSpecialPackImageCompositionEditorData::Type' has a wrong offset!");
static_assert(offsetof(FStoreSpecialPackImageCompositionEditorData, MaxItemCount) == 0x000004, "Member 'FStoreSpecialPackImageCompositionEditorData::MaxItemCount' has a wrong offset!");

// ScriptStruct DeadByDaylight.StoreRecurringSpecialPack
// 0x0098 (0x00A0 - 0x0008)
struct FStoreRecurringSpecialPack final : public FDBDTableRowBase
{
public:
	class FString                                 ID;                                                // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Title;                                             // 0x0018(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        Image;                                             // 0x0030(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFStoreRecurringSpecialPackType               Type;                                              // 0x0058(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 InclusionVersion;                                  // 0x0060(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsPurchasable;                                     // 0x0070(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x3];                                       // 0x0071(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SortOrder;                                         // 0x0074(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HiddenIfOwned;                                     // 0x0078(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x3];                                       // 0x0079(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MinNumberOfUnownedForPurchase;                     // 0x007C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              StartDate;                                         // 0x0080(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FStoreRecurringSpecialPackEntry> Entries;                                           // 0x0088(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FStoreSpecialPackImageCompositionEditorData ImageComposition;                                  // 0x0098(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStoreRecurringSpecialPack) == 0x000008, "Wrong alignment on FStoreRecurringSpecialPack");
static_assert(sizeof(FStoreRecurringSpecialPack) == 0x0000A0, "Wrong size on FStoreRecurringSpecialPack");
static_assert(offsetof(FStoreRecurringSpecialPack, ID) == 0x000008, "Member 'FStoreRecurringSpecialPack::ID' has a wrong offset!");
static_assert(offsetof(FStoreRecurringSpecialPack, Title) == 0x000018, "Member 'FStoreRecurringSpecialPack::Title' has a wrong offset!");
static_assert(offsetof(FStoreRecurringSpecialPack, Image) == 0x000030, "Member 'FStoreRecurringSpecialPack::Image' has a wrong offset!");
static_assert(offsetof(FStoreRecurringSpecialPack, Type) == 0x000058, "Member 'FStoreRecurringSpecialPack::Type' has a wrong offset!");
static_assert(offsetof(FStoreRecurringSpecialPack, InclusionVersion) == 0x000060, "Member 'FStoreRecurringSpecialPack::InclusionVersion' has a wrong offset!");
static_assert(offsetof(FStoreRecurringSpecialPack, IsPurchasable) == 0x000070, "Member 'FStoreRecurringSpecialPack::IsPurchasable' has a wrong offset!");
static_assert(offsetof(FStoreRecurringSpecialPack, SortOrder) == 0x000074, "Member 'FStoreRecurringSpecialPack::SortOrder' has a wrong offset!");
static_assert(offsetof(FStoreRecurringSpecialPack, HiddenIfOwned) == 0x000078, "Member 'FStoreRecurringSpecialPack::HiddenIfOwned' has a wrong offset!");
static_assert(offsetof(FStoreRecurringSpecialPack, MinNumberOfUnownedForPurchase) == 0x00007C, "Member 'FStoreRecurringSpecialPack::MinNumberOfUnownedForPurchase' has a wrong offset!");
static_assert(offsetof(FStoreRecurringSpecialPack, StartDate) == 0x000080, "Member 'FStoreRecurringSpecialPack::StartDate' has a wrong offset!");
static_assert(offsetof(FStoreRecurringSpecialPack, Entries) == 0x000088, "Member 'FStoreRecurringSpecialPack::Entries' has a wrong offset!");
static_assert(offsetof(FStoreRecurringSpecialPack, ImageComposition) == 0x000098, "Member 'FStoreRecurringSpecialPack::ImageComposition' has a wrong offset!");

// ScriptStruct DeadByDaylight.S3PrestigeRewardItem
// 0x0028 (0x0028 - 0x0000)
struct FS3PrestigeRewardItem final
{
public:
	class FString                                 ID;                                                // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 RewardType;                                        // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PerkLevel;                                         // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          PerkLevel_IsSet;                                   // 0x0024(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FS3PrestigeRewardItem) == 0x000008, "Wrong alignment on FS3PrestigeRewardItem");
static_assert(sizeof(FS3PrestigeRewardItem) == 0x000028, "Wrong size on FS3PrestigeRewardItem");
static_assert(offsetof(FS3PrestigeRewardItem, ID) == 0x000000, "Member 'FS3PrestigeRewardItem::ID' has a wrong offset!");
static_assert(offsetof(FS3PrestigeRewardItem, RewardType) == 0x000010, "Member 'FS3PrestigeRewardItem::RewardType' has a wrong offset!");
static_assert(offsetof(FS3PrestigeRewardItem, PerkLevel) == 0x000020, "Member 'FS3PrestigeRewardItem::PerkLevel' has a wrong offset!");
static_assert(offsetof(FS3PrestigeRewardItem, PerkLevel_IsSet) == 0x000024, "Member 'FS3PrestigeRewardItem::PerkLevel_IsSet' has a wrong offset!");

// ScriptStruct DeadByDaylight.S3PrestigeRewards
// 0x0018 (0x0018 - 0x0000)
struct FS3PrestigeRewards final
{
public:
	int32                                         PrestigeLevel;                                     // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FS3PrestigeRewardItem>          Rewards;                                           // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FS3PrestigeRewards) == 0x000008, "Wrong alignment on FS3PrestigeRewards");
static_assert(sizeof(FS3PrestigeRewards) == 0x000018, "Wrong size on FS3PrestigeRewards");
static_assert(offsetof(FS3PrestigeRewards, PrestigeLevel) == 0x000000, "Member 'FS3PrestigeRewards::PrestigeLevel' has a wrong offset!");
static_assert(offsetof(FS3PrestigeRewards, Rewards) == 0x000008, "Member 'FS3PrestigeRewards::Rewards' has a wrong offset!");

// ScriptStruct DeadByDaylight.S3PrestigeCharacterRewards
// 0x0010 (0x0010 - 0x0000)
struct FS3PrestigeCharacterRewards final
{
public:
	TArray<struct FS3PrestigeRewards>             RewardsByPrestigeLevel;                            // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FS3PrestigeCharacterRewards) == 0x000008, "Wrong alignment on FS3PrestigeCharacterRewards");
static_assert(sizeof(FS3PrestigeCharacterRewards) == 0x000010, "Wrong size on FS3PrestigeCharacterRewards");
static_assert(offsetof(FS3PrestigeCharacterRewards, RewardsByPrestigeLevel) == 0x000000, "Member 'FS3PrestigeCharacterRewards::RewardsByPrestigeLevel' has a wrong offset!");

// ScriptStruct DeadByDaylight.StoreRecommendationCustomizationItemValue
// 0x0028 (0x0028 - 0x0000)
struct FStoreRecommendationCustomizationItemValue final
{
public:
	EStoreRecommendationCustomizationItemCategories Category;                                          // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Outfit;                                            // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Item;                                              // 0x0018(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStoreRecommendationCustomizationItemValue) == 0x000008, "Wrong alignment on FStoreRecommendationCustomizationItemValue");
static_assert(sizeof(FStoreRecommendationCustomizationItemValue) == 0x000028, "Wrong size on FStoreRecommendationCustomizationItemValue");
static_assert(offsetof(FStoreRecommendationCustomizationItemValue, Category) == 0x000000, "Member 'FStoreRecommendationCustomizationItemValue::Category' has a wrong offset!");
static_assert(offsetof(FStoreRecommendationCustomizationItemValue, Outfit) == 0x000008, "Member 'FStoreRecommendationCustomizationItemValue::Outfit' has a wrong offset!");
static_assert(offsetof(FStoreRecommendationCustomizationItemValue, Item) == 0x000018, "Member 'FStoreRecommendationCustomizationItemValue::Item' has a wrong offset!");

// ScriptStruct DeadByDaylight.StoreRecommendationCustomizationEditorData
// 0x0060 (0x0078 - 0x0018)
struct FStoreRecommendationCustomizationEditorData : public FDBDTableRowBaseWithId
{
public:
	class FString                                 InclusionVersion;                                  // 0x0018(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              ActiveFrom;                                        // 0x0028(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              ActiveTo;                                          // 0x0030(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FStoreRecommendationCustomizationItemValue> Customizations;                                    // 0x0038(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         Outfits;                                           // 0x0048(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class FString>                         Items;                                             // 0x0058(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class FString>                         RecommendedCategoriesPriority;                     // 0x0068(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FStoreRecommendationCustomizationEditorData) == 0x000008, "Wrong alignment on FStoreRecommendationCustomizationEditorData");
static_assert(sizeof(FStoreRecommendationCustomizationEditorData) == 0x000078, "Wrong size on FStoreRecommendationCustomizationEditorData");
static_assert(offsetof(FStoreRecommendationCustomizationEditorData, InclusionVersion) == 0x000018, "Member 'FStoreRecommendationCustomizationEditorData::InclusionVersion' has a wrong offset!");
static_assert(offsetof(FStoreRecommendationCustomizationEditorData, ActiveFrom) == 0x000028, "Member 'FStoreRecommendationCustomizationEditorData::ActiveFrom' has a wrong offset!");
static_assert(offsetof(FStoreRecommendationCustomizationEditorData, ActiveTo) == 0x000030, "Member 'FStoreRecommendationCustomizationEditorData::ActiveTo' has a wrong offset!");
static_assert(offsetof(FStoreRecommendationCustomizationEditorData, Customizations) == 0x000038, "Member 'FStoreRecommendationCustomizationEditorData::Customizations' has a wrong offset!");
static_assert(offsetof(FStoreRecommendationCustomizationEditorData, Outfits) == 0x000048, "Member 'FStoreRecommendationCustomizationEditorData::Outfits' has a wrong offset!");
static_assert(offsetof(FStoreRecommendationCustomizationEditorData, Items) == 0x000058, "Member 'FStoreRecommendationCustomizationEditorData::Items' has a wrong offset!");
static_assert(offsetof(FStoreRecommendationCustomizationEditorData, RecommendedCategoriesPriority) == 0x000068, "Member 'FStoreRecommendationCustomizationEditorData::RecommendedCategoriesPriority' has a wrong offset!");

// ScriptStruct DeadByDaylight.StoreSpecialsRecommendationEditorData
// 0x0010 (0x0088 - 0x0078)
struct FStoreSpecialsRecommendationEditorData final : public FStoreRecommendationCustomizationEditorData
{
public:
	class FString                                 AuricCellOffer;                                    // 0x0078(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStoreSpecialsRecommendationEditorData) == 0x000008, "Wrong alignment on FStoreSpecialsRecommendationEditorData");
static_assert(sizeof(FStoreSpecialsRecommendationEditorData) == 0x000088, "Wrong size on FStoreSpecialsRecommendationEditorData");
static_assert(offsetof(FStoreSpecialsRecommendationEditorData, AuricCellOffer) == 0x000078, "Member 'FStoreSpecialsRecommendationEditorData::AuricCellOffer' has a wrong offset!");

// ScriptStruct DeadByDaylight.CustomizationItemDropdown
// 0x000E (0x0010 - 0x0002)
struct FCustomizationItemDropdown final : public FRoleDropdown
{
public:
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ItemId;                                            // 0x0004(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCustomizationItemDropdown) == 0x000004, "Wrong alignment on FCustomizationItemDropdown");
static_assert(sizeof(FCustomizationItemDropdown) == 0x000010, "Wrong size on FCustomizationItemDropdown");
static_assert(offsetof(FCustomizationItemDropdown, ItemId) == 0x000004, "Member 'FCustomizationItemDropdown::ItemId' has a wrong offset!");

// ScriptStruct DeadByDaylight.OutfitDropdown
// 0x000C (0x0014 - 0x0008)
struct FOutfitDropdown final : public FCharacterDropdown
{
public:
	class FName                                   OutfitId;                                          // 0x0008(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOutfitDropdown) == 0x000004, "Wrong alignment on FOutfitDropdown");
static_assert(sizeof(FOutfitDropdown) == 0x000014, "Wrong size on FOutfitDropdown");
static_assert(offsetof(FOutfitDropdown, OutfitId) == 0x000008, "Member 'FOutfitDropdown::OutfitId' has a wrong offset!");

// ScriptStruct DeadByDaylight.OutfitViewSetting
// 0x0048 (0x0048 - 0x0000)
struct FOutfitViewSetting final
{
public:
	class FName                                   Label;                                             // 0x0000(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FOutfitDropdown                        OutfitDropdown;                                    // 0x000C(0x0014)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FScreenshotViewSetting                 Settings;                                          // 0x0020(0x0028)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOutfitViewSetting) == 0x000004, "Wrong alignment on FOutfitViewSetting");
static_assert(sizeof(FOutfitViewSetting) == 0x000048, "Wrong size on FOutfitViewSetting");
static_assert(offsetof(FOutfitViewSetting, Label) == 0x000000, "Member 'FOutfitViewSetting::Label' has a wrong offset!");
static_assert(offsetof(FOutfitViewSetting, OutfitDropdown) == 0x00000C, "Member 'FOutfitViewSetting::OutfitDropdown' has a wrong offset!");
static_assert(offsetof(FOutfitViewSetting, Settings) == 0x000020, "Member 'FOutfitViewSetting::Settings' has a wrong offset!");

// ScriptStruct DeadByDaylight.DailyRewardCalendarData
// 0x0030 (0x0030 - 0x0000)
struct FDailyRewardCalendarData final
{
public:
	TArray<struct FDailyRewardData>               DailyRewardList;                                   // 0x0000(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	int32                                         CurrentlyActiveDailyRewardIndex;                   // 0x0010(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              CalendarStartDate;                                 // 0x0018(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              CalendarExpirationDate;                            // 0x0020(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsSet;                                             // 0x0028(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDailyRewardCalendarData) == 0x000008, "Wrong alignment on FDailyRewardCalendarData");
static_assert(sizeof(FDailyRewardCalendarData) == 0x000030, "Wrong size on FDailyRewardCalendarData");
static_assert(offsetof(FDailyRewardCalendarData, DailyRewardList) == 0x000000, "Member 'FDailyRewardCalendarData::DailyRewardList' has a wrong offset!");
static_assert(offsetof(FDailyRewardCalendarData, CurrentlyActiveDailyRewardIndex) == 0x000010, "Member 'FDailyRewardCalendarData::CurrentlyActiveDailyRewardIndex' has a wrong offset!");
static_assert(offsetof(FDailyRewardCalendarData, CalendarStartDate) == 0x000018, "Member 'FDailyRewardCalendarData::CalendarStartDate' has a wrong offset!");
static_assert(offsetof(FDailyRewardCalendarData, CalendarExpirationDate) == 0x000020, "Member 'FDailyRewardCalendarData::CalendarExpirationDate' has a wrong offset!");
static_assert(offsetof(FDailyRewardCalendarData, IsSet) == 0x000028, "Member 'FDailyRewardCalendarData::IsSet' has a wrong offset!");

// ScriptStruct DeadByDaylight.MovementConversionData
// 0x0003 (0x0003 - 0x0000)
struct FMovementConversionData final
{
public:
	uint8                                         Pad_0[0x3];                                        // 0x0000(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMovementConversionData) == 0x000001, "Wrong alignment on FMovementConversionData");
static_assert(sizeof(FMovementConversionData) == 0x000003, "Wrong size on FMovementConversionData");

// ScriptStruct DeadByDaylight.PlayerHitCosmeticParams
// 0x0014 (0x0014 - 0x0000)
struct FPlayerHitCosmeticParams final
{
public:
	TWeakObjectPtr<class APawn>                   Attacker;                                          // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class ACamperPlayer>           Target;                                            // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttackType                                   AttackType;                                        // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CausedKO;                                          // 0x0011(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsWeaponHit;                                       // 0x0012(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13[0x1];                                       // 0x0013(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerHitCosmeticParams) == 0x000004, "Wrong alignment on FPlayerHitCosmeticParams");
static_assert(sizeof(FPlayerHitCosmeticParams) == 0x000014, "Wrong size on FPlayerHitCosmeticParams");
static_assert(offsetof(FPlayerHitCosmeticParams, Attacker) == 0x000000, "Member 'FPlayerHitCosmeticParams::Attacker' has a wrong offset!");
static_assert(offsetof(FPlayerHitCosmeticParams, Target) == 0x000008, "Member 'FPlayerHitCosmeticParams::Target' has a wrong offset!");
static_assert(offsetof(FPlayerHitCosmeticParams, AttackType) == 0x000010, "Member 'FPlayerHitCosmeticParams::AttackType' has a wrong offset!");
static_assert(offsetof(FPlayerHitCosmeticParams, CausedKO) == 0x000011, "Member 'FPlayerHitCosmeticParams::CausedKO' has a wrong offset!");
static_assert(offsetof(FPlayerHitCosmeticParams, IsWeaponHit) == 0x000012, "Member 'FPlayerHitCosmeticParams::IsWeaponHit' has a wrong offset!");

// ScriptStruct DeadByDaylight.AIItemWeightTunableRowData
// 0x0010 (0x0018 - 0x0008)
struct FAIItemWeightTunableRowData final : public FDBDTableRowBase
{
public:
	float                                         CountWeight;                                       // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnergyWeight;                                      // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConditionalWeight;                                 // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIItemWeightTunableRowData) == 0x000008, "Wrong alignment on FAIItemWeightTunableRowData");
static_assert(sizeof(FAIItemWeightTunableRowData) == 0x000018, "Wrong size on FAIItemWeightTunableRowData");
static_assert(offsetof(FAIItemWeightTunableRowData, CountWeight) == 0x000008, "Member 'FAIItemWeightTunableRowData::CountWeight' has a wrong offset!");
static_assert(offsetof(FAIItemWeightTunableRowData, EnergyWeight) == 0x00000C, "Member 'FAIItemWeightTunableRowData::EnergyWeight' has a wrong offset!");
static_assert(offsetof(FAIItemWeightTunableRowData, ConditionalWeight) == 0x000010, "Member 'FAIItemWeightTunableRowData::ConditionalWeight' has a wrong offset!");

// ScriptStruct DeadByDaylight.EscapeTypeObjects
// 0x0018 (0x0018 - 0x0000)
struct FEscapeTypeObjects final
{
public:
	EscapeStrategyType                            Type;                                              // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftClassPtr<class UClass>>           EscapeObjects;                                     // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEscapeTypeObjects) == 0x000008, "Wrong alignment on FEscapeTypeObjects");
static_assert(sizeof(FEscapeTypeObjects) == 0x000018, "Wrong size on FEscapeTypeObjects");
static_assert(offsetof(FEscapeTypeObjects, Type) == 0x000000, "Member 'FEscapeTypeObjects::Type' has a wrong offset!");
static_assert(offsetof(FEscapeTypeObjects, EscapeObjects) == 0x000008, "Member 'FEscapeTypeObjects::EscapeObjects' has a wrong offset!");

// ScriptStruct DeadByDaylight.AIHasPerkConditionArray
// 0x0010 (0x0010 - 0x0000)
struct FAIHasPerkConditionArray final
{
public:
	TArray<struct FAIHasPerkCondition>            Conditions;                                        // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIHasPerkConditionArray) == 0x000008, "Wrong alignment on FAIHasPerkConditionArray");
static_assert(sizeof(FAIHasPerkConditionArray) == 0x000010, "Wrong size on FAIHasPerkConditionArray");
static_assert(offsetof(FAIHasPerkConditionArray, Conditions) == 0x000000, "Member 'FAIHasPerkConditionArray::Conditions' has a wrong offset!");

// ScriptStruct DeadByDaylight.DBDAttackTargetTracker
// 0x00B8 (0x00B8 - 0x0000)
struct FDBDAttackTargetTracker final
{
public:
	bool                                          _useTargetTracking;                                // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FStatProperty                          _targetSnapDistance;                               // 0x0008(0x0088)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class FName                                   _ownerEyeSocketName;                               // 0x0090(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   _targetBoneName;                                   // 0x009C(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class ACharacter>              _trackedTarget;                                    // 0x00A8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class ADBDPlayer>              _owningPlayer;                                     // 0x00B0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FDBDAttackTargetTracker) == 0x000008, "Wrong alignment on FDBDAttackTargetTracker");
static_assert(sizeof(FDBDAttackTargetTracker) == 0x0000B8, "Wrong size on FDBDAttackTargetTracker");
static_assert(offsetof(FDBDAttackTargetTracker, _useTargetTracking) == 0x000000, "Member 'FDBDAttackTargetTracker::_useTargetTracking' has a wrong offset!");
static_assert(offsetof(FDBDAttackTargetTracker, _targetSnapDistance) == 0x000008, "Member 'FDBDAttackTargetTracker::_targetSnapDistance' has a wrong offset!");
static_assert(offsetof(FDBDAttackTargetTracker, _ownerEyeSocketName) == 0x000090, "Member 'FDBDAttackTargetTracker::_ownerEyeSocketName' has a wrong offset!");
static_assert(offsetof(FDBDAttackTargetTracker, _targetBoneName) == 0x00009C, "Member 'FDBDAttackTargetTracker::_targetBoneName' has a wrong offset!");
static_assert(offsetof(FDBDAttackTargetTracker, _trackedTarget) == 0x0000A8, "Member 'FDBDAttackTargetTracker::_trackedTarget' has a wrong offset!");
static_assert(offsetof(FDBDAttackTargetTracker, _owningPlayer) == 0x0000B0, "Member 'FDBDAttackTargetTracker::_owningPlayer' has a wrong offset!");

// ScriptStruct DeadByDaylight.EventTrackerObjectiveMilestone
// 0x0008 (0x0008 - 0x0000)
struct FEventTrackerObjectiveMilestone final
{
public:
	float                                         AdditiveMultiplier;                                // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NeededProgression;                                 // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEventTrackerObjectiveMilestone) == 0x000004, "Wrong alignment on FEventTrackerObjectiveMilestone");
static_assert(sizeof(FEventTrackerObjectiveMilestone) == 0x000008, "Wrong size on FEventTrackerObjectiveMilestone");
static_assert(offsetof(FEventTrackerObjectiveMilestone, AdditiveMultiplier) == 0x000000, "Member 'FEventTrackerObjectiveMilestone::AdditiveMultiplier' has a wrong offset!");
static_assert(offsetof(FEventTrackerObjectiveMilestone, NeededProgression) == 0x000004, "Member 'FEventTrackerObjectiveMilestone::NeededProgression' has a wrong offset!");

// ScriptStruct DeadByDaylight.PerMeshInstancingData
// 0x0190 (0x0190 - 0x0000)
struct FPerMeshInstancingData final
{
public:
	TMap<uint32, class UInstancedStaticMeshComponent*> GpuCulling_hashToInstancedMeshes;                  // 0x0000(0x0050)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TMap<uint32, class UInstancedStaticMeshComponent*> GpuCullingSwap_hashToInstancedMeshes;              // 0x0050(0x0050)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TMap<uint32, class UInstancedStaticMeshComponent*> Hism_hashToInstancedMeshes;                        // 0x00A0(0x0050)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_F0[0xA0];                                      // 0x00F0(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPerMeshInstancingData) == 0x000008, "Wrong alignment on FPerMeshInstancingData");
static_assert(sizeof(FPerMeshInstancingData) == 0x000190, "Wrong size on FPerMeshInstancingData");
static_assert(offsetof(FPerMeshInstancingData, GpuCulling_hashToInstancedMeshes) == 0x000000, "Member 'FPerMeshInstancingData::GpuCulling_hashToInstancedMeshes' has a wrong offset!");
static_assert(offsetof(FPerMeshInstancingData, GpuCullingSwap_hashToInstancedMeshes) == 0x000050, "Member 'FPerMeshInstancingData::GpuCullingSwap_hashToInstancedMeshes' has a wrong offset!");
static_assert(offsetof(FPerMeshInstancingData, Hism_hashToInstancedMeshes) == 0x0000A0, "Member 'FPerMeshInstancingData::Hism_hashToInstancedMeshes' has a wrong offset!");

// ScriptStruct DeadByDaylight.WebNode
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x08) FWebNode final
{
public:
	uint8                                         Pad_0[0x28];                                       // 0x0000(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWebNode) == 0x000008, "Wrong alignment on FWebNode");
static_assert(sizeof(FWebNode) == 0x000028, "Wrong size on FWebNode");

// ScriptStruct DeadByDaylight.PromoPackData
// 0x0180 (0x0188 - 0x0008)
struct FPromoPackData final : public FDBDTableRowBase
{
public:
	class FName                                   ID;                                                // 0x0008(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UPaperSprite>            PromoPackIcon;                                     // 0x0018(0x0038)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FItemUIData                            UIData;                                            // 0x0050(0x0138)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPromoPackData) == 0x000008, "Wrong alignment on FPromoPackData");
static_assert(sizeof(FPromoPackData) == 0x000188, "Wrong size on FPromoPackData");
static_assert(offsetof(FPromoPackData, ID) == 0x000008, "Member 'FPromoPackData::ID' has a wrong offset!");
static_assert(offsetof(FPromoPackData, PromoPackIcon) == 0x000018, "Member 'FPromoPackData::PromoPackIcon' has a wrong offset!");
static_assert(offsetof(FPromoPackData, UIData) == 0x000050, "Member 'FPromoPackData::UIData' has a wrong offset!");

// ScriptStruct DeadByDaylight.MaxSpeedValidate
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FMaxSpeedValidate final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMaxSpeedValidate) == 0x000008, "Wrong alignment on FMaxSpeedValidate");
static_assert(sizeof(FMaxSpeedValidate) == 0x000018, "Wrong size on FMaxSpeedValidate");

// ScriptStruct DeadByDaylight.ShopTransactionItemParameters
// 0x0028 (0x0028 - 0x0000)
struct FShopTransactionItemParameters final
{
public:
	int32                                         ItemAmount;                                        // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ItemName;                                          // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ItemType;                                          // 0x0018(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FShopTransactionItemParameters) == 0x000008, "Wrong alignment on FShopTransactionItemParameters");
static_assert(sizeof(FShopTransactionItemParameters) == 0x000028, "Wrong size on FShopTransactionItemParameters");
static_assert(offsetof(FShopTransactionItemParameters, ItemAmount) == 0x000000, "Member 'FShopTransactionItemParameters::ItemAmount' has a wrong offset!");
static_assert(offsetof(FShopTransactionItemParameters, ItemName) == 0x000008, "Member 'FShopTransactionItemParameters::ItemName' has a wrong offset!");
static_assert(offsetof(FShopTransactionItemParameters, ItemType) == 0x000018, "Member 'FShopTransactionItemParameters::ItemType' has a wrong offset!");

// ScriptStruct DeadByDaylight.ShopTransactionItem
// 0x0028 (0x0028 - 0x0000)
struct FShopTransactionItem final
{
public:
	struct FShopTransactionItemParameters         Item;                                              // 0x0000(0x0028)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FShopTransactionItem) == 0x000008, "Wrong alignment on FShopTransactionItem");
static_assert(sizeof(FShopTransactionItem) == 0x000028, "Wrong size on FShopTransactionItem");
static_assert(offsetof(FShopTransactionItem, Item) == 0x000000, "Member 'FShopTransactionItem::Item' has a wrong offset!");

// ScriptStruct DeadByDaylight.ShopTransactionProducts
// 0x0020 (0x0020 - 0x0000)
struct FShopTransactionProducts final
{
public:
	TArray<struct FShopTransactionVirtualCurrency> VirtualCurrencies;                                 // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FShopTransactionItem>           Items;                                             // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FShopTransactionProducts) == 0x000008, "Wrong alignment on FShopTransactionProducts");
static_assert(sizeof(FShopTransactionProducts) == 0x000020, "Wrong size on FShopTransactionProducts");
static_assert(offsetof(FShopTransactionProducts, VirtualCurrencies) == 0x000000, "Member 'FShopTransactionProducts::VirtualCurrencies' has a wrong offset!");
static_assert(offsetof(FShopTransactionProducts, Items) == 0x000010, "Member 'FShopTransactionProducts::Items' has a wrong offset!");

// ScriptStruct DeadByDaylight.AffectedMaterialAndVariant
// 0x0010 (0x0010 - 0x0000)
struct FAffectedMaterialAndVariant final
{
public:
	class UMaterialInterface*                     AffectedMaterial;                                  // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     MaterialVariant;                                   // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAffectedMaterialAndVariant) == 0x000008, "Wrong alignment on FAffectedMaterialAndVariant");
static_assert(sizeof(FAffectedMaterialAndVariant) == 0x000010, "Wrong size on FAffectedMaterialAndVariant");
static_assert(offsetof(FAffectedMaterialAndVariant, AffectedMaterial) == 0x000000, "Member 'FAffectedMaterialAndVariant::AffectedMaterial' has a wrong offset!");
static_assert(offsetof(FAffectedMaterialAndVariant, MaterialVariant) == 0x000008, "Member 'FAffectedMaterialAndVariant::MaterialVariant' has a wrong offset!");

// ScriptStruct DeadByDaylight.DBDCustomizationToolData
// 0x1178 (0x1178 - 0x0000)
struct FDBDCustomizationToolData final
{
public:
	struct FCustomizationItemData                 Head;                                              // 0x0000(0x0440)(Edit, NativeAccessSpecifierPublic)
	struct FCustomizationItemData                 Torso;                                             // 0x0440(0x0440)(Edit, NativeAccessSpecifierPublic)
	struct FCustomizationItemData                 Leg;                                               // 0x0880(0x0440)(Edit, NativeAccessSpecifierPublic)
	struct FCustomizationItemData                 Bodies;                                            // 0x0CC0(0x0440)(Edit, NativeAccessSpecifierPublic)
	class FString                                 CharacterName;                                     // 0x1100(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 RoleName;                                          // 0x1110(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMesh*                          BaseSkeleton;                                      // 0x1120(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             MaskTexture;                                       // 0x1128(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimationAsset*                        AnimationToPlay;                                   // 0x1130(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 StrHeadDLC;                                        // 0x1138(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 StrTorsoDLC;                                       // 0x1148(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 StrLegDLC;                                         // 0x1158(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 StrBodiesDLC;                                      // 0x1168(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDBDCustomizationToolData) == 0x000008, "Wrong alignment on FDBDCustomizationToolData");
static_assert(sizeof(FDBDCustomizationToolData) == 0x001178, "Wrong size on FDBDCustomizationToolData");
static_assert(offsetof(FDBDCustomizationToolData, Head) == 0x000000, "Member 'FDBDCustomizationToolData::Head' has a wrong offset!");
static_assert(offsetof(FDBDCustomizationToolData, Torso) == 0x000440, "Member 'FDBDCustomizationToolData::Torso' has a wrong offset!");
static_assert(offsetof(FDBDCustomizationToolData, Leg) == 0x000880, "Member 'FDBDCustomizationToolData::Leg' has a wrong offset!");
static_assert(offsetof(FDBDCustomizationToolData, Bodies) == 0x000CC0, "Member 'FDBDCustomizationToolData::Bodies' has a wrong offset!");
static_assert(offsetof(FDBDCustomizationToolData, CharacterName) == 0x001100, "Member 'FDBDCustomizationToolData::CharacterName' has a wrong offset!");
static_assert(offsetof(FDBDCustomizationToolData, RoleName) == 0x001110, "Member 'FDBDCustomizationToolData::RoleName' has a wrong offset!");
static_assert(offsetof(FDBDCustomizationToolData, BaseSkeleton) == 0x001120, "Member 'FDBDCustomizationToolData::BaseSkeleton' has a wrong offset!");
static_assert(offsetof(FDBDCustomizationToolData, MaskTexture) == 0x001128, "Member 'FDBDCustomizationToolData::MaskTexture' has a wrong offset!");
static_assert(offsetof(FDBDCustomizationToolData, AnimationToPlay) == 0x001130, "Member 'FDBDCustomizationToolData::AnimationToPlay' has a wrong offset!");
static_assert(offsetof(FDBDCustomizationToolData, StrHeadDLC) == 0x001138, "Member 'FDBDCustomizationToolData::StrHeadDLC' has a wrong offset!");
static_assert(offsetof(FDBDCustomizationToolData, StrTorsoDLC) == 0x001148, "Member 'FDBDCustomizationToolData::StrTorsoDLC' has a wrong offset!");
static_assert(offsetof(FDBDCustomizationToolData, StrLegDLC) == 0x001158, "Member 'FDBDCustomizationToolData::StrLegDLC' has a wrong offset!");
static_assert(offsetof(FDBDCustomizationToolData, StrBodiesDLC) == 0x001168, "Member 'FDBDCustomizationToolData::StrBodiesDLC' has a wrong offset!");

// ScriptStruct DeadByDaylight.SkillCheckDefinition
// 0x0028 (0x0028 - 0x0000)
struct FSkillCheckDefinition final
{
public:
	float                                         SuccessZoneStart;                                  // 0x0000(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SuccessZoneEnd;                                    // 0x0004(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BonusZoneLength;                                   // 0x0008(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BonusZoneStart;                                    // 0x000C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProgressRate;                                      // 0x0010(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartingTickerPosition;                            // 0x0014(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsDeactivatedAfterResponse;                        // 0x0018(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WarningSoundDelay;                                 // 0x001C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsAudioMuted;                                      // 0x0020(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsJittering;                                       // 0x0021(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsOffCenter;                                       // 0x0022(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsSuccessZoneMirrorred;                            // 0x0023(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsInsane;                                          // 0x0024(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsLocallyPredicted;                                // 0x0025(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26[0x2];                                       // 0x0026(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSkillCheckDefinition) == 0x000004, "Wrong alignment on FSkillCheckDefinition");
static_assert(sizeof(FSkillCheckDefinition) == 0x000028, "Wrong size on FSkillCheckDefinition");
static_assert(offsetof(FSkillCheckDefinition, SuccessZoneStart) == 0x000000, "Member 'FSkillCheckDefinition::SuccessZoneStart' has a wrong offset!");
static_assert(offsetof(FSkillCheckDefinition, SuccessZoneEnd) == 0x000004, "Member 'FSkillCheckDefinition::SuccessZoneEnd' has a wrong offset!");
static_assert(offsetof(FSkillCheckDefinition, BonusZoneLength) == 0x000008, "Member 'FSkillCheckDefinition::BonusZoneLength' has a wrong offset!");
static_assert(offsetof(FSkillCheckDefinition, BonusZoneStart) == 0x00000C, "Member 'FSkillCheckDefinition::BonusZoneStart' has a wrong offset!");
static_assert(offsetof(FSkillCheckDefinition, ProgressRate) == 0x000010, "Member 'FSkillCheckDefinition::ProgressRate' has a wrong offset!");
static_assert(offsetof(FSkillCheckDefinition, StartingTickerPosition) == 0x000014, "Member 'FSkillCheckDefinition::StartingTickerPosition' has a wrong offset!");
static_assert(offsetof(FSkillCheckDefinition, IsDeactivatedAfterResponse) == 0x000018, "Member 'FSkillCheckDefinition::IsDeactivatedAfterResponse' has a wrong offset!");
static_assert(offsetof(FSkillCheckDefinition, WarningSoundDelay) == 0x00001C, "Member 'FSkillCheckDefinition::WarningSoundDelay' has a wrong offset!");
static_assert(offsetof(FSkillCheckDefinition, IsAudioMuted) == 0x000020, "Member 'FSkillCheckDefinition::IsAudioMuted' has a wrong offset!");
static_assert(offsetof(FSkillCheckDefinition, IsJittering) == 0x000021, "Member 'FSkillCheckDefinition::IsJittering' has a wrong offset!");
static_assert(offsetof(FSkillCheckDefinition, IsOffCenter) == 0x000022, "Member 'FSkillCheckDefinition::IsOffCenter' has a wrong offset!");
static_assert(offsetof(FSkillCheckDefinition, IsSuccessZoneMirrorred) == 0x000023, "Member 'FSkillCheckDefinition::IsSuccessZoneMirrorred' has a wrong offset!");
static_assert(offsetof(FSkillCheckDefinition, IsInsane) == 0x000024, "Member 'FSkillCheckDefinition::IsInsane' has a wrong offset!");
static_assert(offsetof(FSkillCheckDefinition, IsLocallyPredicted) == 0x000025, "Member 'FSkillCheckDefinition::IsLocallyPredicted' has a wrong offset!");

// ScriptStruct DeadByDaylight.ScreenshotExportAction
// 0x0018 (0x0018 - 0x0000)
struct FScreenshotExportAction final
{
public:
	bool                                          ExportOnce;                                        // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IncludeDLCFolder;                                  // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IncludeCharacterFolder;                            // 0x0002(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x5];                                        // 0x0003(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         Directories;                                       // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FScreenshotExportAction) == 0x000008, "Wrong alignment on FScreenshotExportAction");
static_assert(sizeof(FScreenshotExportAction) == 0x000018, "Wrong size on FScreenshotExportAction");
static_assert(offsetof(FScreenshotExportAction, ExportOnce) == 0x000000, "Member 'FScreenshotExportAction::ExportOnce' has a wrong offset!");
static_assert(offsetof(FScreenshotExportAction, IncludeDLCFolder) == 0x000001, "Member 'FScreenshotExportAction::IncludeDLCFolder' has a wrong offset!");
static_assert(offsetof(FScreenshotExportAction, IncludeCharacterFolder) == 0x000002, "Member 'FScreenshotExportAction::IncludeCharacterFolder' has a wrong offset!");
static_assert(offsetof(FScreenshotExportAction, Directories) == 0x000008, "Member 'FScreenshotExportAction::Directories' has a wrong offset!");

// ScriptStruct DeadByDaylight.ItemIdDropdown
// 0x000E (0x0010 - 0x0002)
struct FItemIdDropdown final : public FRoleDropdown
{
public:
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ItemId;                                            // 0x0004(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FItemIdDropdown) == 0x000004, "Wrong alignment on FItemIdDropdown");
static_assert(sizeof(FItemIdDropdown) == 0x000010, "Wrong size on FItemIdDropdown");
static_assert(offsetof(FItemIdDropdown, ItemId) == 0x000004, "Member 'FItemIdDropdown::ItemId' has a wrong offset!");

// ScriptStruct DeadByDaylight.CamperLoadout
// 0x00E0 (0x00E0 - 0x0000)
struct FCamperLoadout final
{
public:
	struct FCharacterCustomizationDropdown        Camper;                                            // 0x0000(0x005C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FCharmDropdown                         Slot0_CharmID;                                     // 0x005C(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FCharmDropdown                         Slot1_CharmID;                                     // 0x006C(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FCharmDropdown                         Slot2_CharmID;                                     // 0x007C(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FItemIdDropdown                        Item;                                              // 0x008C(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FDebugLoadoutAddon>             AddonIDs;                                          // 0x00A0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FDebugLoadoutPerk>              Perks;                                             // 0x00B0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FOfferingDropdown                      Offering;                                          // 0x00C0(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FCharacterClassDropdown                CharacterClass;                                    // 0x00D0(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCamperLoadout) == 0x000008, "Wrong alignment on FCamperLoadout");
static_assert(sizeof(FCamperLoadout) == 0x0000E0, "Wrong size on FCamperLoadout");
static_assert(offsetof(FCamperLoadout, Camper) == 0x000000, "Member 'FCamperLoadout::Camper' has a wrong offset!");
static_assert(offsetof(FCamperLoadout, Slot0_CharmID) == 0x00005C, "Member 'FCamperLoadout::Slot0_CharmID' has a wrong offset!");
static_assert(offsetof(FCamperLoadout, Slot1_CharmID) == 0x00006C, "Member 'FCamperLoadout::Slot1_CharmID' has a wrong offset!");
static_assert(offsetof(FCamperLoadout, Slot2_CharmID) == 0x00007C, "Member 'FCamperLoadout::Slot2_CharmID' has a wrong offset!");
static_assert(offsetof(FCamperLoadout, Item) == 0x00008C, "Member 'FCamperLoadout::Item' has a wrong offset!");
static_assert(offsetof(FCamperLoadout, AddonIDs) == 0x0000A0, "Member 'FCamperLoadout::AddonIDs' has a wrong offset!");
static_assert(offsetof(FCamperLoadout, Perks) == 0x0000B0, "Member 'FCamperLoadout::Perks' has a wrong offset!");
static_assert(offsetof(FCamperLoadout, Offering) == 0x0000C0, "Member 'FCamperLoadout::Offering' has a wrong offset!");
static_assert(offsetof(FCamperLoadout, CharacterClass) == 0x0000D0, "Member 'FCamperLoadout::CharacterClass' has a wrong offset!");

// ScriptStruct DeadByDaylight.SubtitlesDescription
// 0x0070 (0x0078 - 0x0008)
struct FSubtitlesDescription final : public FDBDTableRowBase
{
public:
	class FText                                   SubtitlesText;                                     // 0x0008(0x0018)(Edit, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAkAudioEvent>           AudioEvent;                                        // 0x0020(0x0038)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 DurationOverride;                                  // 0x0058(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 InclusionVersion;                                  // 0x0068(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSubtitlesDescription) == 0x000008, "Wrong alignment on FSubtitlesDescription");
static_assert(sizeof(FSubtitlesDescription) == 0x000078, "Wrong size on FSubtitlesDescription");
static_assert(offsetof(FSubtitlesDescription, SubtitlesText) == 0x000008, "Member 'FSubtitlesDescription::SubtitlesText' has a wrong offset!");
static_assert(offsetof(FSubtitlesDescription, AudioEvent) == 0x000020, "Member 'FSubtitlesDescription::AudioEvent' has a wrong offset!");
static_assert(offsetof(FSubtitlesDescription, DurationOverride) == 0x000058, "Member 'FSubtitlesDescription::DurationOverride' has a wrong offset!");
static_assert(offsetof(FSubtitlesDescription, InclusionVersion) == 0x000068, "Member 'FSubtitlesDescription::InclusionVersion' has a wrong offset!");

// ScriptStruct DeadByDaylight.PerkLevelDefinition
// 0x0004 (0x0004 - 0x0000)
struct FPerkLevelDefinition final
{
public:
	int32                                         CountRequired;                                     // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPerkLevelDefinition) == 0x000004, "Wrong alignment on FPerkLevelDefinition");
static_assert(sizeof(FPerkLevelDefinition) == 0x000004, "Wrong size on FPerkLevelDefinition");
static_assert(offsetof(FPerkLevelDefinition, CountRequired) == 0x000000, "Member 'FPerkLevelDefinition::CountRequired' has a wrong offset!");

// ScriptStruct DeadByDaylight.StoreItemSlotData
// 0x0210 (0x0210 - 0x0000)
struct FStoreItemSlotData final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ItemId;                                            // 0x0008(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECustomizationCategory                        Category;                                          // 0x0014(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   MirrorsId;                                         // 0x0018(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 IconPath;                                          // 0x0028(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DisplayName;                                       // 0x0038(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DisplayCollectionName;                             // 0x0048(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Description;                                       // 0x0058(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 RoleCategoryInfo;                                  // 0x0068(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 RarityPartInfo;                                    // 0x0078(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemRarity                                   Rarity;                                            // 0x0088(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSpecialEventUIInfo                    EventInfo;                                         // 0x0090(0x0060)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPublic)
	TArray<struct FPurchaseCurrencyData>          PurchaseDataList;                                  // 0x00F0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<class FName>                           ParentBundleIds;                                   // 0x0100(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<class FName>                           ChildrenItemIds;                                   // 0x0110(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	struct FCustomTransformation                  CustomTransformation;                              // 0x0120(0x0028)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          IsOwned;                                           // 0x0148(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsBuyable;                                         // 0x0149(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsEquipped;                                        // 0x014A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsNewInStore;                                      // 0x014B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsLocked;                                          // 0x014C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsInStore;                                         // 0x014D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsVisceral;                                        // 0x014E(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasPlayMoriButton;                                 // 0x014F(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerRole                                   AssociatedRole;                                    // 0x0150(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_151[0x7];                                      // 0x0151(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              ReleaseDate;                                       // 0x0158(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsEnabled;                                         // 0x0160(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_161[0x7];                                      // 0x0161(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              LimitedEndDateTime;                                // 0x0168(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              DiscountEndDateTime;                               // 0x0170(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_178[0x70];                                     // 0x0178(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FText>                           SearchTags;                                        // 0x01E8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<class FText>                           AssociatedCharacterSearchTags;                     // 0x01F8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	int32                                         LocKeyResultMaxChars;                              // 0x0208(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20C[0x4];                                      // 0x020C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStoreItemSlotData) == 0x000008, "Wrong alignment on FStoreItemSlotData");
static_assert(sizeof(FStoreItemSlotData) == 0x000210, "Wrong size on FStoreItemSlotData");
static_assert(offsetof(FStoreItemSlotData, ItemId) == 0x000008, "Member 'FStoreItemSlotData::ItemId' has a wrong offset!");
static_assert(offsetof(FStoreItemSlotData, Category) == 0x000014, "Member 'FStoreItemSlotData::Category' has a wrong offset!");
static_assert(offsetof(FStoreItemSlotData, MirrorsId) == 0x000018, "Member 'FStoreItemSlotData::MirrorsId' has a wrong offset!");
static_assert(offsetof(FStoreItemSlotData, IconPath) == 0x000028, "Member 'FStoreItemSlotData::IconPath' has a wrong offset!");
static_assert(offsetof(FStoreItemSlotData, DisplayName) == 0x000038, "Member 'FStoreItemSlotData::DisplayName' has a wrong offset!");
static_assert(offsetof(FStoreItemSlotData, DisplayCollectionName) == 0x000048, "Member 'FStoreItemSlotData::DisplayCollectionName' has a wrong offset!");
static_assert(offsetof(FStoreItemSlotData, Description) == 0x000058, "Member 'FStoreItemSlotData::Description' has a wrong offset!");
static_assert(offsetof(FStoreItemSlotData, RoleCategoryInfo) == 0x000068, "Member 'FStoreItemSlotData::RoleCategoryInfo' has a wrong offset!");
static_assert(offsetof(FStoreItemSlotData, RarityPartInfo) == 0x000078, "Member 'FStoreItemSlotData::RarityPartInfo' has a wrong offset!");
static_assert(offsetof(FStoreItemSlotData, Rarity) == 0x000088, "Member 'FStoreItemSlotData::Rarity' has a wrong offset!");
static_assert(offsetof(FStoreItemSlotData, EventInfo) == 0x000090, "Member 'FStoreItemSlotData::EventInfo' has a wrong offset!");
static_assert(offsetof(FStoreItemSlotData, PurchaseDataList) == 0x0000F0, "Member 'FStoreItemSlotData::PurchaseDataList' has a wrong offset!");
static_assert(offsetof(FStoreItemSlotData, ParentBundleIds) == 0x000100, "Member 'FStoreItemSlotData::ParentBundleIds' has a wrong offset!");
static_assert(offsetof(FStoreItemSlotData, ChildrenItemIds) == 0x000110, "Member 'FStoreItemSlotData::ChildrenItemIds' has a wrong offset!");
static_assert(offsetof(FStoreItemSlotData, CustomTransformation) == 0x000120, "Member 'FStoreItemSlotData::CustomTransformation' has a wrong offset!");
static_assert(offsetof(FStoreItemSlotData, IsOwned) == 0x000148, "Member 'FStoreItemSlotData::IsOwned' has a wrong offset!");
static_assert(offsetof(FStoreItemSlotData, IsBuyable) == 0x000149, "Member 'FStoreItemSlotData::IsBuyable' has a wrong offset!");
static_assert(offsetof(FStoreItemSlotData, IsEquipped) == 0x00014A, "Member 'FStoreItemSlotData::IsEquipped' has a wrong offset!");
static_assert(offsetof(FStoreItemSlotData, IsNewInStore) == 0x00014B, "Member 'FStoreItemSlotData::IsNewInStore' has a wrong offset!");
static_assert(offsetof(FStoreItemSlotData, IsLocked) == 0x00014C, "Member 'FStoreItemSlotData::IsLocked' has a wrong offset!");
static_assert(offsetof(FStoreItemSlotData, IsInStore) == 0x00014D, "Member 'FStoreItemSlotData::IsInStore' has a wrong offset!");
static_assert(offsetof(FStoreItemSlotData, IsVisceral) == 0x00014E, "Member 'FStoreItemSlotData::IsVisceral' has a wrong offset!");
static_assert(offsetof(FStoreItemSlotData, HasPlayMoriButton) == 0x00014F, "Member 'FStoreItemSlotData::HasPlayMoriButton' has a wrong offset!");
static_assert(offsetof(FStoreItemSlotData, AssociatedRole) == 0x000150, "Member 'FStoreItemSlotData::AssociatedRole' has a wrong offset!");
static_assert(offsetof(FStoreItemSlotData, ReleaseDate) == 0x000158, "Member 'FStoreItemSlotData::ReleaseDate' has a wrong offset!");
static_assert(offsetof(FStoreItemSlotData, IsEnabled) == 0x000160, "Member 'FStoreItemSlotData::IsEnabled' has a wrong offset!");
static_assert(offsetof(FStoreItemSlotData, LimitedEndDateTime) == 0x000168, "Member 'FStoreItemSlotData::LimitedEndDateTime' has a wrong offset!");
static_assert(offsetof(FStoreItemSlotData, DiscountEndDateTime) == 0x000170, "Member 'FStoreItemSlotData::DiscountEndDateTime' has a wrong offset!");
static_assert(offsetof(FStoreItemSlotData, SearchTags) == 0x0001E8, "Member 'FStoreItemSlotData::SearchTags' has a wrong offset!");
static_assert(offsetof(FStoreItemSlotData, AssociatedCharacterSearchTags) == 0x0001F8, "Member 'FStoreItemSlotData::AssociatedCharacterSearchTags' has a wrong offset!");
static_assert(offsetof(FStoreItemSlotData, LocKeyResultMaxChars) == 0x000208, "Member 'FStoreItemSlotData::LocKeyResultMaxChars' has a wrong offset!");

// ScriptStruct DeadByDaylight.AttackTypeDetails
// 0x0020 (0x0028 - 0x0008)
struct FAttackTypeDetails final : public FDBDTableRowBase
{
public:
	EAttackType                                   AttackType;                                        // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsBasicAttack;                                     // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AssociatedCharacter;                               // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0010(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAttackTypeDetails) == 0x000008, "Wrong alignment on FAttackTypeDetails");
static_assert(sizeof(FAttackTypeDetails) == 0x000028, "Wrong size on FAttackTypeDetails");
static_assert(offsetof(FAttackTypeDetails, AttackType) == 0x000008, "Member 'FAttackTypeDetails::AttackType' has a wrong offset!");
static_assert(offsetof(FAttackTypeDetails, IsBasicAttack) == 0x000009, "Member 'FAttackTypeDetails::IsBasicAttack' has a wrong offset!");
static_assert(offsetof(FAttackTypeDetails, AssociatedCharacter) == 0x00000C, "Member 'FAttackTypeDetails::AssociatedCharacter' has a wrong offset!");
static_assert(offsetof(FAttackTypeDetails, Description) == 0x000010, "Member 'FAttackTypeDetails::Description' has a wrong offset!");

// ScriptStruct DeadByDaylight.InventorySlotData
// 0x0150 (0x0150 - 0x0000)
struct FInventorySlotData final
{
public:
	class FName                                   ItemId;                                            // 0x0000(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 IconFilePath;                                      // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DisplayName;                                       // 0x0020(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ParentId;                                          // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ParentDisplayName;                                 // 0x0040(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ParentTypeDisplayName;                             // 0x0050(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsParentAvailable;                                 // 0x0060(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Description;                                       // 0x0068(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EPerkCategory>                         PerkCategory;                                      // 0x0078(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	EOfferingCategory                             OfferingCategory;                                  // 0x0088(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInventoryItemType                            ItemType;                                          // 0x0089(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemRarity                                   Rarity;                                            // 0x008A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStatusEffectType                             StatusEffectType;                                  // 0x008B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x008C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Subtitle;                                          // 0x0090(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StackCount;                                        // 0x00A0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemAvailability                             Availability;                                      // 0x00A4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsTeachablePerk;                                   // 0x00A5(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsSlasherPerk;                                     // 0x00A6(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsPerkAvailableInFearMarket;                       // 0x00A7(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsPerkAvailableInBloodWeb;                         // 0x00A8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x3];                                       // 0x00A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TeachableLevel;                                    // 0x00AC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DlcDisplayName;                                    // 0x00B0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsLocked;                                          // 0x00C0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C1[0x7];                                       // 0x00C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSpecialEventUIInfo                    EventInfo;                                         // 0x00C8(0x0060)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPublic)
	int32                                         UnlockableLevel;                                   // 0x0128(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsLimitedItem;                                     // 0x012C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsPrivateIcon;                                     // 0x012D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsEnabled;                                         // 0x012E(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsSharablePerk;                                    // 0x012F(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELoadoutPartState                             LoadoutPartState;                                  // 0x0130(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESkillCategory                                SkillCategory;                                     // 0x0131(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsSkillUnlockable;                                 // 0x0132(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_133[0x5];                                      // 0x0133(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FText>                           SearchTags;                                        // 0x0138(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	int32                                         WarningMessageLength;                              // 0x0148(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14C[0x4];                                      // 0x014C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FInventorySlotData) == 0x000008, "Wrong alignment on FInventorySlotData");
static_assert(sizeof(FInventorySlotData) == 0x000150, "Wrong size on FInventorySlotData");
static_assert(offsetof(FInventorySlotData, ItemId) == 0x000000, "Member 'FInventorySlotData::ItemId' has a wrong offset!");
static_assert(offsetof(FInventorySlotData, IconFilePath) == 0x000010, "Member 'FInventorySlotData::IconFilePath' has a wrong offset!");
static_assert(offsetof(FInventorySlotData, DisplayName) == 0x000020, "Member 'FInventorySlotData::DisplayName' has a wrong offset!");
static_assert(offsetof(FInventorySlotData, ParentId) == 0x000030, "Member 'FInventorySlotData::ParentId' has a wrong offset!");
static_assert(offsetof(FInventorySlotData, ParentDisplayName) == 0x000040, "Member 'FInventorySlotData::ParentDisplayName' has a wrong offset!");
static_assert(offsetof(FInventorySlotData, ParentTypeDisplayName) == 0x000050, "Member 'FInventorySlotData::ParentTypeDisplayName' has a wrong offset!");
static_assert(offsetof(FInventorySlotData, IsParentAvailable) == 0x000060, "Member 'FInventorySlotData::IsParentAvailable' has a wrong offset!");
static_assert(offsetof(FInventorySlotData, Description) == 0x000068, "Member 'FInventorySlotData::Description' has a wrong offset!");
static_assert(offsetof(FInventorySlotData, PerkCategory) == 0x000078, "Member 'FInventorySlotData::PerkCategory' has a wrong offset!");
static_assert(offsetof(FInventorySlotData, OfferingCategory) == 0x000088, "Member 'FInventorySlotData::OfferingCategory' has a wrong offset!");
static_assert(offsetof(FInventorySlotData, ItemType) == 0x000089, "Member 'FInventorySlotData::ItemType' has a wrong offset!");
static_assert(offsetof(FInventorySlotData, Rarity) == 0x00008A, "Member 'FInventorySlotData::Rarity' has a wrong offset!");
static_assert(offsetof(FInventorySlotData, StatusEffectType) == 0x00008B, "Member 'FInventorySlotData::StatusEffectType' has a wrong offset!");
static_assert(offsetof(FInventorySlotData, Level) == 0x00008C, "Member 'FInventorySlotData::Level' has a wrong offset!");
static_assert(offsetof(FInventorySlotData, Subtitle) == 0x000090, "Member 'FInventorySlotData::Subtitle' has a wrong offset!");
static_assert(offsetof(FInventorySlotData, StackCount) == 0x0000A0, "Member 'FInventorySlotData::StackCount' has a wrong offset!");
static_assert(offsetof(FInventorySlotData, Availability) == 0x0000A4, "Member 'FInventorySlotData::Availability' has a wrong offset!");
static_assert(offsetof(FInventorySlotData, IsTeachablePerk) == 0x0000A5, "Member 'FInventorySlotData::IsTeachablePerk' has a wrong offset!");
static_assert(offsetof(FInventorySlotData, IsSlasherPerk) == 0x0000A6, "Member 'FInventorySlotData::IsSlasherPerk' has a wrong offset!");
static_assert(offsetof(FInventorySlotData, IsPerkAvailableInFearMarket) == 0x0000A7, "Member 'FInventorySlotData::IsPerkAvailableInFearMarket' has a wrong offset!");
static_assert(offsetof(FInventorySlotData, IsPerkAvailableInBloodWeb) == 0x0000A8, "Member 'FInventorySlotData::IsPerkAvailableInBloodWeb' has a wrong offset!");
static_assert(offsetof(FInventorySlotData, TeachableLevel) == 0x0000AC, "Member 'FInventorySlotData::TeachableLevel' has a wrong offset!");
static_assert(offsetof(FInventorySlotData, DlcDisplayName) == 0x0000B0, "Member 'FInventorySlotData::DlcDisplayName' has a wrong offset!");
static_assert(offsetof(FInventorySlotData, IsLocked) == 0x0000C0, "Member 'FInventorySlotData::IsLocked' has a wrong offset!");
static_assert(offsetof(FInventorySlotData, EventInfo) == 0x0000C8, "Member 'FInventorySlotData::EventInfo' has a wrong offset!");
static_assert(offsetof(FInventorySlotData, UnlockableLevel) == 0x000128, "Member 'FInventorySlotData::UnlockableLevel' has a wrong offset!");
static_assert(offsetof(FInventorySlotData, IsLimitedItem) == 0x00012C, "Member 'FInventorySlotData::IsLimitedItem' has a wrong offset!");
static_assert(offsetof(FInventorySlotData, IsPrivateIcon) == 0x00012D, "Member 'FInventorySlotData::IsPrivateIcon' has a wrong offset!");
static_assert(offsetof(FInventorySlotData, IsEnabled) == 0x00012E, "Member 'FInventorySlotData::IsEnabled' has a wrong offset!");
static_assert(offsetof(FInventorySlotData, IsSharablePerk) == 0x00012F, "Member 'FInventorySlotData::IsSharablePerk' has a wrong offset!");
static_assert(offsetof(FInventorySlotData, LoadoutPartState) == 0x000130, "Member 'FInventorySlotData::LoadoutPartState' has a wrong offset!");
static_assert(offsetof(FInventorySlotData, SkillCategory) == 0x000131, "Member 'FInventorySlotData::SkillCategory' has a wrong offset!");
static_assert(offsetof(FInventorySlotData, IsSkillUnlockable) == 0x000132, "Member 'FInventorySlotData::IsSkillUnlockable' has a wrong offset!");
static_assert(offsetof(FInventorySlotData, SearchTags) == 0x000138, "Member 'FInventorySlotData::SearchTags' has a wrong offset!");
static_assert(offsetof(FInventorySlotData, WarningMessageLength) == 0x000148, "Member 'FInventorySlotData::WarningMessageLength' has a wrong offset!");

// ScriptStruct DeadByDaylight.TallyItemChangedData
// 0x03F8 (0x03F8 - 0x0000)
struct FTallyItemChangedData final
{
public:
	struct FInventorySlotData                     Item;                                              // 0x0000(0x0150)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPublic)
	struct FInventorySlotData                     Addon1;                                            // 0x0150(0x0150)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPublic)
	struct FInventorySlotData                     Addon2;                                            // 0x02A0(0x0150)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPublic)
	bool                                          IsSet;                                             // 0x03F0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEnergyTypeEnum                               EnergyType;                                        // 0x03F1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3F2[0x2];                                      // 0x03F2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EnergyLevel;                                       // 0x03F4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTallyItemChangedData) == 0x000008, "Wrong alignment on FTallyItemChangedData");
static_assert(sizeof(FTallyItemChangedData) == 0x0003F8, "Wrong size on FTallyItemChangedData");
static_assert(offsetof(FTallyItemChangedData, Item) == 0x000000, "Member 'FTallyItemChangedData::Item' has a wrong offset!");
static_assert(offsetof(FTallyItemChangedData, Addon1) == 0x000150, "Member 'FTallyItemChangedData::Addon1' has a wrong offset!");
static_assert(offsetof(FTallyItemChangedData, Addon2) == 0x0002A0, "Member 'FTallyItemChangedData::Addon2' has a wrong offset!");
static_assert(offsetof(FTallyItemChangedData, IsSet) == 0x0003F0, "Member 'FTallyItemChangedData::IsSet' has a wrong offset!");
static_assert(offsetof(FTallyItemChangedData, EnergyType) == 0x0003F1, "Member 'FTallyItemChangedData::EnergyType' has a wrong offset!");
static_assert(offsetof(FTallyItemChangedData, EnergyLevel) == 0x0003F4, "Member 'FTallyItemChangedData::EnergyLevel' has a wrong offset!");

// ScriptStruct DeadByDaylight.ProgressionPoints
// 0x0008 (0x0008 - 0x0000)
struct FProgressionPoints final
{
public:
	EEmblemProgressionType                        Type;                                              // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Points;                                            // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FProgressionPoints) == 0x000004, "Wrong alignment on FProgressionPoints");
static_assert(sizeof(FProgressionPoints) == 0x000008, "Wrong size on FProgressionPoints");
static_assert(offsetof(FProgressionPoints, Type) == 0x000000, "Member 'FProgressionPoints::Type' has a wrong offset!");
static_assert(offsetof(FProgressionPoints, Points) == 0x000004, "Member 'FProgressionPoints::Points' has a wrong offset!");

// ScriptStruct DeadByDaylight.EndOfMatchRPCData
// 0x0018 (0x0018 - 0x0000)
struct FEndOfMatchRPCData final
{
public:
	class FString                                 _jsonData;                                         // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isValid;                                          // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEndOfMatchRPCData) == 0x000008, "Wrong alignment on FEndOfMatchRPCData");
static_assert(sizeof(FEndOfMatchRPCData) == 0x000018, "Wrong size on FEndOfMatchRPCData");
static_assert(offsetof(FEndOfMatchRPCData, _jsonData) == 0x000000, "Member 'FEndOfMatchRPCData::_jsonData' has a wrong offset!");
static_assert(offsetof(FEndOfMatchRPCData, _isValid) == 0x000010, "Member 'FEndOfMatchRPCData::_isValid' has a wrong offset!");

// ScriptStruct DeadByDaylight.SharedAuthenticationTokenInformation
// 0x0030 (0x0030 - 0x0000)
struct FSharedAuthenticationTokenInformation final
{
public:
	class FString                                 LoginProvider;                                     // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AuthToken;                                         // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TokenType;                                         // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSharedAuthenticationTokenInformation) == 0x000008, "Wrong alignment on FSharedAuthenticationTokenInformation");
static_assert(sizeof(FSharedAuthenticationTokenInformation) == 0x000030, "Wrong size on FSharedAuthenticationTokenInformation");
static_assert(offsetof(FSharedAuthenticationTokenInformation, LoginProvider) == 0x000000, "Member 'FSharedAuthenticationTokenInformation::LoginProvider' has a wrong offset!");
static_assert(offsetof(FSharedAuthenticationTokenInformation, AuthToken) == 0x000010, "Member 'FSharedAuthenticationTokenInformation::AuthToken' has a wrong offset!");
static_assert(offsetof(FSharedAuthenticationTokenInformation, TokenType) == 0x000020, "Member 'FSharedAuthenticationTokenInformation::TokenType' has a wrong offset!");

// ScriptStruct DeadByDaylight.LanguageMapping
// 0x0018 (0x0020 - 0x0008)
struct FLanguageMapping final : public FTableRowBase
{
public:
	class FString                                 Language;                                          // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECustomerSupportLanguages                     CustomerSupportId;                                 // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EForumLanguages                               ForumId;                                           // 0x0019(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x6];                                       // 0x001A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLanguageMapping) == 0x000008, "Wrong alignment on FLanguageMapping");
static_assert(sizeof(FLanguageMapping) == 0x000020, "Wrong size on FLanguageMapping");
static_assert(offsetof(FLanguageMapping, Language) == 0x000008, "Member 'FLanguageMapping::Language' has a wrong offset!");
static_assert(offsetof(FLanguageMapping, CustomerSupportId) == 0x000018, "Member 'FLanguageMapping::CustomerSupportId' has a wrong offset!");
static_assert(offsetof(FLanguageMapping, ForumId) == 0x000019, "Member 'FLanguageMapping::ForumId' has a wrong offset!");

// ScriptStruct DeadByDaylight.OfferingProperties
// 0x0038 (0x02D8 - 0x02A0)
struct FOfferingProperties final : public FItemData
{
public:
	EOfferingType                                 OfferingType;                                      // 0x02A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A1[0x7];                                      // 0x02A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           Tags;                                              // 0x02A8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FOfferingEffect>                Effects;                                           // 0x02B8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 BigIconFilePath;                                   // 0x02C8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOfferingProperties) == 0x000008, "Wrong alignment on FOfferingProperties");
static_assert(sizeof(FOfferingProperties) == 0x0002D8, "Wrong size on FOfferingProperties");
static_assert(offsetof(FOfferingProperties, OfferingType) == 0x0002A0, "Member 'FOfferingProperties::OfferingType' has a wrong offset!");
static_assert(offsetof(FOfferingProperties, Tags) == 0x0002A8, "Member 'FOfferingProperties::Tags' has a wrong offset!");
static_assert(offsetof(FOfferingProperties, Effects) == 0x0002B8, "Member 'FOfferingProperties::Effects' has a wrong offset!");
static_assert(offsetof(FOfferingProperties, BigIconFilePath) == 0x0002C8, "Member 'FOfferingProperties::BigIconFilePath' has a wrong offset!");

// ScriptStruct DeadByDaylight.SpecialEventsContentData
// 0x0158 (0x0158 - 0x0000)
struct FSpecialEventsContentData final
{
public:
	class FString                                 EventID;                                           // 0x0000(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 Starttime;                                         // 0x0010(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 MainEndTime;                                       // 0x0020(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 PostEndTime;                                       // 0x0030(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_40[0x118];                                     // 0x0040(0x0118)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSpecialEventsContentData) == 0x000008, "Wrong alignment on FSpecialEventsContentData");
static_assert(sizeof(FSpecialEventsContentData) == 0x000158, "Wrong size on FSpecialEventsContentData");
static_assert(offsetof(FSpecialEventsContentData, EventID) == 0x000000, "Member 'FSpecialEventsContentData::EventID' has a wrong offset!");
static_assert(offsetof(FSpecialEventsContentData, Starttime) == 0x000010, "Member 'FSpecialEventsContentData::Starttime' has a wrong offset!");
static_assert(offsetof(FSpecialEventsContentData, MainEndTime) == 0x000020, "Member 'FSpecialEventsContentData::MainEndTime' has a wrong offset!");
static_assert(offsetof(FSpecialEventsContentData, PostEndTime) == 0x000030, "Member 'FSpecialEventsContentData::PostEndTime' has a wrong offset!");

// ScriptStruct DeadByDaylight.KeyDisplayInfo
// 0x0040 (0x0040 - 0x0000)
struct FKeyDisplayInfo final
{
public:
	struct FKey                                   Key;                                               // 0x0000(0x0020)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 KeyDisplayName;                                    // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PromptType;                                        // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FKeyDisplayInfo) == 0x000008, "Wrong alignment on FKeyDisplayInfo");
static_assert(sizeof(FKeyDisplayInfo) == 0x000040, "Wrong size on FKeyDisplayInfo");
static_assert(offsetof(FKeyDisplayInfo, Key) == 0x000000, "Member 'FKeyDisplayInfo::Key' has a wrong offset!");
static_assert(offsetof(FKeyDisplayInfo, KeyDisplayName) == 0x000020, "Member 'FKeyDisplayInfo::KeyDisplayName' has a wrong offset!");
static_assert(offsetof(FKeyDisplayInfo, PromptType) == 0x000030, "Member 'FKeyDisplayInfo::PromptType' has a wrong offset!");

// ScriptStruct DeadByDaylight.LegacyCharacterSavedInventoryData
// 0x0018 (0x0018 - 0x0000)
struct FLegacyCharacterSavedInventoryData final
{
public:
	uint32                                        Version;                                           // 0x0000(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Name;                                              // 0x0004(0x000C)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         TimeObtainedSinceEpoch;                            // 0x0010(0x0008)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLegacyCharacterSavedInventoryData) == 0x000008, "Wrong alignment on FLegacyCharacterSavedInventoryData");
static_assert(sizeof(FLegacyCharacterSavedInventoryData) == 0x000018, "Wrong size on FLegacyCharacterSavedInventoryData");
static_assert(offsetof(FLegacyCharacterSavedInventoryData, Version) == 0x000000, "Member 'FLegacyCharacterSavedInventoryData::Version' has a wrong offset!");
static_assert(offsetof(FLegacyCharacterSavedInventoryData, Name) == 0x000004, "Member 'FLegacyCharacterSavedInventoryData::Name' has a wrong offset!");
static_assert(offsetof(FLegacyCharacterSavedInventoryData, TimeObtainedSinceEpoch) == 0x000010, "Member 'FLegacyCharacterSavedInventoryData::TimeObtainedSinceEpoch' has a wrong offset!");

// ScriptStruct DeadByDaylight.LobbyPlayerData
// 0x0060 (0x0060 - 0x0000)
struct alignas(0x08) FLobbyPlayerData final
{
public:
	uint8                                         Pad_0[0x60];                                       // 0x0000(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLobbyPlayerData) == 0x000008, "Wrong alignment on FLobbyPlayerData");
static_assert(sizeof(FLobbyPlayerData) == 0x000060, "Wrong size on FLobbyPlayerData");

// ScriptStruct DeadByDaylight.DBDSearchParams
// 0x0080 (0x0080 - 0x0000)
struct alignas(0x08) FDBDSearchParams final
{
public:
	uint8                                         Pad_0[0x80];                                       // 0x0000(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDBDSearchParams) == 0x000008, "Wrong alignment on FDBDSearchParams");
static_assert(sizeof(FDBDSearchParams) == 0x000080, "Wrong size on FDBDSearchParams");

// ScriptStruct DeadByDaylight.StoreCollectionLimitedAvailabilityEnd
// 0x0010 (0x0010 - 0x0000)
struct FStoreCollectionLimitedAvailabilityEnd final
{
public:
	struct FDateTime                              Date;                                              // 0x0000(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          VisibleAfterEndDate;                               // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStoreCollectionLimitedAvailabilityEnd) == 0x000008, "Wrong alignment on FStoreCollectionLimitedAvailabilityEnd");
static_assert(sizeof(FStoreCollectionLimitedAvailabilityEnd) == 0x000010, "Wrong size on FStoreCollectionLimitedAvailabilityEnd");
static_assert(offsetof(FStoreCollectionLimitedAvailabilityEnd, Date) == 0x000000, "Member 'FStoreCollectionLimitedAvailabilityEnd::Date' has a wrong offset!");
static_assert(offsetof(FStoreCollectionLimitedAvailabilityEnd, VisibleAfterEndDate) == 0x000008, "Member 'FStoreCollectionLimitedAvailabilityEnd::VisibleAfterEndDate' has a wrong offset!");

// ScriptStruct DeadByDaylight.LegacySavedBloodWebPersistentData
// 0x0040 (0x0040 - 0x0000)
struct FLegacySavedBloodWebPersistentData final
{
public:
	int32                                         VersionNumber;                                     // 0x0000(0x0004)(ZeroConstructor, SaveGame, NoClear, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x0004(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FLegacySavedBloodWebRingPersistentData> RingData;                                          // 0x0008(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	TArray<class FName>                           Paths;                                             // 0x0018(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	class FString                                 EntityCurrentNode;                                 // 0x0028(0x0010)(ZeroConstructor, SaveGame, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              GenerationDate;                                    // 0x0038(0x0008)(ZeroConstructor, SaveGame, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLegacySavedBloodWebPersistentData) == 0x000008, "Wrong alignment on FLegacySavedBloodWebPersistentData");
static_assert(sizeof(FLegacySavedBloodWebPersistentData) == 0x000040, "Wrong size on FLegacySavedBloodWebPersistentData");
static_assert(offsetof(FLegacySavedBloodWebPersistentData, VersionNumber) == 0x000000, "Member 'FLegacySavedBloodWebPersistentData::VersionNumber' has a wrong offset!");
static_assert(offsetof(FLegacySavedBloodWebPersistentData, Level) == 0x000004, "Member 'FLegacySavedBloodWebPersistentData::Level' has a wrong offset!");
static_assert(offsetof(FLegacySavedBloodWebPersistentData, RingData) == 0x000008, "Member 'FLegacySavedBloodWebPersistentData::RingData' has a wrong offset!");
static_assert(offsetof(FLegacySavedBloodWebPersistentData, Paths) == 0x000018, "Member 'FLegacySavedBloodWebPersistentData::Paths' has a wrong offset!");
static_assert(offsetof(FLegacySavedBloodWebPersistentData, EntityCurrentNode) == 0x000028, "Member 'FLegacySavedBloodWebPersistentData::EntityCurrentNode' has a wrong offset!");
static_assert(offsetof(FLegacySavedBloodWebPersistentData, GenerationDate) == 0x000038, "Member 'FLegacySavedBloodWebPersistentData::GenerationDate' has a wrong offset!");

// ScriptStruct DeadByDaylight.LegacyCharacterSavedProfileData
// 0x0148 (0x0148 - 0x0000)
struct FLegacyCharacterSavedProfileData final
{
public:
	int32                                         VersionNumber;                                     // 0x0000(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BloodPoints;                                       // 0x0004(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BloodWebLevel;                                     // 0x0008(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PrestigeLevel;                                     // 0x000C(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TimesConfronted;                                   // 0x0010(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FDateTime>                      PrestigeDates;                                     // 0x0018(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	struct FLegacySavedBloodWebPersistentData     BloodWebData;                                      // 0x0028(0x0040)(SaveGame, NativeAccessSpecifierPublic)
	struct FLegacySavedPlayerLoadoutData          CharacterLoadoutData;                              // 0x0068(0x00B0)(SaveGame, NativeAccessSpecifierPublic)
	TArray<class FName>                           Inventory;                                         // 0x0118(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	TArray<struct FLegacyCharacterSavedInventoryData> InventoryData;                                     // 0x0128(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	TArray<class FName>                           CurrentCustomization;                              // 0x0138(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLegacyCharacterSavedProfileData) == 0x000008, "Wrong alignment on FLegacyCharacterSavedProfileData");
static_assert(sizeof(FLegacyCharacterSavedProfileData) == 0x000148, "Wrong size on FLegacyCharacterSavedProfileData");
static_assert(offsetof(FLegacyCharacterSavedProfileData, VersionNumber) == 0x000000, "Member 'FLegacyCharacterSavedProfileData::VersionNumber' has a wrong offset!");
static_assert(offsetof(FLegacyCharacterSavedProfileData, BloodPoints) == 0x000004, "Member 'FLegacyCharacterSavedProfileData::BloodPoints' has a wrong offset!");
static_assert(offsetof(FLegacyCharacterSavedProfileData, BloodWebLevel) == 0x000008, "Member 'FLegacyCharacterSavedProfileData::BloodWebLevel' has a wrong offset!");
static_assert(offsetof(FLegacyCharacterSavedProfileData, PrestigeLevel) == 0x00000C, "Member 'FLegacyCharacterSavedProfileData::PrestigeLevel' has a wrong offset!");
static_assert(offsetof(FLegacyCharacterSavedProfileData, TimesConfronted) == 0x000010, "Member 'FLegacyCharacterSavedProfileData::TimesConfronted' has a wrong offset!");
static_assert(offsetof(FLegacyCharacterSavedProfileData, PrestigeDates) == 0x000018, "Member 'FLegacyCharacterSavedProfileData::PrestigeDates' has a wrong offset!");
static_assert(offsetof(FLegacyCharacterSavedProfileData, BloodWebData) == 0x000028, "Member 'FLegacyCharacterSavedProfileData::BloodWebData' has a wrong offset!");
static_assert(offsetof(FLegacyCharacterSavedProfileData, CharacterLoadoutData) == 0x000068, "Member 'FLegacyCharacterSavedProfileData::CharacterLoadoutData' has a wrong offset!");
static_assert(offsetof(FLegacyCharacterSavedProfileData, Inventory) == 0x000118, "Member 'FLegacyCharacterSavedProfileData::Inventory' has a wrong offset!");
static_assert(offsetof(FLegacyCharacterSavedProfileData, InventoryData) == 0x000128, "Member 'FLegacyCharacterSavedProfileData::InventoryData' has a wrong offset!");
static_assert(offsetof(FLegacyCharacterSavedProfileData, CurrentCustomization) == 0x000138, "Member 'FLegacyCharacterSavedProfileData::CurrentCustomization' has a wrong offset!");

// ScriptStruct DeadByDaylight.ScreenshotToolTarget
// 0x0018 (0x0018 - 0x0000)
struct FScreenshotToolTarget final
{
public:
	EScreenshotToolTargetCategory                 Category;                                          // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EScreenshotToolTargetSubCategory              Subcategory;                                       // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 RawData;                                           // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FScreenshotToolTarget) == 0x000008, "Wrong alignment on FScreenshotToolTarget");
static_assert(sizeof(FScreenshotToolTarget) == 0x000018, "Wrong size on FScreenshotToolTarget");
static_assert(offsetof(FScreenshotToolTarget, Category) == 0x000000, "Member 'FScreenshotToolTarget::Category' has a wrong offset!");
static_assert(offsetof(FScreenshotToolTarget, Subcategory) == 0x000001, "Member 'FScreenshotToolTarget::Subcategory' has a wrong offset!");
static_assert(offsetof(FScreenshotToolTarget, RawData) == 0x000008, "Member 'FScreenshotToolTarget::RawData' has a wrong offset!");

// ScriptStruct DeadByDaylight.ScreenshotToolTargetWithLabel
// 0x0028 (0x0028 - 0x0000)
struct FScreenshotToolTargetWithLabel final
{
public:
	class FName                                   Label;                                             // 0x0000(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FScreenshotToolTarget                  Data;                                              // 0x0010(0x0018)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FScreenshotToolTargetWithLabel) == 0x000008, "Wrong alignment on FScreenshotToolTargetWithLabel");
static_assert(sizeof(FScreenshotToolTargetWithLabel) == 0x000028, "Wrong size on FScreenshotToolTargetWithLabel");
static_assert(offsetof(FScreenshotToolTargetWithLabel, Label) == 0x000000, "Member 'FScreenshotToolTargetWithLabel::Label' has a wrong offset!");
static_assert(offsetof(FScreenshotToolTargetWithLabel, Data) == 0x000010, "Member 'FScreenshotToolTargetWithLabel::Data' has a wrong offset!");

// ScriptStruct DeadByDaylight.LegacyPlayerSavedProfileDataLocal
// 0x0198 (0x0198 - 0x0000)
struct FLegacyPlayerSavedProfileDataLocal final
{
public:
	int32                                         Tokens;                                            // 0x0000(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           Offerings;                                         // 0x0008(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	bool                                          FirstTimePlaying;                                  // 0x0018(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasBeenGivenKillerTutorialEndReward;               // 0x0019(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasBeenGivenSurvivorTutorialEndReward;             // 0x001A(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B[0x1];                                       // 0x001B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Wins;                                              // 0x001C(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Losses;                                            // 0x0020(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, struct FLegacyCharacterSavedProfileData> CharacterData;                                     // 0x0028(0x0050)(SaveGame, NativeAccessSpecifierPublic)
	uint64                                        CurrentSeasonTicks;                                // 0x0078(0x0008)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLegacySavedDailyRitualContainer       DailyRituals;                                      // 0x0080(0x0018)(SaveGame, NativeAccessSpecifierPublic)
	struct FLegacySavedFearMarketOfferingInstance FearMarket;                                        // 0x0098(0x0020)(SaveGame, NativeAccessSpecifierPublic)
	struct FLegacySavedPlayerLoadoutData          LastConnectedLoadout;                              // 0x00B8(0x00B0)(SaveGame, NativeAccessSpecifierPublic)
	int32                                         LastConnectedCharacterIndex;                       // 0x0168(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16C[0x4];                                      // 0x016C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              DisconnectPenaltyTime;                             // 0x0170(0x0008)(ZeroConstructor, SaveGame, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _bloodpoints;                                      // 0x0178(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _bonusBloodpoints;                                 // 0x017C(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _unclampedBloodpoints;                             // 0x0180(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _fearTokens;                                       // 0x0184(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              _ongoingGameTime;                                  // 0x0188(0x0008)(ZeroConstructor, SaveGame, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _fearTokensMigrated;                               // 0x0190(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_191[0x7];                                      // 0x0191(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLegacyPlayerSavedProfileDataLocal) == 0x000008, "Wrong alignment on FLegacyPlayerSavedProfileDataLocal");
static_assert(sizeof(FLegacyPlayerSavedProfileDataLocal) == 0x000198, "Wrong size on FLegacyPlayerSavedProfileDataLocal");
static_assert(offsetof(FLegacyPlayerSavedProfileDataLocal, Tokens) == 0x000000, "Member 'FLegacyPlayerSavedProfileDataLocal::Tokens' has a wrong offset!");
static_assert(offsetof(FLegacyPlayerSavedProfileDataLocal, Offerings) == 0x000008, "Member 'FLegacyPlayerSavedProfileDataLocal::Offerings' has a wrong offset!");
static_assert(offsetof(FLegacyPlayerSavedProfileDataLocal, FirstTimePlaying) == 0x000018, "Member 'FLegacyPlayerSavedProfileDataLocal::FirstTimePlaying' has a wrong offset!");
static_assert(offsetof(FLegacyPlayerSavedProfileDataLocal, HasBeenGivenKillerTutorialEndReward) == 0x000019, "Member 'FLegacyPlayerSavedProfileDataLocal::HasBeenGivenKillerTutorialEndReward' has a wrong offset!");
static_assert(offsetof(FLegacyPlayerSavedProfileDataLocal, HasBeenGivenSurvivorTutorialEndReward) == 0x00001A, "Member 'FLegacyPlayerSavedProfileDataLocal::HasBeenGivenSurvivorTutorialEndReward' has a wrong offset!");
static_assert(offsetof(FLegacyPlayerSavedProfileDataLocal, Wins) == 0x00001C, "Member 'FLegacyPlayerSavedProfileDataLocal::Wins' has a wrong offset!");
static_assert(offsetof(FLegacyPlayerSavedProfileDataLocal, Losses) == 0x000020, "Member 'FLegacyPlayerSavedProfileDataLocal::Losses' has a wrong offset!");
static_assert(offsetof(FLegacyPlayerSavedProfileDataLocal, CharacterData) == 0x000028, "Member 'FLegacyPlayerSavedProfileDataLocal::CharacterData' has a wrong offset!");
static_assert(offsetof(FLegacyPlayerSavedProfileDataLocal, CurrentSeasonTicks) == 0x000078, "Member 'FLegacyPlayerSavedProfileDataLocal::CurrentSeasonTicks' has a wrong offset!");
static_assert(offsetof(FLegacyPlayerSavedProfileDataLocal, DailyRituals) == 0x000080, "Member 'FLegacyPlayerSavedProfileDataLocal::DailyRituals' has a wrong offset!");
static_assert(offsetof(FLegacyPlayerSavedProfileDataLocal, FearMarket) == 0x000098, "Member 'FLegacyPlayerSavedProfileDataLocal::FearMarket' has a wrong offset!");
static_assert(offsetof(FLegacyPlayerSavedProfileDataLocal, LastConnectedLoadout) == 0x0000B8, "Member 'FLegacyPlayerSavedProfileDataLocal::LastConnectedLoadout' has a wrong offset!");
static_assert(offsetof(FLegacyPlayerSavedProfileDataLocal, LastConnectedCharacterIndex) == 0x000168, "Member 'FLegacyPlayerSavedProfileDataLocal::LastConnectedCharacterIndex' has a wrong offset!");
static_assert(offsetof(FLegacyPlayerSavedProfileDataLocal, DisconnectPenaltyTime) == 0x000170, "Member 'FLegacyPlayerSavedProfileDataLocal::DisconnectPenaltyTime' has a wrong offset!");
static_assert(offsetof(FLegacyPlayerSavedProfileDataLocal, _bloodpoints) == 0x000178, "Member 'FLegacyPlayerSavedProfileDataLocal::_bloodpoints' has a wrong offset!");
static_assert(offsetof(FLegacyPlayerSavedProfileDataLocal, _bonusBloodpoints) == 0x00017C, "Member 'FLegacyPlayerSavedProfileDataLocal::_bonusBloodpoints' has a wrong offset!");
static_assert(offsetof(FLegacyPlayerSavedProfileDataLocal, _unclampedBloodpoints) == 0x000180, "Member 'FLegacyPlayerSavedProfileDataLocal::_unclampedBloodpoints' has a wrong offset!");
static_assert(offsetof(FLegacyPlayerSavedProfileDataLocal, _fearTokens) == 0x000184, "Member 'FLegacyPlayerSavedProfileDataLocal::_fearTokens' has a wrong offset!");
static_assert(offsetof(FLegacyPlayerSavedProfileDataLocal, _ongoingGameTime) == 0x000188, "Member 'FLegacyPlayerSavedProfileDataLocal::_ongoingGameTime' has a wrong offset!");
static_assert(offsetof(FLegacyPlayerSavedProfileDataLocal, _fearTokensMigrated) == 0x000190, "Member 'FLegacyPlayerSavedProfileDataLocal::_fearTokensMigrated' has a wrong offset!");

// ScriptStruct DeadByDaylight.LegacyPlayerSavedProfileData
// 0x01E8 (0x01F8 - 0x0010)
struct FLegacyPlayerSavedProfileData final : public FSaveDataBase
{
public:
	class FString                                 PlayerUID;                                         // 0x0010(0x0010)(ZeroConstructor, SaveGame, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLegacyPlayerSavedProfileDataShared    SharedData;                                        // 0x0020(0x0040)(SaveGame, NativeAccessSpecifierPublic)
	struct FLegacyPlayerSavedProfileDataLocal     LocalData;                                         // 0x0060(0x0198)(SaveGame, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLegacyPlayerSavedProfileData) == 0x000008, "Wrong alignment on FLegacyPlayerSavedProfileData");
static_assert(sizeof(FLegacyPlayerSavedProfileData) == 0x0001F8, "Wrong size on FLegacyPlayerSavedProfileData");
static_assert(offsetof(FLegacyPlayerSavedProfileData, PlayerUID) == 0x000010, "Member 'FLegacyPlayerSavedProfileData::PlayerUID' has a wrong offset!");
static_assert(offsetof(FLegacyPlayerSavedProfileData, SharedData) == 0x000020, "Member 'FLegacyPlayerSavedProfileData::SharedData' has a wrong offset!");
static_assert(offsetof(FLegacyPlayerSavedProfileData, LocalData) == 0x000060, "Member 'FLegacyPlayerSavedProfileData::LocalData' has a wrong offset!");

// ScriptStruct DeadByDaylight.OutlineOverrideConfig
// 0x0060 (0x0060 - 0x0000)
struct FOutlineOverrideConfig final
{
public:
	TArray<TSoftObjectPtr<class UMaterialInterface>> TranslucencyDefaultMaterialsOverride;              // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<TSoftClassPtr<class UClass>, struct FOutlineConfig> OutlineOverride;                                   // 0x0010(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOutlineOverrideConfig) == 0x000008, "Wrong alignment on FOutlineOverrideConfig");
static_assert(sizeof(FOutlineOverrideConfig) == 0x000060, "Wrong size on FOutlineOverrideConfig");
static_assert(offsetof(FOutlineOverrideConfig, TranslucencyDefaultMaterialsOverride) == 0x000000, "Member 'FOutlineOverrideConfig::TranslucencyDefaultMaterialsOverride' has a wrong offset!");
static_assert(offsetof(FOutlineOverrideConfig, OutlineOverride) == 0x000010, "Member 'FOutlineOverrideConfig::OutlineOverride' has a wrong offset!");

// ScriptStruct DeadByDaylight.ScreenshotVFXCharmHookCharmData
// 0x00C8 (0x00C8 - 0x0000)
struct FScreenshotVFXCharmHookCharmData final
{
public:
	TSoftObjectPtr<class UFXSystemAsset>          TargetSystem;                                      // 0x0000(0x0038)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VFXWarmupTime;                                     // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UMaterialInterface>      TargetMaterial;                                    // 0x0040(0x0038)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, float>                      MaterialScalarParameters;                          // 0x0078(0x0050)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FScreenshotVFXCharmHookCharmData) == 0x000008, "Wrong alignment on FScreenshotVFXCharmHookCharmData");
static_assert(sizeof(FScreenshotVFXCharmHookCharmData) == 0x0000C8, "Wrong size on FScreenshotVFXCharmHookCharmData");
static_assert(offsetof(FScreenshotVFXCharmHookCharmData, TargetSystem) == 0x000000, "Member 'FScreenshotVFXCharmHookCharmData::TargetSystem' has a wrong offset!");
static_assert(offsetof(FScreenshotVFXCharmHookCharmData, VFXWarmupTime) == 0x000038, "Member 'FScreenshotVFXCharmHookCharmData::VFXWarmupTime' has a wrong offset!");
static_assert(offsetof(FScreenshotVFXCharmHookCharmData, TargetMaterial) == 0x000040, "Member 'FScreenshotVFXCharmHookCharmData::TargetMaterial' has a wrong offset!");
static_assert(offsetof(FScreenshotVFXCharmHookCharmData, MaterialScalarParameters) == 0x000078, "Member 'FScreenshotVFXCharmHookCharmData::MaterialScalarParameters' has a wrong offset!");

// ScriptStruct DeadByDaylight.CloudInventoryItem
// 0x0010 (0x0010 - 0x0000)
struct FCloudInventoryItem final
{
public:
	int32                                         DefinitionId;                                      // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	uint64                                        InstanceId;                                        // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCloudInventoryItem) == 0x000008, "Wrong alignment on FCloudInventoryItem");
static_assert(sizeof(FCloudInventoryItem) == 0x000010, "Wrong size on FCloudInventoryItem");
static_assert(offsetof(FCloudInventoryItem, DefinitionId) == 0x000000, "Member 'FCloudInventoryItem::DefinitionId' has a wrong offset!");
static_assert(offsetof(FCloudInventoryItem, InstanceId) == 0x000008, "Member 'FCloudInventoryItem::InstanceId' has a wrong offset!");

// ScriptStruct DeadByDaylight.GamePersistentData
// 0x0108 (0x0108 - 0x0000)
struct FGamePersistentData final
{
public:
	int32                                         PlayerCount;                                       // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SpectatorCount;                                    // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGamePresetData                        GamePresetData;                                    // 0x0008(0x0090)(NativeAccessSpecifierPublic)
	uint8                                         Pad_98[0x70];                                      // 0x0098(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGamePersistentData) == 0x000008, "Wrong alignment on FGamePersistentData");
static_assert(sizeof(FGamePersistentData) == 0x000108, "Wrong size on FGamePersistentData");
static_assert(offsetof(FGamePersistentData, PlayerCount) == 0x000000, "Member 'FGamePersistentData::PlayerCount' has a wrong offset!");
static_assert(offsetof(FGamePersistentData, SpectatorCount) == 0x000004, "Member 'FGamePersistentData::SpectatorCount' has a wrong offset!");
static_assert(offsetof(FGamePersistentData, GamePresetData) == 0x000008, "Member 'FGamePersistentData::GamePresetData' has a wrong offset!");

// ScriptStruct DeadByDaylight.StatusEffectSlotData
// 0x0048 (0x0048 - 0x0000)
struct FStatusEffectSlotData final
{
public:
	class FString                                 ID;                                                // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 IconFilePath;                                      // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DisplayName;                                       // 0x0020(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Description;                                       // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStatusEffectType                             StatusEffectType;                                  // 0x0040(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Level;                                             // 0x0044(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStatusEffectSlotData) == 0x000008, "Wrong alignment on FStatusEffectSlotData");
static_assert(sizeof(FStatusEffectSlotData) == 0x000048, "Wrong size on FStatusEffectSlotData");
static_assert(offsetof(FStatusEffectSlotData, ID) == 0x000000, "Member 'FStatusEffectSlotData::ID' has a wrong offset!");
static_assert(offsetof(FStatusEffectSlotData, IconFilePath) == 0x000010, "Member 'FStatusEffectSlotData::IconFilePath' has a wrong offset!");
static_assert(offsetof(FStatusEffectSlotData, DisplayName) == 0x000020, "Member 'FStatusEffectSlotData::DisplayName' has a wrong offset!");
static_assert(offsetof(FStatusEffectSlotData, Description) == 0x000030, "Member 'FStatusEffectSlotData::Description' has a wrong offset!");
static_assert(offsetof(FStatusEffectSlotData, StatusEffectType) == 0x000040, "Member 'FStatusEffectSlotData::StatusEffectType' has a wrong offset!");
static_assert(offsetof(FStatusEffectSlotData, Level) == 0x000044, "Member 'FStatusEffectSlotData::Level' has a wrong offset!");

// ScriptStruct DeadByDaylight.DBDCharacterMovementSpeedRTPC
// 0x0018 (0x0018 - 0x0000)
struct FDBDCharacterMovementSpeedRTPC final
{
public:
	class FString                                 RTPCName;                                          // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterpolationTime;                                 // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDBDCharacterMovementSpeedRTPC) == 0x000008, "Wrong alignment on FDBDCharacterMovementSpeedRTPC");
static_assert(sizeof(FDBDCharacterMovementSpeedRTPC) == 0x000018, "Wrong size on FDBDCharacterMovementSpeedRTPC");
static_assert(offsetof(FDBDCharacterMovementSpeedRTPC, RTPCName) == 0x000000, "Member 'FDBDCharacterMovementSpeedRTPC::RTPCName' has a wrong offset!");
static_assert(offsetof(FDBDCharacterMovementSpeedRTPC, InterpolationTime) == 0x000010, "Member 'FDBDCharacterMovementSpeedRTPC::InterpolationTime' has a wrong offset!");

// ScriptStruct DeadByDaylight.LookInputScalingData
// 0x0080 (0x0080 - 0x0000)
struct alignas(0x08) FLookInputScalingData final
{
public:
	uint8                                         Pad_0[0x80];                                       // 0x0000(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLookInputScalingData) == 0x000008, "Wrong alignment on FLookInputScalingData");
static_assert(sizeof(FLookInputScalingData) == 0x000080, "Wrong size on FLookInputScalingData");

// ScriptStruct DeadByDaylight.StoreRecommendationCustomizationItemsRuntimeData
// 0x0020 (0x0020 - 0x0000)
struct FStoreRecommendationCustomizationItemsRuntimeData final
{
public:
	class FString                                 Category;                                          // 0x0000(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ID;                                                // 0x0010(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStoreRecommendationCustomizationItemsRuntimeData) == 0x000008, "Wrong alignment on FStoreRecommendationCustomizationItemsRuntimeData");
static_assert(sizeof(FStoreRecommendationCustomizationItemsRuntimeData) == 0x000020, "Wrong size on FStoreRecommendationCustomizationItemsRuntimeData");
static_assert(offsetof(FStoreRecommendationCustomizationItemsRuntimeData, Category) == 0x000000, "Member 'FStoreRecommendationCustomizationItemsRuntimeData::Category' has a wrong offset!");
static_assert(offsetof(FStoreRecommendationCustomizationItemsRuntimeData, ID) == 0x000010, "Member 'FStoreRecommendationCustomizationItemsRuntimeData::ID' has a wrong offset!");

// ScriptStruct DeadByDaylight.StoreRecommendationCustomizationRuntimeData
// 0x0020 (0x0020 - 0x0000)
struct FStoreRecommendationCustomizationRuntimeData final
{
public:
	struct FDateTime                              ActiveFrom;                                        // 0x0000(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              ActiveTo;                                          // 0x0008(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FStoreRecommendationCustomizationItemsRuntimeData> Recommendations;                                   // 0x0010(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStoreRecommendationCustomizationRuntimeData) == 0x000008, "Wrong alignment on FStoreRecommendationCustomizationRuntimeData");
static_assert(sizeof(FStoreRecommendationCustomizationRuntimeData) == 0x000020, "Wrong size on FStoreRecommendationCustomizationRuntimeData");
static_assert(offsetof(FStoreRecommendationCustomizationRuntimeData, ActiveFrom) == 0x000000, "Member 'FStoreRecommendationCustomizationRuntimeData::ActiveFrom' has a wrong offset!");
static_assert(offsetof(FStoreRecommendationCustomizationRuntimeData, ActiveTo) == 0x000008, "Member 'FStoreRecommendationCustomizationRuntimeData::ActiveTo' has a wrong offset!");
static_assert(offsetof(FStoreRecommendationCustomizationRuntimeData, Recommendations) == 0x000010, "Member 'FStoreRecommendationCustomizationRuntimeData::Recommendations' has a wrong offset!");

// ScriptStruct DeadByDaylight.StoredInteraction
// 0x0090 (0x0090 - 0x0000)
struct FStoredInteraction final
{
public:
	TWeakObjectPtr<class UInteractionDefinition>  _interaction;                                      // 0x0000(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EInputInteractionType                         _inputType;                                        // 0x0008(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FInteractionPlayerProperties           _playerProperties;                                 // 0x0010(0x0078)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_88[0x8];                                       // 0x0088(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStoredInteraction) == 0x000008, "Wrong alignment on FStoredInteraction");
static_assert(sizeof(FStoredInteraction) == 0x000090, "Wrong size on FStoredInteraction");
static_assert(offsetof(FStoredInteraction, _interaction) == 0x000000, "Member 'FStoredInteraction::_interaction' has a wrong offset!");
static_assert(offsetof(FStoredInteraction, _inputType) == 0x000008, "Member 'FStoredInteraction::_inputType' has a wrong offset!");
static_assert(offsetof(FStoredInteraction, _playerProperties) == 0x000010, "Member 'FStoredInteraction::_playerProperties' has a wrong offset!");

// ScriptStruct DeadByDaylight.StoreSpecialPackRuntimeItem
// 0x0078 (0x0078 - 0x0000)
struct FStoreSpecialPackRuntimeItem final
{
public:
	bool                                          IsValid;                                           // 0x0000(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ID;                                                // 0x0008(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStoreSpecialPackItemType                     Type;                                              // 0x0018(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Amount;                                            // 0x001C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<ECurrencyType, uint32>                   OriginalCost;                                      // 0x0020(0x0050)(Transient, NativeAccessSpecifierPublic)
	bool                                          IsOwned;                                           // 0x0070(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IncludeInOwnership;                                // 0x0071(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IncludeInPricing;                                  // 0x0072(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasPriorityForPackImageComposition;                // 0x0073(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStoreSpecialPackRuntimeItem) == 0x000008, "Wrong alignment on FStoreSpecialPackRuntimeItem");
static_assert(sizeof(FStoreSpecialPackRuntimeItem) == 0x000078, "Wrong size on FStoreSpecialPackRuntimeItem");
static_assert(offsetof(FStoreSpecialPackRuntimeItem, IsValid) == 0x000000, "Member 'FStoreSpecialPackRuntimeItem::IsValid' has a wrong offset!");
static_assert(offsetof(FStoreSpecialPackRuntimeItem, ID) == 0x000008, "Member 'FStoreSpecialPackRuntimeItem::ID' has a wrong offset!");
static_assert(offsetof(FStoreSpecialPackRuntimeItem, Type) == 0x000018, "Member 'FStoreSpecialPackRuntimeItem::Type' has a wrong offset!");
static_assert(offsetof(FStoreSpecialPackRuntimeItem, Amount) == 0x00001C, "Member 'FStoreSpecialPackRuntimeItem::Amount' has a wrong offset!");
static_assert(offsetof(FStoreSpecialPackRuntimeItem, OriginalCost) == 0x000020, "Member 'FStoreSpecialPackRuntimeItem::OriginalCost' has a wrong offset!");
static_assert(offsetof(FStoreSpecialPackRuntimeItem, IsOwned) == 0x000070, "Member 'FStoreSpecialPackRuntimeItem::IsOwned' has a wrong offset!");
static_assert(offsetof(FStoreSpecialPackRuntimeItem, IncludeInOwnership) == 0x000071, "Member 'FStoreSpecialPackRuntimeItem::IncludeInOwnership' has a wrong offset!");
static_assert(offsetof(FStoreSpecialPackRuntimeItem, IncludeInPricing) == 0x000072, "Member 'FStoreSpecialPackRuntimeItem::IncludeInPricing' has a wrong offset!");
static_assert(offsetof(FStoreSpecialPackRuntimeItem, HasPriorityForPackImageComposition) == 0x000073, "Member 'FStoreSpecialPackRuntimeItem::HasPriorityForPackImageComposition' has a wrong offset!");

// ScriptStruct DeadByDaylight.StoreSpecialPackRuntimeData
// 0x0170 (0x0170 - 0x0000)
struct FStoreSpecialPackRuntimeData final
{
public:
	bool                                          IsValid;                                           // 0x0000(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ID;                                                // 0x0008(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FString, class FString>            TitleByCulture;                                    // 0x0018(0x0050)(Transient, NativeAccessSpecifierPublic)
	TArray<struct FStoreSpecialPackRuntimeItem>   Content;                                           // 0x0068(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TMap<ECurrencyType, uint32>                   OriginalCost;                                      // 0x0078(0x0050)(Transient, NativeAccessSpecifierPublic)
	TMap<ECurrencyType, uint32>                   DiscountedCost;                                    // 0x00C8(0x0050)(Transient, NativeAccessSpecifierPublic)
	double                                        Discount;                                          // 0x0118(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HiddenIfOwned;                                     // 0x0120(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_121[0x3];                                      // 0x0121(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MinNumberOfUnownedForPurchase;                     // 0x0124(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              StartDate;                                         // 0x0128(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              EndDate;                                           // 0x0130(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsOwned;                                           // 0x0138(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsNew;                                             // 0x0139(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13A[0x6];                                      // 0x013A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Image;                                             // 0x0140(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DLCId;                                             // 0x0150(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SortOrder;                                         // 0x0160(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ComposePackImage;                                  // 0x0164(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_165[0x3];                                      // 0x0165(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PackImageCompositionNumberOfItems;                 // 0x0168(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16C[0x4];                                      // 0x016C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStoreSpecialPackRuntimeData) == 0x000008, "Wrong alignment on FStoreSpecialPackRuntimeData");
static_assert(sizeof(FStoreSpecialPackRuntimeData) == 0x000170, "Wrong size on FStoreSpecialPackRuntimeData");
static_assert(offsetof(FStoreSpecialPackRuntimeData, IsValid) == 0x000000, "Member 'FStoreSpecialPackRuntimeData::IsValid' has a wrong offset!");
static_assert(offsetof(FStoreSpecialPackRuntimeData, ID) == 0x000008, "Member 'FStoreSpecialPackRuntimeData::ID' has a wrong offset!");
static_assert(offsetof(FStoreSpecialPackRuntimeData, TitleByCulture) == 0x000018, "Member 'FStoreSpecialPackRuntimeData::TitleByCulture' has a wrong offset!");
static_assert(offsetof(FStoreSpecialPackRuntimeData, Content) == 0x000068, "Member 'FStoreSpecialPackRuntimeData::Content' has a wrong offset!");
static_assert(offsetof(FStoreSpecialPackRuntimeData, OriginalCost) == 0x000078, "Member 'FStoreSpecialPackRuntimeData::OriginalCost' has a wrong offset!");
static_assert(offsetof(FStoreSpecialPackRuntimeData, DiscountedCost) == 0x0000C8, "Member 'FStoreSpecialPackRuntimeData::DiscountedCost' has a wrong offset!");
static_assert(offsetof(FStoreSpecialPackRuntimeData, Discount) == 0x000118, "Member 'FStoreSpecialPackRuntimeData::Discount' has a wrong offset!");
static_assert(offsetof(FStoreSpecialPackRuntimeData, HiddenIfOwned) == 0x000120, "Member 'FStoreSpecialPackRuntimeData::HiddenIfOwned' has a wrong offset!");
static_assert(offsetof(FStoreSpecialPackRuntimeData, MinNumberOfUnownedForPurchase) == 0x000124, "Member 'FStoreSpecialPackRuntimeData::MinNumberOfUnownedForPurchase' has a wrong offset!");
static_assert(offsetof(FStoreSpecialPackRuntimeData, StartDate) == 0x000128, "Member 'FStoreSpecialPackRuntimeData::StartDate' has a wrong offset!");
static_assert(offsetof(FStoreSpecialPackRuntimeData, EndDate) == 0x000130, "Member 'FStoreSpecialPackRuntimeData::EndDate' has a wrong offset!");
static_assert(offsetof(FStoreSpecialPackRuntimeData, IsOwned) == 0x000138, "Member 'FStoreSpecialPackRuntimeData::IsOwned' has a wrong offset!");
static_assert(offsetof(FStoreSpecialPackRuntimeData, IsNew) == 0x000139, "Member 'FStoreSpecialPackRuntimeData::IsNew' has a wrong offset!");
static_assert(offsetof(FStoreSpecialPackRuntimeData, Image) == 0x000140, "Member 'FStoreSpecialPackRuntimeData::Image' has a wrong offset!");
static_assert(offsetof(FStoreSpecialPackRuntimeData, DLCId) == 0x000150, "Member 'FStoreSpecialPackRuntimeData::DLCId' has a wrong offset!");
static_assert(offsetof(FStoreSpecialPackRuntimeData, SortOrder) == 0x000160, "Member 'FStoreSpecialPackRuntimeData::SortOrder' has a wrong offset!");
static_assert(offsetof(FStoreSpecialPackRuntimeData, ComposePackImage) == 0x000164, "Member 'FStoreSpecialPackRuntimeData::ComposePackImage' has a wrong offset!");
static_assert(offsetof(FStoreSpecialPackRuntimeData, PackImageCompositionNumberOfItems) == 0x000168, "Member 'FStoreSpecialPackRuntimeData::PackImageCompositionNumberOfItems' has a wrong offset!");

// ScriptStruct DeadByDaylight.StoreFeaturedRecommendationImageData
// 0x0010 (0x0010 - 0x0000)
struct FStoreFeaturedRecommendationImageData final
{
public:
	class FString                                 Path;                                              // 0x0000(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStoreFeaturedRecommendationImageData) == 0x000008, "Wrong alignment on FStoreFeaturedRecommendationImageData");
static_assert(sizeof(FStoreFeaturedRecommendationImageData) == 0x000010, "Wrong size on FStoreFeaturedRecommendationImageData");
static_assert(offsetof(FStoreFeaturedRecommendationImageData, Path) == 0x000000, "Member 'FStoreFeaturedRecommendationImageData::Path' has a wrong offset!");

// ScriptStruct DeadByDaylight.StoreFeaturedSingleCharacterRecommendationData
// 0x0018 (0x0018 - 0x0000)
struct FStoreFeaturedSingleCharacterRecommendationData final
{
public:
	int32                                         CharacterIndex;                                    // 0x0000(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FStoreFeaturedRecommendationImageData  Image;                                             // 0x0008(0x0010)(Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStoreFeaturedSingleCharacterRecommendationData) == 0x000008, "Wrong alignment on FStoreFeaturedSingleCharacterRecommendationData");
static_assert(sizeof(FStoreFeaturedSingleCharacterRecommendationData) == 0x000018, "Wrong size on FStoreFeaturedSingleCharacterRecommendationData");
static_assert(offsetof(FStoreFeaturedSingleCharacterRecommendationData, CharacterIndex) == 0x000000, "Member 'FStoreFeaturedSingleCharacterRecommendationData::CharacterIndex' has a wrong offset!");
static_assert(offsetof(FStoreFeaturedSingleCharacterRecommendationData, Image) == 0x000008, "Member 'FStoreFeaturedSingleCharacterRecommendationData::Image' has a wrong offset!");

// ScriptStruct DeadByDaylight.PlayerStateData
// 0x0068 (0x0068 - 0x0000)
struct FPlayerStateData final
{
public:
	int32                                         CharacterLevel;                                    // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EquipedFavorId;                                    // 0x0004(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           EquipedPerkIds;                                    // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 EquipedPerkLevels;                                 // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 EquippedBannerId;                                  // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 EquippedBadgeId;                                   // 0x0040(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EquippedCharacterClass;                            // 0x0050(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGameState                                    _playerGameState;                                  // 0x005C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5D[0x3];                                       // 0x005D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _prestigeLevel;                                    // 0x0060(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerStateData) == 0x000008, "Wrong alignment on FPlayerStateData");
static_assert(sizeof(FPlayerStateData) == 0x000068, "Wrong size on FPlayerStateData");
static_assert(offsetof(FPlayerStateData, CharacterLevel) == 0x000000, "Member 'FPlayerStateData::CharacterLevel' has a wrong offset!");
static_assert(offsetof(FPlayerStateData, EquipedFavorId) == 0x000004, "Member 'FPlayerStateData::EquipedFavorId' has a wrong offset!");
static_assert(offsetof(FPlayerStateData, EquipedPerkIds) == 0x000010, "Member 'FPlayerStateData::EquipedPerkIds' has a wrong offset!");
static_assert(offsetof(FPlayerStateData, EquipedPerkLevels) == 0x000020, "Member 'FPlayerStateData::EquipedPerkLevels' has a wrong offset!");
static_assert(offsetof(FPlayerStateData, EquippedBannerId) == 0x000030, "Member 'FPlayerStateData::EquippedBannerId' has a wrong offset!");
static_assert(offsetof(FPlayerStateData, EquippedBadgeId) == 0x000040, "Member 'FPlayerStateData::EquippedBadgeId' has a wrong offset!");
static_assert(offsetof(FPlayerStateData, EquippedCharacterClass) == 0x000050, "Member 'FPlayerStateData::EquippedCharacterClass' has a wrong offset!");
static_assert(offsetof(FPlayerStateData, _playerGameState) == 0x00005C, "Member 'FPlayerStateData::_playerGameState' has a wrong offset!");
static_assert(offsetof(FPlayerStateData, _prestigeLevel) == 0x000060, "Member 'FPlayerStateData::_prestigeLevel' has a wrong offset!");

// ScriptStruct DeadByDaylight.PlayerDataSync
// 0x00C0 (0x00C0 - 0x0000)
struct FPlayerDataSync final
{
public:
	struct FPlayerStateData                       PlayerData;                                        // 0x0000(0x0068)(NativeAccessSpecifierPublic)
	struct FEquippedPlayerCustomization           EquippedCustomization;                             // 0x0068(0x0038)(NativeAccessSpecifierPublic)
	class FName                                   EquipedItemId;                                     // 0x00A0(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           EquipedItemAddonIds;                               // 0x00B0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerDataSync) == 0x000008, "Wrong alignment on FPlayerDataSync");
static_assert(sizeof(FPlayerDataSync) == 0x0000C0, "Wrong size on FPlayerDataSync");
static_assert(offsetof(FPlayerDataSync, PlayerData) == 0x000000, "Member 'FPlayerDataSync::PlayerData' has a wrong offset!");
static_assert(offsetof(FPlayerDataSync, EquippedCustomization) == 0x000068, "Member 'FPlayerDataSync::EquippedCustomization' has a wrong offset!");
static_assert(offsetof(FPlayerDataSync, EquipedItemId) == 0x0000A0, "Member 'FPlayerDataSync::EquipedItemId' has a wrong offset!");
static_assert(offsetof(FPlayerDataSync, EquipedItemAddonIds) == 0x0000B0, "Member 'FPlayerDataSync::EquipedItemAddonIds' has a wrong offset!");

// ScriptStruct DeadByDaylight.MenuCharacterUIData
// 0x0038 (0x0040 - 0x0008)
struct FMenuCharacterUIData final : public FDBDTableRowBase
{
public:
	int32                                         CharacterIndex;                                    // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                OffsetMainMenuForwardPosition;                     // 0x0010(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OffsetMainMenuBackwardPosition;                    // 0x0028(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMenuCharacterUIData) == 0x000008, "Wrong alignment on FMenuCharacterUIData");
static_assert(sizeof(FMenuCharacterUIData) == 0x000040, "Wrong size on FMenuCharacterUIData");
static_assert(offsetof(FMenuCharacterUIData, CharacterIndex) == 0x000008, "Member 'FMenuCharacterUIData::CharacterIndex' has a wrong offset!");
static_assert(offsetof(FMenuCharacterUIData, OffsetMainMenuForwardPosition) == 0x000010, "Member 'FMenuCharacterUIData::OffsetMainMenuForwardPosition' has a wrong offset!");
static_assert(offsetof(FMenuCharacterUIData, OffsetMainMenuBackwardPosition) == 0x000028, "Member 'FMenuCharacterUIData::OffsetMainMenuBackwardPosition' has a wrong offset!");

// ScriptStruct DeadByDaylight.CharacterStateData
// 0x0020 (0x0020 - 0x0000)
struct FCharacterStateData final
{
public:
	int32                                         _pips;                                             // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   _powerId;                                          // 0x0004(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class FName>                           _addonIds;                                         // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FCharacterStateData) == 0x000008, "Wrong alignment on FCharacterStateData");
static_assert(sizeof(FCharacterStateData) == 0x000020, "Wrong size on FCharacterStateData");
static_assert(offsetof(FCharacterStateData, _pips) == 0x000000, "Member 'FCharacterStateData::_pips' has a wrong offset!");
static_assert(offsetof(FCharacterStateData, _powerId) == 0x000004, "Member 'FCharacterStateData::_powerId' has a wrong offset!");
static_assert(offsetof(FCharacterStateData, _addonIds) == 0x000010, "Member 'FCharacterStateData::_addonIds' has a wrong offset!");

// ScriptStruct DeadByDaylight.DBDBotStateInfo
// 0x0020 (0x0020 - 0x0000)
struct FDBDBotStateInfo final
{
public:
	class FText                                   Name;                                              // 0x0000(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         Index;                                             // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsReplacement;                                     // 0x001C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBotReplacementState                          LocalReplacementState;                             // 0x001D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E[0x2];                                       // 0x001E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDBDBotStateInfo) == 0x000008, "Wrong alignment on FDBDBotStateInfo");
static_assert(sizeof(FDBDBotStateInfo) == 0x000020, "Wrong size on FDBDBotStateInfo");
static_assert(offsetof(FDBDBotStateInfo, Name) == 0x000000, "Member 'FDBDBotStateInfo::Name' has a wrong offset!");
static_assert(offsetof(FDBDBotStateInfo, Index) == 0x000018, "Member 'FDBDBotStateInfo::Index' has a wrong offset!");
static_assert(offsetof(FDBDBotStateInfo, IsReplacement) == 0x00001C, "Member 'FDBDBotStateInfo::IsReplacement' has a wrong offset!");
static_assert(offsetof(FDBDBotStateInfo, LocalReplacementState) == 0x00001D, "Member 'FDBDBotStateInfo::LocalReplacementState' has a wrong offset!");

// ScriptStruct DeadByDaylight.PlayerHUDInfos
// 0x0030 (0x0038 - 0x0008)
struct FPlayerHUDInfos final : public FDBDTableRowBase
{
public:
	EPlayerRole                                   Role;                                              // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        TouchInterfaceName;                                // 0x0010(0x0028)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerHUDInfos) == 0x000008, "Wrong alignment on FPlayerHUDInfos");
static_assert(sizeof(FPlayerHUDInfos) == 0x000038, "Wrong size on FPlayerHUDInfos");
static_assert(offsetof(FPlayerHUDInfos, Role) == 0x000008, "Member 'FPlayerHUDInfos::Role' has a wrong offset!");
static_assert(offsetof(FPlayerHUDInfos, TouchInterfaceName) == 0x000010, "Member 'FPlayerHUDInfos::TouchInterfaceName' has a wrong offset!");

// ScriptStruct DeadByDaylight.OutfitData
// 0x0220 (0x0228 - 0x0008)
struct FOutfitData final : public FDBDTableRowBase
{
public:
	class FName                                   ID;                                                // 0x0008(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FItemUIData                            UIData;                                            // 0x0018(0x0138)(Edit, NativeAccessSpecifierPublic)
	struct FItemAvailability                      Availability;                                      // 0x0150(0x0048)(Edit, NativeAccessSpecifierPublic)
	TArray<class FName>                           OutfitItems;                                       // 0x0198(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class FText                                   CollectionName;                                    // 0x01A8(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   CollectionDescription;                             // 0x01C0(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FString                                 InclusionVersion;                                  // 0x01D8(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FText>                           SearchTags;                                        // 0x01E8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint32                                        PlatformExclusiveFlag;                             // 0x01F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CustomizedAudioStateCollection;                    // 0x01FC(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 _outfitId;                                         // 0x0208(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_218[0x10];                                     // 0x0218(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOutfitData) == 0x000008, "Wrong alignment on FOutfitData");
static_assert(sizeof(FOutfitData) == 0x000228, "Wrong size on FOutfitData");
static_assert(offsetof(FOutfitData, ID) == 0x000008, "Member 'FOutfitData::ID' has a wrong offset!");
static_assert(offsetof(FOutfitData, UIData) == 0x000018, "Member 'FOutfitData::UIData' has a wrong offset!");
static_assert(offsetof(FOutfitData, Availability) == 0x000150, "Member 'FOutfitData::Availability' has a wrong offset!");
static_assert(offsetof(FOutfitData, OutfitItems) == 0x000198, "Member 'FOutfitData::OutfitItems' has a wrong offset!");
static_assert(offsetof(FOutfitData, CollectionName) == 0x0001A8, "Member 'FOutfitData::CollectionName' has a wrong offset!");
static_assert(offsetof(FOutfitData, CollectionDescription) == 0x0001C0, "Member 'FOutfitData::CollectionDescription' has a wrong offset!");
static_assert(offsetof(FOutfitData, InclusionVersion) == 0x0001D8, "Member 'FOutfitData::InclusionVersion' has a wrong offset!");
static_assert(offsetof(FOutfitData, SearchTags) == 0x0001E8, "Member 'FOutfitData::SearchTags' has a wrong offset!");
static_assert(offsetof(FOutfitData, PlatformExclusiveFlag) == 0x0001F8, "Member 'FOutfitData::PlatformExclusiveFlag' has a wrong offset!");
static_assert(offsetof(FOutfitData, CustomizedAudioStateCollection) == 0x0001FC, "Member 'FOutfitData::CustomizedAudioStateCollection' has a wrong offset!");
static_assert(offsetof(FOutfitData, _outfitId) == 0x000208, "Member 'FOutfitData::_outfitId' has a wrong offset!");

// ScriptStruct DeadByDaylight.RankDefinition
// 0x0004 (0x0004 - 0x0000)
struct FRankDefinition final
{
public:
	int32                                         PipsRequired;                                      // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRankDefinition) == 0x000004, "Wrong alignment on FRankDefinition");
static_assert(sizeof(FRankDefinition) == 0x000004, "Wrong size on FRankDefinition");
static_assert(offsetof(FRankDefinition, PipsRequired) == 0x000000, "Member 'FRankDefinition::PipsRequired' has a wrong offset!");

// ScriptStruct DeadByDaylight.RankGroupDefinition
// 0x0018 (0x0018 - 0x0000)
struct FRankGroupDefinition final
{
public:
	int32                                         RankThreshold;                                     // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 PipThresholds;                                     // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Config, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRankGroupDefinition) == 0x000008, "Wrong alignment on FRankGroupDefinition");
static_assert(sizeof(FRankGroupDefinition) == 0x000018, "Wrong size on FRankGroupDefinition");
static_assert(offsetof(FRankGroupDefinition, RankThreshold) == 0x000000, "Member 'FRankGroupDefinition::RankThreshold' has a wrong offset!");
static_assert(offsetof(FRankGroupDefinition, PipThresholds) == 0x000008, "Member 'FRankGroupDefinition::PipThresholds' has a wrong offset!");

// ScriptStruct DeadByDaylight.RankResetStartingPips
// 0x0004 (0x0004 - 0x0000)
struct FRankResetStartingPips final
{
public:
	int32                                         NewPipAmount;                                      // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRankResetStartingPips) == 0x000004, "Wrong alignment on FRankResetStartingPips");
static_assert(sizeof(FRankResetStartingPips) == 0x000004, "Wrong size on FRankResetStartingPips");
static_assert(offsetof(FRankResetStartingPips, NewPipAmount) == 0x000000, "Member 'FRankResetStartingPips::NewPipAmount' has a wrong offset!");

// ScriptStruct DeadByDaylight.CharacterSavedInventoryDataV7
// 0x0020 (0x0020 - 0x0000)
struct FCharacterSavedInventoryDataV7 final
{
public:
	class FName                                   ID;                                                // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Num;                                               // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 I;                                                 // 0x0010(0x0010)(ZeroConstructor, SaveGame, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterSavedInventoryDataV7) == 0x000008, "Wrong alignment on FCharacterSavedInventoryDataV7");
static_assert(sizeof(FCharacterSavedInventoryDataV7) == 0x000020, "Wrong size on FCharacterSavedInventoryDataV7");
static_assert(offsetof(FCharacterSavedInventoryDataV7, ID) == 0x000000, "Member 'FCharacterSavedInventoryDataV7::ID' has a wrong offset!");
static_assert(offsetof(FCharacterSavedInventoryDataV7, Num) == 0x00000C, "Member 'FCharacterSavedInventoryDataV7::Num' has a wrong offset!");
static_assert(offsetof(FCharacterSavedInventoryDataV7, I) == 0x000010, "Member 'FCharacterSavedInventoryDataV7::I' has a wrong offset!");

// ScriptStruct DeadByDaylight.AssignedPerkPropertiesV7
// 0x0014 (0x0014 - 0x0000)
struct FAssignedPerkPropertiesV7 final
{
public:
	class FName                                   PerkId;                                            // 0x0000(0x000C)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PerkLevel;                                         // 0x000C(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsTeachable;                                       // 0x0010(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAssignedPerkPropertiesV7) == 0x000004, "Wrong alignment on FAssignedPerkPropertiesV7");
static_assert(sizeof(FAssignedPerkPropertiesV7) == 0x000014, "Wrong size on FAssignedPerkPropertiesV7");
static_assert(offsetof(FAssignedPerkPropertiesV7, PerkId) == 0x000000, "Member 'FAssignedPerkPropertiesV7::PerkId' has a wrong offset!");
static_assert(offsetof(FAssignedPerkPropertiesV7, PerkLevel) == 0x00000C, "Member 'FAssignedPerkPropertiesV7::PerkLevel' has a wrong offset!");
static_assert(offsetof(FAssignedPerkPropertiesV7, IsTeachable) == 0x000010, "Member 'FAssignedPerkPropertiesV7::IsTeachable' has a wrong offset!");

// ScriptStruct DeadByDaylight.MysteryBoxClaimedReward
// 0x0020 (0x0020 - 0x0000)
struct FMysteryBoxClaimedReward final
{
public:
	class FString                                 ID;                                                // 0x0000(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERewardType                                   Type;                                              // 0x0010(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECurrencyType                                 Currency;                                          // 0x0011(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Currency_IsSet;                                    // 0x0012(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EProgressionType                              Progression;                                       // 0x0013(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Progression_IsSet;                                 // 0x0014(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Amount;                                            // 0x0018(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Amount_IsSet;                                      // 0x001C(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMysteryBoxClaimedReward) == 0x000008, "Wrong alignment on FMysteryBoxClaimedReward");
static_assert(sizeof(FMysteryBoxClaimedReward) == 0x000020, "Wrong size on FMysteryBoxClaimedReward");
static_assert(offsetof(FMysteryBoxClaimedReward, ID) == 0x000000, "Member 'FMysteryBoxClaimedReward::ID' has a wrong offset!");
static_assert(offsetof(FMysteryBoxClaimedReward, Type) == 0x000010, "Member 'FMysteryBoxClaimedReward::Type' has a wrong offset!");
static_assert(offsetof(FMysteryBoxClaimedReward, Currency) == 0x000011, "Member 'FMysteryBoxClaimedReward::Currency' has a wrong offset!");
static_assert(offsetof(FMysteryBoxClaimedReward, Currency_IsSet) == 0x000012, "Member 'FMysteryBoxClaimedReward::Currency_IsSet' has a wrong offset!");
static_assert(offsetof(FMysteryBoxClaimedReward, Progression) == 0x000013, "Member 'FMysteryBoxClaimedReward::Progression' has a wrong offset!");
static_assert(offsetof(FMysteryBoxClaimedReward, Progression_IsSet) == 0x000014, "Member 'FMysteryBoxClaimedReward::Progression_IsSet' has a wrong offset!");
static_assert(offsetof(FMysteryBoxClaimedReward, Amount) == 0x000018, "Member 'FMysteryBoxClaimedReward::Amount' has a wrong offset!");
static_assert(offsetof(FMysteryBoxClaimedReward, Amount_IsSet) == 0x00001C, "Member 'FMysteryBoxClaimedReward::Amount_IsSet' has a wrong offset!");

// ScriptStruct DeadByDaylight.SavedCharacterLevelDataV7
// 0x0018 (0x0018 - 0x0000)
struct FSavedCharacterLevelDataV7 final
{
public:
	int32                                         Level;                                             // 0x0000(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasPerksBeenSelected;                              // 0x0004(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasPerkSelectionBeenGenerated;                     // 0x0005(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAssignedPerkPropertiesV7>      PerkSelection;                                     // 0x0008(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSavedCharacterLevelDataV7) == 0x000008, "Wrong alignment on FSavedCharacterLevelDataV7");
static_assert(sizeof(FSavedCharacterLevelDataV7) == 0x000018, "Wrong size on FSavedCharacterLevelDataV7");
static_assert(offsetof(FSavedCharacterLevelDataV7, Level) == 0x000000, "Member 'FSavedCharacterLevelDataV7::Level' has a wrong offset!");
static_assert(offsetof(FSavedCharacterLevelDataV7, HasPerksBeenSelected) == 0x000004, "Member 'FSavedCharacterLevelDataV7::HasPerksBeenSelected' has a wrong offset!");
static_assert(offsetof(FSavedCharacterLevelDataV7, HasPerkSelectionBeenGenerated) == 0x000005, "Member 'FSavedCharacterLevelDataV7::HasPerkSelectionBeenGenerated' has a wrong offset!");
static_assert(offsetof(FSavedCharacterLevelDataV7, PerkSelection) == 0x000008, "Member 'FSavedCharacterLevelDataV7::PerkSelection' has a wrong offset!");

// ScriptStruct DeadByDaylight.LoadingInfoData
// 0x0070 (0x0070 - 0x0000)
struct FLoadingInfoData final
{
public:
	class FText                                   Title;                                             // 0x0000(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0018(0x0018)(Edit, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              Icon;                                              // 0x0030(0x0038)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsAvailableForKiller;                              // 0x0068(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsAvailableForSurvivor;                            // 0x0069(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6A[0x6];                                       // 0x006A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLoadingInfoData) == 0x000008, "Wrong alignment on FLoadingInfoData");
static_assert(sizeof(FLoadingInfoData) == 0x000070, "Wrong size on FLoadingInfoData");
static_assert(offsetof(FLoadingInfoData, Title) == 0x000000, "Member 'FLoadingInfoData::Title' has a wrong offset!");
static_assert(offsetof(FLoadingInfoData, Description) == 0x000018, "Member 'FLoadingInfoData::Description' has a wrong offset!");
static_assert(offsetof(FLoadingInfoData, Icon) == 0x000030, "Member 'FLoadingInfoData::Icon' has a wrong offset!");
static_assert(offsetof(FLoadingInfoData, IsAvailableForKiller) == 0x000068, "Member 'FLoadingInfoData::IsAvailableForKiller' has a wrong offset!");
static_assert(offsetof(FLoadingInfoData, IsAvailableForSurvivor) == 0x000069, "Member 'FLoadingInfoData::IsAvailableForSurvivor' has a wrong offset!");

// ScriptStruct DeadByDaylight.SavedStatsDataV7
// 0x0010 (0x0010 - 0x0000)
struct FSavedStatsDataV7 final
{
public:
	class FName                                   Name;                                              // 0x0000(0x000C)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x000C(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSavedStatsDataV7) == 0x000004, "Wrong alignment on FSavedStatsDataV7");
static_assert(sizeof(FSavedStatsDataV7) == 0x000010, "Wrong size on FSavedStatsDataV7");
static_assert(offsetof(FSavedStatsDataV7, Name) == 0x000000, "Member 'FSavedStatsDataV7::Name' has a wrong offset!");
static_assert(offsetof(FSavedStatsDataV7, Value) == 0x00000C, "Member 'FSavedStatsDataV7::Value' has a wrong offset!");

// ScriptStruct DeadByDaylight.SavedCharmSlotData
// 0x0010 (0x0010 - 0x0000)
struct FSavedCharmSlotData final
{
public:
	int8                                          SlotIndex;                                         // 0x0000(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CharmId;                                           // 0x0004(0x000C)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSavedCharmSlotData) == 0x000004, "Wrong alignment on FSavedCharmSlotData");
static_assert(sizeof(FSavedCharmSlotData) == 0x000010, "Wrong size on FSavedCharmSlotData");
static_assert(offsetof(FSavedCharmSlotData, SlotIndex) == 0x000000, "Member 'FSavedCharmSlotData::SlotIndex' has a wrong offset!");
static_assert(offsetof(FSavedCharmSlotData, CharmId) == 0x000004, "Member 'FSavedCharmSlotData::CharmId' has a wrong offset!");

// ScriptStruct DeadByDaylight.PerspectiveEffectData
// 0x001C (0x001C - 0x0000)
struct FPerspectiveEffectData final
{
public:
	bool                                          WantsActive;                                       // 0x0000(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void(bool IsActive)>                ActivationEvent;                                   // 0x0004(0x0014)(BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPerspectiveActivationCondition               Condition;                                         // 0x0018(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPerspectiveEffectData) == 0x000004, "Wrong alignment on FPerspectiveEffectData");
static_assert(sizeof(FPerspectiveEffectData) == 0x00001C, "Wrong size on FPerspectiveEffectData");
static_assert(offsetof(FPerspectiveEffectData, WantsActive) == 0x000000, "Member 'FPerspectiveEffectData::WantsActive' has a wrong offset!");
static_assert(offsetof(FPerspectiveEffectData, ActivationEvent) == 0x000004, "Member 'FPerspectiveEffectData::ActivationEvent' has a wrong offset!");
static_assert(offsetof(FPerspectiveEffectData, Condition) == 0x000018, "Member 'FPerspectiveEffectData::Condition' has a wrong offset!");

// ScriptStruct DeadByDaylight.CharacterSavedProfileDataV7
// 0x0170 (0x0170 - 0x0000)
struct FCharacterSavedProfileDataV7 final
{
public:
	int32                                         BloodWebLevel;                                     // 0x0000(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PrestigeLevel;                                     // 0x0004(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CharacterExperience;                               // 0x0008(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TimesConfronted;                                   // 0x000C(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         PrestigeDates;                                     // 0x0010(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	struct FLegacySavedBloodWebPersistentData     BloodWebData;                                      // 0x0020(0x0040)(SaveGame, NativeAccessSpecifierPublic)
	struct FLegacySavedPlayerLoadoutData          CharacterLoadoutData;                              // 0x0060(0x00B0)(SaveGame, NativeAccessSpecifierPublic)
	TArray<struct FCharacterSavedInventoryDataV7> Inventory;                                         // 0x0110(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	TArray<struct FSavedCharacterLevelDataV7>     CharacterProgression;                              // 0x0120(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	TArray<struct FSavedStatsDataV7>              StatProgression;                                   // 0x0130(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	TArray<class FName>                           CurrentCustomization;                              // 0x0140(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	TArray<struct FSavedCharmSlotData>            CurrentCharmCustomization;                         // 0x0150(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	TArray<class FName>                           UniquePerksAdded;                                  // 0x0160(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterSavedProfileDataV7) == 0x000008, "Wrong alignment on FCharacterSavedProfileDataV7");
static_assert(sizeof(FCharacterSavedProfileDataV7) == 0x000170, "Wrong size on FCharacterSavedProfileDataV7");
static_assert(offsetof(FCharacterSavedProfileDataV7, BloodWebLevel) == 0x000000, "Member 'FCharacterSavedProfileDataV7::BloodWebLevel' has a wrong offset!");
static_assert(offsetof(FCharacterSavedProfileDataV7, PrestigeLevel) == 0x000004, "Member 'FCharacterSavedProfileDataV7::PrestigeLevel' has a wrong offset!");
static_assert(offsetof(FCharacterSavedProfileDataV7, CharacterExperience) == 0x000008, "Member 'FCharacterSavedProfileDataV7::CharacterExperience' has a wrong offset!");
static_assert(offsetof(FCharacterSavedProfileDataV7, TimesConfronted) == 0x00000C, "Member 'FCharacterSavedProfileDataV7::TimesConfronted' has a wrong offset!");
static_assert(offsetof(FCharacterSavedProfileDataV7, PrestigeDates) == 0x000010, "Member 'FCharacterSavedProfileDataV7::PrestigeDates' has a wrong offset!");
static_assert(offsetof(FCharacterSavedProfileDataV7, BloodWebData) == 0x000020, "Member 'FCharacterSavedProfileDataV7::BloodWebData' has a wrong offset!");
static_assert(offsetof(FCharacterSavedProfileDataV7, CharacterLoadoutData) == 0x000060, "Member 'FCharacterSavedProfileDataV7::CharacterLoadoutData' has a wrong offset!");
static_assert(offsetof(FCharacterSavedProfileDataV7, Inventory) == 0x000110, "Member 'FCharacterSavedProfileDataV7::Inventory' has a wrong offset!");
static_assert(offsetof(FCharacterSavedProfileDataV7, CharacterProgression) == 0x000120, "Member 'FCharacterSavedProfileDataV7::CharacterProgression' has a wrong offset!");
static_assert(offsetof(FCharacterSavedProfileDataV7, StatProgression) == 0x000130, "Member 'FCharacterSavedProfileDataV7::StatProgression' has a wrong offset!");
static_assert(offsetof(FCharacterSavedProfileDataV7, CurrentCustomization) == 0x000140, "Member 'FCharacterSavedProfileDataV7::CurrentCustomization' has a wrong offset!");
static_assert(offsetof(FCharacterSavedProfileDataV7, CurrentCharmCustomization) == 0x000150, "Member 'FCharacterSavedProfileDataV7::CurrentCharmCustomization' has a wrong offset!");
static_assert(offsetof(FCharacterSavedProfileDataV7, UniquePerksAdded) == 0x000160, "Member 'FCharacterSavedProfileDataV7::UniquePerksAdded' has a wrong offset!");

// ScriptStruct DeadByDaylight.KeyTupleBool
// 0x0010 (0x0010 - 0x0000)
struct FKeyTupleBool final
{
public:
	class FName                                   Key;                                               // 0x0000(0x000C)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Value;                                             // 0x000C(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FKeyTupleBool) == 0x000004, "Wrong alignment on FKeyTupleBool");
static_assert(sizeof(FKeyTupleBool) == 0x000010, "Wrong size on FKeyTupleBool");
static_assert(offsetof(FKeyTupleBool, Key) == 0x000000, "Member 'FKeyTupleBool::Key' has a wrong offset!");
static_assert(offsetof(FKeyTupleBool, Value) == 0x00000C, "Member 'FKeyTupleBool::Value' has a wrong offset!");

// ScriptStruct DeadByDaylight.CharacterKeyTuple
// 0x0178 (0x0178 - 0x0000)
struct FCharacterKeyTuple final
{
public:
	int32                                         Key;                                               // 0x0000(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCharacterSavedProfileDataV7           Data;                                              // 0x0008(0x0170)(SaveGame, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterKeyTuple) == 0x000008, "Wrong alignment on FCharacterKeyTuple");
static_assert(sizeof(FCharacterKeyTuple) == 0x000178, "Wrong size on FCharacterKeyTuple");
static_assert(offsetof(FCharacterKeyTuple, Key) == 0x000000, "Member 'FCharacterKeyTuple::Key' has a wrong offset!");
static_assert(offsetof(FCharacterKeyTuple, Data) == 0x000008, "Member 'FCharacterKeyTuple::Data' has a wrong offset!");

// ScriptStruct DeadByDaylight.RankUIData
// 0x0058 (0x0060 - 0x0008)
struct FRankUIData final : public FDBDTableRowBase
{
public:
	int32                                         Rank;                                              // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerRole                                   PlayerRole;                                        // 0x000C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateColor                            Color;                                             // 0x0010(0x0014)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UTexture2D>              Frame;                                             // 0x0028(0x0038)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRankUIData) == 0x000008, "Wrong alignment on FRankUIData");
static_assert(sizeof(FRankUIData) == 0x000060, "Wrong size on FRankUIData");
static_assert(offsetof(FRankUIData, Rank) == 0x000008, "Member 'FRankUIData::Rank' has a wrong offset!");
static_assert(offsetof(FRankUIData, PlayerRole) == 0x00000C, "Member 'FRankUIData::PlayerRole' has a wrong offset!");
static_assert(offsetof(FRankUIData, Color) == 0x000010, "Member 'FRankUIData::Color' has a wrong offset!");
static_assert(offsetof(FRankUIData, Frame) == 0x000028, "Member 'FRankUIData::Frame' has a wrong offset!");

// ScriptStruct DeadByDaylight.SavedFearMarketOfferingInstanceV7
// 0x0030 (0x0030 - 0x0000)
struct FSavedFearMarketOfferingInstanceV7 final
{
public:
	TArray<struct FLegacySavedFearMarketItemInstance> ObjectsForSale;                                    // 0x0000(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	class FString                                 Starttime;                                         // 0x0010(0x0010)(ZeroConstructor, SaveGame, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 EndTime;                                           // 0x0020(0x0010)(ZeroConstructor, SaveGame, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSavedFearMarketOfferingInstanceV7) == 0x000008, "Wrong alignment on FSavedFearMarketOfferingInstanceV7");
static_assert(sizeof(FSavedFearMarketOfferingInstanceV7) == 0x000030, "Wrong size on FSavedFearMarketOfferingInstanceV7");
static_assert(offsetof(FSavedFearMarketOfferingInstanceV7, ObjectsForSale) == 0x000000, "Member 'FSavedFearMarketOfferingInstanceV7::ObjectsForSale' has a wrong offset!");
static_assert(offsetof(FSavedFearMarketOfferingInstanceV7, Starttime) == 0x000010, "Member 'FSavedFearMarketOfferingInstanceV7::Starttime' has a wrong offset!");
static_assert(offsetof(FSavedFearMarketOfferingInstanceV7, EndTime) == 0x000020, "Member 'FSavedFearMarketOfferingInstanceV7::EndTime' has a wrong offset!");

// ScriptStruct DeadByDaylight.SavedSpecialEventDataV7
// 0x0028 (0x0028 - 0x0000)
struct FSavedSpecialEventDataV7 final
{
public:
	class FName                                   EventID;                                           // 0x0000(0x000C)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 SeenCinematics;                                    // 0x0010(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	bool                                          EventEntryScreenOpened;                            // 0x0020(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSavedSpecialEventDataV7) == 0x000008, "Wrong alignment on FSavedSpecialEventDataV7");
static_assert(sizeof(FSavedSpecialEventDataV7) == 0x000028, "Wrong size on FSavedSpecialEventDataV7");
static_assert(offsetof(FSavedSpecialEventDataV7, EventID) == 0x000000, "Member 'FSavedSpecialEventDataV7::EventID' has a wrong offset!");
static_assert(offsetof(FSavedSpecialEventDataV7, SeenCinematics) == 0x000010, "Member 'FSavedSpecialEventDataV7::SeenCinematics' has a wrong offset!");
static_assert(offsetof(FSavedSpecialEventDataV7, EventEntryScreenOpened) == 0x000020, "Member 'FSavedSpecialEventDataV7::EventEntryScreenOpened' has a wrong offset!");

// ScriptStruct DeadByDaylight.CustomLockerOutlineOverride
// 0x0050 (0x0050 - 0x0000)
struct FCustomLockerOutlineOverride final
{
public:
	int32                                         Priority;                                          // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameplayTag>                   LockerStateTags;                                   // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FGameplayTag>                   PlayerStateTags;                                   // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FGameplayTag>                   PlayerPerkFlags;                                   // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FLinearColor                           OutlineColor;                                      // 0x0038(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsAlwaysVisible;                                   // 0x0048(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          FadeOutAsClosingIn;                                // 0x0049(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A[0x6];                                       // 0x004A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCustomLockerOutlineOverride) == 0x000008, "Wrong alignment on FCustomLockerOutlineOverride");
static_assert(sizeof(FCustomLockerOutlineOverride) == 0x000050, "Wrong size on FCustomLockerOutlineOverride");
static_assert(offsetof(FCustomLockerOutlineOverride, Priority) == 0x000000, "Member 'FCustomLockerOutlineOverride::Priority' has a wrong offset!");
static_assert(offsetof(FCustomLockerOutlineOverride, LockerStateTags) == 0x000008, "Member 'FCustomLockerOutlineOverride::LockerStateTags' has a wrong offset!");
static_assert(offsetof(FCustomLockerOutlineOverride, PlayerStateTags) == 0x000018, "Member 'FCustomLockerOutlineOverride::PlayerStateTags' has a wrong offset!");
static_assert(offsetof(FCustomLockerOutlineOverride, PlayerPerkFlags) == 0x000028, "Member 'FCustomLockerOutlineOverride::PlayerPerkFlags' has a wrong offset!");
static_assert(offsetof(FCustomLockerOutlineOverride, OutlineColor) == 0x000038, "Member 'FCustomLockerOutlineOverride::OutlineColor' has a wrong offset!");
static_assert(offsetof(FCustomLockerOutlineOverride, IsAlwaysVisible) == 0x000048, "Member 'FCustomLockerOutlineOverride::IsAlwaysVisible' has a wrong offset!");
static_assert(offsetof(FCustomLockerOutlineOverride, FadeOutAsClosingIn) == 0x000049, "Member 'FCustomLockerOutlineOverride::FadeOutAsClosingIn' has a wrong offset!");

// ScriptStruct DeadByDaylight.SaveDataV7
// 0x0408 (0x0418 - 0x0010)
struct FSaveDataV7 final : public FSaveDataBase
{
public:
	class FString                                 PlayerUID;                                         // 0x0010(0x0010)(ZeroConstructor, SaveGame, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SelectedCamperIndex;                               // 0x0020(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SelectedSlasherIndex;                              // 0x0024(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           Offerings;                                         // 0x0028(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	bool                                          FirstTimePlaying;                                  // 0x0038(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ConsecutiveMatchStreak;                            // 0x003C(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasBeenGivenKillerTutorialEndReward;               // 0x0040(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasBeenGivenSurvivorTutorialEndReward;             // 0x0041(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasSeenBloodpointsOnboardingCurrencyPopup;         // 0x0042(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasSeenAuricCellsOnboardingCurrencyPopup;          // 0x0043(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasSeenIridescentShardsOnboardingCurrencyPopup;    // 0x0044(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint64                                        CurrentSeasonTicks;                                // 0x0048(0x0008)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LastConnectedCharacterIndex;                       // 0x0050(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DisconnectPenaltyTime;                             // 0x0058(0x0010)(ZeroConstructor, SaveGame, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LastMatchEndTime;                                  // 0x0068(0x0010)(ZeroConstructor, SaveGame, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LastMatchStartTime;                                // 0x0078(0x0010)(ZeroConstructor, SaveGame, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LastKillerMatchEndTime;                            // 0x0088(0x0010)(ZeroConstructor, SaveGame, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LastSurvivorMatchEndTime;                          // 0x0098(0x0010)(ZeroConstructor, SaveGame, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Experience;                                        // 0x00A8(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BonusExperience;                                   // 0x00AC(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FearTokens;                                        // 0x00B0(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          FearTokensMigrated;                                // 0x00B4(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B5[0x3];                                       // 0x00B5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 OngoingGameTime;                                   // 0x00B8(0x0010)(ZeroConstructor, SaveGame, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CumulativeMatches;                                 // 0x00C8(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CC[0x4];                                       // 0x00CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FKeyTupleBool>                  PageVisited;                                       // 0x00D0(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	TArray<struct FKeyTupleBool>                  ChatVisible;                                       // 0x00E0(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	int32                                         CumulativeMatchesAsSurvivor;                       // 0x00F0(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CumulativeMatchesAsKiller;                         // 0x00F4(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CumulativeMatchesAsSurvivorNoFriends;              // 0x00F8(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CumulativeMatchesAsKillerNoFriends;                // 0x00FC(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              LastMatchTimestamp;                                // 0x0100(0x0008)(ZeroConstructor, SaveGame, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              LastSessionTimestamp;                              // 0x0108(0x0008)(ZeroConstructor, SaveGame, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CumulativeSessions;                                // 0x0110(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_114[0x4];                                      // 0x0114(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CumulativePlaytime;                                // 0x0118(0x0010)(ZeroConstructor, SaveGame, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FCharacterKeyTuple>             CharacterData;                                     // 0x0128(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	TArray<class FName>                           OwnedCharms;                                       // 0x0138(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	struct FSavedDailyRitualContainerV7           DailyRituals;                                      // 0x0148(0x0040)(SaveGame, NativeAccessSpecifierPublic)
	struct FSavedFearMarketOfferingInstanceV7     FearMarket;                                        // 0x0188(0x0030)(SaveGame, NativeAccessSpecifierPublic)
	struct FLegacySavedPlayerLoadoutData          LastLoadout;                                       // 0x01B8(0x00B0)(SaveGame, NativeAccessSpecifierPublic)
	struct FConsoleUserSettings                   ConsoleUserSettings;                               // 0x0268(0x00E8)(SaveGame, NativeAccessSpecifierPublic)
	TArray<struct FSavedStatsDataV7>              PlayerStatProgression;                             // 0x0350(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	TArray<class FString>                         OwnedContent;                                      // 0x0360(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	TArray<struct FSavedSpecialEventDataV7>       SpecialEvent;                                      // 0x0370(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	struct FLegacySavedBloodWebPersistentData     BloodStoreKillers;                                 // 0x0380(0x0040)(SaveGame, NativeAccessSpecifierPublic)
	struct FLegacySavedBloodWebPersistentData     BloodStoreSurvivors;                               // 0x03C0(0x0040)(SaveGame, NativeAccessSpecifierPublic)
	TArray<struct FKeyTupleBool>                  OnboardingCompleted;                               // 0x0400(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	bool                                          IsCrossplayAllowed;                                // 0x0410(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AutoDeclineFriendInvites;                          // 0x0411(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_412[0x6];                                      // 0x0412(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSaveDataV7) == 0x000008, "Wrong alignment on FSaveDataV7");
static_assert(sizeof(FSaveDataV7) == 0x000418, "Wrong size on FSaveDataV7");
static_assert(offsetof(FSaveDataV7, PlayerUID) == 0x000010, "Member 'FSaveDataV7::PlayerUID' has a wrong offset!");
static_assert(offsetof(FSaveDataV7, SelectedCamperIndex) == 0x000020, "Member 'FSaveDataV7::SelectedCamperIndex' has a wrong offset!");
static_assert(offsetof(FSaveDataV7, SelectedSlasherIndex) == 0x000024, "Member 'FSaveDataV7::SelectedSlasherIndex' has a wrong offset!");
static_assert(offsetof(FSaveDataV7, Offerings) == 0x000028, "Member 'FSaveDataV7::Offerings' has a wrong offset!");
static_assert(offsetof(FSaveDataV7, FirstTimePlaying) == 0x000038, "Member 'FSaveDataV7::FirstTimePlaying' has a wrong offset!");
static_assert(offsetof(FSaveDataV7, ConsecutiveMatchStreak) == 0x00003C, "Member 'FSaveDataV7::ConsecutiveMatchStreak' has a wrong offset!");
static_assert(offsetof(FSaveDataV7, HasBeenGivenKillerTutorialEndReward) == 0x000040, "Member 'FSaveDataV7::HasBeenGivenKillerTutorialEndReward' has a wrong offset!");
static_assert(offsetof(FSaveDataV7, HasBeenGivenSurvivorTutorialEndReward) == 0x000041, "Member 'FSaveDataV7::HasBeenGivenSurvivorTutorialEndReward' has a wrong offset!");
static_assert(offsetof(FSaveDataV7, HasSeenBloodpointsOnboardingCurrencyPopup) == 0x000042, "Member 'FSaveDataV7::HasSeenBloodpointsOnboardingCurrencyPopup' has a wrong offset!");
static_assert(offsetof(FSaveDataV7, HasSeenAuricCellsOnboardingCurrencyPopup) == 0x000043, "Member 'FSaveDataV7::HasSeenAuricCellsOnboardingCurrencyPopup' has a wrong offset!");
static_assert(offsetof(FSaveDataV7, HasSeenIridescentShardsOnboardingCurrencyPopup) == 0x000044, "Member 'FSaveDataV7::HasSeenIridescentShardsOnboardingCurrencyPopup' has a wrong offset!");
static_assert(offsetof(FSaveDataV7, CurrentSeasonTicks) == 0x000048, "Member 'FSaveDataV7::CurrentSeasonTicks' has a wrong offset!");
static_assert(offsetof(FSaveDataV7, LastConnectedCharacterIndex) == 0x000050, "Member 'FSaveDataV7::LastConnectedCharacterIndex' has a wrong offset!");
static_assert(offsetof(FSaveDataV7, DisconnectPenaltyTime) == 0x000058, "Member 'FSaveDataV7::DisconnectPenaltyTime' has a wrong offset!");
static_assert(offsetof(FSaveDataV7, LastMatchEndTime) == 0x000068, "Member 'FSaveDataV7::LastMatchEndTime' has a wrong offset!");
static_assert(offsetof(FSaveDataV7, LastMatchStartTime) == 0x000078, "Member 'FSaveDataV7::LastMatchStartTime' has a wrong offset!");
static_assert(offsetof(FSaveDataV7, LastKillerMatchEndTime) == 0x000088, "Member 'FSaveDataV7::LastKillerMatchEndTime' has a wrong offset!");
static_assert(offsetof(FSaveDataV7, LastSurvivorMatchEndTime) == 0x000098, "Member 'FSaveDataV7::LastSurvivorMatchEndTime' has a wrong offset!");
static_assert(offsetof(FSaveDataV7, Experience) == 0x0000A8, "Member 'FSaveDataV7::Experience' has a wrong offset!");
static_assert(offsetof(FSaveDataV7, BonusExperience) == 0x0000AC, "Member 'FSaveDataV7::BonusExperience' has a wrong offset!");
static_assert(offsetof(FSaveDataV7, FearTokens) == 0x0000B0, "Member 'FSaveDataV7::FearTokens' has a wrong offset!");
static_assert(offsetof(FSaveDataV7, FearTokensMigrated) == 0x0000B4, "Member 'FSaveDataV7::FearTokensMigrated' has a wrong offset!");
static_assert(offsetof(FSaveDataV7, OngoingGameTime) == 0x0000B8, "Member 'FSaveDataV7::OngoingGameTime' has a wrong offset!");
static_assert(offsetof(FSaveDataV7, CumulativeMatches) == 0x0000C8, "Member 'FSaveDataV7::CumulativeMatches' has a wrong offset!");
static_assert(offsetof(FSaveDataV7, PageVisited) == 0x0000D0, "Member 'FSaveDataV7::PageVisited' has a wrong offset!");
static_assert(offsetof(FSaveDataV7, ChatVisible) == 0x0000E0, "Member 'FSaveDataV7::ChatVisible' has a wrong offset!");
static_assert(offsetof(FSaveDataV7, CumulativeMatchesAsSurvivor) == 0x0000F0, "Member 'FSaveDataV7::CumulativeMatchesAsSurvivor' has a wrong offset!");
static_assert(offsetof(FSaveDataV7, CumulativeMatchesAsKiller) == 0x0000F4, "Member 'FSaveDataV7::CumulativeMatchesAsKiller' has a wrong offset!");
static_assert(offsetof(FSaveDataV7, CumulativeMatchesAsSurvivorNoFriends) == 0x0000F8, "Member 'FSaveDataV7::CumulativeMatchesAsSurvivorNoFriends' has a wrong offset!");
static_assert(offsetof(FSaveDataV7, CumulativeMatchesAsKillerNoFriends) == 0x0000FC, "Member 'FSaveDataV7::CumulativeMatchesAsKillerNoFriends' has a wrong offset!");
static_assert(offsetof(FSaveDataV7, LastMatchTimestamp) == 0x000100, "Member 'FSaveDataV7::LastMatchTimestamp' has a wrong offset!");
static_assert(offsetof(FSaveDataV7, LastSessionTimestamp) == 0x000108, "Member 'FSaveDataV7::LastSessionTimestamp' has a wrong offset!");
static_assert(offsetof(FSaveDataV7, CumulativeSessions) == 0x000110, "Member 'FSaveDataV7::CumulativeSessions' has a wrong offset!");
static_assert(offsetof(FSaveDataV7, CumulativePlaytime) == 0x000118, "Member 'FSaveDataV7::CumulativePlaytime' has a wrong offset!");
static_assert(offsetof(FSaveDataV7, CharacterData) == 0x000128, "Member 'FSaveDataV7::CharacterData' has a wrong offset!");
static_assert(offsetof(FSaveDataV7, OwnedCharms) == 0x000138, "Member 'FSaveDataV7::OwnedCharms' has a wrong offset!");
static_assert(offsetof(FSaveDataV7, DailyRituals) == 0x000148, "Member 'FSaveDataV7::DailyRituals' has a wrong offset!");
static_assert(offsetof(FSaveDataV7, FearMarket) == 0x000188, "Member 'FSaveDataV7::FearMarket' has a wrong offset!");
static_assert(offsetof(FSaveDataV7, LastLoadout) == 0x0001B8, "Member 'FSaveDataV7::LastLoadout' has a wrong offset!");
static_assert(offsetof(FSaveDataV7, ConsoleUserSettings) == 0x000268, "Member 'FSaveDataV7::ConsoleUserSettings' has a wrong offset!");
static_assert(offsetof(FSaveDataV7, PlayerStatProgression) == 0x000350, "Member 'FSaveDataV7::PlayerStatProgression' has a wrong offset!");
static_assert(offsetof(FSaveDataV7, OwnedContent) == 0x000360, "Member 'FSaveDataV7::OwnedContent' has a wrong offset!");
static_assert(offsetof(FSaveDataV7, SpecialEvent) == 0x000370, "Member 'FSaveDataV7::SpecialEvent' has a wrong offset!");
static_assert(offsetof(FSaveDataV7, BloodStoreKillers) == 0x000380, "Member 'FSaveDataV7::BloodStoreKillers' has a wrong offset!");
static_assert(offsetof(FSaveDataV7, BloodStoreSurvivors) == 0x0003C0, "Member 'FSaveDataV7::BloodStoreSurvivors' has a wrong offset!");
static_assert(offsetof(FSaveDataV7, OnboardingCompleted) == 0x000400, "Member 'FSaveDataV7::OnboardingCompleted' has a wrong offset!");
static_assert(offsetof(FSaveDataV7, IsCrossplayAllowed) == 0x000410, "Member 'FSaveDataV7::IsCrossplayAllowed' has a wrong offset!");
static_assert(offsetof(FSaveDataV7, AutoDeclineFriendInvites) == 0x000411, "Member 'FSaveDataV7::AutoDeclineFriendInvites' has a wrong offset!");

// ScriptStruct DeadByDaylight.SavedSpecialEventDataV8
// 0x0010 (0x0010 - 0x0000)
struct FSavedSpecialEventDataV8 final
{
public:
	class FName                                   EventID;                                           // 0x0000(0x000C)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EventEntryScreenOpened;                            // 0x000C(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EventSplashScreenSeen;                             // 0x000D(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E[0x2];                                        // 0x000E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSavedSpecialEventDataV8) == 0x000004, "Wrong alignment on FSavedSpecialEventDataV8");
static_assert(sizeof(FSavedSpecialEventDataV8) == 0x000010, "Wrong size on FSavedSpecialEventDataV8");
static_assert(offsetof(FSavedSpecialEventDataV8, EventID) == 0x000000, "Member 'FSavedSpecialEventDataV8::EventID' has a wrong offset!");
static_assert(offsetof(FSavedSpecialEventDataV8, EventEntryScreenOpened) == 0x00000C, "Member 'FSavedSpecialEventDataV8::EventEntryScreenOpened' has a wrong offset!");
static_assert(offsetof(FSavedSpecialEventDataV8, EventSplashScreenSeen) == 0x00000D, "Member 'FSavedSpecialEventDataV8::EventSplashScreenSeen' has a wrong offset!");

// ScriptStruct DeadByDaylight.PlayerRankData
// 0x0018 (0x0018 - 0x0000)
struct FPlayerRankData final
{
public:
	class FString                                 MirrorsId;                                         // 0x0000(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerRole                                   PlayerRole;                                        // 0x0010(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PlayerRankForRole;                                 // 0x0014(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerRankData) == 0x000008, "Wrong alignment on FPlayerRankData");
static_assert(sizeof(FPlayerRankData) == 0x000018, "Wrong size on FPlayerRankData");
static_assert(offsetof(FPlayerRankData, MirrorsId) == 0x000000, "Member 'FPlayerRankData::MirrorsId' has a wrong offset!");
static_assert(offsetof(FPlayerRankData, PlayerRole) == 0x000010, "Member 'FPlayerRankData::PlayerRole' has a wrong offset!");
static_assert(offsetof(FPlayerRankData, PlayerRankForRole) == 0x000014, "Member 'FPlayerRankData::PlayerRankForRole' has a wrong offset!");

// ScriptStruct DeadByDaylight.SavedReleaseDataV8
// 0x0018 (0x0018 - 0x0000)
struct FSavedReleaseDataV8 final
{
public:
	class FString                                 Version;                                           // 0x0000(0x0010)(ZeroConstructor, SaveGame, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NewChapterPopupSeen;                               // 0x0010(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSavedReleaseDataV8) == 0x000008, "Wrong alignment on FSavedReleaseDataV8");
static_assert(sizeof(FSavedReleaseDataV8) == 0x000018, "Wrong size on FSavedReleaseDataV8");
static_assert(offsetof(FSavedReleaseDataV8, Version) == 0x000000, "Member 'FSavedReleaseDataV8::Version' has a wrong offset!");
static_assert(offsetof(FSavedReleaseDataV8, NewChapterPopupSeen) == 0x000010, "Member 'FSavedReleaseDataV8::NewChapterPopupSeen' has a wrong offset!");

// ScriptStruct DeadByDaylight.SaveDataV8
// 0x0750 (0x0760 - 0x0010)
struct FSaveDataV8 final : public FSaveDataBase
{
public:
	class FString                                 PlayerUID;                                         // 0x0010(0x0010)(ZeroConstructor, SaveGame, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SelectedCamperIndex;                               // 0x0020(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SelectedSlasherIndex;                              // 0x0024(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           Offerings;                                         // 0x0028(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	bool                                          FirstTimePlaying;                                  // 0x0038(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasSeenLightSensitivity;                           // 0x0039(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasSeenMainMenu;                                   // 0x003A(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B[0x1];                                       // 0x003B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ConsecutiveMatchStreak;                            // 0x003C(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasBeenGivenKillerTutorialEndReward;               // 0x0040(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasBeenGivenSurvivorTutorialEndReward;             // 0x0041(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasSeenBloodpointsOnboardingCurrencyPopup;         // 0x0042(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasSeenAuricCellsOnboardingCurrencyPopup;          // 0x0043(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasSeenIridescentShardsOnboardingCurrencyPopup;    // 0x0044(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint64                                        CurrentSeasonTicks;                                // 0x0048(0x0008)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LastConnectedCharacterIndex;                       // 0x0050(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DisconnectPenaltyTime;                             // 0x0058(0x0010)(ZeroConstructor, SaveGame, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LastMatchEndTime;                                  // 0x0068(0x0010)(ZeroConstructor, SaveGame, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LastMatchStartTime;                                // 0x0078(0x0010)(ZeroConstructor, SaveGame, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LastKillerMatchEndTime;                            // 0x0088(0x0010)(ZeroConstructor, SaveGame, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LastSurvivorMatchEndTime;                          // 0x0098(0x0010)(ZeroConstructor, SaveGame, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CumulativeMatches;                                 // 0x00A8(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CumulativeMatchesLeft;                             // 0x00AC(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FKeyTupleBool>                  PageVisited;                                       // 0x00B0(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	TArray<struct FKeyTupleBool>                  ChatVisible;                                       // 0x00C0(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	int32                                         CumulativeMatchesAsSurvivor;                       // 0x00D0(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CumulativeMatchesLeftAsSurvivor;                   // 0x00D4(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CumulativeMatchesAsKiller;                         // 0x00D8(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CumulativeMatchesLeftAsKiller;                     // 0x00DC(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CumulativeMatchesAsSurvivorNoFriends;              // 0x00E0(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CumulativeMatchesAsKillerNoFriends;                // 0x00E4(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              LastMatchTimestamp;                                // 0x00E8(0x0008)(ZeroConstructor, SaveGame, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              LastSessionTimestamp;                              // 0x00F0(0x0008)(ZeroConstructor, SaveGame, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CumulativeSessions;                                // 0x00F8(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FC[0x4];                                       // 0x00FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CumulativePlaytime;                                // 0x0100(0x0010)(ZeroConstructor, SaveGame, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FCharacterKeyTuple>             CharacterData;                                     // 0x0110(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	TArray<class FName>                           OwnedCharms;                                       // 0x0120(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	struct FSavedDailyRitualContainerV7           DailyRituals;                                      // 0x0130(0x0040)(SaveGame, NativeAccessSpecifierPublic)
	struct FSavedFearMarketOfferingInstanceV7     FearMarket;                                        // 0x0170(0x0030)(SaveGame, NativeAccessSpecifierPublic)
	struct FLegacySavedPlayerLoadoutData          LastLoadout;                                       // 0x01A0(0x00B0)(SaveGame, NativeAccessSpecifierPublic)
	struct FConsoleUserSettings                   ConsoleUserSettings;                               // 0x0250(0x00E8)(SaveGame, NativeAccessSpecifierPublic)
	TArray<struct FSavedStatsDataV7>              PlayerStatProgression;                             // 0x0338(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	TArray<class FString>                         OwnedContent;                                      // 0x0348(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	TArray<struct FSavedSpecialEventDataV8>       SpecialEvent;                                      // 0x0358(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	TArray<struct FSavedReleaseDataV8>            Releases;                                          // 0x0368(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	TSet<class FName>                             SeenCinematics;                                    // 0x0378(0x0050)(SaveGame, NativeAccessSpecifierPublic)
	TSet<class FName>                             SeenFeatures;                                      // 0x03C8(0x0050)(SaveGame, NativeAccessSpecifierPublic)
	TSet<class FName>                             SeenSecretRewardPopups;                            // 0x0418(0x0050)(SaveGame, NativeAccessSpecifierPublic)
	TMap<class FName, struct FSavedSeenPopupData> SeenPopupsData;                                    // 0x0468(0x0050)(SaveGame, NativeAccessSpecifierPublic)
	struct FLegacySavedBloodWebPersistentData     BloodStoreKillers;                                 // 0x04B8(0x0040)(SaveGame, NativeAccessSpecifierPublic)
	struct FLegacySavedBloodWebPersistentData     BloodStoreSurvivors;                               // 0x04F8(0x0040)(SaveGame, NativeAccessSpecifierPublic)
	TArray<struct FKeyTupleBool>                  OnboardingCompleted;                               // 0x0538(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	struct FDailyRitualSaveData                   DailyRitualSaveData;                               // 0x0548(0x0008)(SaveGame, NoDestructor, NativeAccessSpecifierPublic)
	struct FUIViewFlagSaveData                    UIViewFlags;                                       // 0x0550(0x00F8)(SaveGame, NativeAccessSpecifierPublic)
	bool                                          IsCrossplayAllowed;                                // 0x0648(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AutoDeclineFriendInvites;                          // 0x0649(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasBeginnerTooltipsBeenDisabledAtLevel;            // 0x064A(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShowPortraitBorder;                                // 0x064B(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64C[0x4];                                      // 0x064C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCharacterCustomizationPresetsList> CharacterCustomizationPresets;                     // 0x0650(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	TMap<class FString, struct FCustomizationPresetsDataForGameType> CharacterCustomizationPresetsPerGameType;          // 0x0660(0x0050)(SaveGame, NativeAccessSpecifierPublic)
	TArray<struct FCharacterLoadoutPresetsList>   CharacterLoadoutPresets;                           // 0x06B0(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	TMap<class FString, struct FLoadoutPresetsDataForGameType> CharacterLoadoutPresetsPerGameType;                // 0x06C0(0x0050)(SaveGame, NativeAccessSpecifierPublic)
	TMap<class FName, struct FSavedStoreFilters>  SavedStoreFilters;                                 // 0x0710(0x0050)(SaveGame, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSaveDataV8) == 0x000008, "Wrong alignment on FSaveDataV8");
static_assert(sizeof(FSaveDataV8) == 0x000760, "Wrong size on FSaveDataV8");
static_assert(offsetof(FSaveDataV8, PlayerUID) == 0x000010, "Member 'FSaveDataV8::PlayerUID' has a wrong offset!");
static_assert(offsetof(FSaveDataV8, SelectedCamperIndex) == 0x000020, "Member 'FSaveDataV8::SelectedCamperIndex' has a wrong offset!");
static_assert(offsetof(FSaveDataV8, SelectedSlasherIndex) == 0x000024, "Member 'FSaveDataV8::SelectedSlasherIndex' has a wrong offset!");
static_assert(offsetof(FSaveDataV8, Offerings) == 0x000028, "Member 'FSaveDataV8::Offerings' has a wrong offset!");
static_assert(offsetof(FSaveDataV8, FirstTimePlaying) == 0x000038, "Member 'FSaveDataV8::FirstTimePlaying' has a wrong offset!");
static_assert(offsetof(FSaveDataV8, HasSeenLightSensitivity) == 0x000039, "Member 'FSaveDataV8::HasSeenLightSensitivity' has a wrong offset!");
static_assert(offsetof(FSaveDataV8, HasSeenMainMenu) == 0x00003A, "Member 'FSaveDataV8::HasSeenMainMenu' has a wrong offset!");
static_assert(offsetof(FSaveDataV8, ConsecutiveMatchStreak) == 0x00003C, "Member 'FSaveDataV8::ConsecutiveMatchStreak' has a wrong offset!");
static_assert(offsetof(FSaveDataV8, HasBeenGivenKillerTutorialEndReward) == 0x000040, "Member 'FSaveDataV8::HasBeenGivenKillerTutorialEndReward' has a wrong offset!");
static_assert(offsetof(FSaveDataV8, HasBeenGivenSurvivorTutorialEndReward) == 0x000041, "Member 'FSaveDataV8::HasBeenGivenSurvivorTutorialEndReward' has a wrong offset!");
static_assert(offsetof(FSaveDataV8, HasSeenBloodpointsOnboardingCurrencyPopup) == 0x000042, "Member 'FSaveDataV8::HasSeenBloodpointsOnboardingCurrencyPopup' has a wrong offset!");
static_assert(offsetof(FSaveDataV8, HasSeenAuricCellsOnboardingCurrencyPopup) == 0x000043, "Member 'FSaveDataV8::HasSeenAuricCellsOnboardingCurrencyPopup' has a wrong offset!");
static_assert(offsetof(FSaveDataV8, HasSeenIridescentShardsOnboardingCurrencyPopup) == 0x000044, "Member 'FSaveDataV8::HasSeenIridescentShardsOnboardingCurrencyPopup' has a wrong offset!");
static_assert(offsetof(FSaveDataV8, CurrentSeasonTicks) == 0x000048, "Member 'FSaveDataV8::CurrentSeasonTicks' has a wrong offset!");
static_assert(offsetof(FSaveDataV8, LastConnectedCharacterIndex) == 0x000050, "Member 'FSaveDataV8::LastConnectedCharacterIndex' has a wrong offset!");
static_assert(offsetof(FSaveDataV8, DisconnectPenaltyTime) == 0x000058, "Member 'FSaveDataV8::DisconnectPenaltyTime' has a wrong offset!");
static_assert(offsetof(FSaveDataV8, LastMatchEndTime) == 0x000068, "Member 'FSaveDataV8::LastMatchEndTime' has a wrong offset!");
static_assert(offsetof(FSaveDataV8, LastMatchStartTime) == 0x000078, "Member 'FSaveDataV8::LastMatchStartTime' has a wrong offset!");
static_assert(offsetof(FSaveDataV8, LastKillerMatchEndTime) == 0x000088, "Member 'FSaveDataV8::LastKillerMatchEndTime' has a wrong offset!");
static_assert(offsetof(FSaveDataV8, LastSurvivorMatchEndTime) == 0x000098, "Member 'FSaveDataV8::LastSurvivorMatchEndTime' has a wrong offset!");
static_assert(offsetof(FSaveDataV8, CumulativeMatches) == 0x0000A8, "Member 'FSaveDataV8::CumulativeMatches' has a wrong offset!");
static_assert(offsetof(FSaveDataV8, CumulativeMatchesLeft) == 0x0000AC, "Member 'FSaveDataV8::CumulativeMatchesLeft' has a wrong offset!");
static_assert(offsetof(FSaveDataV8, PageVisited) == 0x0000B0, "Member 'FSaveDataV8::PageVisited' has a wrong offset!");
static_assert(offsetof(FSaveDataV8, ChatVisible) == 0x0000C0, "Member 'FSaveDataV8::ChatVisible' has a wrong offset!");
static_assert(offsetof(FSaveDataV8, CumulativeMatchesAsSurvivor) == 0x0000D0, "Member 'FSaveDataV8::CumulativeMatchesAsSurvivor' has a wrong offset!");
static_assert(offsetof(FSaveDataV8, CumulativeMatchesLeftAsSurvivor) == 0x0000D4, "Member 'FSaveDataV8::CumulativeMatchesLeftAsSurvivor' has a wrong offset!");
static_assert(offsetof(FSaveDataV8, CumulativeMatchesAsKiller) == 0x0000D8, "Member 'FSaveDataV8::CumulativeMatchesAsKiller' has a wrong offset!");
static_assert(offsetof(FSaveDataV8, CumulativeMatchesLeftAsKiller) == 0x0000DC, "Member 'FSaveDataV8::CumulativeMatchesLeftAsKiller' has a wrong offset!");
static_assert(offsetof(FSaveDataV8, CumulativeMatchesAsSurvivorNoFriends) == 0x0000E0, "Member 'FSaveDataV8::CumulativeMatchesAsSurvivorNoFriends' has a wrong offset!");
static_assert(offsetof(FSaveDataV8, CumulativeMatchesAsKillerNoFriends) == 0x0000E4, "Member 'FSaveDataV8::CumulativeMatchesAsKillerNoFriends' has a wrong offset!");
static_assert(offsetof(FSaveDataV8, LastMatchTimestamp) == 0x0000E8, "Member 'FSaveDataV8::LastMatchTimestamp' has a wrong offset!");
static_assert(offsetof(FSaveDataV8, LastSessionTimestamp) == 0x0000F0, "Member 'FSaveDataV8::LastSessionTimestamp' has a wrong offset!");
static_assert(offsetof(FSaveDataV8, CumulativeSessions) == 0x0000F8, "Member 'FSaveDataV8::CumulativeSessions' has a wrong offset!");
static_assert(offsetof(FSaveDataV8, CumulativePlaytime) == 0x000100, "Member 'FSaveDataV8::CumulativePlaytime' has a wrong offset!");
static_assert(offsetof(FSaveDataV8, CharacterData) == 0x000110, "Member 'FSaveDataV8::CharacterData' has a wrong offset!");
static_assert(offsetof(FSaveDataV8, OwnedCharms) == 0x000120, "Member 'FSaveDataV8::OwnedCharms' has a wrong offset!");
static_assert(offsetof(FSaveDataV8, DailyRituals) == 0x000130, "Member 'FSaveDataV8::DailyRituals' has a wrong offset!");
static_assert(offsetof(FSaveDataV8, FearMarket) == 0x000170, "Member 'FSaveDataV8::FearMarket' has a wrong offset!");
static_assert(offsetof(FSaveDataV8, LastLoadout) == 0x0001A0, "Member 'FSaveDataV8::LastLoadout' has a wrong offset!");
static_assert(offsetof(FSaveDataV8, ConsoleUserSettings) == 0x000250, "Member 'FSaveDataV8::ConsoleUserSettings' has a wrong offset!");
static_assert(offsetof(FSaveDataV8, PlayerStatProgression) == 0x000338, "Member 'FSaveDataV8::PlayerStatProgression' has a wrong offset!");
static_assert(offsetof(FSaveDataV8, OwnedContent) == 0x000348, "Member 'FSaveDataV8::OwnedContent' has a wrong offset!");
static_assert(offsetof(FSaveDataV8, SpecialEvent) == 0x000358, "Member 'FSaveDataV8::SpecialEvent' has a wrong offset!");
static_assert(offsetof(FSaveDataV8, Releases) == 0x000368, "Member 'FSaveDataV8::Releases' has a wrong offset!");
static_assert(offsetof(FSaveDataV8, SeenCinematics) == 0x000378, "Member 'FSaveDataV8::SeenCinematics' has a wrong offset!");
static_assert(offsetof(FSaveDataV8, SeenFeatures) == 0x0003C8, "Member 'FSaveDataV8::SeenFeatures' has a wrong offset!");
static_assert(offsetof(FSaveDataV8, SeenSecretRewardPopups) == 0x000418, "Member 'FSaveDataV8::SeenSecretRewardPopups' has a wrong offset!");
static_assert(offsetof(FSaveDataV8, SeenPopupsData) == 0x000468, "Member 'FSaveDataV8::SeenPopupsData' has a wrong offset!");
static_assert(offsetof(FSaveDataV8, BloodStoreKillers) == 0x0004B8, "Member 'FSaveDataV8::BloodStoreKillers' has a wrong offset!");
static_assert(offsetof(FSaveDataV8, BloodStoreSurvivors) == 0x0004F8, "Member 'FSaveDataV8::BloodStoreSurvivors' has a wrong offset!");
static_assert(offsetof(FSaveDataV8, OnboardingCompleted) == 0x000538, "Member 'FSaveDataV8::OnboardingCompleted' has a wrong offset!");
static_assert(offsetof(FSaveDataV8, DailyRitualSaveData) == 0x000548, "Member 'FSaveDataV8::DailyRitualSaveData' has a wrong offset!");
static_assert(offsetof(FSaveDataV8, UIViewFlags) == 0x000550, "Member 'FSaveDataV8::UIViewFlags' has a wrong offset!");
static_assert(offsetof(FSaveDataV8, IsCrossplayAllowed) == 0x000648, "Member 'FSaveDataV8::IsCrossplayAllowed' has a wrong offset!");
static_assert(offsetof(FSaveDataV8, AutoDeclineFriendInvites) == 0x000649, "Member 'FSaveDataV8::AutoDeclineFriendInvites' has a wrong offset!");
static_assert(offsetof(FSaveDataV8, HasBeginnerTooltipsBeenDisabledAtLevel) == 0x00064A, "Member 'FSaveDataV8::HasBeginnerTooltipsBeenDisabledAtLevel' has a wrong offset!");
static_assert(offsetof(FSaveDataV8, ShowPortraitBorder) == 0x00064B, "Member 'FSaveDataV8::ShowPortraitBorder' has a wrong offset!");
static_assert(offsetof(FSaveDataV8, CharacterCustomizationPresets) == 0x000650, "Member 'FSaveDataV8::CharacterCustomizationPresets' has a wrong offset!");
static_assert(offsetof(FSaveDataV8, CharacterCustomizationPresetsPerGameType) == 0x000660, "Member 'FSaveDataV8::CharacterCustomizationPresetsPerGameType' has a wrong offset!");
static_assert(offsetof(FSaveDataV8, CharacterLoadoutPresets) == 0x0006B0, "Member 'FSaveDataV8::CharacterLoadoutPresets' has a wrong offset!");
static_assert(offsetof(FSaveDataV8, CharacterLoadoutPresetsPerGameType) == 0x0006C0, "Member 'FSaveDataV8::CharacterLoadoutPresetsPerGameType' has a wrong offset!");
static_assert(offsetof(FSaveDataV8, SavedStoreFilters) == 0x000710, "Member 'FSaveDataV8::SavedStoreFilters' has a wrong offset!");

// ScriptStruct DeadByDaylight.SaveValidationData
// 0x0030 (0x0030 - 0x0000)
struct FSaveValidationData final
{
public:
	class FString                                 PlayerUID;                                         // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 CharacterData;                                     // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0x10];                                      // 0x0020(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSaveValidationData) == 0x000008, "Wrong alignment on FSaveValidationData");
static_assert(sizeof(FSaveValidationData) == 0x000030, "Wrong size on FSaveValidationData");
static_assert(offsetof(FSaveValidationData, PlayerUID) == 0x000000, "Member 'FSaveValidationData::PlayerUID' has a wrong offset!");
static_assert(offsetof(FSaveValidationData, CharacterData) == 0x000010, "Member 'FSaveValidationData::CharacterData' has a wrong offset!");

// ScriptStruct DeadByDaylight.ScoreCategoryData
// 0x0010 (0x0018 - 0x0008)
struct FScoreCategoryData final : public FDBDTableRowBase
{
public:
	EDBDScoreCategory                             Category;                                          // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ScoreCap;                                          // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ProgressionCap;                                    // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AchievementCap;                                    // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FScoreCategoryData) == 0x000008, "Wrong alignment on FScoreCategoryData");
static_assert(sizeof(FScoreCategoryData) == 0x000018, "Wrong size on FScoreCategoryData");
static_assert(offsetof(FScoreCategoryData, Category) == 0x000008, "Member 'FScoreCategoryData::Category' has a wrong offset!");
static_assert(offsetof(FScoreCategoryData, ScoreCap) == 0x00000C, "Member 'FScoreCategoryData::ScoreCap' has a wrong offset!");
static_assert(offsetof(FScoreCategoryData, ProgressionCap) == 0x000010, "Member 'FScoreCategoryData::ProgressionCap' has a wrong offset!");
static_assert(offsetof(FScoreCategoryData, AchievementCap) == 0x000014, "Member 'FScoreCategoryData::AchievementCap' has a wrong offset!");

// ScriptStruct DeadByDaylight.S3AnalyticsConfig
// 0x00C8 (0x00C8 - 0x0000)
struct FS3AnalyticsConfig final
{
public:
	bool                                          GameInitVerbose;                                   // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 GameConsoleLogMinimumVerbosity;                    // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        MaxFramesUntilSend;                                // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxTrackedRecurrences;                             // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         ScoreTypeWhitelist;                                // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          ScoreTypeWhitelist_IsSet;                          // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         ScoreTypeBlacklist;                                // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          ScoreTypeBlacklist_IsSet;                          // 0x0048(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         DetailedScoreTypeWhitelist;                        // 0x0050(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          DetailedScoreTypeWhitelist_IsSet;                  // 0x0060(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         DetailedScoreTypeBlacklist;                        // 0x0068(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          DetailedScoreTypeBlacklist_IsSet;                  // 0x0078(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x3];                                       // 0x0079(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        PerformanceSamplingRate;                           // 0x007C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         PerformanceSamplingWhitelist;                      // 0x0080(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          PerformanceSamplingWhitelist_IsSet;                // 0x0090(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         PerformanceContextWhitelist;                       // 0x0098(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          PerformanceContextWhitelist_IsSet;                 // 0x00A8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 PerformanceSamplingRule;                           // 0x00B0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AutoflushFrequency;                                // 0x00C0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AutoflushInGameFrequency;                          // 0x00C4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FS3AnalyticsConfig) == 0x000008, "Wrong alignment on FS3AnalyticsConfig");
static_assert(sizeof(FS3AnalyticsConfig) == 0x0000C8, "Wrong size on FS3AnalyticsConfig");
static_assert(offsetof(FS3AnalyticsConfig, GameInitVerbose) == 0x000000, "Member 'FS3AnalyticsConfig::GameInitVerbose' has a wrong offset!");
static_assert(offsetof(FS3AnalyticsConfig, GameConsoleLogMinimumVerbosity) == 0x000008, "Member 'FS3AnalyticsConfig::GameConsoleLogMinimumVerbosity' has a wrong offset!");
static_assert(offsetof(FS3AnalyticsConfig, MaxFramesUntilSend) == 0x000018, "Member 'FS3AnalyticsConfig::MaxFramesUntilSend' has a wrong offset!");
static_assert(offsetof(FS3AnalyticsConfig, MaxTrackedRecurrences) == 0x00001C, "Member 'FS3AnalyticsConfig::MaxTrackedRecurrences' has a wrong offset!");
static_assert(offsetof(FS3AnalyticsConfig, ScoreTypeWhitelist) == 0x000020, "Member 'FS3AnalyticsConfig::ScoreTypeWhitelist' has a wrong offset!");
static_assert(offsetof(FS3AnalyticsConfig, ScoreTypeWhitelist_IsSet) == 0x000030, "Member 'FS3AnalyticsConfig::ScoreTypeWhitelist_IsSet' has a wrong offset!");
static_assert(offsetof(FS3AnalyticsConfig, ScoreTypeBlacklist) == 0x000038, "Member 'FS3AnalyticsConfig::ScoreTypeBlacklist' has a wrong offset!");
static_assert(offsetof(FS3AnalyticsConfig, ScoreTypeBlacklist_IsSet) == 0x000048, "Member 'FS3AnalyticsConfig::ScoreTypeBlacklist_IsSet' has a wrong offset!");
static_assert(offsetof(FS3AnalyticsConfig, DetailedScoreTypeWhitelist) == 0x000050, "Member 'FS3AnalyticsConfig::DetailedScoreTypeWhitelist' has a wrong offset!");
static_assert(offsetof(FS3AnalyticsConfig, DetailedScoreTypeWhitelist_IsSet) == 0x000060, "Member 'FS3AnalyticsConfig::DetailedScoreTypeWhitelist_IsSet' has a wrong offset!");
static_assert(offsetof(FS3AnalyticsConfig, DetailedScoreTypeBlacklist) == 0x000068, "Member 'FS3AnalyticsConfig::DetailedScoreTypeBlacklist' has a wrong offset!");
static_assert(offsetof(FS3AnalyticsConfig, DetailedScoreTypeBlacklist_IsSet) == 0x000078, "Member 'FS3AnalyticsConfig::DetailedScoreTypeBlacklist_IsSet' has a wrong offset!");
static_assert(offsetof(FS3AnalyticsConfig, PerformanceSamplingRate) == 0x00007C, "Member 'FS3AnalyticsConfig::PerformanceSamplingRate' has a wrong offset!");
static_assert(offsetof(FS3AnalyticsConfig, PerformanceSamplingWhitelist) == 0x000080, "Member 'FS3AnalyticsConfig::PerformanceSamplingWhitelist' has a wrong offset!");
static_assert(offsetof(FS3AnalyticsConfig, PerformanceSamplingWhitelist_IsSet) == 0x000090, "Member 'FS3AnalyticsConfig::PerformanceSamplingWhitelist_IsSet' has a wrong offset!");
static_assert(offsetof(FS3AnalyticsConfig, PerformanceContextWhitelist) == 0x000098, "Member 'FS3AnalyticsConfig::PerformanceContextWhitelist' has a wrong offset!");
static_assert(offsetof(FS3AnalyticsConfig, PerformanceContextWhitelist_IsSet) == 0x0000A8, "Member 'FS3AnalyticsConfig::PerformanceContextWhitelist_IsSet' has a wrong offset!");
static_assert(offsetof(FS3AnalyticsConfig, PerformanceSamplingRule) == 0x0000B0, "Member 'FS3AnalyticsConfig::PerformanceSamplingRule' has a wrong offset!");
static_assert(offsetof(FS3AnalyticsConfig, AutoflushFrequency) == 0x0000C0, "Member 'FS3AnalyticsConfig::AutoflushFrequency' has a wrong offset!");
static_assert(offsetof(FS3AnalyticsConfig, AutoflushInGameFrequency) == 0x0000C4, "Member 'FS3AnalyticsConfig::AutoflushInGameFrequency' has a wrong offset!");

// ScriptStruct DeadByDaylight.ScoreValue
// 0x0040 (0x0048 - 0x0008)
struct FScoreValue final : public FDBDTableRowBase
{
public:
	class FName                                   ID;                                                // 0x0008(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDBDScoreCategory                             Category;                                          // 0x0014(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         BloodpointValue;                                   // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxBloodpointValue;                                // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            BloodpointDepreciationCurve;                       // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OngoingWaitTime;                                   // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DisplayName;                                       // 0x0030(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FScoreValue) == 0x000008, "Wrong alignment on FScoreValue");
static_assert(sizeof(FScoreValue) == 0x000048, "Wrong size on FScoreValue");
static_assert(offsetof(FScoreValue, ID) == 0x000008, "Member 'FScoreValue::ID' has a wrong offset!");
static_assert(offsetof(FScoreValue, Category) == 0x000014, "Member 'FScoreValue::Category' has a wrong offset!");
static_assert(offsetof(FScoreValue, BloodpointValue) == 0x000018, "Member 'FScoreValue::BloodpointValue' has a wrong offset!");
static_assert(offsetof(FScoreValue, MaxBloodpointValue) == 0x00001C, "Member 'FScoreValue::MaxBloodpointValue' has a wrong offset!");
static_assert(offsetof(FScoreValue, BloodpointDepreciationCurve) == 0x000020, "Member 'FScoreValue::BloodpointDepreciationCurve' has a wrong offset!");
static_assert(offsetof(FScoreValue, OngoingWaitTime) == 0x000028, "Member 'FScoreValue::OngoingWaitTime' has a wrong offset!");
static_assert(offsetof(FScoreValue, DisplayName) == 0x000030, "Member 'FScoreValue::DisplayName' has a wrong offset!");

// ScriptStruct DeadByDaylight.AwardedScore
// 0x0010 (0x0010 - 0x0000)
struct FAwardedScore final
{
public:
	class FName                                   ScoreTypeId;                                       // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BloodpointsAwarded;                                // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAwardedScore) == 0x000004, "Wrong alignment on FAwardedScore");
static_assert(sizeof(FAwardedScore) == 0x000010, "Wrong size on FAwardedScore");
static_assert(offsetof(FAwardedScore, ScoreTypeId) == 0x000000, "Member 'FAwardedScore::ScoreTypeId' has a wrong offset!");
static_assert(offsetof(FAwardedScore, BloodpointsAwarded) == 0x00000C, "Member 'FAwardedScore::BloodpointsAwarded' has a wrong offset!");

// ScriptStruct DeadByDaylight.MenuCameraView
// 0x0040 (0x0040 - 0x0000)
struct FMenuCameraView final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0018(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          Override_Settings;                                 // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMenuCameraViewSettings                Settings;                                          // 0x0034(0x000C)(Edit, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMenuCameraView) == 0x000008, "Wrong alignment on FMenuCameraView");
static_assert(sizeof(FMenuCameraView) == 0x000040, "Wrong size on FMenuCameraView");
static_assert(offsetof(FMenuCameraView, Location) == 0x000000, "Member 'FMenuCameraView::Location' has a wrong offset!");
static_assert(offsetof(FMenuCameraView, Rotation) == 0x000018, "Member 'FMenuCameraView::Rotation' has a wrong offset!");
static_assert(offsetof(FMenuCameraView, Override_Settings) == 0x000030, "Member 'FMenuCameraView::Override_Settings' has a wrong offset!");
static_assert(offsetof(FMenuCameraView, Settings) == 0x000034, "Member 'FMenuCameraView::Settings' has a wrong offset!");

// ScriptStruct DeadByDaylight.AwardedScores
// 0x0010 (0x0010 - 0x0000)
struct FAwardedScores final
{
public:
	TArray<struct FAwardedScore>                  Array;                                             // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAwardedScores) == 0x000008, "Wrong alignment on FAwardedScores");
static_assert(sizeof(FAwardedScores) == 0x000010, "Wrong size on FAwardedScores");
static_assert(offsetof(FAwardedScores, Array) == 0x000000, "Member 'FAwardedScores::Array' has a wrong offset!");

// ScriptStruct DeadByDaylight.OngoingScoreData
// 0x0030 (0x0030 - 0x0000)
struct FOngoingScoreData final
{
public:
	EDBDScoreTypes                                ScoreType;                                         // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           ScoreTypeTag;                                      // 0x0004(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeSinceScore;                                    // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ApplyScoreTimeout;                                 // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AccumulatedPercent;                                // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 Target;                                            // 0x0020(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                CustomObjectParameter;                             // 0x0028(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOngoingScoreData) == 0x000008, "Wrong alignment on FOngoingScoreData");
static_assert(sizeof(FOngoingScoreData) == 0x000030, "Wrong size on FOngoingScoreData");
static_assert(offsetof(FOngoingScoreData, ScoreType) == 0x000000, "Member 'FOngoingScoreData::ScoreType' has a wrong offset!");
static_assert(offsetof(FOngoingScoreData, ScoreTypeTag) == 0x000004, "Member 'FOngoingScoreData::ScoreTypeTag' has a wrong offset!");
static_assert(offsetof(FOngoingScoreData, TimeSinceScore) == 0x000010, "Member 'FOngoingScoreData::TimeSinceScore' has a wrong offset!");
static_assert(offsetof(FOngoingScoreData, ApplyScoreTimeout) == 0x000014, "Member 'FOngoingScoreData::ApplyScoreTimeout' has a wrong offset!");
static_assert(offsetof(FOngoingScoreData, AccumulatedPercent) == 0x000018, "Member 'FOngoingScoreData::AccumulatedPercent' has a wrong offset!");
static_assert(offsetof(FOngoingScoreData, Target) == 0x000020, "Member 'FOngoingScoreData::Target' has a wrong offset!");
static_assert(offsetof(FOngoingScoreData, CustomObjectParameter) == 0x000028, "Member 'FOngoingScoreData::CustomObjectParameter' has a wrong offset!");

// ScriptStruct DeadByDaylight.UserGameStats
// 0x00B0 (0x00B0 - 0x0000)
struct FUserGameStats final
{
public:
	bool                                          Disconnected;                                      // 0x0000(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         FearTokens;                                        // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Skulls;                                            // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EDBDScoreCategory, int32>                BonusBloodpoints;                                  // 0x0010(0x0050)(Transient, NativeAccessSpecifierPublic)
	TMap<EDBDScoreCategory, int32>                _bloodpoints;                                      // 0x0060(0x0050)(Transient, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FUserGameStats) == 0x000008, "Wrong alignment on FUserGameStats");
static_assert(sizeof(FUserGameStats) == 0x0000B0, "Wrong size on FUserGameStats");
static_assert(offsetof(FUserGameStats, Disconnected) == 0x000000, "Member 'FUserGameStats::Disconnected' has a wrong offset!");
static_assert(offsetof(FUserGameStats, FearTokens) == 0x000004, "Member 'FUserGameStats::FearTokens' has a wrong offset!");
static_assert(offsetof(FUserGameStats, Skulls) == 0x000008, "Member 'FUserGameStats::Skulls' has a wrong offset!");
static_assert(offsetof(FUserGameStats, BonusBloodpoints) == 0x000010, "Member 'FUserGameStats::BonusBloodpoints' has a wrong offset!");
static_assert(offsetof(FUserGameStats, _bloodpoints) == 0x000060, "Member 'FUserGameStats::_bloodpoints' has a wrong offset!");

// ScriptStruct DeadByDaylight.ObjectLock
// 0x0008 (0x0008 - 0x0000)
struct FObjectLock final
{
public:
	TWeakObjectPtr<class UObject>                 _lockingObject;                                    // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FObjectLock) == 0x000004, "Wrong alignment on FObjectLock");
static_assert(sizeof(FObjectLock) == 0x000008, "Wrong size on FObjectLock");
static_assert(offsetof(FObjectLock, _lockingObject) == 0x000000, "Member 'FObjectLock::_lockingObject' has a wrong offset!");

// ScriptStruct DeadByDaylight.PlayerstateDataCache
// 0x0058 (0x0058 - 0x0000)
struct FPlayerstateDataCache final
{
public:
	TMap<class FName, struct FAwardedScores>      AwardedScoresByType;                               // 0x0000(0x0050)(NativeAccessSpecifierPublic)
	bool                                          IsDataCacheValid;                                  // 0x0050(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerstateDataCache) == 0x000008, "Wrong alignment on FPlayerstateDataCache");
static_assert(sizeof(FPlayerstateDataCache) == 0x000058, "Wrong size on FPlayerstateDataCache");
static_assert(offsetof(FPlayerstateDataCache, AwardedScoresByType) == 0x000000, "Member 'FPlayerstateDataCache::AwardedScoresByType' has a wrong offset!");
static_assert(offsetof(FPlayerstateDataCache, IsDataCacheValid) == 0x000050, "Member 'FPlayerstateDataCache::IsDataCacheValid' has a wrong offset!");

// ScriptStruct DeadByDaylight.MapSpecificSpawnActorData
// 0x0048 (0x0048 - 0x0000)
struct FMapSpecificSpawnActorData final
{
public:
	EGameplayElementType                          SpawnerType;                                       // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   ActorClass;                                        // 0x0008(0x0038)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumberToSpawn;                                     // 0x0040(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMapSpecificSpawnActorData) == 0x000008, "Wrong alignment on FMapSpecificSpawnActorData");
static_assert(sizeof(FMapSpecificSpawnActorData) == 0x000048, "Wrong size on FMapSpecificSpawnActorData");
static_assert(offsetof(FMapSpecificSpawnActorData, SpawnerType) == 0x000000, "Member 'FMapSpecificSpawnActorData::SpawnerType' has a wrong offset!");
static_assert(offsetof(FMapSpecificSpawnActorData, ActorClass) == 0x000008, "Member 'FMapSpecificSpawnActorData::ActorClass' has a wrong offset!");
static_assert(offsetof(FMapSpecificSpawnActorData, NumberToSpawn) == 0x000040, "Member 'FMapSpecificSpawnActorData::NumberToSpawn' has a wrong offset!");

// ScriptStruct DeadByDaylight.DBDSRItemData
// 0x0048 (0x0048 - 0x0000)
struct FDBDSRItemData final
{
public:
	class FName                                   ID;                                                // 0x0000(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        Amount;                                            // 0x000C(0x0002)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDBDSRItemType                                Type;                                              // 0x000E(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F[0x1];                                        // 0x000F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UAkAudioEvent>           AlertSFX;                                          // 0x0010(0x0038)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDBDSRItemData) == 0x000008, "Wrong alignment on FDBDSRItemData");
static_assert(sizeof(FDBDSRItemData) == 0x000048, "Wrong size on FDBDSRItemData");
static_assert(offsetof(FDBDSRItemData, ID) == 0x000000, "Member 'FDBDSRItemData::ID' has a wrong offset!");
static_assert(offsetof(FDBDSRItemData, Amount) == 0x00000C, "Member 'FDBDSRItemData::Amount' has a wrong offset!");
static_assert(offsetof(FDBDSRItemData, Type) == 0x00000E, "Member 'FDBDSRItemData::Type' has a wrong offset!");
static_assert(offsetof(FDBDSRItemData, AlertSFX) == 0x000010, "Member 'FDBDSRItemData::AlertSFX' has a wrong offset!");

// ScriptStruct DeadByDaylight.DBDSRComponentData
// 0x0018 (0x0018 - 0x0000)
struct FDBDSRComponentData final
{
public:
	class FName                                   ID;                                                // 0x0000(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UDBDSRComponent>            Class;                                             // 0x0010(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDBDSRComponentData) == 0x000008, "Wrong alignment on FDBDSRComponentData");
static_assert(sizeof(FDBDSRComponentData) == 0x000018, "Wrong size on FDBDSRComponentData");
static_assert(offsetof(FDBDSRComponentData, ID) == 0x000000, "Member 'FDBDSRComponentData::ID' has a wrong offset!");
static_assert(offsetof(FDBDSRComponentData, Class) == 0x000010, "Member 'FDBDSRComponentData::Class' has a wrong offset!");

// ScriptStruct DeadByDaylight.PerkInitializationData
// 0x0008 (0x0008 - 0x0000)
struct FPerkInitializationData final
{
public:
	int32                                         PerkLevel;                                         // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInputInteractionType                         ActivatableInteractionInputType;                   // 0x0004(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AuthorityDataSet;                                  // 0x0005(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPerkInitializationData) == 0x000004, "Wrong alignment on FPerkInitializationData");
static_assert(sizeof(FPerkInitializationData) == 0x000008, "Wrong size on FPerkInitializationData");
static_assert(offsetof(FPerkInitializationData, PerkLevel) == 0x000000, "Member 'FPerkInitializationData::PerkLevel' has a wrong offset!");
static_assert(offsetof(FPerkInitializationData, ActivatableInteractionInputType) == 0x000004, "Member 'FPerkInitializationData::ActivatableInteractionInputType' has a wrong offset!");
static_assert(offsetof(FPerkInitializationData, AuthorityDataSet) == 0x000005, "Member 'FPerkInitializationData::AuthorityDataSet' has a wrong offset!");

// ScriptStruct DeadByDaylight.DBDSRData
// 0x0060 (0x0068 - 0x0008)
struct FDBDSRData final : public FDBDTableRowBase
{
public:
	struct FDBDSRComponentData                    Component;                                         // 0x0008(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FDBDSRItemData                         ItemReward;                                        // 0x0020(0x0048)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDBDSRData) == 0x000008, "Wrong alignment on FDBDSRData");
static_assert(sizeof(FDBDSRData) == 0x000068, "Wrong size on FDBDSRData");
static_assert(offsetof(FDBDSRData, Component) == 0x000008, "Member 'FDBDSRData::Component' has a wrong offset!");
static_assert(offsetof(FDBDSRData, ItemReward) == 0x000020, "Member 'FDBDSRData::ItemReward' has a wrong offset!");

// ScriptStruct DeadByDaylight.StoreFeaturedChapterPackEditorData
// 0x0038 (0x0038 - 0x0000)
struct FStoreFeaturedChapterPackEditorData final
{
public:
	class FString                                 AssociatedDlcId;                                   // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        Image;                                             // 0x0010(0x0028)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStoreFeaturedChapterPackEditorData) == 0x000008, "Wrong alignment on FStoreFeaturedChapterPackEditorData");
static_assert(sizeof(FStoreFeaturedChapterPackEditorData) == 0x000038, "Wrong size on FStoreFeaturedChapterPackEditorData");
static_assert(offsetof(FStoreFeaturedChapterPackEditorData, AssociatedDlcId) == 0x000000, "Member 'FStoreFeaturedChapterPackEditorData::AssociatedDlcId' has a wrong offset!");
static_assert(offsetof(FStoreFeaturedChapterPackEditorData, Image) == 0x000010, "Member 'FStoreFeaturedChapterPackEditorData::Image' has a wrong offset!");

// ScriptStruct DeadByDaylight.StoreFeaturedChapterPackRecommendationEditorData
// 0x0050 (0x0058 - 0x0008)
struct FStoreFeaturedChapterPackRecommendationEditorData final : public FDBDTableRowBase
{
public:
	class FString                                 ID;                                                // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 InclusionVersion;                                  // 0x0018(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              ActiveFrom;                                        // 0x0028(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              ActiveTo;                                          // 0x0030(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FStoreFeaturedChapterPackEditorData> ChapterPacks;                                      // 0x0038(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x10];                                      // 0x0048(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStoreFeaturedChapterPackRecommendationEditorData) == 0x000008, "Wrong alignment on FStoreFeaturedChapterPackRecommendationEditorData");
static_assert(sizeof(FStoreFeaturedChapterPackRecommendationEditorData) == 0x000058, "Wrong size on FStoreFeaturedChapterPackRecommendationEditorData");
static_assert(offsetof(FStoreFeaturedChapterPackRecommendationEditorData, ID) == 0x000008, "Member 'FStoreFeaturedChapterPackRecommendationEditorData::ID' has a wrong offset!");
static_assert(offsetof(FStoreFeaturedChapterPackRecommendationEditorData, InclusionVersion) == 0x000018, "Member 'FStoreFeaturedChapterPackRecommendationEditorData::InclusionVersion' has a wrong offset!");
static_assert(offsetof(FStoreFeaturedChapterPackRecommendationEditorData, ActiveFrom) == 0x000028, "Member 'FStoreFeaturedChapterPackRecommendationEditorData::ActiveFrom' has a wrong offset!");
static_assert(offsetof(FStoreFeaturedChapterPackRecommendationEditorData, ActiveTo) == 0x000030, "Member 'FStoreFeaturedChapterPackRecommendationEditorData::ActiveTo' has a wrong offset!");
static_assert(offsetof(FStoreFeaturedChapterPackRecommendationEditorData, ChapterPacks) == 0x000038, "Member 'FStoreFeaturedChapterPackRecommendationEditorData::ChapterPacks' has a wrong offset!");

// ScriptStruct DeadByDaylight.PlayerFloatTuple
// 0x0010 (0x0010 - 0x0000)
struct FPlayerFloatTuple final
{
public:
	class ACharacter*                             Player;                                            // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerFloatTuple) == 0x000008, "Wrong alignment on FPlayerFloatTuple");
static_assert(sizeof(FPlayerFloatTuple) == 0x000010, "Wrong size on FPlayerFloatTuple");
static_assert(offsetof(FPlayerFloatTuple, Player) == 0x000000, "Member 'FPlayerFloatTuple::Player' has a wrong offset!");
static_assert(offsetof(FPlayerFloatTuple, Value) == 0x000008, "Member 'FPlayerFloatTuple::Value' has a wrong offset!");

// ScriptStruct DeadByDaylight.SurfaceTypeName
// 0x0010 (0x0018 - 0x0008)
struct FSurfaceTypeName final : public FDBDTableRowBase
{
public:
	class FName                                   Name;                                              // 0x0008(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSurfaceTypeName) == 0x000008, "Wrong alignment on FSurfaceTypeName");
static_assert(sizeof(FSurfaceTypeName) == 0x000018, "Wrong size on FSurfaceTypeName");
static_assert(offsetof(FSurfaceTypeName, Name) == 0x000008, "Member 'FSurfaceTypeName::Name' has a wrong offset!");

// ScriptStruct DeadByDaylight.ToastButton
// 0x0020 (0x0020 - 0x0000)
struct FToastButton final
{
public:
	class FText                                   ButtonText;                                        // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          IsRegression;                                      // 0x0018(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FToastButton) == 0x000008, "Wrong alignment on FToastButton");
static_assert(sizeof(FToastButton) == 0x000020, "Wrong size on FToastButton");
static_assert(offsetof(FToastButton, ButtonText) == 0x000000, "Member 'FToastButton::ButtonText' has a wrong offset!");
static_assert(offsetof(FToastButton, IsRegression) == 0x000018, "Member 'FToastButton::IsRegression' has a wrong offset!");

// ScriptStruct DeadByDaylight.Toast
// 0x00B0 (0x00B8 - 0x0008)
struct FToast final : public FDBDTableRowBase
{
public:
	float                                         DisplayDuration;                                   // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Lifetime;                                          // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ToastText;                                         // 0x0010(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<EToastInputType, struct FToastButton>    ButtonsData;                                       // 0x0028(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         DelayBeforeInteraction;                            // 0x0078(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UTexture2D>              ToastIcon;                                         // 0x0080(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FToast) == 0x000008, "Wrong alignment on FToast");
static_assert(sizeof(FToast) == 0x0000B8, "Wrong size on FToast");
static_assert(offsetof(FToast, DisplayDuration) == 0x000008, "Member 'FToast::DisplayDuration' has a wrong offset!");
static_assert(offsetof(FToast, Lifetime) == 0x00000C, "Member 'FToast::Lifetime' has a wrong offset!");
static_assert(offsetof(FToast, ToastText) == 0x000010, "Member 'FToast::ToastText' has a wrong offset!");
static_assert(offsetof(FToast, ButtonsData) == 0x000028, "Member 'FToast::ButtonsData' has a wrong offset!");
static_assert(offsetof(FToast, DelayBeforeInteraction) == 0x000078, "Member 'FToast::DelayBeforeInteraction' has a wrong offset!");
static_assert(offsetof(FToast, ToastIcon) == 0x000080, "Member 'FToast::ToastIcon' has a wrong offset!");

// ScriptStruct DeadByDaylight.MapMeshToAkAudioEvent
// 0x0048 (0x0048 - 0x0000)
struct FMapMeshToAkAudioEvent final
{
public:
	TSoftObjectPtr<class UStaticMesh>             Mesh;                                              // 0x0000(0x0038)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          SoundEvent;                                        // 0x0038(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinDelayBetweenEvents;                             // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinDelayBetweenObject;                             // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMapMeshToAkAudioEvent) == 0x000008, "Wrong alignment on FMapMeshToAkAudioEvent");
static_assert(sizeof(FMapMeshToAkAudioEvent) == 0x000048, "Wrong size on FMapMeshToAkAudioEvent");
static_assert(offsetof(FMapMeshToAkAudioEvent, Mesh) == 0x000000, "Member 'FMapMeshToAkAudioEvent::Mesh' has a wrong offset!");
static_assert(offsetof(FMapMeshToAkAudioEvent, SoundEvent) == 0x000038, "Member 'FMapMeshToAkAudioEvent::SoundEvent' has a wrong offset!");
static_assert(offsetof(FMapMeshToAkAudioEvent, MinDelayBetweenEvents) == 0x000040, "Member 'FMapMeshToAkAudioEvent::MinDelayBetweenEvents' has a wrong offset!");
static_assert(offsetof(FMapMeshToAkAudioEvent, MinDelayBetweenObject) == 0x000044, "Member 'FMapMeshToAkAudioEvent::MinDelayBetweenObject' has a wrong offset!");

// ScriptStruct DeadByDaylight.MenuRoleChangeEventData
// 0x0001 (0x0001 - 0x0000)
struct FMenuRoleChangeEventData final
{
public:
	EPlayerRole                                   PlayerRole;                                        // 0x0000(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMenuRoleChangeEventData) == 0x000001, "Wrong alignment on FMenuRoleChangeEventData");
static_assert(sizeof(FMenuRoleChangeEventData) == 0x000001, "Wrong size on FMenuRoleChangeEventData");
static_assert(offsetof(FMenuRoleChangeEventData, PlayerRole) == 0x000000, "Member 'FMenuRoleChangeEventData::PlayerRole' has a wrong offset!");

// ScriptStruct DeadByDaylight.MapSoundsToAvoid
// 0x0010 (0x0010 - 0x0000)
struct FMapSoundsToAvoid final
{
public:
	class UPrimitiveComponent*                    Component;                                         // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMapSoundsToAvoid) == 0x000008, "Wrong alignment on FMapSoundsToAvoid");
static_assert(sizeof(FMapSoundsToAvoid) == 0x000010, "Wrong size on FMapSoundsToAvoid");
static_assert(offsetof(FMapSoundsToAvoid, Component) == 0x000000, "Member 'FMapSoundsToAvoid::Component' has a wrong offset!");

// ScriptStruct DeadByDaylight.DBD_SoundSpawnerData
// 0x0028 (0x0028 - 0x0000)
struct FDBD_SoundSpawnerData final
{
public:
	TArray<TSoftClassPtr<class UClass>>           TriggerObject;                                     // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          TriggerVisualForCamper;                            // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TriggerVisualForSlasher;                           // 0x0011(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftClassPtr<class UClass>>           ActorToSpawnVisual;                                // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDBD_SoundSpawnerData) == 0x000008, "Wrong alignment on FDBD_SoundSpawnerData");
static_assert(sizeof(FDBD_SoundSpawnerData) == 0x000028, "Wrong size on FDBD_SoundSpawnerData");
static_assert(offsetof(FDBD_SoundSpawnerData, TriggerObject) == 0x000000, "Member 'FDBD_SoundSpawnerData::TriggerObject' has a wrong offset!");
static_assert(offsetof(FDBD_SoundSpawnerData, TriggerVisualForCamper) == 0x000010, "Member 'FDBD_SoundSpawnerData::TriggerVisualForCamper' has a wrong offset!");
static_assert(offsetof(FDBD_SoundSpawnerData, TriggerVisualForSlasher) == 0x000011, "Member 'FDBD_SoundSpawnerData::TriggerVisualForSlasher' has a wrong offset!");
static_assert(offsetof(FDBD_SoundSpawnerData, ActorToSpawnVisual) == 0x000018, "Member 'FDBD_SoundSpawnerData::ActorToSpawnVisual' has a wrong offset!");

// ScriptStruct DeadByDaylight.PlayerPerspectiveChangeTargetData
// 0x0020 (0x0020 - 0x0000)
struct FPlayerPerspectiveChangeTargetData final
{
public:
	bool                                          IsAFirstPersonView;                                // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        SceneComponent;                                    // 0x0008(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraDistanceFromFPVLocationToToggleFPVOnPlayer;  // 0x0010(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SocketNameOnSceneComponent;                        // 0x0014(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerPerspectiveChangeTargetData) == 0x000008, "Wrong alignment on FPlayerPerspectiveChangeTargetData");
static_assert(sizeof(FPlayerPerspectiveChangeTargetData) == 0x000020, "Wrong size on FPlayerPerspectiveChangeTargetData");
static_assert(offsetof(FPlayerPerspectiveChangeTargetData, IsAFirstPersonView) == 0x000000, "Member 'FPlayerPerspectiveChangeTargetData::IsAFirstPersonView' has a wrong offset!");
static_assert(offsetof(FPlayerPerspectiveChangeTargetData, SceneComponent) == 0x000008, "Member 'FPlayerPerspectiveChangeTargetData::SceneComponent' has a wrong offset!");
static_assert(offsetof(FPlayerPerspectiveChangeTargetData, CameraDistanceFromFPVLocationToToggleFPVOnPlayer) == 0x000010, "Member 'FPlayerPerspectiveChangeTargetData::CameraDistanceFromFPVLocationToToggleFPVOnPlayer' has a wrong offset!");
static_assert(offsetof(FPlayerPerspectiveChangeTargetData, SocketNameOnSceneComponent) == 0x000014, "Member 'FPlayerPerspectiveChangeTargetData::SocketNameOnSceneComponent' has a wrong offset!");

// ScriptStruct DeadByDaylight.DDosGameConfigDS
// 0x0002 (0x0002 - 0x0000)
struct FDDosGameConfigDS final
{
public:
	bool                                          DDoSDetection;                                     // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DDoSDetectionAnalytics;                            // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDDosGameConfigDS) == 0x000001, "Wrong alignment on FDDosGameConfigDS");
static_assert(sizeof(FDDosGameConfigDS) == 0x000002, "Wrong size on FDDosGameConfigDS");
static_assert(offsetof(FDDosGameConfigDS, DDoSDetection) == 0x000000, "Member 'FDDosGameConfigDS::DDoSDetection' has a wrong offset!");
static_assert(offsetof(FDDosGameConfigDS, DDoSDetectionAnalytics) == 0x000001, "Member 'FDDosGameConfigDS::DDoSDetectionAnalytics' has a wrong offset!");

// ScriptStruct DeadByDaylight.StoreFeaturedSingleChapterPackRecommendationData
// 0x00B0 (0x00B0 - 0x0000)
struct FStoreFeaturedSingleChapterPackRecommendationData final
{
public:
	class FString                                 AssociatedDlcId;                                   // 0x0000(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStoreFeaturedRecommendationImageData  Image;                                             // 0x0010(0x0010)(Transient, NativeAccessSpecifierPublic)
	struct FDateTime                              StartDate;                                         // 0x0020(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              EndDate;                                           // 0x0028(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   DisplayTitle;                                      // 0x0030(0x0018)(Transient, NativeAccessSpecifierPublic)
	TMap<class FString, class FString>            TitleByCulture;                                    // 0x0048(0x0050)(Transient, NativeAccessSpecifierPublic)
	bool                                          IsDLC;                                             // 0x0098(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsOwned;                                           // 0x0099(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9A[0x6];                                       // 0x009A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FStoreSpecialPackRuntimeItem>   FallbackContent;                                   // 0x00A0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStoreFeaturedSingleChapterPackRecommendationData) == 0x000008, "Wrong alignment on FStoreFeaturedSingleChapterPackRecommendationData");
static_assert(sizeof(FStoreFeaturedSingleChapterPackRecommendationData) == 0x0000B0, "Wrong size on FStoreFeaturedSingleChapterPackRecommendationData");
static_assert(offsetof(FStoreFeaturedSingleChapterPackRecommendationData, AssociatedDlcId) == 0x000000, "Member 'FStoreFeaturedSingleChapterPackRecommendationData::AssociatedDlcId' has a wrong offset!");
static_assert(offsetof(FStoreFeaturedSingleChapterPackRecommendationData, Image) == 0x000010, "Member 'FStoreFeaturedSingleChapterPackRecommendationData::Image' has a wrong offset!");
static_assert(offsetof(FStoreFeaturedSingleChapterPackRecommendationData, StartDate) == 0x000020, "Member 'FStoreFeaturedSingleChapterPackRecommendationData::StartDate' has a wrong offset!");
static_assert(offsetof(FStoreFeaturedSingleChapterPackRecommendationData, EndDate) == 0x000028, "Member 'FStoreFeaturedSingleChapterPackRecommendationData::EndDate' has a wrong offset!");
static_assert(offsetof(FStoreFeaturedSingleChapterPackRecommendationData, DisplayTitle) == 0x000030, "Member 'FStoreFeaturedSingleChapterPackRecommendationData::DisplayTitle' has a wrong offset!");
static_assert(offsetof(FStoreFeaturedSingleChapterPackRecommendationData, TitleByCulture) == 0x000048, "Member 'FStoreFeaturedSingleChapterPackRecommendationData::TitleByCulture' has a wrong offset!");
static_assert(offsetof(FStoreFeaturedSingleChapterPackRecommendationData, IsDLC) == 0x000098, "Member 'FStoreFeaturedSingleChapterPackRecommendationData::IsDLC' has a wrong offset!");
static_assert(offsetof(FStoreFeaturedSingleChapterPackRecommendationData, IsOwned) == 0x000099, "Member 'FStoreFeaturedSingleChapterPackRecommendationData::IsOwned' has a wrong offset!");
static_assert(offsetof(FStoreFeaturedSingleChapterPackRecommendationData, FallbackContent) == 0x0000A0, "Member 'FStoreFeaturedSingleChapterPackRecommendationData::FallbackContent' has a wrong offset!");

// ScriptStruct DeadByDaylight.StoreFeaturedChapterPackRecommendationData
// 0x0020 (0x0020 - 0x0000)
struct FStoreFeaturedChapterPackRecommendationData final
{
public:
	TArray<struct FStoreFeaturedSingleChapterPackRecommendationData> ChapterPacks;                                      // 0x0000(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	struct FDateTime                              ActiveFrom;                                        // 0x0010(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              ActiveTo;                                          // 0x0018(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStoreFeaturedChapterPackRecommendationData) == 0x000008, "Wrong alignment on FStoreFeaturedChapterPackRecommendationData");
static_assert(sizeof(FStoreFeaturedChapterPackRecommendationData) == 0x000020, "Wrong size on FStoreFeaturedChapterPackRecommendationData");
static_assert(offsetof(FStoreFeaturedChapterPackRecommendationData, ChapterPacks) == 0x000000, "Member 'FStoreFeaturedChapterPackRecommendationData::ChapterPacks' has a wrong offset!");
static_assert(offsetof(FStoreFeaturedChapterPackRecommendationData, ActiveFrom) == 0x000010, "Member 'FStoreFeaturedChapterPackRecommendationData::ActiveFrom' has a wrong offset!");
static_assert(offsetof(FStoreFeaturedChapterPackRecommendationData, ActiveTo) == 0x000018, "Member 'FStoreFeaturedChapterPackRecommendationData::ActiveTo' has a wrong offset!");

// ScriptStruct DeadByDaylight.DebugModelExtArchiveQuestEvent
// 0x0028 (0x0028 - 0x0000)
struct FDebugModelExtArchiveQuestEvent final
{
public:
	class FString                                 Parameters;                                        // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 QuestEventId;                                      // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Repetition;                                        // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDebugModelExtArchiveQuestEvent) == 0x000008, "Wrong alignment on FDebugModelExtArchiveQuestEvent");
static_assert(sizeof(FDebugModelExtArchiveQuestEvent) == 0x000028, "Wrong size on FDebugModelExtArchiveQuestEvent");
static_assert(offsetof(FDebugModelExtArchiveQuestEvent, Parameters) == 0x000000, "Member 'FDebugModelExtArchiveQuestEvent::Parameters' has a wrong offset!");
static_assert(offsetof(FDebugModelExtArchiveQuestEvent, QuestEventId) == 0x000010, "Member 'FDebugModelExtArchiveQuestEvent::QuestEventId' has a wrong offset!");
static_assert(offsetof(FDebugModelExtArchiveQuestEvent, Repetition) == 0x000020, "Member 'FDebugModelExtArchiveQuestEvent::Repetition' has a wrong offset!");

// ScriptStruct DeadByDaylight.NodeContentDistributionValue
// 0x0058 (0x0060 - 0x0008)
struct FNodeContentDistributionValue final : public FDBDTableRowBase
{
public:
	int32                                         Empty_Weight;                                      // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Empty_MinCount;                                    // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Empty_MaxCount;                                    // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Perks_Weight;                                      // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Perks_MinCount;                                    // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Perks_MaxCount;                                    // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PerksPacks_Weight;                                 // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PerksPacks_MinCount;                               // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PerksPacks_MaxCount;                               // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Offerings_Weight;                                  // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Offerings_MinCount;                                // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Offerings_MaxCount;                                // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Items_Weight;                                      // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Items_MinCount;                                    // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Items_MaxCount;                                    // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AddOn_Weight;                                      // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AddOn_MinCount;                                    // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AddOn_MaxCount;                                    // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Chests_Weight;                                     // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Chests_MinCount;                                   // 0x0054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Chests_MaxCount;                                   // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNodeContentDistributionValue) == 0x000008, "Wrong alignment on FNodeContentDistributionValue");
static_assert(sizeof(FNodeContentDistributionValue) == 0x000060, "Wrong size on FNodeContentDistributionValue");
static_assert(offsetof(FNodeContentDistributionValue, Empty_Weight) == 0x000008, "Member 'FNodeContentDistributionValue::Empty_Weight' has a wrong offset!");
static_assert(offsetof(FNodeContentDistributionValue, Empty_MinCount) == 0x00000C, "Member 'FNodeContentDistributionValue::Empty_MinCount' has a wrong offset!");
static_assert(offsetof(FNodeContentDistributionValue, Empty_MaxCount) == 0x000010, "Member 'FNodeContentDistributionValue::Empty_MaxCount' has a wrong offset!");
static_assert(offsetof(FNodeContentDistributionValue, Perks_Weight) == 0x000014, "Member 'FNodeContentDistributionValue::Perks_Weight' has a wrong offset!");
static_assert(offsetof(FNodeContentDistributionValue, Perks_MinCount) == 0x000018, "Member 'FNodeContentDistributionValue::Perks_MinCount' has a wrong offset!");
static_assert(offsetof(FNodeContentDistributionValue, Perks_MaxCount) == 0x00001C, "Member 'FNodeContentDistributionValue::Perks_MaxCount' has a wrong offset!");
static_assert(offsetof(FNodeContentDistributionValue, PerksPacks_Weight) == 0x000020, "Member 'FNodeContentDistributionValue::PerksPacks_Weight' has a wrong offset!");
static_assert(offsetof(FNodeContentDistributionValue, PerksPacks_MinCount) == 0x000024, "Member 'FNodeContentDistributionValue::PerksPacks_MinCount' has a wrong offset!");
static_assert(offsetof(FNodeContentDistributionValue, PerksPacks_MaxCount) == 0x000028, "Member 'FNodeContentDistributionValue::PerksPacks_MaxCount' has a wrong offset!");
static_assert(offsetof(FNodeContentDistributionValue, Offerings_Weight) == 0x00002C, "Member 'FNodeContentDistributionValue::Offerings_Weight' has a wrong offset!");
static_assert(offsetof(FNodeContentDistributionValue, Offerings_MinCount) == 0x000030, "Member 'FNodeContentDistributionValue::Offerings_MinCount' has a wrong offset!");
static_assert(offsetof(FNodeContentDistributionValue, Offerings_MaxCount) == 0x000034, "Member 'FNodeContentDistributionValue::Offerings_MaxCount' has a wrong offset!");
static_assert(offsetof(FNodeContentDistributionValue, Items_Weight) == 0x000038, "Member 'FNodeContentDistributionValue::Items_Weight' has a wrong offset!");
static_assert(offsetof(FNodeContentDistributionValue, Items_MinCount) == 0x00003C, "Member 'FNodeContentDistributionValue::Items_MinCount' has a wrong offset!");
static_assert(offsetof(FNodeContentDistributionValue, Items_MaxCount) == 0x000040, "Member 'FNodeContentDistributionValue::Items_MaxCount' has a wrong offset!");
static_assert(offsetof(FNodeContentDistributionValue, AddOn_Weight) == 0x000044, "Member 'FNodeContentDistributionValue::AddOn_Weight' has a wrong offset!");
static_assert(offsetof(FNodeContentDistributionValue, AddOn_MinCount) == 0x000048, "Member 'FNodeContentDistributionValue::AddOn_MinCount' has a wrong offset!");
static_assert(offsetof(FNodeContentDistributionValue, AddOn_MaxCount) == 0x00004C, "Member 'FNodeContentDistributionValue::AddOn_MaxCount' has a wrong offset!");
static_assert(offsetof(FNodeContentDistributionValue, Chests_Weight) == 0x000050, "Member 'FNodeContentDistributionValue::Chests_Weight' has a wrong offset!");
static_assert(offsetof(FNodeContentDistributionValue, Chests_MinCount) == 0x000054, "Member 'FNodeContentDistributionValue::Chests_MinCount' has a wrong offset!");
static_assert(offsetof(FNodeContentDistributionValue, Chests_MaxCount) == 0x000058, "Member 'FNodeContentDistributionValue::Chests_MaxCount' has a wrong offset!");

// ScriptStruct DeadByDaylight.DebugModelExtArchiveQuestSpecialBehaviours
// 0x0020 (0x0020 - 0x0000)
struct FDebugModelExtArchiveQuestSpecialBehaviours final
{
public:
	class FString                                 ID;                                                // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Params;                                            // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDebugModelExtArchiveQuestSpecialBehaviours) == 0x000008, "Wrong alignment on FDebugModelExtArchiveQuestSpecialBehaviours");
static_assert(sizeof(FDebugModelExtArchiveQuestSpecialBehaviours) == 0x000020, "Wrong size on FDebugModelExtArchiveQuestSpecialBehaviours");
static_assert(offsetof(FDebugModelExtArchiveQuestSpecialBehaviours, ID) == 0x000000, "Member 'FDebugModelExtArchiveQuestSpecialBehaviours::ID' has a wrong offset!");
static_assert(offsetof(FDebugModelExtArchiveQuestSpecialBehaviours, Params) == 0x000010, "Member 'FDebugModelExtArchiveQuestSpecialBehaviours::Params' has a wrong offset!");

// ScriptStruct DeadByDaylight.DebugQuestModelExtArchiveCondition
// 0x0020 (0x0020 - 0x0000)
struct FDebugQuestModelExtArchiveCondition final
{
public:
	class FString                                 Key;                                               // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         Value;                                             // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDebugQuestModelExtArchiveCondition) == 0x000008, "Wrong alignment on FDebugQuestModelExtArchiveCondition");
static_assert(sizeof(FDebugQuestModelExtArchiveCondition) == 0x000020, "Wrong size on FDebugQuestModelExtArchiveCondition");
static_assert(offsetof(FDebugQuestModelExtArchiveCondition, Key) == 0x000000, "Member 'FDebugQuestModelExtArchiveCondition::Key' has a wrong offset!");
static_assert(offsetof(FDebugQuestModelExtArchiveCondition, Value) == 0x000010, "Member 'FDebugQuestModelExtArchiveCondition::Value' has a wrong offset!");

// ScriptStruct DeadByDaylight.DebugQuestModelExtArchiveObjective
// 0x0038 (0x0038 - 0x0000)
struct FDebugQuestModelExtArchiveObjective final
{
public:
	TArray<struct FDebugQuestModelExtArchiveCondition> Conditions;                                        // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         NeededProgression;                                 // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FDebugModelExtArchiveQuestEvent> QuestEvents;                                       // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FDebugModelExtArchiveQuestSpecialBehaviours> SpecialBehaviours;                                 // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDebugQuestModelExtArchiveObjective) == 0x000008, "Wrong alignment on FDebugQuestModelExtArchiveObjective");
static_assert(sizeof(FDebugQuestModelExtArchiveObjective) == 0x000038, "Wrong size on FDebugQuestModelExtArchiveObjective");
static_assert(offsetof(FDebugQuestModelExtArchiveObjective, Conditions) == 0x000000, "Member 'FDebugQuestModelExtArchiveObjective::Conditions' has a wrong offset!");
static_assert(offsetof(FDebugQuestModelExtArchiveObjective, NeededProgression) == 0x000010, "Member 'FDebugQuestModelExtArchiveObjective::NeededProgression' has a wrong offset!");
static_assert(offsetof(FDebugQuestModelExtArchiveObjective, QuestEvents) == 0x000018, "Member 'FDebugQuestModelExtArchiveObjective::QuestEvents' has a wrong offset!");
static_assert(offsetof(FDebugQuestModelExtArchiveObjective, SpecialBehaviours) == 0x000028, "Member 'FDebugQuestModelExtArchiveObjective::SpecialBehaviours' has a wrong offset!");

// ScriptStruct DeadByDaylight.DedicatedServerGameConfig
// 0x0018 (0x0018 - 0x0000)
struct FDedicatedServerGameConfig final
{
public:
	int32                                         LatencyRetryCooldownSeconds;                       // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         SuspiciousEnabledBuilds;                           // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDedicatedServerGameConfig) == 0x000008, "Wrong alignment on FDedicatedServerGameConfig");
static_assert(sizeof(FDedicatedServerGameConfig) == 0x000018, "Wrong size on FDedicatedServerGameConfig");
static_assert(offsetof(FDedicatedServerGameConfig, LatencyRetryCooldownSeconds) == 0x000000, "Member 'FDedicatedServerGameConfig::LatencyRetryCooldownSeconds' has a wrong offset!");
static_assert(offsetof(FDedicatedServerGameConfig, SuspiciousEnabledBuilds) == 0x000008, "Member 'FDedicatedServerGameConfig::SuspiciousEnabledBuilds' has a wrong offset!");

// ScriptStruct DeadByDaylight.NamedButton
// 0x0018 (0x0018 - 0x0000)
struct FNamedButton final
{
public:
	int32                                         ClickCounter;                                      // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DisplayName;                                       // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNamedButton) == 0x000008, "Wrong alignment on FNamedButton");
static_assert(sizeof(FNamedButton) == 0x000018, "Wrong size on FNamedButton");
static_assert(offsetof(FNamedButton, ClickCounter) == 0x000000, "Member 'FNamedButton::ClickCounter' has a wrong offset!");
static_assert(offsetof(FNamedButton, DisplayName) == 0x000008, "Member 'FNamedButton::DisplayName' has a wrong offset!");

// ScriptStruct DeadByDaylight.DedicatedSessionSearchCompletedEventData
// 0x0088 (0x0088 - 0x0000)
struct FDedicatedSessionSearchCompletedEventData final
{
public:
	class FString                                 GameLiftSessionId;                                 // 0x0000(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MatchID;                                           // 0x0010(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FleetId;                                           // 0x0020(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 IpAddress;                                         // 0x0030(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Port;                                              // 0x0040(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DnsName;                                           // 0x0048(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Region;                                            // 0x0058(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FleetType;                                         // 0x0068(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 InstanceType;                                      // 0x0078(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDedicatedSessionSearchCompletedEventData) == 0x000008, "Wrong alignment on FDedicatedSessionSearchCompletedEventData");
static_assert(sizeof(FDedicatedSessionSearchCompletedEventData) == 0x000088, "Wrong size on FDedicatedSessionSearchCompletedEventData");
static_assert(offsetof(FDedicatedSessionSearchCompletedEventData, GameLiftSessionId) == 0x000000, "Member 'FDedicatedSessionSearchCompletedEventData::GameLiftSessionId' has a wrong offset!");
static_assert(offsetof(FDedicatedSessionSearchCompletedEventData, MatchID) == 0x000010, "Member 'FDedicatedSessionSearchCompletedEventData::MatchID' has a wrong offset!");
static_assert(offsetof(FDedicatedSessionSearchCompletedEventData, FleetId) == 0x000020, "Member 'FDedicatedSessionSearchCompletedEventData::FleetId' has a wrong offset!");
static_assert(offsetof(FDedicatedSessionSearchCompletedEventData, IpAddress) == 0x000030, "Member 'FDedicatedSessionSearchCompletedEventData::IpAddress' has a wrong offset!");
static_assert(offsetof(FDedicatedSessionSearchCompletedEventData, Port) == 0x000040, "Member 'FDedicatedSessionSearchCompletedEventData::Port' has a wrong offset!");
static_assert(offsetof(FDedicatedSessionSearchCompletedEventData, DnsName) == 0x000048, "Member 'FDedicatedSessionSearchCompletedEventData::DnsName' has a wrong offset!");
static_assert(offsetof(FDedicatedSessionSearchCompletedEventData, Region) == 0x000058, "Member 'FDedicatedSessionSearchCompletedEventData::Region' has a wrong offset!");
static_assert(offsetof(FDedicatedSessionSearchCompletedEventData, FleetType) == 0x000068, "Member 'FDedicatedSessionSearchCompletedEventData::FleetType' has a wrong offset!");
static_assert(offsetof(FDedicatedSessionSearchCompletedEventData, InstanceType) == 0x000078, "Member 'FDedicatedSessionSearchCompletedEventData::InstanceType' has a wrong offset!");

// ScriptStruct DeadByDaylight.ResolutionQualityPair
// 0x0018 (0x0020 - 0x0008)
struct FResolutionQualityPair final : public FDBDTableRowBase
{
public:
	int32                                         ResX;                                              // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ResY;                                              // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Quality;                                           // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AutoAdjust;                                        // 0x0014(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ScreenScaleForWindowedMode;                        // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ScreenResolution;                                  // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FResolutionQualityPair) == 0x000008, "Wrong alignment on FResolutionQualityPair");
static_assert(sizeof(FResolutionQualityPair) == 0x000020, "Wrong size on FResolutionQualityPair");
static_assert(offsetof(FResolutionQualityPair, ResX) == 0x000008, "Member 'FResolutionQualityPair::ResX' has a wrong offset!");
static_assert(offsetof(FResolutionQualityPair, ResY) == 0x00000C, "Member 'FResolutionQualityPair::ResY' has a wrong offset!");
static_assert(offsetof(FResolutionQualityPair, Quality) == 0x000010, "Member 'FResolutionQualityPair::Quality' has a wrong offset!");
static_assert(offsetof(FResolutionQualityPair, AutoAdjust) == 0x000014, "Member 'FResolutionQualityPair::AutoAdjust' has a wrong offset!");
static_assert(offsetof(FResolutionQualityPair, ScreenScaleForWindowedMode) == 0x000018, "Member 'FResolutionQualityPair::ScreenScaleForWindowedMode' has a wrong offset!");
static_assert(offsetof(FResolutionQualityPair, ScreenResolution) == 0x00001C, "Member 'FResolutionQualityPair::ScreenResolution' has a wrong offset!");

// ScriptStruct DeadByDaylight.PCDeviceProfiles
// 0x0028 (0x0030 - 0x0008)
struct FPCDeviceProfiles final : public FDBDTableRowBase
{
public:
	class FName                                   Cpu;                                               // 0x0008(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   GPU;                                               // 0x0014(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FResolutionQualityPair>         Pairs;                                             // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPCDeviceProfiles) == 0x000008, "Wrong alignment on FPCDeviceProfiles");
static_assert(sizeof(FPCDeviceProfiles) == 0x000030, "Wrong size on FPCDeviceProfiles");
static_assert(offsetof(FPCDeviceProfiles, Cpu) == 0x000008, "Member 'FPCDeviceProfiles::Cpu' has a wrong offset!");
static_assert(offsetof(FPCDeviceProfiles, GPU) == 0x000014, "Member 'FPCDeviceProfiles::GPU' has a wrong offset!");
static_assert(offsetof(FPCDeviceProfiles, Pairs) == 0x000020, "Member 'FPCDeviceProfiles::Pairs' has a wrong offset!");

// ScriptStruct DeadByDaylight.LoadoutSlotUnlockLevelValue
// 0x0008 (0x0010 - 0x0008)
struct FLoadoutSlotUnlockLevelValue final : public FDBDTableRowBase
{
public:
	ELoadoutSlot                                  LoadoutSlot;                                       // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         BloodWebLevel;                                     // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLoadoutSlotUnlockLevelValue) == 0x000008, "Wrong alignment on FLoadoutSlotUnlockLevelValue");
static_assert(sizeof(FLoadoutSlotUnlockLevelValue) == 0x000010, "Wrong size on FLoadoutSlotUnlockLevelValue");
static_assert(offsetof(FLoadoutSlotUnlockLevelValue, LoadoutSlot) == 0x000008, "Member 'FLoadoutSlotUnlockLevelValue::LoadoutSlot' has a wrong offset!");
static_assert(offsetof(FLoadoutSlotUnlockLevelValue, BloodWebLevel) == 0x00000C, "Member 'FLoadoutSlotUnlockLevelValue::BloodWebLevel' has a wrong offset!");

// ScriptStruct DeadByDaylight.DisplayStandControllerData
// 0x00D0 (0x00D0 - 0x0000)
struct alignas(0x08) FDisplayStandControllerData final
{
public:
	uint8                                         Pad_0[0xD0];                                       // 0x0000(0x00D0)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDisplayStandControllerData) == 0x000008, "Wrong alignment on FDisplayStandControllerData");
static_assert(sizeof(FDisplayStandControllerData) == 0x0000D0, "Wrong size on FDisplayStandControllerData");

// ScriptStruct DeadByDaylight.DisplayStandMeatHookOverride
// 0x0070 (0x0078 - 0x0008)
struct FDisplayStandMeatHookOverride final : public FDBDTableRowBase
{
public:
	class FString                                 OverrideId;                                        // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDisplayStandMeatHookOverrideType             OverrideType;                                      // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CharacterIndex;                                    // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EventName;                                         // 0x0020(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   HookToUse;                                         // 0x0030(0x0038)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_68[0x10];                                      // 0x0068(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDisplayStandMeatHookOverride) == 0x000008, "Wrong alignment on FDisplayStandMeatHookOverride");
static_assert(sizeof(FDisplayStandMeatHookOverride) == 0x000078, "Wrong size on FDisplayStandMeatHookOverride");
static_assert(offsetof(FDisplayStandMeatHookOverride, OverrideId) == 0x000008, "Member 'FDisplayStandMeatHookOverride::OverrideId' has a wrong offset!");
static_assert(offsetof(FDisplayStandMeatHookOverride, OverrideType) == 0x000018, "Member 'FDisplayStandMeatHookOverride::OverrideType' has a wrong offset!");
static_assert(offsetof(FDisplayStandMeatHookOverride, CharacterIndex) == 0x00001C, "Member 'FDisplayStandMeatHookOverride::CharacterIndex' has a wrong offset!");
static_assert(offsetof(FDisplayStandMeatHookOverride, EventName) == 0x000020, "Member 'FDisplayStandMeatHookOverride::EventName' has a wrong offset!");
static_assert(offsetof(FDisplayStandMeatHookOverride, HookToUse) == 0x000030, "Member 'FDisplayStandMeatHookOverride::HookToUse' has a wrong offset!");

// ScriptStruct DeadByDaylight.DownloadProgression
// 0x0030 (0x0030 - 0x0000)
struct FDownloadProgression final
{
public:
	float                                         DownloadSize;                                      // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TotalDownloadedSize;                               // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DownloadSpeed;                                     // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InstallProgress;                                   // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsDownloading;                                     // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DownloadStatus;                                    // 0x0018(0x0018)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FDownloadProgression) == 0x000008, "Wrong alignment on FDownloadProgression");
static_assert(sizeof(FDownloadProgression) == 0x000030, "Wrong size on FDownloadProgression");
static_assert(offsetof(FDownloadProgression, DownloadSize) == 0x000000, "Member 'FDownloadProgression::DownloadSize' has a wrong offset!");
static_assert(offsetof(FDownloadProgression, TotalDownloadedSize) == 0x000004, "Member 'FDownloadProgression::TotalDownloadedSize' has a wrong offset!");
static_assert(offsetof(FDownloadProgression, DownloadSpeed) == 0x000008, "Member 'FDownloadProgression::DownloadSpeed' has a wrong offset!");
static_assert(offsetof(FDownloadProgression, InstallProgress) == 0x00000C, "Member 'FDownloadProgression::InstallProgress' has a wrong offset!");
static_assert(offsetof(FDownloadProgression, IsDownloading) == 0x000010, "Member 'FDownloadProgression::IsDownloading' has a wrong offset!");
static_assert(offsetof(FDownloadProgression, DownloadStatus) == 0x000018, "Member 'FDownloadProgression::DownloadStatus' has a wrong offset!");

// ScriptStruct DeadByDaylight.EffectsLocatorTargets
// 0x0008 (0x0008 - 0x0000)
struct FEffectsLocatorTargets final
{
public:
	TSubclassOf<class AActor>                     TargetActorClass;                                  // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEffectsLocatorTargets) == 0x000008, "Wrong alignment on FEffectsLocatorTargets");
static_assert(sizeof(FEffectsLocatorTargets) == 0x000008, "Wrong size on FEffectsLocatorTargets");
static_assert(offsetof(FEffectsLocatorTargets, TargetActorClass) == 0x000000, "Member 'FEffectsLocatorTargets::TargetActorClass' has a wrong offset!");

// ScriptStruct DeadByDaylight.SpawnConditions
// 0x0004 (0x0004 - 0x0000)
struct FSpawnConditions final
{
public:
	float                                         MinProximity;                                      // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpawnConditions) == 0x000004, "Wrong alignment on FSpawnConditions");
static_assert(sizeof(FSpawnConditions) == 0x000004, "Wrong size on FSpawnConditions");
static_assert(offsetof(FSpawnConditions, MinProximity) == 0x000000, "Member 'FSpawnConditions::MinProximity' has a wrong offset!");

// ScriptStruct DeadByDaylight.ElementSpawnConditionsData
// 0x00B8 (0x00C0 - 0x0008)
struct FElementSpawnConditionsData final : public FDBDTableRowBase
{
public:
	class FName                                   Name;                                              // 0x0008(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ETileSpawnPointType, struct FSpawnConditions> DependencyElementConditions;                       // 0x0018(0x0050)(Edit, NativeAccessSpecifierPublic)
	TMap<EGameplayElementType, struct FSpawnConditions> GameplayElementConditions;                         // 0x0068(0x0050)(Edit, NativeAccessSpecifierPublic)
	struct FSpawnConditions                       OtherSelvesConditions;                             // 0x00B8(0x0004)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FElementSpawnConditionsData) == 0x000008, "Wrong alignment on FElementSpawnConditionsData");
static_assert(sizeof(FElementSpawnConditionsData) == 0x0000C0, "Wrong size on FElementSpawnConditionsData");
static_assert(offsetof(FElementSpawnConditionsData, Name) == 0x000008, "Member 'FElementSpawnConditionsData::Name' has a wrong offset!");
static_assert(offsetof(FElementSpawnConditionsData, DependencyElementConditions) == 0x000018, "Member 'FElementSpawnConditionsData::DependencyElementConditions' has a wrong offset!");
static_assert(offsetof(FElementSpawnConditionsData, GameplayElementConditions) == 0x000068, "Member 'FElementSpawnConditionsData::GameplayElementConditions' has a wrong offset!");
static_assert(offsetof(FElementSpawnConditionsData, OtherSelvesConditions) == 0x0000B8, "Member 'FElementSpawnConditionsData::OtherSelvesConditions' has a wrong offset!");

// ScriptStruct DeadByDaylight.EmblemProgressionData
// 0x0018 (0x0018 - 0x0000)
struct FEmblemProgressionData final
{
public:
	class FString                                 ProgressionText;                                   // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProgressionPercent;                                // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEmblemProgressionData) == 0x000008, "Wrong alignment on FEmblemProgressionData");
static_assert(sizeof(FEmblemProgressionData) == 0x000018, "Wrong size on FEmblemProgressionData");
static_assert(offsetof(FEmblemProgressionData, ProgressionText) == 0x000000, "Member 'FEmblemProgressionData::ProgressionText' has a wrong offset!");
static_assert(offsetof(FEmblemProgressionData, ProgressionPercent) == 0x000010, "Member 'FEmblemProgressionData::ProgressionPercent' has a wrong offset!");

// ScriptStruct DeadByDaylight.EmblemSlotData
// 0x0080 (0x0080 - 0x0000)
struct FEmblemSlotData final
{
public:
	EEmblemQuality                                Quality;                                           // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 QualityNameUpper;                                  // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Title;                                             // 0x0018(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Description;                                       // 0x0028(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Score;                                             // 0x0038(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         IconPaths;                                         // 0x0040(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<int32>                                 ThresholdPoints;                                   // 0x0050(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	float                                         CurrentPoints;                                     // 0x0060(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FEmblemProgressionData>         ProgressionData;                                   // 0x0068(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	int32                                         CharacterExperience;                               // 0x0078(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEmblemSlotData) == 0x000008, "Wrong alignment on FEmblemSlotData");
static_assert(sizeof(FEmblemSlotData) == 0x000080, "Wrong size on FEmblemSlotData");
static_assert(offsetof(FEmblemSlotData, Quality) == 0x000000, "Member 'FEmblemSlotData::Quality' has a wrong offset!");
static_assert(offsetof(FEmblemSlotData, QualityNameUpper) == 0x000008, "Member 'FEmblemSlotData::QualityNameUpper' has a wrong offset!");
static_assert(offsetof(FEmblemSlotData, Title) == 0x000018, "Member 'FEmblemSlotData::Title' has a wrong offset!");
static_assert(offsetof(FEmblemSlotData, Description) == 0x000028, "Member 'FEmblemSlotData::Description' has a wrong offset!");
static_assert(offsetof(FEmblemSlotData, Score) == 0x000038, "Member 'FEmblemSlotData::Score' has a wrong offset!");
static_assert(offsetof(FEmblemSlotData, IconPaths) == 0x000040, "Member 'FEmblemSlotData::IconPaths' has a wrong offset!");
static_assert(offsetof(FEmblemSlotData, ThresholdPoints) == 0x000050, "Member 'FEmblemSlotData::ThresholdPoints' has a wrong offset!");
static_assert(offsetof(FEmblemSlotData, CurrentPoints) == 0x000060, "Member 'FEmblemSlotData::CurrentPoints' has a wrong offset!");
static_assert(offsetof(FEmblemSlotData, ProgressionData) == 0x000068, "Member 'FEmblemSlotData::ProgressionData' has a wrong offset!");
static_assert(offsetof(FEmblemSlotData, CharacterExperience) == 0x000078, "Member 'FEmblemSlotData::CharacterExperience' has a wrong offset!");

// ScriptStruct DeadByDaylight.TileProperties
// 0x0078 (0x0078 - 0x0000)
struct alignas(0x08) FTileProperties final
{
public:
	uint8                                         Pad_0[0x78];                                       // 0x0000(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTileProperties) == 0x000008, "Wrong alignment on FTileProperties");
static_assert(sizeof(FTileProperties) == 0x000078, "Wrong size on FTileProperties");

// ScriptStruct DeadByDaylight.EventSpawnablePositionData
// 0x0028 (0x0030 - 0x0008)
struct FEventSpawnablePositionData final : public FDBDTableRowBase
{
public:
	class FName                                   Name;                                              // 0x0008(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                BoundOffsetMultiplier;                             // 0x0018(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEventSpawnablePositionData) == 0x000008, "Wrong alignment on FEventSpawnablePositionData");
static_assert(sizeof(FEventSpawnablePositionData) == 0x000030, "Wrong size on FEventSpawnablePositionData");
static_assert(offsetof(FEventSpawnablePositionData, Name) == 0x000008, "Member 'FEventSpawnablePositionData::Name' has a wrong offset!");
static_assert(offsetof(FEventSpawnablePositionData, BoundOffsetMultiplier) == 0x000018, "Member 'FEventSpawnablePositionData::BoundOffsetMultiplier' has a wrong offset!");

// ScriptStruct DeadByDaylight.EventSpawnableShapePresetData
// 0x0048 (0x0050 - 0x0008)
struct FEventSpawnableShapePresetData final : public FDBDTableRowBase
{
public:
	class FName                                   Name;                                              // 0x0008(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                MinBound;                                          // 0x0018(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MaxBound;                                          // 0x0030(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SpawnPriorityTier;                                 // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEventSpawnableShapePresetData) == 0x000008, "Wrong alignment on FEventSpawnableShapePresetData");
static_assert(sizeof(FEventSpawnableShapePresetData) == 0x000050, "Wrong size on FEventSpawnableShapePresetData");
static_assert(offsetof(FEventSpawnableShapePresetData, Name) == 0x000008, "Member 'FEventSpawnableShapePresetData::Name' has a wrong offset!");
static_assert(offsetof(FEventSpawnableShapePresetData, MinBound) == 0x000018, "Member 'FEventSpawnableShapePresetData::MinBound' has a wrong offset!");
static_assert(offsetof(FEventSpawnableShapePresetData, MaxBound) == 0x000030, "Member 'FEventSpawnableShapePresetData::MaxBound' has a wrong offset!");
static_assert(offsetof(FEventSpawnableShapePresetData, SpawnPriorityTier) == 0x000048, "Member 'FEventSpawnableShapePresetData::SpawnPriorityTier' has a wrong offset!");

// ScriptStruct DeadByDaylight.EventSpawnableSizeData
// 0x0018 (0x0020 - 0x0008)
struct FEventSpawnableSizeData final : public FDBDTableRowBase
{
public:
	class FName                                   SizeType;                                          // 0x0008(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinVolume;                                         // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxVolume;                                         // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Budget;                                            // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEventSpawnableSizeData) == 0x000008, "Wrong alignment on FEventSpawnableSizeData");
static_assert(sizeof(FEventSpawnableSizeData) == 0x000020, "Wrong size on FEventSpawnableSizeData");
static_assert(offsetof(FEventSpawnableSizeData, SizeType) == 0x000008, "Member 'FEventSpawnableSizeData::SizeType' has a wrong offset!");
static_assert(offsetof(FEventSpawnableSizeData, MinVolume) == 0x000014, "Member 'FEventSpawnableSizeData::MinVolume' has a wrong offset!");
static_assert(offsetof(FEventSpawnableSizeData, MaxVolume) == 0x000018, "Member 'FEventSpawnableSizeData::MaxVolume' has a wrong offset!");
static_assert(offsetof(FEventSpawnableSizeData, Budget) == 0x00001C, "Member 'FEventSpawnableSizeData::Budget' has a wrong offset!");

// ScriptStruct DeadByDaylight.OfferingCategoryData
// 0x0150 (0x0158 - 0x0008)
struct FOfferingCategoryData final : public FDBDTableRowBase
{
public:
	EOfferingCategory                             OfferingCategory;                                  // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EPlayerRole>                           Role;                                              // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FItemUIData                            UIData;                                            // 0x0020(0x0138)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOfferingCategoryData) == 0x000008, "Wrong alignment on FOfferingCategoryData");
static_assert(sizeof(FOfferingCategoryData) == 0x000158, "Wrong size on FOfferingCategoryData");
static_assert(offsetof(FOfferingCategoryData, OfferingCategory) == 0x000008, "Member 'FOfferingCategoryData::OfferingCategory' has a wrong offset!");
static_assert(offsetof(FOfferingCategoryData, Role) == 0x000010, "Member 'FOfferingCategoryData::Role' has a wrong offset!");
static_assert(offsetof(FOfferingCategoryData, UIData) == 0x000020, "Member 'FOfferingCategoryData::UIData' has a wrong offset!");

// ScriptStruct DeadByDaylight.SurvivorItemProperties
// 0x000C (0x000C - 0x0000)
struct FSurvivorItemProperties final
{
public:
	ECollectableCategory                          Category;                                          // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Weight;                                            // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxPopulation;                                     // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSurvivorItemProperties) == 0x000004, "Wrong alignment on FSurvivorItemProperties");
static_assert(sizeof(FSurvivorItemProperties) == 0x00000C, "Wrong size on FSurvivorItemProperties");
static_assert(offsetof(FSurvivorItemProperties, Category) == 0x000000, "Member 'FSurvivorItemProperties::Category' has a wrong offset!");
static_assert(offsetof(FSurvivorItemProperties, Weight) == 0x000004, "Member 'FSurvivorItemProperties::Weight' has a wrong offset!");
static_assert(offsetof(FSurvivorItemProperties, MaxPopulation) == 0x000008, "Member 'FSurvivorItemProperties::MaxPopulation' has a wrong offset!");

// ScriptStruct DeadByDaylight.S3ContentVersionConfig
// 0x0018 (0x0018 - 0x0000)
struct FS3ContentVersionConfig final
{
public:
	bool                                          DsNewContentShutdown;                              // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DsNewContentShutdownMinMinutes;                    // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DsNewContentShutdownMaxMinutes;                    // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ClientNewContentForceReboot;                       // 0x000C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DsNewContentCatalogItemValidation;                 // 0x000D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E[0x2];                                        // 0x000E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ClientNewContentRebootMinSeconds;                  // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClientNewContentRebootMaxSeconds;                  // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FS3ContentVersionConfig) == 0x000004, "Wrong alignment on FS3ContentVersionConfig");
static_assert(sizeof(FS3ContentVersionConfig) == 0x000018, "Wrong size on FS3ContentVersionConfig");
static_assert(offsetof(FS3ContentVersionConfig, DsNewContentShutdown) == 0x000000, "Member 'FS3ContentVersionConfig::DsNewContentShutdown' has a wrong offset!");
static_assert(offsetof(FS3ContentVersionConfig, DsNewContentShutdownMinMinutes) == 0x000004, "Member 'FS3ContentVersionConfig::DsNewContentShutdownMinMinutes' has a wrong offset!");
static_assert(offsetof(FS3ContentVersionConfig, DsNewContentShutdownMaxMinutes) == 0x000008, "Member 'FS3ContentVersionConfig::DsNewContentShutdownMaxMinutes' has a wrong offset!");
static_assert(offsetof(FS3ContentVersionConfig, ClientNewContentForceReboot) == 0x00000C, "Member 'FS3ContentVersionConfig::ClientNewContentForceReboot' has a wrong offset!");
static_assert(offsetof(FS3ContentVersionConfig, DsNewContentCatalogItemValidation) == 0x00000D, "Member 'FS3ContentVersionConfig::DsNewContentCatalogItemValidation' has a wrong offset!");
static_assert(offsetof(FS3ContentVersionConfig, ClientNewContentRebootMinSeconds) == 0x000010, "Member 'FS3ContentVersionConfig::ClientNewContentRebootMinSeconds' has a wrong offset!");
static_assert(offsetof(FS3ContentVersionConfig, ClientNewContentRebootMaxSeconds) == 0x000014, "Member 'FS3ContentVersionConfig::ClientNewContentRebootMaxSeconds' has a wrong offset!");

// ScriptStruct DeadByDaylight.ExperimentData
// 0x0010 (0x0018 - 0x0008)
struct FExperimentData final : public FDBDTableRowBase
{
public:
	TArray<class FName>                           AdditionalIds;                                     // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FExperimentData) == 0x000008, "Wrong alignment on FExperimentData");
static_assert(sizeof(FExperimentData) == 0x000018, "Wrong size on FExperimentData");
static_assert(offsetof(FExperimentData, AdditionalIds) == 0x000008, "Member 'FExperimentData::AdditionalIds' has a wrong offset!");

// ScriptStruct DeadByDaylight.PathPosition
// 0x0030 (0x0030 - 0x0000)
struct alignas(0x08) FPathPosition final
{
public:
	uint8                                         Pad_0[0x30];                                       // 0x0000(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPathPosition) == 0x000008, "Wrong alignment on FPathPosition");
static_assert(sizeof(FPathPosition) == 0x000030, "Wrong size on FPathPosition");

// ScriptStruct DeadByDaylight.PurchaseItemUIData
// 0x0050 (0x0050 - 0x0000)
struct FPurchaseItemUIData final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ItemId;                                            // 0x0008(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DisplayName;                                       // 0x0018(0x0018)(Transient, NativeAccessSpecifierPublic)
	int32                                         Quantity;                                          // 0x0030(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 IconPath;                                          // 0x0038(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEventItemContentType                         ContentType;                                       // 0x0048(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemRarity                                   Rarity;                                            // 0x0049(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A[0x6];                                       // 0x004A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPurchaseItemUIData) == 0x000008, "Wrong alignment on FPurchaseItemUIData");
static_assert(sizeof(FPurchaseItemUIData) == 0x000050, "Wrong size on FPurchaseItemUIData");
static_assert(offsetof(FPurchaseItemUIData, ItemId) == 0x000008, "Member 'FPurchaseItemUIData::ItemId' has a wrong offset!");
static_assert(offsetof(FPurchaseItemUIData, DisplayName) == 0x000018, "Member 'FPurchaseItemUIData::DisplayName' has a wrong offset!");
static_assert(offsetof(FPurchaseItemUIData, Quantity) == 0x000030, "Member 'FPurchaseItemUIData::Quantity' has a wrong offset!");
static_assert(offsetof(FPurchaseItemUIData, IconPath) == 0x000038, "Member 'FPurchaseItemUIData::IconPath' has a wrong offset!");
static_assert(offsetof(FPurchaseItemUIData, ContentType) == 0x000048, "Member 'FPurchaseItemUIData::ContentType' has a wrong offset!");
static_assert(offsetof(FPurchaseItemUIData, Rarity) == 0x000049, "Member 'FPurchaseItemUIData::Rarity' has a wrong offset!");

// ScriptStruct DeadByDaylight.ExternalEffectData
// 0x0038 (0x0038 - 0x0000)
struct alignas(0x08) FExternalEffectData final
{
public:
	uint8                                         Pad_0[0x38];                                       // 0x0000(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FExternalEffectData) == 0x000008, "Wrong alignment on FExternalEffectData");
static_assert(sizeof(FExternalEffectData) == 0x000038, "Wrong size on FExternalEffectData");

// ScriptStruct DeadByDaylight.FakePalletData
// 0x00F0 (0x00F8 - 0x0008)
struct FFakePalletData final : public FDBDTableRowBase
{
public:
	TSoftClassPtr<class UClass>                   LevelPalletBP;                                     // 0x0008(0x0038)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   DreamPalletBP;                                     // 0x0040(0x0038)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   PalletTrackerBP;                                   // 0x0078(0x0038)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UStaticMesh>             IllusionaryPalletStaticMesh;                       // 0x00B0(0x0038)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ID;                                                // 0x00E8(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F4[0x4];                                       // 0x00F4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFakePalletData) == 0x000008, "Wrong alignment on FFakePalletData");
static_assert(sizeof(FFakePalletData) == 0x0000F8, "Wrong size on FFakePalletData");
static_assert(offsetof(FFakePalletData, LevelPalletBP) == 0x000008, "Member 'FFakePalletData::LevelPalletBP' has a wrong offset!");
static_assert(offsetof(FFakePalletData, DreamPalletBP) == 0x000040, "Member 'FFakePalletData::DreamPalletBP' has a wrong offset!");
static_assert(offsetof(FFakePalletData, PalletTrackerBP) == 0x000078, "Member 'FFakePalletData::PalletTrackerBP' has a wrong offset!");
static_assert(offsetof(FFakePalletData, IllusionaryPalletStaticMesh) == 0x0000B0, "Member 'FFakePalletData::IllusionaryPalletStaticMesh' has a wrong offset!");
static_assert(offsetof(FFakePalletData, ID) == 0x0000E8, "Member 'FFakePalletData::ID' has a wrong offset!");

// ScriptStruct DeadByDaylight.FeatureLocksConditionData
// 0x0030 (0x0030 - 0x0000)
struct FFeatureLocksConditionData final
{
public:
	class FString                                 Left;                                              // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Operator;                                          // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Right;                                             // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFeatureLocksConditionData) == 0x000008, "Wrong alignment on FFeatureLocksConditionData");
static_assert(sizeof(FFeatureLocksConditionData) == 0x000030, "Wrong size on FFeatureLocksConditionData");
static_assert(offsetof(FFeatureLocksConditionData, Left) == 0x000000, "Member 'FFeatureLocksConditionData::Left' has a wrong offset!");
static_assert(offsetof(FFeatureLocksConditionData, Operator) == 0x000010, "Member 'FFeatureLocksConditionData::Operator' has a wrong offset!");
static_assert(offsetof(FFeatureLocksConditionData, Right) == 0x000020, "Member 'FFeatureLocksConditionData::Right' has a wrong offset!");

// ScriptStruct DeadByDaylight.S3SeenPopupsConfigEntry
// 0x0020 (0x0020 - 0x0000)
struct FS3SeenPopupsConfigEntry final
{
public:
	class FString                                 ID;                                                // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxTimes;                                          // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinLoginThreshold;                                 // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SessionsPerPopup;                                  // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FS3SeenPopupsConfigEntry) == 0x000008, "Wrong alignment on FS3SeenPopupsConfigEntry");
static_assert(sizeof(FS3SeenPopupsConfigEntry) == 0x000020, "Wrong size on FS3SeenPopupsConfigEntry");
static_assert(offsetof(FS3SeenPopupsConfigEntry, ID) == 0x000000, "Member 'FS3SeenPopupsConfigEntry::ID' has a wrong offset!");
static_assert(offsetof(FS3SeenPopupsConfigEntry, MaxTimes) == 0x000010, "Member 'FS3SeenPopupsConfigEntry::MaxTimes' has a wrong offset!");
static_assert(offsetof(FS3SeenPopupsConfigEntry, MinLoginThreshold) == 0x000014, "Member 'FS3SeenPopupsConfigEntry::MinLoginThreshold' has a wrong offset!");
static_assert(offsetof(FS3SeenPopupsConfigEntry, SessionsPerPopup) == 0x000018, "Member 'FS3SeenPopupsConfigEntry::SessionsPerPopup' has a wrong offset!");

// ScriptStruct DeadByDaylight.FeatureLocksContentData
// 0x0038 (0x0038 - 0x0000)
struct FFeatureLocksContentData final
{
public:
	class FString                                 ID;                                                // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Role;                                              // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Role_IsSet;                                        // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FFeatureLocksConditionData>     Condition;                                         // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFeatureLocksContentData) == 0x000008, "Wrong alignment on FFeatureLocksContentData");
static_assert(sizeof(FFeatureLocksContentData) == 0x000038, "Wrong size on FFeatureLocksContentData");
static_assert(offsetof(FFeatureLocksContentData, ID) == 0x000000, "Member 'FFeatureLocksContentData::ID' has a wrong offset!");
static_assert(offsetof(FFeatureLocksContentData, Role) == 0x000010, "Member 'FFeatureLocksContentData::Role' has a wrong offset!");
static_assert(offsetof(FFeatureLocksContentData, Role_IsSet) == 0x000020, "Member 'FFeatureLocksContentData::Role_IsSet' has a wrong offset!");
static_assert(offsetof(FFeatureLocksContentData, Condition) == 0x000028, "Member 'FFeatureLocksContentData::Condition' has a wrong offset!");

// ScriptStruct DeadByDaylight.FeatureLocksContent
// 0x0010 (0x0010 - 0x0000)
struct FFeatureLocksContent final
{
public:
	TArray<struct FFeatureLocksContentData>       FeatureLocks;                                      // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FFeatureLocksContent) == 0x000008, "Wrong alignment on FFeatureLocksContent");
static_assert(sizeof(FFeatureLocksContent) == 0x000010, "Wrong size on FFeatureLocksContent");
static_assert(offsetof(FFeatureLocksContent, FeatureLocks) == 0x000000, "Member 'FFeatureLocksContent::FeatureLocks' has a wrong offset!");

// ScriptStruct DeadByDaylight.ForceSpawnTileData
// 0x0020 (0x0020 - 0x0000)
struct FForceSpawnTileData final
{
public:
	class FString                                 Name;                                              // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MatrixX;                                           // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MatrixY;                                           // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Rotation;                                          // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FForceSpawnTileData) == 0x000008, "Wrong alignment on FForceSpawnTileData");
static_assert(sizeof(FForceSpawnTileData) == 0x000020, "Wrong size on FForceSpawnTileData");
static_assert(offsetof(FForceSpawnTileData, Name) == 0x000000, "Member 'FForceSpawnTileData::Name' has a wrong offset!");
static_assert(offsetof(FForceSpawnTileData, MatrixX) == 0x000010, "Member 'FForceSpawnTileData::MatrixX' has a wrong offset!");
static_assert(offsetof(FForceSpawnTileData, MatrixY) == 0x000014, "Member 'FForceSpawnTileData::MatrixY' has a wrong offset!");
static_assert(offsetof(FForceSpawnTileData, Rotation) == 0x000018, "Member 'FForceSpawnTileData::Rotation' has a wrong offset!");

// ScriptStruct DeadByDaylight.GameEventDispatcherHandleBP
// 0x0020 (0x0020 - 0x0000)
struct FGameEventDispatcherHandleBP final
{
public:
	struct FGameplayTag                           Filter;                                            // 0x0000(0x000C)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(struct FGameplayTag& GameEventType, struct FGameEventData& GameEventData)> GameEventDelegate;                                 // 0x000C(0x0014)(Edit, BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameEventDispatcherHandleBP) == 0x000004, "Wrong alignment on FGameEventDispatcherHandleBP");
static_assert(sizeof(FGameEventDispatcherHandleBP) == 0x000020, "Wrong size on FGameEventDispatcherHandleBP");
static_assert(offsetof(FGameEventDispatcherHandleBP, Filter) == 0x000000, "Member 'FGameEventDispatcherHandleBP::Filter' has a wrong offset!");
static_assert(offsetof(FGameEventDispatcherHandleBP, GameEventDelegate) == 0x00000C, "Member 'FGameEventDispatcherHandleBP::GameEventDelegate' has a wrong offset!");

// ScriptStruct DeadByDaylight.S3PrestigeConfig
// 0x0020 (0x0020 - 0x0000)
struct FS3PrestigeConfig final
{
public:
	int32                                         MaxPrestige;                                       // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 PerkThresholds;                                    // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         PrestigeCost;                                      // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FS3PrestigeConfig) == 0x000008, "Wrong alignment on FS3PrestigeConfig");
static_assert(sizeof(FS3PrestigeConfig) == 0x000020, "Wrong size on FS3PrestigeConfig");
static_assert(offsetof(FS3PrestigeConfig, MaxPrestige) == 0x000000, "Member 'FS3PrestigeConfig::MaxPrestige' has a wrong offset!");
static_assert(offsetof(FS3PrestigeConfig, PerkThresholds) == 0x000008, "Member 'FS3PrestigeConfig::PerkThresholds' has a wrong offset!");
static_assert(offsetof(FS3PrestigeConfig, PrestigeCost) == 0x000018, "Member 'FS3PrestigeConfig::PrestigeCost' has a wrong offset!");

// ScriptStruct DeadByDaylight.ModifierTickableConditionReplicatedData
// 0x0018 (0x0018 - 0x0000)
struct FModifierTickableConditionReplicatedData final
{
public:
	TArray<class UBaseModifierCondition*>         Conditions;                                        // 0x0000(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          HasCondition;                                      // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AuthorityDataSet;                                  // 0x0011(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FModifierTickableConditionReplicatedData) == 0x000008, "Wrong alignment on FModifierTickableConditionReplicatedData");
static_assert(sizeof(FModifierTickableConditionReplicatedData) == 0x000018, "Wrong size on FModifierTickableConditionReplicatedData");
static_assert(offsetof(FModifierTickableConditionReplicatedData, Conditions) == 0x000000, "Member 'FModifierTickableConditionReplicatedData::Conditions' has a wrong offset!");
static_assert(offsetof(FModifierTickableConditionReplicatedData, HasCondition) == 0x000010, "Member 'FModifierTickableConditionReplicatedData::HasCondition' has a wrong offset!");
static_assert(offsetof(FModifierTickableConditionReplicatedData, AuthorityDataSet) == 0x000011, "Member 'FModifierTickableConditionReplicatedData::AuthorityDataSet' has a wrong offset!");

// ScriptStruct DeadByDaylight.SkillCheckResponse
// 0x0020 (0x0020 - 0x0000)
struct FSkillCheckResponse final
{
public:
	float                                         ChargeChange;                                      // 0x0000(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsTriggeredByInput;                                // 0x0004(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsSuccessful;                                      // 0x0005(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsBonus;                                           // 0x0006(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsInsane;                                          // 0x0007(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsTriggeringLoudNoise;                             // 0x0008(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          FailedCountedAsSuccess;                            // 0x0009(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESkillCheckCustomType                         Type;                                              // 0x000A(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B[0x5];                                        // 0x000B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UChargeableInteractionDefinition*       Interaction;                                       // 0x0010(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        VerificationKey;                                   // 0x0018(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSkillCheckResponse) == 0x000008, "Wrong alignment on FSkillCheckResponse");
static_assert(sizeof(FSkillCheckResponse) == 0x000020, "Wrong size on FSkillCheckResponse");
static_assert(offsetof(FSkillCheckResponse, ChargeChange) == 0x000000, "Member 'FSkillCheckResponse::ChargeChange' has a wrong offset!");
static_assert(offsetof(FSkillCheckResponse, IsTriggeredByInput) == 0x000004, "Member 'FSkillCheckResponse::IsTriggeredByInput' has a wrong offset!");
static_assert(offsetof(FSkillCheckResponse, IsSuccessful) == 0x000005, "Member 'FSkillCheckResponse::IsSuccessful' has a wrong offset!");
static_assert(offsetof(FSkillCheckResponse, IsBonus) == 0x000006, "Member 'FSkillCheckResponse::IsBonus' has a wrong offset!");
static_assert(offsetof(FSkillCheckResponse, IsInsane) == 0x000007, "Member 'FSkillCheckResponse::IsInsane' has a wrong offset!");
static_assert(offsetof(FSkillCheckResponse, IsTriggeringLoudNoise) == 0x000008, "Member 'FSkillCheckResponse::IsTriggeringLoudNoise' has a wrong offset!");
static_assert(offsetof(FSkillCheckResponse, FailedCountedAsSuccess) == 0x000009, "Member 'FSkillCheckResponse::FailedCountedAsSuccess' has a wrong offset!");
static_assert(offsetof(FSkillCheckResponse, Type) == 0x00000A, "Member 'FSkillCheckResponse::Type' has a wrong offset!");
static_assert(offsetof(FSkillCheckResponse, Interaction) == 0x000010, "Member 'FSkillCheckResponse::Interaction' has a wrong offset!");
static_assert(offsetof(FSkillCheckResponse, VerificationKey) == 0x000018, "Member 'FSkillCheckResponse::VerificationKey' has a wrong offset!");

// ScriptStruct DeadByDaylight.GarantiedRarityRingDistributionValues
// 0x0090 (0x0098 - 0x0008)
struct FGarantiedRarityRingDistributionValues final : public FDBDTableRowBase
{
public:
	int32                                         InnerRingCommonItemProbability;                    // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MiddleRingCommonItemProbability;                   // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OuterRingCommonItemProbability;                    // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InnerRingUncommonItemProbability;                  // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MiddleRingUncommonItemProbability;                 // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OuterRingUncommonItemProbability;                  // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InnerRingRareItemProbability;                      // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MiddleRingRareItemProbability;                     // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OuterRingRareItemProbability;                      // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InnerRingVeryRareItemProbability;                  // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MiddleRingVeryRareItemProbability;                 // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OuterRingVeryRareItemProbability;                  // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InnerRingUltraRareItemProbability;                 // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MiddleRingUltraRareItemProbability;                // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OuterRingUltraRareItemProbability;                 // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InnerRingArtifactItemProbability;                  // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MiddleRingArtifactItemProbability;                 // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OuterRingArtifactItemProbability;                  // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InnerRingSpectralItemProbability;                  // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MiddleRingSpectralItemProbability;                 // 0x0054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OuterRingSpectralItemProbability;                  // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InnerRingSpecialEventItemProbability;              // 0x005C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MiddleRingSpecialEventItemProbability;             // 0x0060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OuterRingSpecialEventItemProbability;              // 0x0064(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InnerRingLegendaryItemProbability;                 // 0x0068(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MiddleRingLegendaryItemProbability;                // 0x006C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OuterRingLegendaryItemProbability;                 // 0x0070(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InnerRingEpicItemProbability;                      // 0x0074(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MiddleRingEpicItemProbability;                     // 0x0078(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OuterRingEpicItemProbability;                      // 0x007C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InnerRingSuperEpicItemProbability;                 // 0x0080(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MiddleRingSuperEpicItemProbability;                // 0x0084(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OuterRingSuperEpicItemProbability;                 // 0x0088(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InnerRingUltraEpicItemProbability;                 // 0x008C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MiddleRingUltraEpicItemProbability;                // 0x0090(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OuterRingUltraEpicItemProbability;                 // 0x0094(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGarantiedRarityRingDistributionValues) == 0x000008, "Wrong alignment on FGarantiedRarityRingDistributionValues");
static_assert(sizeof(FGarantiedRarityRingDistributionValues) == 0x000098, "Wrong size on FGarantiedRarityRingDistributionValues");
static_assert(offsetof(FGarantiedRarityRingDistributionValues, InnerRingCommonItemProbability) == 0x000008, "Member 'FGarantiedRarityRingDistributionValues::InnerRingCommonItemProbability' has a wrong offset!");
static_assert(offsetof(FGarantiedRarityRingDistributionValues, MiddleRingCommonItemProbability) == 0x00000C, "Member 'FGarantiedRarityRingDistributionValues::MiddleRingCommonItemProbability' has a wrong offset!");
static_assert(offsetof(FGarantiedRarityRingDistributionValues, OuterRingCommonItemProbability) == 0x000010, "Member 'FGarantiedRarityRingDistributionValues::OuterRingCommonItemProbability' has a wrong offset!");
static_assert(offsetof(FGarantiedRarityRingDistributionValues, InnerRingUncommonItemProbability) == 0x000014, "Member 'FGarantiedRarityRingDistributionValues::InnerRingUncommonItemProbability' has a wrong offset!");
static_assert(offsetof(FGarantiedRarityRingDistributionValues, MiddleRingUncommonItemProbability) == 0x000018, "Member 'FGarantiedRarityRingDistributionValues::MiddleRingUncommonItemProbability' has a wrong offset!");
static_assert(offsetof(FGarantiedRarityRingDistributionValues, OuterRingUncommonItemProbability) == 0x00001C, "Member 'FGarantiedRarityRingDistributionValues::OuterRingUncommonItemProbability' has a wrong offset!");
static_assert(offsetof(FGarantiedRarityRingDistributionValues, InnerRingRareItemProbability) == 0x000020, "Member 'FGarantiedRarityRingDistributionValues::InnerRingRareItemProbability' has a wrong offset!");
static_assert(offsetof(FGarantiedRarityRingDistributionValues, MiddleRingRareItemProbability) == 0x000024, "Member 'FGarantiedRarityRingDistributionValues::MiddleRingRareItemProbability' has a wrong offset!");
static_assert(offsetof(FGarantiedRarityRingDistributionValues, OuterRingRareItemProbability) == 0x000028, "Member 'FGarantiedRarityRingDistributionValues::OuterRingRareItemProbability' has a wrong offset!");
static_assert(offsetof(FGarantiedRarityRingDistributionValues, InnerRingVeryRareItemProbability) == 0x00002C, "Member 'FGarantiedRarityRingDistributionValues::InnerRingVeryRareItemProbability' has a wrong offset!");
static_assert(offsetof(FGarantiedRarityRingDistributionValues, MiddleRingVeryRareItemProbability) == 0x000030, "Member 'FGarantiedRarityRingDistributionValues::MiddleRingVeryRareItemProbability' has a wrong offset!");
static_assert(offsetof(FGarantiedRarityRingDistributionValues, OuterRingVeryRareItemProbability) == 0x000034, "Member 'FGarantiedRarityRingDistributionValues::OuterRingVeryRareItemProbability' has a wrong offset!");
static_assert(offsetof(FGarantiedRarityRingDistributionValues, InnerRingUltraRareItemProbability) == 0x000038, "Member 'FGarantiedRarityRingDistributionValues::InnerRingUltraRareItemProbability' has a wrong offset!");
static_assert(offsetof(FGarantiedRarityRingDistributionValues, MiddleRingUltraRareItemProbability) == 0x00003C, "Member 'FGarantiedRarityRingDistributionValues::MiddleRingUltraRareItemProbability' has a wrong offset!");
static_assert(offsetof(FGarantiedRarityRingDistributionValues, OuterRingUltraRareItemProbability) == 0x000040, "Member 'FGarantiedRarityRingDistributionValues::OuterRingUltraRareItemProbability' has a wrong offset!");
static_assert(offsetof(FGarantiedRarityRingDistributionValues, InnerRingArtifactItemProbability) == 0x000044, "Member 'FGarantiedRarityRingDistributionValues::InnerRingArtifactItemProbability' has a wrong offset!");
static_assert(offsetof(FGarantiedRarityRingDistributionValues, MiddleRingArtifactItemProbability) == 0x000048, "Member 'FGarantiedRarityRingDistributionValues::MiddleRingArtifactItemProbability' has a wrong offset!");
static_assert(offsetof(FGarantiedRarityRingDistributionValues, OuterRingArtifactItemProbability) == 0x00004C, "Member 'FGarantiedRarityRingDistributionValues::OuterRingArtifactItemProbability' has a wrong offset!");
static_assert(offsetof(FGarantiedRarityRingDistributionValues, InnerRingSpectralItemProbability) == 0x000050, "Member 'FGarantiedRarityRingDistributionValues::InnerRingSpectralItemProbability' has a wrong offset!");
static_assert(offsetof(FGarantiedRarityRingDistributionValues, MiddleRingSpectralItemProbability) == 0x000054, "Member 'FGarantiedRarityRingDistributionValues::MiddleRingSpectralItemProbability' has a wrong offset!");
static_assert(offsetof(FGarantiedRarityRingDistributionValues, OuterRingSpectralItemProbability) == 0x000058, "Member 'FGarantiedRarityRingDistributionValues::OuterRingSpectralItemProbability' has a wrong offset!");
static_assert(offsetof(FGarantiedRarityRingDistributionValues, InnerRingSpecialEventItemProbability) == 0x00005C, "Member 'FGarantiedRarityRingDistributionValues::InnerRingSpecialEventItemProbability' has a wrong offset!");
static_assert(offsetof(FGarantiedRarityRingDistributionValues, MiddleRingSpecialEventItemProbability) == 0x000060, "Member 'FGarantiedRarityRingDistributionValues::MiddleRingSpecialEventItemProbability' has a wrong offset!");
static_assert(offsetof(FGarantiedRarityRingDistributionValues, OuterRingSpecialEventItemProbability) == 0x000064, "Member 'FGarantiedRarityRingDistributionValues::OuterRingSpecialEventItemProbability' has a wrong offset!");
static_assert(offsetof(FGarantiedRarityRingDistributionValues, InnerRingLegendaryItemProbability) == 0x000068, "Member 'FGarantiedRarityRingDistributionValues::InnerRingLegendaryItemProbability' has a wrong offset!");
static_assert(offsetof(FGarantiedRarityRingDistributionValues, MiddleRingLegendaryItemProbability) == 0x00006C, "Member 'FGarantiedRarityRingDistributionValues::MiddleRingLegendaryItemProbability' has a wrong offset!");
static_assert(offsetof(FGarantiedRarityRingDistributionValues, OuterRingLegendaryItemProbability) == 0x000070, "Member 'FGarantiedRarityRingDistributionValues::OuterRingLegendaryItemProbability' has a wrong offset!");
static_assert(offsetof(FGarantiedRarityRingDistributionValues, InnerRingEpicItemProbability) == 0x000074, "Member 'FGarantiedRarityRingDistributionValues::InnerRingEpicItemProbability' has a wrong offset!");
static_assert(offsetof(FGarantiedRarityRingDistributionValues, MiddleRingEpicItemProbability) == 0x000078, "Member 'FGarantiedRarityRingDistributionValues::MiddleRingEpicItemProbability' has a wrong offset!");
static_assert(offsetof(FGarantiedRarityRingDistributionValues, OuterRingEpicItemProbability) == 0x00007C, "Member 'FGarantiedRarityRingDistributionValues::OuterRingEpicItemProbability' has a wrong offset!");
static_assert(offsetof(FGarantiedRarityRingDistributionValues, InnerRingSuperEpicItemProbability) == 0x000080, "Member 'FGarantiedRarityRingDistributionValues::InnerRingSuperEpicItemProbability' has a wrong offset!");
static_assert(offsetof(FGarantiedRarityRingDistributionValues, MiddleRingSuperEpicItemProbability) == 0x000084, "Member 'FGarantiedRarityRingDistributionValues::MiddleRingSuperEpicItemProbability' has a wrong offset!");
static_assert(offsetof(FGarantiedRarityRingDistributionValues, OuterRingSuperEpicItemProbability) == 0x000088, "Member 'FGarantiedRarityRingDistributionValues::OuterRingSuperEpicItemProbability' has a wrong offset!");
static_assert(offsetof(FGarantiedRarityRingDistributionValues, InnerRingUltraEpicItemProbability) == 0x00008C, "Member 'FGarantiedRarityRingDistributionValues::InnerRingUltraEpicItemProbability' has a wrong offset!");
static_assert(offsetof(FGarantiedRarityRingDistributionValues, MiddleRingUltraEpicItemProbability) == 0x000090, "Member 'FGarantiedRarityRingDistributionValues::MiddleRingUltraEpicItemProbability' has a wrong offset!");
static_assert(offsetof(FGarantiedRarityRingDistributionValues, OuterRingUltraEpicItemProbability) == 0x000094, "Member 'FGarantiedRarityRingDistributionValues::OuterRingUltraEpicItemProbability' has a wrong offset!");

// ScriptStruct DeadByDaylight.ManagedGameplayElementData
// 0x0050 (0x0050 - 0x0000)
struct FManagedGameplayElementData final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UActorSpawner*>                  ActivatedSpawners;                                 // 0x0008(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UActorSpawner*>                  RemovedSpawners;                                   // 0x0018(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	EGameplayElementType                          PopulationType;                                    // 0x0028(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CurrentPopulationCost;                             // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxPopulationCost;                                 // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinPopulationCost;                                 // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MapWidth;                                          // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinProximityBetweenElements;                       // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinDistSqrBetweenElements;                         // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TileWidth;                                         // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FactorToAdjustToWhenOutOfProximity;                // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FManagedGameplayElementData) == 0x000008, "Wrong alignment on FManagedGameplayElementData");
static_assert(sizeof(FManagedGameplayElementData) == 0x000050, "Wrong size on FManagedGameplayElementData");
static_assert(offsetof(FManagedGameplayElementData, ActivatedSpawners) == 0x000008, "Member 'FManagedGameplayElementData::ActivatedSpawners' has a wrong offset!");
static_assert(offsetof(FManagedGameplayElementData, RemovedSpawners) == 0x000018, "Member 'FManagedGameplayElementData::RemovedSpawners' has a wrong offset!");
static_assert(offsetof(FManagedGameplayElementData, PopulationType) == 0x000028, "Member 'FManagedGameplayElementData::PopulationType' has a wrong offset!");
static_assert(offsetof(FManagedGameplayElementData, CurrentPopulationCost) == 0x00002C, "Member 'FManagedGameplayElementData::CurrentPopulationCost' has a wrong offset!");
static_assert(offsetof(FManagedGameplayElementData, MaxPopulationCost) == 0x000030, "Member 'FManagedGameplayElementData::MaxPopulationCost' has a wrong offset!");
static_assert(offsetof(FManagedGameplayElementData, MinPopulationCost) == 0x000034, "Member 'FManagedGameplayElementData::MinPopulationCost' has a wrong offset!");
static_assert(offsetof(FManagedGameplayElementData, MapWidth) == 0x000038, "Member 'FManagedGameplayElementData::MapWidth' has a wrong offset!");
static_assert(offsetof(FManagedGameplayElementData, MinProximityBetweenElements) == 0x00003C, "Member 'FManagedGameplayElementData::MinProximityBetweenElements' has a wrong offset!");
static_assert(offsetof(FManagedGameplayElementData, MinDistSqrBetweenElements) == 0x000040, "Member 'FManagedGameplayElementData::MinDistSqrBetweenElements' has a wrong offset!");
static_assert(offsetof(FManagedGameplayElementData, TileWidth) == 0x000044, "Member 'FManagedGameplayElementData::TileWidth' has a wrong offset!");
static_assert(offsetof(FManagedGameplayElementData, FactorToAdjustToWhenOutOfProximity) == 0x000048, "Member 'FManagedGameplayElementData::FactorToAdjustToWhenOutOfProximity' has a wrong offset!");

// ScriptStruct DeadByDaylight.KillerOutlineRevealSettings
// 0x0008 (0x0008 - 0x0000)
struct FKillerOutlineRevealSettings final
{
public:
	float                                         MaxDistance;                                       // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumSurvivorsInteractingToIgnoreDistance;           // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FKillerOutlineRevealSettings) == 0x000004, "Wrong alignment on FKillerOutlineRevealSettings");
static_assert(sizeof(FKillerOutlineRevealSettings) == 0x000008, "Wrong size on FKillerOutlineRevealSettings");
static_assert(offsetof(FKillerOutlineRevealSettings, MaxDistance) == 0x000000, "Member 'FKillerOutlineRevealSettings::MaxDistance' has a wrong offset!");
static_assert(offsetof(FKillerOutlineRevealSettings, NumSurvivorsInteractingToIgnoreDistance) == 0x000004, "Member 'FKillerOutlineRevealSettings::NumSurvivorsInteractingToIgnoreDistance' has a wrong offset!");

// ScriptStruct DeadByDaylight.HangTimesPerStep
// 0x0030 (0x0030 - 0x0000)
struct FHangTimesPerStep final
{
public:
	class FString                                 SourceName;                                        // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 StepName;                                          // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PossibleHangTime;                                  // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HardCapTimeout;                                    // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeCapWithoutProgress;                            // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHangTimesPerStep) == 0x000008, "Wrong alignment on FHangTimesPerStep");
static_assert(sizeof(FHangTimesPerStep) == 0x000030, "Wrong size on FHangTimesPerStep");
static_assert(offsetof(FHangTimesPerStep, SourceName) == 0x000000, "Member 'FHangTimesPerStep::SourceName' has a wrong offset!");
static_assert(offsetof(FHangTimesPerStep, StepName) == 0x000010, "Member 'FHangTimesPerStep::StepName' has a wrong offset!");
static_assert(offsetof(FHangTimesPerStep, PossibleHangTime) == 0x000020, "Member 'FHangTimesPerStep::PossibleHangTime' has a wrong offset!");
static_assert(offsetof(FHangTimesPerStep, HardCapTimeout) == 0x000024, "Member 'FHangTimesPerStep::HardCapTimeout' has a wrong offset!");
static_assert(offsetof(FHangTimesPerStep, TimeCapWithoutProgress) == 0x000028, "Member 'FHangTimesPerStep::TimeCapWithoutProgress' has a wrong offset!");

// ScriptStruct DeadByDaylight.HintData
// 0x0068 (0x0070 - 0x0008)
struct FHintData : public FDBDTableRowBase
{
public:
	EPlayerTeam                                   PlayerTeam;                                        // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Title;                                             // 0x0010(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0028(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FString                                 IconPath;                                          // 0x0040(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LevelMin;                                          // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LevelMax;                                          // 0x0054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RelevantCharacterID;                               // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EGameType>                             FilteredByGameType;                                // 0x0060(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHintData) == 0x000008, "Wrong alignment on FHintData");
static_assert(sizeof(FHintData) == 0x000070, "Wrong size on FHintData");
static_assert(offsetof(FHintData, PlayerTeam) == 0x000008, "Member 'FHintData::PlayerTeam' has a wrong offset!");
static_assert(offsetof(FHintData, Title) == 0x000010, "Member 'FHintData::Title' has a wrong offset!");
static_assert(offsetof(FHintData, Description) == 0x000028, "Member 'FHintData::Description' has a wrong offset!");
static_assert(offsetof(FHintData, IconPath) == 0x000040, "Member 'FHintData::IconPath' has a wrong offset!");
static_assert(offsetof(FHintData, LevelMin) == 0x000050, "Member 'FHintData::LevelMin' has a wrong offset!");
static_assert(offsetof(FHintData, LevelMax) == 0x000054, "Member 'FHintData::LevelMax' has a wrong offset!");
static_assert(offsetof(FHintData, RelevantCharacterID) == 0x000058, "Member 'FHintData::RelevantCharacterID' has a wrong offset!");
static_assert(offsetof(FHintData, FilteredByGameType) == 0x000060, "Member 'FHintData::FilteredByGameType' has a wrong offset!");

// ScriptStruct DeadByDaylight.S3DynamicContentConfig
// 0x0018 (0x0018 - 0x0000)
struct FS3DynamicContentConfig final
{
public:
	TArray<class FString>                         DynamicContentKillswitchPlatforms;                 // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          DynamicContentKillswitchPlatforms_IsSet;           // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FS3DynamicContentConfig) == 0x000008, "Wrong alignment on FS3DynamicContentConfig");
static_assert(sizeof(FS3DynamicContentConfig) == 0x000018, "Wrong size on FS3DynamicContentConfig");
static_assert(offsetof(FS3DynamicContentConfig, DynamicContentKillswitchPlatforms) == 0x000000, "Member 'FS3DynamicContentConfig::DynamicContentKillswitchPlatforms' has a wrong offset!");
static_assert(offsetof(FS3DynamicContentConfig, DynamicContentKillswitchPlatforms_IsSet) == 0x000010, "Member 'FS3DynamicContentConfig::DynamicContentKillswitchPlatforms_IsSet' has a wrong offset!");

// ScriptStruct DeadByDaylight.HitValidationEditorConfig
// 0x0010 (0x0018 - 0x0008)
struct FHitValidationEditorConfig final : public FTableRowBase
{
public:
	EHitValidatorConfigName                       ConfigName;                                        // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CapsuleInflation;                                  // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaximumDistance;                                   // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHitValidationEditorConfig) == 0x000008, "Wrong alignment on FHitValidationEditorConfig");
static_assert(sizeof(FHitValidationEditorConfig) == 0x000018, "Wrong size on FHitValidationEditorConfig");
static_assert(offsetof(FHitValidationEditorConfig, ConfigName) == 0x000008, "Member 'FHitValidationEditorConfig::ConfigName' has a wrong offset!");
static_assert(offsetof(FHitValidationEditorConfig, CapsuleInflation) == 0x00000C, "Member 'FHitValidationEditorConfig::CapsuleInflation' has a wrong offset!");
static_assert(offsetof(FHitValidationEditorConfig, MaximumDistance) == 0x000010, "Member 'FHitValidationEditorConfig::MaximumDistance' has a wrong offset!");

// ScriptStruct DeadByDaylight.HookLingerTimerHandleContainer
// 0x0010 (0x0010 - 0x0000)
struct FHookLingerTimerHandleContainer final
{
public:
	class AMeatHook*                              Hook;                                              // 0x0000(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHookLingerTimerHandleContainer) == 0x000008, "Wrong alignment on FHookLingerTimerHandleContainer");
static_assert(sizeof(FHookLingerTimerHandleContainer) == 0x000010, "Wrong size on FHookLingerTimerHandleContainer");
static_assert(offsetof(FHookLingerTimerHandleContainer, Hook) == 0x000000, "Member 'FHookLingerTimerHandleContainer::Hook' has a wrong offset!");

// ScriptStruct DeadByDaylight.MenuCameraViewTargetWithLabel
// 0x0028 (0x0028 - 0x0000)
struct FMenuCameraViewTargetWithLabel final
{
public:
	class FName                                   Label;                                             // 0x0000(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCharacterViewTarget                   Dropdown;                                          // 0x0010(0x0018)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMenuCameraViewTargetWithLabel) == 0x000008, "Wrong alignment on FMenuCameraViewTargetWithLabel");
static_assert(sizeof(FMenuCameraViewTargetWithLabel) == 0x000028, "Wrong size on FMenuCameraViewTargetWithLabel");
static_assert(offsetof(FMenuCameraViewTargetWithLabel, Label) == 0x000000, "Member 'FMenuCameraViewTargetWithLabel::Label' has a wrong offset!");
static_assert(offsetof(FMenuCameraViewTargetWithLabel, Dropdown) == 0x000010, "Member 'FMenuCameraViewTargetWithLabel::Dropdown' has a wrong offset!");

// ScriptStruct DeadByDaylight.PlayerInfoCache
// 0x0038 (0x0038 - 0x0000)
struct alignas(0x08) FPlayerInfoCache final
{
public:
	uint8                                         Pad_0[0x38];                                       // 0x0000(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerInfoCache) == 0x000008, "Wrong alignment on FPlayerInfoCache");
static_assert(sizeof(FPlayerInfoCache) == 0x000038, "Wrong size on FPlayerInfoCache");

// ScriptStruct DeadByDaylight.InputPromptData
// 0x0210 (0x0210 - 0x0000)
struct alignas(0x08) FInputPromptData final
{
public:
	uint8                                         Pad_0[0x210];                                      // 0x0000(0x0210)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FInputPromptData) == 0x000008, "Wrong alignment on FInputPromptData");
static_assert(sizeof(FInputPromptData) == 0x000210, "Wrong size on FInputPromptData");

// ScriptStruct DeadByDaylight.S3MirrorsDefaultRetryPolicyConfig
// 0x000C (0x000C - 0x0000)
struct FS3MirrorsDefaultRetryPolicyConfig final
{
public:
	bool                                          Enabled;                                           // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RetryCount;                                        // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TIMEOUT;                                           // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FS3MirrorsDefaultRetryPolicyConfig) == 0x000004, "Wrong alignment on FS3MirrorsDefaultRetryPolicyConfig");
static_assert(sizeof(FS3MirrorsDefaultRetryPolicyConfig) == 0x00000C, "Wrong size on FS3MirrorsDefaultRetryPolicyConfig");
static_assert(offsetof(FS3MirrorsDefaultRetryPolicyConfig, Enabled) == 0x000000, "Member 'FS3MirrorsDefaultRetryPolicyConfig::Enabled' has a wrong offset!");
static_assert(offsetof(FS3MirrorsDefaultRetryPolicyConfig, RetryCount) == 0x000004, "Member 'FS3MirrorsDefaultRetryPolicyConfig::RetryCount' has a wrong offset!");
static_assert(offsetof(FS3MirrorsDefaultRetryPolicyConfig, TIMEOUT) == 0x000008, "Member 'FS3MirrorsDefaultRetryPolicyConfig::TIMEOUT' has a wrong offset!");

// ScriptStruct DeadByDaylight.InteractionProficiencyProperties
// 0x0080 (0x0088 - 0x0008)
struct FInteractionProficiencyProperties final : public FDBDTableRowBase
{
public:
	class FName                                   ProficiencyID;                                     // 0x0008(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   ProficiencyBlueprint;                              // 0x0018(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<float>                                 BuffLevelThresholds;                               // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<float>                                 DebuffLevelThresholds;                             // 0x0060(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          HasLevels;                                         // 0x0070(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 IconFilePath;                                      // 0x0078(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FInteractionProficiencyProperties) == 0x000008, "Wrong alignment on FInteractionProficiencyProperties");
static_assert(sizeof(FInteractionProficiencyProperties) == 0x000088, "Wrong size on FInteractionProficiencyProperties");
static_assert(offsetof(FInteractionProficiencyProperties, ProficiencyID) == 0x000008, "Member 'FInteractionProficiencyProperties::ProficiencyID' has a wrong offset!");
static_assert(offsetof(FInteractionProficiencyProperties, ProficiencyBlueprint) == 0x000018, "Member 'FInteractionProficiencyProperties::ProficiencyBlueprint' has a wrong offset!");
static_assert(offsetof(FInteractionProficiencyProperties, BuffLevelThresholds) == 0x000050, "Member 'FInteractionProficiencyProperties::BuffLevelThresholds' has a wrong offset!");
static_assert(offsetof(FInteractionProficiencyProperties, DebuffLevelThresholds) == 0x000060, "Member 'FInteractionProficiencyProperties::DebuffLevelThresholds' has a wrong offset!");
static_assert(offsetof(FInteractionProficiencyProperties, HasLevels) == 0x000070, "Member 'FInteractionProficiencyProperties::HasLevels' has a wrong offset!");
static_assert(offsetof(FInteractionProficiencyProperties, IconFilePath) == 0x000078, "Member 'FInteractionProficiencyProperties::IconFilePath' has a wrong offset!");

// ScriptStruct DeadByDaylight.ContextualAnimationMapping
// 0x0048 (0x0048 - 0x0000)
struct FContextualAnimationMapping final
{
public:
	struct FGameplayTag                           ContextTag;                                        // 0x0000(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UDataTable>              AnimationMapping;                                  // 0x0010(0x0038)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FContextualAnimationMapping) == 0x000008, "Wrong alignment on FContextualAnimationMapping");
static_assert(sizeof(FContextualAnimationMapping) == 0x000048, "Wrong size on FContextualAnimationMapping");
static_assert(offsetof(FContextualAnimationMapping, ContextTag) == 0x000000, "Member 'FContextualAnimationMapping::ContextTag' has a wrong offset!");
static_assert(offsetof(FContextualAnimationMapping, AnimationMapping) == 0x000010, "Member 'FContextualAnimationMapping::AnimationMapping' has a wrong offset!");

// ScriptStruct DeadByDaylight.CharacterFallbackData
// 0x0020 (0x0020 - 0x0000)
struct FCharacterFallbackData final
{
public:
	class FString                                 DefaultKiller;                                     // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DefaultSurvivor;                                   // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterFallbackData) == 0x000008, "Wrong alignment on FCharacterFallbackData");
static_assert(sizeof(FCharacterFallbackData) == 0x000020, "Wrong size on FCharacterFallbackData");
static_assert(offsetof(FCharacterFallbackData, DefaultKiller) == 0x000000, "Member 'FCharacterFallbackData::DefaultKiller' has a wrong offset!");
static_assert(offsetof(FCharacterFallbackData, DefaultSurvivor) == 0x000010, "Member 'FCharacterFallbackData::DefaultSurvivor' has a wrong offset!");

// ScriptStruct DeadByDaylight.PreLevelGenerationModifierProperties
// 0x0018 (0x0020 - 0x0008)
struct FPreLevelGenerationModifierProperties final : public FDBDTableRowBase
{
public:
	class FName                                   ModifierID;                                        // 0x0008(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EPreLevelGenerationModifierType               ModifierType;                                      // 0x0014(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EKillerAbilities                              KillerAbiliy;                                      // 0x0015(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_16[0x2];                                       // 0x0016(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ModifierValue;                                     // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPreLevelGenerationModifierProperties) == 0x000008, "Wrong alignment on FPreLevelGenerationModifierProperties");
static_assert(sizeof(FPreLevelGenerationModifierProperties) == 0x000020, "Wrong size on FPreLevelGenerationModifierProperties");
static_assert(offsetof(FPreLevelGenerationModifierProperties, ModifierID) == 0x000008, "Member 'FPreLevelGenerationModifierProperties::ModifierID' has a wrong offset!");
static_assert(offsetof(FPreLevelGenerationModifierProperties, ModifierType) == 0x000014, "Member 'FPreLevelGenerationModifierProperties::ModifierType' has a wrong offset!");
static_assert(offsetof(FPreLevelGenerationModifierProperties, KillerAbiliy) == 0x000015, "Member 'FPreLevelGenerationModifierProperties::KillerAbiliy' has a wrong offset!");
static_assert(offsetof(FPreLevelGenerationModifierProperties, ModifierValue) == 0x000018, "Member 'FPreLevelGenerationModifierProperties::ModifierValue' has a wrong offset!");

// ScriptStruct DeadByDaylight.ItemCharacterKillswitchData
// 0x00C8 (0x00C8 - 0x0000)
struct FItemCharacterKillswitchData final
{
public:
	struct FCharacterFallbackData                 CharacterFallback;                                 // 0x0000(0x0020)(NativeAccessSpecifierPublic)
	TMap<class FString, struct FCharacterFallbackData> FallbacksByGameType;                               // 0x0020(0x0050)(NativeAccessSpecifierPublic)
	TMap<class FString, struct FDisabledItemData> DisabledItems;                                     // 0x0070(0x0050)(NativeAccessSpecifierPublic)
	bool                                          DisabledItems_IsSet;                               // 0x00C0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C1[0x7];                                       // 0x00C1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FItemCharacterKillswitchData) == 0x000008, "Wrong alignment on FItemCharacterKillswitchData");
static_assert(sizeof(FItemCharacterKillswitchData) == 0x0000C8, "Wrong size on FItemCharacterKillswitchData");
static_assert(offsetof(FItemCharacterKillswitchData, CharacterFallback) == 0x000000, "Member 'FItemCharacterKillswitchData::CharacterFallback' has a wrong offset!");
static_assert(offsetof(FItemCharacterKillswitchData, FallbacksByGameType) == 0x000020, "Member 'FItemCharacterKillswitchData::FallbacksByGameType' has a wrong offset!");
static_assert(offsetof(FItemCharacterKillswitchData, DisabledItems) == 0x000070, "Member 'FItemCharacterKillswitchData::DisabledItems' has a wrong offset!");
static_assert(offsetof(FItemCharacterKillswitchData, DisabledItems_IsSet) == 0x0000C0, "Member 'FItemCharacterKillswitchData::DisabledItems_IsSet' has a wrong offset!");

// ScriptStruct DeadByDaylight.JwtGameConfig
// 0x0001 (0x0001 - 0x0000)
struct FJwtGameConfig final
{
public:
	bool                                          Enabled;                                           // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FJwtGameConfig) == 0x000001, "Wrong alignment on FJwtGameConfig");
static_assert(sizeof(FJwtGameConfig) == 0x000001, "Wrong size on FJwtGameConfig");
static_assert(offsetof(FJwtGameConfig, Enabled) == 0x000000, "Member 'FJwtGameConfig::Enabled' has a wrong offset!");

// ScriptStruct DeadByDaylight.KillerSoundCueTracker
// 0x001C (0x001C - 0x0000)
struct alignas(0x04) FKillerSoundCueTracker final
{
public:
	uint8                                         Pad_0[0x1C];                                       // 0x0000(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FKillerSoundCueTracker) == 0x000004, "Wrong alignment on FKillerSoundCueTracker");
static_assert(sizeof(FKillerSoundCueTracker) == 0x00001C, "Wrong size on FKillerSoundCueTracker");

// ScriptStruct DeadByDaylight.NewsContentDetails
// 0x00B8 (0x00B8 - 0x0000)
struct FNewsContentDetails final
{
public:
	int32                                         Weight;                                            // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Version;                                           // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Title;                                             // 0x0018(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Description;                                       // 0x0028(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ImagePath;                                         // 0x0038(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ImagePath_IsSet;                                   // 0x0048(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DwnImagePath;                                      // 0x0050(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DwnImagePath_IsSet;                                // 0x0060(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x3];                                       // 0x0061(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ImageHeight;                                       // 0x0064(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ImageHeight_IsSet;                                 // 0x0068(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsHidden;                                          // 0x0069(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsHidden_IsSet;                                    // 0x006A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6B[0x21];                                      // 0x006B(0x0021)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Type;                                              // 0x008C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          Type_IsSet;                                        // 0x0090(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         ContentTags;                                       // 0x0098(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class FString                                 StartDate;                                         // 0x00A8(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FNewsContentDetails) == 0x000008, "Wrong alignment on FNewsContentDetails");
static_assert(sizeof(FNewsContentDetails) == 0x0000B8, "Wrong size on FNewsContentDetails");
static_assert(offsetof(FNewsContentDetails, Weight) == 0x000000, "Member 'FNewsContentDetails::Weight' has a wrong offset!");
static_assert(offsetof(FNewsContentDetails, Version) == 0x000008, "Member 'FNewsContentDetails::Version' has a wrong offset!");
static_assert(offsetof(FNewsContentDetails, Title) == 0x000018, "Member 'FNewsContentDetails::Title' has a wrong offset!");
static_assert(offsetof(FNewsContentDetails, Description) == 0x000028, "Member 'FNewsContentDetails::Description' has a wrong offset!");
static_assert(offsetof(FNewsContentDetails, ImagePath) == 0x000038, "Member 'FNewsContentDetails::ImagePath' has a wrong offset!");
static_assert(offsetof(FNewsContentDetails, ImagePath_IsSet) == 0x000048, "Member 'FNewsContentDetails::ImagePath_IsSet' has a wrong offset!");
static_assert(offsetof(FNewsContentDetails, DwnImagePath) == 0x000050, "Member 'FNewsContentDetails::DwnImagePath' has a wrong offset!");
static_assert(offsetof(FNewsContentDetails, DwnImagePath_IsSet) == 0x000060, "Member 'FNewsContentDetails::DwnImagePath_IsSet' has a wrong offset!");
static_assert(offsetof(FNewsContentDetails, ImageHeight) == 0x000064, "Member 'FNewsContentDetails::ImageHeight' has a wrong offset!");
static_assert(offsetof(FNewsContentDetails, ImageHeight_IsSet) == 0x000068, "Member 'FNewsContentDetails::ImageHeight_IsSet' has a wrong offset!");
static_assert(offsetof(FNewsContentDetails, IsHidden) == 0x000069, "Member 'FNewsContentDetails::IsHidden' has a wrong offset!");
static_assert(offsetof(FNewsContentDetails, IsHidden_IsSet) == 0x00006A, "Member 'FNewsContentDetails::IsHidden_IsSet' has a wrong offset!");
static_assert(offsetof(FNewsContentDetails, Type) == 0x00008C, "Member 'FNewsContentDetails::Type' has a wrong offset!");
static_assert(offsetof(FNewsContentDetails, Type_IsSet) == 0x000090, "Member 'FNewsContentDetails::Type_IsSet' has a wrong offset!");
static_assert(offsetof(FNewsContentDetails, ContentTags) == 0x000098, "Member 'FNewsContentDetails::ContentTags' has a wrong offset!");
static_assert(offsetof(FNewsContentDetails, StartDate) == 0x0000A8, "Member 'FNewsContentDetails::StartDate' has a wrong offset!");

// ScriptStruct DeadByDaylight.KillerSpecificNavmeshesData
// 0x0020 (0x0028 - 0x0008)
struct FKillerSpecificNavmeshesData final : public FDBDTableRowBase
{
public:
	struct FGameplayTag                           KillerPresenceTag;                                 // 0x0008(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NavmeshName;                                       // 0x0014(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NavmeshIndex;                                      // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FKillerSpecificNavmeshesData) == 0x000008, "Wrong alignment on FKillerSpecificNavmeshesData");
static_assert(sizeof(FKillerSpecificNavmeshesData) == 0x000028, "Wrong size on FKillerSpecificNavmeshesData");
static_assert(offsetof(FKillerSpecificNavmeshesData, KillerPresenceTag) == 0x000008, "Member 'FKillerSpecificNavmeshesData::KillerPresenceTag' has a wrong offset!");
static_assert(offsetof(FKillerSpecificNavmeshesData, NavmeshName) == 0x000014, "Member 'FKillerSpecificNavmeshesData::NavmeshName' has a wrong offset!");
static_assert(offsetof(FKillerSpecificNavmeshesData, NavmeshIndex) == 0x000020, "Member 'FKillerSpecificNavmeshesData::NavmeshIndex' has a wrong offset!");

// ScriptStruct DeadByDaylight.ThemeProperties
// 0x0108 (0x0110 - 0x0008)
struct FThemeProperties final : public FDBDTableRowBase
{
public:
	class FName                                   Name;                                              // 0x0008(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Weather;                                           // 0x0014(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AudioStateThemes;                                  // 0x0020(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AudioStateWeather;                                 // 0x002C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AudioThemeEvent;                                   // 0x0038(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AudioLimitPointEvent;                              // 0x0044(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAkAudioBank>            AudioThemeSoundBank;                               // 0x0050(0x0038)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TilePath;                                          // 0x0088(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MapPath;                                           // 0x0098(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ThemeNumber;                                       // 0x00A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DisplayName;                                       // 0x00B0(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	EThemeColorId                                 ThemeColorId;                                      // 0x00C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOfferingEffectType                           ThemeSelectionOfferingEffectType;                  // 0x00C9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CA[0x6];                                       // 0x00CA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameplayElementSubstitutions>  SubstitutionElements;                              // 0x00D0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FGameplayElementAddition>       AdditionElements;                                  // 0x00E0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 DlcIDString;                                       // 0x00F0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlackboardData*                        Blackboard;                                        // 0x0100(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Gesture;                                           // 0x0108(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_109[0x7];                                      // 0x0109(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FThemeProperties) == 0x000008, "Wrong alignment on FThemeProperties");
static_assert(sizeof(FThemeProperties) == 0x000110, "Wrong size on FThemeProperties");
static_assert(offsetof(FThemeProperties, Name) == 0x000008, "Member 'FThemeProperties::Name' has a wrong offset!");
static_assert(offsetof(FThemeProperties, Weather) == 0x000014, "Member 'FThemeProperties::Weather' has a wrong offset!");
static_assert(offsetof(FThemeProperties, AudioStateThemes) == 0x000020, "Member 'FThemeProperties::AudioStateThemes' has a wrong offset!");
static_assert(offsetof(FThemeProperties, AudioStateWeather) == 0x00002C, "Member 'FThemeProperties::AudioStateWeather' has a wrong offset!");
static_assert(offsetof(FThemeProperties, AudioThemeEvent) == 0x000038, "Member 'FThemeProperties::AudioThemeEvent' has a wrong offset!");
static_assert(offsetof(FThemeProperties, AudioLimitPointEvent) == 0x000044, "Member 'FThemeProperties::AudioLimitPointEvent' has a wrong offset!");
static_assert(offsetof(FThemeProperties, AudioThemeSoundBank) == 0x000050, "Member 'FThemeProperties::AudioThemeSoundBank' has a wrong offset!");
static_assert(offsetof(FThemeProperties, TilePath) == 0x000088, "Member 'FThemeProperties::TilePath' has a wrong offset!");
static_assert(offsetof(FThemeProperties, MapPath) == 0x000098, "Member 'FThemeProperties::MapPath' has a wrong offset!");
static_assert(offsetof(FThemeProperties, ThemeNumber) == 0x0000A8, "Member 'FThemeProperties::ThemeNumber' has a wrong offset!");
static_assert(offsetof(FThemeProperties, DisplayName) == 0x0000B0, "Member 'FThemeProperties::DisplayName' has a wrong offset!");
static_assert(offsetof(FThemeProperties, ThemeColorId) == 0x0000C8, "Member 'FThemeProperties::ThemeColorId' has a wrong offset!");
static_assert(offsetof(FThemeProperties, ThemeSelectionOfferingEffectType) == 0x0000C9, "Member 'FThemeProperties::ThemeSelectionOfferingEffectType' has a wrong offset!");
static_assert(offsetof(FThemeProperties, SubstitutionElements) == 0x0000D0, "Member 'FThemeProperties::SubstitutionElements' has a wrong offset!");
static_assert(offsetof(FThemeProperties, AdditionElements) == 0x0000E0, "Member 'FThemeProperties::AdditionElements' has a wrong offset!");
static_assert(offsetof(FThemeProperties, DlcIDString) == 0x0000F0, "Member 'FThemeProperties::DlcIDString' has a wrong offset!");
static_assert(offsetof(FThemeProperties, Blackboard) == 0x000100, "Member 'FThemeProperties::Blackboard' has a wrong offset!");
static_assert(offsetof(FThemeProperties, Gesture) == 0x000108, "Member 'FThemeProperties::Gesture' has a wrong offset!");

// ScriptStruct DeadByDaylight.LevelReadyToPlayRequirements
// 0x0010 (0x0010 - 0x0000)
struct FLevelReadyToPlayRequirements final
{
public:
	class ADBDPlayer*                             Player;                                            // 0x0000(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         PerkCount;                                         // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ItemCount;                                         // 0x0009(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         AddonCount;                                        // 0x000A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B[0x5];                                        // 0x000B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLevelReadyToPlayRequirements) == 0x000008, "Wrong alignment on FLevelReadyToPlayRequirements");
static_assert(sizeof(FLevelReadyToPlayRequirements) == 0x000010, "Wrong size on FLevelReadyToPlayRequirements");
static_assert(offsetof(FLevelReadyToPlayRequirements, Player) == 0x000000, "Member 'FLevelReadyToPlayRequirements::Player' has a wrong offset!");
static_assert(offsetof(FLevelReadyToPlayRequirements, PerkCount) == 0x000008, "Member 'FLevelReadyToPlayRequirements::PerkCount' has a wrong offset!");
static_assert(offsetof(FLevelReadyToPlayRequirements, ItemCount) == 0x000009, "Member 'FLevelReadyToPlayRequirements::ItemCount' has a wrong offset!");
static_assert(offsetof(FLevelReadyToPlayRequirements, AddonCount) == 0x00000A, "Member 'FLevelReadyToPlayRequirements::AddonCount' has a wrong offset!");

// ScriptStruct DeadByDaylight.RefundUIData
// 0x0078 (0x0078 - 0x0000)
struct FRefundUIData final
{
public:
	TArray<struct FAtlantaRewardUIData>           OriginalRewards;                                   // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	struct FAtlantaRewardUIData                   Refund;                                            // 0x0010(0x0060)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPublic)
	int32                                         FragmentAmount;                                    // 0x0070(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FragmentRequiredAmount;                            // 0x0074(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRefundUIData) == 0x000008, "Wrong alignment on FRefundUIData");
static_assert(sizeof(FRefundUIData) == 0x000078, "Wrong size on FRefundUIData");
static_assert(offsetof(FRefundUIData, OriginalRewards) == 0x000000, "Member 'FRefundUIData::OriginalRewards' has a wrong offset!");
static_assert(offsetof(FRefundUIData, Refund) == 0x000010, "Member 'FRefundUIData::Refund' has a wrong offset!");
static_assert(offsetof(FRefundUIData, FragmentAmount) == 0x000070, "Member 'FRefundUIData::FragmentAmount' has a wrong offset!");
static_assert(offsetof(FRefundUIData, FragmentRequiredAmount) == 0x000074, "Member 'FRefundUIData::FragmentRequiredAmount' has a wrong offset!");

// ScriptStruct DeadByDaylight.DirectionalHeightFogInterpolationValues
// 0x00A8 (0x00A8 - 0x0000)
struct FDirectionalHeightFogInterpolationValues final
{
public:
	float                                         FogDensity;                                        // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           FogInscatteringLuminance;                          // 0x0004(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           DirectionalInscatteringLuminance;                  // 0x0014(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DirectionalInscatteringExponent;                   // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DirectionalInscatteringStartDistance;              // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           DirectionalInscatteringColor;                      // 0x002C(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FogHeightFalloff;                                  // 0x003C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FogMaxOpacity;                                     // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartDistance;                                     // 0x0044(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SecondFogDensity;                                  // 0x0048(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SecondFogHeightFalloff;                            // 0x004C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SecondFogHeightOffset;                             // 0x0050(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FHeightFogGradientEntry>        FogGradient;                                       // 0x0058(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bReplaceVolumetricFogAlbedoWithColorGradient;      // 0x0068(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x3];                                       // 0x0069(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         VolumetricFogGradientIntensityMultiplier;          // 0x006C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceUntilFlatFog;                              // 0x0070(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceUntilNoFog;                                // 0x0074(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableVolumetricFog;                              // 0x0078(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x3];                                       // 0x0079(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         VolumetricFogScatteringDistribution;               // 0x007C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 VolumetricFogAlbedo;                               // 0x0080(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           VolumetricFogEmissive;                             // 0x0084(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VolumetricFogExtinctionScale;                      // 0x0094(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VolumetricFogDistance;                             // 0x0098(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VolumetricFogStaticLightingScatteringIntensity;    // 0x009C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideLightColorsWithFogInscatteringColors;     // 0x00A0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDirectionalHeightFogInterpolationValues) == 0x000008, "Wrong alignment on FDirectionalHeightFogInterpolationValues");
static_assert(sizeof(FDirectionalHeightFogInterpolationValues) == 0x0000A8, "Wrong size on FDirectionalHeightFogInterpolationValues");
static_assert(offsetof(FDirectionalHeightFogInterpolationValues, FogDensity) == 0x000000, "Member 'FDirectionalHeightFogInterpolationValues::FogDensity' has a wrong offset!");
static_assert(offsetof(FDirectionalHeightFogInterpolationValues, FogInscatteringLuminance) == 0x000004, "Member 'FDirectionalHeightFogInterpolationValues::FogInscatteringLuminance' has a wrong offset!");
static_assert(offsetof(FDirectionalHeightFogInterpolationValues, DirectionalInscatteringLuminance) == 0x000014, "Member 'FDirectionalHeightFogInterpolationValues::DirectionalInscatteringLuminance' has a wrong offset!");
static_assert(offsetof(FDirectionalHeightFogInterpolationValues, DirectionalInscatteringExponent) == 0x000024, "Member 'FDirectionalHeightFogInterpolationValues::DirectionalInscatteringExponent' has a wrong offset!");
static_assert(offsetof(FDirectionalHeightFogInterpolationValues, DirectionalInscatteringStartDistance) == 0x000028, "Member 'FDirectionalHeightFogInterpolationValues::DirectionalInscatteringStartDistance' has a wrong offset!");
static_assert(offsetof(FDirectionalHeightFogInterpolationValues, DirectionalInscatteringColor) == 0x00002C, "Member 'FDirectionalHeightFogInterpolationValues::DirectionalInscatteringColor' has a wrong offset!");
static_assert(offsetof(FDirectionalHeightFogInterpolationValues, FogHeightFalloff) == 0x00003C, "Member 'FDirectionalHeightFogInterpolationValues::FogHeightFalloff' has a wrong offset!");
static_assert(offsetof(FDirectionalHeightFogInterpolationValues, FogMaxOpacity) == 0x000040, "Member 'FDirectionalHeightFogInterpolationValues::FogMaxOpacity' has a wrong offset!");
static_assert(offsetof(FDirectionalHeightFogInterpolationValues, StartDistance) == 0x000044, "Member 'FDirectionalHeightFogInterpolationValues::StartDistance' has a wrong offset!");
static_assert(offsetof(FDirectionalHeightFogInterpolationValues, SecondFogDensity) == 0x000048, "Member 'FDirectionalHeightFogInterpolationValues::SecondFogDensity' has a wrong offset!");
static_assert(offsetof(FDirectionalHeightFogInterpolationValues, SecondFogHeightFalloff) == 0x00004C, "Member 'FDirectionalHeightFogInterpolationValues::SecondFogHeightFalloff' has a wrong offset!");
static_assert(offsetof(FDirectionalHeightFogInterpolationValues, SecondFogHeightOffset) == 0x000050, "Member 'FDirectionalHeightFogInterpolationValues::SecondFogHeightOffset' has a wrong offset!");
static_assert(offsetof(FDirectionalHeightFogInterpolationValues, FogGradient) == 0x000058, "Member 'FDirectionalHeightFogInterpolationValues::FogGradient' has a wrong offset!");
static_assert(offsetof(FDirectionalHeightFogInterpolationValues, bReplaceVolumetricFogAlbedoWithColorGradient) == 0x000068, "Member 'FDirectionalHeightFogInterpolationValues::bReplaceVolumetricFogAlbedoWithColorGradient' has a wrong offset!");
static_assert(offsetof(FDirectionalHeightFogInterpolationValues, VolumetricFogGradientIntensityMultiplier) == 0x00006C, "Member 'FDirectionalHeightFogInterpolationValues::VolumetricFogGradientIntensityMultiplier' has a wrong offset!");
static_assert(offsetof(FDirectionalHeightFogInterpolationValues, DistanceUntilFlatFog) == 0x000070, "Member 'FDirectionalHeightFogInterpolationValues::DistanceUntilFlatFog' has a wrong offset!");
static_assert(offsetof(FDirectionalHeightFogInterpolationValues, DistanceUntilNoFog) == 0x000074, "Member 'FDirectionalHeightFogInterpolationValues::DistanceUntilNoFog' has a wrong offset!");
static_assert(offsetof(FDirectionalHeightFogInterpolationValues, bEnableVolumetricFog) == 0x000078, "Member 'FDirectionalHeightFogInterpolationValues::bEnableVolumetricFog' has a wrong offset!");
static_assert(offsetof(FDirectionalHeightFogInterpolationValues, VolumetricFogScatteringDistribution) == 0x00007C, "Member 'FDirectionalHeightFogInterpolationValues::VolumetricFogScatteringDistribution' has a wrong offset!");
static_assert(offsetof(FDirectionalHeightFogInterpolationValues, VolumetricFogAlbedo) == 0x000080, "Member 'FDirectionalHeightFogInterpolationValues::VolumetricFogAlbedo' has a wrong offset!");
static_assert(offsetof(FDirectionalHeightFogInterpolationValues, VolumetricFogEmissive) == 0x000084, "Member 'FDirectionalHeightFogInterpolationValues::VolumetricFogEmissive' has a wrong offset!");
static_assert(offsetof(FDirectionalHeightFogInterpolationValues, VolumetricFogExtinctionScale) == 0x000094, "Member 'FDirectionalHeightFogInterpolationValues::VolumetricFogExtinctionScale' has a wrong offset!");
static_assert(offsetof(FDirectionalHeightFogInterpolationValues, VolumetricFogDistance) == 0x000098, "Member 'FDirectionalHeightFogInterpolationValues::VolumetricFogDistance' has a wrong offset!");
static_assert(offsetof(FDirectionalHeightFogInterpolationValues, VolumetricFogStaticLightingScatteringIntensity) == 0x00009C, "Member 'FDirectionalHeightFogInterpolationValues::VolumetricFogStaticLightingScatteringIntensity' has a wrong offset!");
static_assert(offsetof(FDirectionalHeightFogInterpolationValues, bOverrideLightColorsWithFogInscatteringColors) == 0x0000A0, "Member 'FDirectionalHeightFogInterpolationValues::bOverrideLightColorsWithFogInscatteringColors' has a wrong offset!");

// ScriptStruct DeadByDaylight.LimitedTimeEventHintData
// 0x0020 (0x0090 - 0x0070)
struct FLimitedTimeEventHintData final : public FHintData
{
public:
	TArray<EGameType>                             GameTypes;                                         // 0x0070(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FCharacterClassDropdown                CharacterClass;                                    // 0x0080(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLimitedTimeEventHintData) == 0x000008, "Wrong alignment on FLimitedTimeEventHintData");
static_assert(sizeof(FLimitedTimeEventHintData) == 0x000090, "Wrong size on FLimitedTimeEventHintData");
static_assert(offsetof(FLimitedTimeEventHintData, GameTypes) == 0x000070, "Member 'FLimitedTimeEventHintData::GameTypes' has a wrong offset!");
static_assert(offsetof(FLimitedTimeEventHintData, CharacterClass) == 0x000080, "Member 'FLimitedTimeEventHintData::CharacterClass' has a wrong offset!");

// ScriptStruct DeadByDaylight.LoadingImagesData
// 0x0038 (0x0040 - 0x0008)
struct FLoadingImagesData final : public FDBDTableRowBase
{
public:
	class FName                                   ID;                                                // 0x0008(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftObjectPtr<class UPaperSprite>>    Images;                                            // 0x0018(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<struct FLoadingInfoData>               InfoData;                                          // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          IsAvailableForSurvivor;                            // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsAvailableForKiller;                              // 0x0039(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsGenericImages;                                   // 0x003A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B[0x5];                                       // 0x003B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLoadingImagesData) == 0x000008, "Wrong alignment on FLoadingImagesData");
static_assert(sizeof(FLoadingImagesData) == 0x000040, "Wrong size on FLoadingImagesData");
static_assert(offsetof(FLoadingImagesData, ID) == 0x000008, "Member 'FLoadingImagesData::ID' has a wrong offset!");
static_assert(offsetof(FLoadingImagesData, Images) == 0x000018, "Member 'FLoadingImagesData::Images' has a wrong offset!");
static_assert(offsetof(FLoadingImagesData, InfoData) == 0x000028, "Member 'FLoadingImagesData::InfoData' has a wrong offset!");
static_assert(offsetof(FLoadingImagesData, IsAvailableForSurvivor) == 0x000038, "Member 'FLoadingImagesData::IsAvailableForSurvivor' has a wrong offset!");
static_assert(offsetof(FLoadingImagesData, IsAvailableForKiller) == 0x000039, "Member 'FLoadingImagesData::IsAvailableForKiller' has a wrong offset!");
static_assert(offsetof(FLoadingImagesData, IsGenericImages) == 0x00003A, "Member 'FLoadingImagesData::IsGenericImages' has a wrong offset!");

// ScriptStruct DeadByDaylight.PlayerLobbyOrderData
// 0x0018 (0x0018 - 0x0000)
struct FPlayerLobbyOrderData final
{
public:
	class FString                                 PlayerId;                                          // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SlotIndex;                                         // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerLobbyOrderData) == 0x000008, "Wrong alignment on FPlayerLobbyOrderData");
static_assert(sizeof(FPlayerLobbyOrderData) == 0x000018, "Wrong size on FPlayerLobbyOrderData");
static_assert(offsetof(FPlayerLobbyOrderData, PlayerId) == 0x000000, "Member 'FPlayerLobbyOrderData::PlayerId' has a wrong offset!");
static_assert(offsetof(FPlayerLobbyOrderData, SlotIndex) == 0x000010, "Member 'FPlayerLobbyOrderData::SlotIndex' has a wrong offset!");

// ScriptStruct DeadByDaylight.LobbyPreviewData
// 0x00B8 (0x00B8 - 0x0000)
struct FLobbyPreviewData final
{
public:
	int32                                         CharacterIndex;                                    // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECustomizationCategory                        Category;                                          // 0x0004(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FEquippedPlayerCustomization           Customization;                                     // 0x0008(0x0038)(NativeAccessSpecifierPublic)
	class FName                                   CustomizationItemId;                               // 0x0040(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int8                                          CharmSlotIndex;                                    // 0x004C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsCharmZoomed;                                     // 0x004D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsKiller;                                          // 0x004E(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsBioSubtab;                                       // 0x004F(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsCustomizationSubtab;                             // 0x0050(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   HookOverride;                                      // 0x0058(0x0038)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FaceLocation;                                      // 0x0090(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PowerId;                                           // 0x00A8(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B4[0x4];                                       // 0x00B4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLobbyPreviewData) == 0x000008, "Wrong alignment on FLobbyPreviewData");
static_assert(sizeof(FLobbyPreviewData) == 0x0000B8, "Wrong size on FLobbyPreviewData");
static_assert(offsetof(FLobbyPreviewData, CharacterIndex) == 0x000000, "Member 'FLobbyPreviewData::CharacterIndex' has a wrong offset!");
static_assert(offsetof(FLobbyPreviewData, Category) == 0x000004, "Member 'FLobbyPreviewData::Category' has a wrong offset!");
static_assert(offsetof(FLobbyPreviewData, Customization) == 0x000008, "Member 'FLobbyPreviewData::Customization' has a wrong offset!");
static_assert(offsetof(FLobbyPreviewData, CustomizationItemId) == 0x000040, "Member 'FLobbyPreviewData::CustomizationItemId' has a wrong offset!");
static_assert(offsetof(FLobbyPreviewData, CharmSlotIndex) == 0x00004C, "Member 'FLobbyPreviewData::CharmSlotIndex' has a wrong offset!");
static_assert(offsetof(FLobbyPreviewData, IsCharmZoomed) == 0x00004D, "Member 'FLobbyPreviewData::IsCharmZoomed' has a wrong offset!");
static_assert(offsetof(FLobbyPreviewData, IsKiller) == 0x00004E, "Member 'FLobbyPreviewData::IsKiller' has a wrong offset!");
static_assert(offsetof(FLobbyPreviewData, IsBioSubtab) == 0x00004F, "Member 'FLobbyPreviewData::IsBioSubtab' has a wrong offset!");
static_assert(offsetof(FLobbyPreviewData, IsCustomizationSubtab) == 0x000050, "Member 'FLobbyPreviewData::IsCustomizationSubtab' has a wrong offset!");
static_assert(offsetof(FLobbyPreviewData, HookOverride) == 0x000058, "Member 'FLobbyPreviewData::HookOverride' has a wrong offset!");
static_assert(offsetof(FLobbyPreviewData, FaceLocation) == 0x000090, "Member 'FLobbyPreviewData::FaceLocation' has a wrong offset!");
static_assert(offsetof(FLobbyPreviewData, PowerId) == 0x0000A8, "Member 'FLobbyPreviewData::PowerId' has a wrong offset!");

// ScriptStruct DeadByDaylight.KillerClosetActorsTypes
// 0x0058 (0x0060 - 0x0008)
struct FKillerClosetActorsTypes final : public FDBDTableRowBase
{
public:
	struct FGameplayTag                           KillerPresenceTag;                                 // 0x0008(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   ClosetActorClass;                                  // 0x0018(0x0038)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SocketToSpawnOn;                                   // 0x0050(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FKillerClosetActorsTypes) == 0x000008, "Wrong alignment on FKillerClosetActorsTypes");
static_assert(sizeof(FKillerClosetActorsTypes) == 0x000060, "Wrong size on FKillerClosetActorsTypes");
static_assert(offsetof(FKillerClosetActorsTypes, KillerPresenceTag) == 0x000008, "Member 'FKillerClosetActorsTypes::KillerPresenceTag' has a wrong offset!");
static_assert(offsetof(FKillerClosetActorsTypes, ClosetActorClass) == 0x000018, "Member 'FKillerClosetActorsTypes::ClosetActorClass' has a wrong offset!");
static_assert(offsetof(FKillerClosetActorsTypes, SocketToSpawnOn) == 0x000050, "Member 'FKillerClosetActorsTypes::SocketToSpawnOn' has a wrong offset!");

// ScriptStruct DeadByDaylight.LoudNoiseIndicatorData
// 0x0030 (0x0030 - 0x0000)
struct FLoudNoiseIndicatorData final
{
public:
	class UStaticMeshComponent*                   MeshMask;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   DistortionMesh;                                    // 0x0008(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0010(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RemainingTime;                                     // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLoudNoiseIndicatorData) == 0x000008, "Wrong alignment on FLoudNoiseIndicatorData");
static_assert(sizeof(FLoudNoiseIndicatorData) == 0x000030, "Wrong size on FLoudNoiseIndicatorData");
static_assert(offsetof(FLoudNoiseIndicatorData, MeshMask) == 0x000000, "Member 'FLoudNoiseIndicatorData::MeshMask' has a wrong offset!");
static_assert(offsetof(FLoudNoiseIndicatorData, DistortionMesh) == 0x000008, "Member 'FLoudNoiseIndicatorData::DistortionMesh' has a wrong offset!");
static_assert(offsetof(FLoudNoiseIndicatorData, Location) == 0x000010, "Member 'FLoudNoiseIndicatorData::Location' has a wrong offset!");
static_assert(offsetof(FLoudNoiseIndicatorData, RemainingTime) == 0x000028, "Member 'FLoudNoiseIndicatorData::RemainingTime' has a wrong offset!");

// ScriptStruct DeadByDaylight.MapSpecificComponentsData
// 0x0048 (0x0050 - 0x0008)
struct FMapSpecificComponentsData final : public FDBDTableRowBase
{
public:
	class FString                                 MapName;                                           // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   MapSpecificComponent;                              // 0x0018(0x0038)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMapSpecificComponentsData) == 0x000008, "Wrong alignment on FMapSpecificComponentsData");
static_assert(sizeof(FMapSpecificComponentsData) == 0x000050, "Wrong size on FMapSpecificComponentsData");
static_assert(offsetof(FMapSpecificComponentsData, MapName) == 0x000008, "Member 'FMapSpecificComponentsData::MapName' has a wrong offset!");
static_assert(offsetof(FMapSpecificComponentsData, MapSpecificComponent) == 0x000018, "Member 'FMapSpecificComponentsData::MapSpecificComponent' has a wrong offset!");

// ScriptStruct DeadByDaylight.MatchmakingContextData
// 0x0004 (0x0004 - 0x0000)
struct FMatchmakingContextData final
{
public:
	uint32                                        ContextId;                                         // 0x0000(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMatchmakingContextData) == 0x000004, "Wrong alignment on FMatchmakingContextData");
static_assert(sizeof(FMatchmakingContextData) == 0x000004, "Wrong size on FMatchmakingContextData");
static_assert(offsetof(FMatchmakingContextData, ContextId) == 0x000000, "Member 'FMatchmakingContextData::ContextId' has a wrong offset!");

// ScriptStruct DeadByDaylight.MenuCameraPreset
// 0x0060 (0x0068 - 0x0008)
struct FMenuCameraPreset final : public FDBDTableRowBase
{
public:
	TMap<EDBDCameraViewType, struct FMenuCameraView> Views;                                             // 0x0008(0x0050)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FMenuCameraViewTargetWithLabel> Targets;                                           // 0x0058(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMenuCameraPreset) == 0x000008, "Wrong alignment on FMenuCameraPreset");
static_assert(sizeof(FMenuCameraPreset) == 0x000068, "Wrong size on FMenuCameraPreset");
static_assert(offsetof(FMenuCameraPreset, Views) == 0x000008, "Member 'FMenuCameraPreset::Views' has a wrong offset!");
static_assert(offsetof(FMenuCameraPreset, Targets) == 0x000058, "Member 'FMenuCameraPreset::Targets' has a wrong offset!");

// ScriptStruct DeadByDaylight.GameInfoEventData
// 0x0002 (0x0002 - 0x0000)
struct FGameInfoEventData final
{
public:
	EPlayerRole                                   PlayerRole;                                        // 0x0000(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGameType                                     GameType;                                          // 0x0001(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameInfoEventData) == 0x000001, "Wrong alignment on FGameInfoEventData");
static_assert(sizeof(FGameInfoEventData) == 0x000002, "Wrong size on FGameInfoEventData");
static_assert(offsetof(FGameInfoEventData, PlayerRole) == 0x000000, "Member 'FGameInfoEventData::PlayerRole' has a wrong offset!");
static_assert(offsetof(FGameInfoEventData, GameType) == 0x000001, "Member 'FGameInfoEventData::GameType' has a wrong offset!");

// ScriptStruct DeadByDaylight.MenuIndexChangeEventData
// 0x0004 (0x0004 - 0x0000)
struct FMenuIndexChangeEventData final
{
public:
	int32                                         Index;                                             // 0x0000(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMenuIndexChangeEventData) == 0x000004, "Wrong alignment on FMenuIndexChangeEventData");
static_assert(sizeof(FMenuIndexChangeEventData) == 0x000004, "Wrong size on FMenuIndexChangeEventData");
static_assert(offsetof(FMenuIndexChangeEventData, Index) == 0x000000, "Member 'FMenuIndexChangeEventData::Index' has a wrong offset!");

// ScriptStruct DeadByDaylight.MontageInstanceInfo
// 0x0030 (0x0030 - 0x0000)
struct alignas(0x08) FMontageInstanceInfo final
{
public:
	uint8                                         Pad_0[0x30];                                       // 0x0000(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMontageInstanceInfo) == 0x000008, "Wrong alignment on FMontageInstanceInfo");
static_assert(sizeof(FMontageInstanceInfo) == 0x000030, "Wrong size on FMontageInstanceInfo");

// ScriptStruct DeadByDaylight.MysteryBoxStatus
// 0x0050 (0x0050 - 0x0000)
struct FMysteryBoxStatus final
{
public:
	class FString                                 Campaign;                                          // 0x0000(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanClaimCurrentBox;                                // 0x0010(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              NextClaimTime;                                     // 0x0018(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NextClaimTime_IsSet;                               // 0x0020(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              LastClaimTime;                                     // 0x0028(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          LastClaimTime_IsSet;                               // 0x0030(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMysteryBoxClaimedReward>       LastRewards;                                       // 0x0038(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	bool                                          LastRewards_IsSet;                                 // 0x0048(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMysteryBoxStatus) == 0x000008, "Wrong alignment on FMysteryBoxStatus");
static_assert(sizeof(FMysteryBoxStatus) == 0x000050, "Wrong size on FMysteryBoxStatus");
static_assert(offsetof(FMysteryBoxStatus, Campaign) == 0x000000, "Member 'FMysteryBoxStatus::Campaign' has a wrong offset!");
static_assert(offsetof(FMysteryBoxStatus, CanClaimCurrentBox) == 0x000010, "Member 'FMysteryBoxStatus::CanClaimCurrentBox' has a wrong offset!");
static_assert(offsetof(FMysteryBoxStatus, NextClaimTime) == 0x000018, "Member 'FMysteryBoxStatus::NextClaimTime' has a wrong offset!");
static_assert(offsetof(FMysteryBoxStatus, NextClaimTime_IsSet) == 0x000020, "Member 'FMysteryBoxStatus::NextClaimTime_IsSet' has a wrong offset!");
static_assert(offsetof(FMysteryBoxStatus, LastClaimTime) == 0x000028, "Member 'FMysteryBoxStatus::LastClaimTime' has a wrong offset!");
static_assert(offsetof(FMysteryBoxStatus, LastClaimTime_IsSet) == 0x000030, "Member 'FMysteryBoxStatus::LastClaimTime_IsSet' has a wrong offset!");
static_assert(offsetof(FMysteryBoxStatus, LastRewards) == 0x000038, "Member 'FMysteryBoxStatus::LastRewards' has a wrong offset!");
static_assert(offsetof(FMysteryBoxStatus, LastRewards_IsSet) == 0x000048, "Member 'FMysteryBoxStatus::LastRewards_IsSet' has a wrong offset!");

// ScriptStruct DeadByDaylight.GuidingInfo
// 0x0018 (0x0018 - 0x0000)
struct FGuidingInfo final
{
public:
	TArray<class ADBDPlayer*>                     _guidingPlayers;                                   // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	EGuidedState                                  _guidedState;                                      // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGuidingInfo) == 0x000008, "Wrong alignment on FGuidingInfo");
static_assert(sizeof(FGuidingInfo) == 0x000018, "Wrong size on FGuidingInfo");
static_assert(offsetof(FGuidingInfo, _guidingPlayers) == 0x000000, "Member 'FGuidingInfo::_guidingPlayers' has a wrong offset!");
static_assert(offsetof(FGuidingInfo, _guidedState) == 0x000010, "Member 'FGuidingInfo::_guidedState' has a wrong offset!");

// ScriptStruct DeadByDaylight.NewsContentOnlineData
// 0x0018 (0x0018 - 0x0000)
struct FNewsContentOnlineData final
{
public:
	TArray<struct FNewsContentDetails>            News;                                              // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          News_isset;                                        // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNewsContentOnlineData) == 0x000008, "Wrong alignment on FNewsContentOnlineData");
static_assert(sizeof(FNewsContentOnlineData) == 0x000018, "Wrong size on FNewsContentOnlineData");
static_assert(offsetof(FNewsContentOnlineData, News) == 0x000000, "Member 'FNewsContentOnlineData::News' has a wrong offset!");
static_assert(offsetof(FNewsContentOnlineData, News_isset) == 0x000010, "Member 'FNewsContentOnlineData::News_isset' has a wrong offset!");

// ScriptStruct DeadByDaylight.OfferingRevealDelays
// 0x0008 (0x0008 - 0x0000)
struct FOfferingRevealDelays final
{
public:
	EOfferingSequenceState                        RevealState;                                       // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Delay;                                             // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOfferingRevealDelays) == 0x000004, "Wrong alignment on FOfferingRevealDelays");
static_assert(sizeof(FOfferingRevealDelays) == 0x000008, "Wrong size on FOfferingRevealDelays");
static_assert(offsetof(FOfferingRevealDelays, RevealState) == 0x000000, "Member 'FOfferingRevealDelays::RevealState' has a wrong offset!");
static_assert(offsetof(FOfferingRevealDelays, Delay) == 0x000004, "Member 'FOfferingRevealDelays::Delay' has a wrong offset!");

// ScriptStruct DeadByDaylight.OfferingTriggerPositionData
// 0x0010 (0x0010 - 0x0000)
struct FOfferingTriggerPositionData final
{
public:
	int32                                         Index;                                             // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PosX;                                              // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PosY;                                              // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CardIndex;                                         // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOfferingTriggerPositionData) == 0x000004, "Wrong alignment on FOfferingTriggerPositionData");
static_assert(sizeof(FOfferingTriggerPositionData) == 0x000010, "Wrong size on FOfferingTriggerPositionData");
static_assert(offsetof(FOfferingTriggerPositionData, Index) == 0x000000, "Member 'FOfferingTriggerPositionData::Index' has a wrong offset!");
static_assert(offsetof(FOfferingTriggerPositionData, PosX) == 0x000004, "Member 'FOfferingTriggerPositionData::PosX' has a wrong offset!");
static_assert(offsetof(FOfferingTriggerPositionData, PosY) == 0x000008, "Member 'FOfferingTriggerPositionData::PosY' has a wrong offset!");
static_assert(offsetof(FOfferingTriggerPositionData, CardIndex) == 0x00000C, "Member 'FOfferingTriggerPositionData::CardIndex' has a wrong offset!");

// ScriptStruct DeadByDaylight.DBDJoinParams
// 0x0001 (0x0001 - 0x0000)
struct FDBDJoinParams final
{
public:
	EGameType                                     GameType;                                          // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDBDJoinParams) == 0x000001, "Wrong alignment on FDBDJoinParams");
static_assert(sizeof(FDBDJoinParams) == 0x000001, "Wrong size on FDBDJoinParams");
static_assert(offsetof(FDBDJoinParams, GameType) == 0x000000, "Member 'FDBDJoinParams::GameType' has a wrong offset!");

// ScriptStruct DeadByDaylight.DBDConnectionStatus
// 0x0010 (0x0010 - 0x0000)
struct FDBDConnectionStatus final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UDBDGameInstance*                       _gameInstance;                                     // 0x0008(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FDBDConnectionStatus) == 0x000008, "Wrong alignment on FDBDConnectionStatus");
static_assert(sizeof(FDBDConnectionStatus) == 0x000010, "Wrong size on FDBDConnectionStatus");
static_assert(offsetof(FDBDConnectionStatus, _gameInstance) == 0x000008, "Member 'FDBDConnectionStatus::_gameInstance' has a wrong offset!");

// ScriptStruct DeadByDaylight.RevealOptions
// 0x0028 (0x0028 - 0x0000)
struct FRevealOptions final
{
public:
	bool                                          IsUnaffectedByBlindness;                           // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsOutlineAlwaysVisible;                            // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsUnaffectedByFadeout;                             // 0x0002(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x1];                                        // 0x0003(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Duration;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Range;                                             // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 ActorToTestRangeFrom;                              // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           OutlineMaterialOverride;                           // 0x0018(0x000C)(Edit, BlueprintVisible, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRevealOptions) == 0x000008, "Wrong alignment on FRevealOptions");
static_assert(sizeof(FRevealOptions) == 0x000028, "Wrong size on FRevealOptions");
static_assert(offsetof(FRevealOptions, IsUnaffectedByBlindness) == 0x000000, "Member 'FRevealOptions::IsUnaffectedByBlindness' has a wrong offset!");
static_assert(offsetof(FRevealOptions, IsOutlineAlwaysVisible) == 0x000001, "Member 'FRevealOptions::IsOutlineAlwaysVisible' has a wrong offset!");
static_assert(offsetof(FRevealOptions, IsUnaffectedByFadeout) == 0x000002, "Member 'FRevealOptions::IsUnaffectedByFadeout' has a wrong offset!");
static_assert(offsetof(FRevealOptions, Duration) == 0x000004, "Member 'FRevealOptions::Duration' has a wrong offset!");
static_assert(offsetof(FRevealOptions, Range) == 0x000008, "Member 'FRevealOptions::Range' has a wrong offset!");
static_assert(offsetof(FRevealOptions, ActorToTestRangeFrom) == 0x000010, "Member 'FRevealOptions::ActorToTestRangeFrom' has a wrong offset!");
static_assert(offsetof(FRevealOptions, OutlineMaterialOverride) == 0x000018, "Member 'FRevealOptions::OutlineMaterialOverride' has a wrong offset!");

// ScriptStruct DeadByDaylight.PartyMemberUIData
// 0x0030 (0x0030 - 0x0000)
struct FPartyMemberUIData final
{
public:
	bool                                          _isLocalPlayer;                                    // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isReady;                                          // 0x0001(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 _mirrorId;                                         // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 _playerName;                                       // 0x0018(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         _playerId;                                         // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPartyMemberUIData) == 0x000008, "Wrong alignment on FPartyMemberUIData");
static_assert(sizeof(FPartyMemberUIData) == 0x000030, "Wrong size on FPartyMemberUIData");
static_assert(offsetof(FPartyMemberUIData, _isLocalPlayer) == 0x000000, "Member 'FPartyMemberUIData::_isLocalPlayer' has a wrong offset!");
static_assert(offsetof(FPartyMemberUIData, _isReady) == 0x000001, "Member 'FPartyMemberUIData::_isReady' has a wrong offset!");
static_assert(offsetof(FPartyMemberUIData, _mirrorId) == 0x000008, "Member 'FPartyMemberUIData::_mirrorId' has a wrong offset!");
static_assert(offsetof(FPartyMemberUIData, _playerName) == 0x000018, "Member 'FPartyMemberUIData::_playerName' has a wrong offset!");
static_assert(offsetof(FPartyMemberUIData, _playerId) == 0x000028, "Member 'FPartyMemberUIData::_playerId' has a wrong offset!");

// ScriptStruct DeadByDaylight.PerkRandomSuccessData
// 0x0008 (0x0008 - 0x0000)
struct FPerkRandomSuccessData final
{
public:
	int32                                         Value;                                             // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPerkRandomSuccessData) == 0x000004, "Wrong alignment on FPerkRandomSuccessData");
static_assert(sizeof(FPerkRandomSuccessData) == 0x000008, "Wrong size on FPerkRandomSuccessData");
static_assert(offsetof(FPerkRandomSuccessData, Value) == 0x000000, "Member 'FPerkRandomSuccessData::Value' has a wrong offset!");
static_assert(offsetof(FPerkRandomSuccessData, Duration) == 0x000004, "Member 'FPerkRandomSuccessData::Duration' has a wrong offset!");

// ScriptStruct DeadByDaylight.PlatformDlcData
// 0x0120 (0x0128 - 0x0008)
struct FPlatformDlcData final : public FDBDTableRowBase
{
public:
	class FString                                 ID;                                                // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ContentDescription;                                // 0x0018(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   DisplayName;                                       // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          IsHeritagePack;                                    // 0x0048(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         UISortOrder;                                       // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        BannerImage;                                       // 0x0050(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Description;                                       // 0x0078(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AllowsCrossProg;                                   // 0x0088(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 HeritageId;                                        // 0x0090(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 DlcIdSteam;                                        // 0x00A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 DlcIdEpic;                                         // 0x00B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 DlcIdPS4;                                          // 0x00C0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 DlcId_XB1_XSX_GDK;                                 // 0x00D0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 DlcIdSwitch;                                       // 0x00E0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 DlcIdGRDK;                                         // 0x00F0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 DlcIdPS5;                                          // 0x0100(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 DlcIdStadia;                                       // 0x0110(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          PlatformDBChanged;                                 // 0x0120(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_121[0x7];                                      // 0x0121(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlatformDlcData) == 0x000008, "Wrong alignment on FPlatformDlcData");
static_assert(sizeof(FPlatformDlcData) == 0x000128, "Wrong size on FPlatformDlcData");
static_assert(offsetof(FPlatformDlcData, ID) == 0x000008, "Member 'FPlatformDlcData::ID' has a wrong offset!");
static_assert(offsetof(FPlatformDlcData, ContentDescription) == 0x000018, "Member 'FPlatformDlcData::ContentDescription' has a wrong offset!");
static_assert(offsetof(FPlatformDlcData, DisplayName) == 0x000030, "Member 'FPlatformDlcData::DisplayName' has a wrong offset!");
static_assert(offsetof(FPlatformDlcData, IsHeritagePack) == 0x000048, "Member 'FPlatformDlcData::IsHeritagePack' has a wrong offset!");
static_assert(offsetof(FPlatformDlcData, UISortOrder) == 0x00004C, "Member 'FPlatformDlcData::UISortOrder' has a wrong offset!");
static_assert(offsetof(FPlatformDlcData, BannerImage) == 0x000050, "Member 'FPlatformDlcData::BannerImage' has a wrong offset!");
static_assert(offsetof(FPlatformDlcData, Description) == 0x000078, "Member 'FPlatformDlcData::Description' has a wrong offset!");
static_assert(offsetof(FPlatformDlcData, AllowsCrossProg) == 0x000088, "Member 'FPlatformDlcData::AllowsCrossProg' has a wrong offset!");
static_assert(offsetof(FPlatformDlcData, HeritageId) == 0x000090, "Member 'FPlatformDlcData::HeritageId' has a wrong offset!");
static_assert(offsetof(FPlatformDlcData, DlcIdSteam) == 0x0000A0, "Member 'FPlatformDlcData::DlcIdSteam' has a wrong offset!");
static_assert(offsetof(FPlatformDlcData, DlcIdEpic) == 0x0000B0, "Member 'FPlatformDlcData::DlcIdEpic' has a wrong offset!");
static_assert(offsetof(FPlatformDlcData, DlcIdPS4) == 0x0000C0, "Member 'FPlatformDlcData::DlcIdPS4' has a wrong offset!");
static_assert(offsetof(FPlatformDlcData, DlcId_XB1_XSX_GDK) == 0x0000D0, "Member 'FPlatformDlcData::DlcId_XB1_XSX_GDK' has a wrong offset!");
static_assert(offsetof(FPlatformDlcData, DlcIdSwitch) == 0x0000E0, "Member 'FPlatformDlcData::DlcIdSwitch' has a wrong offset!");
static_assert(offsetof(FPlatformDlcData, DlcIdGRDK) == 0x0000F0, "Member 'FPlatformDlcData::DlcIdGRDK' has a wrong offset!");
static_assert(offsetof(FPlatformDlcData, DlcIdPS5) == 0x000100, "Member 'FPlatformDlcData::DlcIdPS5' has a wrong offset!");
static_assert(offsetof(FPlatformDlcData, DlcIdStadia) == 0x000110, "Member 'FPlatformDlcData::DlcIdStadia' has a wrong offset!");
static_assert(offsetof(FPlatformDlcData, PlatformDBChanged) == 0x000120, "Member 'FPlatformDlcData::PlatformDBChanged' has a wrong offset!");

// ScriptStruct DeadByDaylight.PlayerCapsuleQueryParams
// 0x0078 (0x0078 - 0x0000)
struct FPlayerCapsuleQueryParams final
{
public:
	class ADBDPlayer*                             Player;                                            // 0x0000(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x10];                                       // 0x0008(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class AActor*>                           IgnoreActors;                                      // 0x0018(0x0050)(NativeAccessSpecifierPublic)
	uint8                                         Pad_68[0x10];                                      // 0x0068(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerCapsuleQueryParams) == 0x000008, "Wrong alignment on FPlayerCapsuleQueryParams");
static_assert(sizeof(FPlayerCapsuleQueryParams) == 0x000078, "Wrong size on FPlayerCapsuleQueryParams");
static_assert(offsetof(FPlayerCapsuleQueryParams, Player) == 0x000000, "Member 'FPlayerCapsuleQueryParams::Player' has a wrong offset!");
static_assert(offsetof(FPlayerCapsuleQueryParams, IgnoreActors) == 0x000018, "Member 'FPlayerCapsuleQueryParams::IgnoreActors' has a wrong offset!");

// ScriptStruct DeadByDaylight.PlayerLevelData
// 0x000C (0x000C - 0x0000)
struct FPlayerLevelData final
{
public:
	int32                                         LevelValue;                                        // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PrestigeValue;                                     // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxXp;                                             // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerLevelData) == 0x000004, "Wrong alignment on FPlayerLevelData");
static_assert(sizeof(FPlayerLevelData) == 0x00000C, "Wrong size on FPlayerLevelData");
static_assert(offsetof(FPlayerLevelData, LevelValue) == 0x000000, "Member 'FPlayerLevelData::LevelValue' has a wrong offset!");
static_assert(offsetof(FPlayerLevelData, PrestigeValue) == 0x000004, "Member 'FPlayerLevelData::PrestigeValue' has a wrong offset!");
static_assert(offsetof(FPlayerLevelData, MaxXp) == 0x000008, "Member 'FPlayerLevelData::MaxXp' has a wrong offset!");

// ScriptStruct DeadByDaylight.PlayerPerspectiveChangeCameraMovementData
// 0x0050 (0x0050 - 0x0000)
struct FPlayerPerspectiveChangeCameraMovementData final
{
public:
	struct FVector                                InitialCameraRelativeLocation;                     // 0x0000(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetCameraRelativeLocation;                      // 0x0018(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShouldForceLockCameraBehindPlayer;                 // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            TransitionCurve;                                   // 0x0038(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraMovementDuration;                            // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0xC];                                       // 0x0044(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerPerspectiveChangeCameraMovementData) == 0x000008, "Wrong alignment on FPlayerPerspectiveChangeCameraMovementData");
static_assert(sizeof(FPlayerPerspectiveChangeCameraMovementData) == 0x000050, "Wrong size on FPlayerPerspectiveChangeCameraMovementData");
static_assert(offsetof(FPlayerPerspectiveChangeCameraMovementData, InitialCameraRelativeLocation) == 0x000000, "Member 'FPlayerPerspectiveChangeCameraMovementData::InitialCameraRelativeLocation' has a wrong offset!");
static_assert(offsetof(FPlayerPerspectiveChangeCameraMovementData, TargetCameraRelativeLocation) == 0x000018, "Member 'FPlayerPerspectiveChangeCameraMovementData::TargetCameraRelativeLocation' has a wrong offset!");
static_assert(offsetof(FPlayerPerspectiveChangeCameraMovementData, ShouldForceLockCameraBehindPlayer) == 0x000030, "Member 'FPlayerPerspectiveChangeCameraMovementData::ShouldForceLockCameraBehindPlayer' has a wrong offset!");
static_assert(offsetof(FPlayerPerspectiveChangeCameraMovementData, TransitionCurve) == 0x000038, "Member 'FPlayerPerspectiveChangeCameraMovementData::TransitionCurve' has a wrong offset!");
static_assert(offsetof(FPlayerPerspectiveChangeCameraMovementData, CameraMovementDuration) == 0x000040, "Member 'FPlayerPerspectiveChangeCameraMovementData::CameraMovementDuration' has a wrong offset!");

// ScriptStruct DeadByDaylight.PlayerRoundStartEventData
// 0x0050 (0x0050 - 0x0000)
struct FPlayerRoundStartEventData final
{
public:
	EPlayerRole                                   PlayerRole;                                        // 0x0000(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsABot;                                            // 0x0001(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAIDifficultyLevel                            BotDifficultyLevel;                                // 0x0002(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x5];                                        // 0x0003(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 BotName;                                           // 0x0008(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 BotMirrorID;                                       // 0x0018(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CharacterId;                                       // 0x0028(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerRankForRole;                                 // 0x002C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PrestigeLevel;                                     // 0x0030(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BloodWebLevel;                                     // 0x0034(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pips;                                              // 0x0038(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPlayerRankData>                PlayerRankDataArray;                               // 0x0040(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerRoundStartEventData) == 0x000008, "Wrong alignment on FPlayerRoundStartEventData");
static_assert(sizeof(FPlayerRoundStartEventData) == 0x000050, "Wrong size on FPlayerRoundStartEventData");
static_assert(offsetof(FPlayerRoundStartEventData, PlayerRole) == 0x000000, "Member 'FPlayerRoundStartEventData::PlayerRole' has a wrong offset!");
static_assert(offsetof(FPlayerRoundStartEventData, IsABot) == 0x000001, "Member 'FPlayerRoundStartEventData::IsABot' has a wrong offset!");
static_assert(offsetof(FPlayerRoundStartEventData, BotDifficultyLevel) == 0x000002, "Member 'FPlayerRoundStartEventData::BotDifficultyLevel' has a wrong offset!");
static_assert(offsetof(FPlayerRoundStartEventData, BotName) == 0x000008, "Member 'FPlayerRoundStartEventData::BotName' has a wrong offset!");
static_assert(offsetof(FPlayerRoundStartEventData, BotMirrorID) == 0x000018, "Member 'FPlayerRoundStartEventData::BotMirrorID' has a wrong offset!");
static_assert(offsetof(FPlayerRoundStartEventData, CharacterId) == 0x000028, "Member 'FPlayerRoundStartEventData::CharacterId' has a wrong offset!");
static_assert(offsetof(FPlayerRoundStartEventData, PlayerRankForRole) == 0x00002C, "Member 'FPlayerRoundStartEventData::PlayerRankForRole' has a wrong offset!");
static_assert(offsetof(FPlayerRoundStartEventData, PrestigeLevel) == 0x000030, "Member 'FPlayerRoundStartEventData::PrestigeLevel' has a wrong offset!");
static_assert(offsetof(FPlayerRoundStartEventData, BloodWebLevel) == 0x000034, "Member 'FPlayerRoundStartEventData::BloodWebLevel' has a wrong offset!");
static_assert(offsetof(FPlayerRoundStartEventData, Pips) == 0x000038, "Member 'FPlayerRoundStartEventData::Pips' has a wrong offset!");
static_assert(offsetof(FPlayerRoundStartEventData, PlayerRankDataArray) == 0x000040, "Member 'FPlayerRoundStartEventData::PlayerRankDataArray' has a wrong offset!");

// ScriptStruct DeadByDaylight.PlayerScoreEmitterData
// 0x0080 (0x0088 - 0x0008)
struct FPlayerScoreEmitterData final : public FDBDTableRowBase
{
public:
	struct FGameplayTagQuery                      PawnSemanticTags;                                  // 0x0008(0x0048)(Edit, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   Emitter;                                           // 0x0050(0x0038)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerScoreEmitterData) == 0x000008, "Wrong alignment on FPlayerScoreEmitterData");
static_assert(sizeof(FPlayerScoreEmitterData) == 0x000088, "Wrong size on FPlayerScoreEmitterData");
static_assert(offsetof(FPlayerScoreEmitterData, PawnSemanticTags) == 0x000008, "Member 'FPlayerScoreEmitterData::PawnSemanticTags' has a wrong offset!");
static_assert(offsetof(FPlayerScoreEmitterData, Emitter) == 0x000050, "Member 'FPlayerScoreEmitterData::Emitter' has a wrong offset!");

// ScriptStruct DeadByDaylight.PostAttackData
// 0x0007 (0x0007 - 0x0000)
struct FPostAttackData final
{
public:
	bool                                          IsOblivious;                                       // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsKO;                                              // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsExposed;                                         // 0x0002(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsPostPhaseWalkAttack;                             // 0x0003(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsDownedInDemonMode;                               // 0x0004(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsLegionBleedOutAttack;                            // 0x0005(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsDemogorgonPounceAttack;                          // 0x0006(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPostAttackData) == 0x000001, "Wrong alignment on FPostAttackData");
static_assert(sizeof(FPostAttackData) == 0x000007, "Wrong size on FPostAttackData");
static_assert(offsetof(FPostAttackData, IsOblivious) == 0x000000, "Member 'FPostAttackData::IsOblivious' has a wrong offset!");
static_assert(offsetof(FPostAttackData, IsKO) == 0x000001, "Member 'FPostAttackData::IsKO' has a wrong offset!");
static_assert(offsetof(FPostAttackData, IsExposed) == 0x000002, "Member 'FPostAttackData::IsExposed' has a wrong offset!");
static_assert(offsetof(FPostAttackData, IsPostPhaseWalkAttack) == 0x000003, "Member 'FPostAttackData::IsPostPhaseWalkAttack' has a wrong offset!");
static_assert(offsetof(FPostAttackData, IsDownedInDemonMode) == 0x000004, "Member 'FPostAttackData::IsDownedInDemonMode' has a wrong offset!");
static_assert(offsetof(FPostAttackData, IsLegionBleedOutAttack) == 0x000005, "Member 'FPostAttackData::IsLegionBleedOutAttack' has a wrong offset!");
static_assert(offsetof(FPostAttackData, IsDemogorgonPounceAttack) == 0x000006, "Member 'FPostAttackData::IsDemogorgonPounceAttack' has a wrong offset!");

// ScriptStruct DeadByDaylight.PrestigeRewardStruct
// 0x0018 (0x0018 - 0x0000)
struct FPrestigeRewardStruct final
{
public:
	class FString                                 RewardId;                                          // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPrestigeRewardType                           RewardType;                                        // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RewardPerkLevel;                                   // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPrestigeRewardStruct) == 0x000008, "Wrong alignment on FPrestigeRewardStruct");
static_assert(sizeof(FPrestigeRewardStruct) == 0x000018, "Wrong size on FPrestigeRewardStruct");
static_assert(offsetof(FPrestigeRewardStruct, RewardId) == 0x000000, "Member 'FPrestigeRewardStruct::RewardId' has a wrong offset!");
static_assert(offsetof(FPrestigeRewardStruct, RewardType) == 0x000010, "Member 'FPrestigeRewardStruct::RewardType' has a wrong offset!");
static_assert(offsetof(FPrestigeRewardStruct, RewardPerkLevel) == 0x000014, "Member 'FPrestigeRewardStruct::RewardPerkLevel' has a wrong offset!");

// ScriptStruct DeadByDaylight.PrestigeRewardData
// 0x0050 (0x0058 - 0x0008)
struct FPrestigeRewardData final : public FDBDTableRowBase
{
public:
	int32                                         AssociatedCharacter;                               // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PrestigeLevel;                                     // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrestigeRewardStruct                  Rewards[0x3];                                      // 0x0010(0x0018)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPrestigeRewardData) == 0x000008, "Wrong alignment on FPrestigeRewardData");
static_assert(sizeof(FPrestigeRewardData) == 0x000058, "Wrong size on FPrestigeRewardData");
static_assert(offsetof(FPrestigeRewardData, AssociatedCharacter) == 0x000008, "Member 'FPrestigeRewardData::AssociatedCharacter' has a wrong offset!");
static_assert(offsetof(FPrestigeRewardData, PrestigeLevel) == 0x00000C, "Member 'FPrestigeRewardData::PrestigeLevel' has a wrong offset!");
static_assert(offsetof(FPrestigeRewardData, Rewards) == 0x000010, "Member 'FPrestigeRewardData::Rewards' has a wrong offset!");

// ScriptStruct DeadByDaylight.WeightedItem
// 0x0040 (0x0040 - 0x0000)
struct FWeightedItem final
{
public:
	TSoftClassPtr<class UClass>                   Element;                                           // 0x0000(0x0038)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWeightedItem) == 0x000008, "Wrong alignment on FWeightedItem");
static_assert(sizeof(FWeightedItem) == 0x000040, "Wrong size on FWeightedItem");
static_assert(offsetof(FWeightedItem, Element) == 0x000000, "Member 'FWeightedItem::Element' has a wrong offset!");
static_assert(offsetof(FWeightedItem, Weight) == 0x000038, "Member 'FWeightedItem::Weight' has a wrong offset!");

// ScriptStruct DeadByDaylight.QuadrantSpawnItem
// 0x0018 (0x0018 - 0x0000)
struct FQuadrantSpawnItem final
{
public:
	EQuadrantSpawnType                            Type;                                              // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FWeightedItem>                  Elements;                                          // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FQuadrantSpawnItem) == 0x000008, "Wrong alignment on FQuadrantSpawnItem");
static_assert(sizeof(FQuadrantSpawnItem) == 0x000018, "Wrong size on FQuadrantSpawnItem");
static_assert(offsetof(FQuadrantSpawnItem, Type) == 0x000000, "Member 'FQuadrantSpawnItem::Type' has a wrong offset!");
static_assert(offsetof(FQuadrantSpawnItem, Elements) == 0x000008, "Member 'FQuadrantSpawnItem::Elements' has a wrong offset!");

// ScriptStruct DeadByDaylight.QuadrantSpawnCategories
// 0x0020 (0x0020 - 0x0000)
struct FQuadrantSpawnCategories final
{
public:
	class FName                                   QuadrantSpawnTag;                                  // 0x0000(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FQuadrantSpawnItem>             Items;                                             // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FQuadrantSpawnCategories) == 0x000008, "Wrong alignment on FQuadrantSpawnCategories");
static_assert(sizeof(FQuadrantSpawnCategories) == 0x000020, "Wrong size on FQuadrantSpawnCategories");
static_assert(offsetof(FQuadrantSpawnCategories, QuadrantSpawnTag) == 0x000000, "Member 'FQuadrantSpawnCategories::QuadrantSpawnTag' has a wrong offset!");
static_assert(offsetof(FQuadrantSpawnCategories, Items) == 0x000010, "Member 'FQuadrantSpawnCategories::Items' has a wrong offset!");

// ScriptStruct DeadByDaylight.KillerProperties
// 0x0018 (0x0020 - 0x0008)
struct FKillerProperties final : public FDBDTableRowBase
{
public:
	EKillerAbilities                              KillerAbility;                                     // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameplayElementSubstitutions>  SubstitutionElements;                              // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FKillerProperties) == 0x000008, "Wrong alignment on FKillerProperties");
static_assert(sizeof(FKillerProperties) == 0x000020, "Wrong size on FKillerProperties");
static_assert(offsetof(FKillerProperties, KillerAbility) == 0x000008, "Member 'FKillerProperties::KillerAbility' has a wrong offset!");
static_assert(offsetof(FKillerProperties, SubstitutionElements) == 0x000010, "Member 'FKillerProperties::SubstitutionElements' has a wrong offset!");

// ScriptStruct DeadByDaylight.SurvivorGroupingProbability
// 0x0008 (0x0008 - 0x0000)
struct FSurvivorGroupingProbability final
{
public:
	ESurvivorGrouping                             Type;                                              // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Probability;                                       // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSurvivorGroupingProbability) == 0x000004, "Wrong alignment on FSurvivorGroupingProbability");
static_assert(sizeof(FSurvivorGroupingProbability) == 0x000008, "Wrong size on FSurvivorGroupingProbability");
static_assert(offsetof(FSurvivorGroupingProbability, Type) == 0x000000, "Member 'FSurvivorGroupingProbability::Type' has a wrong offset!");
static_assert(offsetof(FSurvivorGroupingProbability, Probability) == 0x000004, "Member 'FSurvivorGroupingProbability::Probability' has a wrong offset!");

// ScriptStruct DeadByDaylight.GameplayElementsPopulation
// 0x0088 (0x0088 - 0x0000)
struct FGameplayElementsPopulation final
{
public:
	EGameplayElementType                          Type;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ETileSpawnPointType                           TileSpawnPointType;                                // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   GameplayElementBlueprint;                          // 0x0008(0x0038)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         MinPopulation;                                     // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         MaxPopulation;                                     // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         MinGuaranteePopulation;                            // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         SpawnPass;                                         // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftClassPtr<class UClass>                   IterativeWeightAdjustmentStrategyClass;            // 0x0050(0x0038)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FGameplayElementsPopulation) == 0x000008, "Wrong alignment on FGameplayElementsPopulation");
static_assert(sizeof(FGameplayElementsPopulation) == 0x000088, "Wrong size on FGameplayElementsPopulation");
static_assert(offsetof(FGameplayElementsPopulation, Type) == 0x000000, "Member 'FGameplayElementsPopulation::Type' has a wrong offset!");
static_assert(offsetof(FGameplayElementsPopulation, TileSpawnPointType) == 0x000001, "Member 'FGameplayElementsPopulation::TileSpawnPointType' has a wrong offset!");
static_assert(offsetof(FGameplayElementsPopulation, GameplayElementBlueprint) == 0x000008, "Member 'FGameplayElementsPopulation::GameplayElementBlueprint' has a wrong offset!");
static_assert(offsetof(FGameplayElementsPopulation, MinPopulation) == 0x000040, "Member 'FGameplayElementsPopulation::MinPopulation' has a wrong offset!");
static_assert(offsetof(FGameplayElementsPopulation, MaxPopulation) == 0x000044, "Member 'FGameplayElementsPopulation::MaxPopulation' has a wrong offset!");
static_assert(offsetof(FGameplayElementsPopulation, MinGuaranteePopulation) == 0x000048, "Member 'FGameplayElementsPopulation::MinGuaranteePopulation' has a wrong offset!");
static_assert(offsetof(FGameplayElementsPopulation, SpawnPass) == 0x00004C, "Member 'FGameplayElementsPopulation::SpawnPass' has a wrong offset!");
static_assert(offsetof(FGameplayElementsPopulation, IterativeWeightAdjustmentStrategyClass) == 0x000050, "Member 'FGameplayElementsPopulation::IterativeWeightAdjustmentStrategyClass' has a wrong offset!");

// ScriptStruct DeadByDaylight.KillerItemProperty
// 0x0088 (0x0088 - 0x0000)
struct FKillerItemProperty final
{
public:
	TSoftClassPtr<class UClass>                   Object;                                            // 0x0000(0x0038)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            Population;                                        // 0x0038(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EGameplayElementType                          _gameplayElementType;                              // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   IterativeWeightAdjustmentStrategyClass;            // 0x0048(0x0038)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         _dependencySpawnOrder;                             // 0x0080(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_84[0x4];                                       // 0x0084(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FKillerItemProperty) == 0x000008, "Wrong alignment on FKillerItemProperty");
static_assert(sizeof(FKillerItemProperty) == 0x000088, "Wrong size on FKillerItemProperty");
static_assert(offsetof(FKillerItemProperty, Object) == 0x000000, "Member 'FKillerItemProperty::Object' has a wrong offset!");
static_assert(offsetof(FKillerItemProperty, Population) == 0x000038, "Member 'FKillerItemProperty::Population' has a wrong offset!");
static_assert(offsetof(FKillerItemProperty, _gameplayElementType) == 0x000040, "Member 'FKillerItemProperty::_gameplayElementType' has a wrong offset!");
static_assert(offsetof(FKillerItemProperty, IterativeWeightAdjustmentStrategyClass) == 0x000048, "Member 'FKillerItemProperty::IterativeWeightAdjustmentStrategyClass' has a wrong offset!");
static_assert(offsetof(FKillerItemProperty, _dependencySpawnOrder) == 0x000080, "Member 'FKillerItemProperty::_dependencySpawnOrder' has a wrong offset!");

// ScriptStruct DeadByDaylight.KillerItemDependencies
// 0x0018 (0x0020 - 0x0008)
struct FKillerItemDependencies final : public FDBDTableRowBase
{
public:
	EKillerAbilities                              KillerAbility;                                     // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FKillerItemProperty>            Items;                                             // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FKillerItemDependencies) == 0x000008, "Wrong alignment on FKillerItemDependencies");
static_assert(sizeof(FKillerItemDependencies) == 0x000020, "Wrong size on FKillerItemDependencies");
static_assert(offsetof(FKillerItemDependencies, KillerAbility) == 0x000008, "Member 'FKillerItemDependencies::KillerAbility' has a wrong offset!");
static_assert(offsetof(FKillerItemDependencies, Items) == 0x000010, "Member 'FKillerItemDependencies::Items' has a wrong offset!");

// ScriptStruct DeadByDaylight.SectionLenghtsProperties
// 0x0008 (0x0008 - 0x0000)
struct FSectionLenghtsProperties final
{
public:
	EDirection                                    Direction;                                         // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Length;                                            // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSectionLenghtsProperties) == 0x000004, "Wrong alignment on FSectionLenghtsProperties");
static_assert(sizeof(FSectionLenghtsProperties) == 0x000008, "Wrong size on FSectionLenghtsProperties");
static_assert(offsetof(FSectionLenghtsProperties, Direction) == 0x000000, "Member 'FSectionLenghtsProperties::Direction' has a wrong offset!");
static_assert(offsetof(FSectionLenghtsProperties, Length) == 0x000004, "Member 'FSectionLenghtsProperties::Length' has a wrong offset!");

// ScriptStruct DeadByDaylight.QuadrantSpawnTypeProperties
// 0x0018 (0x0018 - 0x0000)
struct FQuadrantSpawnTypeProperties final
{
public:
	EQuadrantSpawnType                            QuadrantSpawnType;                                 // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSectionLenghtsProperties>      SectionLenghts;                                    // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FQuadrantSpawnTypeProperties) == 0x000008, "Wrong alignment on FQuadrantSpawnTypeProperties");
static_assert(sizeof(FQuadrantSpawnTypeProperties) == 0x000018, "Wrong size on FQuadrantSpawnTypeProperties");
static_assert(offsetof(FQuadrantSpawnTypeProperties, QuadrantSpawnType) == 0x000000, "Member 'FQuadrantSpawnTypeProperties::QuadrantSpawnType' has a wrong offset!");
static_assert(offsetof(FQuadrantSpawnTypeProperties, SectionLenghts) == 0x000008, "Member 'FQuadrantSpawnTypeProperties::SectionLenghts' has a wrong offset!");

// ScriptStruct DeadByDaylight.ArrayOfSceneComponent
// 0x0010 (0x0010 - 0x0000)
struct FArrayOfSceneComponent final
{
public:
	TArray<class USceneComponent*>                SceneComp;                                         // 0x0000(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FArrayOfSceneComponent) == 0x000008, "Wrong alignment on FArrayOfSceneComponent");
static_assert(sizeof(FArrayOfSceneComponent) == 0x000010, "Wrong size on FArrayOfSceneComponent");
static_assert(offsetof(FArrayOfSceneComponent, SceneComp) == 0x000000, "Member 'FArrayOfSceneComponent::SceneComp' has a wrong offset!");

// ScriptStruct DeadByDaylight.GeneratedLevelData
// 0x0380 (0x0380 - 0x0000)
struct FGeneratedLevelData final
{
public:
	class FString                                 UsedPaperTileMap;                                  // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PremadeMap;                                        // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StreamRelatedSeed;                                 // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AvailableSurvivorItemCount;                        // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESurvivorGrouping                             GroupingType;                                      // 0x0028(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        KillerSpawnPoint;                                  // 0x0030(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class USceneComponent*>                AdditionalKillerSpawnPoints;                       // 0x0038(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class USceneComponent*>                SurvivorSpawnPoints;                               // 0x0048(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class USceneComponent*>                InteractableElementsSpawnPoints;                   // 0x0058(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class USceneComponent*>                KillerItemsSpawnPoints;                            // 0x0068(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TMap<class FName, int32>                      SpecialBehaviourRequestCounts;                     // 0x0078(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FName, struct FArrayOfSceneComponent> SpecialBehaviourSpawnPoints;                       // 0x00C8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TMap<class FName, struct FArrayOfSceneComponent> SpecialBehaviourActorSpawners;                     // 0x0118(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class USceneComponent*>                SearchableSpawners;                                // 0x0168(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class USceneComponent*>                HexSpawners;                                       // 0x0178(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class USceneComponent*>                KillerLairSpawners;                                // 0x0188(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class USceneComponent*>                HatchSpawners;                                     // 0x0198(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class USceneComponent*>                MainBuildingHatchSpawners;                         // 0x01A8(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class USceneComponent*>                ShackHatchSpawners;                                // 0x01B8(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class USceneComponent*>                BreakableWallSpawners;                             // 0x01C8(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class USceneComponent*>                EscapeSpawners;                                    // 0x01D8(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FManagedGameplayElementData            BookshelfManagedGameplayElementData;               // 0x01E8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FManagedGameplayElementData            MeatHookManagedGameplayElementData;                // 0x0238(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FDependency>                    LevelDependencies;                                 // 0x0288(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FDependency>                    LateLevelDependencies;                             // 0x0298(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         FixedMapTileIds;                                   // 0x02A8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         FixedMapOrphanSpawners;                            // 0x02B8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class USceneComponent*>                FinisherMoriSpawnPoints;                           // 0x02C8(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class USceneComponent*>                SteamPipeSpawners;                                 // 0x02D8(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class USceneComponent*>                SteamPipeButtonSpawners;                           // 0x02E8(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class USceneComponent*>                BasementSeanceSpawners;                            // 0x02F8(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class USceneComponent*>                VoidSpawners;                                      // 0x0308(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class FName                                   SpecialEventId;                                    // 0x0318(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SpecialEventIdForGameplayAdditions;                // 0x0324(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseForcedMap;                                      // 0x0330(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UsePremadeMap;                                     // 0x0331(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_332[0x6];                                      // 0x0332(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 GenerationLogs;                                    // 0x0338(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 GenerationErrors;                                  // 0x0348(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GenerationPlayerCount;                             // 0x0358(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35C[0x4];                                      // 0x035C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FForceSpawnTileData>            ForceSpawnTileData;                                // 0x0360(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         LevelLightings;                                    // 0x0370(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGeneratedLevelData) == 0x000008, "Wrong alignment on FGeneratedLevelData");
static_assert(sizeof(FGeneratedLevelData) == 0x000380, "Wrong size on FGeneratedLevelData");
static_assert(offsetof(FGeneratedLevelData, UsedPaperTileMap) == 0x000000, "Member 'FGeneratedLevelData::UsedPaperTileMap' has a wrong offset!");
static_assert(offsetof(FGeneratedLevelData, PremadeMap) == 0x000010, "Member 'FGeneratedLevelData::PremadeMap' has a wrong offset!");
static_assert(offsetof(FGeneratedLevelData, StreamRelatedSeed) == 0x000020, "Member 'FGeneratedLevelData::StreamRelatedSeed' has a wrong offset!");
static_assert(offsetof(FGeneratedLevelData, AvailableSurvivorItemCount) == 0x000024, "Member 'FGeneratedLevelData::AvailableSurvivorItemCount' has a wrong offset!");
static_assert(offsetof(FGeneratedLevelData, GroupingType) == 0x000028, "Member 'FGeneratedLevelData::GroupingType' has a wrong offset!");
static_assert(offsetof(FGeneratedLevelData, KillerSpawnPoint) == 0x000030, "Member 'FGeneratedLevelData::KillerSpawnPoint' has a wrong offset!");
static_assert(offsetof(FGeneratedLevelData, AdditionalKillerSpawnPoints) == 0x000038, "Member 'FGeneratedLevelData::AdditionalKillerSpawnPoints' has a wrong offset!");
static_assert(offsetof(FGeneratedLevelData, SurvivorSpawnPoints) == 0x000048, "Member 'FGeneratedLevelData::SurvivorSpawnPoints' has a wrong offset!");
static_assert(offsetof(FGeneratedLevelData, InteractableElementsSpawnPoints) == 0x000058, "Member 'FGeneratedLevelData::InteractableElementsSpawnPoints' has a wrong offset!");
static_assert(offsetof(FGeneratedLevelData, KillerItemsSpawnPoints) == 0x000068, "Member 'FGeneratedLevelData::KillerItemsSpawnPoints' has a wrong offset!");
static_assert(offsetof(FGeneratedLevelData, SpecialBehaviourRequestCounts) == 0x000078, "Member 'FGeneratedLevelData::SpecialBehaviourRequestCounts' has a wrong offset!");
static_assert(offsetof(FGeneratedLevelData, SpecialBehaviourSpawnPoints) == 0x0000C8, "Member 'FGeneratedLevelData::SpecialBehaviourSpawnPoints' has a wrong offset!");
static_assert(offsetof(FGeneratedLevelData, SpecialBehaviourActorSpawners) == 0x000118, "Member 'FGeneratedLevelData::SpecialBehaviourActorSpawners' has a wrong offset!");
static_assert(offsetof(FGeneratedLevelData, SearchableSpawners) == 0x000168, "Member 'FGeneratedLevelData::SearchableSpawners' has a wrong offset!");
static_assert(offsetof(FGeneratedLevelData, HexSpawners) == 0x000178, "Member 'FGeneratedLevelData::HexSpawners' has a wrong offset!");
static_assert(offsetof(FGeneratedLevelData, KillerLairSpawners) == 0x000188, "Member 'FGeneratedLevelData::KillerLairSpawners' has a wrong offset!");
static_assert(offsetof(FGeneratedLevelData, HatchSpawners) == 0x000198, "Member 'FGeneratedLevelData::HatchSpawners' has a wrong offset!");
static_assert(offsetof(FGeneratedLevelData, MainBuildingHatchSpawners) == 0x0001A8, "Member 'FGeneratedLevelData::MainBuildingHatchSpawners' has a wrong offset!");
static_assert(offsetof(FGeneratedLevelData, ShackHatchSpawners) == 0x0001B8, "Member 'FGeneratedLevelData::ShackHatchSpawners' has a wrong offset!");
static_assert(offsetof(FGeneratedLevelData, BreakableWallSpawners) == 0x0001C8, "Member 'FGeneratedLevelData::BreakableWallSpawners' has a wrong offset!");
static_assert(offsetof(FGeneratedLevelData, EscapeSpawners) == 0x0001D8, "Member 'FGeneratedLevelData::EscapeSpawners' has a wrong offset!");
static_assert(offsetof(FGeneratedLevelData, BookshelfManagedGameplayElementData) == 0x0001E8, "Member 'FGeneratedLevelData::BookshelfManagedGameplayElementData' has a wrong offset!");
static_assert(offsetof(FGeneratedLevelData, MeatHookManagedGameplayElementData) == 0x000238, "Member 'FGeneratedLevelData::MeatHookManagedGameplayElementData' has a wrong offset!");
static_assert(offsetof(FGeneratedLevelData, LevelDependencies) == 0x000288, "Member 'FGeneratedLevelData::LevelDependencies' has a wrong offset!");
static_assert(offsetof(FGeneratedLevelData, LateLevelDependencies) == 0x000298, "Member 'FGeneratedLevelData::LateLevelDependencies' has a wrong offset!");
static_assert(offsetof(FGeneratedLevelData, FixedMapTileIds) == 0x0002A8, "Member 'FGeneratedLevelData::FixedMapTileIds' has a wrong offset!");
static_assert(offsetof(FGeneratedLevelData, FixedMapOrphanSpawners) == 0x0002B8, "Member 'FGeneratedLevelData::FixedMapOrphanSpawners' has a wrong offset!");
static_assert(offsetof(FGeneratedLevelData, FinisherMoriSpawnPoints) == 0x0002C8, "Member 'FGeneratedLevelData::FinisherMoriSpawnPoints' has a wrong offset!");
static_assert(offsetof(FGeneratedLevelData, SteamPipeSpawners) == 0x0002D8, "Member 'FGeneratedLevelData::SteamPipeSpawners' has a wrong offset!");
static_assert(offsetof(FGeneratedLevelData, SteamPipeButtonSpawners) == 0x0002E8, "Member 'FGeneratedLevelData::SteamPipeButtonSpawners' has a wrong offset!");
static_assert(offsetof(FGeneratedLevelData, BasementSeanceSpawners) == 0x0002F8, "Member 'FGeneratedLevelData::BasementSeanceSpawners' has a wrong offset!");
static_assert(offsetof(FGeneratedLevelData, VoidSpawners) == 0x000308, "Member 'FGeneratedLevelData::VoidSpawners' has a wrong offset!");
static_assert(offsetof(FGeneratedLevelData, SpecialEventId) == 0x000318, "Member 'FGeneratedLevelData::SpecialEventId' has a wrong offset!");
static_assert(offsetof(FGeneratedLevelData, SpecialEventIdForGameplayAdditions) == 0x000324, "Member 'FGeneratedLevelData::SpecialEventIdForGameplayAdditions' has a wrong offset!");
static_assert(offsetof(FGeneratedLevelData, UseForcedMap) == 0x000330, "Member 'FGeneratedLevelData::UseForcedMap' has a wrong offset!");
static_assert(offsetof(FGeneratedLevelData, UsePremadeMap) == 0x000331, "Member 'FGeneratedLevelData::UsePremadeMap' has a wrong offset!");
static_assert(offsetof(FGeneratedLevelData, GenerationLogs) == 0x000338, "Member 'FGeneratedLevelData::GenerationLogs' has a wrong offset!");
static_assert(offsetof(FGeneratedLevelData, GenerationErrors) == 0x000348, "Member 'FGeneratedLevelData::GenerationErrors' has a wrong offset!");
static_assert(offsetof(FGeneratedLevelData, GenerationPlayerCount) == 0x000358, "Member 'FGeneratedLevelData::GenerationPlayerCount' has a wrong offset!");
static_assert(offsetof(FGeneratedLevelData, ForceSpawnTileData) == 0x000360, "Member 'FGeneratedLevelData::ForceSpawnTileData' has a wrong offset!");
static_assert(offsetof(FGeneratedLevelData, LevelLightings) == 0x000370, "Member 'FGeneratedLevelData::LevelLightings' has a wrong offset!");

// ScriptStruct DeadByDaylight.ProceduralMap
// 0x00B8 (0x00C0 - 0x0008)
struct FProceduralMap final : public FDBDTableRowBase
{
public:
	class FName                                   MapId;                                             // 0x0008(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Name;                                              // 0x0018(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   ThemeName;                                         // 0x0030(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0048(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         HookMinDistance;                                   // 0x0060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HookMinCount;                                      // 0x0064(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HookMaxCount;                                      // 0x0068(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BookShelvesMinDistance;                            // 0x006C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BookShelvesMinCount;                               // 0x0070(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BookShelvesMaxCount;                               // 0x0074(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LivingWorldObjectsMinCount;                        // 0x0078(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LivingWorldObjectsMaxCount;                        // 0x007C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ThumbnailPath;                                     // 0x0080(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SortingIndex;                                      // 0x0090(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DlcIDString;                                       // 0x0098(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 FixedLayoutSeed;                                   // 0x00A8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          IsInNonViolentBuild;                               // 0x00B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsLicensed;                                        // 0x00B9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AreEventSpawnersEnabled;                           // 0x00BA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BB[0x5];                                       // 0x00BB(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FProceduralMap) == 0x000008, "Wrong alignment on FProceduralMap");
static_assert(sizeof(FProceduralMap) == 0x0000C0, "Wrong size on FProceduralMap");
static_assert(offsetof(FProceduralMap, MapId) == 0x000008, "Member 'FProceduralMap::MapId' has a wrong offset!");
static_assert(offsetof(FProceduralMap, Name) == 0x000018, "Member 'FProceduralMap::Name' has a wrong offset!");
static_assert(offsetof(FProceduralMap, ThemeName) == 0x000030, "Member 'FProceduralMap::ThemeName' has a wrong offset!");
static_assert(offsetof(FProceduralMap, Description) == 0x000048, "Member 'FProceduralMap::Description' has a wrong offset!");
static_assert(offsetof(FProceduralMap, HookMinDistance) == 0x000060, "Member 'FProceduralMap::HookMinDistance' has a wrong offset!");
static_assert(offsetof(FProceduralMap, HookMinCount) == 0x000064, "Member 'FProceduralMap::HookMinCount' has a wrong offset!");
static_assert(offsetof(FProceduralMap, HookMaxCount) == 0x000068, "Member 'FProceduralMap::HookMaxCount' has a wrong offset!");
static_assert(offsetof(FProceduralMap, BookShelvesMinDistance) == 0x00006C, "Member 'FProceduralMap::BookShelvesMinDistance' has a wrong offset!");
static_assert(offsetof(FProceduralMap, BookShelvesMinCount) == 0x000070, "Member 'FProceduralMap::BookShelvesMinCount' has a wrong offset!");
static_assert(offsetof(FProceduralMap, BookShelvesMaxCount) == 0x000074, "Member 'FProceduralMap::BookShelvesMaxCount' has a wrong offset!");
static_assert(offsetof(FProceduralMap, LivingWorldObjectsMinCount) == 0x000078, "Member 'FProceduralMap::LivingWorldObjectsMinCount' has a wrong offset!");
static_assert(offsetof(FProceduralMap, LivingWorldObjectsMaxCount) == 0x00007C, "Member 'FProceduralMap::LivingWorldObjectsMaxCount' has a wrong offset!");
static_assert(offsetof(FProceduralMap, ThumbnailPath) == 0x000080, "Member 'FProceduralMap::ThumbnailPath' has a wrong offset!");
static_assert(offsetof(FProceduralMap, SortingIndex) == 0x000090, "Member 'FProceduralMap::SortingIndex' has a wrong offset!");
static_assert(offsetof(FProceduralMap, DlcIDString) == 0x000098, "Member 'FProceduralMap::DlcIDString' has a wrong offset!");
static_assert(offsetof(FProceduralMap, FixedLayoutSeed) == 0x0000A8, "Member 'FProceduralMap::FixedLayoutSeed' has a wrong offset!");
static_assert(offsetof(FProceduralMap, IsInNonViolentBuild) == 0x0000B8, "Member 'FProceduralMap::IsInNonViolentBuild' has a wrong offset!");
static_assert(offsetof(FProceduralMap, IsLicensed) == 0x0000B9, "Member 'FProceduralMap::IsLicensed' has a wrong offset!");
static_assert(offsetof(FProceduralMap, AreEventSpawnersEnabled) == 0x0000BA, "Member 'FProceduralMap::AreEventSpawnersEnabled' has a wrong offset!");

// ScriptStruct DeadByDaylight.ProfileLoadEventData
// 0x0010 (0x0010 - 0x0000)
struct FProfileLoadEventData final
{
public:
	bool                                          FirstTimePlaying;                                  // 0x0000(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              Timestamp;                                         // 0x0008(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FProfileLoadEventData) == 0x000008, "Wrong alignment on FProfileLoadEventData");
static_assert(sizeof(FProfileLoadEventData) == 0x000010, "Wrong size on FProfileLoadEventData");
static_assert(offsetof(FProfileLoadEventData, FirstTimePlaying) == 0x000000, "Member 'FProfileLoadEventData::FirstTimePlaying' has a wrong offset!");
static_assert(offsetof(FProfileLoadEventData, Timestamp) == 0x000008, "Member 'FProfileLoadEventData::Timestamp' has a wrong offset!");

// ScriptStruct DeadByDaylight.PremiumPurchasedItemData
// 0x0028 (0x0028 - 0x0000)
struct FPremiumPurchasedItemData final
{
public:
	class FString                                 ID;                                                // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Type;                                              // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Amount;                                            // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPremiumPurchasedItemData) == 0x000008, "Wrong alignment on FPremiumPurchasedItemData");
static_assert(sizeof(FPremiumPurchasedItemData) == 0x000028, "Wrong size on FPremiumPurchasedItemData");
static_assert(offsetof(FPremiumPurchasedItemData, ID) == 0x000000, "Member 'FPremiumPurchasedItemData::ID' has a wrong offset!");
static_assert(offsetof(FPremiumPurchasedItemData, Type) == 0x000010, "Member 'FPremiumPurchasedItemData::Type' has a wrong offset!");
static_assert(offsetof(FPremiumPurchasedItemData, Amount) == 0x000020, "Member 'FPremiumPurchasedItemData::Amount' has a wrong offset!");

// ScriptStruct DeadByDaylight.PremiumPurchaseCompleteData
// 0x0010 (0x0010 - 0x0000)
struct FPremiumPurchaseCompleteData final
{
public:
	TArray<struct FPremiumPurchasedItemData>      PurchasedItems;                                    // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPremiumPurchaseCompleteData) == 0x000008, "Wrong alignment on FPremiumPurchaseCompleteData");
static_assert(sizeof(FPremiumPurchaseCompleteData) == 0x000010, "Wrong size on FPremiumPurchaseCompleteData");
static_assert(offsetof(FPremiumPurchaseCompleteData, PurchasedItems) == 0x000000, "Member 'FPremiumPurchaseCompleteData::PurchasedItems' has a wrong offset!");

// ScriptStruct DeadByDaylight.QuestParameterType
// 0x0010 (0x0018 - 0x0008)
struct FQuestParameterType final : public FDBDTableRowBase
{
public:
	class FString                                 ID;                                                // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FQuestParameterType) == 0x000008, "Wrong alignment on FQuestParameterType");
static_assert(sizeof(FQuestParameterType) == 0x000018, "Wrong size on FQuestParameterType");
static_assert(offsetof(FQuestParameterType, ID) == 0x000008, "Member 'FQuestParameterType::ID' has a wrong offset!");

// ScriptStruct DeadByDaylight.RandomPerksData
// 0x0048 (0x0048 - 0x0000)
struct alignas(0x08) FRandomPerksData final
{
public:
	uint8                                         Pad_0[0x48];                                       // 0x0000(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRandomPerksData) == 0x000008, "Wrong alignment on FRandomPerksData");
static_assert(sizeof(FRandomPerksData) == 0x000048, "Wrong size on FRandomPerksData");

// ScriptStruct DeadByDaylight.RandomRewardsData
// 0x0020 (0x0020 - 0x0000)
struct FRandomRewardsData final
{
public:
	class FString                                 RewardId;                                          // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FRewardResponseItem>            Rewards;                                           // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRandomRewardsData) == 0x000008, "Wrong alignment on FRandomRewardsData");
static_assert(sizeof(FRandomRewardsData) == 0x000020, "Wrong size on FRandomRewardsData");
static_assert(offsetof(FRandomRewardsData, RewardId) == 0x000000, "Member 'FRandomRewardsData::RewardId' has a wrong offset!");
static_assert(offsetof(FRandomRewardsData, Rewards) == 0x000010, "Member 'FRandomRewardsData::Rewards' has a wrong offset!");

// ScriptStruct DeadByDaylight.RandomRewards
// 0x0018 (0x0018 - 0x0000)
struct FRandomRewards final
{
public:
	TArray<struct FRandomRewardsData>             RandomRewards;                                     // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          RandomRewards_IsSet;                               // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRandomRewards) == 0x000008, "Wrong alignment on FRandomRewards");
static_assert(sizeof(FRandomRewards) == 0x000018, "Wrong size on FRandomRewards");
static_assert(offsetof(FRandomRewards, RandomRewards) == 0x000000, "Member 'FRandomRewards::RandomRewards' has a wrong offset!");
static_assert(offsetof(FRandomRewards, RandomRewards_IsSet) == 0x000010, "Member 'FRandomRewards::RandomRewards_IsSet' has a wrong offset!");

// ScriptStruct DeadByDaylight.RankNameData
// 0x0020 (0x0028 - 0x0008)
struct FRankNameData final : public FDBDTableRowBase
{
public:
	class FText                                   RankName;                                          // 0x0008(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         SubRanks;                                          // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRankNameData) == 0x000008, "Wrong alignment on FRankNameData");
static_assert(sizeof(FRankNameData) == 0x000028, "Wrong size on FRankNameData");
static_assert(offsetof(FRankNameData, RankName) == 0x000008, "Member 'FRankNameData::RankName' has a wrong offset!");
static_assert(offsetof(FRankNameData, SubRanks) == 0x000020, "Member 'FRankNameData::SubRanks' has a wrong offset!");

// ScriptStruct DeadByDaylight.RarityDistributionValue
// 0x0010 (0x0018 - 0x0008)
struct FRarityDistributionValue final : public FDBDTableRowBase
{
public:
	int32                                         InnerRing;                                         // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MiddleRing;                                        // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OuterRing;                                         // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRarityDistributionValue) == 0x000008, "Wrong alignment on FRarityDistributionValue");
static_assert(sizeof(FRarityDistributionValue) == 0x000018, "Wrong size on FRarityDistributionValue");
static_assert(offsetof(FRarityDistributionValue, InnerRing) == 0x000008, "Member 'FRarityDistributionValue::InnerRing' has a wrong offset!");
static_assert(offsetof(FRarityDistributionValue, MiddleRing) == 0x00000C, "Member 'FRarityDistributionValue::MiddleRing' has a wrong offset!");
static_assert(offsetof(FRarityDistributionValue, OuterRing) == 0x000010, "Member 'FRarityDistributionValue::OuterRing' has a wrong offset!");

// ScriptStruct DeadByDaylight.DBDRecentGameplayEvents
// 0x0050 (0x0050 - 0x0000)
struct FDBDRecentGameplayEvents final
{
public:
	TMap<EDBDScoreTypes, struct FDateTime>        _recentGameplayEvents;                             // 0x0000(0x0050)(NativeAccessSpecifierPrivate)
};
static_assert(alignof(FDBDRecentGameplayEvents) == 0x000008, "Wrong alignment on FDBDRecentGameplayEvents");
static_assert(sizeof(FDBDRecentGameplayEvents) == 0x000050, "Wrong size on FDBDRecentGameplayEvents");
static_assert(offsetof(FDBDRecentGameplayEvents, _recentGameplayEvents) == 0x000000, "Member 'FDBDRecentGameplayEvents::_recentGameplayEvents' has a wrong offset!");

// ScriptStruct DeadByDaylight.RefundKeyUIData
// 0x0058 (0x0058 - 0x0000)
struct FRefundKeyUIData final
{
public:
	class FName                                   ID;                                                // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 IconFilePath;                                      // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   DisplayName;                                       // 0x0020(0x0018)(NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0038(0x0018)(NativeAccessSpecifierPublic)
	ERefundSource                                 Source;                                            // 0x0050(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRefundKeyUIData) == 0x000008, "Wrong alignment on FRefundKeyUIData");
static_assert(sizeof(FRefundKeyUIData) == 0x000058, "Wrong size on FRefundKeyUIData");
static_assert(offsetof(FRefundKeyUIData, ID) == 0x000000, "Member 'FRefundKeyUIData::ID' has a wrong offset!");
static_assert(offsetof(FRefundKeyUIData, IconFilePath) == 0x000010, "Member 'FRefundKeyUIData::IconFilePath' has a wrong offset!");
static_assert(offsetof(FRefundKeyUIData, DisplayName) == 0x000020, "Member 'FRefundKeyUIData::DisplayName' has a wrong offset!");
static_assert(offsetof(FRefundKeyUIData, Description) == 0x000038, "Member 'FRefundKeyUIData::Description' has a wrong offset!");
static_assert(offsetof(FRefundKeyUIData, Source) == 0x000050, "Member 'FRefundKeyUIData::Source' has a wrong offset!");

// ScriptStruct DeadByDaylight.Region
// 0x0020 (0x0020 - 0x0000)
struct FRegion final
{
public:
	class FName                                   Region;                                            // 0x0000(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 IP;                                                // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRegion) == 0x000008, "Wrong alignment on FRegion");
static_assert(sizeof(FRegion) == 0x000020, "Wrong size on FRegion");
static_assert(offsetof(FRegion, Region) == 0x000000, "Member 'FRegion::Region' has a wrong offset!");
static_assert(offsetof(FRegion, IP) == 0x000010, "Member 'FRegion::IP' has a wrong offset!");

// ScriptStruct DeadByDaylight.ReportData
// 0x0030 (0x0030 - 0x0000)
struct FReportData final
{
public:
	class FString                                 Type;                                              // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Reason;                                            // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Comment;                                           // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FReportData) == 0x000008, "Wrong alignment on FReportData");
static_assert(sizeof(FReportData) == 0x000030, "Wrong size on FReportData");
static_assert(offsetof(FReportData, Type) == 0x000000, "Member 'FReportData::Type' has a wrong offset!");
static_assert(offsetof(FReportData, Reason) == 0x000010, "Member 'FReportData::Reason' has a wrong offset!");
static_assert(offsetof(FReportData, Comment) == 0x000020, "Member 'FReportData::Comment' has a wrong offset!");

// ScriptStruct DeadByDaylight.RewardItemData
// 0x0038 (0x0038 - 0x0000)
struct FRewardItemData final
{
public:
	class FString                                 IconPath;                                          // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Title;                                             // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Description;                                       // 0x0020(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemRarity                                   Rarity;                                            // 0x0030(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInventoryItemType                            ItemType;                                          // 0x0031(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsDuplicate;                                       // 0x0032(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECurrencyType                                 CurrencyType;                                      // 0x0033(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrencyAmount;                                    // 0x0034(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRewardItemData) == 0x000008, "Wrong alignment on FRewardItemData");
static_assert(sizeof(FRewardItemData) == 0x000038, "Wrong size on FRewardItemData");
static_assert(offsetof(FRewardItemData, IconPath) == 0x000000, "Member 'FRewardItemData::IconPath' has a wrong offset!");
static_assert(offsetof(FRewardItemData, Title) == 0x000010, "Member 'FRewardItemData::Title' has a wrong offset!");
static_assert(offsetof(FRewardItemData, Description) == 0x000020, "Member 'FRewardItemData::Description' has a wrong offset!");
static_assert(offsetof(FRewardItemData, Rarity) == 0x000030, "Member 'FRewardItemData::Rarity' has a wrong offset!");
static_assert(offsetof(FRewardItemData, ItemType) == 0x000031, "Member 'FRewardItemData::ItemType' has a wrong offset!");
static_assert(offsetof(FRewardItemData, IsDuplicate) == 0x000032, "Member 'FRewardItemData::IsDuplicate' has a wrong offset!");
static_assert(offsetof(FRewardItemData, CurrencyType) == 0x000033, "Member 'FRewardItemData::CurrencyType' has a wrong offset!");
static_assert(offsetof(FRewardItemData, CurrencyAmount) == 0x000034, "Member 'FRewardItemData::CurrencyAmount' has a wrong offset!");

// ScriptStruct DeadByDaylight.S3AnalyticsRules
// 0x00A8 (0x00A8 - 0x0000)
struct FS3AnalyticsRules final
{
public:
	TArray<class FString>                         AF;                                                // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          AF_IsSet;                                          // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         BL;                                                // 0x0018(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          BL_IsSet;                                          // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         DD;                                                // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          DD_IsSet;                                          // 0x0040(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         KAL;                                               // 0x0048(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          KAL_IsSet;                                         // 0x0058(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         KA;                                                // 0x0060(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          KA_IsSet;                                          // 0x0070(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         KL;                                                // 0x0078(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          KL_IsSet;                                          // 0x0088(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         All;                                               // 0x0090(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          ALL_IsSet;                                         // 0x00A0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FS3AnalyticsRules) == 0x000008, "Wrong alignment on FS3AnalyticsRules");
static_assert(sizeof(FS3AnalyticsRules) == 0x0000A8, "Wrong size on FS3AnalyticsRules");
static_assert(offsetof(FS3AnalyticsRules, AF) == 0x000000, "Member 'FS3AnalyticsRules::AF' has a wrong offset!");
static_assert(offsetof(FS3AnalyticsRules, AF_IsSet) == 0x000010, "Member 'FS3AnalyticsRules::AF_IsSet' has a wrong offset!");
static_assert(offsetof(FS3AnalyticsRules, BL) == 0x000018, "Member 'FS3AnalyticsRules::BL' has a wrong offset!");
static_assert(offsetof(FS3AnalyticsRules, BL_IsSet) == 0x000028, "Member 'FS3AnalyticsRules::BL_IsSet' has a wrong offset!");
static_assert(offsetof(FS3AnalyticsRules, DD) == 0x000030, "Member 'FS3AnalyticsRules::DD' has a wrong offset!");
static_assert(offsetof(FS3AnalyticsRules, DD_IsSet) == 0x000040, "Member 'FS3AnalyticsRules::DD_IsSet' has a wrong offset!");
static_assert(offsetof(FS3AnalyticsRules, KAL) == 0x000048, "Member 'FS3AnalyticsRules::KAL' has a wrong offset!");
static_assert(offsetof(FS3AnalyticsRules, KAL_IsSet) == 0x000058, "Member 'FS3AnalyticsRules::KAL_IsSet' has a wrong offset!");
static_assert(offsetof(FS3AnalyticsRules, KA) == 0x000060, "Member 'FS3AnalyticsRules::KA' has a wrong offset!");
static_assert(offsetof(FS3AnalyticsRules, KA_IsSet) == 0x000070, "Member 'FS3AnalyticsRules::KA_IsSet' has a wrong offset!");
static_assert(offsetof(FS3AnalyticsRules, KL) == 0x000078, "Member 'FS3AnalyticsRules::KL' has a wrong offset!");
static_assert(offsetof(FS3AnalyticsRules, KL_IsSet) == 0x000088, "Member 'FS3AnalyticsRules::KL_IsSet' has a wrong offset!");
static_assert(offsetof(FS3AnalyticsRules, All) == 0x000090, "Member 'FS3AnalyticsRules::All' has a wrong offset!");
static_assert(offsetof(FS3AnalyticsRules, ALL_IsSet) == 0x0000A0, "Member 'FS3AnalyticsRules::ALL_IsSet' has a wrong offset!");

// ScriptStruct DeadByDaylight.S3BeginnerTutorialLevelConfig
// 0x0008 (0x0008 - 0x0000)
struct FS3BeginnerTutorialLevelConfig final
{
public:
	int32                                         LevelToHideTutorial;                               // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PrestigeToHideTutorial;                            // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FS3BeginnerTutorialLevelConfig) == 0x000004, "Wrong alignment on FS3BeginnerTutorialLevelConfig");
static_assert(sizeof(FS3BeginnerTutorialLevelConfig) == 0x000008, "Wrong size on FS3BeginnerTutorialLevelConfig");
static_assert(offsetof(FS3BeginnerTutorialLevelConfig, LevelToHideTutorial) == 0x000000, "Member 'FS3BeginnerTutorialLevelConfig::LevelToHideTutorial' has a wrong offset!");
static_assert(offsetof(FS3BeginnerTutorialLevelConfig, PrestigeToHideTutorial) == 0x000004, "Member 'FS3BeginnerTutorialLevelConfig::PrestigeToHideTutorial' has a wrong offset!");

// ScriptStruct DeadByDaylight.S3CommentatorConfig
// 0x0001 (0x0001 - 0x0000)
struct FS3CommentatorConfig final
{
public:
	bool                                          EnableCommentatorSaveHistory;                      // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FS3CommentatorConfig) == 0x000001, "Wrong alignment on FS3CommentatorConfig");
static_assert(sizeof(FS3CommentatorConfig) == 0x000001, "Wrong size on FS3CommentatorConfig");
static_assert(offsetof(FS3CommentatorConfig, EnableCommentatorSaveHistory) == 0x000000, "Member 'FS3CommentatorConfig::EnableCommentatorSaveHistory' has a wrong offset!");

// ScriptStruct DeadByDaylight.S3DisconnectionBotReplacementConfig
// 0x0040 (0x0040 - 0x0000)
struct FS3DisconnectionBotReplacementConfig final
{
public:
	bool                                          EnableDisconnectionBotReplacement;                 // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReplacementBotRank;                                // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UsePlayerRankForReplacementBot;                    // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         BotKillswitchRules;                                // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          BotKillswitchRules_IsSet;                          // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         DisableBotReplacementDuringMapLoadingGameTypes;    // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          DisableBotReplacementDuringMapLoadingGameTypes_IsSet; // 0x0038(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FS3DisconnectionBotReplacementConfig) == 0x000008, "Wrong alignment on FS3DisconnectionBotReplacementConfig");
static_assert(sizeof(FS3DisconnectionBotReplacementConfig) == 0x000040, "Wrong size on FS3DisconnectionBotReplacementConfig");
static_assert(offsetof(FS3DisconnectionBotReplacementConfig, EnableDisconnectionBotReplacement) == 0x000000, "Member 'FS3DisconnectionBotReplacementConfig::EnableDisconnectionBotReplacement' has a wrong offset!");
static_assert(offsetof(FS3DisconnectionBotReplacementConfig, ReplacementBotRank) == 0x000004, "Member 'FS3DisconnectionBotReplacementConfig::ReplacementBotRank' has a wrong offset!");
static_assert(offsetof(FS3DisconnectionBotReplacementConfig, UsePlayerRankForReplacementBot) == 0x000008, "Member 'FS3DisconnectionBotReplacementConfig::UsePlayerRankForReplacementBot' has a wrong offset!");
static_assert(offsetof(FS3DisconnectionBotReplacementConfig, BotKillswitchRules) == 0x000010, "Member 'FS3DisconnectionBotReplacementConfig::BotKillswitchRules' has a wrong offset!");
static_assert(offsetof(FS3DisconnectionBotReplacementConfig, BotKillswitchRules_IsSet) == 0x000020, "Member 'FS3DisconnectionBotReplacementConfig::BotKillswitchRules_IsSet' has a wrong offset!");
static_assert(offsetof(FS3DisconnectionBotReplacementConfig, DisableBotReplacementDuringMapLoadingGameTypes) == 0x000028, "Member 'FS3DisconnectionBotReplacementConfig::DisableBotReplacementDuringMapLoadingGameTypes' has a wrong offset!");
static_assert(offsetof(FS3DisconnectionBotReplacementConfig, DisableBotReplacementDuringMapLoadingGameTypes_IsSet) == 0x000038, "Member 'FS3DisconnectionBotReplacementConfig::DisableBotReplacementDuringMapLoadingGameTypes_IsSet' has a wrong offset!");

// ScriptStruct DeadByDaylight.S3DLCAdditionalInfoEntry
// 0x0040 (0x0040 - 0x0000)
struct FS3DLCAdditionalInfoEntry final
{
public:
	class FString                                 DLCId;                                             // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AvailableStartDate;                                // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AvailableStartDate_IsSet;                          // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 AvailableEndDate;                                  // 0x0028(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AvailableEndDate_IsSet;                            // 0x0038(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsShownInGameStore;                                // 0x0039(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsShownInGameStore_IsSet;                          // 0x003A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsChapterDlc;                                      // 0x003B(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsChapterDlc_IsSet;                                // 0x003C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FS3DLCAdditionalInfoEntry) == 0x000008, "Wrong alignment on FS3DLCAdditionalInfoEntry");
static_assert(sizeof(FS3DLCAdditionalInfoEntry) == 0x000040, "Wrong size on FS3DLCAdditionalInfoEntry");
static_assert(offsetof(FS3DLCAdditionalInfoEntry, DLCId) == 0x000000, "Member 'FS3DLCAdditionalInfoEntry::DLCId' has a wrong offset!");
static_assert(offsetof(FS3DLCAdditionalInfoEntry, AvailableStartDate) == 0x000010, "Member 'FS3DLCAdditionalInfoEntry::AvailableStartDate' has a wrong offset!");
static_assert(offsetof(FS3DLCAdditionalInfoEntry, AvailableStartDate_IsSet) == 0x000020, "Member 'FS3DLCAdditionalInfoEntry::AvailableStartDate_IsSet' has a wrong offset!");
static_assert(offsetof(FS3DLCAdditionalInfoEntry, AvailableEndDate) == 0x000028, "Member 'FS3DLCAdditionalInfoEntry::AvailableEndDate' has a wrong offset!");
static_assert(offsetof(FS3DLCAdditionalInfoEntry, AvailableEndDate_IsSet) == 0x000038, "Member 'FS3DLCAdditionalInfoEntry::AvailableEndDate_IsSet' has a wrong offset!");
static_assert(offsetof(FS3DLCAdditionalInfoEntry, IsShownInGameStore) == 0x000039, "Member 'FS3DLCAdditionalInfoEntry::IsShownInGameStore' has a wrong offset!");
static_assert(offsetof(FS3DLCAdditionalInfoEntry, IsShownInGameStore_IsSet) == 0x00003A, "Member 'FS3DLCAdditionalInfoEntry::IsShownInGameStore_IsSet' has a wrong offset!");
static_assert(offsetof(FS3DLCAdditionalInfoEntry, IsChapterDlc) == 0x00003B, "Member 'FS3DLCAdditionalInfoEntry::IsChapterDlc' has a wrong offset!");
static_assert(offsetof(FS3DLCAdditionalInfoEntry, IsChapterDlc_IsSet) == 0x00003C, "Member 'FS3DLCAdditionalInfoEntry::IsChapterDlc_IsSet' has a wrong offset!");

// ScriptStruct DeadByDaylight.S3DLCConfig
// 0x0010 (0x0010 - 0x0000)
struct FS3DLCConfig final
{
public:
	TArray<struct FS3DLCAdditionalInfoEntry>      DlcAdditionalInfo;                                 // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FS3DLCConfig) == 0x000008, "Wrong alignment on FS3DLCConfig");
static_assert(sizeof(FS3DLCConfig) == 0x000010, "Wrong size on FS3DLCConfig");
static_assert(offsetof(FS3DLCConfig, DlcAdditionalInfo) == 0x000000, "Member 'FS3DLCConfig::DlcAdditionalInfo' has a wrong offset!");

// ScriptStruct DeadByDaylight.S3FriendsListGameConfig
// 0x000C (0x000C - 0x0000)
struct FS3FriendsListGameConfig final
{
public:
	int32                                         MaxFriendSuggestionsFacebook;                      // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxFriendSuggestionsGoogle;                        // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxFriendSuggestionsRecentlyPlayed;                // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FS3FriendsListGameConfig) == 0x000004, "Wrong alignment on FS3FriendsListGameConfig");
static_assert(sizeof(FS3FriendsListGameConfig) == 0x00000C, "Wrong size on FS3FriendsListGameConfig");
static_assert(offsetof(FS3FriendsListGameConfig, MaxFriendSuggestionsFacebook) == 0x000000, "Member 'FS3FriendsListGameConfig::MaxFriendSuggestionsFacebook' has a wrong offset!");
static_assert(offsetof(FS3FriendsListGameConfig, MaxFriendSuggestionsGoogle) == 0x000004, "Member 'FS3FriendsListGameConfig::MaxFriendSuggestionsGoogle' has a wrong offset!");
static_assert(offsetof(FS3FriendsListGameConfig, MaxFriendSuggestionsRecentlyPlayed) == 0x000008, "Member 'FS3FriendsListGameConfig::MaxFriendSuggestionsRecentlyPlayed' has a wrong offset!");

// ScriptStruct DeadByDaylight.S3MatchConfig
// 0x0008 (0x0008 - 0x0000)
struct FS3MatchConfig final
{
public:
	int32                                         MaxMatchSeconds;                                   // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxEndGameCollapseSeconds;                         // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FS3MatchConfig) == 0x000004, "Wrong alignment on FS3MatchConfig");
static_assert(sizeof(FS3MatchConfig) == 0x000008, "Wrong size on FS3MatchConfig");
static_assert(offsetof(FS3MatchConfig, MaxMatchSeconds) == 0x000000, "Member 'FS3MatchConfig::MaxMatchSeconds' has a wrong offset!");
static_assert(offsetof(FS3MatchConfig, MaxEndGameCollapseSeconds) == 0x000004, "Member 'FS3MatchConfig::MaxEndGameCollapseSeconds' has a wrong offset!");

// ScriptStruct DeadByDaylight.S3MarketingConfig
// 0x0018 (0x0018 - 0x0000)
struct FS3MarketingConfig final
{
public:
	TArray<class FString>                         CRMFlowKillswitchPlatforms;                        // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          CRMFlowKillswitchPlatforms_IsSet;                  // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FS3MarketingConfig) == 0x000008, "Wrong alignment on FS3MarketingConfig");
static_assert(sizeof(FS3MarketingConfig) == 0x000018, "Wrong size on FS3MarketingConfig");
static_assert(offsetof(FS3MarketingConfig, CRMFlowKillswitchPlatforms) == 0x000000, "Member 'FS3MarketingConfig::CRMFlowKillswitchPlatforms' has a wrong offset!");
static_assert(offsetof(FS3MarketingConfig, CRMFlowKillswitchPlatforms_IsSet) == 0x000010, "Member 'FS3MarketingConfig::CRMFlowKillswitchPlatforms_IsSet' has a wrong offset!");

// ScriptStruct DeadByDaylight.S3OnlineConfig
// 0x0020 (0x0020 - 0x0000)
struct FS3OnlineConfig final
{
public:
	TArray<int32>                                 HiddenProgressiveQueueDelays;                      // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         HiddenQueueDelayResetThreshold;                    // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RandomQueueDelayMin;                               // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RandomQueueDelayMax;                               // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FS3OnlineConfig) == 0x000008, "Wrong alignment on FS3OnlineConfig");
static_assert(sizeof(FS3OnlineConfig) == 0x000020, "Wrong size on FS3OnlineConfig");
static_assert(offsetof(FS3OnlineConfig, HiddenProgressiveQueueDelays) == 0x000000, "Member 'FS3OnlineConfig::HiddenProgressiveQueueDelays' has a wrong offset!");
static_assert(offsetof(FS3OnlineConfig, HiddenQueueDelayResetThreshold) == 0x000010, "Member 'FS3OnlineConfig::HiddenQueueDelayResetThreshold' has a wrong offset!");
static_assert(offsetof(FS3OnlineConfig, RandomQueueDelayMin) == 0x000014, "Member 'FS3OnlineConfig::RandomQueueDelayMin' has a wrong offset!");
static_assert(offsetof(FS3OnlineConfig, RandomQueueDelayMax) == 0x000018, "Member 'FS3OnlineConfig::RandomQueueDelayMax' has a wrong offset!");

// ScriptStruct DeadByDaylight.S3SecurityConfig
// 0x0002 (0x0002 - 0x0000)
struct FS3SecurityConfig final
{
public:
	bool                                          AllowServerCheats;                                 // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AllowClientGuestProviderOnServerLogin;             // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FS3SecurityConfig) == 0x000001, "Wrong alignment on FS3SecurityConfig");
static_assert(sizeof(FS3SecurityConfig) == 0x000002, "Wrong size on FS3SecurityConfig");
static_assert(offsetof(FS3SecurityConfig, AllowServerCheats) == 0x000000, "Member 'FS3SecurityConfig::AllowServerCheats' has a wrong offset!");
static_assert(offsetof(FS3SecurityConfig, AllowClientGuestProviderOnServerLogin) == 0x000001, "Member 'FS3SecurityConfig::AllowClientGuestProviderOnServerLogin' has a wrong offset!");

// ScriptStruct DeadByDaylight.S3KrakenSdkValidationConfig
// 0x0020 (0x0020 - 0x0000)
struct FS3KrakenSdkValidationConfig final
{
public:
	bool                                          Enabled;                                           // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseWhitelist;                                      // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         Whitelist;                                         // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          Whitelist_IsSet;                                   // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FS3KrakenSdkValidationConfig) == 0x000008, "Wrong alignment on FS3KrakenSdkValidationConfig");
static_assert(sizeof(FS3KrakenSdkValidationConfig) == 0x000020, "Wrong size on FS3KrakenSdkValidationConfig");
static_assert(offsetof(FS3KrakenSdkValidationConfig, Enabled) == 0x000000, "Member 'FS3KrakenSdkValidationConfig::Enabled' has a wrong offset!");
static_assert(offsetof(FS3KrakenSdkValidationConfig, UseWhitelist) == 0x000001, "Member 'FS3KrakenSdkValidationConfig::UseWhitelist' has a wrong offset!");
static_assert(offsetof(FS3KrakenSdkValidationConfig, Whitelist) == 0x000008, "Member 'FS3KrakenSdkValidationConfig::Whitelist' has a wrong offset!");
static_assert(offsetof(FS3KrakenSdkValidationConfig, Whitelist_IsSet) == 0x000018, "Member 'FS3KrakenSdkValidationConfig::Whitelist_IsSet' has a wrong offset!");

// ScriptStruct DeadByDaylight.S3SeenPopupsConfig
// 0x0020 (0x0020 - 0x0000)
struct FS3SeenPopupsConfig final
{
public:
	class FString                                 ID;                                                // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FS3SeenPopupsConfigEntry>       Configs;                                           // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FS3SeenPopupsConfig) == 0x000008, "Wrong alignment on FS3SeenPopupsConfig");
static_assert(sizeof(FS3SeenPopupsConfig) == 0x000020, "Wrong size on FS3SeenPopupsConfig");
static_assert(offsetof(FS3SeenPopupsConfig, ID) == 0x000000, "Member 'FS3SeenPopupsConfig::ID' has a wrong offset!");
static_assert(offsetof(FS3SeenPopupsConfig, Configs) == 0x000010, "Member 'FS3SeenPopupsConfig::Configs' has a wrong offset!");

// ScriptStruct DeadByDaylight.S3GameConfigsData
// 0x0590 (0x0590 - 0x0000)
struct FS3GameConfigsData final
{
public:
	struct FS3AnalyticsConfig                     Analytics;                                         // 0x0000(0x00C8)(NativeAccessSpecifierPublic)
	struct FArchivesConfig                        Archives;                                          // 0x00C8(0x0004)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_CC[0x4];                                       // 0x00CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBalanceToolGameConfig                 BalanceTool;                                       // 0x00D0(0x0010)(NativeAccessSpecifierPublic)
	bool                                          BalanceTool_IsSet;                                 // 0x00E0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E1[0x3];                                       // 0x00E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FS3BeginnerTutorialLevelConfig         BeginnerTutorialLevel;                             // 0x00E4(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_EC[0x4];                                       // 0x00EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBotMatchConfig                        BotMatch;                                          // 0x00F0(0x0020)(NativeAccessSpecifierPublic)
	struct FDedicatedServerGameConfig             DedicatedServer;                                   // 0x0110(0x0018)(NativeAccessSpecifierPublic)
	struct FS3DLCConfig                           Dlc;                                               // 0x0128(0x0010)(NativeAccessSpecifierPublic)
	bool                                          EnableNetAsyncLoading;                             // 0x0138(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnablePlayersConnectionStatus;                     // 0x0139(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnablePlayerIdInSurvey;                            // 0x013A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnableBotsInCustomMatch;                           // 0x013B(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DisableNavigationDuringMatchmaking;                // 0x013C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13D[0x3];                                      // 0x013D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RTMTimeoutThreshold;                               // 0x0140(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GameLoadingTimeout;                                // 0x0144(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnableHapticVibration;                             // 0x0148(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnableWinGDKAccountMismatchPopup;                  // 0x0149(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnableAntiMoveHack;                                // 0x014A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnablePostIISCinematic;                            // 0x014B(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnablePlayStationTrophiesIISSync;                  // 0x014C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnableDSQuestsUpdate;                              // 0x014D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14E[0x2];                                      // 0x014E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, bool>                     CrossPromoManagerPlatforms;                        // 0x0150(0x0050)(NativeAccessSpecifierPublic)
	bool                                          CrossPromoManagerPlatforms_IsSet;                  // 0x01A0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A1[0x3];                                      // 0x01A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FS3FriendsListGameConfig               FriendsList;                                       // 0x01A4(0x000C)(NoDestructor, NativeAccessSpecifierPublic)
	struct FHitValidationGameConfig               HitValidation;                                     // 0x01B0(0x0018)(NativeAccessSpecifierPublic)
	struct FAnimBudgeterGameConfig                AnimBudgeter;                                      // 0x01C8(0x0028)(NativeAccessSpecifierPublic)
	bool                                          AnimBudgeter_IsSet;                                // 0x01F0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FJwtGameConfig                         Jwt;                                               // 0x01F1(0x0001)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F2[0x2];                                      // 0x01F2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FS3MatchConfig                         Match;                                             // 0x01F4(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FC[0x4];                                      // 0x01FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FHangTimesPerStep>              HangTimes;                                         // 0x0200(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FS3MarketingConfig                     Marketing;                                         // 0x0210(0x0018)(NativeAccessSpecifierPublic)
	bool                                          EnableCrossPromoPopupDisplay;                      // 0x0228(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnableCrossPromoPopupDisplay_IsSet;                // 0x0229(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22A[0x6];                                      // 0x022A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, bool>                     MatchmakingCrossplayPlatforms;                     // 0x0230(0x0050)(NativeAccessSpecifierPublic)
	struct FS3MirrorsDefaultRetryPolicyConfig     MirrorsDefaultRetryPolicy;                         // 0x0280(0x000C)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_28C[0x4];                                      // 0x028C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FS3OnlineConfig                        Online;                                            // 0x0290(0x0020)(NativeAccessSpecifierPublic)
	struct FS3SecurityConfig                      Security;                                          // 0x02B0(0x0002)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B2[0x6];                                      // 0x02B2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FS3KrakenSdkValidationConfig           KrakenSdkValidation;                               // 0x02B8(0x0020)(NativeAccessSpecifierPublic)
	struct FS3ContentVersionConfig                ContentVersion;                                    // 0x02D8(0x0018)(NoDestructor, NativeAccessSpecifierPublic)
	struct FS3DisconnectionBotReplacementConfig   DisconnectionBotReplacement;                       // 0x02F0(0x0040)(NativeAccessSpecifierPublic)
	struct FS3CommentatorConfig                   Commentator;                                       // 0x0330(0x0001)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_331[0x7];                                      // 0x0331(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, struct FS3SeenPopupsConfig> SeenPopupsConfig;                                  // 0x0338(0x0050)(NativeAccessSpecifierPublic)
	TMap<class FString, bool>                     SocialCrossfriendsPlatforms;                       // 0x0388(0x0050)(NativeAccessSpecifierPublic)
	TMap<class FString, bool>                     SocialCrossprogressionPlatforms;                   // 0x03D8(0x0050)(NativeAccessSpecifierPublic)
	bool                                          EnableMoriPreviewButton;                           // 0x0428(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnableRealtimeMoriPreview;                         // 0x0429(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnableRealtimeMoriPreview_IsSet;                   // 0x042A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnableAntiCamping;                                 // 0x042B(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnableConsumableQueryFromKraken;                   // 0x042C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnableLimitRegressionEvents;                       // 0x042D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnableLobbyKickPlayerForCharacterOwnership;        // 0x042E(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42F[0x1];                                      // 0x042F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         EnableFullProfileSaveAtLocation;                   // 0x0430(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          EnableLocalStartSnapping;                          // 0x0440(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnableUmgStore;                                    // 0x0441(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnableContainerAgressiveMemorySaving;              // 0x0442(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnableFirstMoveAfterForcedUpdates;                 // 0x0443(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DSProviderOnShutdownNotificationDelay;             // 0x0444(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnableAlwaysSendCrashWithUI;                       // 0x0448(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_449[0x7];                                      // 0x0449(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FS3DynamicContentConfig                DynamicContent;                                    // 0x0450(0x0018)(NativeAccessSpecifierPublic)
	bool                                          DynamicContent_IsSet;                              // 0x0468(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_469[0x7];                                      // 0x0469(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         EnableSimulateMovementOptimization;                // 0x0470(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         DisableSecretRewards;                              // 0x0480(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          DisableSecretRewards_IsSet;                        // 0x0490(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_491[0x7];                                      // 0x0491(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FS3AnalyticsRules                      AnalyticsRules;                                    // 0x0498(0x00A8)(NativeAccessSpecifierPublic)
	TMap<class FString, class FString>            AnalyticsRulesHVS;                                 // 0x0540(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FS3GameConfigsData) == 0x000008, "Wrong alignment on FS3GameConfigsData");
static_assert(sizeof(FS3GameConfigsData) == 0x000590, "Wrong size on FS3GameConfigsData");
static_assert(offsetof(FS3GameConfigsData, Analytics) == 0x000000, "Member 'FS3GameConfigsData::Analytics' has a wrong offset!");
static_assert(offsetof(FS3GameConfigsData, Archives) == 0x0000C8, "Member 'FS3GameConfigsData::Archives' has a wrong offset!");
static_assert(offsetof(FS3GameConfigsData, BalanceTool) == 0x0000D0, "Member 'FS3GameConfigsData::BalanceTool' has a wrong offset!");
static_assert(offsetof(FS3GameConfigsData, BalanceTool_IsSet) == 0x0000E0, "Member 'FS3GameConfigsData::BalanceTool_IsSet' has a wrong offset!");
static_assert(offsetof(FS3GameConfigsData, BeginnerTutorialLevel) == 0x0000E4, "Member 'FS3GameConfigsData::BeginnerTutorialLevel' has a wrong offset!");
static_assert(offsetof(FS3GameConfigsData, BotMatch) == 0x0000F0, "Member 'FS3GameConfigsData::BotMatch' has a wrong offset!");
static_assert(offsetof(FS3GameConfigsData, DedicatedServer) == 0x000110, "Member 'FS3GameConfigsData::DedicatedServer' has a wrong offset!");
static_assert(offsetof(FS3GameConfigsData, Dlc) == 0x000128, "Member 'FS3GameConfigsData::Dlc' has a wrong offset!");
static_assert(offsetof(FS3GameConfigsData, EnableNetAsyncLoading) == 0x000138, "Member 'FS3GameConfigsData::EnableNetAsyncLoading' has a wrong offset!");
static_assert(offsetof(FS3GameConfigsData, EnablePlayersConnectionStatus) == 0x000139, "Member 'FS3GameConfigsData::EnablePlayersConnectionStatus' has a wrong offset!");
static_assert(offsetof(FS3GameConfigsData, EnablePlayerIdInSurvey) == 0x00013A, "Member 'FS3GameConfigsData::EnablePlayerIdInSurvey' has a wrong offset!");
static_assert(offsetof(FS3GameConfigsData, EnableBotsInCustomMatch) == 0x00013B, "Member 'FS3GameConfigsData::EnableBotsInCustomMatch' has a wrong offset!");
static_assert(offsetof(FS3GameConfigsData, DisableNavigationDuringMatchmaking) == 0x00013C, "Member 'FS3GameConfigsData::DisableNavigationDuringMatchmaking' has a wrong offset!");
static_assert(offsetof(FS3GameConfigsData, RTMTimeoutThreshold) == 0x000140, "Member 'FS3GameConfigsData::RTMTimeoutThreshold' has a wrong offset!");
static_assert(offsetof(FS3GameConfigsData, GameLoadingTimeout) == 0x000144, "Member 'FS3GameConfigsData::GameLoadingTimeout' has a wrong offset!");
static_assert(offsetof(FS3GameConfigsData, EnableHapticVibration) == 0x000148, "Member 'FS3GameConfigsData::EnableHapticVibration' has a wrong offset!");
static_assert(offsetof(FS3GameConfigsData, EnableWinGDKAccountMismatchPopup) == 0x000149, "Member 'FS3GameConfigsData::EnableWinGDKAccountMismatchPopup' has a wrong offset!");
static_assert(offsetof(FS3GameConfigsData, EnableAntiMoveHack) == 0x00014A, "Member 'FS3GameConfigsData::EnableAntiMoveHack' has a wrong offset!");
static_assert(offsetof(FS3GameConfigsData, EnablePostIISCinematic) == 0x00014B, "Member 'FS3GameConfigsData::EnablePostIISCinematic' has a wrong offset!");
static_assert(offsetof(FS3GameConfigsData, EnablePlayStationTrophiesIISSync) == 0x00014C, "Member 'FS3GameConfigsData::EnablePlayStationTrophiesIISSync' has a wrong offset!");
static_assert(offsetof(FS3GameConfigsData, EnableDSQuestsUpdate) == 0x00014D, "Member 'FS3GameConfigsData::EnableDSQuestsUpdate' has a wrong offset!");
static_assert(offsetof(FS3GameConfigsData, CrossPromoManagerPlatforms) == 0x000150, "Member 'FS3GameConfigsData::CrossPromoManagerPlatforms' has a wrong offset!");
static_assert(offsetof(FS3GameConfigsData, CrossPromoManagerPlatforms_IsSet) == 0x0001A0, "Member 'FS3GameConfigsData::CrossPromoManagerPlatforms_IsSet' has a wrong offset!");
static_assert(offsetof(FS3GameConfigsData, FriendsList) == 0x0001A4, "Member 'FS3GameConfigsData::FriendsList' has a wrong offset!");
static_assert(offsetof(FS3GameConfigsData, HitValidation) == 0x0001B0, "Member 'FS3GameConfigsData::HitValidation' has a wrong offset!");
static_assert(offsetof(FS3GameConfigsData, AnimBudgeter) == 0x0001C8, "Member 'FS3GameConfigsData::AnimBudgeter' has a wrong offset!");
static_assert(offsetof(FS3GameConfigsData, AnimBudgeter_IsSet) == 0x0001F0, "Member 'FS3GameConfigsData::AnimBudgeter_IsSet' has a wrong offset!");
static_assert(offsetof(FS3GameConfigsData, Jwt) == 0x0001F1, "Member 'FS3GameConfigsData::Jwt' has a wrong offset!");
static_assert(offsetof(FS3GameConfigsData, Match) == 0x0001F4, "Member 'FS3GameConfigsData::Match' has a wrong offset!");
static_assert(offsetof(FS3GameConfigsData, HangTimes) == 0x000200, "Member 'FS3GameConfigsData::HangTimes' has a wrong offset!");
static_assert(offsetof(FS3GameConfigsData, Marketing) == 0x000210, "Member 'FS3GameConfigsData::Marketing' has a wrong offset!");
static_assert(offsetof(FS3GameConfigsData, EnableCrossPromoPopupDisplay) == 0x000228, "Member 'FS3GameConfigsData::EnableCrossPromoPopupDisplay' has a wrong offset!");
static_assert(offsetof(FS3GameConfigsData, EnableCrossPromoPopupDisplay_IsSet) == 0x000229, "Member 'FS3GameConfigsData::EnableCrossPromoPopupDisplay_IsSet' has a wrong offset!");
static_assert(offsetof(FS3GameConfigsData, MatchmakingCrossplayPlatforms) == 0x000230, "Member 'FS3GameConfigsData::MatchmakingCrossplayPlatforms' has a wrong offset!");
static_assert(offsetof(FS3GameConfigsData, MirrorsDefaultRetryPolicy) == 0x000280, "Member 'FS3GameConfigsData::MirrorsDefaultRetryPolicy' has a wrong offset!");
static_assert(offsetof(FS3GameConfigsData, Online) == 0x000290, "Member 'FS3GameConfigsData::Online' has a wrong offset!");
static_assert(offsetof(FS3GameConfigsData, Security) == 0x0002B0, "Member 'FS3GameConfigsData::Security' has a wrong offset!");
static_assert(offsetof(FS3GameConfigsData, KrakenSdkValidation) == 0x0002B8, "Member 'FS3GameConfigsData::KrakenSdkValidation' has a wrong offset!");
static_assert(offsetof(FS3GameConfigsData, ContentVersion) == 0x0002D8, "Member 'FS3GameConfigsData::ContentVersion' has a wrong offset!");
static_assert(offsetof(FS3GameConfigsData, DisconnectionBotReplacement) == 0x0002F0, "Member 'FS3GameConfigsData::DisconnectionBotReplacement' has a wrong offset!");
static_assert(offsetof(FS3GameConfigsData, Commentator) == 0x000330, "Member 'FS3GameConfigsData::Commentator' has a wrong offset!");
static_assert(offsetof(FS3GameConfigsData, SeenPopupsConfig) == 0x000338, "Member 'FS3GameConfigsData::SeenPopupsConfig' has a wrong offset!");
static_assert(offsetof(FS3GameConfigsData, SocialCrossfriendsPlatforms) == 0x000388, "Member 'FS3GameConfigsData::SocialCrossfriendsPlatforms' has a wrong offset!");
static_assert(offsetof(FS3GameConfigsData, SocialCrossprogressionPlatforms) == 0x0003D8, "Member 'FS3GameConfigsData::SocialCrossprogressionPlatforms' has a wrong offset!");
static_assert(offsetof(FS3GameConfigsData, EnableMoriPreviewButton) == 0x000428, "Member 'FS3GameConfigsData::EnableMoriPreviewButton' has a wrong offset!");
static_assert(offsetof(FS3GameConfigsData, EnableRealtimeMoriPreview) == 0x000429, "Member 'FS3GameConfigsData::EnableRealtimeMoriPreview' has a wrong offset!");
static_assert(offsetof(FS3GameConfigsData, EnableRealtimeMoriPreview_IsSet) == 0x00042A, "Member 'FS3GameConfigsData::EnableRealtimeMoriPreview_IsSet' has a wrong offset!");
static_assert(offsetof(FS3GameConfigsData, EnableAntiCamping) == 0x00042B, "Member 'FS3GameConfigsData::EnableAntiCamping' has a wrong offset!");
static_assert(offsetof(FS3GameConfigsData, EnableConsumableQueryFromKraken) == 0x00042C, "Member 'FS3GameConfigsData::EnableConsumableQueryFromKraken' has a wrong offset!");
static_assert(offsetof(FS3GameConfigsData, EnableLimitRegressionEvents) == 0x00042D, "Member 'FS3GameConfigsData::EnableLimitRegressionEvents' has a wrong offset!");
static_assert(offsetof(FS3GameConfigsData, EnableLobbyKickPlayerForCharacterOwnership) == 0x00042E, "Member 'FS3GameConfigsData::EnableLobbyKickPlayerForCharacterOwnership' has a wrong offset!");
static_assert(offsetof(FS3GameConfigsData, EnableFullProfileSaveAtLocation) == 0x000430, "Member 'FS3GameConfigsData::EnableFullProfileSaveAtLocation' has a wrong offset!");
static_assert(offsetof(FS3GameConfigsData, EnableLocalStartSnapping) == 0x000440, "Member 'FS3GameConfigsData::EnableLocalStartSnapping' has a wrong offset!");
static_assert(offsetof(FS3GameConfigsData, EnableUmgStore) == 0x000441, "Member 'FS3GameConfigsData::EnableUmgStore' has a wrong offset!");
static_assert(offsetof(FS3GameConfigsData, EnableContainerAgressiveMemorySaving) == 0x000442, "Member 'FS3GameConfigsData::EnableContainerAgressiveMemorySaving' has a wrong offset!");
static_assert(offsetof(FS3GameConfigsData, EnableFirstMoveAfterForcedUpdates) == 0x000443, "Member 'FS3GameConfigsData::EnableFirstMoveAfterForcedUpdates' has a wrong offset!");
static_assert(offsetof(FS3GameConfigsData, DSProviderOnShutdownNotificationDelay) == 0x000444, "Member 'FS3GameConfigsData::DSProviderOnShutdownNotificationDelay' has a wrong offset!");
static_assert(offsetof(FS3GameConfigsData, EnableAlwaysSendCrashWithUI) == 0x000448, "Member 'FS3GameConfigsData::EnableAlwaysSendCrashWithUI' has a wrong offset!");
static_assert(offsetof(FS3GameConfigsData, DynamicContent) == 0x000450, "Member 'FS3GameConfigsData::DynamicContent' has a wrong offset!");
static_assert(offsetof(FS3GameConfigsData, DynamicContent_IsSet) == 0x000468, "Member 'FS3GameConfigsData::DynamicContent_IsSet' has a wrong offset!");
static_assert(offsetof(FS3GameConfigsData, EnableSimulateMovementOptimization) == 0x000470, "Member 'FS3GameConfigsData::EnableSimulateMovementOptimization' has a wrong offset!");
static_assert(offsetof(FS3GameConfigsData, DisableSecretRewards) == 0x000480, "Member 'FS3GameConfigsData::DisableSecretRewards' has a wrong offset!");
static_assert(offsetof(FS3GameConfigsData, DisableSecretRewards_IsSet) == 0x000490, "Member 'FS3GameConfigsData::DisableSecretRewards_IsSet' has a wrong offset!");
static_assert(offsetof(FS3GameConfigsData, AnalyticsRules) == 0x000498, "Member 'FS3GameConfigsData::AnalyticsRules' has a wrong offset!");
static_assert(offsetof(FS3GameConfigsData, AnalyticsRulesHVS) == 0x000540, "Member 'FS3GameConfigsData::AnalyticsRulesHVS' has a wrong offset!");

// ScriptStruct DeadByDaylight.S3GameConfigsDSData
// 0x0100 (0x0100 - 0x0000)
struct FS3GameConfigsDSData final
{
public:
	struct FDDosGameConfigDS                      Ddos;                                              // 0x0000(0x0002)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, float>                            MapHistoryWeights;                                 // 0x0008(0x0050)(NativeAccessSpecifierPublic)
	struct FS3AnalyticsRules                      AnalyticsRulesDedicatedServer;                     // 0x0058(0x00A8)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FS3GameConfigsDSData) == 0x000008, "Wrong alignment on FS3GameConfigsDSData");
static_assert(sizeof(FS3GameConfigsDSData) == 0x000100, "Wrong size on FS3GameConfigsDSData");
static_assert(offsetof(FS3GameConfigsDSData, Ddos) == 0x000000, "Member 'FS3GameConfigsDSData::Ddos' has a wrong offset!");
static_assert(offsetof(FS3GameConfigsDSData, MapHistoryWeights) == 0x000008, "Member 'FS3GameConfigsDSData::MapHistoryWeights' has a wrong offset!");
static_assert(offsetof(FS3GameConfigsDSData, AnalyticsRulesDedicatedServer) == 0x000058, "Member 'FS3GameConfigsDSData::AnalyticsRulesDedicatedServer' has a wrong offset!");

// ScriptStruct DeadByDaylight.S3PrestigeData
// 0x0070 (0x0070 - 0x0000)
struct FS3PrestigeData final
{
public:
	struct FS3PrestigeConfig                      Config;                                            // 0x0000(0x0020)(NativeAccessSpecifierPublic)
	TMap<class FString, struct FS3PrestigeCharacterRewards> RewardsByCharacters;                               // 0x0020(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FS3PrestigeData) == 0x000008, "Wrong alignment on FS3PrestigeData");
static_assert(sizeof(FS3PrestigeData) == 0x000070, "Wrong size on FS3PrestigeData");
static_assert(offsetof(FS3PrestigeData, Config) == 0x000000, "Member 'FS3PrestigeData::Config' has a wrong offset!");
static_assert(offsetof(FS3PrestigeData, RewardsByCharacters) == 0x000020, "Member 'FS3PrestigeData::RewardsByCharacters' has a wrong offset!");

// ScriptStruct DeadByDaylight.S3RemoteContentManifestEntry
// 0x0058 (0x0058 - 0x0000)
struct FS3RemoteContentManifestEntry final
{
public:
	class FString                                 Schema;                                            // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Uri;                                               // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ContentVersion;                                    // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PackagedPath;                                      // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnableChecksum;                                    // 0x0040(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DownloadStrategy;                                  // 0x0048(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FS3RemoteContentManifestEntry) == 0x000008, "Wrong alignment on FS3RemoteContentManifestEntry");
static_assert(sizeof(FS3RemoteContentManifestEntry) == 0x000058, "Wrong size on FS3RemoteContentManifestEntry");
static_assert(offsetof(FS3RemoteContentManifestEntry, Schema) == 0x000000, "Member 'FS3RemoteContentManifestEntry::Schema' has a wrong offset!");
static_assert(offsetof(FS3RemoteContentManifestEntry, Uri) == 0x000010, "Member 'FS3RemoteContentManifestEntry::Uri' has a wrong offset!");
static_assert(offsetof(FS3RemoteContentManifestEntry, ContentVersion) == 0x000020, "Member 'FS3RemoteContentManifestEntry::ContentVersion' has a wrong offset!");
static_assert(offsetof(FS3RemoteContentManifestEntry, PackagedPath) == 0x000030, "Member 'FS3RemoteContentManifestEntry::PackagedPath' has a wrong offset!");
static_assert(offsetof(FS3RemoteContentManifestEntry, EnableChecksum) == 0x000040, "Member 'FS3RemoteContentManifestEntry::EnableChecksum' has a wrong offset!");
static_assert(offsetof(FS3RemoteContentManifestEntry, DownloadStrategy) == 0x000048, "Member 'FS3RemoteContentManifestEntry::DownloadStrategy' has a wrong offset!");

// ScriptStruct DeadByDaylight.S3RemoteContentManifest
// 0x0010 (0x0010 - 0x0000)
struct FS3RemoteContentManifest final
{
public:
	TArray<struct FS3RemoteContentManifestEntry>  Entries;                                           // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FS3RemoteContentManifest) == 0x000008, "Wrong alignment on FS3RemoteContentManifest");
static_assert(sizeof(FS3RemoteContentManifest) == 0x000010, "Wrong size on FS3RemoteContentManifest");
static_assert(offsetof(FS3RemoteContentManifest, Entries) == 0x000000, "Member 'FS3RemoteContentManifest::Entries' has a wrong offset!");

// ScriptStruct DeadByDaylight.RoleGenderViewSetting
// 0x0038 (0x0038 - 0x0000)
struct FRoleGenderViewSetting final
{
public:
	class FName                                   Label;                                             // 0x0000(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRoleDropdown                          RoleDropdown;                                      // 0x000C(0x0002)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	EGender                                       Gender;                                            // 0x000E(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F[0x1];                                        // 0x000F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FScreenshotViewSetting                 Settings;                                          // 0x0010(0x0028)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRoleGenderViewSetting) == 0x000004, "Wrong alignment on FRoleGenderViewSetting");
static_assert(sizeof(FRoleGenderViewSetting) == 0x000038, "Wrong size on FRoleGenderViewSetting");
static_assert(offsetof(FRoleGenderViewSetting, Label) == 0x000000, "Member 'FRoleGenderViewSetting::Label' has a wrong offset!");
static_assert(offsetof(FRoleGenderViewSetting, RoleDropdown) == 0x00000C, "Member 'FRoleGenderViewSetting::RoleDropdown' has a wrong offset!");
static_assert(offsetof(FRoleGenderViewSetting, Gender) == 0x00000E, "Member 'FRoleGenderViewSetting::Gender' has a wrong offset!");
static_assert(offsetof(FRoleGenderViewSetting, Settings) == 0x000010, "Member 'FRoleGenderViewSetting::Settings' has a wrong offset!");

// ScriptStruct DeadByDaylight.GenderViewSetting
// 0x0044 (0x0044 - 0x0000)
struct FGenderViewSetting final
{
public:
	class FName                                   Label;                                             // 0x0000(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRoleItemCategoryDropdown              RoleItemCategory;                                  // 0x000C(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	EGender                                       Gender;                                            // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FScreenshotViewSetting                 Settings;                                          // 0x001C(0x0028)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGenderViewSetting) == 0x000004, "Wrong alignment on FGenderViewSetting");
static_assert(sizeof(FGenderViewSetting) == 0x000044, "Wrong size on FGenderViewSetting");
static_assert(offsetof(FGenderViewSetting, Label) == 0x000000, "Member 'FGenderViewSetting::Label' has a wrong offset!");
static_assert(offsetof(FGenderViewSetting, RoleItemCategory) == 0x00000C, "Member 'FGenderViewSetting::RoleItemCategory' has a wrong offset!");
static_assert(offsetof(FGenderViewSetting, Gender) == 0x000018, "Member 'FGenderViewSetting::Gender' has a wrong offset!");
static_assert(offsetof(FGenderViewSetting, Settings) == 0x00001C, "Member 'FGenderViewSetting::Settings' has a wrong offset!");

// ScriptStruct DeadByDaylight.CharacterViewSetting
// 0x003C (0x003C - 0x0000)
struct FCharacterViewSetting final
{
public:
	class FName                                   Label;                                             // 0x0000(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCharacterDropdown                     CharacterDropdown;                                 // 0x000C(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FScreenshotViewSetting                 Settings;                                          // 0x0014(0x0028)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterViewSetting) == 0x000004, "Wrong alignment on FCharacterViewSetting");
static_assert(sizeof(FCharacterViewSetting) == 0x00003C, "Wrong size on FCharacterViewSetting");
static_assert(offsetof(FCharacterViewSetting, Label) == 0x000000, "Member 'FCharacterViewSetting::Label' has a wrong offset!");
static_assert(offsetof(FCharacterViewSetting, CharacterDropdown) == 0x00000C, "Member 'FCharacterViewSetting::CharacterDropdown' has a wrong offset!");
static_assert(offsetof(FCharacterViewSetting, Settings) == 0x000014, "Member 'FCharacterViewSetting::Settings' has a wrong offset!");

// ScriptStruct DeadByDaylight.CharmCategorySetting
// 0x0038 (0x0038 - 0x0000)
struct FCharmCategorySetting final
{
public:
	class FName                                   Label;                                             // 0x0000(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECharmCategory                                CharmCategory;                                     // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FScreenshotViewSetting                 Settings;                                          // 0x0010(0x0028)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharmCategorySetting) == 0x000004, "Wrong alignment on FCharmCategorySetting");
static_assert(sizeof(FCharmCategorySetting) == 0x000038, "Wrong size on FCharmCategorySetting");
static_assert(offsetof(FCharmCategorySetting, Label) == 0x000000, "Member 'FCharmCategorySetting::Label' has a wrong offset!");
static_assert(offsetof(FCharmCategorySetting, CharmCategory) == 0x00000C, "Member 'FCharmCategorySetting::CharmCategory' has a wrong offset!");
static_assert(offsetof(FCharmCategorySetting, Settings) == 0x000010, "Member 'FCharmCategorySetting::Settings' has a wrong offset!");

// ScriptStruct DeadByDaylight.CharmViewSetting
// 0x0044 (0x0044 - 0x0000)
struct FCharmViewSetting final
{
public:
	class FName                                   Label;                                             // 0x0000(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCharmDropdown                         CharmId;                                           // 0x000C(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FScreenshotViewSetting                 Settings;                                          // 0x001C(0x0028)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharmViewSetting) == 0x000004, "Wrong alignment on FCharmViewSetting");
static_assert(sizeof(FCharmViewSetting) == 0x000044, "Wrong size on FCharmViewSetting");
static_assert(offsetof(FCharmViewSetting, Label) == 0x000000, "Member 'FCharmViewSetting::Label' has a wrong offset!");
static_assert(offsetof(FCharmViewSetting, CharmId) == 0x00000C, "Member 'FCharmViewSetting::CharmId' has a wrong offset!");
static_assert(offsetof(FCharmViewSetting, Settings) == 0x00001C, "Member 'FCharmViewSetting::Settings' has a wrong offset!");

// ScriptStruct DeadByDaylight.CharacterItemCategoryViewSetting
// 0x0040 (0x0040 - 0x0000)
struct FCharacterItemCategoryViewSetting final
{
public:
	class FName                                   Label;                                             // 0x0000(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRoleItemCategoryDropdown              CharacterDropdown;                                 // 0x000C(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FScreenshotViewSetting                 Settings;                                          // 0x0018(0x0028)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterItemCategoryViewSetting) == 0x000004, "Wrong alignment on FCharacterItemCategoryViewSetting");
static_assert(sizeof(FCharacterItemCategoryViewSetting) == 0x000040, "Wrong size on FCharacterItemCategoryViewSetting");
static_assert(offsetof(FCharacterItemCategoryViewSetting, Label) == 0x000000, "Member 'FCharacterItemCategoryViewSetting::Label' has a wrong offset!");
static_assert(offsetof(FCharacterItemCategoryViewSetting, CharacterDropdown) == 0x00000C, "Member 'FCharacterItemCategoryViewSetting::CharacterDropdown' has a wrong offset!");
static_assert(offsetof(FCharacterItemCategoryViewSetting, Settings) == 0x000018, "Member 'FCharacterItemCategoryViewSetting::Settings' has a wrong offset!");

// ScriptStruct DeadByDaylight.ItemViewSetting
// 0x0044 (0x0044 - 0x0000)
struct FItemViewSetting final
{
public:
	class FName                                   Label;                                             // 0x0000(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCustomizationItemDropdown             Item;                                              // 0x000C(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FScreenshotViewSetting                 Settings;                                          // 0x001C(0x0028)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FItemViewSetting) == 0x000004, "Wrong alignment on FItemViewSetting");
static_assert(sizeof(FItemViewSetting) == 0x000044, "Wrong size on FItemViewSetting");
static_assert(offsetof(FItemViewSetting, Label) == 0x000000, "Member 'FItemViewSetting::Label' has a wrong offset!");
static_assert(offsetof(FItemViewSetting, Item) == 0x00000C, "Member 'FItemViewSetting::Item' has a wrong offset!");
static_assert(offsetof(FItemViewSetting, Settings) == 0x00001C, "Member 'FItemViewSetting::Settings' has a wrong offset!");

// ScriptStruct DeadByDaylight.CharacterAnimation
// 0x0058 (0x0058 - 0x0000)
struct FCharacterAnimation final
{
public:
	class FName                                   Label;                                             // 0x0000(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCharacterAnimationDropdown            Data;                                              // 0x0010(0x0038)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FCharacterAnimationAssetOutfitOverride> OutfitOverrides;                                   // 0x0048(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterAnimation) == 0x000008, "Wrong alignment on FCharacterAnimation");
static_assert(sizeof(FCharacterAnimation) == 0x000058, "Wrong size on FCharacterAnimation");
static_assert(offsetof(FCharacterAnimation, Label) == 0x000000, "Member 'FCharacterAnimation::Label' has a wrong offset!");
static_assert(offsetof(FCharacterAnimation, Data) == 0x000010, "Member 'FCharacterAnimation::Data' has a wrong offset!");
static_assert(offsetof(FCharacterAnimation, OutfitOverrides) == 0x000048, "Member 'FCharacterAnimation::OutfitOverrides' has a wrong offset!");

// ScriptStruct DeadByDaylight.CharacterRoleAnimation
// 0x0048 (0x0048 - 0x0000)
struct FCharacterRoleAnimation final
{
public:
	class FName                                   Label;                                             // 0x0000(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCharacterAnimationDropdown            Data;                                              // 0x0010(0x0038)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterRoleAnimation) == 0x000008, "Wrong alignment on FCharacterRoleAnimation");
static_assert(sizeof(FCharacterRoleAnimation) == 0x000048, "Wrong size on FCharacterRoleAnimation");
static_assert(offsetof(FCharacterRoleAnimation, Label) == 0x000000, "Member 'FCharacterRoleAnimation::Label' has a wrong offset!");
static_assert(offsetof(FCharacterRoleAnimation, Data) == 0x000010, "Member 'FCharacterRoleAnimation::Data' has a wrong offset!");

// ScriptStruct DeadByDaylight.OutfitAnimation
// 0x0050 (0x0050 - 0x0000)
struct FOutfitAnimation final
{
public:
	class FName                                   Label;                                             // 0x0000(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCharacterAnimationAssetOutfitOverride Data;                                              // 0x0010(0x0040)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOutfitAnimation) == 0x000008, "Wrong alignment on FOutfitAnimation");
static_assert(sizeof(FOutfitAnimation) == 0x000050, "Wrong size on FOutfitAnimation");
static_assert(offsetof(FOutfitAnimation, Label) == 0x000000, "Member 'FOutfitAnimation::Label' has a wrong offset!");
static_assert(offsetof(FOutfitAnimation, Data) == 0x000010, "Member 'FOutfitAnimation::Data' has a wrong offset!");

// ScriptStruct DeadByDaylight.ScreenshotToolViewOverridesData
// 0x0038 (0x0040 - 0x0008)
struct FScreenshotToolViewOverridesData final : public FTableRowBase
{
public:
	struct FScreenshotViewSetting                 Settings;                                          // 0x0008(0x0028)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FScreenshotToolTargetWithLabel> Targets;                                           // 0x0030(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FScreenshotToolViewOverridesData) == 0x000008, "Wrong alignment on FScreenshotToolViewOverridesData");
static_assert(sizeof(FScreenshotToolViewOverridesData) == 0x000040, "Wrong size on FScreenshotToolViewOverridesData");
static_assert(offsetof(FScreenshotToolViewOverridesData, Settings) == 0x000008, "Member 'FScreenshotToolViewOverridesData::Settings' has a wrong offset!");
static_assert(offsetof(FScreenshotToolViewOverridesData, Targets) == 0x000030, "Member 'FScreenshotToolViewOverridesData::Targets' has a wrong offset!");

// ScriptStruct DeadByDaylight.ScreenshotToolPathInfo
// 0x0018 (0x0018 - 0x0000)
struct FScreenshotToolPathInfo final
{
public:
	bool                                          IncludeDLCFolder;                                  // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IncludeCharacterFolder;                            // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Path;                                              // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FScreenshotToolPathInfo) == 0x000008, "Wrong alignment on FScreenshotToolPathInfo");
static_assert(sizeof(FScreenshotToolPathInfo) == 0x000018, "Wrong size on FScreenshotToolPathInfo");
static_assert(offsetof(FScreenshotToolPathInfo, IncludeDLCFolder) == 0x000000, "Member 'FScreenshotToolPathInfo::IncludeDLCFolder' has a wrong offset!");
static_assert(offsetof(FScreenshotToolPathInfo, IncludeCharacterFolder) == 0x000001, "Member 'FScreenshotToolPathInfo::IncludeCharacterFolder' has a wrong offset!");
static_assert(offsetof(FScreenshotToolPathInfo, Path) == 0x000008, "Member 'FScreenshotToolPathInfo::Path' has a wrong offset!");

// ScriptStruct DeadByDaylight.ScreenshotPreviewAction
// 0x0098 (0x0098 - 0x0000)
struct FScreenshotPreviewAction final
{
public:
	TMap<ECharacterToolItemType, struct FIntPoint> FrameSizes;                                        // 0x0000(0x0050)(Edit, EditFixedSize, NativeAccessSpecifierPublic)
	uint16                                        RenderResolution;                                  // 0x0050(0x0002)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_52[0x6];                                       // 0x0052(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UTextureRenderTarget2D>  RenderTarget;                                      // 0x0058(0x0038)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UScreenshotPreviewWidget>   EditorWidgetClass;                                 // 0x0090(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FScreenshotPreviewAction) == 0x000008, "Wrong alignment on FScreenshotPreviewAction");
static_assert(sizeof(FScreenshotPreviewAction) == 0x000098, "Wrong size on FScreenshotPreviewAction");
static_assert(offsetof(FScreenshotPreviewAction, FrameSizes) == 0x000000, "Member 'FScreenshotPreviewAction::FrameSizes' has a wrong offset!");
static_assert(offsetof(FScreenshotPreviewAction, RenderResolution) == 0x000050, "Member 'FScreenshotPreviewAction::RenderResolution' has a wrong offset!");
static_assert(offsetof(FScreenshotPreviewAction, RenderTarget) == 0x000058, "Member 'FScreenshotPreviewAction::RenderTarget' has a wrong offset!");
static_assert(offsetof(FScreenshotPreviewAction, EditorWidgetClass) == 0x000090, "Member 'FScreenshotPreviewAction::EditorWidgetClass' has a wrong offset!");

// ScriptStruct DeadByDaylight.ScreenshotToolCustomizationInfo
// 0x0014 (0x0014 - 0x0000)
struct FScreenshotToolCustomizationInfo final
{
public:
	int32                                         CharacterId;                                       // 0x0000(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ID;                                                // 0x0004(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECustomizationCategory                        Category;                                          // 0x0010(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FScreenshotToolCustomizationInfo) == 0x000004, "Wrong alignment on FScreenshotToolCustomizationInfo");
static_assert(sizeof(FScreenshotToolCustomizationInfo) == 0x000014, "Wrong size on FScreenshotToolCustomizationInfo");
static_assert(offsetof(FScreenshotToolCustomizationInfo, CharacterId) == 0x000000, "Member 'FScreenshotToolCustomizationInfo::CharacterId' has a wrong offset!");
static_assert(offsetof(FScreenshotToolCustomizationInfo, ID) == 0x000004, "Member 'FScreenshotToolCustomizationInfo::ID' has a wrong offset!");
static_assert(offsetof(FScreenshotToolCustomizationInfo, Category) == 0x000010, "Member 'FScreenshotToolCustomizationInfo::Category' has a wrong offset!");

// ScriptStruct DeadByDaylight.ScreenshotToolOverrideInfo
// 0x001C (0x001C - 0x0000)
struct FScreenshotToolOverrideInfo final
{
public:
	int16                                         PriorityHit;                                       // 0x0000(0x0002)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   RowName;                                           // 0x0004(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TargetLabel;                                       // 0x0010(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FScreenshotToolOverrideInfo) == 0x000004, "Wrong alignment on FScreenshotToolOverrideInfo");
static_assert(sizeof(FScreenshotToolOverrideInfo) == 0x00001C, "Wrong size on FScreenshotToolOverrideInfo");
static_assert(offsetof(FScreenshotToolOverrideInfo, PriorityHit) == 0x000000, "Member 'FScreenshotToolOverrideInfo::PriorityHit' has a wrong offset!");
static_assert(offsetof(FScreenshotToolOverrideInfo, RowName) == 0x000004, "Member 'FScreenshotToolOverrideInfo::RowName' has a wrong offset!");
static_assert(offsetof(FScreenshotToolOverrideInfo, TargetLabel) == 0x000010, "Member 'FScreenshotToolOverrideInfo::TargetLabel' has a wrong offset!");

// ScriptStruct DeadByDaylight.ScreenshotVFXCharmHookCharm
// 0x00D8 (0x00D8 - 0x0000)
struct FScreenshotVFXCharmHookCharm final
{
public:
	struct FCharmDropdown                         Charm;                                             // 0x0000(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FScreenshotVFXCharmHookCharmData       Data;                                              // 0x0010(0x00C8)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FScreenshotVFXCharmHookCharm) == 0x000008, "Wrong alignment on FScreenshotVFXCharmHookCharm");
static_assert(sizeof(FScreenshotVFXCharmHookCharm) == 0x0000D8, "Wrong size on FScreenshotVFXCharmHookCharm");
static_assert(offsetof(FScreenshotVFXCharmHookCharm, Charm) == 0x000000, "Member 'FScreenshotVFXCharmHookCharm::Charm' has a wrong offset!");
static_assert(offsetof(FScreenshotVFXCharmHookCharm, Data) == 0x000010, "Member 'FScreenshotVFXCharmHookCharm::Data' has a wrong offset!");

// ScriptStruct DeadByDaylight.RoleGenderCharacterRotation
// 0x0014 (0x0014 - 0x0000)
struct FRoleGenderCharacterRotation final
{
public:
	class FName                                   Label;                                             // 0x0000(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRoleDropdown                          Role;                                              // 0x000C(0x0002)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_E[0x2];                                        // 0x000E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Rotation;                                          // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRoleGenderCharacterRotation) == 0x000004, "Wrong alignment on FRoleGenderCharacterRotation");
static_assert(sizeof(FRoleGenderCharacterRotation) == 0x000014, "Wrong size on FRoleGenderCharacterRotation");
static_assert(offsetof(FRoleGenderCharacterRotation, Label) == 0x000000, "Member 'FRoleGenderCharacterRotation::Label' has a wrong offset!");
static_assert(offsetof(FRoleGenderCharacterRotation, Role) == 0x00000C, "Member 'FRoleGenderCharacterRotation::Role' has a wrong offset!");
static_assert(offsetof(FRoleGenderCharacterRotation, Rotation) == 0x000010, "Member 'FRoleGenderCharacterRotation::Rotation' has a wrong offset!");

// ScriptStruct DeadByDaylight.SeenStoreItemsSaved
// 0x0020 (0x0030 - 0x0010)
struct FSeenStoreItemsSaved final : public FSaveDataBase
{
public:
	class FString                                 NewStoreItemsStartDate;                            // 0x0010(0x0010)(ZeroConstructor, SaveGame, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         SeenNewStoreItems;                                 // 0x0020(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSeenStoreItemsSaved) == 0x000008, "Wrong alignment on FSeenStoreItemsSaved");
static_assert(sizeof(FSeenStoreItemsSaved) == 0x000030, "Wrong size on FSeenStoreItemsSaved");
static_assert(offsetof(FSeenStoreItemsSaved, NewStoreItemsStartDate) == 0x000010, "Member 'FSeenStoreItemsSaved::NewStoreItemsStartDate' has a wrong offset!");
static_assert(offsetof(FSeenStoreItemsSaved, SeenNewStoreItems) == 0x000020, "Member 'FSeenStoreItemsSaved::SeenNewStoreItems' has a wrong offset!");

// ScriptStruct DeadByDaylight.ShopTransactionItemProducts
// 0x0010 (0x0010 - 0x0000)
struct FShopTransactionItemProducts final
{
public:
	TArray<struct FShopTransactionItem>           Items;                                             // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FShopTransactionItemProducts) == 0x000008, "Wrong alignment on FShopTransactionItemProducts");
static_assert(sizeof(FShopTransactionItemProducts) == 0x000010, "Wrong size on FShopTransactionItemProducts");
static_assert(offsetof(FShopTransactionItemProducts, Items) == 0x000000, "Member 'FShopTransactionItemProducts::Items' has a wrong offset!");

// ScriptStruct DeadByDaylight.ShopTransactionItemCustomData
// 0x0030 (0x0030 - 0x0000)
struct FShopTransactionItemCustomData final
{
public:
	struct FShopTransactionItemProducts           ProductsReceived;                                  // 0x0000(0x0010)(NativeAccessSpecifierPublic)
	class FString                                 TransactionName;                                   // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TransactionType;                                   // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FShopTransactionItemCustomData) == 0x000008, "Wrong alignment on FShopTransactionItemCustomData");
static_assert(sizeof(FShopTransactionItemCustomData) == 0x000030, "Wrong size on FShopTransactionItemCustomData");
static_assert(offsetof(FShopTransactionItemCustomData, ProductsReceived) == 0x000000, "Member 'FShopTransactionItemCustomData::ProductsReceived' has a wrong offset!");
static_assert(offsetof(FShopTransactionItemCustomData, TransactionName) == 0x000010, "Member 'FShopTransactionItemCustomData::TransactionName' has a wrong offset!");
static_assert(offsetof(FShopTransactionItemCustomData, TransactionType) == 0x000020, "Member 'FShopTransactionItemCustomData::TransactionType' has a wrong offset!");

// ScriptStruct DeadByDaylight.ShopTransactionCurrencyCustomData
// 0x0030 (0x0030 - 0x0000)
struct FShopTransactionCurrencyCustomData final
{
public:
	struct FShopTransactionCurrencyProducts       ProductsReceived;                                  // 0x0000(0x0010)(NativeAccessSpecifierPublic)
	class FString                                 TransactionName;                                   // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TransactionType;                                   // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FShopTransactionCurrencyCustomData) == 0x000008, "Wrong alignment on FShopTransactionCurrencyCustomData");
static_assert(sizeof(FShopTransactionCurrencyCustomData) == 0x000030, "Wrong size on FShopTransactionCurrencyCustomData");
static_assert(offsetof(FShopTransactionCurrencyCustomData, ProductsReceived) == 0x000000, "Member 'FShopTransactionCurrencyCustomData::ProductsReceived' has a wrong offset!");
static_assert(offsetof(FShopTransactionCurrencyCustomData, TransactionName) == 0x000010, "Member 'FShopTransactionCurrencyCustomData::TransactionName' has a wrong offset!");
static_assert(offsetof(FShopTransactionCurrencyCustomData, TransactionType) == 0x000020, "Member 'FShopTransactionCurrencyCustomData::TransactionType' has a wrong offset!");

// ScriptStruct DeadByDaylight.ShopTransactionCustomData
// 0x0040 (0x0040 - 0x0000)
struct FShopTransactionCustomData final
{
public:
	struct FShopTransactionProducts               ProductsReceived;                                  // 0x0000(0x0020)(NativeAccessSpecifierPublic)
	class FString                                 TransactionName;                                   // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TransactionType;                                   // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FShopTransactionCustomData) == 0x000008, "Wrong alignment on FShopTransactionCustomData");
static_assert(sizeof(FShopTransactionCustomData) == 0x000040, "Wrong size on FShopTransactionCustomData");
static_assert(offsetof(FShopTransactionCustomData, ProductsReceived) == 0x000000, "Member 'FShopTransactionCustomData::ProductsReceived' has a wrong offset!");
static_assert(offsetof(FShopTransactionCustomData, TransactionName) == 0x000020, "Member 'FShopTransactionCustomData::TransactionName' has a wrong offset!");
static_assert(offsetof(FShopTransactionCustomData, TransactionType) == 0x000030, "Member 'FShopTransactionCustomData::TransactionType' has a wrong offset!");

// ScriptStruct DeadByDaylight.ShopWalletUpdate
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FShopWalletUpdate final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FShopWalletUpdate) == 0x000008, "Wrong alignment on FShopWalletUpdate");
static_assert(sizeof(FShopWalletUpdate) == 0x000018, "Wrong size on FShopWalletUpdate");

// ScriptStruct DeadByDaylight.SkillInitializationData
// 0x0001 (0x0001 - 0x0000)
struct FSkillInitializationData final
{
public:
	bool                                          AuthorityDataSet;                                  // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSkillInitializationData) == 0x000001, "Wrong alignment on FSkillInitializationData");
static_assert(sizeof(FSkillInitializationData) == 0x000001, "Wrong size on FSkillInitializationData");
static_assert(offsetof(FSkillInitializationData, AuthorityDataSet) == 0x000000, "Member 'FSkillInitializationData::AuthorityDataSet' has a wrong offset!");

// ScriptStruct DeadByDaylight.GiftSpecialActionData
// 0x0040 (0x0048 - 0x0008)
struct FGiftSpecialActionData final : public FDBDTableRowBase
{
public:
	EGiftSpecialAction                            ActionType;                                        // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UMediaSource>            VideoSource;                                       // 0x0010(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGiftSpecialActionData) == 0x000008, "Wrong alignment on FGiftSpecialActionData");
static_assert(sizeof(FGiftSpecialActionData) == 0x000048, "Wrong size on FGiftSpecialActionData");
static_assert(offsetof(FGiftSpecialActionData, ActionType) == 0x000008, "Member 'FGiftSpecialActionData::ActionType' has a wrong offset!");
static_assert(offsetof(FGiftSpecialActionData, VideoSource) == 0x000010, "Member 'FGiftSpecialActionData::VideoSource' has a wrong offset!");

// ScriptStruct DeadByDaylight.SpecialBehaviourPopulation
// 0x00A8 (0x00B0 - 0x0008)
struct FSpecialBehaviourPopulation final : public FDBDTableRowBase
{
public:
	class FName                                   _name;                                             // 0x0008(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EGameplayElementType>                  _spawnerTypes;                                     // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<ETileSpawnPointType>                   _spawnPointTypes;                                  // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPrivate)
	TSoftClassPtr<class UClass>                   _actor;                                            // 0x0038(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         _tileSpawnPointPriority;                           // 0x0070(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   IterativeWeightAdjustmentStrategyClass;            // 0x0078(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FSpecialBehaviourPopulation) == 0x000008, "Wrong alignment on FSpecialBehaviourPopulation");
static_assert(sizeof(FSpecialBehaviourPopulation) == 0x0000B0, "Wrong size on FSpecialBehaviourPopulation");
static_assert(offsetof(FSpecialBehaviourPopulation, _name) == 0x000008, "Member 'FSpecialBehaviourPopulation::_name' has a wrong offset!");
static_assert(offsetof(FSpecialBehaviourPopulation, _spawnerTypes) == 0x000018, "Member 'FSpecialBehaviourPopulation::_spawnerTypes' has a wrong offset!");
static_assert(offsetof(FSpecialBehaviourPopulation, _spawnPointTypes) == 0x000028, "Member 'FSpecialBehaviourPopulation::_spawnPointTypes' has a wrong offset!");
static_assert(offsetof(FSpecialBehaviourPopulation, _actor) == 0x000038, "Member 'FSpecialBehaviourPopulation::_actor' has a wrong offset!");
static_assert(offsetof(FSpecialBehaviourPopulation, _tileSpawnPointPriority) == 0x000070, "Member 'FSpecialBehaviourPopulation::_tileSpawnPointPriority' has a wrong offset!");
static_assert(offsetof(FSpecialBehaviourPopulation, IterativeWeightAdjustmentStrategyClass) == 0x000078, "Member 'FSpecialBehaviourPopulation::IterativeWeightAdjustmentStrategyClass' has a wrong offset!");

// ScriptStruct DeadByDaylight.SpecialEventObjectiveData
// 0x00E0 (0x00E0 - 0x0000)
struct FSpecialEventObjectiveData final
{
public:
	class FName                                   ObjectiveId;                                       // 0x0000(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Title;                                             // 0x0010(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0028(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FString                                 IconPath;                                          // 0x0040(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ObjectiveFrameLabel;                               // 0x0050(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   CompletedTitle;                                    // 0x0060(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   CompletedDescription;                              // 0x0078(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FName                                   RewardId;                                          // 0x0090(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 LockedRewardGenericIconPath;                       // 0x00A0(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 UnlockedRewardGenericIconPath;                     // 0x00B0(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerRole                                   PlayerRole;                                        // 0x00C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C1[0x7];                                       // 0x00C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 StatName;                                          // 0x00C8(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        Sections;                                          // 0x00D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        MaxValue;                                          // 0x00DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpecialEventObjectiveData) == 0x000008, "Wrong alignment on FSpecialEventObjectiveData");
static_assert(sizeof(FSpecialEventObjectiveData) == 0x0000E0, "Wrong size on FSpecialEventObjectiveData");
static_assert(offsetof(FSpecialEventObjectiveData, ObjectiveId) == 0x000000, "Member 'FSpecialEventObjectiveData::ObjectiveId' has a wrong offset!");
static_assert(offsetof(FSpecialEventObjectiveData, Title) == 0x000010, "Member 'FSpecialEventObjectiveData::Title' has a wrong offset!");
static_assert(offsetof(FSpecialEventObjectiveData, Description) == 0x000028, "Member 'FSpecialEventObjectiveData::Description' has a wrong offset!");
static_assert(offsetof(FSpecialEventObjectiveData, IconPath) == 0x000040, "Member 'FSpecialEventObjectiveData::IconPath' has a wrong offset!");
static_assert(offsetof(FSpecialEventObjectiveData, ObjectiveFrameLabel) == 0x000050, "Member 'FSpecialEventObjectiveData::ObjectiveFrameLabel' has a wrong offset!");
static_assert(offsetof(FSpecialEventObjectiveData, CompletedTitle) == 0x000060, "Member 'FSpecialEventObjectiveData::CompletedTitle' has a wrong offset!");
static_assert(offsetof(FSpecialEventObjectiveData, CompletedDescription) == 0x000078, "Member 'FSpecialEventObjectiveData::CompletedDescription' has a wrong offset!");
static_assert(offsetof(FSpecialEventObjectiveData, RewardId) == 0x000090, "Member 'FSpecialEventObjectiveData::RewardId' has a wrong offset!");
static_assert(offsetof(FSpecialEventObjectiveData, LockedRewardGenericIconPath) == 0x0000A0, "Member 'FSpecialEventObjectiveData::LockedRewardGenericIconPath' has a wrong offset!");
static_assert(offsetof(FSpecialEventObjectiveData, UnlockedRewardGenericIconPath) == 0x0000B0, "Member 'FSpecialEventObjectiveData::UnlockedRewardGenericIconPath' has a wrong offset!");
static_assert(offsetof(FSpecialEventObjectiveData, PlayerRole) == 0x0000C0, "Member 'FSpecialEventObjectiveData::PlayerRole' has a wrong offset!");
static_assert(offsetof(FSpecialEventObjectiveData, StatName) == 0x0000C8, "Member 'FSpecialEventObjectiveData::StatName' has a wrong offset!");
static_assert(offsetof(FSpecialEventObjectiveData, Sections) == 0x0000D8, "Member 'FSpecialEventObjectiveData::Sections' has a wrong offset!");
static_assert(offsetof(FSpecialEventObjectiveData, MaxValue) == 0x0000DC, "Member 'FSpecialEventObjectiveData::MaxValue' has a wrong offset!");

// ScriptStruct DeadByDaylight.SpecialEventEntryPopupData
// 0x00C8 (0x00C8 - 0x0000)
struct FSpecialEventEntryPopupData final
{
public:
	class FText                                   Title;                                             // 0x0000(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0018(0x0018)(Edit, NativeAccessSpecifierPublic)
	TArray<class FName>                           AdditionalStoreItemIds;                            // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           AdditionalStoreEventsIds;                          // 0x0040(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           StoreItemIdPriorityOrdering;                       // 0x0050(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           CollectionItemIdPriorityOrdering;                  // 0x0060(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          UseDetailsTab;                                     // 0x0070(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSpecialEventDetailsTabData            DetailsTabData;                                    // 0x0078(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpecialEventEntryPopupData) == 0x000008, "Wrong alignment on FSpecialEventEntryPopupData");
static_assert(sizeof(FSpecialEventEntryPopupData) == 0x0000C8, "Wrong size on FSpecialEventEntryPopupData");
static_assert(offsetof(FSpecialEventEntryPopupData, Title) == 0x000000, "Member 'FSpecialEventEntryPopupData::Title' has a wrong offset!");
static_assert(offsetof(FSpecialEventEntryPopupData, Description) == 0x000018, "Member 'FSpecialEventEntryPopupData::Description' has a wrong offset!");
static_assert(offsetof(FSpecialEventEntryPopupData, AdditionalStoreItemIds) == 0x000030, "Member 'FSpecialEventEntryPopupData::AdditionalStoreItemIds' has a wrong offset!");
static_assert(offsetof(FSpecialEventEntryPopupData, AdditionalStoreEventsIds) == 0x000040, "Member 'FSpecialEventEntryPopupData::AdditionalStoreEventsIds' has a wrong offset!");
static_assert(offsetof(FSpecialEventEntryPopupData, StoreItemIdPriorityOrdering) == 0x000050, "Member 'FSpecialEventEntryPopupData::StoreItemIdPriorityOrdering' has a wrong offset!");
static_assert(offsetof(FSpecialEventEntryPopupData, CollectionItemIdPriorityOrdering) == 0x000060, "Member 'FSpecialEventEntryPopupData::CollectionItemIdPriorityOrdering' has a wrong offset!");
static_assert(offsetof(FSpecialEventEntryPopupData, UseDetailsTab) == 0x000070, "Member 'FSpecialEventEntryPopupData::UseDetailsTab' has a wrong offset!");
static_assert(offsetof(FSpecialEventEntryPopupData, DetailsTabData) == 0x000078, "Member 'FSpecialEventEntryPopupData::DetailsTabData' has a wrong offset!");

// ScriptStruct DeadByDaylight.SpecialEventSplashScreenData
// 0x0040 (0x0040 - 0x0000)
struct FSpecialEventSplashScreenData final
{
public:
	bool                                          Enabled;                                           // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Delay;                                             // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   DBDLogoClass;                                      // 0x0008(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpecialEventSplashScreenData) == 0x000008, "Wrong alignment on FSpecialEventSplashScreenData");
static_assert(sizeof(FSpecialEventSplashScreenData) == 0x000040, "Wrong size on FSpecialEventSplashScreenData");
static_assert(offsetof(FSpecialEventSplashScreenData, Enabled) == 0x000000, "Member 'FSpecialEventSplashScreenData::Enabled' has a wrong offset!");
static_assert(offsetof(FSpecialEventSplashScreenData, Delay) == 0x000004, "Member 'FSpecialEventSplashScreenData::Delay' has a wrong offset!");
static_assert(offsetof(FSpecialEventSplashScreenData, DBDLogoClass) == 0x000008, "Member 'FSpecialEventSplashScreenData::DBDLogoClass' has a wrong offset!");

// ScriptStruct DeadByDaylight.SpecialEventOfferingSequenceData
// 0x0070 (0x0070 - 0x0000)
struct FSpecialEventOfferingSequenceData final
{
public:
	TSoftClassPtr<class UClass>                   CardClass;                                         // 0x0000(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   ManagerClass;                                      // 0x0038(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpecialEventOfferingSequenceData) == 0x000008, "Wrong alignment on FSpecialEventOfferingSequenceData");
static_assert(sizeof(FSpecialEventOfferingSequenceData) == 0x000070, "Wrong size on FSpecialEventOfferingSequenceData");
static_assert(offsetof(FSpecialEventOfferingSequenceData, CardClass) == 0x000000, "Member 'FSpecialEventOfferingSequenceData::CardClass' has a wrong offset!");
static_assert(offsetof(FSpecialEventOfferingSequenceData, ManagerClass) == 0x000038, "Member 'FSpecialEventOfferingSequenceData::ManagerClass' has a wrong offset!");

// ScriptStruct DeadByDaylight.SpecialEventUiTakeoverData
// 0x0005 (0x0005 - 0x0000)
struct FSpecialEventUiTakeoverData final
{
public:
	bool                                          UseMainMenuTakeover;                               // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseEventEntryPopupTakeover;                        // 0x0001(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseArchivesTakeover;                               // 0x0002(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseStoreShrineTakeover;                            // 0x0003(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseLobbyTakeover;                                  // 0x0004(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpecialEventUiTakeoverData) == 0x000001, "Wrong alignment on FSpecialEventUiTakeoverData");
static_assert(sizeof(FSpecialEventUiTakeoverData) == 0x000005, "Wrong size on FSpecialEventUiTakeoverData");
static_assert(offsetof(FSpecialEventUiTakeoverData, UseMainMenuTakeover) == 0x000000, "Member 'FSpecialEventUiTakeoverData::UseMainMenuTakeover' has a wrong offset!");
static_assert(offsetof(FSpecialEventUiTakeoverData, UseEventEntryPopupTakeover) == 0x000001, "Member 'FSpecialEventUiTakeoverData::UseEventEntryPopupTakeover' has a wrong offset!");
static_assert(offsetof(FSpecialEventUiTakeoverData, UseArchivesTakeover) == 0x000002, "Member 'FSpecialEventUiTakeoverData::UseArchivesTakeover' has a wrong offset!");
static_assert(offsetof(FSpecialEventUiTakeoverData, UseStoreShrineTakeover) == 0x000003, "Member 'FSpecialEventUiTakeoverData::UseStoreShrineTakeover' has a wrong offset!");
static_assert(offsetof(FSpecialEventUiTakeoverData, UseLobbyTakeover) == 0x000004, "Member 'FSpecialEventUiTakeoverData::UseLobbyTakeover' has a wrong offset!");

// ScriptStruct DeadByDaylight.SpecialEventData
// 0x02D0 (0x02D8 - 0x0008)
struct FSpecialEventData final : public FDBDTableRowBase
{
public:
	class FName                                   EventID;                                           // 0x0008(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESpecialEventMainMenuType                     MainMenuType;                                      // 0x0014(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECurrencyType                                 CurrencyType;                                      // 0x0015(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16[0x2];                                       // 0x0016(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   EventName;                                         // 0x0018(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FString                                 EventBannerLabel;                                  // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 EventThemeLabel;                                   // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsTrackedOnline;                                   // 0x0050(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseSpecialEventLoadingScreen;                      // 0x0051(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseSpecialEventLoadingScreenInOnlineQueue;         // 0x0052(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_53[0x5];                                       // 0x0053(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSpecialEventCommunityChallengeData    CommunityChallenge;                                // 0x0058(0x0070)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<struct FSpecialEventObjectiveData>     Objectives;                                        // 0x00C8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 LobbyName;                                         // 0x00D8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ShopName;                                          // 0x00E8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         AdditionalLobbyNames;                              // 0x00F8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   AudioStateSpecialEvent;                            // 0x0108(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_114[0x4];                                      // 0x0114(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSpecialBehaviourSpawnableComponent> SpawnableComponents;                               // 0x0118(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	ESpecialEventGameMode                         GameMode;                                          // 0x0128(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseEventEntryScreen;                               // 0x0129(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12A[0x6];                                      // 0x012A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSpecialEventEntryPopupData            EventEntryData;                                    // 0x0130(0x00C8)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	ESpecialEventDependency                       EventDependency;                                   // 0x01F8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseMarketDiscount;                                 // 0x01F9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSpecialEventBloodwebData              Bloodweb;                                          // 0x01FA(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FB[0x5];                                      // 0x01FB(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSpecialEventOfferingSequenceData      OfferingSequence;                                  // 0x0200(0x0070)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FSpecialEventSplashScreenData          SplashScreen;                                      // 0x0270(0x0040)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FSpecialEventUiTakeoverData            UiTakeoverData;                                    // 0x02B0(0x0005)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B5[0x3];                                      // 0x02B5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UCommentatorAudioData*                  CommentatorAudioData;                              // 0x02B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             EffectCardsDB;                                     // 0x02C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 InclusionVersion;                                  // 0x02C8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpecialEventData) == 0x000008, "Wrong alignment on FSpecialEventData");
static_assert(sizeof(FSpecialEventData) == 0x0002D8, "Wrong size on FSpecialEventData");
static_assert(offsetof(FSpecialEventData, EventID) == 0x000008, "Member 'FSpecialEventData::EventID' has a wrong offset!");
static_assert(offsetof(FSpecialEventData, MainMenuType) == 0x000014, "Member 'FSpecialEventData::MainMenuType' has a wrong offset!");
static_assert(offsetof(FSpecialEventData, CurrencyType) == 0x000015, "Member 'FSpecialEventData::CurrencyType' has a wrong offset!");
static_assert(offsetof(FSpecialEventData, EventName) == 0x000018, "Member 'FSpecialEventData::EventName' has a wrong offset!");
static_assert(offsetof(FSpecialEventData, EventBannerLabel) == 0x000030, "Member 'FSpecialEventData::EventBannerLabel' has a wrong offset!");
static_assert(offsetof(FSpecialEventData, EventThemeLabel) == 0x000040, "Member 'FSpecialEventData::EventThemeLabel' has a wrong offset!");
static_assert(offsetof(FSpecialEventData, IsTrackedOnline) == 0x000050, "Member 'FSpecialEventData::IsTrackedOnline' has a wrong offset!");
static_assert(offsetof(FSpecialEventData, UseSpecialEventLoadingScreen) == 0x000051, "Member 'FSpecialEventData::UseSpecialEventLoadingScreen' has a wrong offset!");
static_assert(offsetof(FSpecialEventData, UseSpecialEventLoadingScreenInOnlineQueue) == 0x000052, "Member 'FSpecialEventData::UseSpecialEventLoadingScreenInOnlineQueue' has a wrong offset!");
static_assert(offsetof(FSpecialEventData, CommunityChallenge) == 0x000058, "Member 'FSpecialEventData::CommunityChallenge' has a wrong offset!");
static_assert(offsetof(FSpecialEventData, Objectives) == 0x0000C8, "Member 'FSpecialEventData::Objectives' has a wrong offset!");
static_assert(offsetof(FSpecialEventData, LobbyName) == 0x0000D8, "Member 'FSpecialEventData::LobbyName' has a wrong offset!");
static_assert(offsetof(FSpecialEventData, ShopName) == 0x0000E8, "Member 'FSpecialEventData::ShopName' has a wrong offset!");
static_assert(offsetof(FSpecialEventData, AdditionalLobbyNames) == 0x0000F8, "Member 'FSpecialEventData::AdditionalLobbyNames' has a wrong offset!");
static_assert(offsetof(FSpecialEventData, AudioStateSpecialEvent) == 0x000108, "Member 'FSpecialEventData::AudioStateSpecialEvent' has a wrong offset!");
static_assert(offsetof(FSpecialEventData, SpawnableComponents) == 0x000118, "Member 'FSpecialEventData::SpawnableComponents' has a wrong offset!");
static_assert(offsetof(FSpecialEventData, GameMode) == 0x000128, "Member 'FSpecialEventData::GameMode' has a wrong offset!");
static_assert(offsetof(FSpecialEventData, UseEventEntryScreen) == 0x000129, "Member 'FSpecialEventData::UseEventEntryScreen' has a wrong offset!");
static_assert(offsetof(FSpecialEventData, EventEntryData) == 0x000130, "Member 'FSpecialEventData::EventEntryData' has a wrong offset!");
static_assert(offsetof(FSpecialEventData, EventDependency) == 0x0001F8, "Member 'FSpecialEventData::EventDependency' has a wrong offset!");
static_assert(offsetof(FSpecialEventData, UseMarketDiscount) == 0x0001F9, "Member 'FSpecialEventData::UseMarketDiscount' has a wrong offset!");
static_assert(offsetof(FSpecialEventData, Bloodweb) == 0x0001FA, "Member 'FSpecialEventData::Bloodweb' has a wrong offset!");
static_assert(offsetof(FSpecialEventData, OfferingSequence) == 0x000200, "Member 'FSpecialEventData::OfferingSequence' has a wrong offset!");
static_assert(offsetof(FSpecialEventData, SplashScreen) == 0x000270, "Member 'FSpecialEventData::SplashScreen' has a wrong offset!");
static_assert(offsetof(FSpecialEventData, UiTakeoverData) == 0x0002B0, "Member 'FSpecialEventData::UiTakeoverData' has a wrong offset!");
static_assert(offsetof(FSpecialEventData, CommentatorAudioData) == 0x0002B8, "Member 'FSpecialEventData::CommentatorAudioData' has a wrong offset!");
static_assert(offsetof(FSpecialEventData, EffectCardsDB) == 0x0002C0, "Member 'FSpecialEventData::EffectCardsDB' has a wrong offset!");
static_assert(offsetof(FSpecialEventData, InclusionVersion) == 0x0002C8, "Member 'FSpecialEventData::InclusionVersion' has a wrong offset!");

// ScriptStruct DeadByDaylight.SpecialEventLoadingTextData
// 0x0068 (0x0068 - 0x0000)
struct FSpecialEventLoadingTextData final
{
public:
	class FName                                   EventID;                                           // 0x0000(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Title;                                             // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Description;                                       // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 IconPath;                                          // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SpecialBehaviourId;                                // 0x0040(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ID;                                                // 0x0050(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsPreviousSpecial;                                 // 0x0060(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsPreviousSpecial_IsSet;                           // 0x0061(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsNextSpecial;                                     // 0x0062(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsNextSpecial_IsSet;                               // 0x0063(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSpecialEventLoadingTextData) == 0x000008, "Wrong alignment on FSpecialEventLoadingTextData");
static_assert(sizeof(FSpecialEventLoadingTextData) == 0x000068, "Wrong size on FSpecialEventLoadingTextData");
static_assert(offsetof(FSpecialEventLoadingTextData, EventID) == 0x000000, "Member 'FSpecialEventLoadingTextData::EventID' has a wrong offset!");
static_assert(offsetof(FSpecialEventLoadingTextData, Title) == 0x000010, "Member 'FSpecialEventLoadingTextData::Title' has a wrong offset!");
static_assert(offsetof(FSpecialEventLoadingTextData, Description) == 0x000020, "Member 'FSpecialEventLoadingTextData::Description' has a wrong offset!");
static_assert(offsetof(FSpecialEventLoadingTextData, IconPath) == 0x000030, "Member 'FSpecialEventLoadingTextData::IconPath' has a wrong offset!");
static_assert(offsetof(FSpecialEventLoadingTextData, SpecialBehaviourId) == 0x000040, "Member 'FSpecialEventLoadingTextData::SpecialBehaviourId' has a wrong offset!");
static_assert(offsetof(FSpecialEventLoadingTextData, ID) == 0x000050, "Member 'FSpecialEventLoadingTextData::ID' has a wrong offset!");
static_assert(offsetof(FSpecialEventLoadingTextData, IsPreviousSpecial) == 0x000060, "Member 'FSpecialEventLoadingTextData::IsPreviousSpecial' has a wrong offset!");
static_assert(offsetof(FSpecialEventLoadingTextData, IsPreviousSpecial_IsSet) == 0x000061, "Member 'FSpecialEventLoadingTextData::IsPreviousSpecial_IsSet' has a wrong offset!");
static_assert(offsetof(FSpecialEventLoadingTextData, IsNextSpecial) == 0x000062, "Member 'FSpecialEventLoadingTextData::IsNextSpecial' has a wrong offset!");
static_assert(offsetof(FSpecialEventLoadingTextData, IsNextSpecial_IsSet) == 0x000063, "Member 'FSpecialEventLoadingTextData::IsNextSpecial_IsSet' has a wrong offset!");

// ScriptStruct DeadByDaylight.LoadingTextContentData
// 0x0018 (0x0018 - 0x0000)
struct FLoadingTextContentData final
{
public:
	TArray<struct FSpecialEventLoadingTextData>   LoadingText;                                       // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          LoadingText_isset;                                 // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLoadingTextContentData) == 0x000008, "Wrong alignment on FLoadingTextContentData");
static_assert(sizeof(FLoadingTextContentData) == 0x000018, "Wrong size on FLoadingTextContentData");
static_assert(offsetof(FLoadingTextContentData, LoadingText) == 0x000000, "Member 'FLoadingTextContentData::LoadingText' has a wrong offset!");
static_assert(offsetof(FLoadingTextContentData, LoadingText_isset) == 0x000010, "Member 'FLoadingTextContentData::LoadingText_isset' has a wrong offset!");

// ScriptStruct DeadByDaylight.SpecialEventMiscRewards
// 0x0020 (0x0020 - 0x0000)
struct FSpecialEventMiscRewards final
{
public:
	class FString                                 ID;                                                // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FRewardResponseItem>            Rewards;                                           // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpecialEventMiscRewards) == 0x000008, "Wrong alignment on FSpecialEventMiscRewards");
static_assert(sizeof(FSpecialEventMiscRewards) == 0x000020, "Wrong size on FSpecialEventMiscRewards");
static_assert(offsetof(FSpecialEventMiscRewards, ID) == 0x000000, "Member 'FSpecialEventMiscRewards::ID' has a wrong offset!");
static_assert(offsetof(FSpecialEventMiscRewards, Rewards) == 0x000010, "Member 'FSpecialEventMiscRewards::Rewards' has a wrong offset!");

// ScriptStruct DeadByDaylight.EventPeriod
// 0x0040 (0x0040 - 0x0000)
struct FEventPeriod final
{
public:
	class FString                                 ID;                                                // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 StartDate;                                         // 0x0010(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 EndDate;                                           // 0x0020(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEventPeriod) == 0x000008, "Wrong alignment on FEventPeriod");
static_assert(sizeof(FEventPeriod) == 0x000040, "Wrong size on FEventPeriod");
static_assert(offsetof(FEventPeriod, ID) == 0x000000, "Member 'FEventPeriod::ID' has a wrong offset!");
static_assert(offsetof(FEventPeriod, StartDate) == 0x000010, "Member 'FEventPeriod::StartDate' has a wrong offset!");
static_assert(offsetof(FEventPeriod, EndDate) == 0x000020, "Member 'FEventPeriod::EndDate' has a wrong offset!");

// ScriptStruct DeadByDaylight.LTEData
// 0x0040 (0x0040 - 0x0000)
struct FLTEData final
{
public:
	class FString                                 GameType;                                          // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 GameModeQueue;                                     // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IncentiveBonus;                                    // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         KillswitchPlatforms;                               // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          KillswitchPlatforms_IsSet;                         // 0x0038(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLTEData) == 0x000008, "Wrong alignment on FLTEData");
static_assert(sizeof(FLTEData) == 0x000040, "Wrong size on FLTEData");
static_assert(offsetof(FLTEData, GameType) == 0x000000, "Member 'FLTEData::GameType' has a wrong offset!");
static_assert(offsetof(FLTEData, GameModeQueue) == 0x000010, "Member 'FLTEData::GameModeQueue' has a wrong offset!");
static_assert(offsetof(FLTEData, IncentiveBonus) == 0x000020, "Member 'FLTEData::IncentiveBonus' has a wrong offset!");
static_assert(offsetof(FLTEData, KillswitchPlatforms) == 0x000028, "Member 'FLTEData::KillswitchPlatforms' has a wrong offset!");
static_assert(offsetof(FLTEData, KillswitchPlatforms_IsSet) == 0x000038, "Member 'FLTEData::KillswitchPlatforms_IsSet' has a wrong offset!");

// ScriptStruct DeadByDaylight.EventTrackerQuestEventCondition
// 0x0020 (0x0020 - 0x0000)
struct FEventTrackerQuestEventCondition final
{
public:
	class FString                                 Key;                                               // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         Value;                                             // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEventTrackerQuestEventCondition) == 0x000008, "Wrong alignment on FEventTrackerQuestEventCondition");
static_assert(sizeof(FEventTrackerQuestEventCondition) == 0x000020, "Wrong size on FEventTrackerQuestEventCondition");
static_assert(offsetof(FEventTrackerQuestEventCondition, Key) == 0x000000, "Member 'FEventTrackerQuestEventCondition::Key' has a wrong offset!");
static_assert(offsetof(FEventTrackerQuestEventCondition, Value) == 0x000010, "Member 'FEventTrackerQuestEventCondition::Value' has a wrong offset!");

// ScriptStruct DeadByDaylight.EventTrackerObjective
// 0x0060 (0x0060 - 0x0000)
struct FEventTrackerObjective final
{
public:
	class FString                                 ID;                                                // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxProgressionPerMatchPlayer;                      // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 QuestEventId;                                      // 0x0018(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 QuestEventParams;                                  // 0x0028(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FEventTrackerQuestEventCondition> QuestEventConditions;                              // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          QuestEventConditions_IsSet;                        // 0x0048(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FEventTrackerObjectiveMilestone> Milestones;                                        // 0x0050(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEventTrackerObjective) == 0x000008, "Wrong alignment on FEventTrackerObjective");
static_assert(sizeof(FEventTrackerObjective) == 0x000060, "Wrong size on FEventTrackerObjective");
static_assert(offsetof(FEventTrackerObjective, ID) == 0x000000, "Member 'FEventTrackerObjective::ID' has a wrong offset!");
static_assert(offsetof(FEventTrackerObjective, MaxProgressionPerMatchPlayer) == 0x000010, "Member 'FEventTrackerObjective::MaxProgressionPerMatchPlayer' has a wrong offset!");
static_assert(offsetof(FEventTrackerObjective, QuestEventId) == 0x000018, "Member 'FEventTrackerObjective::QuestEventId' has a wrong offset!");
static_assert(offsetof(FEventTrackerObjective, QuestEventParams) == 0x000028, "Member 'FEventTrackerObjective::QuestEventParams' has a wrong offset!");
static_assert(offsetof(FEventTrackerObjective, QuestEventConditions) == 0x000038, "Member 'FEventTrackerObjective::QuestEventConditions' has a wrong offset!");
static_assert(offsetof(FEventTrackerObjective, QuestEventConditions_IsSet) == 0x000048, "Member 'FEventTrackerObjective::QuestEventConditions_IsSet' has a wrong offset!");
static_assert(offsetof(FEventTrackerObjective, Milestones) == 0x000050, "Member 'FEventTrackerObjective::Milestones' has a wrong offset!");

// ScriptStruct DeadByDaylight.SpecialEventsData
// 0x00E8 (0x00E8 - 0x0000)
struct FSpecialEventsData final
{
public:
	class FString                                 EventID;                                           // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLTEData                               LTEData;                                           // 0x0010(0x0040)(NativeAccessSpecifierPublic)
	bool                                          LteData_IsSet;                                     // 0x0050(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSpecialEventMiscRewards>       MiscRewards;                                       // 0x0058(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          MiscRewards_IsSet;                                 // 0x0068(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRewardResponseItem>            OwnerRewards;                                      // 0x0070(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          OwnerRewards_IsSet;                                // 0x0080(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0x7];                                       // 0x0081(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FScoreEventRewards>             ScoreEventRewards;                                 // 0x0088(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          ScoreEventRewards_IsSet;                           // 0x0098(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSpecialEventMilestoneRewards>  MilestoneRewards;                                  // 0x00A0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          MilestoneRewards_IsSet;                            // 0x00B0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0x7];                                       // 0x00B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FEventPeriod>                   EventPeriods;                                      // 0x00B8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          EventPeriods_IsSet;                                // 0x00C8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C9[0x7];                                       // 0x00C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FEventTrackerObjective>         EventTrackerObjectives;                            // 0x00D0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          EventTrackerObjectives_IsSet;                      // 0x00E0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E1[0x7];                                       // 0x00E1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSpecialEventsData) == 0x000008, "Wrong alignment on FSpecialEventsData");
static_assert(sizeof(FSpecialEventsData) == 0x0000E8, "Wrong size on FSpecialEventsData");
static_assert(offsetof(FSpecialEventsData, EventID) == 0x000000, "Member 'FSpecialEventsData::EventID' has a wrong offset!");
static_assert(offsetof(FSpecialEventsData, LTEData) == 0x000010, "Member 'FSpecialEventsData::LTEData' has a wrong offset!");
static_assert(offsetof(FSpecialEventsData, LteData_IsSet) == 0x000050, "Member 'FSpecialEventsData::LteData_IsSet' has a wrong offset!");
static_assert(offsetof(FSpecialEventsData, MiscRewards) == 0x000058, "Member 'FSpecialEventsData::MiscRewards' has a wrong offset!");
static_assert(offsetof(FSpecialEventsData, MiscRewards_IsSet) == 0x000068, "Member 'FSpecialEventsData::MiscRewards_IsSet' has a wrong offset!");
static_assert(offsetof(FSpecialEventsData, OwnerRewards) == 0x000070, "Member 'FSpecialEventsData::OwnerRewards' has a wrong offset!");
static_assert(offsetof(FSpecialEventsData, OwnerRewards_IsSet) == 0x000080, "Member 'FSpecialEventsData::OwnerRewards_IsSet' has a wrong offset!");
static_assert(offsetof(FSpecialEventsData, ScoreEventRewards) == 0x000088, "Member 'FSpecialEventsData::ScoreEventRewards' has a wrong offset!");
static_assert(offsetof(FSpecialEventsData, ScoreEventRewards_IsSet) == 0x000098, "Member 'FSpecialEventsData::ScoreEventRewards_IsSet' has a wrong offset!");
static_assert(offsetof(FSpecialEventsData, MilestoneRewards) == 0x0000A0, "Member 'FSpecialEventsData::MilestoneRewards' has a wrong offset!");
static_assert(offsetof(FSpecialEventsData, MilestoneRewards_IsSet) == 0x0000B0, "Member 'FSpecialEventsData::MilestoneRewards_IsSet' has a wrong offset!");
static_assert(offsetof(FSpecialEventsData, EventPeriods) == 0x0000B8, "Member 'FSpecialEventsData::EventPeriods' has a wrong offset!");
static_assert(offsetof(FSpecialEventsData, EventPeriods_IsSet) == 0x0000C8, "Member 'FSpecialEventsData::EventPeriods_IsSet' has a wrong offset!");
static_assert(offsetof(FSpecialEventsData, EventTrackerObjectives) == 0x0000D0, "Member 'FSpecialEventsData::EventTrackerObjectives' has a wrong offset!");
static_assert(offsetof(FSpecialEventsData, EventTrackerObjectives_IsSet) == 0x0000E0, "Member 'FSpecialEventsData::EventTrackerObjectives_IsSet' has a wrong offset!");

// ScriptStruct DeadByDaylight.SpecialEventContent
// 0x0028 (0x0028 - 0x0000)
struct FSpecialEventContent final
{
public:
	TArray<struct FSpecialEventsContentData>      SpecialEvents;                                     // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSpecialEventsData>             SpecialEventsData;                                 // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          SpecialEventsData_IsSet;                           // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSpecialEventContent) == 0x000008, "Wrong alignment on FSpecialEventContent");
static_assert(sizeof(FSpecialEventContent) == 0x000028, "Wrong size on FSpecialEventContent");
static_assert(offsetof(FSpecialEventContent, SpecialEvents) == 0x000000, "Member 'FSpecialEventContent::SpecialEvents' has a wrong offset!");
static_assert(offsetof(FSpecialEventContent, SpecialEventsData) == 0x000010, "Member 'FSpecialEventContent::SpecialEventsData' has a wrong offset!");
static_assert(offsetof(FSpecialEventContent, SpecialEventsData_IsSet) == 0x000020, "Member 'FSpecialEventContent::SpecialEventsData_IsSet' has a wrong offset!");

// ScriptStruct DeadByDaylight.StatusEffectInitializationData
// 0x0028 (0x0028 - 0x0000)
struct FStatusEffectInitializationData final
{
public:
	class ADBDPlayer*                             OriginatingPlayer;                                 // 0x0000(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasOriginatingPlayer;                              // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UGameplayModifierContainer*             OriginatingEffect;                                 // 0x0010(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasOriginatingEffect;                              // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStatusEffectType                             StatusEffectType;                                  // 0x0019(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x2];                                       // 0x001A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CustomParam;                                       // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitializationLifeTime;                            // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AuthorityDataSet;                                  // 0x0024(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStatusEffectInitializationData) == 0x000008, "Wrong alignment on FStatusEffectInitializationData");
static_assert(sizeof(FStatusEffectInitializationData) == 0x000028, "Wrong size on FStatusEffectInitializationData");
static_assert(offsetof(FStatusEffectInitializationData, OriginatingPlayer) == 0x000000, "Member 'FStatusEffectInitializationData::OriginatingPlayer' has a wrong offset!");
static_assert(offsetof(FStatusEffectInitializationData, HasOriginatingPlayer) == 0x000008, "Member 'FStatusEffectInitializationData::HasOriginatingPlayer' has a wrong offset!");
static_assert(offsetof(FStatusEffectInitializationData, OriginatingEffect) == 0x000010, "Member 'FStatusEffectInitializationData::OriginatingEffect' has a wrong offset!");
static_assert(offsetof(FStatusEffectInitializationData, HasOriginatingEffect) == 0x000018, "Member 'FStatusEffectInitializationData::HasOriginatingEffect' has a wrong offset!");
static_assert(offsetof(FStatusEffectInitializationData, StatusEffectType) == 0x000019, "Member 'FStatusEffectInitializationData::StatusEffectType' has a wrong offset!");
static_assert(offsetof(FStatusEffectInitializationData, CustomParam) == 0x00001C, "Member 'FStatusEffectInitializationData::CustomParam' has a wrong offset!");
static_assert(offsetof(FStatusEffectInitializationData, InitializationLifeTime) == 0x000020, "Member 'FStatusEffectInitializationData::InitializationLifeTime' has a wrong offset!");
static_assert(offsetof(FStatusEffectInitializationData, AuthorityDataSet) == 0x000024, "Member 'FStatusEffectInitializationData::AuthorityDataSet' has a wrong offset!");

// ScriptStruct DeadByDaylight.StatusEffectProperties
// 0x0050 (0x02F0 - 0x02A0)
struct FStatusEffectProperties final : public FItemData
{
public:
	TArray<class FName>                           Tags;                                              // 0x02A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   StatusEffectBlueprint;                             // 0x02B0(0x0038)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStatusEffectType                             StatusEffectType;                                  // 0x02E8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EExternalEffectSource                         ExternalEffectSource;                              // 0x02E9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2EA[0x6];                                      // 0x02EA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStatusEffectProperties) == 0x000008, "Wrong alignment on FStatusEffectProperties");
static_assert(sizeof(FStatusEffectProperties) == 0x0002F0, "Wrong size on FStatusEffectProperties");
static_assert(offsetof(FStatusEffectProperties, Tags) == 0x0002A0, "Member 'FStatusEffectProperties::Tags' has a wrong offset!");
static_assert(offsetof(FStatusEffectProperties, StatusEffectBlueprint) == 0x0002B0, "Member 'FStatusEffectProperties::StatusEffectBlueprint' has a wrong offset!");
static_assert(offsetof(FStatusEffectProperties, StatusEffectType) == 0x0002E8, "Member 'FStatusEffectProperties::StatusEffectType' has a wrong offset!");
static_assert(offsetof(FStatusEffectProperties, ExternalEffectSource) == 0x0002E9, "Member 'FStatusEffectProperties::ExternalEffectSource' has a wrong offset!");

// ScriptStruct DeadByDaylight.StatusViewSource
// 0x002C (0x002C - 0x0000)
struct FStatusViewSource final
{
public:
	class FName                                   _sourceID;                                         // 0x0000(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isActive;                                         // 0x000C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _remainingTime;                                    // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _percentageFill;                                   // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _level;                                            // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EInventoryItemType                            _sourceType;                                       // 0x001C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _sourceIconIndex;                                  // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _sourceLevel;                                      // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isVisuallyInfinite;                               // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStatusViewSource) == 0x000004, "Wrong alignment on FStatusViewSource");
static_assert(sizeof(FStatusViewSource) == 0x00002C, "Wrong size on FStatusViewSource");
static_assert(offsetof(FStatusViewSource, _sourceID) == 0x000000, "Member 'FStatusViewSource::_sourceID' has a wrong offset!");
static_assert(offsetof(FStatusViewSource, _isActive) == 0x00000C, "Member 'FStatusViewSource::_isActive' has a wrong offset!");
static_assert(offsetof(FStatusViewSource, _remainingTime) == 0x000010, "Member 'FStatusViewSource::_remainingTime' has a wrong offset!");
static_assert(offsetof(FStatusViewSource, _percentageFill) == 0x000014, "Member 'FStatusViewSource::_percentageFill' has a wrong offset!");
static_assert(offsetof(FStatusViewSource, _level) == 0x000018, "Member 'FStatusViewSource::_level' has a wrong offset!");
static_assert(offsetof(FStatusViewSource, _sourceType) == 0x00001C, "Member 'FStatusViewSource::_sourceType' has a wrong offset!");
static_assert(offsetof(FStatusViewSource, _sourceIconIndex) == 0x000020, "Member 'FStatusViewSource::_sourceIconIndex' has a wrong offset!");
static_assert(offsetof(FStatusViewSource, _sourceLevel) == 0x000024, "Member 'FStatusViewSource::_sourceLevel' has a wrong offset!");
static_assert(offsetof(FStatusViewSource, _isVisuallyInfinite) == 0x000028, "Member 'FStatusViewSource::_isVisuallyInfinite' has a wrong offset!");

// ScriptStruct DeadByDaylight.StatusViewProperties
// 0x00D0 (0x00D8 - 0x0008)
struct FStatusViewProperties final : public FDBDTableRowBase
{
public:
	class FName                                   _statusViewID;                                     // 0x0008(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   _description;                                      // 0x0018(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FText                                   _displayName;                                      // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   _statusViewBlueprint;                              // 0x0048(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EStatusEffectType                             _statusType;                                       // 0x0080(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_81[0x7];                                       // 0x0081(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 _iconFilePath;                                     // 0x0088(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UTexture2D>              _iconAsset;                                        // 0x0098(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _playIntroAnimation;                               // 0x00D0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D1[0x7];                                       // 0x00D1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStatusViewProperties) == 0x000008, "Wrong alignment on FStatusViewProperties");
static_assert(sizeof(FStatusViewProperties) == 0x0000D8, "Wrong size on FStatusViewProperties");
static_assert(offsetof(FStatusViewProperties, _statusViewID) == 0x000008, "Member 'FStatusViewProperties::_statusViewID' has a wrong offset!");
static_assert(offsetof(FStatusViewProperties, _description) == 0x000018, "Member 'FStatusViewProperties::_description' has a wrong offset!");
static_assert(offsetof(FStatusViewProperties, _displayName) == 0x000030, "Member 'FStatusViewProperties::_displayName' has a wrong offset!");
static_assert(offsetof(FStatusViewProperties, _statusViewBlueprint) == 0x000048, "Member 'FStatusViewProperties::_statusViewBlueprint' has a wrong offset!");
static_assert(offsetof(FStatusViewProperties, _statusType) == 0x000080, "Member 'FStatusViewProperties::_statusType' has a wrong offset!");
static_assert(offsetof(FStatusViewProperties, _iconFilePath) == 0x000088, "Member 'FStatusViewProperties::_iconFilePath' has a wrong offset!");
static_assert(offsetof(FStatusViewProperties, _iconAsset) == 0x000098, "Member 'FStatusViewProperties::_iconAsset' has a wrong offset!");
static_assert(offsetof(FStatusViewProperties, _playIntroAnimation) == 0x0000D0, "Member 'FStatusViewProperties::_playIntroAnimation' has a wrong offset!");

// ScriptStruct DeadByDaylight.StoreCollectionLimitedAvailabilityStart
// 0x0010 (0x0010 - 0x0000)
struct FStoreCollectionLimitedAvailabilityStart final
{
public:
	struct FDateTime                              Date;                                              // 0x0000(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          VisibleBeforeStartDate;                            // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStoreCollectionLimitedAvailabilityStart) == 0x000008, "Wrong alignment on FStoreCollectionLimitedAvailabilityStart");
static_assert(sizeof(FStoreCollectionLimitedAvailabilityStart) == 0x000010, "Wrong size on FStoreCollectionLimitedAvailabilityStart");
static_assert(offsetof(FStoreCollectionLimitedAvailabilityStart, Date) == 0x000000, "Member 'FStoreCollectionLimitedAvailabilityStart::Date' has a wrong offset!");
static_assert(offsetof(FStoreCollectionLimitedAvailabilityStart, VisibleBeforeStartDate) == 0x000008, "Member 'FStoreCollectionLimitedAvailabilityStart::VisibleBeforeStartDate' has a wrong offset!");

// ScriptStruct DeadByDaylight.StoreCollectionEditorData
// 0x0110 (0x0118 - 0x0008)
struct FStoreCollectionEditorData final : public FDBDTableRowBase
{
public:
	class FString                                 CollectionId;                                      // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 InclusionVersion;                                  // 0x0018(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   CollectionTitle;                                   // 0x0028(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   CollectionSubtitle;                                // 0x0040(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FDateTime                              DateUpdated;                                       // 0x0058(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsEnabled;                                         // 0x0060(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasLimitedAvailabilityStartDate;                   // 0x0061(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_62[0x6];                                       // 0x0062(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FStoreCollectionLimitedAvailabilityStart LimitedAvailabilityStart;                          // 0x0068(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          HasLimitedAvailabilityEndDate;                     // 0x0078(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FStoreCollectionLimitedAvailabilityEnd LimitedAvailabilityEnd;                            // 0x0080(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         SortOrder;                                         // 0x0090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        HeroImage;                                         // 0x0098(0x0028)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        HeroVideo;                                         // 0x00C0(0x0028)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSoftObjectPath>                AdditionalImages;                                  // 0x00E8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         Items;                                             // 0x00F8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_108[0x10];                                     // 0x0108(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStoreCollectionEditorData) == 0x000008, "Wrong alignment on FStoreCollectionEditorData");
static_assert(sizeof(FStoreCollectionEditorData) == 0x000118, "Wrong size on FStoreCollectionEditorData");
static_assert(offsetof(FStoreCollectionEditorData, CollectionId) == 0x000008, "Member 'FStoreCollectionEditorData::CollectionId' has a wrong offset!");
static_assert(offsetof(FStoreCollectionEditorData, InclusionVersion) == 0x000018, "Member 'FStoreCollectionEditorData::InclusionVersion' has a wrong offset!");
static_assert(offsetof(FStoreCollectionEditorData, CollectionTitle) == 0x000028, "Member 'FStoreCollectionEditorData::CollectionTitle' has a wrong offset!");
static_assert(offsetof(FStoreCollectionEditorData, CollectionSubtitle) == 0x000040, "Member 'FStoreCollectionEditorData::CollectionSubtitle' has a wrong offset!");
static_assert(offsetof(FStoreCollectionEditorData, DateUpdated) == 0x000058, "Member 'FStoreCollectionEditorData::DateUpdated' has a wrong offset!");
static_assert(offsetof(FStoreCollectionEditorData, IsEnabled) == 0x000060, "Member 'FStoreCollectionEditorData::IsEnabled' has a wrong offset!");
static_assert(offsetof(FStoreCollectionEditorData, HasLimitedAvailabilityStartDate) == 0x000061, "Member 'FStoreCollectionEditorData::HasLimitedAvailabilityStartDate' has a wrong offset!");
static_assert(offsetof(FStoreCollectionEditorData, LimitedAvailabilityStart) == 0x000068, "Member 'FStoreCollectionEditorData::LimitedAvailabilityStart' has a wrong offset!");
static_assert(offsetof(FStoreCollectionEditorData, HasLimitedAvailabilityEndDate) == 0x000078, "Member 'FStoreCollectionEditorData::HasLimitedAvailabilityEndDate' has a wrong offset!");
static_assert(offsetof(FStoreCollectionEditorData, LimitedAvailabilityEnd) == 0x000080, "Member 'FStoreCollectionEditorData::LimitedAvailabilityEnd' has a wrong offset!");
static_assert(offsetof(FStoreCollectionEditorData, SortOrder) == 0x000090, "Member 'FStoreCollectionEditorData::SortOrder' has a wrong offset!");
static_assert(offsetof(FStoreCollectionEditorData, HeroImage) == 0x000098, "Member 'FStoreCollectionEditorData::HeroImage' has a wrong offset!");
static_assert(offsetof(FStoreCollectionEditorData, HeroVideo) == 0x0000C0, "Member 'FStoreCollectionEditorData::HeroVideo' has a wrong offset!");
static_assert(offsetof(FStoreCollectionEditorData, AdditionalImages) == 0x0000E8, "Member 'FStoreCollectionEditorData::AdditionalImages' has a wrong offset!");
static_assert(offsetof(FStoreCollectionEditorData, Items) == 0x0000F8, "Member 'FStoreCollectionEditorData::Items' has a wrong offset!");

// ScriptStruct DeadByDaylight.StoreCollectionMediaData
// 0x0010 (0x0010 - 0x0000)
struct FStoreCollectionMediaData final
{
public:
	class FString                                 Path;                                              // 0x0000(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStoreCollectionMediaData) == 0x000008, "Wrong alignment on FStoreCollectionMediaData");
static_assert(sizeof(FStoreCollectionMediaData) == 0x000010, "Wrong size on FStoreCollectionMediaData");
static_assert(offsetof(FStoreCollectionMediaData, Path) == 0x000000, "Member 'FStoreCollectionMediaData::Path' has a wrong offset!");

// ScriptStruct DeadByDaylight.StoreCollectionRuntimeData
// 0x0128 (0x0128 - 0x0000)
struct FStoreCollectionRuntimeData final
{
public:
	class FString                                 CollectionId;                                      // 0x0000(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 InclusionVersion;                                  // 0x0010(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              UpdatedDate;                                       // 0x0020(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FString, class FString>            CollectionTitle;                                   // 0x0028(0x0050)(Transient, NativeAccessSpecifierPublic)
	TMap<class FString, class FString>            CollectionSubtitle;                                // 0x0078(0x0050)(Transient, NativeAccessSpecifierPublic)
	struct FDateTime                              LimitedAvailabilityStartDate;                      // 0x00C8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          LimitedAvailabilityStartDate_IsSet;                // 0x00D0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          VisibleBeforeStartDate;                            // 0x00D1(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          VisibleBeforeStartDate_IsSet;                      // 0x00D2(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D3[0x5];                                       // 0x00D3(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              LimitedAvailabilityEndDate;                        // 0x00D8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          LimitedAvailabilityEndDate_IsSet;                  // 0x00E0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          VisibleAfterEndDate;                               // 0x00E1(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          VisibleAfterEndDate_IsSet;                         // 0x00E2(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E3[0x1];                                       // 0x00E3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SortOrder;                                         // 0x00E4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStoreCollectionMediaData              HeroImage;                                         // 0x00E8(0x0010)(Transient, NativeAccessSpecifierPublic)
	struct FStoreCollectionMediaData              HeroVideo;                                         // 0x00F8(0x0010)(Transient, NativeAccessSpecifierPublic)
	TArray<struct FStoreCollectionMediaData>      AdditionalImages;                                  // 0x0108(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<class FString>                         Items;                                             // 0x0118(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStoreCollectionRuntimeData) == 0x000008, "Wrong alignment on FStoreCollectionRuntimeData");
static_assert(sizeof(FStoreCollectionRuntimeData) == 0x000128, "Wrong size on FStoreCollectionRuntimeData");
static_assert(offsetof(FStoreCollectionRuntimeData, CollectionId) == 0x000000, "Member 'FStoreCollectionRuntimeData::CollectionId' has a wrong offset!");
static_assert(offsetof(FStoreCollectionRuntimeData, InclusionVersion) == 0x000010, "Member 'FStoreCollectionRuntimeData::InclusionVersion' has a wrong offset!");
static_assert(offsetof(FStoreCollectionRuntimeData, UpdatedDate) == 0x000020, "Member 'FStoreCollectionRuntimeData::UpdatedDate' has a wrong offset!");
static_assert(offsetof(FStoreCollectionRuntimeData, CollectionTitle) == 0x000028, "Member 'FStoreCollectionRuntimeData::CollectionTitle' has a wrong offset!");
static_assert(offsetof(FStoreCollectionRuntimeData, CollectionSubtitle) == 0x000078, "Member 'FStoreCollectionRuntimeData::CollectionSubtitle' has a wrong offset!");
static_assert(offsetof(FStoreCollectionRuntimeData, LimitedAvailabilityStartDate) == 0x0000C8, "Member 'FStoreCollectionRuntimeData::LimitedAvailabilityStartDate' has a wrong offset!");
static_assert(offsetof(FStoreCollectionRuntimeData, LimitedAvailabilityStartDate_IsSet) == 0x0000D0, "Member 'FStoreCollectionRuntimeData::LimitedAvailabilityStartDate_IsSet' has a wrong offset!");
static_assert(offsetof(FStoreCollectionRuntimeData, VisibleBeforeStartDate) == 0x0000D1, "Member 'FStoreCollectionRuntimeData::VisibleBeforeStartDate' has a wrong offset!");
static_assert(offsetof(FStoreCollectionRuntimeData, VisibleBeforeStartDate_IsSet) == 0x0000D2, "Member 'FStoreCollectionRuntimeData::VisibleBeforeStartDate_IsSet' has a wrong offset!");
static_assert(offsetof(FStoreCollectionRuntimeData, LimitedAvailabilityEndDate) == 0x0000D8, "Member 'FStoreCollectionRuntimeData::LimitedAvailabilityEndDate' has a wrong offset!");
static_assert(offsetof(FStoreCollectionRuntimeData, LimitedAvailabilityEndDate_IsSet) == 0x0000E0, "Member 'FStoreCollectionRuntimeData::LimitedAvailabilityEndDate_IsSet' has a wrong offset!");
static_assert(offsetof(FStoreCollectionRuntimeData, VisibleAfterEndDate) == 0x0000E1, "Member 'FStoreCollectionRuntimeData::VisibleAfterEndDate' has a wrong offset!");
static_assert(offsetof(FStoreCollectionRuntimeData, VisibleAfterEndDate_IsSet) == 0x0000E2, "Member 'FStoreCollectionRuntimeData::VisibleAfterEndDate_IsSet' has a wrong offset!");
static_assert(offsetof(FStoreCollectionRuntimeData, SortOrder) == 0x0000E4, "Member 'FStoreCollectionRuntimeData::SortOrder' has a wrong offset!");
static_assert(offsetof(FStoreCollectionRuntimeData, HeroImage) == 0x0000E8, "Member 'FStoreCollectionRuntimeData::HeroImage' has a wrong offset!");
static_assert(offsetof(FStoreCollectionRuntimeData, HeroVideo) == 0x0000F8, "Member 'FStoreCollectionRuntimeData::HeroVideo' has a wrong offset!");
static_assert(offsetof(FStoreCollectionRuntimeData, AdditionalImages) == 0x000108, "Member 'FStoreCollectionRuntimeData::AdditionalImages' has a wrong offset!");
static_assert(offsetof(FStoreCollectionRuntimeData, Items) == 0x000118, "Member 'FStoreCollectionRuntimeData::Items' has a wrong offset!");

// ScriptStruct DeadByDaylight.StoreFeaturedCharacterEditorData
// 0x0038 (0x0038 - 0x0000)
struct FStoreFeaturedCharacterEditorData final
{
public:
	class FString                                 CharacterIndex;                                    // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        Image;                                             // 0x0010(0x0028)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStoreFeaturedCharacterEditorData) == 0x000008, "Wrong alignment on FStoreFeaturedCharacterEditorData");
static_assert(sizeof(FStoreFeaturedCharacterEditorData) == 0x000038, "Wrong size on FStoreFeaturedCharacterEditorData");
static_assert(offsetof(FStoreFeaturedCharacterEditorData, CharacterIndex) == 0x000000, "Member 'FStoreFeaturedCharacterEditorData::CharacterIndex' has a wrong offset!");
static_assert(offsetof(FStoreFeaturedCharacterEditorData, Image) == 0x000010, "Member 'FStoreFeaturedCharacterEditorData::Image' has a wrong offset!");

// ScriptStruct DeadByDaylight.StoreFeaturedCharacterRecommendationEditorData
// 0x0050 (0x0058 - 0x0008)
struct FStoreFeaturedCharacterRecommendationEditorData final : public FDBDTableRowBase
{
public:
	class FString                                 ID;                                                // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 InclusionVersion;                                  // 0x0018(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              ActiveFrom;                                        // 0x0028(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              ActiveTo;                                          // 0x0030(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FStoreFeaturedCharacterEditorData> Characters;                                        // 0x0038(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x10];                                      // 0x0048(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStoreFeaturedCharacterRecommendationEditorData) == 0x000008, "Wrong alignment on FStoreFeaturedCharacterRecommendationEditorData");
static_assert(sizeof(FStoreFeaturedCharacterRecommendationEditorData) == 0x000058, "Wrong size on FStoreFeaturedCharacterRecommendationEditorData");
static_assert(offsetof(FStoreFeaturedCharacterRecommendationEditorData, ID) == 0x000008, "Member 'FStoreFeaturedCharacterRecommendationEditorData::ID' has a wrong offset!");
static_assert(offsetof(FStoreFeaturedCharacterRecommendationEditorData, InclusionVersion) == 0x000018, "Member 'FStoreFeaturedCharacterRecommendationEditorData::InclusionVersion' has a wrong offset!");
static_assert(offsetof(FStoreFeaturedCharacterRecommendationEditorData, ActiveFrom) == 0x000028, "Member 'FStoreFeaturedCharacterRecommendationEditorData::ActiveFrom' has a wrong offset!");
static_assert(offsetof(FStoreFeaturedCharacterRecommendationEditorData, ActiveTo) == 0x000030, "Member 'FStoreFeaturedCharacterRecommendationEditorData::ActiveTo' has a wrong offset!");
static_assert(offsetof(FStoreFeaturedCharacterRecommendationEditorData, Characters) == 0x000038, "Member 'FStoreFeaturedCharacterRecommendationEditorData::Characters' has a wrong offset!");

// ScriptStruct DeadByDaylight.StoreFeaturedCardRecommendationEntryEditorData
// 0x0038 (0x0038 - 0x0000)
struct FStoreFeaturedCardRecommendationEntryEditorData final
{
public:
	EStoreFeaturedCardRecommendationType          Type;                                              // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ChapterPackId;                                     // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SpecialPackId;                                     // 0x0018(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CrossPromotionId;                                  // 0x0028(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStoreFeaturedCardRecommendationEntryEditorData) == 0x000008, "Wrong alignment on FStoreFeaturedCardRecommendationEntryEditorData");
static_assert(sizeof(FStoreFeaturedCardRecommendationEntryEditorData) == 0x000038, "Wrong size on FStoreFeaturedCardRecommendationEntryEditorData");
static_assert(offsetof(FStoreFeaturedCardRecommendationEntryEditorData, Type) == 0x000000, "Member 'FStoreFeaturedCardRecommendationEntryEditorData::Type' has a wrong offset!");
static_assert(offsetof(FStoreFeaturedCardRecommendationEntryEditorData, ChapterPackId) == 0x000008, "Member 'FStoreFeaturedCardRecommendationEntryEditorData::ChapterPackId' has a wrong offset!");
static_assert(offsetof(FStoreFeaturedCardRecommendationEntryEditorData, SpecialPackId) == 0x000018, "Member 'FStoreFeaturedCardRecommendationEntryEditorData::SpecialPackId' has a wrong offset!");
static_assert(offsetof(FStoreFeaturedCardRecommendationEntryEditorData, CrossPromotionId) == 0x000028, "Member 'FStoreFeaturedCardRecommendationEntryEditorData::CrossPromotionId' has a wrong offset!");

// ScriptStruct DeadByDaylight.StoreFeaturedCardRecommendationEditorData
// 0x0030 (0x0048 - 0x0018)
struct FStoreFeaturedCardRecommendationEditorData final : public FDBDTableRowBaseWithId
{
public:
	class FString                                 InclusionVersion;                                  // 0x0018(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              ActiveFrom;                                        // 0x0028(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              ActiveTo;                                          // 0x0030(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FStoreFeaturedCardRecommendationEntryEditorData> Entries;                                           // 0x0038(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStoreFeaturedCardRecommendationEditorData) == 0x000008, "Wrong alignment on FStoreFeaturedCardRecommendationEditorData");
static_assert(sizeof(FStoreFeaturedCardRecommendationEditorData) == 0x000048, "Wrong size on FStoreFeaturedCardRecommendationEditorData");
static_assert(offsetof(FStoreFeaturedCardRecommendationEditorData, InclusionVersion) == 0x000018, "Member 'FStoreFeaturedCardRecommendationEditorData::InclusionVersion' has a wrong offset!");
static_assert(offsetof(FStoreFeaturedCardRecommendationEditorData, ActiveFrom) == 0x000028, "Member 'FStoreFeaturedCardRecommendationEditorData::ActiveFrom' has a wrong offset!");
static_assert(offsetof(FStoreFeaturedCardRecommendationEditorData, ActiveTo) == 0x000030, "Member 'FStoreFeaturedCardRecommendationEditorData::ActiveTo' has a wrong offset!");
static_assert(offsetof(FStoreFeaturedCardRecommendationEditorData, Entries) == 0x000038, "Member 'FStoreFeaturedCardRecommendationEditorData::Entries' has a wrong offset!");

// ScriptStruct DeadByDaylight.StoreFeaturedCharacterRecommendationData
// 0x0020 (0x0020 - 0x0000)
struct FStoreFeaturedCharacterRecommendationData final
{
public:
	TArray<struct FStoreFeaturedSingleCharacterRecommendationData> Characters;                                        // 0x0000(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	struct FDateTime                              ActiveFrom;                                        // 0x0010(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              ActiveTo;                                          // 0x0018(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStoreFeaturedCharacterRecommendationData) == 0x000008, "Wrong alignment on FStoreFeaturedCharacterRecommendationData");
static_assert(sizeof(FStoreFeaturedCharacterRecommendationData) == 0x000020, "Wrong size on FStoreFeaturedCharacterRecommendationData");
static_assert(offsetof(FStoreFeaturedCharacterRecommendationData, Characters) == 0x000000, "Member 'FStoreFeaturedCharacterRecommendationData::Characters' has a wrong offset!");
static_assert(offsetof(FStoreFeaturedCharacterRecommendationData, ActiveFrom) == 0x000010, "Member 'FStoreFeaturedCharacterRecommendationData::ActiveFrom' has a wrong offset!");
static_assert(offsetof(FStoreFeaturedCharacterRecommendationData, ActiveTo) == 0x000018, "Member 'FStoreFeaturedCharacterRecommendationData::ActiveTo' has a wrong offset!");

// ScriptStruct DeadByDaylight.StoreFeaturedCardRecommendationEntryData
// 0x0018 (0x0018 - 0x0000)
struct FStoreFeaturedCardRecommendationEntryData final
{
public:
	EStoreFeaturedCardRecommendationType          Type;                                              // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 EntryId;                                           // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStoreFeaturedCardRecommendationEntryData) == 0x000008, "Wrong alignment on FStoreFeaturedCardRecommendationEntryData");
static_assert(sizeof(FStoreFeaturedCardRecommendationEntryData) == 0x000018, "Wrong size on FStoreFeaturedCardRecommendationEntryData");
static_assert(offsetof(FStoreFeaturedCardRecommendationEntryData, Type) == 0x000000, "Member 'FStoreFeaturedCardRecommendationEntryData::Type' has a wrong offset!");
static_assert(offsetof(FStoreFeaturedCardRecommendationEntryData, EntryId) == 0x000008, "Member 'FStoreFeaturedCardRecommendationEntryData::EntryId' has a wrong offset!");

// ScriptStruct DeadByDaylight.StoreFeaturedCardRecommendationData
// 0x0040 (0x0040 - 0x0000)
struct FStoreFeaturedCardRecommendationData final
{
public:
	class FString                                 FeaturedCardId;                                    // 0x0000(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 InclusionVersion;                                  // 0x0010(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              ActiveFrom;                                        // 0x0020(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              ActiveTo;                                          // 0x0028(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FStoreFeaturedCardRecommendationEntryData> Entries;                                           // 0x0030(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStoreFeaturedCardRecommendationData) == 0x000008, "Wrong alignment on FStoreFeaturedCardRecommendationData");
static_assert(sizeof(FStoreFeaturedCardRecommendationData) == 0x000040, "Wrong size on FStoreFeaturedCardRecommendationData");
static_assert(offsetof(FStoreFeaturedCardRecommendationData, FeaturedCardId) == 0x000000, "Member 'FStoreFeaturedCardRecommendationData::FeaturedCardId' has a wrong offset!");
static_assert(offsetof(FStoreFeaturedCardRecommendationData, InclusionVersion) == 0x000010, "Member 'FStoreFeaturedCardRecommendationData::InclusionVersion' has a wrong offset!");
static_assert(offsetof(FStoreFeaturedCardRecommendationData, ActiveFrom) == 0x000020, "Member 'FStoreFeaturedCardRecommendationData::ActiveFrom' has a wrong offset!");
static_assert(offsetof(FStoreFeaturedCardRecommendationData, ActiveTo) == 0x000028, "Member 'FStoreFeaturedCardRecommendationData::ActiveTo' has a wrong offset!");
static_assert(offsetof(FStoreFeaturedCardRecommendationData, Entries) == 0x000030, "Member 'FStoreFeaturedCardRecommendationData::Entries' has a wrong offset!");

// ScriptStruct DeadByDaylight.StorefrontStateData
// 0x0001 (0x0001 - 0x0000)
struct FStorefrontStateData final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStorefrontStateData) == 0x000001, "Wrong alignment on FStorefrontStateData");
static_assert(sizeof(FStorefrontStateData) == 0x000001, "Wrong size on FStorefrontStateData");

// ScriptStruct DeadByDaylight.StoreRecommendationRuntimeData
// 0x0058 (0x0058 - 0x0000)
struct FStoreRecommendationRuntimeData final
{
public:
	TArray<struct FStoreRecommendationCustomizationRuntimeData> FeaturedCustomizationRecommendations;              // 0x0000(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<struct FStoreFeaturedCharacterRecommendationData> FeaturedCharacterRecommendations;                  // 0x0010(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<struct FStoreFeaturedChapterPackRecommendationData> FeaturedChapterPackRecommendations;                // 0x0020(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<struct FStoreFeaturedCardRecommendationData> FeaturedCard;                                      // 0x0030(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	bool                                          FeaturedCard_IsSet;                                // 0x0040(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FStoreRecommendationCustomizationRuntimeData> SpecialsRecommendations;                           // 0x0048(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStoreRecommendationRuntimeData) == 0x000008, "Wrong alignment on FStoreRecommendationRuntimeData");
static_assert(sizeof(FStoreRecommendationRuntimeData) == 0x000058, "Wrong size on FStoreRecommendationRuntimeData");
static_assert(offsetof(FStoreRecommendationRuntimeData, FeaturedCustomizationRecommendations) == 0x000000, "Member 'FStoreRecommendationRuntimeData::FeaturedCustomizationRecommendations' has a wrong offset!");
static_assert(offsetof(FStoreRecommendationRuntimeData, FeaturedCharacterRecommendations) == 0x000010, "Member 'FStoreRecommendationRuntimeData::FeaturedCharacterRecommendations' has a wrong offset!");
static_assert(offsetof(FStoreRecommendationRuntimeData, FeaturedChapterPackRecommendations) == 0x000020, "Member 'FStoreRecommendationRuntimeData::FeaturedChapterPackRecommendations' has a wrong offset!");
static_assert(offsetof(FStoreRecommendationRuntimeData, FeaturedCard) == 0x000030, "Member 'FStoreRecommendationRuntimeData::FeaturedCard' has a wrong offset!");
static_assert(offsetof(FStoreRecommendationRuntimeData, FeaturedCard_IsSet) == 0x000040, "Member 'FStoreRecommendationRuntimeData::FeaturedCard_IsSet' has a wrong offset!");
static_assert(offsetof(FStoreRecommendationRuntimeData, SpecialsRecommendations) == 0x000048, "Member 'FStoreRecommendationRuntimeData::SpecialsRecommendations' has a wrong offset!");

// ScriptStruct DeadByDaylight.StoreSpecialPackEditorData
// 0x0120 (0x0128 - 0x0008)
struct FStoreSpecialPackEditorData final : public FDBDTableRowBase
{
public:
	class FString                                 ID;                                                // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Title;                                             // 0x0018(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        Image;                                             // 0x0030(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 InclusionVersion;                                  // 0x0058(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsPurchasable;                                     // 0x0068(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<ECurrencyType>                           AvailableCurrencies;                               // 0x0070(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         Discount;                                          // 0x00C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HiddenIfOwned;                                     // 0x00C4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C5[0x3];                                       // 0x00C5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MinNumberOfUnownedForPurchase;                     // 0x00C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SortOrder;                                         // 0x00CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DLCId;                                             // 0x00D0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FStoreSpecialPackItem>          Content;                                           // 0x00E0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         AvailabilityDates;                                 // 0x00F0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F1[0x7];                                       // 0x00F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              StartDate;                                         // 0x00F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              EndDate;                                           // 0x0100(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStoreSpecialPackImageCompositionEditorData ImageComposition;                                  // 0x0108(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          _isChapterPack;                                    // 0x0110(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_111[0x17];                                     // 0x0111(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStoreSpecialPackEditorData) == 0x000008, "Wrong alignment on FStoreSpecialPackEditorData");
static_assert(sizeof(FStoreSpecialPackEditorData) == 0x000128, "Wrong size on FStoreSpecialPackEditorData");
static_assert(offsetof(FStoreSpecialPackEditorData, ID) == 0x000008, "Member 'FStoreSpecialPackEditorData::ID' has a wrong offset!");
static_assert(offsetof(FStoreSpecialPackEditorData, Title) == 0x000018, "Member 'FStoreSpecialPackEditorData::Title' has a wrong offset!");
static_assert(offsetof(FStoreSpecialPackEditorData, Image) == 0x000030, "Member 'FStoreSpecialPackEditorData::Image' has a wrong offset!");
static_assert(offsetof(FStoreSpecialPackEditorData, InclusionVersion) == 0x000058, "Member 'FStoreSpecialPackEditorData::InclusionVersion' has a wrong offset!");
static_assert(offsetof(FStoreSpecialPackEditorData, IsPurchasable) == 0x000068, "Member 'FStoreSpecialPackEditorData::IsPurchasable' has a wrong offset!");
static_assert(offsetof(FStoreSpecialPackEditorData, AvailableCurrencies) == 0x000070, "Member 'FStoreSpecialPackEditorData::AvailableCurrencies' has a wrong offset!");
static_assert(offsetof(FStoreSpecialPackEditorData, Discount) == 0x0000C0, "Member 'FStoreSpecialPackEditorData::Discount' has a wrong offset!");
static_assert(offsetof(FStoreSpecialPackEditorData, HiddenIfOwned) == 0x0000C4, "Member 'FStoreSpecialPackEditorData::HiddenIfOwned' has a wrong offset!");
static_assert(offsetof(FStoreSpecialPackEditorData, MinNumberOfUnownedForPurchase) == 0x0000C8, "Member 'FStoreSpecialPackEditorData::MinNumberOfUnownedForPurchase' has a wrong offset!");
static_assert(offsetof(FStoreSpecialPackEditorData, SortOrder) == 0x0000CC, "Member 'FStoreSpecialPackEditorData::SortOrder' has a wrong offset!");
static_assert(offsetof(FStoreSpecialPackEditorData, DLCId) == 0x0000D0, "Member 'FStoreSpecialPackEditorData::DLCId' has a wrong offset!");
static_assert(offsetof(FStoreSpecialPackEditorData, Content) == 0x0000E0, "Member 'FStoreSpecialPackEditorData::Content' has a wrong offset!");
static_assert(offsetof(FStoreSpecialPackEditorData, AvailabilityDates) == 0x0000F0, "Member 'FStoreSpecialPackEditorData::AvailabilityDates' has a wrong offset!");
static_assert(offsetof(FStoreSpecialPackEditorData, StartDate) == 0x0000F8, "Member 'FStoreSpecialPackEditorData::StartDate' has a wrong offset!");
static_assert(offsetof(FStoreSpecialPackEditorData, EndDate) == 0x000100, "Member 'FStoreSpecialPackEditorData::EndDate' has a wrong offset!");
static_assert(offsetof(FStoreSpecialPackEditorData, ImageComposition) == 0x000108, "Member 'FStoreSpecialPackEditorData::ImageComposition' has a wrong offset!");
static_assert(offsetof(FStoreSpecialPackEditorData, _isChapterPack) == 0x000110, "Member 'FStoreSpecialPackEditorData::_isChapterPack' has a wrong offset!");

// ScriptStruct DeadByDaylight.StoreSpecialPackImageCompositionData
// 0x000C (0x000C - 0x0000)
struct FStoreSpecialPackImageCompositionData final
{
public:
	bool                                          OverrideDefaults;                                  // 0x0000(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStoreSpecialPackImageType                    Type;                                              // 0x0001(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Type_IsSet;                                        // 0x0002(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x1];                                        // 0x0003(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxItemCount;                                      // 0x0004(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MaxItemCount_IsSet;                                // 0x0008(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStoreSpecialPackImageCompositionData) == 0x000004, "Wrong alignment on FStoreSpecialPackImageCompositionData");
static_assert(sizeof(FStoreSpecialPackImageCompositionData) == 0x00000C, "Wrong size on FStoreSpecialPackImageCompositionData");
static_assert(offsetof(FStoreSpecialPackImageCompositionData, OverrideDefaults) == 0x000000, "Member 'FStoreSpecialPackImageCompositionData::OverrideDefaults' has a wrong offset!");
static_assert(offsetof(FStoreSpecialPackImageCompositionData, Type) == 0x000001, "Member 'FStoreSpecialPackImageCompositionData::Type' has a wrong offset!");
static_assert(offsetof(FStoreSpecialPackImageCompositionData, Type_IsSet) == 0x000002, "Member 'FStoreSpecialPackImageCompositionData::Type_IsSet' has a wrong offset!");
static_assert(offsetof(FStoreSpecialPackImageCompositionData, MaxItemCount) == 0x000004, "Member 'FStoreSpecialPackImageCompositionData::MaxItemCount' has a wrong offset!");
static_assert(offsetof(FStoreSpecialPackImageCompositionData, MaxItemCount_IsSet) == 0x000008, "Member 'FStoreSpecialPackImageCompositionData::MaxItemCount_IsSet' has a wrong offset!");

// ScriptStruct DeadByDaylight.StoreSpecialPackCatalogPrice
// 0x0018 (0x0018 - 0x0000)
struct FStoreSpecialPackCatalogPrice final
{
public:
	class FString                                 CurrencyId;                                        // 0x0000(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        Price;                                             // 0x0010(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStoreSpecialPackCatalogPrice) == 0x000008, "Wrong alignment on FStoreSpecialPackCatalogPrice");
static_assert(sizeof(FStoreSpecialPackCatalogPrice) == 0x000018, "Wrong size on FStoreSpecialPackCatalogPrice");
static_assert(offsetof(FStoreSpecialPackCatalogPrice, CurrencyId) == 0x000000, "Member 'FStoreSpecialPackCatalogPrice::CurrencyId' has a wrong offset!");
static_assert(offsetof(FStoreSpecialPackCatalogPrice, Price) == 0x000010, "Member 'FStoreSpecialPackCatalogPrice::Price' has a wrong offset!");

// ScriptStruct DeadByDaylight.StoreSpecialPackCatalogItemRewardGameSpecificData
// 0x0018 (0x0018 - 0x0000)
struct FStoreSpecialPackCatalogItemRewardGameSpecificData final
{
public:
	class FString                                 Type;                                              // 0x0000(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IncludeInOwnership;                                // 0x0010(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IncludeInPricing;                                  // 0x0011(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasPriorityForPackImageComposition;                // 0x0012(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasPriorityForPackImageComposition_IsSet;          // 0x0013(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStoreSpecialPackCatalogItemRewardGameSpecificData) == 0x000008, "Wrong alignment on FStoreSpecialPackCatalogItemRewardGameSpecificData");
static_assert(sizeof(FStoreSpecialPackCatalogItemRewardGameSpecificData) == 0x000018, "Wrong size on FStoreSpecialPackCatalogItemRewardGameSpecificData");
static_assert(offsetof(FStoreSpecialPackCatalogItemRewardGameSpecificData, Type) == 0x000000, "Member 'FStoreSpecialPackCatalogItemRewardGameSpecificData::Type' has a wrong offset!");
static_assert(offsetof(FStoreSpecialPackCatalogItemRewardGameSpecificData, IncludeInOwnership) == 0x000010, "Member 'FStoreSpecialPackCatalogItemRewardGameSpecificData::IncludeInOwnership' has a wrong offset!");
static_assert(offsetof(FStoreSpecialPackCatalogItemRewardGameSpecificData, IncludeInPricing) == 0x000011, "Member 'FStoreSpecialPackCatalogItemRewardGameSpecificData::IncludeInPricing' has a wrong offset!");
static_assert(offsetof(FStoreSpecialPackCatalogItemRewardGameSpecificData, HasPriorityForPackImageComposition) == 0x000012, "Member 'FStoreSpecialPackCatalogItemRewardGameSpecificData::HasPriorityForPackImageComposition' has a wrong offset!");
static_assert(offsetof(FStoreSpecialPackCatalogItemRewardGameSpecificData, HasPriorityForPackImageComposition_IsSet) == 0x000013, "Member 'FStoreSpecialPackCatalogItemRewardGameSpecificData::HasPriorityForPackImageComposition_IsSet' has a wrong offset!");

// ScriptStruct DeadByDaylight.StoreSpecialPackCatalogItemMetaData
// 0x00D8 (0x00D8 - 0x0000)
struct FStoreSpecialPackCatalogItemMetaData final
{
public:
	TArray<struct FStoreSpecialPackCatalogPrice>  FullPrice;                                         // 0x0000(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	uint32                                        SortOrder;                                         // 0x0010(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ImagePath;                                         // 0x0018(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ImagePath_IsSet;                                   // 0x0028(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, class FString>            SpecialPackTitle;                                  // 0x0030(0x0050)(Transient, NativeAccessSpecifierPublic)
	float                                         Discount;                                          // 0x0080(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HiddenIfOwned;                                     // 0x0084(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_85[0x3];                                       // 0x0085(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MinNumberOfUnownedForPurchase;                     // 0x0088(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              StartDate;                                         // 0x0090(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          StartDate_IsSet;                                   // 0x0098(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              EndDate;                                           // 0x00A0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EndDate_IsSet;                                     // 0x00A8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DLCId;                                             // 0x00B0(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DLCId_IsSet;                                       // 0x00C0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C1[0x3];                                       // 0x00C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FStoreSpecialPackImageCompositionData  ImageComposition;                                  // 0x00C4(0x000C)(Transient, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ImageComposition_IsSet;                            // 0x00D0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D1[0x7];                                       // 0x00D1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStoreSpecialPackCatalogItemMetaData) == 0x000008, "Wrong alignment on FStoreSpecialPackCatalogItemMetaData");
static_assert(sizeof(FStoreSpecialPackCatalogItemMetaData) == 0x0000D8, "Wrong size on FStoreSpecialPackCatalogItemMetaData");
static_assert(offsetof(FStoreSpecialPackCatalogItemMetaData, FullPrice) == 0x000000, "Member 'FStoreSpecialPackCatalogItemMetaData::FullPrice' has a wrong offset!");
static_assert(offsetof(FStoreSpecialPackCatalogItemMetaData, SortOrder) == 0x000010, "Member 'FStoreSpecialPackCatalogItemMetaData::SortOrder' has a wrong offset!");
static_assert(offsetof(FStoreSpecialPackCatalogItemMetaData, ImagePath) == 0x000018, "Member 'FStoreSpecialPackCatalogItemMetaData::ImagePath' has a wrong offset!");
static_assert(offsetof(FStoreSpecialPackCatalogItemMetaData, ImagePath_IsSet) == 0x000028, "Member 'FStoreSpecialPackCatalogItemMetaData::ImagePath_IsSet' has a wrong offset!");
static_assert(offsetof(FStoreSpecialPackCatalogItemMetaData, SpecialPackTitle) == 0x000030, "Member 'FStoreSpecialPackCatalogItemMetaData::SpecialPackTitle' has a wrong offset!");
static_assert(offsetof(FStoreSpecialPackCatalogItemMetaData, Discount) == 0x000080, "Member 'FStoreSpecialPackCatalogItemMetaData::Discount' has a wrong offset!");
static_assert(offsetof(FStoreSpecialPackCatalogItemMetaData, HiddenIfOwned) == 0x000084, "Member 'FStoreSpecialPackCatalogItemMetaData::HiddenIfOwned' has a wrong offset!");
static_assert(offsetof(FStoreSpecialPackCatalogItemMetaData, MinNumberOfUnownedForPurchase) == 0x000088, "Member 'FStoreSpecialPackCatalogItemMetaData::MinNumberOfUnownedForPurchase' has a wrong offset!");
static_assert(offsetof(FStoreSpecialPackCatalogItemMetaData, StartDate) == 0x000090, "Member 'FStoreSpecialPackCatalogItemMetaData::StartDate' has a wrong offset!");
static_assert(offsetof(FStoreSpecialPackCatalogItemMetaData, StartDate_IsSet) == 0x000098, "Member 'FStoreSpecialPackCatalogItemMetaData::StartDate_IsSet' has a wrong offset!");
static_assert(offsetof(FStoreSpecialPackCatalogItemMetaData, EndDate) == 0x0000A0, "Member 'FStoreSpecialPackCatalogItemMetaData::EndDate' has a wrong offset!");
static_assert(offsetof(FStoreSpecialPackCatalogItemMetaData, EndDate_IsSet) == 0x0000A8, "Member 'FStoreSpecialPackCatalogItemMetaData::EndDate_IsSet' has a wrong offset!");
static_assert(offsetof(FStoreSpecialPackCatalogItemMetaData, DLCId) == 0x0000B0, "Member 'FStoreSpecialPackCatalogItemMetaData::DLCId' has a wrong offset!");
static_assert(offsetof(FStoreSpecialPackCatalogItemMetaData, DLCId_IsSet) == 0x0000C0, "Member 'FStoreSpecialPackCatalogItemMetaData::DLCId_IsSet' has a wrong offset!");
static_assert(offsetof(FStoreSpecialPackCatalogItemMetaData, ImageComposition) == 0x0000C4, "Member 'FStoreSpecialPackCatalogItemMetaData::ImageComposition' has a wrong offset!");
static_assert(offsetof(FStoreSpecialPackCatalogItemMetaData, ImageComposition_IsSet) == 0x0000D0, "Member 'FStoreSpecialPackCatalogItemMetaData::ImageComposition_IsSet' has a wrong offset!");

// ScriptStruct DeadByDaylight.StoreTimerFlagData
// 0x0028 (0x0028 - 0x0000)
struct FStoreTimerFlagData final
{
public:
	class FString                                 RemainingTimeLabel;                                // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 RemainingDiscountLabel;                            // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0x8];                                       // 0x0020(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStoreTimerFlagData) == 0x000008, "Wrong alignment on FStoreTimerFlagData");
static_assert(sizeof(FStoreTimerFlagData) == 0x000028, "Wrong size on FStoreTimerFlagData");
static_assert(offsetof(FStoreTimerFlagData, RemainingTimeLabel) == 0x000000, "Member 'FStoreTimerFlagData::RemainingTimeLabel' has a wrong offset!");
static_assert(offsetof(FStoreTimerFlagData, RemainingDiscountLabel) == 0x000010, "Member 'FStoreTimerFlagData::RemainingDiscountLabel' has a wrong offset!");

// ScriptStruct DeadByDaylight.StreamerModePlayerData
// 0x0008 (0x0008 - 0x0000)
struct FStreamerModePlayerData final
{
public:
	bool                                          IsAnonymousMode;                                   // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AnonymousSuffix;                                   // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStreamerModePlayerData) == 0x000004, "Wrong alignment on FStreamerModePlayerData");
static_assert(sizeof(FStreamerModePlayerData) == 0x000008, "Wrong size on FStreamerModePlayerData");
static_assert(offsetof(FStreamerModePlayerData, IsAnonymousMode) == 0x000000, "Member 'FStreamerModePlayerData::IsAnonymousMode' has a wrong offset!");
static_assert(offsetof(FStreamerModePlayerData, AnonymousSuffix) == 0x000004, "Member 'FStreamerModePlayerData::AnonymousSuffix' has a wrong offset!");

// ScriptStruct DeadByDaylight.SubscriptionUIData
// 0x00F0 (0x00F8 - 0x0008)
struct FSubscriptionUIData final : public FDBDTableRowBase
{
public:
	class FText                                   DisplayName;                                       // 0x0008(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0020(0x0018)(Edit, NativeAccessSpecifierPublic)
	TMap<class FName, class FText>                PlatformDetails;                                   // 0x0038(0x0050)(Edit, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              TitleTexture;                                      // 0x0088(0x0038)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              PortraitBorderTexture;                             // 0x00C0(0x0038)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSubscriptionUIData) == 0x000008, "Wrong alignment on FSubscriptionUIData");
static_assert(sizeof(FSubscriptionUIData) == 0x0000F8, "Wrong size on FSubscriptionUIData");
static_assert(offsetof(FSubscriptionUIData, DisplayName) == 0x000008, "Member 'FSubscriptionUIData::DisplayName' has a wrong offset!");
static_assert(offsetof(FSubscriptionUIData, Description) == 0x000020, "Member 'FSubscriptionUIData::Description' has a wrong offset!");
static_assert(offsetof(FSubscriptionUIData, PlatformDetails) == 0x000038, "Member 'FSubscriptionUIData::PlatformDetails' has a wrong offset!");
static_assert(offsetof(FSubscriptionUIData, TitleTexture) == 0x000088, "Member 'FSubscriptionUIData::TitleTexture' has a wrong offset!");
static_assert(offsetof(FSubscriptionUIData, PortraitBorderTexture) == 0x0000C0, "Member 'FSubscriptionUIData::PortraitBorderTexture' has a wrong offset!");

// ScriptStruct DeadByDaylight.SurvivorActivity
// 0x0028 (0x0028 - 0x0000)
struct FSurvivorActivity final
{
public:
	bool                                          ShouldDisplayProgress;                             // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameplayTag>                   TagsAssociatedWithAction;                          // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ActivityType;                                      // 0x0018(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSurvivorActivity) == 0x000008, "Wrong alignment on FSurvivorActivity");
static_assert(sizeof(FSurvivorActivity) == 0x000028, "Wrong size on FSurvivorActivity");
static_assert(offsetof(FSurvivorActivity, ShouldDisplayProgress) == 0x000000, "Member 'FSurvivorActivity::ShouldDisplayProgress' has a wrong offset!");
static_assert(offsetof(FSurvivorActivity, TagsAssociatedWithAction) == 0x000008, "Member 'FSurvivorActivity::TagsAssociatedWithAction' has a wrong offset!");
static_assert(offsetof(FSurvivorActivity, ActivityType) == 0x000018, "Member 'FSurvivorActivity::ActivityType' has a wrong offset!");

// ScriptStruct DeadByDaylight.SurvivorActivityUIRowData
// 0x0048 (0x0050 - 0x0008)
struct FSurvivorActivityUIRowData final : public FDBDTunableRowBase
{
public:
	struct FGameplayTag                           ActivityType;                                      // 0x0008(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UTexture2D>              IconAsset;                                         // 0x0018(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSurvivorActivityUIRowData) == 0x000008, "Wrong alignment on FSurvivorActivityUIRowData");
static_assert(sizeof(FSurvivorActivityUIRowData) == 0x000050, "Wrong size on FSurvivorActivityUIRowData");
static_assert(offsetof(FSurvivorActivityUIRowData, ActivityType) == 0x000008, "Member 'FSurvivorActivityUIRowData::ActivityType' has a wrong offset!");
static_assert(offsetof(FSurvivorActivityUIRowData, IconAsset) == 0x000018, "Member 'FSurvivorActivityUIRowData::IconAsset' has a wrong offset!");

// ScriptStruct DeadByDaylight.SurvivorHookTimer
// 0x0038 (0x0038 - 0x0000)
struct alignas(0x08) FSurvivorHookTimer final
{
public:
	uint8                                         Pad_0[0x38];                                       // 0x0000(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSurvivorHookTimer) == 0x000008, "Wrong alignment on FSurvivorHookTimer");
static_assert(sizeof(FSurvivorHookTimer) == 0x000038, "Wrong size on FSurvivorHookTimer");

// ScriptStruct DeadByDaylight.SurvivorItemDependenciesData
// 0x0048 (0x0050 - 0x0008)
struct FSurvivorItemDependenciesData final : public FDBDTableRowBase
{
public:
	TSoftClassPtr<class UClass>                   SpawnConditionStrategyClass;                       // 0x0008(0x0038)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FKillerItemProperty>            Items;                                             // 0x0040(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSurvivorItemDependenciesData) == 0x000008, "Wrong alignment on FSurvivorItemDependenciesData");
static_assert(sizeof(FSurvivorItemDependenciesData) == 0x000050, "Wrong size on FSurvivorItemDependenciesData");
static_assert(offsetof(FSurvivorItemDependenciesData, SpawnConditionStrategyClass) == 0x000008, "Member 'FSurvivorItemDependenciesData::SpawnConditionStrategyClass' has a wrong offset!");
static_assert(offsetof(FSurvivorItemDependenciesData, Items) == 0x000040, "Member 'FSurvivorItemDependenciesData::Items' has a wrong offset!");

// ScriptStruct DeadByDaylight.SurvivorSleepiness
// 0x0008 (0x0008 - 0x0000)
struct FSurvivorSleepiness final
{
public:
	float                                         _sleepiness;                                       // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _sleepThreshold;                                   // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FSurvivorSleepiness) == 0x000004, "Wrong alignment on FSurvivorSleepiness");
static_assert(sizeof(FSurvivorSleepiness) == 0x000008, "Wrong size on FSurvivorSleepiness");
static_assert(offsetof(FSurvivorSleepiness, _sleepiness) == 0x000000, "Member 'FSurvivorSleepiness::_sleepiness' has a wrong offset!");
static_assert(offsetof(FSurvivorSleepiness, _sleepThreshold) == 0x000004, "Member 'FSurvivorSleepiness::_sleepThreshold' has a wrong offset!");

// ScriptStruct DeadByDaylight.TallyScorePipsData
// 0x0038 (0x0038 - 0x0000)
struct FTallyScorePipsData final
{
public:
	float                                         Threshold;                                         // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 PipThresholds;                                     // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<struct FEmblemSlotData>                Scores;                                            // 0x0018(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	int32                                         PipsDelta;                                         // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsSlasher;                                         // 0x002C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NumChars;                                          // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTallyScorePipsData) == 0x000008, "Wrong alignment on FTallyScorePipsData");
static_assert(sizeof(FTallyScorePipsData) == 0x000038, "Wrong size on FTallyScorePipsData");
static_assert(offsetof(FTallyScorePipsData, Threshold) == 0x000000, "Member 'FTallyScorePipsData::Threshold' has a wrong offset!");
static_assert(offsetof(FTallyScorePipsData, PipThresholds) == 0x000008, "Member 'FTallyScorePipsData::PipThresholds' has a wrong offset!");
static_assert(offsetof(FTallyScorePipsData, Scores) == 0x000018, "Member 'FTallyScorePipsData::Scores' has a wrong offset!");
static_assert(offsetof(FTallyScorePipsData, PipsDelta) == 0x000028, "Member 'FTallyScorePipsData::PipsDelta' has a wrong offset!");
static_assert(offsetof(FTallyScorePipsData, IsSlasher) == 0x00002C, "Member 'FTallyScorePipsData::IsSlasher' has a wrong offset!");
static_assert(offsetof(FTallyScorePipsData, NumChars) == 0x000030, "Member 'FTallyScorePipsData::NumChars' has a wrong offset!");

// ScriptStruct DeadByDaylight.TeachableData
// 0x0168 (0x0168 - 0x0000)
struct FTeachableData final
{
public:
	struct FInventorySlotData                     InventorySlotData;                                 // 0x0000(0x0150)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPublic)
	ETeachableStatus                              Status;                                            // 0x0150(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_151[0x3];                                      // 0x0151(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         UnlockLevel;                                       // 0x0154(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Message;                                           // 0x0158(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTeachableData) == 0x000008, "Wrong alignment on FTeachableData");
static_assert(sizeof(FTeachableData) == 0x000168, "Wrong size on FTeachableData");
static_assert(offsetof(FTeachableData, InventorySlotData) == 0x000000, "Member 'FTeachableData::InventorySlotData' has a wrong offset!");
static_assert(offsetof(FTeachableData, Status) == 0x000150, "Member 'FTeachableData::Status' has a wrong offset!");
static_assert(offsetof(FTeachableData, UnlockLevel) == 0x000154, "Member 'FTeachableData::UnlockLevel' has a wrong offset!");
static_assert(offsetof(FTeachableData, Message) == 0x000158, "Member 'FTeachableData::Message' has a wrong offset!");

// ScriptStruct DeadByDaylight.TileRandomizerData
// 0x0028 (0x0028 - 0x0000)
struct FTileRandomizerData final
{
public:
	class FString                                 Name;                                              // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Minimun;                                           // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Maximun;                                           // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         Elements;                                          // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTileRandomizerData) == 0x000008, "Wrong alignment on FTileRandomizerData");
static_assert(sizeof(FTileRandomizerData) == 0x000028, "Wrong size on FTileRandomizerData");
static_assert(offsetof(FTileRandomizerData, Name) == 0x000000, "Member 'FTileRandomizerData::Name' has a wrong offset!");
static_assert(offsetof(FTileRandomizerData, Minimun) == 0x000010, "Member 'FTileRandomizerData::Minimun' has a wrong offset!");
static_assert(offsetof(FTileRandomizerData, Maximun) == 0x000014, "Member 'FTileRandomizerData::Maximun' has a wrong offset!");
static_assert(offsetof(FTileRandomizerData, Elements) == 0x000018, "Member 'FTileRandomizerData::Elements' has a wrong offset!");

// ScriptStruct DeadByDaylight.TileEventSpawnerSettingData
// 0x0020 (0x0028 - 0x0008)
struct FTileEventSpawnerSettingData final : public FDBDTableRowBase
{
public:
	ETileType                                     TileType;                                          // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsExitGate;                                        // 0x0009(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpawnProbability;                                  // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinBudget;                                         // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxBudget;                                         // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FEventSpawnableSpawnRequirements> SpawnRequirementsPerSize;                          // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTileEventSpawnerSettingData) == 0x000008, "Wrong alignment on FTileEventSpawnerSettingData");
static_assert(sizeof(FTileEventSpawnerSettingData) == 0x000028, "Wrong size on FTileEventSpawnerSettingData");
static_assert(offsetof(FTileEventSpawnerSettingData, TileType) == 0x000008, "Member 'FTileEventSpawnerSettingData::TileType' has a wrong offset!");
static_assert(offsetof(FTileEventSpawnerSettingData, IsExitGate) == 0x000009, "Member 'FTileEventSpawnerSettingData::IsExitGate' has a wrong offset!");
static_assert(offsetof(FTileEventSpawnerSettingData, SpawnProbability) == 0x00000C, "Member 'FTileEventSpawnerSettingData::SpawnProbability' has a wrong offset!");
static_assert(offsetof(FTileEventSpawnerSettingData, MinBudget) == 0x000010, "Member 'FTileEventSpawnerSettingData::MinBudget' has a wrong offset!");
static_assert(offsetof(FTileEventSpawnerSettingData, MaxBudget) == 0x000014, "Member 'FTileEventSpawnerSettingData::MaxBudget' has a wrong offset!");
static_assert(offsetof(FTileEventSpawnerSettingData, SpawnRequirementsPerSize) == 0x000018, "Member 'FTileEventSpawnerSettingData::SpawnRequirementsPerSize' has a wrong offset!");

// ScriptStruct DeadByDaylight.QuadrantInfo
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x08) FQuadrantInfo final
{
public:
	uint8                                         Pad_0[0x28];                                       // 0x0000(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FQuadrantInfo) == 0x000008, "Wrong alignment on FQuadrantInfo");
static_assert(sizeof(FQuadrantInfo) == 0x000028, "Wrong size on FQuadrantInfo");

// ScriptStruct DeadByDaylight.ArrayOfInt32
// 0x0010 (0x0010 - 0x0000)
struct FArrayOfInt32 final
{
public:
	TArray<int32>                                 Value;                                             // 0x0000(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FArrayOfInt32) == 0x000008, "Wrong alignment on FArrayOfInt32");
static_assert(sizeof(FArrayOfInt32) == 0x000010, "Wrong size on FArrayOfInt32");
static_assert(offsetof(FArrayOfInt32, Value) == 0x000000, "Member 'FArrayOfInt32::Value' has a wrong offset!");

// ScriptStruct DeadByDaylight.TransactionEventData
// 0x0088 (0x0088 - 0x0000)
struct FTransactionEventData final
{
public:
	class FString                                 TransactionType;                                   // 0x0000(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TransactionSource;                                 // 0x0010(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SourceID;                                          // 0x0020(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SourceTier;                                        // 0x0030(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CurrencyType;                                      // 0x0038(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrencyAmount;                                    // 0x0048(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrencyBalance;                                   // 0x004C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LevelAchieved;                                     // 0x0050(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Prestige;                                          // 0x0054(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ItemIDAcquired;                                    // 0x0058(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Rank;                                              // 0x0068(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SelectedCharacter;                                 // 0x0070(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TransactionTriggeredLevelUp;                       // 0x0080(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0x7];                                       // 0x0081(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTransactionEventData) == 0x000008, "Wrong alignment on FTransactionEventData");
static_assert(sizeof(FTransactionEventData) == 0x000088, "Wrong size on FTransactionEventData");
static_assert(offsetof(FTransactionEventData, TransactionType) == 0x000000, "Member 'FTransactionEventData::TransactionType' has a wrong offset!");
static_assert(offsetof(FTransactionEventData, TransactionSource) == 0x000010, "Member 'FTransactionEventData::TransactionSource' has a wrong offset!");
static_assert(offsetof(FTransactionEventData, SourceID) == 0x000020, "Member 'FTransactionEventData::SourceID' has a wrong offset!");
static_assert(offsetof(FTransactionEventData, SourceTier) == 0x000030, "Member 'FTransactionEventData::SourceTier' has a wrong offset!");
static_assert(offsetof(FTransactionEventData, CurrencyType) == 0x000038, "Member 'FTransactionEventData::CurrencyType' has a wrong offset!");
static_assert(offsetof(FTransactionEventData, CurrencyAmount) == 0x000048, "Member 'FTransactionEventData::CurrencyAmount' has a wrong offset!");
static_assert(offsetof(FTransactionEventData, CurrencyBalance) == 0x00004C, "Member 'FTransactionEventData::CurrencyBalance' has a wrong offset!");
static_assert(offsetof(FTransactionEventData, LevelAchieved) == 0x000050, "Member 'FTransactionEventData::LevelAchieved' has a wrong offset!");
static_assert(offsetof(FTransactionEventData, Prestige) == 0x000054, "Member 'FTransactionEventData::Prestige' has a wrong offset!");
static_assert(offsetof(FTransactionEventData, ItemIDAcquired) == 0x000058, "Member 'FTransactionEventData::ItemIDAcquired' has a wrong offset!");
static_assert(offsetof(FTransactionEventData, Rank) == 0x000068, "Member 'FTransactionEventData::Rank' has a wrong offset!");
static_assert(offsetof(FTransactionEventData, SelectedCharacter) == 0x000070, "Member 'FTransactionEventData::SelectedCharacter' has a wrong offset!");
static_assert(offsetof(FTransactionEventData, TransactionTriggeredLevelUp) == 0x000080, "Member 'FTransactionEventData::TransactionTriggeredLevelUp' has a wrong offset!");

// ScriptStruct DeadByDaylight.TunableValue
// 0x0018 (0x0020 - 0x0008)
struct FTunableValue final : public FDBDTunableRowBase
{
public:
	float                                         Value;                                             // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Description;                                       // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTunableValue) == 0x000008, "Wrong alignment on FTunableValue");
static_assert(sizeof(FTunableValue) == 0x000020, "Wrong size on FTunableValue");
static_assert(offsetof(FTunableValue, Value) == 0x000008, "Member 'FTunableValue::Value' has a wrong offset!");
static_assert(offsetof(FTunableValue, Description) == 0x000010, "Member 'FTunableValue::Description' has a wrong offset!");

// ScriptStruct DeadByDaylight.PerPlatformTunable
// 0x0018 (0x0020 - 0x0008)
struct FPerPlatformTunable final : public FDBDTableRowBase
{
public:
	struct FPerPlatformFloat                      Value;                                             // 0x0008(0x0004)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Description;                                       // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPerPlatformTunable) == 0x000008, "Wrong alignment on FPerPlatformTunable");
static_assert(sizeof(FPerPlatformTunable) == 0x000020, "Wrong size on FPerPlatformTunable");
static_assert(offsetof(FPerPlatformTunable, Value) == 0x000008, "Member 'FPerPlatformTunable::Value' has a wrong offset!");
static_assert(offsetof(FPerPlatformTunable, Description) == 0x000010, "Member 'FPerPlatformTunable::Description' has a wrong offset!");

// ScriptStruct DeadByDaylight.HtmlTagConvertRow
// 0x0020 (0x0028 - 0x0008)
struct FHtmlTagConvertRow final : public FTableRowBase
{
public:
	class FString                                 HtmlTag;                                           // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 RichTextTag;                                       // 0x0018(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHtmlTagConvertRow) == 0x000008, "Wrong alignment on FHtmlTagConvertRow");
static_assert(sizeof(FHtmlTagConvertRow) == 0x000028, "Wrong size on FHtmlTagConvertRow");
static_assert(offsetof(FHtmlTagConvertRow, HtmlTag) == 0x000008, "Member 'FHtmlTagConvertRow::HtmlTag' has a wrong offset!");
static_assert(offsetof(FHtmlTagConvertRow, RichTextTag) == 0x000018, "Member 'FHtmlTagConvertRow::RichTextTag' has a wrong offset!");

// ScriptStruct DeadByDaylight.InteractButtonInfo
// 0x0448 (0x0450 - 0x0008)
struct FInteractButtonInfo final : public FTableRowBase
{
public:
	class FName                                   InteractButtonID;                                  // 0x0008(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   InteractionID;                                     // 0x0014(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerRole                                   PlayerRole;                                        // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInputInteractionType                         InteractionInputType;                              // 0x0021(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0xE];                                       // 0x0022(0x000E)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            Icon;                                              // 0x0030(0x00D0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	EButtonType                                   CancelButtonType;                                  // 0x0100(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EButtonType                                   SecondaryActionButtonType;                         // 0x0101(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_102[0xE];                                      // 0x0102(0x000E)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            AttackIcon;                                        // 0x0110(0x00D0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSlateBrush                            AbilityIcon;                                       // 0x01E0(0x00D0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSlateBrush                            ThumbJoystickUnpressedIcon;                        // 0x02B0(0x00D0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSlateBrush                            ThumbJoystickPressedIcon;                          // 0x0380(0x00D0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInteractButtonInfo) == 0x000010, "Wrong alignment on FInteractButtonInfo");
static_assert(sizeof(FInteractButtonInfo) == 0x000450, "Wrong size on FInteractButtonInfo");
static_assert(offsetof(FInteractButtonInfo, InteractButtonID) == 0x000008, "Member 'FInteractButtonInfo::InteractButtonID' has a wrong offset!");
static_assert(offsetof(FInteractButtonInfo, InteractionID) == 0x000014, "Member 'FInteractButtonInfo::InteractionID' has a wrong offset!");
static_assert(offsetof(FInteractButtonInfo, PlayerRole) == 0x000020, "Member 'FInteractButtonInfo::PlayerRole' has a wrong offset!");
static_assert(offsetof(FInteractButtonInfo, InteractionInputType) == 0x000021, "Member 'FInteractButtonInfo::InteractionInputType' has a wrong offset!");
static_assert(offsetof(FInteractButtonInfo, Icon) == 0x000030, "Member 'FInteractButtonInfo::Icon' has a wrong offset!");
static_assert(offsetof(FInteractButtonInfo, CancelButtonType) == 0x000100, "Member 'FInteractButtonInfo::CancelButtonType' has a wrong offset!");
static_assert(offsetof(FInteractButtonInfo, SecondaryActionButtonType) == 0x000101, "Member 'FInteractButtonInfo::SecondaryActionButtonType' has a wrong offset!");
static_assert(offsetof(FInteractButtonInfo, AttackIcon) == 0x000110, "Member 'FInteractButtonInfo::AttackIcon' has a wrong offset!");
static_assert(offsetof(FInteractButtonInfo, AbilityIcon) == 0x0001E0, "Member 'FInteractButtonInfo::AbilityIcon' has a wrong offset!");
static_assert(offsetof(FInteractButtonInfo, ThumbJoystickUnpressedIcon) == 0x0002B0, "Member 'FInteractButtonInfo::ThumbJoystickUnpressedIcon' has a wrong offset!");
static_assert(offsetof(FInteractButtonInfo, ThumbJoystickPressedIcon) == 0x000380, "Member 'FInteractButtonInfo::ThumbJoystickPressedIcon' has a wrong offset!");

// ScriptStruct DeadByDaylight.VariationData
// 0x0028 (0x0030 - 0x0008)
struct FVariationData final : public FDBDTableRowBase
{
public:
	struct FGameplayTag                           Tag;                                               // 0x0008(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Name;                                              // 0x0018(0x0018)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVariationData) == 0x000008, "Wrong alignment on FVariationData");
static_assert(sizeof(FVariationData) == 0x000030, "Wrong size on FVariationData");
static_assert(offsetof(FVariationData, Tag) == 0x000008, "Member 'FVariationData::Tag' has a wrong offset!");
static_assert(offsetof(FVariationData, Name) == 0x000018, "Member 'FVariationData::Name' has a wrong offset!");

// ScriptStruct DeadByDaylight.ArchivesVignettes
// 0x0060 (0x0068 - 0x0008)
struct FArchivesVignettes final : public FDBDTableRowBase
{
public:
	class FString                                 VignetteId;                                        // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Title;                                             // 0x0018(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   Subtitle;                                          // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<struct FArchivesVignetteEntry>         Entries;                                           // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UMediaSource>>    CinematicPaths;                                    // 0x0058(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FArchivesVignettes) == 0x000008, "Wrong alignment on FArchivesVignettes");
static_assert(sizeof(FArchivesVignettes) == 0x000068, "Wrong size on FArchivesVignettes");
static_assert(offsetof(FArchivesVignettes, VignetteId) == 0x000008, "Member 'FArchivesVignettes::VignetteId' has a wrong offset!");
static_assert(offsetof(FArchivesVignettes, Title) == 0x000018, "Member 'FArchivesVignettes::Title' has a wrong offset!");
static_assert(offsetof(FArchivesVignettes, Subtitle) == 0x000030, "Member 'FArchivesVignettes::Subtitle' has a wrong offset!");
static_assert(offsetof(FArchivesVignettes, Entries) == 0x000048, "Member 'FArchivesVignettes::Entries' has a wrong offset!");
static_assert(offsetof(FArchivesVignettes, CinematicPaths) == 0x000058, "Member 'FArchivesVignettes::CinematicPaths' has a wrong offset!");

// ScriptStruct DeadByDaylight.ArchivesJournal
// 0x0028 (0x0040 - 0x0018)
struct FArchivesJournal final : public FDBDTableRowBaseWithId
{
public:
	class FText                                   Title;                                             // 0x0018(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<struct FArchivesVignettes>             Vignettes;                                         // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FArchivesJournal) == 0x000008, "Wrong alignment on FArchivesJournal");
static_assert(sizeof(FArchivesJournal) == 0x000040, "Wrong size on FArchivesJournal");
static_assert(offsetof(FArchivesJournal, Title) == 0x000018, "Member 'FArchivesJournal::Title' has a wrong offset!");
static_assert(offsetof(FArchivesJournal, Vignettes) == 0x000030, "Member 'FArchivesJournal::Vignettes' has a wrong offset!");

// ScriptStruct DeadByDaylight.WalesCypherEventData
// 0x0030 (0x0030 - 0x0000)
struct FWalesCypherEventData final
{
public:
	class FString                                 EnteredSequence;                                   // 0x0000(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ExpectedSequence;                                  // 0x0010(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TimeoutThreshold;                                  // 0x0020(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Success;                                           // 0x0024(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TIMEOUT;                                           // 0x0025(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CharmGranted;                                      // 0x0026(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27[0x1];                                       // 0x0027(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ValidCharacterSelcted;                             // 0x0028(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWalesCypherEventData) == 0x000008, "Wrong alignment on FWalesCypherEventData");
static_assert(sizeof(FWalesCypherEventData) == 0x000030, "Wrong size on FWalesCypherEventData");
static_assert(offsetof(FWalesCypherEventData, EnteredSequence) == 0x000000, "Member 'FWalesCypherEventData::EnteredSequence' has a wrong offset!");
static_assert(offsetof(FWalesCypherEventData, ExpectedSequence) == 0x000010, "Member 'FWalesCypherEventData::ExpectedSequence' has a wrong offset!");
static_assert(offsetof(FWalesCypherEventData, TimeoutThreshold) == 0x000020, "Member 'FWalesCypherEventData::TimeoutThreshold' has a wrong offset!");
static_assert(offsetof(FWalesCypherEventData, Success) == 0x000024, "Member 'FWalesCypherEventData::Success' has a wrong offset!");
static_assert(offsetof(FWalesCypherEventData, TIMEOUT) == 0x000025, "Member 'FWalesCypherEventData::TIMEOUT' has a wrong offset!");
static_assert(offsetof(FWalesCypherEventData, CharmGranted) == 0x000026, "Member 'FWalesCypherEventData::CharmGranted' has a wrong offset!");
static_assert(offsetof(FWalesCypherEventData, ValidCharacterSelcted) == 0x000028, "Member 'FWalesCypherEventData::ValidCharacterSelcted' has a wrong offset!");

// ScriptStruct DeadByDaylight.WeightBasedItemData
// 0x0014 (0x0014 - 0x0000)
struct FWeightBasedItemData final
{
public:
	struct FItemIdDropdown                        ItemId;                                            // 0x0000(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWeightBasedItemData) == 0x000004, "Wrong alignment on FWeightBasedItemData");
static_assert(sizeof(FWeightBasedItemData) == 0x000014, "Wrong size on FWeightBasedItemData");
static_assert(offsetof(FWeightBasedItemData, ItemId) == 0x000000, "Member 'FWeightBasedItemData::ItemId' has a wrong offset!");
static_assert(offsetof(FWeightBasedItemData, Weight) == 0x000010, "Member 'FWeightBasedItemData::Weight' has a wrong offset!");

// ScriptStruct DeadByDaylight.VaultData
// 0x0038 (0x0038 - 0x0000)
struct alignas(0x08) FVaultData final
{
public:
	uint8                                         Pad_0[0x38];                                       // 0x0000(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVaultData) == 0x000008, "Wrong alignment on FVaultData");
static_assert(sizeof(FVaultData) == 0x000038, "Wrong size on FVaultData");

// ScriptStruct DeadByDaylight.XpBonusData
// 0x0018 (0x0018 - 0x0000)
struct FXpBonusData final
{
public:
	class FString                                 Name;                                              // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         XpValue;                                           // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FXpBonusData) == 0x000008, "Wrong alignment on FXpBonusData");
static_assert(sizeof(FXpBonusData) == 0x000018, "Wrong size on FXpBonusData");
static_assert(offsetof(FXpBonusData, Name) == 0x000000, "Member 'FXpBonusData::Name' has a wrong offset!");
static_assert(offsetof(FXpBonusData, XpValue) == 0x000010, "Member 'FXpBonusData::XpValue' has a wrong offset!");

}

