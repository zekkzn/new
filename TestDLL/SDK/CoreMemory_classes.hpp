#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: CoreMemory

#include "Basic.hpp"

#include "Engine_classes.hpp"
#include "Archives_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "DataTableUtilities_structs.hpp"
#include "AIModule_structs.hpp"
#include "DeadByDaylight_structs.hpp"
#include "DeadByDaylight_classes.hpp"
#include "GameplayTags_structs.hpp"
#include "CoreMemory_structs.hpp"


namespace SDK
{

// Class CoreMemory.CoreMemoryAtEndTrialCountQEEvaluator
// 0x0000 (0x00A8 - 0x00A8)
class UCoreMemoryAtEndTrialCountQEEvaluator final : public UEndOfGameQEEvaluator
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CoreMemoryAtEndTrialCountQEEvaluator">();
	}
	static class UCoreMemoryAtEndTrialCountQEEvaluator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCoreMemoryAtEndTrialCountQEEvaluator>();
	}
};
static_assert(alignof(UCoreMemoryAtEndTrialCountQEEvaluator) == 0x000008, "Wrong alignment on UCoreMemoryAtEndTrialCountQEEvaluator");
static_assert(sizeof(UCoreMemoryAtEndTrialCountQEEvaluator) == 0x0000A8, "Wrong size on UCoreMemoryAtEndTrialCountQEEvaluator");

// Class CoreMemory.CoreMemoryBehaviourBase
// 0x0000 (0x0030 - 0x0030)
class UCoreMemoryBehaviourBase : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CoreMemoryBehaviourBase">();
	}
	static class UCoreMemoryBehaviourBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCoreMemoryBehaviourBase>();
	}
};
static_assert(alignof(UCoreMemoryBehaviourBase) == 0x000008, "Wrong alignment on UCoreMemoryBehaviourBase");
static_assert(sizeof(UCoreMemoryBehaviourBase) == 0x000030, "Wrong size on UCoreMemoryBehaviourBase");

// Class CoreMemory.CoreMemoryChallengePlayerSpecificController
// 0x0100 (0x03A0 - 0x02A0)
class ACoreMemoryChallengePlayerSpecificController final : public AInfo
{
public:
	uint8                                         Pad_2A0[0xC0];                                     // 0x02A0(0x00C0)(Fixing Size After Last Property [ Dumper-7 ])
	class ADBDPlayer*                             _owningPlayer;                                     // 0x0360(0x0008)(Net, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCoreMemoryController*                  _controller;                                       // 0x0368(0x0008)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UCoreMemoryFragmentComponent*>   _fragments;                                        // 0x0370(0x0010)(ExportObject, Net, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	int32                                         _numFragmentsToCollect;                            // 0x0380(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_384[0xC];                                      // 0x0384(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class ACoreMemoryFragment>> _fragmentsSpawnedBeforeBehavioursWereSetup;        // 0x0390(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	void OnPortalReplicated();
	void OnRep_Controller();
	void StartQuest();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CoreMemoryChallengePlayerSpecificController">();
	}
	static class ACoreMemoryChallengePlayerSpecificController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACoreMemoryChallengePlayerSpecificController>();
	}
};
static_assert(alignof(ACoreMemoryChallengePlayerSpecificController) == 0x000008, "Wrong alignment on ACoreMemoryChallengePlayerSpecificController");
static_assert(sizeof(ACoreMemoryChallengePlayerSpecificController) == 0x0003A0, "Wrong size on ACoreMemoryChallengePlayerSpecificController");
static_assert(offsetof(ACoreMemoryChallengePlayerSpecificController, _owningPlayer) == 0x000360, "Member 'ACoreMemoryChallengePlayerSpecificController::_owningPlayer' has a wrong offset!");
static_assert(offsetof(ACoreMemoryChallengePlayerSpecificController, _controller) == 0x000368, "Member 'ACoreMemoryChallengePlayerSpecificController::_controller' has a wrong offset!");
static_assert(offsetof(ACoreMemoryChallengePlayerSpecificController, _fragments) == 0x000370, "Member 'ACoreMemoryChallengePlayerSpecificController::_fragments' has a wrong offset!");
static_assert(offsetof(ACoreMemoryChallengePlayerSpecificController, _numFragmentsToCollect) == 0x000380, "Member 'ACoreMemoryChallengePlayerSpecificController::_numFragmentsToCollect' has a wrong offset!");
static_assert(offsetof(ACoreMemoryChallengePlayerSpecificController, _fragmentsSpawnedBeforeBehavioursWereSetup) == 0x000390, "Member 'ACoreMemoryChallengePlayerSpecificController::_fragmentsSpawnedBeforeBehavioursWereSetup' has a wrong offset!");

// Class CoreMemory.CoreMemoryController
// 0x0068 (0x0110 - 0x00A8)
class UCoreMemoryController final : public UActorComponent
{
public:
	TArray<class UCoreMemoryBehaviourBase*>       _behaviours;                                       // 0x00A8(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class ACoreMemoryChallengePlayerSpecificController*> _playerSpecificControllers;                        // 0x00B8(0x0010)(Net, ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class FName                                   _archiveSpecialBehaviourId;                        // 0x00C8(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ACoreMemoryPortal>          _coreMemoryPortalClass;                            // 0x00D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoClear, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ACoreMemoryPortal*                      _coreMemoryPortal;                                 // 0x00E0(0x0008)(Net, ZeroConstructor, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E8[0x28];                                      // 0x00E8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_CreatePlayerSpecificController(class ADBDPlayer* Player);
	void Authority_OnCharacterAdded(class ADBDPlayer* Player);
	void OnRep_CoreMemoryPortal();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CoreMemoryController">();
	}
	static class UCoreMemoryController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCoreMemoryController>();
	}
};
static_assert(alignof(UCoreMemoryController) == 0x000008, "Wrong alignment on UCoreMemoryController");
static_assert(sizeof(UCoreMemoryController) == 0x000110, "Wrong size on UCoreMemoryController");
static_assert(offsetof(UCoreMemoryController, _behaviours) == 0x0000A8, "Member 'UCoreMemoryController::_behaviours' has a wrong offset!");
static_assert(offsetof(UCoreMemoryController, _playerSpecificControllers) == 0x0000B8, "Member 'UCoreMemoryController::_playerSpecificControllers' has a wrong offset!");
static_assert(offsetof(UCoreMemoryController, _archiveSpecialBehaviourId) == 0x0000C8, "Member 'UCoreMemoryController::_archiveSpecialBehaviourId' has a wrong offset!");
static_assert(offsetof(UCoreMemoryController, _coreMemoryPortalClass) == 0x0000D8, "Member 'UCoreMemoryController::_coreMemoryPortalClass' has a wrong offset!");
static_assert(offsetof(UCoreMemoryController, _coreMemoryPortal) == 0x0000E0, "Member 'UCoreMemoryController::_coreMemoryPortal' has a wrong offset!");

// Class CoreMemory.CoreMemoryDebugSpawnBehaviour
// 0x0010 (0x0040 - 0x0030)
class UCoreMemoryDebugSpawnBehaviour final : public UCoreMemoryBehaviourBase
{
public:
	TSubclassOf<class ACoreMemoryFragment>        _fragmentClass;                                    // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _numberOfFragmentsToSpawn;                         // 0x0038(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _fragmentSpawnOffset;                              // 0x003C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CoreMemoryDebugSpawnBehaviour">();
	}
	static class UCoreMemoryDebugSpawnBehaviour* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCoreMemoryDebugSpawnBehaviour>();
	}
};
static_assert(alignof(UCoreMemoryDebugSpawnBehaviour) == 0x000008, "Wrong alignment on UCoreMemoryDebugSpawnBehaviour");
static_assert(sizeof(UCoreMemoryDebugSpawnBehaviour) == 0x000040, "Wrong size on UCoreMemoryDebugSpawnBehaviour");
static_assert(offsetof(UCoreMemoryDebugSpawnBehaviour, _fragmentClass) == 0x000030, "Member 'UCoreMemoryDebugSpawnBehaviour::_fragmentClass' has a wrong offset!");
static_assert(offsetof(UCoreMemoryDebugSpawnBehaviour, _numberOfFragmentsToSpawn) == 0x000038, "Member 'UCoreMemoryDebugSpawnBehaviour::_numberOfFragmentsToSpawn' has a wrong offset!");
static_assert(offsetof(UCoreMemoryDebugSpawnBehaviour, _fragmentSpawnOffset) == 0x00003C, "Member 'UCoreMemoryDebugSpawnBehaviour::_fragmentSpawnOffset' has a wrong offset!");

// Class CoreMemory.CoreMemoryDefaultCollectBehaviour
// 0x0078 (0x00A8 - 0x0030)
class UCoreMemoryDefaultCollectBehaviour final : public UCoreMemoryBehaviourBase
{
public:
	struct FDBDTunableRowHandle                   _secondsUncollectibleAfterTriggered;               // 0x0030(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_58[0x50];                                      // 0x0058(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCollectZoneEntered(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CoreMemoryDefaultCollectBehaviour">();
	}
	static class UCoreMemoryDefaultCollectBehaviour* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCoreMemoryDefaultCollectBehaviour>();
	}
};
static_assert(alignof(UCoreMemoryDefaultCollectBehaviour) == 0x000008, "Wrong alignment on UCoreMemoryDefaultCollectBehaviour");
static_assert(sizeof(UCoreMemoryDefaultCollectBehaviour) == 0x0000A8, "Wrong size on UCoreMemoryDefaultCollectBehaviour");
static_assert(offsetof(UCoreMemoryDefaultCollectBehaviour, _secondsUncollectibleAfterTriggered) == 0x000030, "Member 'UCoreMemoryDefaultCollectBehaviour::_secondsUncollectibleAfterTriggered' has a wrong offset!");

// Class CoreMemory.CoreMemoryDefaultQuestProgressBehaviour
// 0x0038 (0x0068 - 0x0030)
class UCoreMemoryDefaultQuestProgressBehaviour final : public UCoreMemoryBehaviourBase
{
public:
	struct FGameplayTag                           _onPlayerExitWithMemoryAcquiredScoreTag;           // 0x0030(0x000C)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTag                           _onFragmentCollectedScoreTag;                      // 0x003C(0x000C)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTag                           _onMemoryAcquiredScoreTag;                         // 0x0048(0x000C)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTag                           _onMemorySynchronizedScoreTag;                     // 0x0054(0x000C)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_60[0x8];                                       // 0x0060(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CoreMemoryDefaultQuestProgressBehaviour">();
	}
	static class UCoreMemoryDefaultQuestProgressBehaviour* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCoreMemoryDefaultQuestProgressBehaviour>();
	}
};
static_assert(alignof(UCoreMemoryDefaultQuestProgressBehaviour) == 0x000008, "Wrong alignment on UCoreMemoryDefaultQuestProgressBehaviour");
static_assert(sizeof(UCoreMemoryDefaultQuestProgressBehaviour) == 0x000068, "Wrong size on UCoreMemoryDefaultQuestProgressBehaviour");
static_assert(offsetof(UCoreMemoryDefaultQuestProgressBehaviour, _onPlayerExitWithMemoryAcquiredScoreTag) == 0x000030, "Member 'UCoreMemoryDefaultQuestProgressBehaviour::_onPlayerExitWithMemoryAcquiredScoreTag' has a wrong offset!");
static_assert(offsetof(UCoreMemoryDefaultQuestProgressBehaviour, _onFragmentCollectedScoreTag) == 0x00003C, "Member 'UCoreMemoryDefaultQuestProgressBehaviour::_onFragmentCollectedScoreTag' has a wrong offset!");
static_assert(offsetof(UCoreMemoryDefaultQuestProgressBehaviour, _onMemoryAcquiredScoreTag) == 0x000048, "Member 'UCoreMemoryDefaultQuestProgressBehaviour::_onMemoryAcquiredScoreTag' has a wrong offset!");
static_assert(offsetof(UCoreMemoryDefaultQuestProgressBehaviour, _onMemorySynchronizedScoreTag) == 0x000054, "Member 'UCoreMemoryDefaultQuestProgressBehaviour::_onMemorySynchronizedScoreTag' has a wrong offset!");

// Class CoreMemory.CoreMemoryDefaultTriggerBehaviour
// 0x00A8 (0x00D8 - 0x0030)
class UCoreMemoryDefaultTriggerBehaviour final : public UCoreMemoryBehaviourBase
{
public:
	float                                         _authority_lineOfSightTimerRate;                   // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _authority_DisableCollisionDetectionAtSpawn;       // 0x0038(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_60[0x78];                                      // 0x0060(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_CheckLineOfSight(const class ACoreMemoryFragment* Fragment);
	void Authority_OnTriggerZoneEntered(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void Authority_OnTriggerZoneExited(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CoreMemoryDefaultTriggerBehaviour">();
	}
	static class UCoreMemoryDefaultTriggerBehaviour* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCoreMemoryDefaultTriggerBehaviour>();
	}
};
static_assert(alignof(UCoreMemoryDefaultTriggerBehaviour) == 0x000008, "Wrong alignment on UCoreMemoryDefaultTriggerBehaviour");
static_assert(sizeof(UCoreMemoryDefaultTriggerBehaviour) == 0x0000D8, "Wrong size on UCoreMemoryDefaultTriggerBehaviour");
static_assert(offsetof(UCoreMemoryDefaultTriggerBehaviour, _authority_lineOfSightTimerRate) == 0x000030, "Member 'UCoreMemoryDefaultTriggerBehaviour::_authority_lineOfSightTimerRate' has a wrong offset!");
static_assert(offsetof(UCoreMemoryDefaultTriggerBehaviour, _authority_DisableCollisionDetectionAtSpawn) == 0x000038, "Member 'UCoreMemoryDefaultTriggerBehaviour::_authority_DisableCollisionDetectionAtSpawn' has a wrong offset!");

// Class CoreMemory.CoreMemoryFragment
// 0x00F8 (0x0398 - 0x02A0)
class ACoreMemoryFragment final : public AActor
{
public:
	uint8                                         Pad_2A0[0x20];                                     // 0x02A0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   _coreMemoryFragmentStaticMesh;                     // 0x02C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoClear, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticMeshComponent*                   _coreMemoryTendrilStaticMesh;                      // 0x02C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoClear, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCoreMemoryFragmentComponent*           _coreMemoryFragmentComponent;                      // 0x02D0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoClear, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCoreMemoryFragmentFXComponent*         _coreMemoryFragmentFXComponent;                    // 0x02D8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoClear, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USphereComponent*                       _coreMemoryFragmentTriggerZone;                    // 0x02E0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoClear, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USphereComponent*                       _coreMemoryFragmentCollectionZone;                 // 0x02E8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoClear, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                _spawnLocation;                                    // 0x02F0(0x0018)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FRotator                               _spawnRotation;                                    // 0x0308(0x0018)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _triggerZoneRadius;                                // 0x0320(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _collectionZoneRadius;                             // 0x0348(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FLinearColor                           _outlineColour;                                    // 0x0370(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDBDOutlineComponent*                   _outlineComponent;                                 // 0x0380(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGameplayTagContainerComponent*         _objectState;                                      // 0x0388(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UActivatorComponent*                    _activator;                                        // 0x0390(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnRep_SpawnLocation(const struct FVector& Location);
	void OnRep_SpawnRotation(const struct FRotator& Rotation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CoreMemoryFragment">();
	}
	static class ACoreMemoryFragment* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACoreMemoryFragment>();
	}
};
static_assert(alignof(ACoreMemoryFragment) == 0x000008, "Wrong alignment on ACoreMemoryFragment");
static_assert(sizeof(ACoreMemoryFragment) == 0x000398, "Wrong size on ACoreMemoryFragment");
static_assert(offsetof(ACoreMemoryFragment, _coreMemoryFragmentStaticMesh) == 0x0002C0, "Member 'ACoreMemoryFragment::_coreMemoryFragmentStaticMesh' has a wrong offset!");
static_assert(offsetof(ACoreMemoryFragment, _coreMemoryTendrilStaticMesh) == 0x0002C8, "Member 'ACoreMemoryFragment::_coreMemoryTendrilStaticMesh' has a wrong offset!");
static_assert(offsetof(ACoreMemoryFragment, _coreMemoryFragmentComponent) == 0x0002D0, "Member 'ACoreMemoryFragment::_coreMemoryFragmentComponent' has a wrong offset!");
static_assert(offsetof(ACoreMemoryFragment, _coreMemoryFragmentFXComponent) == 0x0002D8, "Member 'ACoreMemoryFragment::_coreMemoryFragmentFXComponent' has a wrong offset!");
static_assert(offsetof(ACoreMemoryFragment, _coreMemoryFragmentTriggerZone) == 0x0002E0, "Member 'ACoreMemoryFragment::_coreMemoryFragmentTriggerZone' has a wrong offset!");
static_assert(offsetof(ACoreMemoryFragment, _coreMemoryFragmentCollectionZone) == 0x0002E8, "Member 'ACoreMemoryFragment::_coreMemoryFragmentCollectionZone' has a wrong offset!");
static_assert(offsetof(ACoreMemoryFragment, _spawnLocation) == 0x0002F0, "Member 'ACoreMemoryFragment::_spawnLocation' has a wrong offset!");
static_assert(offsetof(ACoreMemoryFragment, _spawnRotation) == 0x000308, "Member 'ACoreMemoryFragment::_spawnRotation' has a wrong offset!");
static_assert(offsetof(ACoreMemoryFragment, _triggerZoneRadius) == 0x000320, "Member 'ACoreMemoryFragment::_triggerZoneRadius' has a wrong offset!");
static_assert(offsetof(ACoreMemoryFragment, _collectionZoneRadius) == 0x000348, "Member 'ACoreMemoryFragment::_collectionZoneRadius' has a wrong offset!");
static_assert(offsetof(ACoreMemoryFragment, _outlineColour) == 0x000370, "Member 'ACoreMemoryFragment::_outlineColour' has a wrong offset!");
static_assert(offsetof(ACoreMemoryFragment, _outlineComponent) == 0x000380, "Member 'ACoreMemoryFragment::_outlineComponent' has a wrong offset!");
static_assert(offsetof(ACoreMemoryFragment, _objectState) == 0x000388, "Member 'ACoreMemoryFragment::_objectState' has a wrong offset!");
static_assert(offsetof(ACoreMemoryFragment, _activator) == 0x000390, "Member 'ACoreMemoryFragment::_activator' has a wrong offset!");

// Class CoreMemory.CoreMemoryFragmentComponent
// 0x00E0 (0x0188 - 0x00A8)
class UCoreMemoryFragmentComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x60];                                      // 0x00A8(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	class ADBDPlayer*                             _owningPlayer;                                     // 0x0108(0x0008)(Net, ZeroConstructor, Transient, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ACoreMemoryChallengePlayerSpecificController* _controller;                                       // 0x0110(0x0008)(Net, ZeroConstructor, Transient, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_118[0x1];                                      // 0x0118(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _wasTriggered;                                     // 0x0119(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_11A[0x6];                                      // 0x011A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  _killerPreventingTags;                             // 0x0120(0x0020)(Edit, NativeAccessSpecifierPrivate)
	struct FGameplayTagContainer                  _camperPreventingTags;                             // 0x0140(0x0020)(Edit, NativeAccessSpecifierPrivate)
	uint8                                         Pad_160[0x8];                                      // 0x0160(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _isDespawned;                                      // 0x0168(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _wasCollected;                                     // 0x0169(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_16A[0x1E];                                     // 0x016A(0x001E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnLocallyObservedChanged(bool IsLocallyObserved);
	void OnRep_Controller();
	void OnRep_IsDespawned();
	void OnRep_OwningPlayer();
	void OnRep_WasCollected();
	void OnRep_WasTriggered();
	void Server_OnFragmentCollected();

	void Multicast_FragmentDespawnCountdown(float FloatVal) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CoreMemoryFragmentComponent">();
	}
	static class UCoreMemoryFragmentComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCoreMemoryFragmentComponent>();
	}
};
static_assert(alignof(UCoreMemoryFragmentComponent) == 0x000008, "Wrong alignment on UCoreMemoryFragmentComponent");
static_assert(sizeof(UCoreMemoryFragmentComponent) == 0x000188, "Wrong size on UCoreMemoryFragmentComponent");
static_assert(offsetof(UCoreMemoryFragmentComponent, _owningPlayer) == 0x000108, "Member 'UCoreMemoryFragmentComponent::_owningPlayer' has a wrong offset!");
static_assert(offsetof(UCoreMemoryFragmentComponent, _controller) == 0x000110, "Member 'UCoreMemoryFragmentComponent::_controller' has a wrong offset!");
static_assert(offsetof(UCoreMemoryFragmentComponent, _wasTriggered) == 0x000119, "Member 'UCoreMemoryFragmentComponent::_wasTriggered' has a wrong offset!");
static_assert(offsetof(UCoreMemoryFragmentComponent, _killerPreventingTags) == 0x000120, "Member 'UCoreMemoryFragmentComponent::_killerPreventingTags' has a wrong offset!");
static_assert(offsetof(UCoreMemoryFragmentComponent, _camperPreventingTags) == 0x000140, "Member 'UCoreMemoryFragmentComponent::_camperPreventingTags' has a wrong offset!");
static_assert(offsetof(UCoreMemoryFragmentComponent, _isDespawned) == 0x000168, "Member 'UCoreMemoryFragmentComponent::_isDespawned' has a wrong offset!");
static_assert(offsetof(UCoreMemoryFragmentComponent, _wasCollected) == 0x000169, "Member 'UCoreMemoryFragmentComponent::_wasCollected' has a wrong offset!");

// Class CoreMemory.CoreMemoryFragmentDespawnWithTimerBehaviour
// 0x0010 (0x0040 - 0x0030)
class UCoreMemoryFragmentDespawnWithTimerBehaviour : public UCoreMemoryBehaviourBase
{
public:
	float                                         _fragmentPhaseIdleTime;                            // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_34[0xC];                                       // 0x0034(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CoreMemoryFragmentDespawnWithTimerBehaviour">();
	}
	static class UCoreMemoryFragmentDespawnWithTimerBehaviour* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCoreMemoryFragmentDespawnWithTimerBehaviour>();
	}
};
static_assert(alignof(UCoreMemoryFragmentDespawnWithTimerBehaviour) == 0x000008, "Wrong alignment on UCoreMemoryFragmentDespawnWithTimerBehaviour");
static_assert(sizeof(UCoreMemoryFragmentDespawnWithTimerBehaviour) == 0x000040, "Wrong size on UCoreMemoryFragmentDespawnWithTimerBehaviour");
static_assert(offsetof(UCoreMemoryFragmentDespawnWithTimerBehaviour, _fragmentPhaseIdleTime) == 0x000030, "Member 'UCoreMemoryFragmentDespawnWithTimerBehaviour::_fragmentPhaseIdleTime' has a wrong offset!");

// Class CoreMemory.CoreMemoryFragmentDespawnWithTimerOnStateTagModifiedBehaviour
// 0x0048 (0x0088 - 0x0040)
class UCoreMemoryFragmentDespawnWithTimerOnStateTagModifiedBehaviour final : public UCoreMemoryFragmentDespawnWithTimerBehaviour
{
public:
	struct FGameplayTagContainer                  _tagsToTrackToStartPhase;                          // 0x0040(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_60[0x28];                                      // 0x0060(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CoreMemoryFragmentDespawnWithTimerOnStateTagModifiedBehaviour">();
	}
	static class UCoreMemoryFragmentDespawnWithTimerOnStateTagModifiedBehaviour* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCoreMemoryFragmentDespawnWithTimerOnStateTagModifiedBehaviour>();
	}
};
static_assert(alignof(UCoreMemoryFragmentDespawnWithTimerOnStateTagModifiedBehaviour) == 0x000008, "Wrong alignment on UCoreMemoryFragmentDespawnWithTimerOnStateTagModifiedBehaviour");
static_assert(sizeof(UCoreMemoryFragmentDespawnWithTimerOnStateTagModifiedBehaviour) == 0x000088, "Wrong size on UCoreMemoryFragmentDespawnWithTimerOnStateTagModifiedBehaviour");
static_assert(offsetof(UCoreMemoryFragmentDespawnWithTimerOnStateTagModifiedBehaviour, _tagsToTrackToStartPhase) == 0x000040, "Member 'UCoreMemoryFragmentDespawnWithTimerOnStateTagModifiedBehaviour::_tagsToTrackToStartPhase' has a wrong offset!");

// Class CoreMemory.CoreMemoryFragmentFXComponent
// 0x0088 (0x0130 - 0x00A8)
class UCoreMemoryFragmentFXComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             Cosmetic_FragmentTriggered;                        // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             Cosmetic_FragmentSpawned;                          // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             Cosmetic_FragmentDespawn;                          // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             Cosmetic_FragmentCollected;                        // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FRotator                               _tendrilMeshRotationOffset;                        // 0x00E8(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	float                                         _hoverHeight;                                      // 0x0100(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_104[0x1C];                                     // 0x0104(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             Cosmetic_FragmentDespawnCountingDown;              // 0x0120(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CoreMemoryFragmentFXComponent">();
	}
	static class UCoreMemoryFragmentFXComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCoreMemoryFragmentFXComponent>();
	}
};
static_assert(alignof(UCoreMemoryFragmentFXComponent) == 0x000008, "Wrong alignment on UCoreMemoryFragmentFXComponent");
static_assert(sizeof(UCoreMemoryFragmentFXComponent) == 0x000130, "Wrong size on UCoreMemoryFragmentFXComponent");
static_assert(offsetof(UCoreMemoryFragmentFXComponent, Cosmetic_FragmentTriggered) == 0x0000A8, "Member 'UCoreMemoryFragmentFXComponent::Cosmetic_FragmentTriggered' has a wrong offset!");
static_assert(offsetof(UCoreMemoryFragmentFXComponent, Cosmetic_FragmentSpawned) == 0x0000B8, "Member 'UCoreMemoryFragmentFXComponent::Cosmetic_FragmentSpawned' has a wrong offset!");
static_assert(offsetof(UCoreMemoryFragmentFXComponent, Cosmetic_FragmentDespawn) == 0x0000C8, "Member 'UCoreMemoryFragmentFXComponent::Cosmetic_FragmentDespawn' has a wrong offset!");
static_assert(offsetof(UCoreMemoryFragmentFXComponent, Cosmetic_FragmentCollected) == 0x0000D8, "Member 'UCoreMemoryFragmentFXComponent::Cosmetic_FragmentCollected' has a wrong offset!");
static_assert(offsetof(UCoreMemoryFragmentFXComponent, _tendrilMeshRotationOffset) == 0x0000E8, "Member 'UCoreMemoryFragmentFXComponent::_tendrilMeshRotationOffset' has a wrong offset!");
static_assert(offsetof(UCoreMemoryFragmentFXComponent, _hoverHeight) == 0x000100, "Member 'UCoreMemoryFragmentFXComponent::_hoverHeight' has a wrong offset!");
static_assert(offsetof(UCoreMemoryFragmentFXComponent, Cosmetic_FragmentDespawnCountingDown) == 0x000120, "Member 'UCoreMemoryFragmentFXComponent::Cosmetic_FragmentDespawnCountingDown' has a wrong offset!");

// Class CoreMemory.CoreMemoryFragmentMoveUncollectibleBehaviour
// 0x0058 (0x0088 - 0x0030)
class UCoreMemoryFragmentMoveUncollectibleBehaviour final : public UCoreMemoryBehaviourBase
{
public:
	uint8                                         Pad_30[0x50];                                      // 0x0030(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _maxLineOfSightTries;                              // 0x0080(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_84[0x4];                                       // 0x0084(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CoreMemoryFragmentMoveUncollectibleBehaviour">();
	}
	static class UCoreMemoryFragmentMoveUncollectibleBehaviour* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCoreMemoryFragmentMoveUncollectibleBehaviour>();
	}
};
static_assert(alignof(UCoreMemoryFragmentMoveUncollectibleBehaviour) == 0x000008, "Wrong alignment on UCoreMemoryFragmentMoveUncollectibleBehaviour");
static_assert(sizeof(UCoreMemoryFragmentMoveUncollectibleBehaviour) == 0x000088, "Wrong size on UCoreMemoryFragmentMoveUncollectibleBehaviour");
static_assert(offsetof(UCoreMemoryFragmentMoveUncollectibleBehaviour, _maxLineOfSightTries) == 0x000080, "Member 'UCoreMemoryFragmentMoveUncollectibleBehaviour::_maxLineOfSightTries' has a wrong offset!");

// Class CoreMemory.CoreMemoryFragmentMoveUnpredictableBehaviour
// 0x0048 (0x0078 - 0x0030)
class UCoreMemoryFragmentMoveUnpredictableBehaviour final : public UCoreMemoryBehaviourBase
{
public:
	uint8                                         Pad_30[0x48];                                      // 0x0030(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CoreMemoryFragmentMoveUnpredictableBehaviour">();
	}
	static class UCoreMemoryFragmentMoveUnpredictableBehaviour* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCoreMemoryFragmentMoveUnpredictableBehaviour>();
	}
};
static_assert(alignof(UCoreMemoryFragmentMoveUnpredictableBehaviour) == 0x000008, "Wrong alignment on UCoreMemoryFragmentMoveUnpredictableBehaviour");
static_assert(sizeof(UCoreMemoryFragmentMoveUnpredictableBehaviour) == 0x000078, "Wrong size on UCoreMemoryFragmentMoveUnpredictableBehaviour");

// Class CoreMemory.CoreMemoryFragmentNavAgentComponent
// 0x0008 (0x00B0 - 0x00A8)
class UCoreMemoryFragmentNavAgentComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CoreMemoryFragmentNavAgentComponent">();
	}
	static class UCoreMemoryFragmentNavAgentComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCoreMemoryFragmentNavAgentComponent>();
	}
};
static_assert(alignof(UCoreMemoryFragmentNavAgentComponent) == 0x000008, "Wrong alignment on UCoreMemoryFragmentNavAgentComponent");
static_assert(sizeof(UCoreMemoryFragmentNavAgentComponent) == 0x0000B0, "Wrong size on UCoreMemoryFragmentNavAgentComponent");

// Class CoreMemory.CoreMemoryFragmentOutlineUpdateStrategy
// 0x0000 (0x00F0 - 0x00F0)
class UCoreMemoryFragmentOutlineUpdateStrategy : public UDefaultOutlineUpdateStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CoreMemoryFragmentOutlineUpdateStrategy">();
	}
	static class UCoreMemoryFragmentOutlineUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCoreMemoryFragmentOutlineUpdateStrategy>();
	}
};
static_assert(alignof(UCoreMemoryFragmentOutlineUpdateStrategy) == 0x000008, "Wrong alignment on UCoreMemoryFragmentOutlineUpdateStrategy");
static_assert(sizeof(UCoreMemoryFragmentOutlineUpdateStrategy) == 0x0000F0, "Wrong size on UCoreMemoryFragmentOutlineUpdateStrategy");

// Class CoreMemory.CoreMemoryFragmentNotCollectedOutlineUpdateStrategy
// 0x0000 (0x00F0 - 0x00F0)
class UCoreMemoryFragmentNotCollectedOutlineUpdateStrategy : public UCoreMemoryFragmentOutlineUpdateStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CoreMemoryFragmentNotCollectedOutlineUpdateStrategy">();
	}
	static class UCoreMemoryFragmentNotCollectedOutlineUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCoreMemoryFragmentNotCollectedOutlineUpdateStrategy>();
	}
};
static_assert(alignof(UCoreMemoryFragmentNotCollectedOutlineUpdateStrategy) == 0x000008, "Wrong alignment on UCoreMemoryFragmentNotCollectedOutlineUpdateStrategy");
static_assert(sizeof(UCoreMemoryFragmentNotCollectedOutlineUpdateStrategy) == 0x0000F0, "Wrong size on UCoreMemoryFragmentNotCollectedOutlineUpdateStrategy");

// Class CoreMemory.CoreMemoryFragmentNotCollectedWithinRangeOutlineUpdateStrategy
// 0x0008 (0x00F8 - 0x00F0)
class UCoreMemoryFragmentNotCollectedWithinRangeOutlineUpdateStrategy final : public UCoreMemoryFragmentNotCollectedOutlineUpdateStrategy
{
public:
	float                                         _auraDisplayedRange;                               // 0x00F0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F4[0x4];                                       // 0x00F4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CoreMemoryFragmentNotCollectedWithinRangeOutlineUpdateStrategy">();
	}
	static class UCoreMemoryFragmentNotCollectedWithinRangeOutlineUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCoreMemoryFragmentNotCollectedWithinRangeOutlineUpdateStrategy>();
	}
};
static_assert(alignof(UCoreMemoryFragmentNotCollectedWithinRangeOutlineUpdateStrategy) == 0x000008, "Wrong alignment on UCoreMemoryFragmentNotCollectedWithinRangeOutlineUpdateStrategy");
static_assert(sizeof(UCoreMemoryFragmentNotCollectedWithinRangeOutlineUpdateStrategy) == 0x0000F8, "Wrong size on UCoreMemoryFragmentNotCollectedWithinRangeOutlineUpdateStrategy");
static_assert(offsetof(UCoreMemoryFragmentNotCollectedWithinRangeOutlineUpdateStrategy, _auraDisplayedRange) == 0x0000F0, "Member 'UCoreMemoryFragmentNotCollectedWithinRangeOutlineUpdateStrategy::_auraDisplayedRange' has a wrong offset!");

// Class CoreMemory.CoreMemoryFragmentNotTriggeredOutlineUpdateStrategy
// 0x0000 (0x00F0 - 0x00F0)
class UCoreMemoryFragmentNotTriggeredOutlineUpdateStrategy final : public UCoreMemoryFragmentOutlineUpdateStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CoreMemoryFragmentNotTriggeredOutlineUpdateStrategy">();
	}
	static class UCoreMemoryFragmentNotTriggeredOutlineUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCoreMemoryFragmentNotTriggeredOutlineUpdateStrategy>();
	}
};
static_assert(alignof(UCoreMemoryFragmentNotTriggeredOutlineUpdateStrategy) == 0x000008, "Wrong alignment on UCoreMemoryFragmentNotTriggeredOutlineUpdateStrategy");
static_assert(sizeof(UCoreMemoryFragmentNotTriggeredOutlineUpdateStrategy) == 0x0000F0, "Wrong size on UCoreMemoryFragmentNotTriggeredOutlineUpdateStrategy");

// Class CoreMemory.CoreMemoryFragmentSimpleMovementComponent
// 0x0050 (0x00F8 - 0x00A8)
class UCoreMemoryFragmentSimpleMovementComponent final : public UActorComponent
{
public:
	class FName                                   _characterBoneName;                                // 0x00A8(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B4[0xC];                                       // 0x00B4(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _fragmentMoveSpeed;                                // 0x00C0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _speedCurve;                                       // 0x00E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F0[0x8];                                       // 0x00F0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CoreMemoryFragmentSimpleMovementComponent">();
	}
	static class UCoreMemoryFragmentSimpleMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCoreMemoryFragmentSimpleMovementComponent>();
	}
};
static_assert(alignof(UCoreMemoryFragmentSimpleMovementComponent) == 0x000008, "Wrong alignment on UCoreMemoryFragmentSimpleMovementComponent");
static_assert(sizeof(UCoreMemoryFragmentSimpleMovementComponent) == 0x0000F8, "Wrong size on UCoreMemoryFragmentSimpleMovementComponent");
static_assert(offsetof(UCoreMemoryFragmentSimpleMovementComponent, _characterBoneName) == 0x0000A8, "Member 'UCoreMemoryFragmentSimpleMovementComponent::_characterBoneName' has a wrong offset!");
static_assert(offsetof(UCoreMemoryFragmentSimpleMovementComponent, _fragmentMoveSpeed) == 0x0000C0, "Member 'UCoreMemoryFragmentSimpleMovementComponent::_fragmentMoveSpeed' has a wrong offset!");
static_assert(offsetof(UCoreMemoryFragmentSimpleMovementComponent, _speedCurve) == 0x0000E8, "Member 'UCoreMemoryFragmentSimpleMovementComponent::_speedCurve' has a wrong offset!");

// Class CoreMemory.CoreMemoryFragmentToPositionMovementComponent
// 0x0070 (0x0118 - 0x00A8)
class UCoreMemoryFragmentToPositionMovementComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x48];                                      // 0x00A8(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _fragmentMoveSpeed;                                // 0x00F0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CoreMemoryFragmentToPositionMovementComponent">();
	}
	static class UCoreMemoryFragmentToPositionMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCoreMemoryFragmentToPositionMovementComponent>();
	}
};
static_assert(alignof(UCoreMemoryFragmentToPositionMovementComponent) == 0x000008, "Wrong alignment on UCoreMemoryFragmentToPositionMovementComponent");
static_assert(sizeof(UCoreMemoryFragmentToPositionMovementComponent) == 0x000118, "Wrong size on UCoreMemoryFragmentToPositionMovementComponent");
static_assert(offsetof(UCoreMemoryFragmentToPositionMovementComponent, _fragmentMoveSpeed) == 0x0000F0, "Member 'UCoreMemoryFragmentToPositionMovementComponent::_fragmentMoveSpeed' has a wrong offset!");

// Class CoreMemory.CoreMemoryImposeStatusEffectBehaviour
// 0x00E0 (0x0110 - 0x0030)
class UCoreMemoryImposeStatusEffectBehaviour final : public UCoreMemoryBehaviourBase
{
public:
	uint8                                         Pad_30[0x18];                                      // 0x0030(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCoreMemoryStatusEffectDetails         _statusEffectToImposeOnFragmentCollected;          // 0x0048(0x0030)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FCoreMemoryStatusEffectDetails         _statusEffectToImposeOnMemoryAcquired;             // 0x0078(0x0030)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FCoreMemoryStatusEffectDetails         _statusEffectToImposeOnStartedSynchronizingMemory; // 0x00A8(0x0030)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FCoreMemoryStatusEffectDetails         _statusEffectToImposeOnMemorySynchronized;         // 0x00D8(0x0030)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	bool                                          _shouldUseSameEffectForLastFragment;               // 0x0108(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_109[0x7];                                      // 0x0109(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CoreMemoryImposeStatusEffectBehaviour">();
	}
	static class UCoreMemoryImposeStatusEffectBehaviour* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCoreMemoryImposeStatusEffectBehaviour>();
	}
};
static_assert(alignof(UCoreMemoryImposeStatusEffectBehaviour) == 0x000008, "Wrong alignment on UCoreMemoryImposeStatusEffectBehaviour");
static_assert(sizeof(UCoreMemoryImposeStatusEffectBehaviour) == 0x000110, "Wrong size on UCoreMemoryImposeStatusEffectBehaviour");
static_assert(offsetof(UCoreMemoryImposeStatusEffectBehaviour, _statusEffectToImposeOnFragmentCollected) == 0x000048, "Member 'UCoreMemoryImposeStatusEffectBehaviour::_statusEffectToImposeOnFragmentCollected' has a wrong offset!");
static_assert(offsetof(UCoreMemoryImposeStatusEffectBehaviour, _statusEffectToImposeOnMemoryAcquired) == 0x000078, "Member 'UCoreMemoryImposeStatusEffectBehaviour::_statusEffectToImposeOnMemoryAcquired' has a wrong offset!");
static_assert(offsetof(UCoreMemoryImposeStatusEffectBehaviour, _statusEffectToImposeOnStartedSynchronizingMemory) == 0x0000A8, "Member 'UCoreMemoryImposeStatusEffectBehaviour::_statusEffectToImposeOnStartedSynchronizingMemory' has a wrong offset!");
static_assert(offsetof(UCoreMemoryImposeStatusEffectBehaviour, _statusEffectToImposeOnMemorySynchronized) == 0x0000D8, "Member 'UCoreMemoryImposeStatusEffectBehaviour::_statusEffectToImposeOnMemorySynchronized' has a wrong offset!");
static_assert(offsetof(UCoreMemoryImposeStatusEffectBehaviour, _shouldUseSameEffectForLastFragment) == 0x000108, "Member 'UCoreMemoryImposeStatusEffectBehaviour::_shouldUseSameEffectForLastFragment' has a wrong offset!");

// Class CoreMemory.CoreMemoryNavMovementComponent
// 0x00A0 (0x0228 - 0x0188)
class UCoreMemoryNavMovementComponent final : public UActorNavMovementComponent
{
public:
	struct FAIMoveRequest                         _moveRequest;                                      // 0x0188(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TSubclassOf<class UNavigationQueryFilter>     _navFilter;                                        // 0x01D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _movementAcceptanceRadius;                         // 0x01E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1E4[0x4];                                      // 0x01E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _fragmentMoveSpeed;                                // 0x01E8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class UCoreMemoryFragmentNavAgentComponent*   _navAgentComponent;                                // 0x0210(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_218[0x10];                                     // 0x0218(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CoreMemoryNavMovementComponent">();
	}
	static class UCoreMemoryNavMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCoreMemoryNavMovementComponent>();
	}
};
static_assert(alignof(UCoreMemoryNavMovementComponent) == 0x000008, "Wrong alignment on UCoreMemoryNavMovementComponent");
static_assert(sizeof(UCoreMemoryNavMovementComponent) == 0x000228, "Wrong size on UCoreMemoryNavMovementComponent");
static_assert(offsetof(UCoreMemoryNavMovementComponent, _moveRequest) == 0x000188, "Member 'UCoreMemoryNavMovementComponent::_moveRequest' has a wrong offset!");
static_assert(offsetof(UCoreMemoryNavMovementComponent, _navFilter) == 0x0001D8, "Member 'UCoreMemoryNavMovementComponent::_navFilter' has a wrong offset!");
static_assert(offsetof(UCoreMemoryNavMovementComponent, _movementAcceptanceRadius) == 0x0001E0, "Member 'UCoreMemoryNavMovementComponent::_movementAcceptanceRadius' has a wrong offset!");
static_assert(offsetof(UCoreMemoryNavMovementComponent, _fragmentMoveSpeed) == 0x0001E8, "Member 'UCoreMemoryNavMovementComponent::_fragmentMoveSpeed' has a wrong offset!");
static_assert(offsetof(UCoreMemoryNavMovementComponent, _navAgentComponent) == 0x000210, "Member 'UCoreMemoryNavMovementComponent::_navAgentComponent' has a wrong offset!");

// Class CoreMemory.CoreMemoryNavToLocationMovementComponent
// 0x00A8 (0x0230 - 0x0188)
class UCoreMemoryNavToLocationMovementComponent final : public UActorNavMovementComponent
{
public:
	uint8                                         Pad_188[0x18];                                     // 0x0188(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAIMoveRequest                         _moveRequest;                                      // 0x01A0(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TSubclassOf<class UNavigationQueryFilter>     _navFilter;                                        // 0x01F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _movementAcceptanceRadius;                         // 0x01F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1FC[0x4];                                      // 0x01FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCoreMemoryFragmentNavAgentComponent*   _navAgentComponent;                                // 0x0200(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_208[0x28];                                     // 0x0208(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CoreMemoryNavToLocationMovementComponent">();
	}
	static class UCoreMemoryNavToLocationMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCoreMemoryNavToLocationMovementComponent>();
	}
};
static_assert(alignof(UCoreMemoryNavToLocationMovementComponent) == 0x000008, "Wrong alignment on UCoreMemoryNavToLocationMovementComponent");
static_assert(sizeof(UCoreMemoryNavToLocationMovementComponent) == 0x000230, "Wrong size on UCoreMemoryNavToLocationMovementComponent");
static_assert(offsetof(UCoreMemoryNavToLocationMovementComponent, _moveRequest) == 0x0001A0, "Member 'UCoreMemoryNavToLocationMovementComponent::_moveRequest' has a wrong offset!");
static_assert(offsetof(UCoreMemoryNavToLocationMovementComponent, _navFilter) == 0x0001F0, "Member 'UCoreMemoryNavToLocationMovementComponent::_navFilter' has a wrong offset!");
static_assert(offsetof(UCoreMemoryNavToLocationMovementComponent, _movementAcceptanceRadius) == 0x0001F8, "Member 'UCoreMemoryNavToLocationMovementComponent::_movementAcceptanceRadius' has a wrong offset!");
static_assert(offsetof(UCoreMemoryNavToLocationMovementComponent, _navAgentComponent) == 0x000200, "Member 'UCoreMemoryNavToLocationMovementComponent::_navAgentComponent' has a wrong offset!");

// Class CoreMemory.CoreMemoryPortal
// 0x00B0 (0x0498 - 0x03E8)
class ACoreMemoryPortal final : public ASpecialBehaviourInteractable
{
public:
	uint8                                         Pad_3E8[0x18];                                     // 0x03E8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   _coreMemoryPortalStaticMesh;                       // 0x0400(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoClear, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCoreMemoryPortalComponent*             _coreMemoryPortalComponent;                        // 0x0408(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoClear, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCoreMemoryPortalFXComponent*           _coreMemoryPortalFXComponent;                      // 0x0410(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoClear, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInteractor*                            _synchronizeCoreMemoryInteractor;                  // 0x0418(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoClear, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USynchronizeCoreMemoryInteraction*      _synchronizeCoreMemoryInteraction;                 // 0x0420(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoClear, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USynchronizeCoreMemoryInteraction*      _synchronizeCoreMemoryInteractionKiller;           // 0x0428(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoClear, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UChargeableComponent*                   _synchronizeCoreMemoryInteractionChargeable;       // 0x0430(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoClear, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UChargeableComponent*                   _synchronizeCoreMemoryInteractionChargeableKiller; // 0x0438(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoClear, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPrimitiveComponent*                    _synchronizeCoreMemoryInteractionZone;             // 0x0440(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoClear, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _synchronizeCoreMemoryInteractionSecondsToCharge;  // 0x0448(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _synchronizeCoreMemoryInteractionSecondsToChargeKiller; // 0x0470(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	void OnInteractionStarted(class ADBDPlayer* Player);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CoreMemoryPortal">();
	}
	static class ACoreMemoryPortal* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACoreMemoryPortal>();
	}
};
static_assert(alignof(ACoreMemoryPortal) == 0x000008, "Wrong alignment on ACoreMemoryPortal");
static_assert(sizeof(ACoreMemoryPortal) == 0x000498, "Wrong size on ACoreMemoryPortal");
static_assert(offsetof(ACoreMemoryPortal, _coreMemoryPortalStaticMesh) == 0x000400, "Member 'ACoreMemoryPortal::_coreMemoryPortalStaticMesh' has a wrong offset!");
static_assert(offsetof(ACoreMemoryPortal, _coreMemoryPortalComponent) == 0x000408, "Member 'ACoreMemoryPortal::_coreMemoryPortalComponent' has a wrong offset!");
static_assert(offsetof(ACoreMemoryPortal, _coreMemoryPortalFXComponent) == 0x000410, "Member 'ACoreMemoryPortal::_coreMemoryPortalFXComponent' has a wrong offset!");
static_assert(offsetof(ACoreMemoryPortal, _synchronizeCoreMemoryInteractor) == 0x000418, "Member 'ACoreMemoryPortal::_synchronizeCoreMemoryInteractor' has a wrong offset!");
static_assert(offsetof(ACoreMemoryPortal, _synchronizeCoreMemoryInteraction) == 0x000420, "Member 'ACoreMemoryPortal::_synchronizeCoreMemoryInteraction' has a wrong offset!");
static_assert(offsetof(ACoreMemoryPortal, _synchronizeCoreMemoryInteractionKiller) == 0x000428, "Member 'ACoreMemoryPortal::_synchronizeCoreMemoryInteractionKiller' has a wrong offset!");
static_assert(offsetof(ACoreMemoryPortal, _synchronizeCoreMemoryInteractionChargeable) == 0x000430, "Member 'ACoreMemoryPortal::_synchronizeCoreMemoryInteractionChargeable' has a wrong offset!");
static_assert(offsetof(ACoreMemoryPortal, _synchronizeCoreMemoryInteractionChargeableKiller) == 0x000438, "Member 'ACoreMemoryPortal::_synchronizeCoreMemoryInteractionChargeableKiller' has a wrong offset!");
static_assert(offsetof(ACoreMemoryPortal, _synchronizeCoreMemoryInteractionZone) == 0x000440, "Member 'ACoreMemoryPortal::_synchronizeCoreMemoryInteractionZone' has a wrong offset!");
static_assert(offsetof(ACoreMemoryPortal, _synchronizeCoreMemoryInteractionSecondsToCharge) == 0x000448, "Member 'ACoreMemoryPortal::_synchronizeCoreMemoryInteractionSecondsToCharge' has a wrong offset!");
static_assert(offsetof(ACoreMemoryPortal, _synchronizeCoreMemoryInteractionSecondsToChargeKiller) == 0x000470, "Member 'ACoreMemoryPortal::_synchronizeCoreMemoryInteractionSecondsToChargeKiller' has a wrong offset!");

// Class CoreMemory.CoreMemoryPortalComponent
// 0x0088 (0x0130 - 0x00A8)
class UCoreMemoryPortalComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x78];                                      // 0x00A8(0x0078)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ADBDPlayer*>                     _playersWithActivePortal;                          // 0x0120(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	const TArray<class ADBDPlayer*> GetPlayersWithActivePortal() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CoreMemoryPortalComponent">();
	}
	static class UCoreMemoryPortalComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCoreMemoryPortalComponent>();
	}
};
static_assert(alignof(UCoreMemoryPortalComponent) == 0x000008, "Wrong alignment on UCoreMemoryPortalComponent");
static_assert(sizeof(UCoreMemoryPortalComponent) == 0x000130, "Wrong size on UCoreMemoryPortalComponent");
static_assert(offsetof(UCoreMemoryPortalComponent, _playersWithActivePortal) == 0x000120, "Member 'UCoreMemoryPortalComponent::_playersWithActivePortal' has a wrong offset!");

// Class CoreMemory.CoreMemoryPortalDefaultBehaviour
// 0x0000 (0x0030 - 0x0030)
class UCoreMemoryPortalDefaultBehaviour final : public UCoreMemoryBehaviourBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CoreMemoryPortalDefaultBehaviour">();
	}
	static class UCoreMemoryPortalDefaultBehaviour* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCoreMemoryPortalDefaultBehaviour>();
	}
};
static_assert(alignof(UCoreMemoryPortalDefaultBehaviour) == 0x000008, "Wrong alignment on UCoreMemoryPortalDefaultBehaviour");
static_assert(sizeof(UCoreMemoryPortalDefaultBehaviour) == 0x000030, "Wrong size on UCoreMemoryPortalDefaultBehaviour");

// Class CoreMemory.CoreMemoryPortalFXComponent
// 0x0068 (0x0110 - 0x00A8)
class UCoreMemoryPortalFXComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             Cosmetic_OnPortalSpawned;                          // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             Cosmetic_OnPlayerStartedInteractingWithPortal;     // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             Cosmetic_OnPortalInteractionInterrupted;           // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             Cosmetic_OnPortalDeactivated;                      // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             Cosmetic_OnInteractionComplete;                    // 0x00E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_F8[0x18];                                      // 0x00F8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CoreMemoryPortalFXComponent">();
	}
	static class UCoreMemoryPortalFXComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCoreMemoryPortalFXComponent>();
	}
};
static_assert(alignof(UCoreMemoryPortalFXComponent) == 0x000008, "Wrong alignment on UCoreMemoryPortalFXComponent");
static_assert(sizeof(UCoreMemoryPortalFXComponent) == 0x000110, "Wrong size on UCoreMemoryPortalFXComponent");
static_assert(offsetof(UCoreMemoryPortalFXComponent, Cosmetic_OnPortalSpawned) == 0x0000A8, "Member 'UCoreMemoryPortalFXComponent::Cosmetic_OnPortalSpawned' has a wrong offset!");
static_assert(offsetof(UCoreMemoryPortalFXComponent, Cosmetic_OnPlayerStartedInteractingWithPortal) == 0x0000B8, "Member 'UCoreMemoryPortalFXComponent::Cosmetic_OnPlayerStartedInteractingWithPortal' has a wrong offset!");
static_assert(offsetof(UCoreMemoryPortalFXComponent, Cosmetic_OnPortalInteractionInterrupted) == 0x0000C8, "Member 'UCoreMemoryPortalFXComponent::Cosmetic_OnPortalInteractionInterrupted' has a wrong offset!");
static_assert(offsetof(UCoreMemoryPortalFXComponent, Cosmetic_OnPortalDeactivated) == 0x0000D8, "Member 'UCoreMemoryPortalFXComponent::Cosmetic_OnPortalDeactivated' has a wrong offset!");
static_assert(offsetof(UCoreMemoryPortalFXComponent, Cosmetic_OnInteractionComplete) == 0x0000E8, "Member 'UCoreMemoryPortalFXComponent::Cosmetic_OnInteractionComplete' has a wrong offset!");

// Class CoreMemory.CoreMemoryPortalOutlineUpdateStrategy
// 0x0010 (0x0100 - 0x00F0)
class UCoreMemoryPortalOutlineUpdateStrategy final : public UDefaultOutlineUpdateStrategy
{
public:
	struct FLinearColor                           _outlineColor;                                     // 0x00F0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CoreMemoryPortalOutlineUpdateStrategy">();
	}
	static class UCoreMemoryPortalOutlineUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCoreMemoryPortalOutlineUpdateStrategy>();
	}
};
static_assert(alignof(UCoreMemoryPortalOutlineUpdateStrategy) == 0x000008, "Wrong alignment on UCoreMemoryPortalOutlineUpdateStrategy");
static_assert(sizeof(UCoreMemoryPortalOutlineUpdateStrategy) == 0x000100, "Wrong size on UCoreMemoryPortalOutlineUpdateStrategy");
static_assert(offsetof(UCoreMemoryPortalOutlineUpdateStrategy, _outlineColor) == 0x0000F0, "Member 'UCoreMemoryPortalOutlineUpdateStrategy::_outlineColor' has a wrong offset!");

// Class CoreMemory.CoreMemoryRemoveStatusEffectBehaviour
// 0x0020 (0x0050 - 0x0030)
class UCoreMemoryRemoveStatusEffectBehaviour final : public UCoreMemoryBehaviourBase
{
public:
	TSubclassOf<class UStatusEffect>              _statusEffectToRemoveOnFragmentCollected;          // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _statusEffectToRemoveOnMemoryAcquired;             // 0x0038(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _statusEffectToRemoveOnStartedSynchronizingMemory; // 0x0040(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _statusEffectToRemoveOnMemorySynchronized;         // 0x0048(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CoreMemoryRemoveStatusEffectBehaviour">();
	}
	static class UCoreMemoryRemoveStatusEffectBehaviour* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCoreMemoryRemoveStatusEffectBehaviour>();
	}
};
static_assert(alignof(UCoreMemoryRemoveStatusEffectBehaviour) == 0x000008, "Wrong alignment on UCoreMemoryRemoveStatusEffectBehaviour");
static_assert(sizeof(UCoreMemoryRemoveStatusEffectBehaviour) == 0x000050, "Wrong size on UCoreMemoryRemoveStatusEffectBehaviour");
static_assert(offsetof(UCoreMemoryRemoveStatusEffectBehaviour, _statusEffectToRemoveOnFragmentCollected) == 0x000030, "Member 'UCoreMemoryRemoveStatusEffectBehaviour::_statusEffectToRemoveOnFragmentCollected' has a wrong offset!");
static_assert(offsetof(UCoreMemoryRemoveStatusEffectBehaviour, _statusEffectToRemoveOnMemoryAcquired) == 0x000038, "Member 'UCoreMemoryRemoveStatusEffectBehaviour::_statusEffectToRemoveOnMemoryAcquired' has a wrong offset!");
static_assert(offsetof(UCoreMemoryRemoveStatusEffectBehaviour, _statusEffectToRemoveOnStartedSynchronizingMemory) == 0x000040, "Member 'UCoreMemoryRemoveStatusEffectBehaviour::_statusEffectToRemoveOnStartedSynchronizingMemory' has a wrong offset!");
static_assert(offsetof(UCoreMemoryRemoveStatusEffectBehaviour, _statusEffectToRemoveOnMemorySynchronized) == 0x000048, "Member 'UCoreMemoryRemoveStatusEffectBehaviour::_statusEffectToRemoveOnMemorySynchronized' has a wrong offset!");

// Class CoreMemory.CoreMemoryScreamBehaviour
// 0x0008 (0x0038 - 0x0030)
class UCoreMemoryScreamBehaviour final : public UCoreMemoryBehaviourBase
{
public:
	bool                                          _shouldScreamOnCollect;                            // 0x0030(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _shouldScreamOnAcquired;                           // 0x0031(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _shouldScreamOnSynchronized;                       // 0x0032(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_33[0x5];                                       // 0x0033(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_Scream(class ACamperPlayer* Camper) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CoreMemoryScreamBehaviour">();
	}
	static class UCoreMemoryScreamBehaviour* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCoreMemoryScreamBehaviour>();
	}
};
static_assert(alignof(UCoreMemoryScreamBehaviour) == 0x000008, "Wrong alignment on UCoreMemoryScreamBehaviour");
static_assert(sizeof(UCoreMemoryScreamBehaviour) == 0x000038, "Wrong size on UCoreMemoryScreamBehaviour");
static_assert(offsetof(UCoreMemoryScreamBehaviour, _shouldScreamOnCollect) == 0x000030, "Member 'UCoreMemoryScreamBehaviour::_shouldScreamOnCollect' has a wrong offset!");
static_assert(offsetof(UCoreMemoryScreamBehaviour, _shouldScreamOnAcquired) == 0x000031, "Member 'UCoreMemoryScreamBehaviour::_shouldScreamOnAcquired' has a wrong offset!");
static_assert(offsetof(UCoreMemoryScreamBehaviour, _shouldScreamOnSynchronized) == 0x000032, "Member 'UCoreMemoryScreamBehaviour::_shouldScreamOnSynchronized' has a wrong offset!");

// Class CoreMemory.CoreMemorySpawnedStatusEffectTrackerComponent
// 0x0018 (0x00C0 - 0x00A8)
class UCoreMemorySpawnedStatusEffectTrackerComponent final : public UActorComponent
{
public:
	TArray<TWeakObjectPtr<class UStatusEffect>>   _authority_spawnedStatusEffects;                   // 0x00A8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class UCoreMemoryImposeStatusEffectBehaviour> _authority_imposeStatusEffectBehaviour;            // 0x00B8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Authority_AddSpawnedStatusEffect(class UStatusEffect* StatusEffect, class ACoreMemoryChallengePlayerSpecificController* PlayerController);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CoreMemorySpawnedStatusEffectTrackerComponent">();
	}
	static class UCoreMemorySpawnedStatusEffectTrackerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCoreMemorySpawnedStatusEffectTrackerComponent>();
	}
};
static_assert(alignof(UCoreMemorySpawnedStatusEffectTrackerComponent) == 0x000008, "Wrong alignment on UCoreMemorySpawnedStatusEffectTrackerComponent");
static_assert(sizeof(UCoreMemorySpawnedStatusEffectTrackerComponent) == 0x0000C0, "Wrong size on UCoreMemorySpawnedStatusEffectTrackerComponent");
static_assert(offsetof(UCoreMemorySpawnedStatusEffectTrackerComponent, _authority_spawnedStatusEffects) == 0x0000A8, "Member 'UCoreMemorySpawnedStatusEffectTrackerComponent::_authority_spawnedStatusEffects' has a wrong offset!");
static_assert(offsetof(UCoreMemorySpawnedStatusEffectTrackerComponent, _authority_imposeStatusEffectBehaviour) == 0x0000B8, "Member 'UCoreMemorySpawnedStatusEffectTrackerComponent::_authority_imposeStatusEffectBehaviour' has a wrong offset!");

// Class CoreMemory.CoreMemorySpawnFragmentOnEventBehaviour
// 0x0040 (0x0070 - 0x0030)
class UCoreMemorySpawnFragmentOnEventBehaviour : public UCoreMemoryBehaviourBase
{
public:
	struct FCoreMemoryFragmentSpawnData           _fragmentSpawnData;                                // 0x0030(0x0018)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FGameplayTag>                   _spawnFragmentOnGameEvents;                        // 0x0048(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	bool                                          _onlyForKiller;                                    // 0x0058(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _onlyForSurvivors;                                 // 0x0059(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5A[0x16];                                      // 0x005A(0x0016)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CoreMemorySpawnFragmentOnEventBehaviour">();
	}
	static class UCoreMemorySpawnFragmentOnEventBehaviour* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCoreMemorySpawnFragmentOnEventBehaviour>();
	}
};
static_assert(alignof(UCoreMemorySpawnFragmentOnEventBehaviour) == 0x000008, "Wrong alignment on UCoreMemorySpawnFragmentOnEventBehaviour");
static_assert(sizeof(UCoreMemorySpawnFragmentOnEventBehaviour) == 0x000070, "Wrong size on UCoreMemorySpawnFragmentOnEventBehaviour");
static_assert(offsetof(UCoreMemorySpawnFragmentOnEventBehaviour, _fragmentSpawnData) == 0x000030, "Member 'UCoreMemorySpawnFragmentOnEventBehaviour::_fragmentSpawnData' has a wrong offset!");
static_assert(offsetof(UCoreMemorySpawnFragmentOnEventBehaviour, _spawnFragmentOnGameEvents) == 0x000048, "Member 'UCoreMemorySpawnFragmentOnEventBehaviour::_spawnFragmentOnGameEvents' has a wrong offset!");
static_assert(offsetof(UCoreMemorySpawnFragmentOnEventBehaviour, _onlyForKiller) == 0x000058, "Member 'UCoreMemorySpawnFragmentOnEventBehaviour::_onlyForKiller' has a wrong offset!");
static_assert(offsetof(UCoreMemorySpawnFragmentOnEventBehaviour, _onlyForSurvivors) == 0x000059, "Member 'UCoreMemorySpawnFragmentOnEventBehaviour::_onlyForSurvivors' has a wrong offset!");

// Class CoreMemory.CoreMemorySpawnFragmentOnEventWithinRangeOfTargetBehaviour
// 0x0008 (0x0078 - 0x0070)
class UCoreMemorySpawnFragmentOnEventWithinRangeOfTargetBehaviour final : public UCoreMemorySpawnFragmentOnEventBehaviour
{
public:
	ETileSpawnPointType                           _tileSpawnPointType;                               // 0x0070(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CoreMemorySpawnFragmentOnEventWithinRangeOfTargetBehaviour">();
	}
	static class UCoreMemorySpawnFragmentOnEventWithinRangeOfTargetBehaviour* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCoreMemorySpawnFragmentOnEventWithinRangeOfTargetBehaviour>();
	}
};
static_assert(alignof(UCoreMemorySpawnFragmentOnEventWithinRangeOfTargetBehaviour) == 0x000008, "Wrong alignment on UCoreMemorySpawnFragmentOnEventWithinRangeOfTargetBehaviour");
static_assert(sizeof(UCoreMemorySpawnFragmentOnEventWithinRangeOfTargetBehaviour) == 0x000078, "Wrong size on UCoreMemorySpawnFragmentOnEventWithinRangeOfTargetBehaviour");
static_assert(offsetof(UCoreMemorySpawnFragmentOnEventWithinRangeOfTargetBehaviour, _tileSpawnPointType) == 0x000070, "Member 'UCoreMemorySpawnFragmentOnEventWithinRangeOfTargetBehaviour::_tileSpawnPointType' has a wrong offset!");

// Class CoreMemory.CoreMemorySpawnFragmentsOnCollectBehaviour
// 0x0018 (0x0048 - 0x0030)
class UCoreMemorySpawnFragmentsOnCollectBehaviour final : public UCoreMemoryBehaviourBase
{
public:
	struct FCoreMemoryFragmentSpawnData           _fragmentSpawnData;                                // 0x0030(0x0018)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CoreMemorySpawnFragmentsOnCollectBehaviour">();
	}
	static class UCoreMemorySpawnFragmentsOnCollectBehaviour* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCoreMemorySpawnFragmentsOnCollectBehaviour>();
	}
};
static_assert(alignof(UCoreMemorySpawnFragmentsOnCollectBehaviour) == 0x000008, "Wrong alignment on UCoreMemorySpawnFragmentsOnCollectBehaviour");
static_assert(sizeof(UCoreMemorySpawnFragmentsOnCollectBehaviour) == 0x000048, "Wrong size on UCoreMemorySpawnFragmentsOnCollectBehaviour");
static_assert(offsetof(UCoreMemorySpawnFragmentsOnCollectBehaviour, _fragmentSpawnData) == 0x000030, "Member 'UCoreMemorySpawnFragmentsOnCollectBehaviour::_fragmentSpawnData' has a wrong offset!");

// Class CoreMemory.CoreMemorySpawnFragmentsOnRandPlayerSpawnBehaviour
// 0x0020 (0x0050 - 0x0030)
class UCoreMemorySpawnFragmentsOnRandPlayerSpawnBehaviour final : public UCoreMemoryBehaviourBase
{
public:
	struct FCoreMemoryFragmentSpawnData           _fragmentSpawnData;                                // 0x0030(0x0018)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	ETileSpawnPointType                           _tileSpawnPointType;                               // 0x0048(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CoreMemorySpawnFragmentsOnRandPlayerSpawnBehaviour">();
	}
	static class UCoreMemorySpawnFragmentsOnRandPlayerSpawnBehaviour* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCoreMemorySpawnFragmentsOnRandPlayerSpawnBehaviour>();
	}
};
static_assert(alignof(UCoreMemorySpawnFragmentsOnRandPlayerSpawnBehaviour) == 0x000008, "Wrong alignment on UCoreMemorySpawnFragmentsOnRandPlayerSpawnBehaviour");
static_assert(sizeof(UCoreMemorySpawnFragmentsOnRandPlayerSpawnBehaviour) == 0x000050, "Wrong size on UCoreMemorySpawnFragmentsOnRandPlayerSpawnBehaviour");
static_assert(offsetof(UCoreMemorySpawnFragmentsOnRandPlayerSpawnBehaviour, _fragmentSpawnData) == 0x000030, "Member 'UCoreMemorySpawnFragmentsOnRandPlayerSpawnBehaviour::_fragmentSpawnData' has a wrong offset!");
static_assert(offsetof(UCoreMemorySpawnFragmentsOnRandPlayerSpawnBehaviour, _tileSpawnPointType) == 0x000048, "Member 'UCoreMemorySpawnFragmentsOnRandPlayerSpawnBehaviour::_tileSpawnPointType' has a wrong offset!");

// Class CoreMemory.CoreMemoryUtilities
// 0x0000 (0x0030 - 0x0030)
class UCoreMemoryUtilities final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CoreMemoryUtilities">();
	}
	static class UCoreMemoryUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCoreMemoryUtilities>();
	}
};
static_assert(alignof(UCoreMemoryUtilities) == 0x000008, "Wrong alignment on UCoreMemoryUtilities");
static_assert(sizeof(UCoreMemoryUtilities) == 0x000030, "Wrong size on UCoreMemoryUtilities");

// Class CoreMemory.SynchronizeCoreMemoryInteraction
// 0x0000 (0x08C0 - 0x08C0)
class USynchronizeCoreMemoryInteraction final : public UChargeableInteractionDefinition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SynchronizeCoreMemoryInteraction">();
	}
	static class USynchronizeCoreMemoryInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<USynchronizeCoreMemoryInteraction>();
	}
};
static_assert(alignof(USynchronizeCoreMemoryInteraction) == 0x000010, "Wrong alignment on USynchronizeCoreMemoryInteraction");
static_assert(sizeof(USynchronizeCoreMemoryInteraction) == 0x0008C0, "Wrong size on USynchronizeCoreMemoryInteraction");

}

