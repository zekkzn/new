#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: DBDBots

#include "Basic.hpp"

#include "AIModule_structs.hpp"
#include "DeadByDaylight_structs.hpp"
#include "GameplayTags_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "DBDSharedTypes_structs.hpp"


namespace SDK
{

// Enum DBDBots.ETargetObjectType
// NumValues: 0x0007
enum class ETargetObjectType : uint8
{
	None                                     = 0,
	Survivor                                 = 1,
	Generator                                = 2,
	Hook                                     = 4,
	SurvivorOrGenerator                      = 3,
	Max                                      = 8,
	ETargetObjectType_MAX                    = 9,
};

// Enum DBDBots.ETrackedKillerState
// NumValues: 0x0004
enum class ETrackedKillerState : uint8
{
	Patrolling                               = 0,
	Chasing                                  = 1,
	Carrying                                 = 2,
	ETrackedKillerState_MAX                  = 3,
};

// Enum DBDBots.EInteractionSkillInputModes
// NumValues: 0x0006
enum class EInteractionSkillInputModes : uint8
{
	Once                                     = 0,
	Hold                                     = 1,
	Toggle                                   = 2,
	ToggleHold                               = 3,
	OneClickHold                             = 4,
	EInteractionSkillInputModes_MAX          = 5,
};

// Enum DBDBots.EInteractionCancelInputModes
// NumValues: 0x0003
enum class EInteractionCancelInputModes : uint8
{
	PressCancelInput                         = 0,
	InvertWithStopInputFlow                  = 1,
	EInteractionCancelInputModes_MAX         = 2,
};

// Enum DBDBots.EInteractionTargetRequirements
// NumValues: 0x0006
enum class EInteractionTargetRequirements : uint8
{
	BestTargetMustBeValid                    = 0,
	AnyValidTarget                           = 1,
	AnyTarget                                = 2,
	NoTarget                                 = 3,
	None                                     = 4,
	EInteractionTargetRequirements_MAX       = 5,
};

// Enum DBDBots.EInteractionTargetInSightModes
// NumValues: 0x0005
enum class EInteractionTargetInSightModes : uint8
{
	None                                     = 0,
	MustBeInSight                            = 1,
	MustBeInSight_NoObstruction              = 2,
	ActivateIfOutOfSight                     = 3,
	EInteractionTargetInSightModes_MAX       = 4,
};

// Enum DBDBots.EAIThrowPredictionModes
// NumValues: 0x0004
enum class EAIThrowPredictionModes : uint8
{
	FindBestThrowPowerRatio                  = 0,
	RangeBasedThrowPowerRatio                = 1,
	FullThrowPowerRatio                      = 2,
	EAIThrowPredictionModes_MAX              = 3,
};

// Enum DBDBots.EAIThrowProjectileModes
// NumValues: 0x0003
enum class EAIThrowProjectileModes : uint8
{
	OneShot                                  = 0,
	Continuous                               = 1,
	EAIThrowProjectileModes_MAX              = 2,
};

// Enum DBDBots.EAISkillBlinkState
// NumValues: 0x0006
enum class EAISkillBlinkState : uint8
{
	Ready                                    = 0,
	Charging                                 = 1,
	Warping                                  = 2,
	PostBlink                                = 3,
	Cooldown                                 = 4,
	EAISkillBlinkState_MAX                   = 5,
};

// Enum DBDBots.EGeneratorDangerRating
// NumValues: 0x0004
enum class EGeneratorDangerRating : uint8
{
	Safe                                     = 0,
	Neutral                                  = 1,
	Dangerous                                = 2,
	EGeneratorDangerRating_MAX               = 3,
};

// Enum DBDBots.EPlayerFilter
// NumValues: 0x0004
enum class EPlayerFilter : uint8
{
	Self                                     = 0,
	AnyFriend                                = 1,
	AnyOpponent                              = 2,
	EPlayerFilter_MAX                        = 3,
};

// Enum DBDBots.EIsCamperStateOnFilter
// NumValues: 0x0003
enum class EIsCamperStateOnFilter : uint8
{
	OnBlackboardKey                          = 0,
	OnOthersThanSelf                         = 1,
	EIsCamperStateOnFilter_MAX               = 2,
};

// Enum DBDBots.EIsInteractionAvailableOnFilter
// NumValues: 0x0004
enum class EIsInteractionAvailableOnFilter : uint8
{
	Self                                     = 0,
	AnyFriend                                = 1,
	Interactor                               = 2,
	EIsInteractionAvailableOnFilter_MAX      = 3,
};

// Enum DBDBots.EInteractionCheckType
// NumValues: 0x0003
enum class EInteractionCheckType : uint8
{
	InteractionID                            = 0,
	InputType                                = 1,
	EInteractionCheckType_MAX                = 2,
};

// Enum DBDBots.EDecoratorIsObjFocusedFilter
// NumValues: 0x0003
enum class EDecoratorIsObjFocusedFilter : uint8
{
	Self                                     = 0,
	SelfNearest                              = 1,
	EDecoratorIsObjFocusedFilter_MAX         = 2,
};

// Enum DBDBots.ETunableComparison
// NumValues: 0x0007
enum class ETunableComparison : uint8
{
	Equal                                    = 0,
	NotEqual                                 = 1,
	Less                                     = 2,
	LessOrEqual                              = 3,
	Greater                                  = 4,
	GreaterOrEqual                           = 5,
	ETunableComparison_MAX                   = 6,
};

// Enum DBDBots.EItemType
// NumValues: 0x0004
enum class EItemType : uint8
{
	RegularItem                              = 0,
	SpecialItem                              = 1,
	CursedItem                               = 2,
	EItemType_MAX                            = 3,
};

// Enum DBDBots.EFindEnemySurvivorPurpose
// NumValues: 0x0004
enum class EFindEnemySurvivorPurpose : uint8
{
	Search                                   = 0,
	Chase                                    = 1,
	Pickup                                   = 2,
	EFindEnemySurvivorPurpose_MAX            = 3,
};

// Enum DBDBots.EFindInteractableCamperFilter
// NumValues: 0x0007
enum class EFindInteractableCamperFilter : uint8
{
	Crawling                                 = 0,
	Standing                                 = 1,
	GiveHelp                                 = 2,
	RequestHelp                              = 3,
	RescuableBeingCarried                    = 4,
	Any                                      = 5,
	EFindInteractableCamperFilter_MAX        = 6,
};

// Enum DBDBots.EFindInteractorExitOptions
// NumValues: 0x0004
enum class EFindInteractorExitOptions : uint8
{
	All                                      = 0,
	HatchOnly                                = 1,
	GateOnly                                 = 2,
	EFindInteractorExitOptions_MAX           = 3,
};

// Enum DBDBots.EFindInteractorOpenConditions
// NumValues: 0x0005
enum class EFindInteractorOpenConditions : uint8
{
	AllGate_OpenedHatch                      = 0,
	All                                      = 1,
	ClosedOnly                               = 2,
	OpenedOnly                               = 3,
	EFindInteractorOpenConditions_MAX        = 4,
};

// Enum DBDBots.EFindInteractableGeneratorStatusFilter
// NumValues: 0x0003
enum class EFindInteractableGeneratorStatusFilter : uint8
{
	NeedRepair                               = 0,
	CanBeDamaged                             = 1,
	EFindInteractableGeneratorStatusFilter_MAX = 2,
};

// Enum DBDBots.EFindInteractableLockerStatusFilter
// NumValues: 0x0004
enum class EFindInteractableLockerStatusFilter : uint8
{
	Empty                                    = 0,
	Occupied                                 = 1,
	Both                                     = 2,
	EFindInteractableLockerStatusFilter_MAX  = 3,
};

// Enum DBDBots.EInLockerPerkEmptyHandType
// NumValues: 0x0005
enum class EInLockerPerkEmptyHandType : uint8
{
	None                                     = 0,
	SurvivorItem                             = 1,
	SpecialItem                              = 2,
	Both                                     = 3,
	EInLockerPerkEmptyHandType_MAX           = 4,
};

// Enum DBDBots.EFindInteractableMeatHookStatus
// NumValues: 0x0004
enum class EFindInteractableMeatHookStatus : uint8
{
	HookedSurvivor                           = 0,
	Available                                = 1,
	Sabotage                                 = 2,
	EFindInteractableMeatHookStatus_MAX      = 3,
};

// Enum DBDBots.EFindInteractablePalletIntentions
// NumValues: 0x0005
enum class EFindInteractablePalletIntentions : uint8
{
	Fall                                     = 0,
	Raise                                    = 1,
	Break                                    = 2,
	Restore                                  = 3,
	EFindInteractablePalletIntentions_MAX    = 4,
};

// Enum DBDBots.EAINodeRelevancyOptions
// NumValues: 0x0005
enum class EAINodeRelevancyOptions : uint8
{
	OnEnter                                  = 0,
	OnExit                                   = 1,
	OnEnterAndExit                           = 2,
	OnTick                                   = 3,
	EAINodeRelevancyOptions_MAX              = 4,
};

// Enum DBDBots.EAIInvestigateSteps
// NumValues: 0x0004
enum class EAIInvestigateSteps : uint8
{
	None                                     = 0,
	ToInvestigation                          = 1,
	Investigating                            = 2,
	EAIInvestigateSteps_MAX                  = 3,
};

// Enum DBDBots.EExtMoveToStrafeFocusOptions
// NumValues: 0x0008
enum class EExtMoveToStrafeFocusOptions : uint8
{
	Never                                    = 0,
	NearFocus                                = 1,
	NearGoal                                 = 2,
	Always                                   = 3,
	Intermittent                             = 4,
	IntermittentOrNearFocus                  = 5,
	IntermittentOrNearGoal                   = 6,
	EExtMoveToStrafeFocusOptions_MAX         = 7,
};

// Enum DBDBots.ETaskInputPressModes
// NumValues: 0x0004
enum class ETaskInputPressModes : uint8
{
	Once                                     = 0,
	Loop                                     = 1,
	Hold                                     = 2,
	ETaskInputPressModes_MAX                 = 3,
};

// Enum DBDBots.EPassiveCameraState
// NumValues: 0x0006
enum class EPassiveCameraState : uint8
{
	Inactive                                 = 0,
	Idle                                     = 1,
	Moving                                   = 2,
	Interaction                              = 3,
	Hooked                                   = 4,
	EPassiveCameraState_MAX                  = 5,
};

// Enum DBDBots.EAIDangerState
// NumValues: 0x0004
enum class EAIDangerState : uint8
{
	Safe                                     = 0,
	Unsafe                                   = 1,
	Dire                                     = 2,
	EAIDangerState_MAX                       = 3,
};

// Enum DBDBots.EAIObjectiveState
// NumValues: 0x0005
enum class EAIObjectiveState : uint8
{
	Early                                    = 0,
	Mid                                      = 1,
	Last                                     = 2,
	Completed                                = 3,
	EAIObjectiveState_MAX                    = 4,
};

// Enum DBDBots.EAIGameState
// NumValues: 0x0007
enum class EAIGameState : uint8
{
	VeryEarly                                = 0,
	Early                                    = 1,
	Mid                                      = 2,
	Late                                     = 3,
	VeryLate                                 = 4,
	Max                                      = 5,
	EAIGameState_MAX                         = 6,
};

// Enum DBDBots.EAIPressureZoneLevel
// NumValues: 0x0005
enum class EAIPressureZoneLevel : uint8
{
	LMin                                     = 0,
	L01                                      = 1,
	L02                                      = 2,
	LMax                                     = 3,
	EAIPressureZoneLevel_MAX                 = 4,
};

// Enum DBDBots.ENavObstacleBorderType
// NumValues: 0x0006
enum class ENavObstacleBorderType : uint8
{
	None                                     = 0,
	Shape                                    = 1,
	Obstacle                                 = 2,
	Mixed                                    = 3,
	DetachedShape                            = 4,
	ENavObstacleBorderType_MAX               = 5,
};

// Enum DBDBots.ENavObstacleEdgeValidCheckType
// NumValues: 0x0005
enum class ENavObstacleEdgeValidCheckType : uint8
{
	Any                                      = 0,
	ChainsawObstruction                      = 1,
	CrouchCover                              = 2,
	StandCover                               = 3,
	ENavObstacleEdgeValidCheckType_MAX       = 4,
};

// Enum DBDBots.ENavObstacleInitializationState
// NumValues: 0x000B
enum class ENavObstacleInitializationState : uint8
{
	NotReady                                 = 0,
	Unused                                   = 1,
	GettingNavEdges                          = 2,
	CreatingNavObstacles                     = 3,
	MergingNavObstacles                      = 4,
	FilteringNavObstacles                    = 5,
	InitializingEdgeData                     = 6,
	InitializingMatrices                     = 7,
	SortingObstaclesInMatrix                 = 8,
	Completed                                = 9,
	ENavObstacleInitializationState_MAX      = 10,
};

// Enum DBDBots.ENavLinkPlayerStates
// NumValues: 0x0006
enum class ENavLinkPlayerStates : uint8
{
	RequestStart                             = 0,
	MoveStart                                = 1,
	Using                                    = 2,
	MoveEnd                                  = 3,
	Release                                  = 4,
	ENavLinkPlayerStates_MAX                 = 5,
};

// Enum DBDBots.EPathBuildResult
// NumValues: 0x0006
enum class EPathBuildResult : uint8
{
	None                                     = 0,
	Failed                                   = 1,
	Succeeded                                = 2,
	Partial                                  = 3,
	InProgress                               = 4,
	EPathBuildResult_MAX                     = 5,
};

// Enum DBDBots.EAIFleePathStrategy
// NumValues: 0x0008
enum class EAIFleePathStrategy : uint8
{
	None                                     = 0,
	KeepGoal                                 = 1,
	Away                                     = 2,
	Loop                                     = 3,
	AwayLOS                                  = 4,
	Lure                                     = 5,
	Reposition                               = 6,
	EAIFleePathStrategy_MAX                  = 7,
};

// Enum DBDBots.EAIFleeLoopStrategy
// NumValues: 0x0003
enum class EAIFleeLoopStrategy : uint8
{
	LoseKiller                               = 0,
	WasteTime                                = 1,
	EAIFleeLoopStrategy_MAX                  = 2,
};

// ScriptStruct DBDBots.NavMovePathPoint
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FNavMovePathPoint final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNavMovePathPoint) == 0x000008, "Wrong alignment on FNavMovePathPoint");
static_assert(sizeof(FNavMovePathPoint) == 0x000020, "Wrong size on FNavMovePathPoint");

// ScriptStruct DBDBots.AISkillContextWeights
// 0x00E0 (0x00E0 - 0x0000)
struct FAISkillContextWeights
{
public:
	struct FGameplayTagContainer                  Context;                                           // 0x0000(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    BaseWeight;                                        // 0x0020(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    DistanceWeight;                                    // 0x0080(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAISkillContextWeights) == 0x000008, "Wrong alignment on FAISkillContextWeights");
static_assert(sizeof(FAISkillContextWeights) == 0x0000E0, "Wrong size on FAISkillContextWeights");
static_assert(offsetof(FAISkillContextWeights, Context) == 0x000000, "Member 'FAISkillContextWeights::Context' has a wrong offset!");
static_assert(offsetof(FAISkillContextWeights, BaseWeight) == 0x000020, "Member 'FAISkillContextWeights::BaseWeight' has a wrong offset!");
static_assert(offsetof(FAISkillContextWeights, DistanceWeight) == 0x000080, "Member 'FAISkillContextWeights::DistanceWeight' has a wrong offset!");

// ScriptStruct DBDBots.TargetMoveAwayToFastInfo
// 0x00F0 (0x00F0 - 0x0000)
struct FTargetMoveAwayToFastInfo final
{
public:
	float                                         AccumulatedTime;                                   // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CooldownUntilTime;                                 // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAIDetectedStimulus                    Stimulus;                                          // 0x0008(0x00E8)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTargetMoveAwayToFastInfo) == 0x000008, "Wrong alignment on FTargetMoveAwayToFastInfo");
static_assert(sizeof(FTargetMoveAwayToFastInfo) == 0x0000F0, "Wrong size on FTargetMoveAwayToFastInfo");
static_assert(offsetof(FTargetMoveAwayToFastInfo, AccumulatedTime) == 0x000000, "Member 'FTargetMoveAwayToFastInfo::AccumulatedTime' has a wrong offset!");
static_assert(offsetof(FTargetMoveAwayToFastInfo, CooldownUntilTime) == 0x000004, "Member 'FTargetMoveAwayToFastInfo::CooldownUntilTime' has a wrong offset!");
static_assert(offsetof(FTargetMoveAwayToFastInfo, Stimulus) == 0x000008, "Member 'FTargetMoveAwayToFastInfo::Stimulus' has a wrong offset!");

// ScriptStruct DBDBots.ModifierValueData
// 0x0020 (0x0020 - 0x0000)
struct FModifierValueData final
{
public:
	struct FGameplayTag                           ModifierTag;                                       // 0x0000(0x000C)(Edit, DisableEditOnTemplate, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EstimateWithSemantics;                             // 0x000C(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           SemanticTag;                                       // 0x0010(0x000C)(Edit, DisableEditOnTemplate, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UsesItemAddons;                                    // 0x001C(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FModifierValueData) == 0x000004, "Wrong alignment on FModifierValueData");
static_assert(sizeof(FModifierValueData) == 0x000020, "Wrong size on FModifierValueData");
static_assert(offsetof(FModifierValueData, ModifierTag) == 0x000000, "Member 'FModifierValueData::ModifierTag' has a wrong offset!");
static_assert(offsetof(FModifierValueData, EstimateWithSemantics) == 0x00000C, "Member 'FModifierValueData::EstimateWithSemantics' has a wrong offset!");
static_assert(offsetof(FModifierValueData, SemanticTag) == 0x000010, "Member 'FModifierValueData::SemanticTag' has a wrong offset!");
static_assert(offsetof(FModifierValueData, UsesItemAddons) == 0x00001C, "Member 'FModifierValueData::UsesItemAddons' has a wrong offset!");

// ScriptStruct DBDBots.DistanceToTargetData
// 0x0040 (0x0040 - 0x0000)
struct FDistanceToTargetData final
{
public:
	uint8                                         Pad_0[0x30];                                       // 0x0000(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              _lastUpdateTime;                                   // 0x0030(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDateTime                              _lastTargetTime;                                   // 0x0038(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FDistanceToTargetData) == 0x000008, "Wrong alignment on FDistanceToTargetData");
static_assert(sizeof(FDistanceToTargetData) == 0x000040, "Wrong size on FDistanceToTargetData");
static_assert(offsetof(FDistanceToTargetData, _lastUpdateTime) == 0x000030, "Member 'FDistanceToTargetData::_lastUpdateTime' has a wrong offset!");
static_assert(offsetof(FDistanceToTargetData, _lastTargetTime) == 0x000038, "Member 'FDistanceToTargetData::_lastTargetTime' has a wrong offset!");

// ScriptStruct DBDBots.GameStateEvadeLoopStrategyMapContainer
// 0x0050 (0x0050 - 0x0000)
struct FGameStateEvadeLoopStrategyMapContainer final
{
public:
	TMap<EAIGameState, EAIFleeLoopStrategy>       Map;                                               // 0x0000(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameStateEvadeLoopStrategyMapContainer) == 0x000008, "Wrong alignment on FGameStateEvadeLoopStrategyMapContainer");
static_assert(sizeof(FGameStateEvadeLoopStrategyMapContainer) == 0x000050, "Wrong size on FGameStateEvadeLoopStrategyMapContainer");
static_assert(offsetof(FGameStateEvadeLoopStrategyMapContainer, Map) == 0x000000, "Member 'FGameStateEvadeLoopStrategyMapContainer::Map' has a wrong offset!");

// ScriptStruct DBDBots.AIHasItemAddonCondition
// 0x0030 (0x0030 - 0x0000)
struct FAIHasItemAddonCondition final
{
public:
	struct FDataTableDropdown                     ItemAddonID;                                       // 0x0000(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIHasItemAddonCondition) == 0x000008, "Wrong alignment on FAIHasItemAddonCondition");
static_assert(sizeof(FAIHasItemAddonCondition) == 0x000030, "Wrong size on FAIHasItemAddonCondition");
static_assert(offsetof(FAIHasItemAddonCondition, ItemAddonID) == 0x000000, "Member 'FAIHasItemAddonCondition::ItemAddonID' has a wrong offset!");

// ScriptStruct DBDBots.NavObstacleEdgeRow
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FNavObstacleEdgeRow final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNavObstacleEdgeRow) == 0x000008, "Wrong alignment on FNavObstacleEdgeRow");
static_assert(sizeof(FNavObstacleEdgeRow) == 0x000010, "Wrong size on FNavObstacleEdgeRow");

// ScriptStruct DBDBots.KillerFilterItem
// 0x0008 (0x0008 - 0x0000)
struct FKillerFilterItem final
{
public:
	struct FCharacterDropdown                     Character;                                         // 0x0000(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FKillerFilterItem) == 0x000004, "Wrong alignment on FKillerFilterItem");
static_assert(sizeof(FKillerFilterItem) == 0x000008, "Wrong size on FKillerFilterItem");
static_assert(offsetof(FKillerFilterItem, Character) == 0x000000, "Member 'FKillerFilterItem::Character' has a wrong offset!");

// ScriptStruct DBDBots.AdditionalDynamicSubtree
// 0x0060 (0x0060 - 0x0000)
struct FAdditionalDynamicSubtree final
{
public:
	struct FGameplayTagContainer                  DynamicSubtreeContexts;                            // 0x0000(0x0020)(Edit, NativeAccessSpecifierPublic)
	bool                                          AlwaysEnable;                                      // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UBehaviorTree>           DynamicSubtree;                                    // 0x0028(0x0038)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAdditionalDynamicSubtree) == 0x000008, "Wrong alignment on FAdditionalDynamicSubtree");
static_assert(sizeof(FAdditionalDynamicSubtree) == 0x000060, "Wrong size on FAdditionalDynamicSubtree");
static_assert(offsetof(FAdditionalDynamicSubtree, DynamicSubtreeContexts) == 0x000000, "Member 'FAdditionalDynamicSubtree::DynamicSubtreeContexts' has a wrong offset!");
static_assert(offsetof(FAdditionalDynamicSubtree, AlwaysEnable) == 0x000020, "Member 'FAdditionalDynamicSubtree::AlwaysEnable' has a wrong offset!");
static_assert(offsetof(FAdditionalDynamicSubtree, DynamicSubtree) == 0x000028, "Member 'FAdditionalDynamicSubtree::DynamicSubtree' has a wrong offset!");

// ScriptStruct DBDBots.AIHasExhaustionPerkCondition
// 0x0030 (0x0030 - 0x0000)
struct FAIHasExhaustionPerkCondition final
{
public:
	struct FDataTableDropdown                     PerkId;                                            // 0x0000(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIHasExhaustionPerkCondition) == 0x000008, "Wrong alignment on FAIHasExhaustionPerkCondition");
static_assert(sizeof(FAIHasExhaustionPerkCondition) == 0x000030, "Wrong size on FAIHasExhaustionPerkCondition");
static_assert(offsetof(FAIHasExhaustionPerkCondition, PerkId) == 0x000000, "Member 'FAIHasExhaustionPerkCondition::PerkId' has a wrong offset!");

// ScriptStruct DBDBots.AIRandomByDistancePercentagesAtTime
// 0x0120 (0x0120 - 0x0000)
struct FAIRandomByDistancePercentagesAtTime final
{
public:
	struct FAITunableParameter                    PercentageAtStartDistance;                         // 0x0000(0x0060)(Edit, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    PercentageAtEndDistance;                           // 0x0060(0x0060)(Edit, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    AtRelativeTime;                                    // 0x00C0(0x0060)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIRandomByDistancePercentagesAtTime) == 0x000008, "Wrong alignment on FAIRandomByDistancePercentagesAtTime");
static_assert(sizeof(FAIRandomByDistancePercentagesAtTime) == 0x000120, "Wrong size on FAIRandomByDistancePercentagesAtTime");
static_assert(offsetof(FAIRandomByDistancePercentagesAtTime, PercentageAtStartDistance) == 0x000000, "Member 'FAIRandomByDistancePercentagesAtTime::PercentageAtStartDistance' has a wrong offset!");
static_assert(offsetof(FAIRandomByDistancePercentagesAtTime, PercentageAtEndDistance) == 0x000060, "Member 'FAIRandomByDistancePercentagesAtTime::PercentageAtEndDistance' has a wrong offset!");
static_assert(offsetof(FAIRandomByDistancePercentagesAtTime, AtRelativeTime) == 0x0000C0, "Member 'FAIRandomByDistancePercentagesAtTime::AtRelativeTime' has a wrong offset!");

// ScriptStruct DBDBots.AIGetAttentionMovement
// 0x000C (0x000C - 0x0000)
struct alignas(0x04) FAIGetAttentionMovement final
{
public:
	uint8                                         Pad_0[0xC];                                        // 0x0000(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIGetAttentionMovement) == 0x000004, "Wrong alignment on FAIGetAttentionMovement");
static_assert(sizeof(FAIGetAttentionMovement) == 0x00000C, "Wrong size on FAIGetAttentionMovement");

// ScriptStruct DBDBots.InLockerPerk
// 0x00E8 (0x00E8 - 0x0000)
struct FInLockerPerk final
{
public:
	struct FDataTableDropdown                     PerkId;                                            // 0x0000(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	bool                                          PerkNeedToBeFullyCharged;                          // 0x0030(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInLockerPerkEmptyHandType                    RequiredHeldItemSlots;                             // 0x0031(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInLockerPerkEmptyHandType                    RequiredEmptyHandedSlots;                          // 0x0032(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NeedToBeInjured;                                   // 0x0033(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NeedPerkSkillToBeRunnableAtLocation;               // 0x0034(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MustBeFarFromLinkedObject;                         // 0x0035(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_36[0x2];                                       // 0x0036(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinimumDistanceFromObject;                         // 0x0038(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AActor>                     LinkedObjectClass;                                 // 0x0040(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UnusableIfLockerPenaltyReceived;                   // 0x0048(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlackboardKeySelector                 BBLockerPenaltyReceived;                           // 0x0050(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	float                                         UnusableUnlessKillerIsFartherThan;                 // 0x0080(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_84[0x4];                                       // 0x0084(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAITunableParameter                    PerkWeight;                                        // 0x0088(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInLockerPerk) == 0x000008, "Wrong alignment on FInLockerPerk");
static_assert(sizeof(FInLockerPerk) == 0x0000E8, "Wrong size on FInLockerPerk");
static_assert(offsetof(FInLockerPerk, PerkId) == 0x000000, "Member 'FInLockerPerk::PerkId' has a wrong offset!");
static_assert(offsetof(FInLockerPerk, PerkNeedToBeFullyCharged) == 0x000030, "Member 'FInLockerPerk::PerkNeedToBeFullyCharged' has a wrong offset!");
static_assert(offsetof(FInLockerPerk, RequiredHeldItemSlots) == 0x000031, "Member 'FInLockerPerk::RequiredHeldItemSlots' has a wrong offset!");
static_assert(offsetof(FInLockerPerk, RequiredEmptyHandedSlots) == 0x000032, "Member 'FInLockerPerk::RequiredEmptyHandedSlots' has a wrong offset!");
static_assert(offsetof(FInLockerPerk, NeedToBeInjured) == 0x000033, "Member 'FInLockerPerk::NeedToBeInjured' has a wrong offset!");
static_assert(offsetof(FInLockerPerk, NeedPerkSkillToBeRunnableAtLocation) == 0x000034, "Member 'FInLockerPerk::NeedPerkSkillToBeRunnableAtLocation' has a wrong offset!");
static_assert(offsetof(FInLockerPerk, MustBeFarFromLinkedObject) == 0x000035, "Member 'FInLockerPerk::MustBeFarFromLinkedObject' has a wrong offset!");
static_assert(offsetof(FInLockerPerk, MinimumDistanceFromObject) == 0x000038, "Member 'FInLockerPerk::MinimumDistanceFromObject' has a wrong offset!");
static_assert(offsetof(FInLockerPerk, LinkedObjectClass) == 0x000040, "Member 'FInLockerPerk::LinkedObjectClass' has a wrong offset!");
static_assert(offsetof(FInLockerPerk, UnusableIfLockerPenaltyReceived) == 0x000048, "Member 'FInLockerPerk::UnusableIfLockerPenaltyReceived' has a wrong offset!");
static_assert(offsetof(FInLockerPerk, BBLockerPenaltyReceived) == 0x000050, "Member 'FInLockerPerk::BBLockerPenaltyReceived' has a wrong offset!");
static_assert(offsetof(FInLockerPerk, UnusableUnlessKillerIsFartherThan) == 0x000080, "Member 'FInLockerPerk::UnusableUnlessKillerIsFartherThan' has a wrong offset!");
static_assert(offsetof(FInLockerPerk, PerkWeight) == 0x000088, "Member 'FInLockerPerk::PerkWeight' has a wrong offset!");

// ScriptStruct DBDBots.DreamPalletSpawnState
// 0x0040 (0x0040 - 0x0000)
struct alignas(0x08) FDreamPalletSpawnState final
{
public:
	uint8                                         Pad_0[0x40];                                       // 0x0000(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDreamPalletSpawnState) == 0x000008, "Wrong alignment on FDreamPalletSpawnState");
static_assert(sizeof(FDreamPalletSpawnState) == 0x000040, "Wrong size on FDreamPalletSpawnState");

// ScriptStruct DBDBots.AISearchLockerInfo
// 0x0060 (0x0060 - 0x0000)
struct alignas(0x08) FAISearchLockerInfo final
{
public:
	uint8                                         Pad_0[0x60];                                       // 0x0000(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAISearchLockerInfo) == 0x000008, "Wrong alignment on FAISearchLockerInfo");
static_assert(sizeof(FAISearchLockerInfo) == 0x000060, "Wrong size on FAISearchLockerInfo");

// ScriptStruct DBDBots.AISelfHelpInteraction
// 0x0080 (0x0080 - 0x0000)
struct FAISelfHelpInteraction final
{
public:
	class FString                                 InteractionID;                                     // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInputInteractionType                         InputType;                                         // 0x0010(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAITunableParameter                    BasicWeight;                                       // 0x0018(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	bool                                          UsesSurvivorItem;                                  // 0x0078(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          PreferHelpFromOther;                               // 0x0079(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UsesAISkill;                                       // 0x007A(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7B[0x5];                                       // 0x007B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAISelfHelpInteraction) == 0x000008, "Wrong alignment on FAISelfHelpInteraction");
static_assert(sizeof(FAISelfHelpInteraction) == 0x000080, "Wrong size on FAISelfHelpInteraction");
static_assert(offsetof(FAISelfHelpInteraction, InteractionID) == 0x000000, "Member 'FAISelfHelpInteraction::InteractionID' has a wrong offset!");
static_assert(offsetof(FAISelfHelpInteraction, InputType) == 0x000010, "Member 'FAISelfHelpInteraction::InputType' has a wrong offset!");
static_assert(offsetof(FAISelfHelpInteraction, BasicWeight) == 0x000018, "Member 'FAISelfHelpInteraction::BasicWeight' has a wrong offset!");
static_assert(offsetof(FAISelfHelpInteraction, UsesSurvivorItem) == 0x000078, "Member 'FAISelfHelpInteraction::UsesSurvivorItem' has a wrong offset!");
static_assert(offsetof(FAISelfHelpInteraction, PreferHelpFromOther) == 0x000079, "Member 'FAISelfHelpInteraction::PreferHelpFromOther' has a wrong offset!");
static_assert(offsetof(FAISelfHelpInteraction, UsesAISkill) == 0x00007A, "Member 'FAISelfHelpInteraction::UsesAISkill' has a wrong offset!");

// ScriptStruct DBDBots.AICleansePerkCondition
// 0x0038 (0x0038 - 0x0000)
struct FAICleansePerkCondition final
{
public:
	struct FDataTableDropdown                     CleansePerkID;                                     // 0x0000(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	EArithmeticKeyOperation                       DisplayPercentQuery;                               // 0x0030(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DisplayPercentValue;                               // 0x0034(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAICleansePerkCondition) == 0x000008, "Wrong alignment on FAICleansePerkCondition");
static_assert(sizeof(FAICleansePerkCondition) == 0x000038, "Wrong size on FAICleansePerkCondition");
static_assert(offsetof(FAICleansePerkCondition, CleansePerkID) == 0x000000, "Member 'FAICleansePerkCondition::CleansePerkID' has a wrong offset!");
static_assert(offsetof(FAICleansePerkCondition, DisplayPercentQuery) == 0x000030, "Member 'FAICleansePerkCondition::DisplayPercentQuery' has a wrong offset!");
static_assert(offsetof(FAICleansePerkCondition, DisplayPercentValue) == 0x000034, "Member 'FAICleansePerkCondition::DisplayPercentValue' has a wrong offset!");

// ScriptStruct DBDBots.InteractableWithInteractionId
// 0x0018 (0x0018 - 0x0000)
struct FInteractableWithInteractionId final
{
public:
	TSubclassOf<class AInteractable>              InteractableClass;                                 // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 InteractionID;                                     // 0x0008(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInteractableWithInteractionId) == 0x000008, "Wrong alignment on FInteractableWithInteractionId");
static_assert(sizeof(FInteractableWithInteractionId) == 0x000018, "Wrong size on FInteractableWithInteractionId");
static_assert(offsetof(FInteractableWithInteractionId, InteractableClass) == 0x000000, "Member 'FInteractableWithInteractionId::InteractableClass' has a wrong offset!");
static_assert(offsetof(FInteractableWithInteractionId, InteractionID) == 0x000008, "Member 'FInteractableWithInteractionId::InteractionID' has a wrong offset!");

// ScriptStruct DBDBots.CachedEQSResultData
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x08) FCachedEQSResultData final
{
public:
	uint8                                         Pad_0[0x28];                                       // 0x0000(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCachedEQSResultData) == 0x000008, "Wrong alignment on FCachedEQSResultData");
static_assert(sizeof(FCachedEQSResultData) == 0x000028, "Wrong size on FCachedEQSResultData");

// ScriptStruct DBDBots.DangerStateGameStateMapContainer
// 0x0050 (0x0050 - 0x0000)
struct FDangerStateGameStateMapContainer final
{
public:
	TMap<EAIDangerState, EAIGameState>            Map;                                               // 0x0000(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDangerStateGameStateMapContainer) == 0x000008, "Wrong alignment on FDangerStateGameStateMapContainer");
static_assert(sizeof(FDangerStateGameStateMapContainer) == 0x000050, "Wrong size on FDangerStateGameStateMapContainer");
static_assert(offsetof(FDangerStateGameStateMapContainer, Map) == 0x000000, "Member 'FDangerStateGameStateMapContainer::Map' has a wrong offset!");

// ScriptStruct DBDBots.DangerObjectData
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x04) FDangerObjectData final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDangerObjectData) == 0x000004, "Wrong alignment on FDangerObjectData");
static_assert(sizeof(FDangerObjectData) == 0x000008, "Wrong size on FDangerObjectData");

// ScriptStruct DBDBots.MovementModeNearActor
// 0x0148 (0x0148 - 0x0000)
struct FMovementModeNearActor final
{
public:
	ECharacterMovementTypes                       NearActorMovementMode;                             // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AActor>                     NearActorClass;                                    // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    NearDistanceSquared;                               // 0x0010(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FAIRoll                                SeeActorRoll;                                      // 0x0070(0x00C8)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	TArray<EPlayerRole>                           ApplyToPlayerRoles;                                // 0x0138(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMovementModeNearActor) == 0x000008, "Wrong alignment on FMovementModeNearActor");
static_assert(sizeof(FMovementModeNearActor) == 0x000148, "Wrong size on FMovementModeNearActor");
static_assert(offsetof(FMovementModeNearActor, NearActorMovementMode) == 0x000000, "Member 'FMovementModeNearActor::NearActorMovementMode' has a wrong offset!");
static_assert(offsetof(FMovementModeNearActor, NearActorClass) == 0x000008, "Member 'FMovementModeNearActor::NearActorClass' has a wrong offset!");
static_assert(offsetof(FMovementModeNearActor, NearDistanceSquared) == 0x000010, "Member 'FMovementModeNearActor::NearDistanceSquared' has a wrong offset!");
static_assert(offsetof(FMovementModeNearActor, SeeActorRoll) == 0x000070, "Member 'FMovementModeNearActor::SeeActorRoll' has a wrong offset!");
static_assert(offsetof(FMovementModeNearActor, ApplyToPlayerRoles) == 0x000138, "Member 'FMovementModeNearActor::ApplyToPlayerRoles' has a wrong offset!");

// ScriptStruct DBDBots.AISkillCharacterClass
// 0x0018 (0x0018 - 0x0000)
struct FAISkillCharacterClass final
{
public:
	TArray<struct FCharacterClassDropdown>        Classes;                                           // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class UAISkill*                               Skill;                                             // 0x0010(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAISkillCharacterClass) == 0x000008, "Wrong alignment on FAISkillCharacterClass");
static_assert(sizeof(FAISkillCharacterClass) == 0x000018, "Wrong size on FAISkillCharacterClass");
static_assert(offsetof(FAISkillCharacterClass, Classes) == 0x000000, "Member 'FAISkillCharacterClass::Classes' has a wrong offset!");
static_assert(offsetof(FAISkillCharacterClass, Skill) == 0x000010, "Member 'FAISkillCharacterClass::Skill' has a wrong offset!");

// ScriptStruct DBDBots.AISkillPerk
// 0x0018 (0x0018 - 0x0000)
struct FAISkillPerk final
{
public:
	TArray<struct FPerkIdDropdown>                Perks;                                             // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class UAISkill*                               Skill;                                             // 0x0010(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAISkillPerk) == 0x000008, "Wrong alignment on FAISkillPerk");
static_assert(sizeof(FAISkillPerk) == 0x000018, "Wrong size on FAISkillPerk");
static_assert(offsetof(FAISkillPerk, Perks) == 0x000000, "Member 'FAISkillPerk::Perks' has a wrong offset!");
static_assert(offsetof(FAISkillPerk, Skill) == 0x000010, "Member 'FAISkillPerk::Skill' has a wrong offset!");

// ScriptStruct DBDBots.AIPerkTunnableWeight
// 0x0090 (0x0090 - 0x0000)
struct FAIPerkTunnableWeight final
{
public:
	struct FDataTableDropdown                     PerkId;                                            // 0x0000(0x0030)(Edit, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    Weight;                                            // 0x0030(0x0060)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIPerkTunnableWeight) == 0x000008, "Wrong alignment on FAIPerkTunnableWeight");
static_assert(sizeof(FAIPerkTunnableWeight) == 0x000090, "Wrong size on FAIPerkTunnableWeight");
static_assert(offsetof(FAIPerkTunnableWeight, PerkId) == 0x000000, "Member 'FAIPerkTunnableWeight::PerkId' has a wrong offset!");
static_assert(offsetof(FAIPerkTunnableWeight, Weight) == 0x000030, "Member 'FAIPerkTunnableWeight::Weight' has a wrong offset!");

// ScriptStruct DBDBots.AIPerkTunableWeightArray
// 0x0010 (0x0010 - 0x0000)
struct FAIPerkTunableWeightArray final
{
public:
	TArray<struct FAIPerkTunnableWeight>          Perks;                                             // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIPerkTunableWeightArray) == 0x000008, "Wrong alignment on FAIPerkTunableWeightArray");
static_assert(sizeof(FAIPerkTunableWeightArray) == 0x000010, "Wrong size on FAIPerkTunableWeightArray");
static_assert(offsetof(FAIPerkTunableWeightArray, Perks) == 0x000000, "Member 'FAIPerkTunableWeightArray::Perks' has a wrong offset!");

// ScriptStruct DBDBots.AISkillEvent
// 0x0030 (0x0030 - 0x0000)
struct FAISkillEvent final
{
public:
	TArray<class FName>                           SpecialEventIds;                                   // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<EGameType>                             GameTypes;                                         // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          RequiresBoth;                                      // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAISkill*                               Skill;                                             // 0x0028(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAISkillEvent) == 0x000008, "Wrong alignment on FAISkillEvent");
static_assert(sizeof(FAISkillEvent) == 0x000030, "Wrong size on FAISkillEvent");
static_assert(offsetof(FAISkillEvent, SpecialEventIds) == 0x000000, "Member 'FAISkillEvent::SpecialEventIds' has a wrong offset!");
static_assert(offsetof(FAISkillEvent, GameTypes) == 0x000010, "Member 'FAISkillEvent::GameTypes' has a wrong offset!");
static_assert(offsetof(FAISkillEvent, RequiresBoth) == 0x000020, "Member 'FAISkillEvent::RequiresBoth' has a wrong offset!");
static_assert(offsetof(FAISkillEvent, Skill) == 0x000028, "Member 'FAISkillEvent::Skill' has a wrong offset!");

// ScriptStruct DBDBots.AISkillDynamicSubtreeStruct
// 0x0058 (0x0058 - 0x0000)
struct FAISkillDynamicSubtreeStruct final
{
public:
	TMap<class UAISkill*, class UBehaviorTree*>   AISkillDynamicSubtreeMap;                          // 0x0000(0x0050)(Transient, NativeAccessSpecifierPublic)
	class UBehaviorTree*                          ConnectingSubtree;                                 // 0x0050(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAISkillDynamicSubtreeStruct) == 0x000008, "Wrong alignment on FAISkillDynamicSubtreeStruct");
static_assert(sizeof(FAISkillDynamicSubtreeStruct) == 0x000058, "Wrong size on FAISkillDynamicSubtreeStruct");
static_assert(offsetof(FAISkillDynamicSubtreeStruct, AISkillDynamicSubtreeMap) == 0x000000, "Member 'FAISkillDynamicSubtreeStruct::AISkillDynamicSubtreeMap' has a wrong offset!");
static_assert(offsetof(FAISkillDynamicSubtreeStruct, ConnectingSubtree) == 0x000050, "Member 'FAISkillDynamicSubtreeStruct::ConnectingSubtree' has a wrong offset!");

// ScriptStruct DBDBots.AISkillPausingAISkills
// 0x0010 (0x0010 - 0x0000)
struct FAISkillPausingAISkills final
{
public:
	TArray<class UAISkill*>                       PausingAISkills;                                   // 0x0000(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAISkillPausingAISkills) == 0x000008, "Wrong alignment on FAISkillPausingAISkills");
static_assert(sizeof(FAISkillPausingAISkills) == 0x000010, "Wrong size on FAISkillPausingAISkills");
static_assert(offsetof(FAISkillPausingAISkills, PausingAISkills) == 0x000000, "Member 'FAISkillPausingAISkills::PausingAISkills' has a wrong offset!");

// ScriptStruct DBDBots.WeightedWishedObjectMapContainer
// 0x0050 (0x0050 - 0x0000)
struct alignas(0x08) FWeightedWishedObjectMapContainer final
{
public:
	uint8                                         Pad_0[0x50];                                       // 0x0000(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWeightedWishedObjectMapContainer) == 0x000008, "Wrong alignment on FWeightedWishedObjectMapContainer");
static_assert(sizeof(FWeightedWishedObjectMapContainer) == 0x000050, "Wrong size on FWeightedWishedObjectMapContainer");

// ScriptStruct DBDBots.AITrackedEnemyData
// 0x0180 (0x0180 - 0x0000)
struct FAITrackedEnemyData final
{
public:
	uint8                                         Pad_0[0xF0];                                       // 0x0000(0x00F0)(Fixing Size After Last Property [ Dumper-7 ])
	class UAIEnemyTargetPrediction*               EnemyTargetPrediction;                             // 0x00F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F8[0x88];                                      // 0x00F8(0x0088)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAITrackedEnemyData) == 0x000008, "Wrong alignment on FAITrackedEnemyData");
static_assert(sizeof(FAITrackedEnemyData) == 0x000180, "Wrong size on FAITrackedEnemyData");
static_assert(offsetof(FAITrackedEnemyData, EnemyTargetPrediction) == 0x0000F0, "Member 'FAITrackedEnemyData::EnemyTargetPrediction' has a wrong offset!");

// ScriptStruct DBDBots.EnvQueryTestLoopData
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FEnvQueryTestLoopData final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEnvQueryTestLoopData) == 0x000008, "Wrong alignment on FEnvQueryTestLoopData");
static_assert(sizeof(FEnvQueryTestLoopData) == 0x000020, "Wrong size on FEnvQueryTestLoopData");

// ScriptStruct DBDBots.AIEstimatedLocation
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FAIEstimatedLocation final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIEstimatedLocation) == 0x000008, "Wrong alignment on FAIEstimatedLocation");
static_assert(sizeof(FAIEstimatedLocation) == 0x000020, "Wrong size on FAIEstimatedLocation");

// ScriptStruct DBDBots.AIGoal
// 0x0018 (0x0018 - 0x0000)
struct FAIGoal final
{
public:
	class UObject*                                Source;                                            // 0x0000(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                MetaGoal;                                          // 0x0008(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                Goal;                                              // 0x0010(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIGoal) == 0x000008, "Wrong alignment on FAIGoal");
static_assert(sizeof(FAIGoal) == 0x000018, "Wrong size on FAIGoal");
static_assert(offsetof(FAIGoal, Source) == 0x000000, "Member 'FAIGoal::Source' has a wrong offset!");
static_assert(offsetof(FAIGoal, MetaGoal) == 0x000008, "Member 'FAIGoal::MetaGoal' has a wrong offset!");
static_assert(offsetof(FAIGoal, Goal) == 0x000010, "Member 'FAIGoal::Goal' has a wrong offset!");

// ScriptStruct DBDBots.AIGoalWeight
// 0x0030 (0x0030 - 0x0000)
struct FAIGoalWeight final
{
public:
	struct FAIGoal                                GoalInfo;                                          // 0x0000(0x0018)(NoDestructor, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 WeightDebug;                                       // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIGoalWeight) == 0x000008, "Wrong alignment on FAIGoalWeight");
static_assert(sizeof(FAIGoalWeight) == 0x000030, "Wrong size on FAIGoalWeight");
static_assert(offsetof(FAIGoalWeight, GoalInfo) == 0x000000, "Member 'FAIGoalWeight::GoalInfo' has a wrong offset!");
static_assert(offsetof(FAIGoalWeight, Weight) == 0x000018, "Member 'FAIGoalWeight::Weight' has a wrong offset!");
static_assert(offsetof(FAIGoalWeight, WeightDebug) == 0x000020, "Member 'FAIGoalWeight::WeightDebug' has a wrong offset!");

// ScriptStruct DBDBots.AIGoalWeightContainer
// 0x0010 (0x0010 - 0x0000)
struct FAIGoalWeightContainer final
{
public:
	TArray<struct FAIGoalWeight>                  WeightedGoals;                                     // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIGoalWeightContainer) == 0x000008, "Wrong alignment on FAIGoalWeightContainer");
static_assert(sizeof(FAIGoalWeightContainer) == 0x000010, "Wrong size on FAIGoalWeightContainer");
static_assert(offsetof(FAIGoalWeightContainer, WeightedGoals) == 0x000000, "Member 'FAIGoalWeightContainer::WeightedGoals' has a wrong offset!");

// ScriptStruct DBDBots.FocusPointData
// 0x0050 (0x0050 - 0x0000)
struct alignas(0x08) FFocusPointData final
{
public:
	uint8                                         Pad_0[0x50];                                       // 0x0000(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFocusPointData) == 0x000008, "Wrong alignment on FFocusPointData");
static_assert(sizeof(FFocusPointData) == 0x000050, "Wrong size on FFocusPointData");

// ScriptStruct DBDBots.GameStatePressureZoneLevelMapContainer
// 0x0050 (0x0050 - 0x0000)
struct FGameStatePressureZoneLevelMapContainer final
{
public:
	TMap<EAIGameState, EAIPressureZoneLevel>      Map;                                               // 0x0000(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameStatePressureZoneLevelMapContainer) == 0x000008, "Wrong alignment on FGameStatePressureZoneLevelMapContainer");
static_assert(sizeof(FGameStatePressureZoneLevelMapContainer) == 0x000050, "Wrong size on FGameStatePressureZoneLevelMapContainer");
static_assert(offsetof(FGameStatePressureZoneLevelMapContainer, Map) == 0x000000, "Member 'FGameStatePressureZoneLevelMapContainer::Map' has a wrong offset!");

// ScriptStruct DBDBots.KillerAttackProfile
// 0x0048 (0x0048 - 0x0000)
struct alignas(0x08) FKillerAttackProfile final
{
public:
	uint8                                         Pad_0[0x48];                                       // 0x0000(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FKillerAttackProfile) == 0x000008, "Wrong alignment on FKillerAttackProfile");
static_assert(sizeof(FKillerAttackProfile) == 0x000048, "Wrong size on FKillerAttackProfile");

// ScriptStruct DBDBots.RelevantNodeMemory
// 0x0018 (0x0018 - 0x0000)
struct FRelevantNodeMemory final
{
public:
	class UBTNode*                                Node;                                              // 0x0000(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x10];                                       // 0x0008(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRelevantNodeMemory) == 0x000008, "Wrong alignment on FRelevantNodeMemory");
static_assert(sizeof(FRelevantNodeMemory) == 0x000018, "Wrong size on FRelevantNodeMemory");
static_assert(offsetof(FRelevantNodeMemory, Node) == 0x000000, "Member 'FRelevantNodeMemory::Node' has a wrong offset!");

// ScriptStruct DBDBots.WeightedWishedObjectData
// 0x0010 (0x0010 - 0x0000)
struct FWeightedWishedObjectData final
{
public:
	float                                         Weight;                                            // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAISkill_Find*                          SkillSource;                                       // 0x0008(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWeightedWishedObjectData) == 0x000008, "Wrong alignment on FWeightedWishedObjectData");
static_assert(sizeof(FWeightedWishedObjectData) == 0x000010, "Wrong size on FWeightedWishedObjectData");
static_assert(offsetof(FWeightedWishedObjectData, Weight) == 0x000000, "Member 'FWeightedWishedObjectData::Weight' has a wrong offset!");
static_assert(offsetof(FWeightedWishedObjectData, SkillSource) == 0x000008, "Member 'FWeightedWishedObjectData::SkillSource' has a wrong offset!");

// ScriptStruct DBDBots.MindFocusObjectEntry
// 0x0078 (0x0078 - 0x0000)
struct FMindFocusObjectEntry final
{
public:
	TArray<class UObject*>                        FocusedBy;                                         // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         FocusedStartTime;                                  // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, float>                      CooldownMap;                                       // 0x0018(0x0050)(NativeAccessSpecifierPublic)
	uint8                                         Pad_68[0x10];                                      // 0x0068(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMindFocusObjectEntry) == 0x000008, "Wrong alignment on FMindFocusObjectEntry");
static_assert(sizeof(FMindFocusObjectEntry) == 0x000078, "Wrong size on FMindFocusObjectEntry");
static_assert(offsetof(FMindFocusObjectEntry, FocusedBy) == 0x000000, "Member 'FMindFocusObjectEntry::FocusedBy' has a wrong offset!");
static_assert(offsetof(FMindFocusObjectEntry, FocusedStartTime) == 0x000010, "Member 'FMindFocusObjectEntry::FocusedStartTime' has a wrong offset!");
static_assert(offsetof(FMindFocusObjectEntry, CooldownMap) == 0x000018, "Member 'FMindFocusObjectEntry::CooldownMap' has a wrong offset!");

// ScriptStruct DBDBots.ExplorableTileInfo
// 0x0048 (0x0048 - 0x0000)
struct FExplorableTileInfo final
{
public:
	struct FGuid                                  ID;                                                // 0x0000(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBox                                   Bounds;                                            // 0x0010(0x0038)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FExplorableTileInfo) == 0x000008, "Wrong alignment on FExplorableTileInfo");
static_assert(sizeof(FExplorableTileInfo) == 0x000048, "Wrong size on FExplorableTileInfo");
static_assert(offsetof(FExplorableTileInfo, ID) == 0x000000, "Member 'FExplorableTileInfo::ID' has a wrong offset!");
static_assert(offsetof(FExplorableTileInfo, Bounds) == 0x000010, "Member 'FExplorableTileInfo::Bounds' has a wrong offset!");

// ScriptStruct DBDBots.NavObstacleEdge
// 0x00B0 (0x00B0 - 0x0000)
struct alignas(0x08) FNavObstacleEdge final
{
public:
	uint8                                         Pad_0[0xB0];                                       // 0x0000(0x00B0)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNavObstacleEdge) == 0x000008, "Wrong alignment on FNavObstacleEdge");
static_assert(sizeof(FNavObstacleEdge) == 0x0000B0, "Wrong size on FNavObstacleEdge");

// ScriptStruct DBDBots.MoveLinkPlayerInfo
// 0x0040 (0x0040 - 0x0000)
struct alignas(0x08) FMoveLinkPlayerInfo final
{
public:
	uint8                                         Pad_0[0x40];                                       // 0x0000(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMoveLinkPlayerInfo) == 0x000008, "Wrong alignment on FMoveLinkPlayerInfo");
static_assert(sizeof(FMoveLinkPlayerInfo) == 0x000040, "Wrong size on FMoveLinkPlayerInfo");

// ScriptStruct DBDBots.NavLinkInteractPlayerSetup
// 0x0078 (0x0078 - 0x0000)
struct FNavLinkInteractPlayerSetup final
{
public:
	EPawnInputPressTypes                          Input;                                             // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         InteractionIds;                                    // 0x0008(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    InputTimeDeviationInChase;                         // 0x0018(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNavLinkInteractPlayerSetup) == 0x000008, "Wrong alignment on FNavLinkInteractPlayerSetup");
static_assert(sizeof(FNavLinkInteractPlayerSetup) == 0x000078, "Wrong size on FNavLinkInteractPlayerSetup");
static_assert(offsetof(FNavLinkInteractPlayerSetup, Input) == 0x000000, "Member 'FNavLinkInteractPlayerSetup::Input' has a wrong offset!");
static_assert(offsetof(FNavLinkInteractPlayerSetup, InteractionIds) == 0x000008, "Member 'FNavLinkInteractPlayerSetup::InteractionIds' has a wrong offset!");
static_assert(offsetof(FNavLinkInteractPlayerSetup, InputTimeDeviationInChase) == 0x000018, "Member 'FNavLinkInteractPlayerSetup::InputTimeDeviationInChase' has a wrong offset!");

// ScriptStruct DBDBots.NavMovePathReshapeData
// 0x0060 (0x0060 - 0x0000)
struct alignas(0x08) FNavMovePathReshapeData final
{
public:
	uint8                                         Pad_0[0x60];                                       // 0x0000(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNavMovePathReshapeData) == 0x000008, "Wrong alignment on FNavMovePathReshapeData");
static_assert(sizeof(FNavMovePathReshapeData) == 0x000060, "Wrong size on FNavMovePathReshapeData");

// ScriptStruct DBDBots.NavObstacleRow
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FNavObstacleRow final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNavObstacleRow) == 0x000008, "Wrong alignment on FNavObstacleRow");
static_assert(sizeof(FNavObstacleRow) == 0x000010, "Wrong size on FNavObstacleRow");

// ScriptStruct DBDBots.PathToLoopInfo
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FPathToLoopInfo final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPathToLoopInfo) == 0x000008, "Wrong alignment on FPathToLoopInfo");
static_assert(sizeof(FPathToLoopInfo) == 0x000018, "Wrong size on FPathToLoopInfo");

}

