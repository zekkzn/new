#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: TheOni

#include "Basic.hpp"

#include "DeadByDaylight_structs.hpp"
#include "DeadByDaylight_classes.hpp"
#include "DBDBots_classes.hpp"
#include "DBDCompetence_classes.hpp"
#include "DBDGameplay_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "TheOni_structs.hpp"
#include "Engine_classes.hpp"
#include "DBDAnimation_classes.hpp"
#include "DBDAttack_classes.hpp"
#include "AnimationUtilities_structs.hpp"


namespace SDK
{

// Class TheOni.BloodOrbCollection
// 0x0048 (0x00F0 - 0x00A8)
class UBloodOrbCollection final : public UActorComponent
{
public:
	TArray<class ABloodOrb*>                      _bloodOrbs;                                        // 0x00A8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B8[0x38];                                      // 0x00B8(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BloodOrbCollection">();
	}
	static class UBloodOrbCollection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBloodOrbCollection>();
	}
};
static_assert(alignof(UBloodOrbCollection) == 0x000008, "Wrong alignment on UBloodOrbCollection");
static_assert(sizeof(UBloodOrbCollection) == 0x0000F0, "Wrong size on UBloodOrbCollection");
static_assert(offsetof(UBloodOrbCollection, _bloodOrbs) == 0x0000A8, "Member 'UBloodOrbCollection::_bloodOrbs' has a wrong offset!");

// Class TheOni.AbsorbBloodOrbsInteraction
// 0x0040 (0x07C0 - 0x0780)
class UAbsorbBloodOrbsInteraction final : public UInteractionDefinition
{
public:
	uint8                                         Pad_778[0x48];                                     // 0x0778(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetPlayerOwner(const class ADBDPlayer* Player);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbsorbBloodOrbsInteraction">();
	}
	static class UAbsorbBloodOrbsInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbsorbBloodOrbsInteraction>();
	}
};
static_assert(alignof(UAbsorbBloodOrbsInteraction) == 0x000010, "Wrong alignment on UAbsorbBloodOrbsInteraction");
static_assert(sizeof(UAbsorbBloodOrbsInteraction) == 0x0007C0, "Wrong size on UAbsorbBloodOrbsInteraction");

// Class TheOni.AISkill_FindOrb
// 0x0008 (0x02F8 - 0x02F0)
class UAISkill_FindOrb final : public UAISkill_Find
{
public:
	uint8                                         Pad_2F0[0x8];                                      // 0x02F0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_FindOrb">();
	}
	static class UAISkill_FindOrb* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_FindOrb>();
	}
};
static_assert(alignof(UAISkill_FindOrb) == 0x000008, "Wrong alignment on UAISkill_FindOrb");
static_assert(sizeof(UAISkill_FindOrb) == 0x0002F8, "Wrong size on UAISkill_FindOrb");

// Class TheOni.AISkill_InteractionTarget_DashOni
// 0x0000 (0x0348 - 0x0348)
class UAISkill_InteractionTarget_DashOni final : public UAISkill_InteractionTarget_Dash
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_InteractionTarget_DashOni">();
	}
	static class UAISkill_InteractionTarget_DashOni* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_InteractionTarget_DashOni>();
	}
};
static_assert(alignof(UAISkill_InteractionTarget_DashOni) == 0x000008, "Wrong alignment on UAISkill_InteractionTarget_DashOni");
static_assert(sizeof(UAISkill_InteractionTarget_DashOni) == 0x000348, "Wrong size on UAISkill_InteractionTarget_DashOni");

// Class TheOni.AISkill_InteractionTarget_DemonMode
// 0x0000 (0x0348 - 0x0348)
class UAISkill_InteractionTarget_DemonMode final : public UAISkill_InteractionTarget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_InteractionTarget_DemonMode">();
	}
	static class UAISkill_InteractionTarget_DemonMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_InteractionTarget_DemonMode>();
	}
};
static_assert(alignof(UAISkill_InteractionTarget_DemonMode) == 0x000008, "Wrong alignment on UAISkill_InteractionTarget_DemonMode");
static_assert(sizeof(UAISkill_InteractionTarget_DemonMode) == 0x000348, "Wrong size on UAISkill_InteractionTarget_DemonMode");

// Class TheOni.AISkill_Interaction_OrbAbsorb
// 0x0000 (0x0280 - 0x0280)
class UAISkill_Interaction_OrbAbsorb final : public UAISkill_Interaction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_Interaction_OrbAbsorb">();
	}
	static class UAISkill_Interaction_OrbAbsorb* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_Interaction_OrbAbsorb>();
	}
};
static_assert(alignof(UAISkill_Interaction_OrbAbsorb) == 0x000008, "Wrong alignment on UAISkill_Interaction_OrbAbsorb");
static_assert(sizeof(UAISkill_Interaction_OrbAbsorb) == 0x000280, "Wrong size on UAISkill_Interaction_OrbAbsorb");

// Class TheOni.BloodOrb
// 0x0060 (0x0300 - 0x02A0)
class ABloodOrb final : public AActor
{
public:
	struct FFloatInterval                         _randomMoveDelayInterval;                          // 0x02A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        _absorbReference;                                  // 0x02A8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDBDOutlineComponent*                   _outlineComponent;                                 // 0x02B0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _despawnDelay;                                     // 0x02B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2BC[0x4];                                      // 0x02BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class ADBDPlayer>              _droppingPlayer;                                   // 0x02C0(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EBloodOrbState                                _state;                                            // 0x02C8(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C9[0x7];                                      // 0x02C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBloodOrbFadeComponent*                 _fadeComponent;                                    // 0x02D0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D8[0x28];                                     // 0x02D8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_Despawn();
	void Authority_DestroyBloodOrb();
	void Authority_OnDropFinished();
	void Authority_OnDropped(const class ADBDPlayer* DroppedBy, const float ImpulseFactor);
	void OnAbsorbedCosmetic();
	void OnDestroyedCosmetic();
	void OnIsAttractedChangedCosmetic(const bool IsAttracted);
	void OnRep_State(const EBloodOrbState OldState);
	void UpdateAbsorbed_Cosmetic(const struct FVector& Destination, class ADBDPlayer* Absorber, const float DeltaTime);
	void UpdateAttracted_Cosmetic(const struct FVector& Destination, class ADBDPlayer* Absorber, const float DeltaTime);

	class ADBDPlayer* GetDroppingPlayer() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BloodOrb">();
	}
	static class ABloodOrb* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABloodOrb>();
	}
};
static_assert(alignof(ABloodOrb) == 0x000008, "Wrong alignment on ABloodOrb");
static_assert(sizeof(ABloodOrb) == 0x000300, "Wrong size on ABloodOrb");
static_assert(offsetof(ABloodOrb, _randomMoveDelayInterval) == 0x0002A0, "Member 'ABloodOrb::_randomMoveDelayInterval' has a wrong offset!");
static_assert(offsetof(ABloodOrb, _absorbReference) == 0x0002A8, "Member 'ABloodOrb::_absorbReference' has a wrong offset!");
static_assert(offsetof(ABloodOrb, _outlineComponent) == 0x0002B0, "Member 'ABloodOrb::_outlineComponent' has a wrong offset!");
static_assert(offsetof(ABloodOrb, _despawnDelay) == 0x0002B8, "Member 'ABloodOrb::_despawnDelay' has a wrong offset!");
static_assert(offsetof(ABloodOrb, _droppingPlayer) == 0x0002C0, "Member 'ABloodOrb::_droppingPlayer' has a wrong offset!");
static_assert(offsetof(ABloodOrb, _state) == 0x0002C8, "Member 'ABloodOrb::_state' has a wrong offset!");
static_assert(offsetof(ABloodOrb, _fadeComponent) == 0x0002D0, "Member 'ABloodOrb::_fadeComponent' has a wrong offset!");

// Class TheOni.BloodOrbAbsorberComponent
// 0x0068 (0x0110 - 0x00A8)
class UBloodOrbAbsorberComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             Authority_OnBloodOrbAbsorbed;                      // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnIsAbsorbingChanged;                              // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FVector                                AbsorbLocationOffset;                              // 0x00C8(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E0[0x20];                                      // 0x00E0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UBloodOrbDropperComponent*>      _camperBloodOrbDropperComponents;                  // 0x0100(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	void SetInAbsorbMode(const bool InAbsorptionMode);

	bool IsInAbsorbMode() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BloodOrbAbsorberComponent">();
	}
	static class UBloodOrbAbsorberComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBloodOrbAbsorberComponent>();
	}
};
static_assert(alignof(UBloodOrbAbsorberComponent) == 0x000008, "Wrong alignment on UBloodOrbAbsorberComponent");
static_assert(sizeof(UBloodOrbAbsorberComponent) == 0x000110, "Wrong size on UBloodOrbAbsorberComponent");
static_assert(offsetof(UBloodOrbAbsorberComponent, Authority_OnBloodOrbAbsorbed) == 0x0000A8, "Member 'UBloodOrbAbsorberComponent::Authority_OnBloodOrbAbsorbed' has a wrong offset!");
static_assert(offsetof(UBloodOrbAbsorberComponent, OnIsAbsorbingChanged) == 0x0000B8, "Member 'UBloodOrbAbsorberComponent::OnIsAbsorbingChanged' has a wrong offset!");
static_assert(offsetof(UBloodOrbAbsorberComponent, AbsorbLocationOffset) == 0x0000C8, "Member 'UBloodOrbAbsorberComponent::AbsorbLocationOffset' has a wrong offset!");
static_assert(offsetof(UBloodOrbAbsorberComponent, _camperBloodOrbDropperComponents) == 0x000100, "Member 'UBloodOrbAbsorberComponent::_camperBloodOrbDropperComponents' has a wrong offset!");

// Class TheOni.BloodOrbConfiguratorComponent
// 0x0070 (0x0118 - 0x00A8)
class UBloodOrbConfiguratorComponent final : public UActorComponent
{
public:
	TSubclassOf<class ABloodOrb>                  _bloodOrbClass;                                    // 0x00A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FGameEventBloodOrbDropParams>   _bloodOrbDropGameEvents;                           // 0x00B0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         _fadeDuration;                                     // 0x00C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _initialFadeOutDelay;                              // 0x00C4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           _bloodOrbAuraColor;                                // 0x00C8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           _bloodOrbAttractedAuraColor;                       // 0x00D8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _bloodOrbVisibilityRangeInterpolationSpeed;        // 0x00E8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_EC[0x4];                                       // 0x00EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AMobileBloodOrbRenderer>    _mobileBloodOrbRendererClass;                      // 0x00F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F8[0x20];                                      // 0x00F8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnLevelReadyToPlay();

	void Authority_UpdateSurvivorBloodOrbDropperOnCrouchModifier(const class ADBDPlayer* Killer) const;
	void UpdateBloodOrbAttractSpeed(class UBloodOrbAbsorberComponent* BloodOrbAbsorberComponent, class ADBDPlayer* Killer) const;
	void UpdateKillerBloodOrbVisiblityRanges(class UBloodOrbVisibilityComponent* BloodOrbVisibilityComponent, class ADBDPlayer* Killer) const;
	void UpdateSurvivorBloodOrbVisibilityRange(class UBloodOrbVisibilityComponent* BloodOrbVisibilityComponent, const class ADBDPlayer* Killer) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BloodOrbConfiguratorComponent">();
	}
	static class UBloodOrbConfiguratorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBloodOrbConfiguratorComponent>();
	}
};
static_assert(alignof(UBloodOrbConfiguratorComponent) == 0x000008, "Wrong alignment on UBloodOrbConfiguratorComponent");
static_assert(sizeof(UBloodOrbConfiguratorComponent) == 0x000118, "Wrong size on UBloodOrbConfiguratorComponent");
static_assert(offsetof(UBloodOrbConfiguratorComponent, _bloodOrbClass) == 0x0000A8, "Member 'UBloodOrbConfiguratorComponent::_bloodOrbClass' has a wrong offset!");
static_assert(offsetof(UBloodOrbConfiguratorComponent, _bloodOrbDropGameEvents) == 0x0000B0, "Member 'UBloodOrbConfiguratorComponent::_bloodOrbDropGameEvents' has a wrong offset!");
static_assert(offsetof(UBloodOrbConfiguratorComponent, _fadeDuration) == 0x0000C0, "Member 'UBloodOrbConfiguratorComponent::_fadeDuration' has a wrong offset!");
static_assert(offsetof(UBloodOrbConfiguratorComponent, _initialFadeOutDelay) == 0x0000C4, "Member 'UBloodOrbConfiguratorComponent::_initialFadeOutDelay' has a wrong offset!");
static_assert(offsetof(UBloodOrbConfiguratorComponent, _bloodOrbAuraColor) == 0x0000C8, "Member 'UBloodOrbConfiguratorComponent::_bloodOrbAuraColor' has a wrong offset!");
static_assert(offsetof(UBloodOrbConfiguratorComponent, _bloodOrbAttractedAuraColor) == 0x0000D8, "Member 'UBloodOrbConfiguratorComponent::_bloodOrbAttractedAuraColor' has a wrong offset!");
static_assert(offsetof(UBloodOrbConfiguratorComponent, _bloodOrbVisibilityRangeInterpolationSpeed) == 0x0000E8, "Member 'UBloodOrbConfiguratorComponent::_bloodOrbVisibilityRangeInterpolationSpeed' has a wrong offset!");
static_assert(offsetof(UBloodOrbConfiguratorComponent, _mobileBloodOrbRendererClass) == 0x0000F0, "Member 'UBloodOrbConfiguratorComponent::_mobileBloodOrbRendererClass' has a wrong offset!");

// Class TheOni.BloodOrbDropperComponent
// 0x0078 (0x0120 - 0x00A8)
class UBloodOrbDropperComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x78];                                      // 0x00A8(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnCamperCrouched(const struct FGameplayTag& GameEvent, const struct FGameEventData& GameEventData);
	void Authority_OnCamperUnhooked(const struct FGameplayTag& GameEvent, const struct FGameEventData& GameEventData);
	void Authority_OnOwningCamperDamageStateChanged(const ECamperDamageState OldState, const ECamperDamageState NewState);
	void Authority_SetPaused(const bool Paused);

	void Authority_OnCamperHooked(const struct FGameplayTag& GameEvent, const struct FGameEventData& GameEventData) const;
	void Authority_OnDropOrbsGameEvent(const struct FGameplayTag& GameEvent, const struct FGameEventData& GameEventData, const struct FBloodOrbDropParams& DropParams) const;
	void DBD_DropBloodOrbs(const int32 NumOrbs) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BloodOrbDropperComponent">();
	}
	static class UBloodOrbDropperComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBloodOrbDropperComponent>();
	}
};
static_assert(alignof(UBloodOrbDropperComponent) == 0x000008, "Wrong alignment on UBloodOrbDropperComponent");
static_assert(sizeof(UBloodOrbDropperComponent) == 0x000120, "Wrong size on UBloodOrbDropperComponent");

// Class TheOni.BloodOrbFadeComponent
// 0x0008 (0x00D0 - 0x00C8)
class UBloodOrbFadeComponent final : public UFadeComponent
{
public:
	uint8                                         Pad_C8[0x8];                                       // 0x00C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BloodOrbFadeComponent">();
	}
	static class UBloodOrbFadeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBloodOrbFadeComponent>();
	}
};
static_assert(alignof(UBloodOrbFadeComponent) == 0x000008, "Wrong alignment on UBloodOrbFadeComponent");
static_assert(sizeof(UBloodOrbFadeComponent) == 0x0000D0, "Wrong size on UBloodOrbFadeComponent");

// Class TheOni.BloodOrbOverlapComponent
// 0x0040 (0x00E8 - 0x00A8)
class UBloodOrbOverlapComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _currentOverlappingOrbs;                           // 0x00B0(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B4[0x34];                                      // 0x00B4(0x0034)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnBloodOrbBeginOverlap(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void Authority_OnBloodOrbEndOverlap(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void Authority_OnBloodOrbVisibilityModeChanged(EBloodOrbVisibilityMode VisibilityMode);
	void Authority_OnDestroyedBloodOrb(class AActor* DestroyedActor);
	void OnRep_CurrentOverlappingOrbs(int32 PreviousOverlappingOrbs);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BloodOrbOverlapComponent">();
	}
	static class UBloodOrbOverlapComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBloodOrbOverlapComponent>();
	}
};
static_assert(alignof(UBloodOrbOverlapComponent) == 0x000008, "Wrong alignment on UBloodOrbOverlapComponent");
static_assert(sizeof(UBloodOrbOverlapComponent) == 0x0000E8, "Wrong size on UBloodOrbOverlapComponent");
static_assert(offsetof(UBloodOrbOverlapComponent, _currentOverlappingOrbs) == 0x0000B0, "Member 'UBloodOrbOverlapComponent::_currentOverlappingOrbs' has a wrong offset!");

// Class TheOni.BloodOrbOverlapRevealToKiller
// 0x0028 (0x03A8 - 0x0380)
class UBloodOrbOverlapRevealToKiller final : public UStatusEffect
{
public:
	uint8                                         Pad_380[0x28];                                     // 0x0380(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BloodOrbOverlapRevealToKiller">();
	}
	static class UBloodOrbOverlapRevealToKiller* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBloodOrbOverlapRevealToKiller>();
	}
};
static_assert(alignof(UBloodOrbOverlapRevealToKiller) == 0x000008, "Wrong alignment on UBloodOrbOverlapRevealToKiller");
static_assert(sizeof(UBloodOrbOverlapRevealToKiller) == 0x0003A8, "Wrong size on UBloodOrbOverlapRevealToKiller");

// Class TheOni.BloodOrbStateMonitorComponent
// 0x0070 (0x0118 - 0x00A8)
class UBloodOrbStateMonitorComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnBloodOrbAbsorbedCosmetic;                        // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_B8[0x60];                                      // 0x00B8(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnBloodOrbDestroyed(const class ABloodOrb* BloodOrb);
	void OnBloodOrbSpawned(const class ABloodOrb* BloodOrb);

	void OnBloodOrbStateChanged(const EBloodOrbState OldState, const EBloodOrbState NewState, const class ABloodOrb* BloodOrb) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BloodOrbStateMonitorComponent">();
	}
	static class UBloodOrbStateMonitorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBloodOrbStateMonitorComponent>();
	}
};
static_assert(alignof(UBloodOrbStateMonitorComponent) == 0x000008, "Wrong alignment on UBloodOrbStateMonitorComponent");
static_assert(sizeof(UBloodOrbStateMonitorComponent) == 0x000118, "Wrong size on UBloodOrbStateMonitorComponent");
static_assert(offsetof(UBloodOrbStateMonitorComponent, OnBloodOrbAbsorbedCosmetic) == 0x0000A8, "Member 'UBloodOrbStateMonitorComponent::OnBloodOrbAbsorbedCosmetic' has a wrong offset!");

// Class TheOni.BloodOrbUtilities
// 0x0000 (0x0030 - 0x0030)
class UBloodOrbUtilities final : public UBlueprintFunctionLibrary
{
public:
	static const TArray<class ABloodOrb*> GetAllBloodOrbs(const class UObject* WorldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BloodOrbUtilities">();
	}
	static class UBloodOrbUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBloodOrbUtilities>();
	}
};
static_assert(alignof(UBloodOrbUtilities) == 0x000008, "Wrong alignment on UBloodOrbUtilities");
static_assert(sizeof(UBloodOrbUtilities) == 0x000030, "Wrong size on UBloodOrbUtilities");

// Class TheOni.BloodOrbVisibilityComponent
// 0x0038 (0x00E0 - 0x00A8)
class UBloodOrbVisibilityComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x38];                                      // 0x00A8(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetAuraVisibilityRange(const float AuraVisibilityRange);
	void SetShowAttractedBloodOrbsAuras(const bool Show);
	void SetVisibilityMode(const EBloodOrbVisibilityMode VisibilityMode);
	void SetVisibilityRange(const float VisibilityRange);

	void OnBloodOrbSpawned(const class ABloodOrb* BloodOrb) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BloodOrbVisibilityComponent">();
	}
	static class UBloodOrbVisibilityComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBloodOrbVisibilityComponent>();
	}
};
static_assert(alignof(UBloodOrbVisibilityComponent) == 0x000008, "Wrong alignment on UBloodOrbVisibilityComponent");
static_assert(sizeof(UBloodOrbVisibilityComponent) == 0x0000E0, "Wrong size on UBloodOrbVisibilityComponent");

// Class TheOni.DemonModeComponent
// 0x0198 (0x0240 - 0x00A8)
class UDemonModeComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnDemonModeReady;                                  // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDemonModeStarted;                                // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDemonModeEnded;                                  // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDemonModeInterruptedDuringStartup;               // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDemonModeInterruptedDuringEnding;                // 0x00E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnChargeGainedAfterAttackCosmetic;                 // 0x00F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnChargeGainedAfterLockerGrabCosmetic;             // 0x0108(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UPowerChargeComponent*                  _powerChargeComponent;                             // 0x0118(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPowerToggleComponent*                  _powerToggleComponent;                             // 0x0120(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInteractionStarterComponent*           _authority_demonModeCooldownStarterComponent;      // 0x0128(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInteractionDefinition*                 _demonModeCooldownInteraction;                     // 0x0130(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_138[0x2C];                                     // 0x0138(0x002C)(Fixing Size After Last Property [ Dumper-7 ])
	EDemonModeState                               _demonModeState;                                   // 0x0164(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_165[0xAB];                                     // 0x0165(0x00AB)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class USkeletalMeshComponent*>         _normalModeCustomization;                          // 0x0210(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class USkeletalMeshComponent*>         _demonModeCustomization;                           // 0x0220(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UParticleSystemComponent*>       _demonModeVfx;                                     // 0x0230(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	void Authority_AddCharge(const float ChargeAmount);
	void Authority_InterruptedMontage(const struct FAnimationMontageDescriptor& Montage, bool Interrupted);
	void Authority_OnChargeChanged(const float CurrentChargePercent);
	void Authority_OnLevelReadyToPlay();
	void Authority_SetDemonModeCooldownInteraction(class UInteractionDefinition* Interaction);
	void DBD_DemonModeForever(const bool Forever);
	void Multicast_DemonModeInterruptedOnEnding();
	void Multicast_DemonModeInterruptedOnStartup();
	void OnCustomizationChanged();
	void ShowDemonModeCustomization(bool ShowDemonMode);

	bool CanStartDemonMode() const;
	float GetChargePercent() const;
	float GetCurrentCharge() const;
	const TArray<class USkeletalMeshComponent*> GetDemonModeCustomization() const;
	EDemonModeState GetDemonModeState() const;
	const TArray<class USkeletalMeshComponent*> GetNormalModeCustomization() const;
	bool IsInDemonMode() const;
	void OnIsPowerChanged(const bool IsInPower) const;
	void OnPowerChargeEmpty() const;
	void OnPowerChargeFull() const;
	bool ShouldLoseDemonModeOnStun() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DemonModeComponent">();
	}
	static class UDemonModeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDemonModeComponent>();
	}
};
static_assert(alignof(UDemonModeComponent) == 0x000008, "Wrong alignment on UDemonModeComponent");
static_assert(sizeof(UDemonModeComponent) == 0x000240, "Wrong size on UDemonModeComponent");
static_assert(offsetof(UDemonModeComponent, OnDemonModeReady) == 0x0000A8, "Member 'UDemonModeComponent::OnDemonModeReady' has a wrong offset!");
static_assert(offsetof(UDemonModeComponent, OnDemonModeStarted) == 0x0000B8, "Member 'UDemonModeComponent::OnDemonModeStarted' has a wrong offset!");
static_assert(offsetof(UDemonModeComponent, OnDemonModeEnded) == 0x0000C8, "Member 'UDemonModeComponent::OnDemonModeEnded' has a wrong offset!");
static_assert(offsetof(UDemonModeComponent, OnDemonModeInterruptedDuringStartup) == 0x0000D8, "Member 'UDemonModeComponent::OnDemonModeInterruptedDuringStartup' has a wrong offset!");
static_assert(offsetof(UDemonModeComponent, OnDemonModeInterruptedDuringEnding) == 0x0000E8, "Member 'UDemonModeComponent::OnDemonModeInterruptedDuringEnding' has a wrong offset!");
static_assert(offsetof(UDemonModeComponent, OnChargeGainedAfterAttackCosmetic) == 0x0000F8, "Member 'UDemonModeComponent::OnChargeGainedAfterAttackCosmetic' has a wrong offset!");
static_assert(offsetof(UDemonModeComponent, OnChargeGainedAfterLockerGrabCosmetic) == 0x000108, "Member 'UDemonModeComponent::OnChargeGainedAfterLockerGrabCosmetic' has a wrong offset!");
static_assert(offsetof(UDemonModeComponent, _powerChargeComponent) == 0x000118, "Member 'UDemonModeComponent::_powerChargeComponent' has a wrong offset!");
static_assert(offsetof(UDemonModeComponent, _powerToggleComponent) == 0x000120, "Member 'UDemonModeComponent::_powerToggleComponent' has a wrong offset!");
static_assert(offsetof(UDemonModeComponent, _authority_demonModeCooldownStarterComponent) == 0x000128, "Member 'UDemonModeComponent::_authority_demonModeCooldownStarterComponent' has a wrong offset!");
static_assert(offsetof(UDemonModeComponent, _demonModeCooldownInteraction) == 0x000130, "Member 'UDemonModeComponent::_demonModeCooldownInteraction' has a wrong offset!");
static_assert(offsetof(UDemonModeComponent, _demonModeState) == 0x000164, "Member 'UDemonModeComponent::_demonModeState' has a wrong offset!");
static_assert(offsetof(UDemonModeComponent, _normalModeCustomization) == 0x000210, "Member 'UDemonModeComponent::_normalModeCustomization' has a wrong offset!");
static_assert(offsetof(UDemonModeComponent, _demonModeCustomization) == 0x000220, "Member 'UDemonModeComponent::_demonModeCustomization' has a wrong offset!");
static_assert(offsetof(UDemonModeComponent, _demonModeVfx) == 0x000230, "Member 'UDemonModeComponent::_demonModeVfx' has a wrong offset!");

// Class TheOni.DemonModeCooldownInteraction
// 0x0020 (0x07A0 - 0x0780)
class UDemonModeCooldownInteraction final : public UInteractionDefinition
{
public:
	uint8                                         Pad_778[0x28];                                     // 0x0778(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnLevelReadyToPlay();
	void SetPlayerOwner(const class ADBDPlayer* Owner);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DemonModeCooldownInteraction">();
	}
	static class UDemonModeCooldownInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDemonModeCooldownInteraction>();
	}
};
static_assert(alignof(UDemonModeCooldownInteraction) == 0x000010, "Wrong alignment on UDemonModeCooldownInteraction");
static_assert(sizeof(UDemonModeCooldownInteraction) == 0x0007A0, "Wrong size on UDemonModeCooldownInteraction");

// Class TheOni.DemonModeMenuComponent
// 0x0020 (0x00C8 - 0x00A8)
class UDemonModeMenuComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x20];                                      // 0x00A8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetInMenuDemonMode(const bool InMenuDemonMode);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DemonModeMenuComponent">();
	}
	static class UDemonModeMenuComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDemonModeMenuComponent>();
	}
};
static_assert(alignof(UDemonModeMenuComponent) == 0x000008, "Wrong alignment on UDemonModeMenuComponent");
static_assert(sizeof(UDemonModeMenuComponent) == 0x0000C8, "Wrong size on UDemonModeMenuComponent");

// Class TheOni.IsPlayerAbsorbingBloodOrbsCondition
// 0x0000 (0x0120 - 0x0120)
class UIsPlayerAbsorbingBloodOrbsCondition final : public UIsPlayerPerformingInteraction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IsPlayerAbsorbingBloodOrbsCondition">();
	}
	static class UIsPlayerAbsorbingBloodOrbsCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIsPlayerAbsorbingBloodOrbsCondition>();
	}
};
static_assert(alignof(UIsPlayerAbsorbingBloodOrbsCondition) == 0x000008, "Wrong alignment on UIsPlayerAbsorbingBloodOrbsCondition");
static_assert(sizeof(UIsPlayerAbsorbingBloodOrbsCondition) == 0x000120, "Wrong size on UIsPlayerAbsorbingBloodOrbsCondition");

// Class TheOni.K18AnimInstance
// 0x0030 (0x0750 - 0x0720)
class UK18AnimInstance final : public UKillerAnimInstance
{
public:
	bool                                          _isAbsorbing;                                      // 0x0720(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isDemonMode;                                      // 0x0721(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isCharging;                                       // 0x0722(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_723[0x1];                                      // 0x0723(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _absorbCharge;                                     // 0x0724(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isDashing;                                        // 0x0728(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_729[0x3];                                      // 0x0729(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _chargeDuration;                                   // 0x072C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _powerAttackOpen;                                  // 0x0730(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EOniAttackType                                _attackType;                                       // 0x0731(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_732[0x1E];                                     // 0x0732(0x001E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void UpdatePowerAttackOpen();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K18AnimInstance">();
	}
	static class UK18AnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK18AnimInstance>();
	}
};
static_assert(alignof(UK18AnimInstance) == 0x000010, "Wrong alignment on UK18AnimInstance");
static_assert(sizeof(UK18AnimInstance) == 0x000750, "Wrong size on UK18AnimInstance");
static_assert(offsetof(UK18AnimInstance, _isAbsorbing) == 0x000720, "Member 'UK18AnimInstance::_isAbsorbing' has a wrong offset!");
static_assert(offsetof(UK18AnimInstance, _isDemonMode) == 0x000721, "Member 'UK18AnimInstance::_isDemonMode' has a wrong offset!");
static_assert(offsetof(UK18AnimInstance, _isCharging) == 0x000722, "Member 'UK18AnimInstance::_isCharging' has a wrong offset!");
static_assert(offsetof(UK18AnimInstance, _absorbCharge) == 0x000724, "Member 'UK18AnimInstance::_absorbCharge' has a wrong offset!");
static_assert(offsetof(UK18AnimInstance, _isDashing) == 0x000728, "Member 'UK18AnimInstance::_isDashing' has a wrong offset!");
static_assert(offsetof(UK18AnimInstance, _chargeDuration) == 0x00072C, "Member 'UK18AnimInstance::_chargeDuration' has a wrong offset!");
static_assert(offsetof(UK18AnimInstance, _powerAttackOpen) == 0x000730, "Member 'UK18AnimInstance::_powerAttackOpen' has a wrong offset!");
static_assert(offsetof(UK18AnimInstance, _attackType) == 0x000731, "Member 'UK18AnimInstance::_attackType' has a wrong offset!");

// Class TheOni.MobileBloodOrbRenderer
// 0x0090 (0x0330 - 0x02A0)
class AMobileBloodOrbRenderer final : public AActor
{
public:
	class UMaterialInstance*                      OrbMaterialInstance;                               // 0x02A0(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstance*                      OutlineMaterialInstance;                           // 0x02A8(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CullInterval;                                      // 0x02B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B4[0x4];                                      // 0x02B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UInstancedStaticMeshComponent*          _ismComponent;                                     // 0x02B8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInstancedStaticMeshComponent*          _outlineIsmComponent;                              // 0x02C0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class ABloodOrb*, struct FBloodOrbInfo>  _instanceMap;                                      // 0x02C8(0x0050)(Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               _outlineMaterialInstanceDynamic;                   // 0x0318(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               _orbMaterialInstanceDynamic;                       // 0x0320(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBloodOrbVisibilityComponent*           _bloodOrbVisibilityComponent;                      // 0x0328(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MobileBloodOrbRenderer">();
	}
	static class AMobileBloodOrbRenderer* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMobileBloodOrbRenderer>();
	}
};
static_assert(alignof(AMobileBloodOrbRenderer) == 0x000008, "Wrong alignment on AMobileBloodOrbRenderer");
static_assert(sizeof(AMobileBloodOrbRenderer) == 0x000330, "Wrong size on AMobileBloodOrbRenderer");
static_assert(offsetof(AMobileBloodOrbRenderer, OrbMaterialInstance) == 0x0002A0, "Member 'AMobileBloodOrbRenderer::OrbMaterialInstance' has a wrong offset!");
static_assert(offsetof(AMobileBloodOrbRenderer, OutlineMaterialInstance) == 0x0002A8, "Member 'AMobileBloodOrbRenderer::OutlineMaterialInstance' has a wrong offset!");
static_assert(offsetof(AMobileBloodOrbRenderer, CullInterval) == 0x0002B0, "Member 'AMobileBloodOrbRenderer::CullInterval' has a wrong offset!");
static_assert(offsetof(AMobileBloodOrbRenderer, _ismComponent) == 0x0002B8, "Member 'AMobileBloodOrbRenderer::_ismComponent' has a wrong offset!");
static_assert(offsetof(AMobileBloodOrbRenderer, _outlineIsmComponent) == 0x0002C0, "Member 'AMobileBloodOrbRenderer::_outlineIsmComponent' has a wrong offset!");
static_assert(offsetof(AMobileBloodOrbRenderer, _instanceMap) == 0x0002C8, "Member 'AMobileBloodOrbRenderer::_instanceMap' has a wrong offset!");
static_assert(offsetof(AMobileBloodOrbRenderer, _outlineMaterialInstanceDynamic) == 0x000318, "Member 'AMobileBloodOrbRenderer::_outlineMaterialInstanceDynamic' has a wrong offset!");
static_assert(offsetof(AMobileBloodOrbRenderer, _orbMaterialInstanceDynamic) == 0x000320, "Member 'AMobileBloodOrbRenderer::_orbMaterialInstanceDynamic' has a wrong offset!");
static_assert(offsetof(AMobileBloodOrbRenderer, _bloodOrbVisibilityComponent) == 0x000328, "Member 'AMobileBloodOrbRenderer::_bloodOrbVisibilityComponent' has a wrong offset!");

// Class TheOni.OniAttackPicker
// 0x0018 (0x00C0 - 0x00A8)
class UOniAttackPicker final : public USlasherAttackPickerComponent
{
public:
	uint8                                         Pad_A8[0x18];                                      // 0x00A8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OniAttackPicker">();
	}
	static class UOniAttackPicker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOniAttackPicker>();
	}
};
static_assert(alignof(UOniAttackPicker) == 0x000008, "Wrong alignment on UOniAttackPicker");
static_assert(sizeof(UOniAttackPicker) == 0x0000C0, "Wrong size on UOniAttackPicker");

// Class TheOni.OniBasicAttack
// 0x0010 (0x0430 - 0x0420)
class UOniBasicAttack final : public UPounceAttack
{
public:
	uint8                                         Pad_420[0x10];                                     // 0x0420(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OniBasicAttack">();
	}
	static class UOniBasicAttack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOniBasicAttack>();
	}
};
static_assert(alignof(UOniBasicAttack) == 0x000010, "Wrong alignment on UOniBasicAttack");
static_assert(sizeof(UOniBasicAttack) == 0x000430, "Wrong size on UOniBasicAttack");

// Class TheOni.OniBasicAttackSuccessSubstate
// 0x0000 (0x0118 - 0x0118)
class UOniBasicAttackSuccessSubstate final : public UPounceAttackSuccessSubstate
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OniBasicAttackSuccessSubstate">();
	}
	static class UOniBasicAttackSuccessSubstate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOniBasicAttackSuccessSubstate>();
	}
};
static_assert(alignof(UOniBasicAttackSuccessSubstate) == 0x000008, "Wrong alignment on UOniBasicAttackSuccessSubstate");
static_assert(sizeof(UOniBasicAttackSuccessSubstate) == 0x000118, "Wrong size on UOniBasicAttackSuccessSubstate");

// Class TheOni.OniCustomizationItemAnimInstance
// 0x0020 (0x0370 - 0x0350)
class UOniCustomizationItemAnimInstance final : public UAnimInstance
{
public:
	bool                                          _isInDemonMode;                                    // 0x0350(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_351[0x1F];                                     // 0x0351(0x001F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetIsInDemonMode(const bool IsInDemonMode);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OniCustomizationItemAnimInstance">();
	}
	static class UOniCustomizationItemAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOniCustomizationItemAnimInstance>();
	}
};
static_assert(alignof(UOniCustomizationItemAnimInstance) == 0x000010, "Wrong alignment on UOniCustomizationItemAnimInstance");
static_assert(sizeof(UOniCustomizationItemAnimInstance) == 0x000370, "Wrong size on UOniCustomizationItemAnimInstance");
static_assert(offsetof(UOniCustomizationItemAnimInstance, _isInDemonMode) == 0x000350, "Member 'UOniCustomizationItemAnimInstance::_isInDemonMode' has a wrong offset!");

// Class TheOni.OniDashInteraction
// 0x0050 (0x0910 - 0x08C0)
class UOniDashInteraction final : public UChargeableInteractionDefinition
{
public:
	class UCurveFloat*                            _chargingSpeedCurve;                               // 0x08C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            _dashingSpeedCurve;                                // 0x08C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _yawAdjustTime;                                    // 0x08D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8D4[0x4];                                      // 0x08D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            _cooldownSpeedCurve;                               // 0x08D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8E0[0x30];                                     // 0x08E0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnChargeBegin(class ADBDPlayer* Player);
	void OnChargeEnd(class ADBDPlayer* Player, const bool ChargeCompleted);
	void OnDashBegin(class ADBDPlayer* Player);
	void OnDashEnd(class ADBDPlayer* Player);
	void OnLevelReadyToPlay();
	void SetPlayerOwner(const class ADBDPlayer* Player);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OniDashInteraction">();
	}
	static class UOniDashInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOniDashInteraction>();
	}
};
static_assert(alignof(UOniDashInteraction) == 0x000010, "Wrong alignment on UOniDashInteraction");
static_assert(sizeof(UOniDashInteraction) == 0x000910, "Wrong size on UOniDashInteraction");
static_assert(offsetof(UOniDashInteraction, _chargingSpeedCurve) == 0x0008C0, "Member 'UOniDashInteraction::_chargingSpeedCurve' has a wrong offset!");
static_assert(offsetof(UOniDashInteraction, _dashingSpeedCurve) == 0x0008C8, "Member 'UOniDashInteraction::_dashingSpeedCurve' has a wrong offset!");
static_assert(offsetof(UOniDashInteraction, _yawAdjustTime) == 0x0008D0, "Member 'UOniDashInteraction::_yawAdjustTime' has a wrong offset!");
static_assert(offsetof(UOniDashInteraction, _cooldownSpeedCurve) == 0x0008D8, "Member 'UOniDashInteraction::_cooldownSpeedCurve' has a wrong offset!");

// Class TheOni.OniDemonBasicAttack
// 0x0000 (0x0420 - 0x0420)
class UOniDemonBasicAttack final : public UPounceAttack
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OniDemonBasicAttack">();
	}
	static class UOniDemonBasicAttack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOniDemonBasicAttack>();
	}
};
static_assert(alignof(UOniDemonBasicAttack) == 0x000010, "Wrong alignment on UOniDemonBasicAttack");
static_assert(sizeof(UOniDemonBasicAttack) == 0x000420, "Wrong size on UOniDemonBasicAttack");

// Class TheOni.OniDemonPowerAttack
// 0x0030 (0x0450 - 0x0420)
class UOniDemonPowerAttack : public UPounceAttack
{
public:
	uint8                                         Pad_420[0x30];                                     // 0x0420(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OniDemonPowerAttack">();
	}
	static class UOniDemonPowerAttack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOniDemonPowerAttack>();
	}
};
static_assert(alignof(UOniDemonPowerAttack) == 0x000010, "Wrong alignment on UOniDemonPowerAttack");
static_assert(sizeof(UOniDemonPowerAttack) == 0x000450, "Wrong size on UOniDemonPowerAttack");

// Class TheOni.OniDemonDashAttack
// 0x0000 (0x0450 - 0x0450)
class UOniDemonDashAttack final : public UOniDemonPowerAttack
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OniDemonDashAttack">();
	}
	static class UOniDemonDashAttack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOniDemonDashAttack>();
	}
};
static_assert(alignof(UOniDemonDashAttack) == 0x000010, "Wrong alignment on UOniDemonDashAttack");
static_assert(sizeof(UOniDemonDashAttack) == 0x000450, "Wrong size on UOniDemonDashAttack");

// Class TheOni.OniDemonPowerAttackOpenSubstate
// 0x0018 (0x0148 - 0x0130)
class UOniDemonPowerAttackOpenSubstate : public UPounceAttackOpenSubstate
{
public:
	uint8                                         Pad_130[0x18];                                     // 0x0130(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OniDemonPowerAttackOpenSubstate">();
	}
	static class UOniDemonPowerAttackOpenSubstate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOniDemonPowerAttackOpenSubstate>();
	}
};
static_assert(alignof(UOniDemonPowerAttackOpenSubstate) == 0x000008, "Wrong alignment on UOniDemonPowerAttackOpenSubstate");
static_assert(sizeof(UOniDemonPowerAttackOpenSubstate) == 0x000148, "Wrong size on UOniDemonPowerAttackOpenSubstate");

// Class TheOni.OniDemonDashAttackOpenSubstate
// 0x0000 (0x0148 - 0x0148)
class UOniDemonDashAttackOpenSubstate final : public UOniDemonPowerAttackOpenSubstate
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OniDemonDashAttackOpenSubstate">();
	}
	static class UOniDemonDashAttackOpenSubstate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOniDemonDashAttackOpenSubstate>();
	}
};
static_assert(alignof(UOniDemonDashAttackOpenSubstate) == 0x000008, "Wrong alignment on UOniDemonDashAttackOpenSubstate");
static_assert(sizeof(UOniDemonDashAttackOpenSubstate) == 0x000148, "Wrong size on UOniDemonDashAttackOpenSubstate");

// Class TheOni.OniDemonPowerAttackHittingSubstate
// 0x0000 (0x01A0 - 0x01A0)
class UOniDemonPowerAttackHittingSubstate final : public UPounceAttackHittingSubstate
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OniDemonPowerAttackHittingSubstate">();
	}
	static class UOniDemonPowerAttackHittingSubstate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOniDemonPowerAttackHittingSubstate>();
	}
};
static_assert(alignof(UOniDemonPowerAttackHittingSubstate) == 0x000008, "Wrong alignment on UOniDemonPowerAttackHittingSubstate");
static_assert(sizeof(UOniDemonPowerAttackHittingSubstate) == 0x0001A0, "Wrong size on UOniDemonPowerAttackHittingSubstate");

// Class TheOni.OniDemonPowerAttackSuccessSubstate
// 0x0030 (0x0148 - 0x0118)
class UOniDemonPowerAttackSuccessSubstate final : public UPounceAttackSuccessSubstate
{
public:
	uint8                                         Pad_118[0x30];                                     // 0x0118(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OniDemonPowerAttackSuccessSubstate">();
	}
	static class UOniDemonPowerAttackSuccessSubstate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOniDemonPowerAttackSuccessSubstate>();
	}
};
static_assert(alignof(UOniDemonPowerAttackSuccessSubstate) == 0x000008, "Wrong alignment on UOniDemonPowerAttackSuccessSubstate");
static_assert(sizeof(UOniDemonPowerAttackSuccessSubstate) == 0x000148, "Wrong size on UOniDemonPowerAttackSuccessSubstate");

// Class TheOni.OniDemonPowerAttackMissSubstate
// 0x0000 (0x0120 - 0x0120)
class UOniDemonPowerAttackMissSubstate final : public UPounceAttackMissSubstate
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OniDemonPowerAttackMissSubstate">();
	}
	static class UOniDemonPowerAttackMissSubstate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOniDemonPowerAttackMissSubstate>();
	}
};
static_assert(alignof(UOniDemonPowerAttackMissSubstate) == 0x000008, "Wrong alignment on UOniDemonPowerAttackMissSubstate");
static_assert(sizeof(UOniDemonPowerAttackMissSubstate) == 0x000120, "Wrong size on UOniDemonPowerAttackMissSubstate");

// Class TheOni.OniDemonPowerAttackObstructSubstate
// 0x0000 (0x0128 - 0x0128)
class UOniDemonPowerAttackObstructSubstate final : public UPounceAttackObstructSubstate
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OniDemonPowerAttackObstructSubstate">();
	}
	static class UOniDemonPowerAttackObstructSubstate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOniDemonPowerAttackObstructSubstate>();
	}
};
static_assert(alignof(UOniDemonPowerAttackObstructSubstate) == 0x000008, "Wrong alignment on UOniDemonPowerAttackObstructSubstate");
static_assert(sizeof(UOniDemonPowerAttackObstructSubstate) == 0x000128, "Wrong size on UOniDemonPowerAttackObstructSubstate");

// Class TheOni.OniPounceInteraction
// 0x0030 (0x08F0 - 0x08C0)
class UOniPounceInteraction final : public UChargeableInteractionDefinition
{
public:
	uint8                                         Pad_8C0[0x10];                                     // 0x08C0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UOniDemonModeAttackStateComponent*      _chargedAttackState;                               // 0x08D0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDemonModeComponent*                    _demonModeComponent;                               // 0x08D8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ASlasherPlayer*                         _owningSlasher;                                    // 0x08E0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8E8[0x8];                                      // 0x08E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OniPounceInteraction">();
	}
	static class UOniPounceInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOniPounceInteraction>();
	}
};
static_assert(alignof(UOniPounceInteraction) == 0x000010, "Wrong alignment on UOniPounceInteraction");
static_assert(sizeof(UOniPounceInteraction) == 0x0008F0, "Wrong size on UOniPounceInteraction");
static_assert(offsetof(UOniPounceInteraction, _chargedAttackState) == 0x0008D0, "Member 'UOniPounceInteraction::_chargedAttackState' has a wrong offset!");
static_assert(offsetof(UOniPounceInteraction, _demonModeComponent) == 0x0008D8, "Member 'UOniPounceInteraction::_demonModeComponent' has a wrong offset!");
static_assert(offsetof(UOniPounceInteraction, _owningSlasher) == 0x0008E0, "Member 'UOniPounceInteraction::_owningSlasher' has a wrong offset!");

// Class TheOni.RenjirosBloodyGlove
// 0x00B8 (0x03A0 - 0x02E8)
class URenjirosBloodyGlove final : public UItemAddon
{
public:
	uint8                                         Pad_2E8[0x8];                                      // 0x02E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _revealTime;                                       // 0x02F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2F4[0x4];                                      // 0x02F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UStatusEffect>              _bloodOrbRevealToKillerStatusEffectClass;          // 0x02F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class ACamperPlayer*, class UBloodOrbOverlapRevealToKiller*> _revealEffectPerCamper;                            // 0x0300(0x0050)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_350[0x50];                                     // 0x0350(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnBloodOrbOverlapBegin(const class AActor* OverlappingActor, const class ABloodOrb* BloodOrb);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RenjirosBloodyGlove">();
	}
	static class URenjirosBloodyGlove* GetDefaultObj()
	{
		return GetDefaultObjImpl<URenjirosBloodyGlove>();
	}
};
static_assert(alignof(URenjirosBloodyGlove) == 0x000008, "Wrong alignment on URenjirosBloodyGlove");
static_assert(sizeof(URenjirosBloodyGlove) == 0x0003A0, "Wrong size on URenjirosBloodyGlove");
static_assert(offsetof(URenjirosBloodyGlove, _revealTime) == 0x0002F0, "Member 'URenjirosBloodyGlove::_revealTime' has a wrong offset!");
static_assert(offsetof(URenjirosBloodyGlove, _bloodOrbRevealToKillerStatusEffectClass) == 0x0002F8, "Member 'URenjirosBloodyGlove::_bloodOrbRevealToKillerStatusEffectClass' has a wrong offset!");
static_assert(offsetof(URenjirosBloodyGlove, _revealEffectPerCamper) == 0x000300, "Member 'URenjirosBloodyGlove::_revealEffectPerCamper' has a wrong offset!");

// Class TheOni.StartDemonModeInteraction
// 0x0050 (0x0910 - 0x08C0)
class UStartDemonModeInteraction final : public UChargeableInteractionDefinition
{
public:
	float                                         YawAdjustTime;                                     // 0x08C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8C4[0x4];                                      // 0x08C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAnimationMontageDescriptor            DemonModeActivationMontage;                        // 0x08C8(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_8E8[0x28];                                     // 0x08E8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnLevelReadyToPlay();
	void SetPlayerOwner(const class ADBDPlayer* Owner);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StartDemonModeInteraction">();
	}
	static class UStartDemonModeInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStartDemonModeInteraction>();
	}
};
static_assert(alignof(UStartDemonModeInteraction) == 0x000010, "Wrong alignment on UStartDemonModeInteraction");
static_assert(sizeof(UStartDemonModeInteraction) == 0x000910, "Wrong size on UStartDemonModeInteraction");
static_assert(offsetof(UStartDemonModeInteraction, YawAdjustTime) == 0x0008C0, "Member 'UStartDemonModeInteraction::YawAdjustTime' has a wrong offset!");
static_assert(offsetof(UStartDemonModeInteraction, DemonModeActivationMontage) == 0x0008C8, "Member 'UStartDemonModeInteraction::DemonModeActivationMontage' has a wrong offset!");

}

