#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: DBDGameplay

#include "Basic.hpp"

#include "DBDGameplay_classes.hpp"
#include "DBDGameplay_parameters.hpp"


namespace SDK
{

// Function DBDGameplay.DebugIndicator.SetColor
// (Native, Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FLinearColor                     Color                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADebugIndicator::SetColor(const struct FLinearColor& Color)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DebugIndicator", "SetColor");

	Params::DebugIndicator_SetColor Parms{};

	Parms.Color = std::move(Color);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.DebugIndicator.SetVisible
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Visible                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADebugIndicator::SetVisible(const bool Visible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DebugIndicator", "SetVisible");

	Params::DebugIndicator_SetVisible Parms{};

	Parms.Visible = Visible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.BaseHusk.Cosmetic_InitializeSkeletalMesh
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)
// Parameters:
// class USkeletalMeshComponent*           Mesh                                                   (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseHusk::Cosmetic_InitializeSkeletalMesh(class USkeletalMeshComponent* Mesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseHusk", "Cosmetic_InitializeSkeletalMesh");

	Params::BaseHusk_Cosmetic_InitializeSkeletalMesh Parms{};

	Parms.Mesh = Mesh;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DBDGameplay.BaseHusk.InitializeHusk
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UCustomizedSkeletalMesh*          CustomizedSkeletalMeshToCopy                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkeletalMeshComponent*           SkeletalMeshToCopy                                     (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   CharacterIdOverride                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseHusk::InitializeHusk(class UCustomizedSkeletalMesh* CustomizedSkeletalMeshToCopy, class USkeletalMeshComponent* SkeletalMeshToCopy, int32 CharacterIdOverride)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseHusk", "InitializeHusk");

	Params::BaseHusk_InitializeHusk Parms{};

	Parms.CustomizedSkeletalMeshToCopy = CustomizedSkeletalMeshToCopy;
	Parms.SkeletalMeshToCopy = SkeletalMeshToCopy;
	Parms.CharacterIdOverride = CharacterIdOverride;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.BaseHusk.SetHuskVisibility
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    Visible                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseHusk::SetHuskVisibility(bool Visible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseHusk", "SetHuskVisibility");

	Params::BaseHusk_SetHuskVisibility Parms{};

	Parms.Visible = Visible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.BaseHusk.SetScalarParameterOnAllChildrenMeshes
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class FName                             ParameterName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkeletalMeshComponent*           Mesh                                                   (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseHusk::SetScalarParameterOnAllChildrenMeshes(class FName ParameterName, float Value, class USkeletalMeshComponent* Mesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseHusk", "SetScalarParameterOnAllChildrenMeshes");

	Params::BaseHusk_SetScalarParameterOnAllChildrenMeshes Parms{};

	Parms.ParameterName = ParameterName;
	Parms.Value = Value;
	Parms.Mesh = Mesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.BaseHusk.GetCopiedCustomizedSkeletalMesh
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class UCustomizedSkeletalMesh*    ReturnValue                                            (ConstParm, ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UCustomizedSkeletalMesh* ABaseHusk::GetCopiedCustomizedSkeletalMesh() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseHusk", "GetCopiedCustomizedSkeletalMesh");

	Params::BaseHusk_GetCopiedCustomizedSkeletalMesh Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.BlindAndDeafenRangedExplosiveActorEffect.Authority_TryToBlind
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// class UBlindableBaseComponent*          BlindableComponent                                     (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           EffectorActor                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBlindAndDeafenRangedExplosiveActorEffect::Authority_TryToBlind(class UBlindableBaseComponent* BlindableComponent, class AActor* EffectorActor) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BlindAndDeafenRangedExplosiveActorEffect", "Authority_TryToBlind");

	Params::BlindAndDeafenRangedExplosiveActorEffect_Authority_TryToBlind Parms{};

	Parms.BlindableComponent = BlindableComponent;
	Parms.EffectorActor = EffectorActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.BlindAndDeafenRangedExplosiveActorEffect.Authority_TryToDeafen
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// class ADBDPlayer*                       Player                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAudioFXComponent*                AudioFXComponent                                       (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBlindAndDeafenRangedExplosiveActorEffect::Authority_TryToDeafen(const class ADBDPlayer* Player, class UAudioFXComponent* AudioFXComponent) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BlindAndDeafenRangedExplosiveActorEffect", "Authority_TryToDeafen");

	Params::BlindAndDeafenRangedExplosiveActorEffect_Authority_TryToDeafen Parms{};

	Parms.Player = Player;
	Parms.AudioFXComponent = AudioFXComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.BlindAndDeafenRangedExplosiveActorEffect.GetBlindnessEffectDuration
// (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           Player                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UBlindAndDeafenRangedExplosiveActorEffect::GetBlindnessEffectDuration(const class AActor* Player) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BlindAndDeafenRangedExplosiveActorEffect", "GetBlindnessEffectDuration");

	Params::BlindAndDeafenRangedExplosiveActorEffect_GetBlindnessEffectDuration Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.BlindAndDeafenRangedExplosiveActorEffect.GetDeafnessEffectDuration
// (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           Player                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UBlindAndDeafenRangedExplosiveActorEffect::GetDeafnessEffectDuration(const class AActor* Player) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BlindAndDeafenRangedExplosiveActorEffect", "GetDeafnessEffectDuration");

	Params::BlindAndDeafenRangedExplosiveActorEffect_GetDeafnessEffectDuration Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.CageHook.CheckRescuerSocketPosition
// (Event, Protected, BlueprintEvent)

void ACageHook::CheckRescuerSocketPosition()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CageHook", "CheckRescuerSocketPosition");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DBDGameplay.CageHook.Cosmetic_DisplayCage
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    Display                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACageHook::Cosmetic_DisplayCage(const bool Display)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CageHook", "Cosmetic_DisplayCage");

	Params::CageHook_Cosmetic_DisplayCage Parms{};

	Parms.Display = Display;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DBDGameplay.CageHook.Cosmetic_OnPlayerAbsorbedByGround
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)

void ACageHook::Cosmetic_OnPlayerAbsorbedByGround()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CageHook", "Cosmetic_OnPlayerAbsorbedByGround");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DBDGameplay.CageHook.Cosmetic_OnRelocateStart
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)

void ACageHook::Cosmetic_OnRelocateStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CageHook", "Cosmetic_OnRelocateStart");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DBDGameplay.CageHook.FX_SurvivorSavedFromCage
// (BlueprintCosmetic, Event, Public, BlueprintEvent)

void ACageHook::FX_SurvivorSavedFromCage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CageHook", "FX_SurvivorSavedFromCage");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DBDGameplay.CageHook.Multicast_Relocate
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private, HasDefaults)
// Parameters:
// struct FVector                          Location                                               (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         Rotation                                               (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    IsAnticampRelocation                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACageHook::Multicast_Relocate(const struct FVector& Location, const struct FRotator& Rotation, const bool IsAnticampRelocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CageHook", "Multicast_Relocate");

	Params::CageHook_Multicast_Relocate Parms{};

	Parms.Location = std::move(Location);
	Parms.Rotation = std::move(Rotation);
	Parms.IsAnticampRelocation = IsAnticampRelocation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.CageHook.Multicast_SendSurvivorToCage
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class ACamperPlayer*                    Survivor                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ASlasherPlayer*                   KillerInstigator                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACageHook::Multicast_SendSurvivorToCage(class ACamperPlayer* Survivor, class ASlasherPlayer* KillerInstigator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CageHook", "Multicast_SendSurvivorToCage");

	Params::CageHook_Multicast_SendSurvivorToCage Parms{};

	Parms.Survivor = Survivor;
	Parms.KillerInstigator = KillerInstigator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.CageHook.Multicast_SendSurvivorToCageImmediately
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private, HasDefaults)
// Parameters:
// class ACamperPlayer*                    Survivor                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ASlasherPlayer*                   KillerInstigator                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         Rotation                                               (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void ACageHook::Multicast_SendSurvivorToCageImmediately(class ACamperPlayer* Survivor, class ASlasherPlayer* KillerInstigator, const struct FVector& Location, const struct FRotator& Rotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CageHook", "Multicast_SendSurvivorToCageImmediately");

	Params::CageHook_Multicast_SendSurvivorToCageImmediately Parms{};

	Parms.Survivor = Survivor;
	Parms.KillerInstigator = KillerInstigator;
	Parms.Location = std::move(Location);
	Parms.Rotation = std::move(Rotation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.CageHook.OnCageDisappear
// (Final, Native, Protected, BlueprintCallable)

void ACageHook::OnCageDisappear()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CageHook", "OnCageDisappear");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.CageHook.OnRescueCancelled
// (Event, Protected, BlueprintEvent)

void ACageHook::OnRescueCancelled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CageHook", "OnRescueCancelled");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DBDGameplay.CageHook.OnSkillCheckFailed
// (Final, Native, Private)

void ACageHook::OnSkillCheckFailed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CageHook", "OnSkillCheckFailed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.CageHook.OnSkillCheckFailed_Cosmetic
// (BlueprintCosmetic, Event, Public, BlueprintEvent)

void ACageHook::OnSkillCheckFailed_Cosmetic()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CageHook", "OnSkillCheckFailed_Cosmetic");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DBDGameplay.CageHook.PlayerOverlapZoneBeginOverlap
// (Final, Native, Private, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ACageHook::PlayerOverlapZoneBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CageHook", "PlayerOverlapZoneBeginOverlap");

	Params::CageHook_PlayerOverlapZoneBeginOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.CageHook.PlayerOverlapZoneEndOverlap
// (Final, Native, Private)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACageHook::PlayerOverlapZoneEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CageHook", "PlayerOverlapZoneEndOverlap");

	Params::CageHook_PlayerOverlapZoneEndOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.CageHook.GetCagedSurvivor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ACamperPlayer*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACamperPlayer* ACageHook::GetCagedSurvivor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CageHook", "GetCagedSurvivor");

	Params::CageHook_GetCagedSurvivor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.CageHook.GetMontagePlayer
// (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UMontagePlayer*                   ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMontagePlayer* ACageHook::GetMontagePlayer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CageHook", "GetMontagePlayer");

	Params::CageHook_GetMontagePlayer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.CageHook.GetRescuerSnapPosition
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ACageHook::GetRescuerSnapPosition() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CageHook", "GetRescuerSnapPosition");

	Params::CageHook_GetRescuerSnapPosition Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.BaseActorAttackableComponent.HitWithProjectile
// (Native, Public, BlueprintCallable)
// Parameters:
// class ABaseProjectile*                  Projectile                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBaseActorAttackableComponent::HitWithProjectile(class ABaseProjectile* Projectile)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseActorAttackableComponent", "HitWithProjectile");

	Params::BaseActorAttackableComponent_HitWithProjectile Parms{};

	Parms.Projectile = Projectile;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.CageRescueInteraction.GetRescuerSnapPosition
// (Final, Native, Protected, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UCageRescueInteraction::GetRescuerSnapPosition() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CageRescueInteraction", "GetRescuerSnapPosition");

	Params::CageRescueInteraction_GetRescuerSnapPosition Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.SendToCageInteraction.FX_InteractionCancel
// (BlueprintCosmetic, Event, Public, BlueprintEvent)

void USendToCageInteraction::FX_InteractionCancel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SendToCageInteraction", "FX_InteractionCancel");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DBDGameplay.SendToCageInteraction.FX_InteractionChargeCompleted
// (BlueprintCosmetic, Event, Public, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USendToCageInteraction::FX_InteractionChargeCompleted(class ADBDPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SendToCageInteraction", "FX_InteractionChargeCompleted");

	Params::SendToCageInteraction_FX_InteractionChargeCompleted Parms{};

	Parms.Player = Player;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DBDGameplay.SendToCageInteraction.FX_InteractionStart
// (BlueprintCosmetic, Event, Public, BlueprintEvent)

void USendToCageInteraction::FX_InteractionStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SendToCageInteraction", "FX_InteractionStart");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DBDGameplay.SendToCageInteraction.GetOwningSurvivor
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class ACamperPlayer*              ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class ACamperPlayer* USendToCageInteraction::GetOwningSurvivor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SendToCageInteraction", "GetOwningSurvivor");

	Params::SendToCageInteraction_GetOwningSurvivor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.AuraOverriderComponent.ForceShowAura
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     Color                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsAlwaysVisible                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MinimumOutlineDistanceVisible                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MinimumOutlineDistance                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAuraOverriderComponent::ForceShowAura(const class AActor* Actor, const struct FLinearColor& Color, bool IsAlwaysVisible, const float MinimumOutlineDistanceVisible, const float MinimumOutlineDistance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuraOverriderComponent", "ForceShowAura");

	Params::AuraOverriderComponent_ForceShowAura Parms{};

	Parms.Actor = Actor;
	Parms.Color = std::move(Color);
	Parms.IsAlwaysVisible = IsAlwaysVisible;
	Parms.MinimumOutlineDistanceVisible = MinimumOutlineDistanceVisible;
	Parms.MinimumOutlineDistance = MinimumOutlineDistance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.AuraOverriderComponent.ResetAura
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAuraOverriderComponent::ResetAura(const class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuraOverriderComponent", "ResetAura");

	Params::AuraOverriderComponent_ResetAura Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.BaseSightManagerComponent.Authority_OnCharacterSightChanged
// (Native, Protected)
// Parameters:
// class ACharacter*                       SightedCharacter                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCharacterSightComponent*         SightComponent                                         (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBaseSightManagerComponent::Authority_OnCharacterSightChanged(class ACharacter* SightedCharacter, class UCharacterSightComponent* SightComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSightManagerComponent", "Authority_OnCharacterSightChanged");

	Params::BaseSightManagerComponent_Authority_OnCharacterSightChanged Parms{};

	Parms.SightedCharacter = SightedCharacter;
	Parms.SightComponent = SightComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.BaseSightManagerComponent.OnIntroCompleted
// (Native, Protected)

void UBaseSightManagerComponent::OnIntroCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSightManagerComponent", "OnIntroCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.DebugTimerLogComponent.OnRep_TimerCountdown
// (Final, Native, Private)

void UDebugTimerLogComponent::OnRep_TimerCountdown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DebugTimerLogComponent", "OnRep_TimerCountdown");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.FadeComponent.GetFadePercent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UFadeComponent::GetFadePercent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FadeComponent", "GetFadePercent");

	Params::FadeComponent_GetFadePercent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.FlashlightTargetFXComponent.OnIsLitChanged
// (Final, Native, Private)
// Parameters:
// bool                                    IsLit                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFlashlightTargetFXComponent::OnIsLitChanged(bool IsLit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlashlightTargetFXComponent", "OnIsLitChanged");

	Params::FlashlightTargetFXComponent_OnIsLitChanged Parms{};

	Parms.IsLit = IsLit;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.TerrorRadiusScreenIndicatorComponent.OnHeartStateChanged
// (Final, Native, Private)
// Parameters:
// struct FGameplayTag                     HeartState                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTerrorRadiusScreenIndicatorComponent::OnHeartStateChanged(const struct FGameplayTag& HeartState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TerrorRadiusScreenIndicatorComponent", "OnHeartStateChanged");

	Params::TerrorRadiusScreenIndicatorComponent_OnHeartStateChanged Parms{};

	Parms.HeartState = std::move(HeartState);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.KillerAbilityComponent.OnRep_CooldownTimer
// (Final, Native, Protected)

void UKillerAbilityComponent::OnRep_CooldownTimer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerAbilityComponent", "OnRep_CooldownTimer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.KillerAbilityComponent.OnRep_DurationTimer
// (Final, Native, Protected)

void UKillerAbilityComponent::OnRep_DurationTimer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerAbilityComponent", "OnRep_DurationTimer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.KillerAbilityComponent.OnRep_TokenCount
// (Native, Protected)
// Parameters:
// int32                                   OldCount                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKillerAbilityComponent::OnRep_TokenCount(const int32 OldCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerAbilityComponent", "OnRep_TokenCount");

	Params::KillerAbilityComponent_OnRep_TokenCount Parms{};

	Parms.OldCount = OldCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.KillerAbilityComponent.OnRep_TokenRechargeTimer
// (Final, Native, Protected)

void UKillerAbilityComponent::OnRep_TokenRechargeTimer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerAbilityComponent", "OnRep_TokenRechargeTimer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.KillerAbilityComponent.GetCooldown
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKillerAbilityComponent::GetCooldown() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerAbilityComponent", "GetCooldown");

	Params::KillerAbilityComponent_GetCooldown Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.KillerAbilityComponent.GetDuration
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKillerAbilityComponent::GetDuration() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerAbilityComponent", "GetDuration");

	Params::KillerAbilityComponent_GetDuration Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.KillerAbilityComponent.GetOwningKiller
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ASlasherPlayer*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ASlasherPlayer* UKillerAbilityComponent::GetOwningKiller() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerAbilityComponent", "GetOwningKiller");

	Params::KillerAbilityComponent_GetOwningKiller Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.KillerAbilityComponent.GetOwningPower
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AKillerPower*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AKillerPower* UKillerAbilityComponent::GetOwningPower() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerAbilityComponent", "GetOwningPower");

	Params::KillerAbilityComponent_GetOwningPower Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.KillerAbilityComponent.GetRemainingCooldown
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKillerAbilityComponent::GetRemainingCooldown() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerAbilityComponent", "GetRemainingCooldown");

	Params::KillerAbilityComponent_GetRemainingCooldown Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.KillerAbilityComponent.GetRemainingCooldownPercent
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKillerAbilityComponent::GetRemainingCooldownPercent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerAbilityComponent", "GetRemainingCooldownPercent");

	Params::KillerAbilityComponent_GetRemainingCooldownPercent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.KillerAbilityComponent.IsApplicable
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKillerAbilityComponent::IsApplicable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerAbilityComponent", "IsApplicable");

	Params::KillerAbilityComponent_IsApplicable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.KillerAbilityComponent.IsAvailable
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKillerAbilityComponent::IsAvailable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerAbilityComponent", "IsAvailable");

	Params::KillerAbilityComponent_IsAvailable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.KillerAbilityComponent.IsOnCooldown
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKillerAbilityComponent::IsOnCooldown() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerAbilityComponent", "IsOnCooldown");

	Params::KillerAbilityComponent_IsOnCooldown Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.KillerAbilityComponent.PlayAudioOnOwningKiller
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// class UAkAudioEvent*                    AudioEvent                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    OnlyPlayIfLocallyObserved                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKillerAbilityComponent::PlayAudioOnOwningKiller(class UAkAudioEvent* AudioEvent, bool OnlyPlayIfLocallyObserved) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerAbilityComponent", "PlayAudioOnOwningKiller");

	Params::KillerAbilityComponent_PlayAudioOnOwningKiller Parms{};

	Parms.AudioEvent = AudioEvent;
	Parms.OnlyPlayIfLocallyObserved = OnlyPlayIfLocallyObserved;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.PoseableHusk.CapturePose
// (Final, Native, Public, BlueprintCallable)

void APoseableHusk::CapturePose()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PoseableHusk", "CapturePose");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.PoseableHusk.Cosmetic_OnAnimationPoseCaptured
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)

void APoseableHusk::Cosmetic_OnAnimationPoseCaptured()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PoseableHusk", "Cosmetic_OnAnimationPoseCaptured");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DBDGameplay.PoseableHusk.OnActiveStateChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    IsActive                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APoseableHusk::OnActiveStateChanged(bool IsActive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PoseableHusk", "OnActiveStateChanged");

	Params::PoseableHusk_OnActiveStateChanged Parms{};

	Parms.IsActive = IsActive;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DBDGameplay.PoseableHusk.SetIsActive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    IsActive                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APoseableHusk::SetIsActive(bool IsActive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PoseableHusk", "SetIsActive");

	Params::PoseableHusk_SetIsActive Parms{};

	Parms.IsActive = IsActive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.PoseableHusk.GetIsActive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APoseableHusk::GetIsActive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PoseableHusk", "GetIsActive");

	Params::PoseableHusk_GetIsActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.KillerPower.OnRep_OwningKiller
// (Final, Native, Protected)

void AKillerPower::OnRep_OwningKiller()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerPower", "OnRep_OwningKiller");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.ClosetHideInteraction.FireSoundEventFromInteractor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Instigator                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       InstigatingPlayer                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UClosetHideInteraction::FireSoundEventFromInteractor(class AActor* Instigator, class ADBDPlayer* InstigatingPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClosetHideInteraction", "FireSoundEventFromInteractor");

	Params::ClosetHideInteraction_FireSoundEventFromInteractor Parms{};

	Parms.Instigator = Instigator;
	Parms.InstigatingPlayer = InstigatingPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.ClosetHideInteraction.SetOtherInteractorsUsable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    IsEnabled                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UClosetHideInteraction::SetOtherInteractorsUsable(const bool IsEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClosetHideInteraction", "SetOtherInteractorsUsable");

	Params::ClosetHideInteraction_SetOtherInteractorsUsable Parms{};

	Parms.IsEnabled = IsEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.ClosetHideInteraction.GetInsideInteractor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UInteractor*                      ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UInteractor* UClosetHideInteraction::GetInsideInteractor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClosetHideInteraction", "GetInsideInteractor");

	Params::ClosetHideInteraction_GetInsideInteractor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.ClosetHideInteraction.GetPlayerInCloset
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ADBDPlayer*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADBDPlayer* UClosetHideInteraction::GetPlayerInCloset() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClosetHideInteraction", "GetPlayerInCloset");

	Params::ClosetHideInteraction_GetPlayerInCloset Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.ClosetHideInteraction.IsInteractingPlayerInsideCloset
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ADBDPlayer*                       Player                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UClosetHideInteraction::IsInteractingPlayerInsideCloset(const class ADBDPlayer* Player) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClosetHideInteraction", "IsInteractingPlayerInsideCloset");

	Params::ClosetHideInteraction_IsInteractingPlayerInsideCloset Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.ClosetHideInteraction.IsOccupied
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UClosetHideInteraction::IsOccupied() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClosetHideInteraction", "IsOccupied");

	Params::ClosetHideInteraction_IsOccupied Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.ClosetHideInteraction.IsRushed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UClosetHideInteraction::IsRushed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClosetHideInteraction", "IsRushed");

	Params::ClosetHideInteraction_IsRushed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.ClosetHideInteraction.SetCollisionWithCloset
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// bool                                    IsEnabled                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UClosetHideInteraction::SetCollisionWithCloset(const bool IsEnabled, class ADBDPlayer* Player) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClosetHideInteraction", "SetCollisionWithCloset");

	Params::ClosetHideInteraction_SetCollisionWithCloset Parms{};

	Parms.IsEnabled = IsEnabled;
	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.ClosetHideEnterInteraction.EjectSurvivorFromLocker
// (Final, Native, Protected)
// Parameters:
// class ACamperPlayer*                    Survivor                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ALocker*                          Locker                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UClosetHideEnterInteraction::EjectSurvivorFromLocker(class ACamperPlayer* Survivor, class ALocker* Locker)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClosetHideEnterInteraction", "EjectSurvivorFromLocker");

	Params::ClosetHideEnterInteraction_EjectSurvivorFromLocker Parms{};

	Parms.Survivor = Survivor;
	Parms.Locker = Locker;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.PalletTrackerVisibilityComponent.Cosmetic_OnPalletTrackerSelectedChanged
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    Selected                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPalletTrackerVisibilityComponent::Cosmetic_OnPalletTrackerSelectedChanged(bool Selected)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PalletTrackerVisibilityComponent", "Cosmetic_OnPalletTrackerSelectedChanged");

	Params::PalletTrackerVisibilityComponent_Cosmetic_OnPalletTrackerSelectedChanged Parms{};

	Parms.Selected = Selected;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DBDGameplay.PalletTrackerVisibilityComponent.Cosmetic_OnVisibilityChanged
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    IsVisible                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPalletTrackerVisibilityComponent::Cosmetic_OnVisibilityChanged(bool IsVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PalletTrackerVisibilityComponent", "Cosmetic_OnVisibilityChanged");

	Params::PalletTrackerVisibilityComponent_Cosmetic_OnVisibilityChanged Parms{};

	Parms.IsVisible = IsVisible;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DBDGameplay.PalletTrackerVisibilityComponent.OnLocallyObservedChanged
// (Final, Native, Private)

void UPalletTrackerVisibilityComponent::OnLocallyObservedChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PalletTrackerVisibilityComponent", "OnLocallyObservedChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.PalletTrackerVisibilityComponent.GetPalletTrackerOwner
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class APalletTracker*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APalletTracker* UPalletTrackerVisibilityComponent::GetPalletTrackerOwner() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PalletTrackerVisibilityComponent", "GetPalletTrackerOwner");

	Params::PalletTrackerVisibilityComponent_GetPalletTrackerOwner Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.CageHookAntiCampComponent.Multicast_TriggerAntiCamp
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)

void UCageHookAntiCampComponent::Multicast_TriggerAntiCamp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CageHookAntiCampComponent", "Multicast_TriggerAntiCamp");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// DelegateFunction DBDGameplay.LimitGeneratorRegressionEventComponent.CosmeticEvent__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// int32                                   CurrentRegressionLevel                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULimitGeneratorRegressionEventComponent::CosmeticEvent__DelegateSignature(int32 CurrentRegressionLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LimitGeneratorRegressionEventComponent", "CosmeticEvent__DelegateSignature");

	Params::LimitGeneratorRegressionEventComponent_CosmeticEvent__DelegateSignature Parms{};

	Parms.CurrentRegressionLevel = CurrentRegressionLevel;

	UObject::ProcessEvent(Func, &Parms);
}


// DelegateFunction DBDGameplay.LimitGeneratorRegressionEventComponent.OnBlockingStatusChanged__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// int32                                   CurrentRegressionLevel                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Blocked                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULimitGeneratorRegressionEventComponent::OnBlockingStatusChanged__DelegateSignature(int32 CurrentRegressionLevel, bool Blocked)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LimitGeneratorRegressionEventComponent", "OnBlockingStatusChanged__DelegateSignature");

	Params::LimitGeneratorRegressionEventComponent_OnBlockingStatusChanged__DelegateSignature Parms{};

	Parms.CurrentRegressionLevel = CurrentRegressionLevel;
	Parms.Blocked = Blocked;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DBDGameplay.LimitGeneratorRegressionEventComponent.OnKillerProximityZoneForRegressionEventsOverlapBegin
// (Final, Native, Private, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              HitComponent                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ULimitGeneratorRegressionEventComponent::OnKillerProximityZoneForRegressionEventsOverlapBegin(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LimitGeneratorRegressionEventComponent", "OnKillerProximityZoneForRegressionEventsOverlapBegin");

	Params::LimitGeneratorRegressionEventComponent_OnKillerProximityZoneForRegressionEventsOverlapBegin Parms{};

	Parms.HitComponent = HitComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.LimitGeneratorRegressionEventComponent.OnKillerProximityZoneForRegressionEventsOverlapEnd
// (Final, Native, Private)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULimitGeneratorRegressionEventComponent::OnKillerProximityZoneForRegressionEventsOverlapEnd(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LimitGeneratorRegressionEventComponent", "OnKillerProximityZoneForRegressionEventsOverlapEnd");

	Params::LimitGeneratorRegressionEventComponent_OnKillerProximityZoneForRegressionEventsOverlapEnd Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// DelegateFunction DBDGameplay.LimitGeneratorRegressionEventComponent.OnRegressionEvent__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// int32                                   CurrentRegressionLevel                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    SurvivorInteracting                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULimitGeneratorRegressionEventComponent::OnRegressionEvent__DelegateSignature(int32 CurrentRegressionLevel, bool SurvivorInteracting)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LimitGeneratorRegressionEventComponent", "OnRegressionEvent__DelegateSignature");

	Params::LimitGeneratorRegressionEventComponent_OnRegressionEvent__DelegateSignature Parms{};

	Parms.CurrentRegressionLevel = CurrentRegressionLevel;
	Parms.SurvivorInteracting = SurvivorInteracting;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DBDGameplay.LimitGeneratorRegressionEventComponent.OnRep_RegressionEventsSuffered
// (Final, Native, Private)

void ULimitGeneratorRegressionEventComponent::OnRep_RegressionEventsSuffered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LimitGeneratorRegressionEventComponent", "OnRep_RegressionEventsSuffered");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.LimitGeneratorRegressionEventComponent.GetMaxNumberRegressionEventsAllowed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULimitGeneratorRegressionEventComponent::GetMaxNumberRegressionEventsAllowed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LimitGeneratorRegressionEventComponent", "GetMaxNumberRegressionEventsAllowed");

	Params::LimitGeneratorRegressionEventComponent_GetMaxNumberRegressionEventsAllowed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.RangedExplosive.Multicast_InitFromSpawningPlayer
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class ADBDPlayer*                       Spawner                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARangedExplosive::Multicast_InitFromSpawningPlayer(class ADBDPlayer* Spawner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RangedExplosive", "Multicast_InitFromSpawningPlayer");

	Params::RangedExplosive_Multicast_InitFromSpawningPlayer Parms{};

	Parms.Spawner = Spawner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.RangedExplosive.OnExplode_BP
// (Event, Protected, BlueprintEvent)

void ARangedExplosive::OnExplode_BP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RangedExplosive", "OnExplode_BP");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DBDGameplay.RangedExplosive.OnFuseBurnEnter
// (Event, Protected, BlueprintEvent)

void ARangedExplosive::OnFuseBurnEnter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RangedExplosive", "OnFuseBurnEnter");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DBDGameplay.RangedExplosive.OnFuseBurnExit
// (Event, Protected, BlueprintEvent)

void ARangedExplosive::OnFuseBurnExit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RangedExplosive", "OnFuseBurnExit");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DBDGameplay.RangedExplosive.OnFuseBurnUpdate
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                                   DeltaSeconds                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   FuseTimeLeftPercent                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARangedExplosive::OnFuseBurnUpdate(float DeltaSeconds, float FuseTimeLeftPercent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RangedExplosive", "OnFuseBurnUpdate");

	Params::RangedExplosive_OnFuseBurnUpdate Parms{};

	Parms.DeltaSeconds = DeltaSeconds;
	Parms.FuseTimeLeftPercent = FuseTimeLeftPercent;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DBDGameplay.RangedExplosive.GetExplosionEffectDuration
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ARangedExplosive::GetExplosionEffectDuration() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RangedExplosive", "GetExplosionEffectDuration");

	Params::RangedExplosive_GetExplosionEffectDuration Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.RangedExplosive.GetExplosionRange
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ARangedExplosive::GetExplosionRange() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RangedExplosive", "GetExplosionRange");

	Params::RangedExplosive_GetExplosionRange Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.RangedExplosive.GetModifierValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTag                     Type                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ARangedExplosive::GetModifierValue(const struct FGameplayTag& Type) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RangedExplosive", "GetModifierValue");

	Params::RangedExplosive_GetModifierValue Parms{};

	Parms.Type = std::move(Type);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.RangedExplosive.GetOwningPlayer
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ADBDPlayer*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADBDPlayer* ARangedExplosive::GetOwningPlayer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RangedExplosive", "GetOwningPlayer");

	Params::RangedExplosive_GetOwningPlayer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.RangedExplosive.GetRangedExplosiveActorEffect
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UBaseRangedExplosiveActorEffect*  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UBaseRangedExplosiveActorEffect* ARangedExplosive::GetRangedExplosiveActorEffect() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RangedExplosive", "GetRangedExplosiveActorEffect");

	Params::RangedExplosive_GetRangedExplosiveActorEffect Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.AimPointPerlinNoise.SetBaseInaccuracyNoiseAmplitude
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Amplitude                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAimPointPerlinNoise::SetBaseInaccuracyNoiseAmplitude(const float Amplitude)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AimPointPerlinNoise", "SetBaseInaccuracyNoiseAmplitude");

	Params::AimPointPerlinNoise_SetBaseInaccuracyNoiseAmplitude Parms{};

	Parms.Amplitude = Amplitude;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.AimPointPerlinNoise.SetBaseInaccuracyNoiseFrequency
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Frequency                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAimPointPerlinNoise::SetBaseInaccuracyNoiseFrequency(const float Frequency)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AimPointPerlinNoise", "SetBaseInaccuracyNoiseFrequency");

	Params::AimPointPerlinNoise_SetBaseInaccuracyNoiseFrequency Parms{};

	Parms.Frequency = Frequency;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.AimPointPerlinNoise.SetBaseInaccuracyNoiseOctaveCount
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   OctaveCount                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAimPointPerlinNoise::SetBaseInaccuracyNoiseOctaveCount(const int32 OctaveCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AimPointPerlinNoise", "SetBaseInaccuracyNoiseOctaveCount");

	Params::AimPointPerlinNoise_SetBaseInaccuracyNoiseOctaveCount Parms{};

	Parms.OctaveCount = OctaveCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.AimPointPerlinNoise.SetBaseInaccuracyNoisePersistence
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NoisePersistence                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAimPointPerlinNoise::SetBaseInaccuracyNoisePersistence(const float NoisePersistence)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AimPointPerlinNoise", "SetBaseInaccuracyNoisePersistence");

	Params::AimPointPerlinNoise_SetBaseInaccuracyNoisePersistence Parms{};

	Parms.NoisePersistence = NoisePersistence;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.AimPointPerlinNoise.SetNoiseAmplitudeMultiplier
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Multiplier                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAimPointPerlinNoise::SetNoiseAmplitudeMultiplier(const float Multiplier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AimPointPerlinNoise", "SetNoiseAmplitudeMultiplier");

	Params::AimPointPerlinNoise_SetNoiseAmplitudeMultiplier Parms{};

	Parms.Multiplier = Multiplier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.AimPointPerlinNoise.SetNoiseFrequencyMultiplier
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Multiplier                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAimPointPerlinNoise::SetNoiseFrequencyMultiplier(const float Multiplier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AimPointPerlinNoise", "SetNoiseFrequencyMultiplier");

	Params::AimPointPerlinNoise_SetNoiseFrequencyMultiplier Parms{};

	Parms.Multiplier = Multiplier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.KillerAbilityData.GetCooldown
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKillerAbilityData::GetCooldown() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerAbilityData", "GetCooldown");

	Params::KillerAbilityData_GetCooldown Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.KillerAbilityData.GetDuration
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKillerAbilityData::GetDuration() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerAbilityData", "GetDuration");

	Params::KillerAbilityData_GetDuration Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.KillerFormSwitchingAbility.Cosmetic_OnCurrentFormChanged
// (BlueprintCosmetic, Event, Public, BlueprintEvent)
// Parameters:
// bool                                    IsStartingForm                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKillerFormSwitchingAbility::Cosmetic_OnCurrentFormChanged(bool IsStartingForm)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerFormSwitchingAbility", "Cosmetic_OnCurrentFormChanged");

	Params::KillerFormSwitchingAbility_Cosmetic_OnCurrentFormChanged Parms{};

	Parms.IsStartingForm = IsStartingForm;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DBDGameplay.KillerFormSwitchingAbility.Cosmetic_OnEnterForm
// (BlueprintCosmetic, Event, Public, BlueprintEvent)
// Parameters:
// struct FGameplayTag                     FormID                                                 (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsStartingForm                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKillerFormSwitchingAbility::Cosmetic_OnEnterForm(const struct FGameplayTag& FormID, bool IsStartingForm)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerFormSwitchingAbility", "Cosmetic_OnEnterForm");

	Params::KillerFormSwitchingAbility_Cosmetic_OnEnterForm Parms{};

	Parms.FormID = std::move(FormID);
	Parms.IsStartingForm = IsStartingForm;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DBDGameplay.KillerFormSwitchingAbility.Cosmetic_OnExitForm
// (BlueprintCosmetic, Event, Public, BlueprintEvent)
// Parameters:
// struct FGameplayTag                     FormID                                                 (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKillerFormSwitchingAbility::Cosmetic_OnExitForm(const struct FGameplayTag& FormID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerFormSwitchingAbility", "Cosmetic_OnExitForm");

	Params::KillerFormSwitchingAbility_Cosmetic_OnExitForm Parms{};

	Parms.FormID = std::move(FormID);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DBDGameplay.KillerFormSwitchingAbility.GetTransitionDuration
// (Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKillerFormSwitchingAbility::GetTransitionDuration()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerFormSwitchingAbility", "GetTransitionDuration");

	Params::KillerFormSwitchingAbility_GetTransitionDuration Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.KillerFormSwitchingAbility.OnRep_CurrentFormID
// (Final, Native, Protected)
// Parameters:
// struct FGameplayTag                     OldFormId                                              (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKillerFormSwitchingAbility::OnRep_CurrentFormID(const struct FGameplayTag& OldFormId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerFormSwitchingAbility", "OnRep_CurrentFormID");

	Params::KillerFormSwitchingAbility_OnRep_CurrentFormID Parms{};

	Parms.OldFormId = std::move(OldFormId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.KillerFormSwitchingAbility.GetCurrentFormID
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayTag UKillerFormSwitchingAbility::GetCurrentFormID() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerFormSwitchingAbility", "GetCurrentFormID");

	Params::KillerFormSwitchingAbility_GetCurrentFormID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.AimableComponent.SetMaxAimDistance
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   MaxAimDistance                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAimableComponent::SetMaxAimDistance(float MaxAimDistance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AimableComponent", "SetMaxAimDistance");

	Params::AimableComponent_SetMaxAimDistance Parms{};

	Parms.MaxAimDistance = MaxAimDistance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.AimableComponent.SetOcclusionIgnoredActors
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class AActor*>                   IgnoredActors                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UAimableComponent::SetOcclusionIgnoredActors(const TArray<class AActor*>& IgnoredActors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AimableComponent", "SetOcclusionIgnoredActors");

	Params::AimableComponent_SetOcclusionIgnoredActors Parms{};

	Parms.IgnoredActors = std::move(IgnoredActors);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.AimableComponent.SetProcessors
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class UAimPointProcessor*>       Processors                                             (Parm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UAimableComponent::SetProcessors(const TArray<class UAimPointProcessor*>& Processors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AimableComponent", "SetProcessors");

	Params::AimableComponent_SetProcessors Parms{};

	Parms.Processors = std::move(Processors);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.TerrorRadiusEmitterComponent.SetEmitterActive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Active                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTerrorRadiusEmitterComponent::SetEmitterActive(bool Active)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TerrorRadiusEmitterComponent", "SetEmitterActive");

	Params::TerrorRadiusEmitterComponent_SetEmitterActive Parms{};

	Parms.Active = Active;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.TerrorRadiusEmitterComponent.SetImitatesAudioOnly
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ImitatesAudioOnly                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTerrorRadiusEmitterComponent::SetImitatesAudioOnly(bool ImitatesAudioOnly)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TerrorRadiusEmitterComponent", "SetImitatesAudioOnly");

	Params::TerrorRadiusEmitterComponent_SetImitatesAudioOnly Parms{};

	Parms.ImitatesAudioOnly = ImitatesAudioOnly;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.TerrorRadiusEmitterComponent.SetIsFakeTerrorRadius
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTerrorRadiusEmitterComponent::SetIsFakeTerrorRadius(bool Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TerrorRadiusEmitterComponent", "SetIsFakeTerrorRadius");

	Params::TerrorRadiusEmitterComponent_SetIsFakeTerrorRadius Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.TerrorRadiusEmitterComponent.SetSimulatedFixedDistance
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Distance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTerrorRadiusEmitterComponent::SetSimulatedFixedDistance(float Distance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TerrorRadiusEmitterComponent", "SetSimulatedFixedDistance");

	Params::TerrorRadiusEmitterComponent_SetSimulatedFixedDistance Parms{};

	Parms.Distance = Distance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.TerrorRadiusEmitterComponent.SetTerrorRadius
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTerrorRadiusEmitterComponent::SetTerrorRadius(float Radius)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TerrorRadiusEmitterComponent", "SetTerrorRadius");

	Params::TerrorRadiusEmitterComponent_SetTerrorRadius Parms{};

	Parms.Radius = Radius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.TerrorRadiusEmitterComponent.GetImitatesAudioOnly
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTerrorRadiusEmitterComponent::GetImitatesAudioOnly() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TerrorRadiusEmitterComponent", "GetImitatesAudioOnly");

	Params::TerrorRadiusEmitterComponent_GetImitatesAudioOnly Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.TerrorRadiusEmitterComponent.GetIsActive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTerrorRadiusEmitterComponent::GetIsActive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TerrorRadiusEmitterComponent", "GetIsActive");

	Params::TerrorRadiusEmitterComponent_GetIsActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.TerrorRadiusEmitterComponent.GetRadius
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTerrorRadiusEmitterComponent::GetRadius() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TerrorRadiusEmitterComponent", "GetRadius");

	Params::TerrorRadiusEmitterComponent_GetRadius Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.TerrorRadiusEmitterComponent.GetSimulatedFixedDistance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTerrorRadiusEmitterComponent::GetSimulatedFixedDistance() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TerrorRadiusEmitterComponent", "GetSimulatedFixedDistance");

	Params::TerrorRadiusEmitterComponent_GetSimulatedFixedDistance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.TerrorRadiusEmitterComponent.IsInTerrorRadius
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UTerrorRadiusReceiverComponent*   Receiver                                               (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTerrorRadiusEmitterComponent::IsInTerrorRadius(class UTerrorRadiusReceiverComponent* Receiver) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TerrorRadiusEmitterComponent", "IsInTerrorRadius");

	Params::TerrorRadiusEmitterComponent_IsInTerrorRadius Parms{};

	Parms.Receiver = Receiver;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.SlasherTerrorRadiusEmitterComponent.SetBaseTerrorRadius
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   baseTerrorRadius                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Progressive                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USlasherTerrorRadiusEmitterComponent::SetBaseTerrorRadius(float baseTerrorRadius, const bool Progressive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherTerrorRadiusEmitterComponent", "SetBaseTerrorRadius");

	Params::SlasherTerrorRadiusEmitterComponent_SetBaseTerrorRadius Parms{};

	Parms.baseTerrorRadius = baseTerrorRadius;
	Parms.Progressive = Progressive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.AISense_Terror.ReportTerrorEvent
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObj                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Instigator                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTerrorRadiusEmitterComponent*    TerrorEmitter                                          (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAISense_Terror::ReportTerrorEvent(class UObject* WorldContextObj, const struct FVector& Location, class AActor* Instigator, class UTerrorRadiusEmitterComponent* TerrorEmitter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AISense_Terror", "ReportTerrorEvent");

	Params::AISense_Terror_ReportTerrorEvent Parms{};

	Parms.WorldContextObj = WorldContextObj;
	Parms.Location = std::move(Location);
	Parms.Instigator = Instigator;
	Parms.TerrorEmitter = TerrorEmitter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.BlockFeedbackComponent.OnLocallyObservedChanged
// (Final, Native, Private)

void UBlockFeedbackComponent::OnLocallyObservedChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BlockFeedbackComponent", "OnLocallyObservedChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.PowerToggleComponent.OnRep_IsInPower
// (Final, Native, Private, Const)

void UPowerToggleComponent::OnRep_IsInPower() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PowerToggleComponent", "OnRep_IsInPower");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.BubbleIndicator.ActivateBubbleFX
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   Duration                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABubbleIndicator::ActivateBubbleFX(const float Duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BubbleIndicator", "ActivateBubbleFX");

	Params::BubbleIndicator_ActivateBubbleFX Parms{};

	Parms.Duration = Duration;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DBDGameplay.BubbleIndicator.DeactivateBubble
// (Final, Native, Protected, BlueprintCallable)

void ABubbleIndicator::DeactivateBubble()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BubbleIndicator", "DeactivateBubble");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.BubbleIndicator.RefreshBubbleVisibility
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    IsVisible                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABubbleIndicator::RefreshBubbleVisibility(const bool IsVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BubbleIndicator", "RefreshBubbleVisibility");

	Params::BubbleIndicator_RefreshBubbleVisibility Parms{};

	Parms.IsVisible = IsVisible;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DBDGameplay.BubbleIndicator.SetSilhouette
// (Event, Public, BlueprintEvent)
// Parameters:
// class UStaticMesh*                      StaticMesh                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABubbleIndicator::SetSilhouette(class UStaticMesh* StaticMesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BubbleIndicator", "SetSilhouette");

	Params::BubbleIndicator_SetSilhouette Parms{};

	Parms.StaticMesh = StaticMesh;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DBDGameplay.BubbleIndicatorNotifier.ActivateBubbleIndicator
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ABubbleIndicator*                 BubbleIndicator                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       Transform                                              (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    TriggerLoudNoise                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Lifetime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AudibleRange                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBubbleIndicatorNotifier::ActivateBubbleIndicator(class UObject* WorldContextObject, class ABubbleIndicator* BubbleIndicator, const struct FTransform& Transform, bool TriggerLoudNoise, float Lifetime, float AudibleRange)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BubbleIndicatorNotifier", "ActivateBubbleIndicator");

	Params::BubbleIndicatorNotifier_ActivateBubbleIndicator Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.BubbleIndicator = BubbleIndicator;
	Parms.Transform = std::move(Transform);
	Parms.TriggerLoudNoise = TriggerLoudNoise;
	Parms.Lifetime = Lifetime;
	Parms.AudibleRange = AudibleRange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.BubbleIndicatorNotifier.PreSpawnBubbleIndicator
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class ABubbleIndicator>     bubbleIndicatorBP                                      (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UStaticMesh*                      SilhouetteStaticMesh                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ABubbleIndicator*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ABubbleIndicator* UBubbleIndicatorNotifier::PreSpawnBubbleIndicator(class UObject* WorldContextObject, TSubclassOf<class ABubbleIndicator> bubbleIndicatorBP, class UStaticMesh* SilhouetteStaticMesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BubbleIndicatorNotifier", "PreSpawnBubbleIndicator");

	Params::BubbleIndicatorNotifier_PreSpawnBubbleIndicator Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.bubbleIndicatorBP = bubbleIndicatorBP;
	Parms.SilhouetteStaticMesh = SilhouetteStaticMesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.BubbleIndicatorNotifier.SpawnBubbleIndicator
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class ABubbleIndicator>     bubbleIndicatorBP                                      (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       Transform                                              (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    TriggerLoudNoise                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EBubbleShowedPlayerType                 ShowedPlayerType                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Lifetime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UStaticMesh*                      SilhouetteStaticMesh                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AudibleRange                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBubbleIndicatorNotifier::SpawnBubbleIndicator(class UObject* WorldContextObject, TSubclassOf<class ABubbleIndicator> bubbleIndicatorBP, const struct FTransform& Transform, bool TriggerLoudNoise, EBubbleShowedPlayerType ShowedPlayerType, float Lifetime, class UStaticMesh* SilhouetteStaticMesh, float AudibleRange)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BubbleIndicatorNotifier", "SpawnBubbleIndicator");

	Params::BubbleIndicatorNotifier_SpawnBubbleIndicator Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.bubbleIndicatorBP = bubbleIndicatorBP;
	Parms.Transform = std::move(Transform);
	Parms.TriggerLoudNoise = TriggerLoudNoise;
	Parms.ShowedPlayerType = ShowedPlayerType;
	Parms.Lifetime = Lifetime;
	Parms.SilhouetteStaticMesh = SilhouetteStaticMesh;
	Parms.AudibleRange = AudibleRange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.IgnoreWindowsCollisionsComponent.OnLevelReadyToPlay
// (Final, Native, Private)

void UIgnoreWindowsCollisionsComponent::OnLevelReadyToPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IgnoreWindowsCollisionsComponent", "OnLevelReadyToPlay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.CageHookPoolComponent.Multicast_SpawnTrapBlocker
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private, HasDefaults)
// Parameters:
// TArray<struct FTransform>               SpawnLocations                                         (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// struct FVector                          BoxExtent                                              (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCageHookPoolComponent::Multicast_SpawnTrapBlocker(const TArray<struct FTransform>& SpawnLocations, const struct FVector& BoxExtent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CageHookPoolComponent", "Multicast_SpawnTrapBlocker");

	Params::CageHookPoolComponent_Multicast_SpawnTrapBlocker Parms{};

	Parms.SpawnLocations = std::move(SpawnLocations);
	Parms.BoxExtent = std::move(BoxExtent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.SightRevealableComponent.Authority_IsBeingRevealed
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USightRevealableComponent::Authority_IsBeingRevealed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SightRevealableComponent", "Authority_IsBeingRevealed");

	Params::SightRevealableComponent_Authority_IsBeingRevealed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.CamperFootstepCreatorComponent.OnLoudNoiseTriggered
// (Final, Native, Protected, HasOutParams, HasDefaults)
// Parameters:
// class AActor*                           Originator                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InstigatingActor                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ShouldTrack                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AudibleRange                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsQuickAction                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsDeceivingNoise                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCamperFootstepCreatorComponent::OnLoudNoiseTriggered(class AActor* Originator, class AActor* InstigatingActor, const struct FVector& Location, bool ShouldTrack, float* AudibleRange, bool IsQuickAction, bool IsDeceivingNoise)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperFootstepCreatorComponent", "OnLoudNoiseTriggered");

	Params::CamperFootstepCreatorComponent_OnLoudNoiseTriggered Parms{};

	Parms.Originator = Originator;
	Parms.InstigatingActor = InstigatingActor;
	Parms.Location = std::move(Location);
	Parms.ShouldTrack = ShouldTrack;
	Parms.IsQuickAction = IsQuickAction;
	Parms.IsDeceivingNoise = IsDeceivingNoise;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (AudibleRange != nullptr)
		*AudibleRange = Parms.AudibleRange;
}


// Function DBDGameplay.CollectableComponentUtilities.GetCollector
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UActorComponent*                  Component                                              (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADBDPlayer* UCollectableComponentUtilities::GetCollector(const class UActorComponent* Component)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CollectableComponentUtilities", "GetCollector");

	Params::CollectableComponentUtilities_GetCollector Parms{};

	Parms.Component = Component;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.DecoySlasherComponent.CopyCustomizationFromSlasher
// (Final, Native, Private)

void UDecoySlasherComponent::CopyCustomizationFromSlasher()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DecoySlasherComponent", "CopyCustomizationFromSlasher");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.DecoySlasherComponent.DoPostVFXUpdates
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         Rotation                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UDecoySlasherComponent::DoPostVFXUpdates(const struct FVector& Location, const struct FRotator& Rotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DecoySlasherComponent", "DoPostVFXUpdates");

	Params::DecoySlasherComponent_DoPostVFXUpdates Parms{};

	Parms.Location = std::move(Location);
	Parms.Rotation = std::move(Rotation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.DecoySlasherComponent.OnRealSlasherTerrorRadiusChanged
// (Final, Native, Private)
// Parameters:
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDecoySlasherComponent::OnRealSlasherTerrorRadiusChanged(float NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DecoySlasherComponent", "OnRealSlasherTerrorRadiusChanged");

	Params::DecoySlasherComponent_OnRealSlasherTerrorRadiusChanged Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.DecoySlasherComponent.SetDecoyIsActive
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// bool                                    Param_IsActive                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         Rotation                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    VisibleRedGlow                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDecoySlasherComponent::SetDecoyIsActive(bool Param_IsActive, const struct FVector& Location, const struct FRotator& Rotation, bool VisibleRedGlow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DecoySlasherComponent", "SetDecoyIsActive");

	Params::DecoySlasherComponent_SetDecoyIsActive Parms{};

	Parms.Param_IsActive = Param_IsActive;
	Parms.Location = std::move(Location);
	Parms.Rotation = std::move(Rotation);
	Parms.VisibleRedGlow = VisibleRedGlow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.DecoySlasherComponent.GetRealSlasher
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ASlasherPlayer*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ASlasherPlayer* UDecoySlasherComponent::GetRealSlasher() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DecoySlasherComponent", "GetRealSlasher");

	Params::DecoySlasherComponent_GetRealSlasher Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.DecoySlasherComponent.IsDecoyActive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDecoySlasherComponent::IsDecoyActive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DecoySlasherComponent", "IsDecoyActive");

	Params::DecoySlasherComponent_IsDecoyActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.EndGameEffectsComponent.OnLocallyObservedChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEndGameEffectsComponent::OnLocallyObservedChanged(class ADBDPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EndGameEffectsComponent", "OnLocallyObservedChanged");

	Params::EndGameEffectsComponent_OnLocallyObservedChanged Parms{};

	Parms.Player = Player;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DBDGameplay.EndGameEffectsComponent.RegisterLocallyObservedEvents
// (Event, Protected, BlueprintCallable, BlueprintEvent)

void UEndGameEffectsComponent::RegisterLocallyObservedEvents()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EndGameEffectsComponent", "RegisterLocallyObservedEvents");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DBDGameplay.EndGameEffectsComponent.StartUpdateTimer
// (Event, Protected, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGameplayTag                     GameEventType                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameEventData                   GameEventData                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UEndGameEffectsComponent::StartUpdateTimer(const struct FGameplayTag& GameEventType, const struct FGameEventData& GameEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EndGameEffectsComponent", "StartUpdateTimer");

	Params::EndGameEffectsComponent_StartUpdateTimer Parms{};

	Parms.GameEventType = std::move(GameEventType);
	Parms.GameEventData = std::move(GameEventData);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DBDGameplay.EndGameEffectsComponent.UnregisterLocallyObservedEvents
// (Event, Protected, BlueprintCallable, BlueprintEvent)

void UEndGameEffectsComponent::UnregisterLocallyObservedEvents()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EndGameEffectsComponent", "UnregisterLocallyObservedEvents");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DBDGameplay.EtherealComponent.OnRep_OnIsEtherealChanged
// (Final, Native, Private)

void UEtherealComponent::OnRep_OnIsEtherealChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EtherealComponent", "OnRep_OnIsEtherealChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.EtherealComponent.Server_SetIsEthereal
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// float                                   Timestamp                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Ethereal                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEtherealComponent::Server_SetIsEthereal(float Timestamp, bool Ethereal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EtherealComponent", "Server_SetIsEthereal");

	Params::EtherealComponent_Server_SetIsEthereal Parms{};

	Parms.Timestamp = Timestamp;
	Parms.Ethereal = Ethereal;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.RangeToActorsTrackerStrategy.OnInRangeToTrackedActorsChanged
// (Final, Native, Private)
// Parameters:
// bool                                    InRange                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URangeToActorsTrackerStrategy::OnInRangeToTrackedActorsChanged(const bool InRange)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RangeToActorsTrackerStrategy", "OnInRangeToTrackedActorsChanged");

	Params::RangeToActorsTrackerStrategy_OnInRangeToTrackedActorsChanged Parms{};

	Parms.InRange = InRange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.FadingBlockFeedback.OnFadeOutEnded
// (BlueprintCosmetic, Event, Public, BlueprintEvent)

void AFadingBlockFeedback::OnFadeOutEnded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FadingBlockFeedback", "OnFadeOutEnded");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DBDGameplay.FadingBlockFeedback.OnFadeOutStarted
// (BlueprintCosmetic, Event, Public, BlueprintEvent)
// Parameters:
// float                                   FadeDuration                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFadingBlockFeedback::OnFadeOutStarted(const float FadeDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FadingBlockFeedback", "OnFadeOutStarted");

	Params::FadingBlockFeedback_OnFadeOutStarted Parms{};

	Parms.FadeDuration = FadeDuration;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DBDGameplay.Flashlight.GetSpotlightComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USpotLightComponent*              ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USpotLightComponent* AFlashlight::GetSpotlightComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Flashlight", "GetSpotlightComponent");

	Params::Flashlight_GetSpotlightComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction DBDGameplay.FlashlightableComponent.OnFlashlightAddedRemovedEvent__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// class UFlashlightComponent*             Flashlight                                             (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFlashlightableComponent::OnFlashlightAddedRemovedEvent__DelegateSignature(const class UFlashlightComponent* Flashlight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlashlightableComponent", "OnFlashlightAddedRemovedEvent__DelegateSignature");

	Params::FlashlightableComponent_OnFlashlightAddedRemovedEvent__DelegateSignature Parms{};

	Parms.Flashlight = Flashlight;

	UObject::ProcessEvent(Func, &Parms);
}


// DelegateFunction DBDGameplay.FlashlightableComponent.OnFlashlightLitChangedEvent__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// bool                                    IsLit                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFlashlightableComponent::OnFlashlightLitChangedEvent__DelegateSignature(bool IsLit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlashlightableComponent", "OnFlashlightLitChangedEvent__DelegateSignature");

	Params::FlashlightableComponent_OnFlashlightLitChangedEvent__DelegateSignature Parms{};

	Parms.IsLit = IsLit;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DBDGameplay.FlashlightableComponent.IsLit
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFlashlightableComponent::IsLit() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlashlightableComponent", "IsLit");

	Params::FlashlightableComponent_IsLit Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction DBDGameplay.FlashlightComponent.OnFlashlightEvent__DelegateSignature
// (MulticastDelegate, Public, Delegate)

void UFlashlightComponent::OnFlashlightEvent__DelegateSignature()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlashlightComponent", "OnFlashlightEvent__DelegateSignature");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DBDGameplay.FlashlightComponent.OnRep_IsOwnerLagging
// (Final, Native, Private)

void UFlashlightComponent::OnRep_IsOwnerLagging()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlashlightComponent", "OnRep_IsOwnerLagging");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.FlashlightComponent.OnRep_ReplicatedLitFlashlightables
// (Final, Native, Private)

void UFlashlightComponent::OnRep_ReplicatedLitFlashlightables()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlashlightComponent", "OnRep_ReplicatedLitFlashlightables");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.FlashlightComponent.Server_SetAndUpdateAutonomousLitFlashlightables
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// TArray<class UFlashlightableComponent*> NewLitFlashlightables                                  (ConstParm, Parm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UFlashlightComponent::Server_SetAndUpdateAutonomousLitFlashlightables(const TArray<class UFlashlightableComponent*>& NewLitFlashlightables)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlashlightComponent", "Server_SetAndUpdateAutonomousLitFlashlightables");

	Params::FlashlightComponent_Server_SetAndUpdateAutonomousLitFlashlightables Parms{};

	Parms.NewLitFlashlightables = std::move(NewLitFlashlightables);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.FlashlightComponent.TurnOff
// (Final, Native, Public, BlueprintCallable)

void UFlashlightComponent::TurnOff()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlashlightComponent", "TurnOff");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.FlashlightComponent.TurnOn
// (Final, Native, Public, BlueprintCallable)

void UFlashlightComponent::TurnOn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlashlightComponent", "TurnOn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.FlashlightComponent.GetEffectiveBlindnessDuration
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UFlashlightComponent::GetEffectiveBlindnessDuration() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlashlightComponent", "GetEffectiveBlindnessDuration");

	Params::FlashlightComponent_GetEffectiveBlindnessDuration Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.FlashlightComponent.GetEffectiveTimeToBlindModifier
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UFlashlightComponent::GetEffectiveTimeToBlindModifier() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlashlightComponent", "GetEffectiveTimeToBlindModifier");

	Params::FlashlightComponent_GetEffectiveTimeToBlindModifier Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.FlashlightComponent.IsOn
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFlashlightComponent::IsOn() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlashlightComponent", "IsOn");

	Params::FlashlightComponent_IsOn Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.FlashlightConeComponent.GetEffectiveConeHalfAngle
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UFlashlightConeComponent::GetEffectiveConeHalfAngle() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlashlightConeComponent", "GetEffectiveConeHalfAngle");

	Params::FlashlightConeComponent_GetEffectiveConeHalfAngle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.FlashlightConeComponent.GetEffectiveConeLength
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UFlashlightConeComponent::GetEffectiveConeLength() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlashlightConeComponent", "GetEffectiveConeLength");

	Params::FlashlightConeComponent_GetEffectiveConeLength Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.FlashlightConeComponent.GetOcclusionDistance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UFlashlightConeComponent::GetOcclusionDistance() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlashlightConeComponent", "GetOcclusionDistance");

	Params::FlashlightConeComponent_GetOcclusionDistance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.FlashlightFXComponent.OnCollectedEvent
// (Event, Protected, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       Collector                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFlashlightFXComponent::OnCollectedEvent(class ADBDPlayer* Collector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlashlightFXComponent", "OnCollectedEvent");

	Params::FlashlightFXComponent_OnCollectedEvent Parms{};

	Parms.Collector = Collector;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DBDGameplay.FlashlightFXComponent.OnCollectorLocallyObservedChangedEvent
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    IsLocallyObserved                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFlashlightFXComponent::OnCollectorLocallyObservedChangedEvent(bool IsLocallyObserved)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlashlightFXComponent", "OnCollectorLocallyObservedChangedEvent");

	Params::FlashlightFXComponent_OnCollectorLocallyObservedChangedEvent Parms{};

	Parms.IsLocallyObserved = IsLocallyObserved;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DBDGameplay.FlashlightFXComponent.OnDroppedEvent
// (Event, Protected, BlueprintEvent)

void UFlashlightFXComponent::OnDroppedEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlashlightFXComponent", "OnDroppedEvent");

	UObject::ProcessEvent(Func, nullptr);
}


// DelegateFunction DBDGameplay.FlashlightFXComponent.OnFlashEvent__DelegateSignature
// (MulticastDelegate, Public, Delegate)

void UFlashlightFXComponent::OnFlashEvent__DelegateSignature()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlashlightFXComponent", "OnFlashEvent__DelegateSignature");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DBDGameplay.FlashlightFXComponent.OnStartEvent
// (Event, Protected, BlueprintEvent)

void UFlashlightFXComponent::OnStartEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlashlightFXComponent", "OnStartEvent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DBDGameplay.FlashlightFXComponent.OnStopEvent
// (Event, Protected, BlueprintEvent)

void UFlashlightFXComponent::OnStopEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlashlightFXComponent", "OnStopEvent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DBDGameplay.FlashlightFXComponent.OnTurnedOff
// (Final, Native, Private)

void UFlashlightFXComponent::OnTurnedOff()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlashlightFXComponent", "OnTurnedOff");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.FlashlightFXComponent.OnTurnedOn
// (Final, Native, Private)

void UFlashlightFXComponent::OnTurnedOn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlashlightFXComponent", "OnTurnedOn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.FlashlightFXComponent.PostUpdateEvent
// (Event, Protected, BlueprintEvent)

void UFlashlightFXComponent::PostUpdateEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlashlightFXComponent", "PostUpdateEvent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DBDGameplay.FlashlightFXComponent.UpdateConeEvent
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                                   Length                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   HalfAngle                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFlashlightFXComponent::UpdateConeEvent(float Length, float HalfAngle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlashlightFXComponent", "UpdateConeEvent");

	Params::FlashlightFXComponent_UpdateConeEvent Parms{};

	Parms.Length = Length;
	Parms.HalfAngle = HalfAngle;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DBDGameplay.FlashlightFXComponent.UpdateFXTargets
// (Final, Native, Private)

void UFlashlightFXComponent::UpdateFXTargets()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlashlightFXComponent", "UpdateFXTargets");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.FlashlightFXComponent.GetBlindingSuccessRatio
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UFlashlightFXComponent::GetBlindingSuccessRatio() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlashlightFXComponent", "GetBlindingSuccessRatio");

	Params::FlashlightFXComponent_GetBlindingSuccessRatio Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.FootstepManagerComponent.OnUpdateCreatorFootsteps
// (Final, Native, Public)
// Parameters:
// class UFootstepCreatorComponent*        Creator                                                (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFootstepManagerComponent::OnUpdateCreatorFootsteps(class UFootstepCreatorComponent* Creator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FootstepManagerComponent", "OnUpdateCreatorFootsteps");

	Params::FootstepManagerComponent_OnUpdateCreatorFootsteps Parms{};

	Parms.Creator = Creator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.FootstepManagerComponent.OnUpdateObserverFootsteps
// (Final, Native, Public)

void UFootstepManagerComponent::OnUpdateObserverFootsteps()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FootstepManagerComponent", "OnUpdateObserverFootsteps");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.FootstepManagerComponent.TriggerSpawnFootstep
// (Final, Native, Public, HasDefaults)
// Parameters:
// class UFootstepCreatorComponent*        OriginatorComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFootstepManagerComponent::TriggerSpawnFootstep(class UFootstepCreatorComponent* OriginatorComponent, const struct FVector& Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FootstepManagerComponent", "TriggerSpawnFootstep");

	Params::FootstepManagerComponent_TriggerSpawnFootstep Parms{};

	Parms.OriginatorComponent = OriginatorComponent;
	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.GeneratorWithMostProgressTracker.OnGeneratorCompleted
// (Final, Native, Private)
// Parameters:
// bool                                    IsAutoCompleted                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGeneratorWithMostProgressTracker::OnGeneratorCompleted(bool IsAutoCompleted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorWithMostProgressTracker", "OnGeneratorCompleted");

	Params::GeneratorWithMostProgressTracker_OnGeneratorCompleted Parms{};

	Parms.IsAutoCompleted = IsAutoCompleted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.GeneratorWithMostProgressTracker.OnLevelReadyToPlay
// (Final, Native, Private)

void UGeneratorWithMostProgressTracker::OnLevelReadyToPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorWithMostProgressTracker", "OnLevelReadyToPlay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.GlassBeadMapAddon.Authority_OnSecondaryInputPressed
// (Final, Native, Private)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInteractionDefinition*           Interaction                                            (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    FromCancelRequest                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGlassBeadMapAddon::Authority_OnSecondaryInputPressed(class ADBDPlayer* Player, class UInteractionDefinition* Interaction, bool FromCancelRequest)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GlassBeadMapAddon", "Authority_OnSecondaryInputPressed");

	Params::GlassBeadMapAddon_Authority_OnSecondaryInputPressed Parms{};

	Parms.Player = Player;
	Parms.Interaction = Interaction;
	Parms.FromCancelRequest = FromCancelRequest;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.IgnorePalletsCollisionsComponent.OnLevelReadyToPlay
// (Final, Native, Private)

void UIgnorePalletsCollisionsComponent::OnLevelReadyToPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IgnorePalletsCollisionsComponent", "OnLevelReadyToPlay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.InteractionAttacherComponent.OnRep_ChargeableComponents
// (Final, Native, Private)

void UInteractionAttacherComponent::OnRep_ChargeableComponents()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionAttacherComponent", "OnRep_ChargeableComponents");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.InteractionAttacherComponent.OnRep_InteractionDefinitions
// (Final, Native, Private)

void UInteractionAttacherComponent::OnRep_InteractionDefinitions()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionAttacherComponent", "OnRep_InteractionDefinitions");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.InteractionStarterComponent.OnInteractionStarted
// (Final, Native, Private)

void UInteractionStarterComponent::OnInteractionStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionStarterComponent", "OnInteractionStarted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.InteractionStarterComponent.OnRep_ShouldStartInteraction
// (Final, Native, Private)

void UInteractionStarterComponent::OnRep_ShouldStartInteraction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionStarterComponent", "OnRep_ShouldStartInteraction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.KillerInstinctComponent.GetParticleSystem
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// class UNiagaraComponent*                ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNiagaraComponent* UKillerInstinctComponent::GetParticleSystem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerInstinctComponent", "GetParticleSystem");

	Params::KillerInstinctComponent_GetParticleSystem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.KillerInstinctComponent.OnKillerLocallyObservedChanged
// (Final, Native, Private)
// Parameters:
// bool                                    LocallyObserved                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKillerInstinctComponent::OnKillerLocallyObservedChanged(bool LocallyObserved)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerInstinctComponent", "OnKillerLocallyObservedChanged");

	Params::KillerInstinctComponent_OnKillerLocallyObservedChanged Parms{};

	Parms.LocallyObserved = LocallyObserved;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.KillerInstinctComponent.SetParticleSystem
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class UNiagaraComponent*                ParticleSystemComponent                                (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKillerInstinctComponent::SetParticleSystem(class UNiagaraComponent* ParticleSystemComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerInstinctComponent", "SetParticleSystem");

	Params::KillerInstinctComponent_SetParticleSystem Parms{};

	Parms.ParticleSystemComponent = ParticleSystemComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.KillerPowerUtilities.GetKillerPowerFromPlayer
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ADBDPlayer*                       Player                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AKillerPower*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AKillerPower* UKillerPowerUtilities::GetKillerPowerFromPlayer(const class ADBDPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KillerPowerUtilities", "GetKillerPowerFromPlayer");

	Params::KillerPowerUtilities_GetKillerPowerFromPlayer Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.MapCollectable.OnReadMapInteractionFinished
// (Final, Native, Private)

void AMapCollectable::OnReadMapInteractionFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapCollectable", "OnReadMapInteractionFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.MapCollectable.GetActorKnowledgeCollection
// (Event, Public, BlueprintEvent, Const)
// Parameters:
// class UActorKnowledgeCollection*        ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UActorKnowledgeCollection* AMapCollectable::GetActorKnowledgeCollection() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapCollectable", "GetActorKnowledgeCollection");

	Params::MapCollectable_GetActorKnowledgeCollection Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DBDGameplay.MapCollectable.GetChargeableComponent
// (Event, Public, BlueprintEvent, Const)
// Parameters:
// class UChargeableComponent*             ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UChargeableComponent* AMapCollectable::GetChargeableComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapCollectable", "GetChargeableComponent");

	Params::MapCollectable_GetChargeableComponent Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DBDGameplay.MapCollectable.GetChargerComponent
// (Event, Public, BlueprintEvent, Const)
// Parameters:
// class UChargerComponent*                ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UChargerComponent* AMapCollectable::GetChargerComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapCollectable", "GetChargerComponent");

	Params::MapCollectable_GetChargerComponent Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DBDGameplay.MapMarkerActor.OnDestroy
// (Event, Protected, BlueprintEvent)

void AMapMarkerActor::OnDestroy()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapMarkerActor", "OnDestroy");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DBDGameplay.Medkit.Authority_ConsumeIfNotInteracting
// (Final, Native, Protected)

void AMedkit::Authority_ConsumeIfNotInteracting()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Medkit", "Authority_ConsumeIfNotInteracting");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.Medkit.Authority_OnAnyOngoingInteractionChanged
// (Final, Native, Protected)
// Parameters:
// bool                                    IsInteracting                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMedkit::Authority_OnAnyOngoingInteractionChanged(const bool IsInteracting)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Medkit", "Authority_OnAnyOngoingInteractionChanged");

	Params::Medkit_Authority_OnAnyOngoingInteractionChanged Parms{};

	Parms.IsInteracting = IsInteracting;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.Medkit.Authority_OnChargeStateChange
// (Final, Native, Protected)
// Parameters:
// bool                                    Empty                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMedkit::Authority_OnChargeStateChange(const bool Empty)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Medkit", "Authority_OnChargeStateChange");

	Params::Medkit_Authority_OnChargeStateChange Parms{};

	Parms.Empty = Empty;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.Medkit.OnMedkitHealedCamper
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       HealedPlayer                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMedkit::OnMedkitHealedCamper(class ADBDPlayer* HealedPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Medkit", "OnMedkitHealedCamper");

	Params::Medkit_OnMedkitHealedCamper Parms{};

	Parms.HealedPlayer = HealedPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.Medkit.UseCharge
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Seconds                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMedkit::UseCharge(float Seconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Medkit", "UseCharge");

	Params::Medkit_UseCharge Parms{};

	Parms.Seconds = Seconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.Medkit.GetCharge
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AMedkit::GetCharge() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Medkit", "GetCharge");

	Params::Medkit_GetCharge Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.Medkit.GetChargeMultiplier
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AMedkit::GetChargeMultiplier() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Medkit", "GetChargeMultiplier");

	Params::Medkit_GetChargeMultiplier Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.Medkit.HasCharge
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMedkit::HasCharge() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Medkit", "HasCharge");

	Params::Medkit_HasCharge Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.MoveToGroundComponent.MoveOwnerToGround
// (Final, Native, Private)

void UMoveToGroundComponent::MoveOwnerToGround()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MoveToGroundComponent", "MoveOwnerToGround");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.NearestOutsideMapBoundsLocator.Client_InitializeAkLimitPointEvent
// (Final, Native, Private)

void UNearestOutsideMapBoundsLocator::Client_InitializeAkLimitPointEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NearestOutsideMapBoundsLocator", "Client_InitializeAkLimitPointEvent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.NearestOutsideMapBoundsLocator.OnGameBegin
// (Final, Native, Private)

void UNearestOutsideMapBoundsLocator::OnGameBegin()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NearestOutsideMapBoundsLocator", "OnGameBegin");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.NearestOutsideMapBoundsLocator.OnGameEnd
// (Final, Native, Private)
// Parameters:
// EEndGameReason                          EndGameReason                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNearestOutsideMapBoundsLocator::OnGameEnd(EEndGameReason EndGameReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NearestOutsideMapBoundsLocator", "OnGameEnd");

	Params::NearestOutsideMapBoundsLocator_OnGameEnd Parms{};

	Parms.EndGameReason = EndGameReason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.Passage.Cosmetic_OnPlayerInRangeChanged
// (Final, Native, Private)
// Parameters:
// bool                                    InRange                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       Player                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APassage::Cosmetic_OnPlayerInRangeChanged(const bool InRange, const class ADBDPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Passage", "Cosmetic_OnPlayerInRangeChanged");

	Params::Passage_Cosmetic_OnPlayerInRangeChanged Parms{};

	Parms.InRange = InRange;
	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// DelegateFunction DBDGameplay.Passage.CosmeticPassageEventDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// EPassageCosmeticState                   NewState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPassageCosmeticState                   OldState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APassage::CosmeticPassageEventDelegate__DelegateSignature(EPassageCosmeticState NewState, EPassageCosmeticState OldState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Passage", "CosmeticPassageEventDelegate__DelegateSignature");

	Params::Passage_CosmeticPassageEventDelegate__DelegateSignature Parms{};

	Parms.NewState = NewState;
	Parms.OldState = OldState;

	UObject::ProcessEvent(Func, &Parms);
}


// DelegateFunction DBDGameplay.Passage.CosmeticPlayerInRangeOfPassageEvent__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// class ADBDPlayer*                       Player                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsInRange                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APassage::CosmeticPlayerInRangeOfPassageEvent__DelegateSignature(const class ADBDPlayer* Player, bool IsInRange)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Passage", "CosmeticPlayerInRangeOfPassageEvent__DelegateSignature");

	Params::Passage_CosmeticPlayerInRangeOfPassageEvent__DelegateSignature Parms{};

	Parms.Player = Player;
	Parms.IsInRange = IsInRange;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DBDGameplay.Passage.Local_OnPlayerLeftGame
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FGameplayTag                     GameplayTag                                            (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameEventData                   GameEventData                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void APassage::Local_OnPlayerLeftGame(const struct FGameplayTag& GameplayTag, const struct FGameEventData& GameEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Passage", "Local_OnPlayerLeftGame");

	Params::Passage_Local_OnPlayerLeftGame Parms{};

	Parms.GameplayTag = std::move(GameplayTag);
	Parms.GameEventData = std::move(GameEventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.Passage.Local_OnPlayerLocallyObservedChanged
// (Final, Native, Private)
// Parameters:
// bool                                    IsObserved                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       Player                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APassage::Local_OnPlayerLocallyObservedChanged(bool IsObserved, const class ADBDPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Passage", "Local_OnPlayerLocallyObservedChanged");

	Params::Passage_Local_OnPlayerLocallyObservedChanged Parms{};

	Parms.IsObserved = IsObserved;
	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.Passage.OnBeginOverlapRevealExitAuraZone
// (Final, Native, Private, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              HitComponent                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void APassage::OnBeginOverlapRevealExitAuraZone(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Passage", "OnBeginOverlapRevealExitAuraZone");

	Params::Passage_OnBeginOverlapRevealExitAuraZone Parms{};

	Parms.HitComponent = HitComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.Passage.OnEndOverlapRevealExitAuraZone
// (Final, Native, Private)
// Parameters:
// class UPrimitiveComponent*              HitComponent                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APassage::OnEndOverlapRevealExitAuraZone(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Passage", "OnEndOverlapRevealExitAuraZone");

	Params::Passage_OnEndOverlapRevealExitAuraZone Parms{};

	Parms.HitComponent = HitComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.Passage.GetConnectedPassage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class APassage*                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APassage* APassage::GetConnectedPassage() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Passage", "GetConnectedPassage");

	Params::Passage_GetConnectedPassage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.Passage.GetPassageCosmeticState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EPassageCosmeticState                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EPassageCosmeticState APassage::GetPassageCosmeticState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Passage", "GetPassageCosmeticState");

	Params::Passage_GetPassageCosmeticState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction DBDGameplay.PassageEnterInteraction.CosmeticPassageInteractionEventDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPassageEnterInteraction::CosmeticPassageInteractionEventDelegate__DelegateSignature(class ADBDPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PassageEnterInteraction", "CosmeticPassageInteractionEventDelegate__DelegateSignature");

	Params::PassageEnterInteraction_CosmeticPassageInteractionEventDelegate__DelegateSignature Parms{};

	Parms.Player = Player;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DBDGameplay.PassageEnterInteraction.GetOwningPassage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class APassage*                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APassage* UPassageEnterInteraction::GetOwningPassage() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PassageEnterInteraction", "GetOwningPassage");

	Params::PassageEnterInteraction_GetOwningPassage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction DBDGameplay.PlayerInteractionListenerComponent.InteractionDelegate__DelegateSignature
// (Public, Delegate)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     InteractionSemantic                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInteractionListenerComponent::InteractionDelegate__DelegateSignature(class ADBDPlayer* Player, const struct FGameplayTag& InteractionSemantic)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInteractionListenerComponent", "InteractionDelegate__DelegateSignature");

	Params::PlayerInteractionListenerComponent_InteractionDelegate__DelegateSignature Parms{};

	Parms.Player = Player;
	Parms.InteractionSemantic = std::move(InteractionSemantic);

	UObject::ProcessEvent(Func, &Parms);
}


// DelegateFunction DBDGameplay.PlayerInteractionListenerComponent.InteractionMulticastDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     InteractionSemantic                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInteractionListenerComponent::InteractionMulticastDelegate__DelegateSignature(class ADBDPlayer* Player, const struct FGameplayTag& InteractionSemantic)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInteractionListenerComponent", "InteractionMulticastDelegate__DelegateSignature");

	Params::PlayerInteractionListenerComponent_InteractionMulticastDelegate__DelegateSignature Parms{};

	Parms.Player = Player;
	Parms.InteractionSemantic = std::move(InteractionSemantic);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DBDGameplay.PlayerInteractionListenerComponent.ListenToInteractionEnd
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     InteractionSemantic                                    (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(class ADBDPlayer* Player, const struct FGameplayTag& InteractionSemantic)>InteractionDelegate                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInteractionListenerComponent::ListenToInteractionEnd(class ADBDPlayer* Player, const struct FGameplayTag& InteractionSemantic, const TDelegate<void(class ADBDPlayer* Player, const struct FGameplayTag& InteractionSemantic)>& InteractionDelegate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInteractionListenerComponent", "ListenToInteractionEnd");

	Params::PlayerInteractionListenerComponent_ListenToInteractionEnd Parms{};

	Parms.Player = Player;
	Parms.InteractionSemantic = std::move(InteractionSemantic);
	Parms.InteractionDelegate = InteractionDelegate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.PlayerInteractionListenerComponent.ListenToInteractionStart
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     InteractionSemantic                                    (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(class ADBDPlayer* Player, const struct FGameplayTag& InteractionSemantic)>InteractionDelegate                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInteractionListenerComponent::ListenToInteractionStart(class ADBDPlayer* Player, const struct FGameplayTag& InteractionSemantic, const TDelegate<void(class ADBDPlayer* Player, const struct FGameplayTag& InteractionSemantic)>& InteractionDelegate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInteractionListenerComponent", "ListenToInteractionStart");

	Params::PlayerInteractionListenerComponent_ListenToInteractionStart Parms{};

	Parms.Player = Player;
	Parms.InteractionSemantic = std::move(InteractionSemantic);
	Parms.InteractionDelegate = InteractionDelegate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.PlayerInteractionListenerComponent.OnActorDestroyed
// (Final, Native, Private)
// Parameters:
// class AActor*                           DestroyedActor                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInteractionListenerComponent::OnActorDestroyed(class AActor* DestroyedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInteractionListenerComponent", "OnActorDestroyed");

	Params::PlayerInteractionListenerComponent_OnActorDestroyed Parms{};

	Parms.DestroyedActor = DestroyedActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.PlayerInteractionListenerComponent.UnlistenToInteractionEnd
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     InteractionSemantic                                    (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInteractionListenerComponent::UnlistenToInteractionEnd(class ADBDPlayer* Player, const struct FGameplayTag& InteractionSemantic)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInteractionListenerComponent", "UnlistenToInteractionEnd");

	Params::PlayerInteractionListenerComponent_UnlistenToInteractionEnd Parms{};

	Parms.Player = Player;
	Parms.InteractionSemantic = std::move(InteractionSemantic);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.PlayerInteractionListenerComponent.UnlistenToInteractionStart
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     InteractionSemantic                                    (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInteractionListenerComponent::UnlistenToInteractionStart(class ADBDPlayer* Player, const struct FGameplayTag& InteractionSemantic)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInteractionListenerComponent", "UnlistenToInteractionStart");

	Params::PlayerInteractionListenerComponent_UnlistenToInteractionStart Parms{};

	Parms.Player = Player;
	Parms.InteractionSemantic = std::move(InteractionSemantic);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.PlayerMovementUtilities.Local_ApplyGamepadPitchScaleMultiplier
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Multiplier                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AdjustmentTime                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerMovementUtilities::Local_ApplyGamepadPitchScaleMultiplier(class ADBDPlayer* Player, const float Multiplier, const float AdjustmentTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PlayerMovementUtilities", "Local_ApplyGamepadPitchScaleMultiplier");

	Params::PlayerMovementUtilities_Local_ApplyGamepadPitchScaleMultiplier Parms{};

	Parms.Player = Player;
	Parms.Multiplier = Multiplier;
	Parms.AdjustmentTime = AdjustmentTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.PlayerMovementUtilities.Local_ApplyGamepadYawScaleMultiplier
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Multiplier                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AdjustmentTime                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerMovementUtilities::Local_ApplyGamepadYawScaleMultiplier(class ADBDPlayer* Player, const float Multiplier, const float AdjustmentTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PlayerMovementUtilities", "Local_ApplyGamepadYawScaleMultiplier");

	Params::PlayerMovementUtilities_Local_ApplyGamepadYawScaleMultiplier Parms{};

	Parms.Player = Player;
	Parms.Multiplier = Multiplier;
	Parms.AdjustmentTime = AdjustmentTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.PlayerMovementUtilities.Local_ApplyMousePitchScaleMultiplier
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Multiplier                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AdjustmentTime                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerMovementUtilities::Local_ApplyMousePitchScaleMultiplier(class ADBDPlayer* Player, const float Multiplier, const float AdjustmentTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PlayerMovementUtilities", "Local_ApplyMousePitchScaleMultiplier");

	Params::PlayerMovementUtilities_Local_ApplyMousePitchScaleMultiplier Parms{};

	Parms.Player = Player;
	Parms.Multiplier = Multiplier;
	Parms.AdjustmentTime = AdjustmentTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.PlayerMovementUtilities.Local_ApplyMouseYawScaleMultiplier
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Multiplier                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AdjustmentTime                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerMovementUtilities::Local_ApplyMouseYawScaleMultiplier(class ADBDPlayer* Player, const float Multiplier, const float AdjustmentTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PlayerMovementUtilities", "Local_ApplyMouseYawScaleMultiplier");

	Params::PlayerMovementUtilities_Local_ApplyMouseYawScaleMultiplier Parms{};

	Parms.Player = Player;
	Parms.Multiplier = Multiplier;
	Parms.AdjustmentTime = AdjustmentTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.PlayerMovementUtilities.Local_ApplyPitchScaleMultiplier
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Multiplier                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AdjustmentTime                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerMovementUtilities::Local_ApplyPitchScaleMultiplier(class ADBDPlayer* Player, const float Multiplier, const float AdjustmentTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PlayerMovementUtilities", "Local_ApplyPitchScaleMultiplier");

	Params::PlayerMovementUtilities_Local_ApplyPitchScaleMultiplier Parms{};

	Parms.Player = Player;
	Parms.Multiplier = Multiplier;
	Parms.AdjustmentTime = AdjustmentTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.PlayerMovementUtilities.Local_ApplyRotationScaleMultiplier
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Multiplier                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AdjustmentTime                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerMovementUtilities::Local_ApplyRotationScaleMultiplier(class ADBDPlayer* Player, const float Multiplier, const float AdjustmentTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PlayerMovementUtilities", "Local_ApplyRotationScaleMultiplier");

	Params::PlayerMovementUtilities_Local_ApplyRotationScaleMultiplier Parms{};

	Parms.Player = Player;
	Parms.Multiplier = Multiplier;
	Parms.AdjustmentTime = AdjustmentTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.PlayerMovementUtilities.Local_ApplyYawScaleMultiplier
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Multiplier                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AdjustmentTime                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerMovementUtilities::Local_ApplyYawScaleMultiplier(class ADBDPlayer* Player, const float Multiplier, const float AdjustmentTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PlayerMovementUtilities", "Local_ApplyYawScaleMultiplier");

	Params::PlayerMovementUtilities_Local_ApplyYawScaleMultiplier Parms{};

	Parms.Player = Player;
	Parms.Multiplier = Multiplier;
	Parms.AdjustmentTime = AdjustmentTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.PlayerMovementUtilities.Local_ResetGamepadLookCurves
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerMovementUtilities::Local_ResetGamepadLookCurves(class ADBDPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PlayerMovementUtilities", "Local_ResetGamepadLookCurves");

	Params::PlayerMovementUtilities_Local_ResetGamepadLookCurves Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.PlayerMovementUtilities.Local_ResetRotationScale
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AdjustmentTime                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerMovementUtilities::Local_ResetRotationScale(class ADBDPlayer* Player, const float AdjustmentTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PlayerMovementUtilities", "Local_ResetRotationScale");

	Params::PlayerMovementUtilities_Local_ResetRotationScale Parms{};

	Parms.Player = Player;
	Parms.AdjustmentTime = AdjustmentTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.PlayerMovementUtilities.Local_SetGamepadPitchCurve
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCurveFloat*                      Curve                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerMovementUtilities::Local_SetGamepadPitchCurve(class ADBDPlayer* Player, class UCurveFloat* Curve)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PlayerMovementUtilities", "Local_SetGamepadPitchCurve");

	Params::PlayerMovementUtilities_Local_SetGamepadPitchCurve Parms{};

	Parms.Player = Player;
	Parms.Curve = Curve;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.PlayerMovementUtilities.Local_SetGamepadYawCurve
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCurveFloat*                      Curve                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerMovementUtilities::Local_SetGamepadYawCurve(class ADBDPlayer* Player, class UCurveFloat* Curve)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PlayerMovementUtilities", "Local_SetGamepadYawCurve");

	Params::PlayerMovementUtilities_Local_SetGamepadYawCurve Parms{};

	Parms.Player = Player;
	Parms.Curve = Curve;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.PlayersInZoneTracker.Authority_OnBeginPlayerOverlap
// (Final, Native, Private, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Other                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UPlayersInZoneTracker::Authority_OnBeginPlayerOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayersInZoneTracker", "Authority_OnBeginPlayerOverlap");

	Params::PlayersInZoneTracker_Authority_OnBeginPlayerOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.Other = Other;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.PlayersInZoneTracker.Authority_OnEndPlayerOverlap
// (Final, Native, Private)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayersInZoneTracker::Authority_OnEndPlayerOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayersInZoneTracker", "Authority_OnEndPlayerOverlap");

	Params::PlayersInZoneTracker_Authority_OnEndPlayerOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// DelegateFunction DBDGameplay.PlayersInZoneTracker.OnCosmeticNeeded__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayersInZoneTracker::OnCosmeticNeeded__DelegateSignature(class ADBDPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayersInZoneTracker", "OnCosmeticNeeded__DelegateSignature");

	Params::PlayersInZoneTracker_OnCosmeticNeeded__DelegateSignature Parms{};

	Parms.Player = Player;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DBDGameplay.PlayersInZoneTracker.OnRep_PlayersInRange
// (Final, Native, Private)

void UPlayersInZoneTracker::OnRep_PlayersInRange()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayersInZoneTracker", "OnRep_PlayersInRange");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.ZoneComponent.OnRep_CurrentZone
// (Final, Native, Protected)

void UZoneComponent::OnRep_CurrentZone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ZoneComponent", "OnRep_CurrentZone");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.PowerChargeComponent.OnCurrentChargeChanged
// (Final, Native, Private)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPowerChargeComponent::OnCurrentChargeChanged(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PowerChargeComponent", "OnCurrentChargeChanged");

	Params::PowerChargeComponent_OnCurrentChargeChanged Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.PowerChargeComponent.OnRep_CurrentCharge
// (Final, Native, Private)

void UPowerChargeComponent::OnRep_CurrentCharge()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PowerChargeComponent", "OnRep_CurrentCharge");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.RacoonDogComponent.Authority_OnDeleteActorTimerCompleted
// (Final, Native, Private)

void URacoonDogComponent::Authority_OnDeleteActorTimerCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RacoonDogComponent", "Authority_OnDeleteActorTimerCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.RacoonDogComponent.Authority_OnIsLookingTowardsTimerFinished
// (Final, Native, Private)

void URacoonDogComponent::Authority_OnIsLookingTowardsTimerFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RacoonDogComponent", "Authority_OnIsLookingTowardsTimerFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.RacoonDogComponent.Authority_OnPlayerInRangeChanged
// (Final, Native, Private)
// Parameters:
// class AActor*                           PlayerActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsInRange                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URacoonDogComponent::Authority_OnPlayerInRangeChanged(class AActor* PlayerActor, const bool IsInRange)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RacoonDogComponent", "Authority_OnPlayerInRangeChanged");

	Params::RacoonDogComponent_Authority_OnPlayerInRangeChanged Parms{};

	Parms.PlayerActor = PlayerActor;
	Parms.IsInRange = IsInRange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.RacoonDogComponent.Authority_OnPlayerIsLookingTowardsChanged
// (Final, Native, Private)
// Parameters:
// bool                                    IsLookingTowards                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       Player                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URacoonDogComponent::Authority_OnPlayerIsLookingTowardsChanged(const bool IsLookingTowards, const class ADBDPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RacoonDogComponent", "Authority_OnPlayerIsLookingTowardsChanged");

	Params::RacoonDogComponent_Authority_OnPlayerIsLookingTowardsChanged Parms{};

	Parms.IsLookingTowards = IsLookingTowards;
	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.RacoonDogComponent.Authority_OnPossessedPawnChanged
// (Final, Native, Private)
// Parameters:
// class APawn*                            OldPawn                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APawn*                            NewPawn                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URacoonDogComponent::Authority_OnPossessedPawnChanged(class APawn* OldPawn, class APawn* NewPawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RacoonDogComponent", "Authority_OnPossessedPawnChanged");

	Params::RacoonDogComponent_Authority_OnPossessedPawnChanged Parms{};

	Parms.OldPawn = OldPawn;
	Parms.NewPawn = NewPawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.RacoonDogComponent.DBD_ResetRacoonDogWasActivated
// (Final, Exec, Native, Private)

void URacoonDogComponent::DBD_ResetRacoonDogWasActivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RacoonDogComponent", "DBD_ResetRacoonDogWasActivated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.RacoonDogComponent.DBD_SetSelectedRacoonDogAnimIndex
// (Final, Exec, Native, Private)
// Parameters:
// uint8                                   Param_Index                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URacoonDogComponent::DBD_SetSelectedRacoonDogAnimIndex(const uint8 Param_Index)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RacoonDogComponent", "DBD_SetSelectedRacoonDogAnimIndex");

	Params::RacoonDogComponent_DBD_SetSelectedRacoonDogAnimIndex Parms{};

	Parms.Param_Index = Param_Index;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.RacoonDogComponent.OnAnimationMontageCompleted
// (Final, Native, Private)

void URacoonDogComponent::OnAnimationMontageCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RacoonDogComponent", "OnAnimationMontageCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.RacoonDogComponent.OnRep_WasActivated
// (Final, Native, Private)

void URacoonDogComponent::OnRep_WasActivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RacoonDogComponent", "OnRep_WasActivated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// DelegateFunction DBDGameplay.RacoonDogComponent.RacoonDogEventDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate)

void URacoonDogComponent::RacoonDogEventDelegate__DelegateSignature()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RacoonDogComponent", "RacoonDogEventDelegate__DelegateSignature");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DBDGameplay.RangedExplosiveEffectHandlerComponent.OnRangedExplosiveDestroyed
// (Final, Native, Private)
// Parameters:
// class AActor*                           DestroyedActor                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URangedExplosiveEffectHandlerComponent::OnRangedExplosiveDestroyed(class AActor* DestroyedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RangedExplosiveEffectHandlerComponent", "OnRangedExplosiveDestroyed");

	Params::RangedExplosiveEffectHandlerComponent_OnRangedExplosiveDestroyed Parms{};

	Parms.DestroyedActor = DestroyedActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.RangeToActorsTrackerComponent.OnLevelReadyToPlay
// (Final, Native, Private)

void URangeToActorsTrackerComponent::OnLevelReadyToPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RangeToActorsTrackerComponent", "OnLevelReadyToPlay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.RespawnableComponent.Authority_OnMinRespawnTimerDone
// (Final, Native, Private)

void URespawnableComponent::Authority_OnMinRespawnTimerDone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RespawnableComponent", "Authority_OnMinRespawnTimerDone");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.RespawnableComponent.Authority_OnTimerDone
// (Final, Native, Private)

void URespawnableComponent::Authority_OnTimerDone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RespawnableComponent", "Authority_OnTimerDone");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.RespawnableComponent.Authority_TryTeleport
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URespawnableComponent::Authority_TryTeleport()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RespawnableComponent", "Authority_TryTeleport");

	Params::RespawnableComponent_Authority_TryTeleport Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction DBDGameplay.RespawnableComponent.OnCosmeticNeeded__DelegateSignature
// (MulticastDelegate, Public, Delegate)

void URespawnableComponent::OnCosmeticNeeded__DelegateSignature()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RespawnableComponent", "OnCosmeticNeeded__DelegateSignature");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DBDGameplay.RespawnableComponent.OnDespawnCosmeticsComplete
// (Native, Public, BlueprintCallable)

void URespawnableComponent::OnDespawnCosmeticsComplete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RespawnableComponent", "OnDespawnCosmeticsComplete");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.RespawnableComponent.OnLevelReadyToPlay
// (Native, Protected)

void URespawnableComponent::OnLevelReadyToPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RespawnableComponent", "OnLevelReadyToPlay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.RespawnableComponent.OnRep_OnLocationChanged
// (Final, Native, Private)

void URespawnableComponent::OnRep_OnLocationChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RespawnableComponent", "OnRep_OnLocationChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// DelegateFunction DBDGameplay.RespawnableComponent.OnTeleportSucceded__DelegateSignature
// (MulticastDelegate, Public, Delegate)

void URespawnableComponent::OnTeleportSucceded__DelegateSignature()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RespawnableComponent", "OnTeleportSucceded__DelegateSignature");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DBDGameplay.SteamPipe.Authority_OnBeginOverlap
// (Final, Native, Private, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ASteamPipe::Authority_OnBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamPipe", "Authority_OnBeginOverlap");

	Params::SteamPipe_Authority_OnBeginOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.SteamPipe.Authority_OnEndOverlap
// (Final, Native, Private)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASteamPipe::Authority_OnEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamPipe", "Authority_OnEndOverlap");

	Params::SteamPipe_Authority_OnEndOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.SteamPipe.Cosmetic_OnSteamPipeStateChanged
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)
// Parameters:
// ESteamPipeState                         NewState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASteamPipe::Cosmetic_OnSteamPipeStateChanged(ESteamPipeState NewState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamPipe", "Cosmetic_OnSteamPipeStateChanged");

	Params::SteamPipe_Cosmetic_OnSteamPipeStateChanged Parms{};

	Parms.NewState = NewState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DBDGameplay.SteamPipe.OnRep_SteamPipeState
// (Final, Native, Private)

void ASteamPipe::OnRep_SteamPipeState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamPipe", "OnRep_SteamPipeState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.SteamPipe.GetCurrentSteamPipeState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ESteamPipeState                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESteamPipeState ASteamPipe::GetCurrentSteamPipeState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamPipe", "GetCurrentSteamPipeState");

	Params::SteamPipe_GetCurrentSteamPipeState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.SteamPipeEffectComponent.Authority_OnHealthStateChanged
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FGameplayTag                     GameplayTag                                            (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameEventData                   GameEventData                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void USteamPipeEffectComponent::Authority_OnHealthStateChanged(const struct FGameplayTag& GameplayTag, const struct FGameEventData& GameEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamPipeEffectComponent", "Authority_OnHealthStateChanged");

	Params::SteamPipeEffectComponent_Authority_OnHealthStateChanged Parms{};

	Parms.GameplayTag = std::move(GameplayTag);
	Parms.GameEventData = std::move(GameEventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.SteamPipeEffectComponent.Authority_OnStoppedCrouching
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FGameplayTag                     GameplayTag                                            (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameEventData                   GameEventData                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void USteamPipeEffectComponent::Authority_OnStoppedCrouching(const struct FGameplayTag& GameplayTag, const struct FGameEventData& GameEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamPipeEffectComponent", "Authority_OnStoppedCrouching");

	Params::SteamPipeEffectComponent_Authority_OnStoppedCrouching Parms{};

	Parms.GameplayTag = std::move(GameplayTag);
	Parms.GameEventData = std::move(GameEventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.SteamPipeManagerComponent.Authority_OnCharacterAdded
// (Final, Native, Private)
// Parameters:
// class ADBDPlayer*                       Character                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamPipeManagerComponent::Authority_OnCharacterAdded(class ADBDPlayer* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamPipeManagerComponent", "Authority_OnCharacterAdded");

	Params::SteamPipeManagerComponent_Authority_OnCharacterAdded Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.SteamPipeManagerComponent.Authority_OnResetInteractionComplete
// (Final, Native, Private, HasOutParams)
// Parameters:
// bool                                    COMPLETED                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   InstigatorsForCompletion                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void USteamPipeManagerComponent::Authority_OnResetInteractionComplete(bool COMPLETED, const TArray<class AActor*>& InstigatorsForCompletion)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamPipeManagerComponent", "Authority_OnResetInteractionComplete");

	Params::SteamPipeManagerComponent_Authority_OnResetInteractionComplete Parms{};

	Parms.COMPLETED = COMPLETED;
	Parms.InstigatorsForCompletion = std::move(InstigatorsForCompletion);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.SteamPipeManagerComponent.Authority_OnSteamPipeStateChanged
// (Final, Native, Private)
// Parameters:
// class ASteamPipe*                       SteamPipe                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESteamPipeState                         NewState                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamPipeManagerComponent::Authority_OnSteamPipeStateChanged(const class ASteamPipe* SteamPipe, const ESteamPipeState NewState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamPipeManagerComponent", "Authority_OnSteamPipeStateChanged");

	Params::SteamPipeManagerComponent_Authority_OnSteamPipeStateChanged Parms{};

	Parms.SteamPipe = SteamPipe;
	Parms.NewState = NewState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.SteamPipeManagerComponent.Authority_OnSwitchCooldownComplete
// (Final, Native, Private)

void USteamPipeManagerComponent::Authority_OnSwitchCooldownComplete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamPipeManagerComponent", "Authority_OnSwitchCooldownComplete");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.SteamPipeManagerComponent.Authority_UpdateCanUseResetSwitch
// (Final, Native, Private)

void USteamPipeManagerComponent::Authority_UpdateCanUseResetSwitch()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamPipeManagerComponent", "Authority_UpdateCanUseResetSwitch");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.SteamPipeManagerComponent.OnLevelReadyToPlay
// (Final, Native, Private)

void USteamPipeManagerComponent::OnLevelReadyToPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamPipeManagerComponent", "OnLevelReadyToPlay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.SteamPipeResetSwitch.Cosmetic_NumberOfDisabledSteamPipesChanged
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)
// Parameters:
// int32                                   NumberOfDisabledSteamPipes                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASteamPipeResetSwitch::Cosmetic_NumberOfDisabledSteamPipesChanged(const int32 NumberOfDisabledSteamPipes)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamPipeResetSwitch", "Cosmetic_NumberOfDisabledSteamPipesChanged");

	Params::SteamPipeResetSwitch_Cosmetic_NumberOfDisabledSteamPipesChanged Parms{};

	Parms.NumberOfDisabledSteamPipes = NumberOfDisabledSteamPipes;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DBDGameplay.SteamPipeResetSwitch.Cosmetic_OnCooldownDone
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)

void ASteamPipeResetSwitch::Cosmetic_OnCooldownDone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamPipeResetSwitch", "Cosmetic_OnCooldownDone");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DBDGameplay.SteamPipeResetSwitch.Cosmetic_OnSwitchTriggered
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)
// Parameters:
// float                                   CooldownTime                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASteamPipeResetSwitch::Cosmetic_OnSwitchTriggered(float CooldownTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamPipeResetSwitch", "Cosmetic_OnSwitchTriggered");

	Params::SteamPipeResetSwitch_Cosmetic_OnSwitchTriggered Parms{};

	Parms.CooldownTime = CooldownTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DBDGameplay.SteamPipeResetSwitch.Cosmetic_OnTotalSteamPipesInLevelChanged
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)
// Parameters:
// int32                                   TotalSteamPipesInLevel                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASteamPipeResetSwitch::Cosmetic_OnTotalSteamPipesInLevelChanged(const int32 TotalSteamPipesInLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamPipeResetSwitch", "Cosmetic_OnTotalSteamPipesInLevelChanged");

	Params::SteamPipeResetSwitch_Cosmetic_OnTotalSteamPipesInLevelChanged Parms{};

	Parms.TotalSteamPipesInLevel = TotalSteamPipesInLevel;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DBDGameplay.SteamPipeResetSwitch.OnRep_IsOnCooldown
// (Final, Native, Private)

void ASteamPipeResetSwitch::OnRep_IsOnCooldown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamPipeResetSwitch", "OnRep_IsOnCooldown");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.SteamPipeResetSwitch.OnRep_NumberOfDisabledSteamPipes
// (Final, Native, Private)

void ASteamPipeResetSwitch::OnRep_NumberOfDisabledSteamPipes()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamPipeResetSwitch", "OnRep_NumberOfDisabledSteamPipes");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.SteamPipeResetSwitch.OnRep_SharedChargeableComponent
// (Final, Native, Private)

void ASteamPipeResetSwitch::OnRep_SharedChargeableComponent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamPipeResetSwitch", "OnRep_SharedChargeableComponent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.SteamPipeResetSwitch.GetTotalSteamPipesInLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ASteamPipeResetSwitch::GetTotalSteamPipesInLevel() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamPipeResetSwitch", "GetTotalSteamPipesInLevel");

	Params::SteamPipeResetSwitch_GetTotalSteamPipesInLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.StruggleComponent.Authority_TryActivateSkillCheck
// (Final, Native, Private)

void UStruggleComponent::Authority_TryActivateSkillCheck()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StruggleComponent", "Authority_TryActivateSkillCheck");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.StruggleComponent.OnSkillCheckEnd
// (Final, Native, Private)
// Parameters:
// bool                                    HadInput                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Success                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Bonus                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESkillCheckCustomType                   Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStruggleComponent::OnSkillCheckEnd(bool HadInput, bool Success, bool Bonus, ESkillCheckCustomType Type, class ADBDPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StruggleComponent", "OnSkillCheckEnd");

	Params::StruggleComponent_OnSkillCheckEnd Parms{};

	Parms.HadInput = HadInput;
	Parms.Success = Success;
	Parms.Bonus = Bonus;
	Parms.Type = Type;
	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.TerrorRadiusEmitterFunctionLibrary.GetActiveFakeTerrorRadiusEmittersCount
// (Final, Native, Static, Private, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UTerrorRadiusEmitterFunctionLibrary::GetActiveFakeTerrorRadiusEmittersCount(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TerrorRadiusEmitterFunctionLibrary", "GetActiveFakeTerrorRadiusEmittersCount");

	Params::TerrorRadiusEmitterFunctionLibrary_GetActiveFakeTerrorRadiusEmittersCount Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction DBDGameplay.TerrorRadiusReceiverComponent.OnIsInTerrorRadiusChanged__DelegateSignature
// (MulticastDelegate, Public, Delegate)

void UTerrorRadiusReceiverComponent::OnIsInTerrorRadiusChanged__DelegateSignature()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TerrorRadiusReceiverComponent", "OnIsInTerrorRadiusChanged__DelegateSignature");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DBDGameplay.TerrorRadiusReceiverComponent.IsInTerrorRadius
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTerrorRadiusReceiverComponent::IsInTerrorRadius() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TerrorRadiusReceiverComponent", "IsInTerrorRadius");

	Params::TerrorRadiusReceiverComponent_IsInTerrorRadius Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.TerrorRadiusReceiverComponent.IsInTerrorRadiusRange
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTerrorRadiusReceiverComponent::IsInTerrorRadiusRange() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TerrorRadiusReceiverComponent", "IsInTerrorRadiusRange");

	Params::TerrorRadiusReceiverComponent_IsInTerrorRadiusRange Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.WiggleComponent.Authority_AddWiggleCharge
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ChargeAmount                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWiggleComponent::Authority_AddWiggleCharge(float ChargeAmount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WiggleComponent", "Authority_AddWiggleCharge");

	Params::WiggleComponent_Authority_AddWiggleCharge Parms{};

	Parms.ChargeAmount = ChargeAmount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.WiggleComponent.Authority_TutorialEndWiggle
// (Final, Native, Public, BlueprintCallable)

void UWiggleComponent::Authority_TutorialEndWiggle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WiggleComponent", "Authority_TutorialEndWiggle");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.WiggleComponent.OnHideWiggleSkillCheck
// (Final, Native, Private)
// Parameters:
// ESkillCheckCustomType                   Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWiggleComponent::OnHideWiggleSkillCheck(ESkillCheckCustomType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WiggleComponent", "OnHideWiggleSkillCheck");

	Params::WiggleComponent_OnHideWiggleSkillCheck Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.WiggleComponent.OnKeyBindingsChanged
// (Final, Native, Private)

void UWiggleComponent::OnKeyBindingsChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WiggleComponent", "OnKeyBindingsChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.WiggleComponent.OnLevelReadyToPlay
// (Final, Native, Private)

void UWiggleComponent::OnLevelReadyToPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WiggleComponent", "OnLevelReadyToPlay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.WiggleComponent.OnPickedUpSkillCheckEnd
// (Final, Native, Private)
// Parameters:
// bool                                    HadInput                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Success                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Bonus                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESkillCheckCustomType                   Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWiggleComponent::OnPickedUpSkillCheckEnd(bool HadInput, bool Success, bool Bonus, ESkillCheckCustomType Type, class ADBDPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WiggleComponent", "OnPickedUpSkillCheckEnd");

	Params::WiggleComponent_OnPickedUpSkillCheckEnd Parms{};

	Parms.HadInput = HadInput;
	Parms.Success = Success;
	Parms.Bonus = Bonus;
	Parms.Type = Type;
	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.WiggleComponent.OnPlayerPickedUpEnd
// (Final, Native, Private)
// Parameters:
// class ADBDPlayer*                       Picker                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWiggleComponent::OnPlayerPickedUpEnd(class ADBDPlayer* Picker)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WiggleComponent", "OnPlayerPickedUpEnd");

	Params::WiggleComponent_OnPlayerPickedUpEnd Parms{};

	Parms.Picker = Picker;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.WiggleComponent.OnPlayerPickedUpStart
// (Final, Native, Private)
// Parameters:
// class ADBDPlayer*                       Picker                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWiggleComponent::OnPlayerPickedUpStart(class ADBDPlayer* Picker)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WiggleComponent", "OnPlayerPickedUpStart");

	Params::WiggleComponent_OnPlayerPickedUpStart Parms{};

	Parms.Picker = Picker;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.WiggleComponent.OnSurvivorHookedOrUnhookedOrDropped
// (Final, Native, Private)

void UWiggleComponent::OnSurvivorHookedOrUnhookedOrDropped()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WiggleComponent", "OnSurvivorHookedOrUnhookedOrDropped");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.WiggleComponent.OnWiggleEnd
// (Final, Native, Private)

void UWiggleComponent::OnWiggleEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WiggleComponent", "OnWiggleEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.WiggleComponent.OnWiggleInput
// (Final, Native, Private)

void UWiggleComponent::OnWiggleInput()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WiggleComponent", "OnWiggleInput");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.WiggleComponent.OnWiggleSkillCheckEnd
// (Final, Native, Private)
// Parameters:
// bool                                    HadInput                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Success                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Bonus                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESkillCheckCustomType                   Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWiggleComponent::OnWiggleSkillCheckEnd(bool HadInput, bool Success, bool Bonus, ESkillCheckCustomType Type, class ADBDPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WiggleComponent", "OnWiggleSkillCheckEnd");

	Params::WiggleComponent_OnWiggleSkillCheckEnd Parms{};

	Parms.HadInput = HadInput;
	Parms.Success = Success;
	Parms.Bonus = Bonus;
	Parms.Type = Type;
	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.WiggleComponent.Server_OnWiggleEnd
// (Final, Net, NetReliable, Native, Event, Private, NetServer)

void UWiggleComponent::Server_OnWiggleEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WiggleComponent", "Server_OnWiggleEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.WiggleComponent.DBD_SetWiggleProgress
// (Final, Exec, Native, Public, Const)
// Parameters:
// float                                   ProgressPercent                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWiggleComponent::DBD_SetWiggleProgress(const float ProgressPercent) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WiggleComponent", "DBD_SetWiggleProgress");

	Params::WiggleComponent_DBD_SetWiggleProgress Parms{};

	Parms.ProgressPercent = ProgressPercent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.WiggleComponent.GetWiggleChargeable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UChargeableComponent*             ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UChargeableComponent* UWiggleComponent::GetWiggleChargeable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WiggleComponent", "GetWiggleChargeable");

	Params::WiggleComponent_GetWiggleChargeable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.WiggleFreeComponent.Authority_OnChargeableCompleteEvent
// (Final, Native, Private, HasOutParams)
// Parameters:
// bool                                    COMPLETED                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   InstigatorsForCompletion                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UWiggleFreeComponent::Authority_OnChargeableCompleteEvent(bool COMPLETED, const TArray<class AActor*>& InstigatorsForCompletion)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WiggleFreeComponent", "Authority_OnChargeableCompleteEvent");

	Params::WiggleFreeComponent_Authority_OnChargeableCompleteEvent Parms{};

	Parms.COMPLETED = COMPLETED;
	Parms.InstigatorsForCompletion = std::move(InstigatorsForCompletion);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.WiggleFreeComponent.Authority_OnChargeApplied
// (Final, Native, Private)
// Parameters:
// float                                   IndividualChargeAmount                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TotalChargeAmount                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ChargeInstigator                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    WasCoop                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWiggleFreeComponent::Authority_OnChargeApplied(float IndividualChargeAmount, float TotalChargeAmount, class AActor* ChargeInstigator, bool WasCoop, float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WiggleFreeComponent", "Authority_OnChargeApplied");

	Params::WiggleFreeComponent_Authority_OnChargeApplied Parms{};

	Parms.IndividualChargeAmount = IndividualChargeAmount;
	Parms.TotalChargeAmount = TotalChargeAmount;
	Parms.ChargeInstigator = ChargeInstigator;
	Parms.WasCoop = WasCoop;
	Parms.DeltaTime = DeltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.WiggleFreeComponent.Authority_OnPlayerPickedUpEnd
// (Final, Native, Private)
// Parameters:
// class ADBDPlayer*                       Picker                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWiggleFreeComponent::Authority_OnPlayerPickedUpEnd(class ADBDPlayer* Picker)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WiggleFreeComponent", "Authority_OnPlayerPickedUpEnd");

	Params::WiggleFreeComponent_Authority_OnPlayerPickedUpEnd Parms{};

	Parms.Picker = Picker;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.WiggleFreeComponent.Authority_OnWiggleEnd
// (Final, Native, Private)

void UWiggleFreeComponent::Authority_OnWiggleEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WiggleFreeComponent", "Authority_OnWiggleEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.WiggleFreeComponent.Authority_RegisterListeners
// (Final, Native, Private)

void UWiggleFreeComponent::Authority_RegisterListeners()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WiggleFreeComponent", "Authority_RegisterListeners");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.WiggleMotionComponent.OnHideWiggleSkillCheck
// (Final, Native, Private)
// Parameters:
// ESkillCheckCustomType                   Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWiggleMotionComponent::OnHideWiggleSkillCheck(ESkillCheckCustomType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WiggleMotionComponent", "OnHideWiggleSkillCheck");

	Params::WiggleMotionComponent_OnHideWiggleSkillCheck Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.WiggleMotionComponent.OnSurvivorPickedUp
// (Final, Native, Private)
// Parameters:
// class ADBDPlayer*                       Target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWiggleMotionComponent::OnSurvivorPickedUp(class ADBDPlayer* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WiggleMotionComponent", "OnSurvivorPickedUp");

	Params::WiggleMotionComponent_OnSurvivorPickedUp Parms{};

	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.WiggleMotionComponent.OnSurvivorRemoved
// (Final, Native, Private)
// Parameters:
// class ADBDPlayer*                       Target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWiggleMotionComponent::OnSurvivorRemoved(class ADBDPlayer* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WiggleMotionComponent", "OnSurvivorRemoved");

	Params::WiggleMotionComponent_OnSurvivorRemoved Parms{};

	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.WiggleMotionComponent.OnWiggleSkillCheckEnd
// (Final, Native, Private)
// Parameters:
// bool                                    HadInput                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Success                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Bonus                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESkillCheckCustomType                   Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWiggleMotionComponent::OnWiggleSkillCheckEnd(bool HadInput, bool Success, bool Bonus, ESkillCheckCustomType Type, class ADBDPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WiggleMotionComponent", "OnWiggleSkillCheckEnd");

	Params::WiggleMotionComponent_OnWiggleSkillCheckEnd Parms{};

	Parms.HadInput = HadInput;
	Parms.Success = Success;
	Parms.Bonus = Bonus;
	Parms.Type = Type;
	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.WiggleMotionComponent.Server_SetIsBeingWiggled
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// bool                                    IsBeingWiggled                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWiggleMotionComponent::Server_SetIsBeingWiggled(const bool IsBeingWiggled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WiggleMotionComponent", "Server_SetIsBeingWiggled");

	Params::WiggleMotionComponent_Server_SetIsBeingWiggled Parms{};

	Parms.IsBeingWiggled = IsBeingWiggled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.WiggleMotionComponent.SetIsBeingWiggled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    IsBeingWiggled                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWiggleMotionComponent::SetIsBeingWiggled(const bool IsBeingWiggled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WiggleMotionComponent", "SetIsBeingWiggled");

	Params::WiggleMotionComponent_SetIsBeingWiggled Parms{};

	Parms.IsBeingWiggled = IsBeingWiggled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}

}

