#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: TheK32

#include "Basic.hpp"

#include "DBDInteraction_classes.hpp"
#include "DataTableUtilities_structs.hpp"
#include "DeadByDaylight_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "DBDCompetence_classes.hpp"
#include "TheK32_structs.hpp"
#include "Engine_classes.hpp"
#include "DBDAnimation_classes.hpp"
#include "DBDGameplay_classes.hpp"
#include "StatSystem_structs.hpp"
#include "DBDUIViewInterfaces_structs.hpp"
#include "GameplayUtilities_classes.hpp"
#include "GameplayTags_structs.hpp"
#include "SystemUtilities_structs.hpp"
#include "DBDCosmetic_classes.hpp"


namespace SDK
{

// Class TheK32.K32BaseProjectile
// 0x0130 (0x03D0 - 0x02A0)
class alignas(0x10) AK32BaseProjectile final : public AActor
{
public:
	uint8                                         Pad_2A0[0x8];                                      // 0x02A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnAcquiredChanged;                                 // 0x02A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FDBDTunableRowHandle                   _speedInMeterPerSecond;                            // 0x02B8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _hitDistance;                                      // 0x02E0(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_308[0xB8];                                     // 0x0308(0x00B8)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _isAcquiredFromPool;                               // 0x03C0(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3C1[0xF];                                      // 0x03C1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_OnProjectileHidden();
	void Cosmetic_OnProjectileVisible();
	void OnRep_IsAcquiredFromPool(bool OldIsAcquiredFromPool);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K32BaseProjectile">();
	}
	static class AK32BaseProjectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK32BaseProjectile>();
	}
};
static_assert(alignof(AK32BaseProjectile) == 0x000010, "Wrong alignment on AK32BaseProjectile");
static_assert(sizeof(AK32BaseProjectile) == 0x0003D0, "Wrong size on AK32BaseProjectile");
static_assert(offsetof(AK32BaseProjectile, OnAcquiredChanged) == 0x0002A8, "Member 'AK32BaseProjectile::OnAcquiredChanged' has a wrong offset!");
static_assert(offsetof(AK32BaseProjectile, _speedInMeterPerSecond) == 0x0002B8, "Member 'AK32BaseProjectile::_speedInMeterPerSecond' has a wrong offset!");
static_assert(offsetof(AK32BaseProjectile, _hitDistance) == 0x0002E0, "Member 'AK32BaseProjectile::_hitDistance' has a wrong offset!");
static_assert(offsetof(AK32BaseProjectile, _isAcquiredFromPool) == 0x0003C0, "Member 'AK32BaseProjectile::_isAcquiredFromPool' has a wrong offset!");

// Class TheK32.Addon_K32Power_14
// 0x0088 (0x0370 - 0x02E8)
class UAddon_K32Power_14 final : public UItemAddon
{
public:
	struct FDBDTunableRowHandle                   _addon14RecentAssimilationWithinTime;              // 0x02E8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UStatusEffect>              _addon14ModifyTerrorRadiusStatusEffect;            // 0x0310(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _addon14TerrorRadiusAdditive;                      // 0x0318(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _addon14TerrorRadiusAdditiveDuration;              // 0x0340(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UStatusEffect*                          _lastModifyTerrorRadiusStatusEffect;               // 0x0368(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Addon_K32Power_14">();
	}
	static class UAddon_K32Power_14* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAddon_K32Power_14>();
	}
};
static_assert(alignof(UAddon_K32Power_14) == 0x000008, "Wrong alignment on UAddon_K32Power_14");
static_assert(sizeof(UAddon_K32Power_14) == 0x000370, "Wrong size on UAddon_K32Power_14");
static_assert(offsetof(UAddon_K32Power_14, _addon14RecentAssimilationWithinTime) == 0x0002E8, "Member 'UAddon_K32Power_14::_addon14RecentAssimilationWithinTime' has a wrong offset!");
static_assert(offsetof(UAddon_K32Power_14, _addon14ModifyTerrorRadiusStatusEffect) == 0x000310, "Member 'UAddon_K32Power_14::_addon14ModifyTerrorRadiusStatusEffect' has a wrong offset!");
static_assert(offsetof(UAddon_K32Power_14, _addon14TerrorRadiusAdditive) == 0x000318, "Member 'UAddon_K32Power_14::_addon14TerrorRadiusAdditive' has a wrong offset!");
static_assert(offsetof(UAddon_K32Power_14, _addon14TerrorRadiusAdditiveDuration) == 0x000340, "Member 'UAddon_K32Power_14::_addon14TerrorRadiusAdditiveDuration' has a wrong offset!");
static_assert(offsetof(UAddon_K32Power_14, _lastModifyTerrorRadiusStatusEffect) == 0x000368, "Member 'UAddon_K32Power_14::_lastModifyTerrorRadiusStatusEffect' has a wrong offset!");

// Class TheK32.Addon_K32Power_19
// 0x0030 (0x0318 - 0x02E8)
class UAddon_K32Power_19 final : public UItemAddon
{
public:
	TSubclassOf<class UStatusEffect>              _addon19HinderedStatusEffect;                      // 0x02E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _addon19HinderedDuration;                          // 0x02F0(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Addon_K32Power_19">();
	}
	static class UAddon_K32Power_19* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAddon_K32Power_19>();
	}
};
static_assert(alignof(UAddon_K32Power_19) == 0x000008, "Wrong alignment on UAddon_K32Power_19");
static_assert(sizeof(UAddon_K32Power_19) == 0x000318, "Wrong size on UAddon_K32Power_19");
static_assert(offsetof(UAddon_K32Power_19, _addon19HinderedStatusEffect) == 0x0002E8, "Member 'UAddon_K32Power_19::_addon19HinderedStatusEffect' has a wrong offset!");
static_assert(offsetof(UAddon_K32Power_19, _addon19HinderedDuration) == 0x0002F0, "Member 'UAddon_K32Power_19::_addon19HinderedDuration' has a wrong offset!");

// Class TheK32.InK32PodZoneLingeringEffect
// 0x00A0 (0x0488 - 0x03E8)
class UInK32PodZoneLingeringEffect final : public UBaseLingeringStatusEffect
{
public:
	struct FDBDTunableRowHandle                   _range;                                            // 0x03E8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TArray<class AK32KillerPod*>                  _podsInRange;                                      // 0x0410(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_420[0x68];                                     // 0x0420(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnKillerPodAcquiredChanged(const bool IsAcquired);
	void Authority_OnKillerPodDisabledChanged(const bool IsDisabled);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InK32PodZoneLingeringEffect">();
	}
	static class UInK32PodZoneLingeringEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInK32PodZoneLingeringEffect>();
	}
};
static_assert(alignof(UInK32PodZoneLingeringEffect) == 0x000008, "Wrong alignment on UInK32PodZoneLingeringEffect");
static_assert(sizeof(UInK32PodZoneLingeringEffect) == 0x000488, "Wrong size on UInK32PodZoneLingeringEffect");
static_assert(offsetof(UInK32PodZoneLingeringEffect, _range) == 0x0003E8, "Member 'UInK32PodZoneLingeringEffect::_range' has a wrong offset!");
static_assert(offsetof(UInK32PodZoneLingeringEffect, _podsInRange) == 0x000410, "Member 'UInK32PodZoneLingeringEffect::_podsInRange' has a wrong offset!");

// Class TheK32.K32AnalyticsComponent
// 0x0038 (0x00E0 - 0x00A8)
class UK32AnalyticsComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x10];                                      // 0x00A8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class ACamperPlayer*                          _survivorAssimilatedFirstTime;                     // 0x00B8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FAssimilationFromDifferentPodsStageData _assimilationFromDifferentPodsStage;               // 0x00C0(0x0020)(Transient, NoDestructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K32AnalyticsComponent">();
	}
	static class UK32AnalyticsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK32AnalyticsComponent>();
	}
};
static_assert(alignof(UK32AnalyticsComponent) == 0x000008, "Wrong alignment on UK32AnalyticsComponent");
static_assert(sizeof(UK32AnalyticsComponent) == 0x0000E0, "Wrong size on UK32AnalyticsComponent");
static_assert(offsetof(UK32AnalyticsComponent, _survivorAssimilatedFirstTime) == 0x0000B8, "Member 'UK32AnalyticsComponent::_survivorAssimilatedFirstTime' has a wrong offset!");
static_assert(offsetof(UK32AnalyticsComponent, _assimilationFromDifferentPodsStage) == 0x0000C0, "Member 'UK32AnalyticsComponent::_assimilationFromDifferentPodsStage' has a wrong offset!");

// Class TheK32.K32AnimInstance
// 0x0060 (0x0780 - 0x0720)
class UK32AnimInstance final : public UKillerAnimInstance
{
public:
	bool                                          _isAimingPodPlacement;                             // 0x0720(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isShootingPod;                                    // 0x0721(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isInOverclockMode;                                // 0x0722(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isTeleporting;                                    // 0x0723(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isControllingPod;                                 // 0x0724(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isTeleportingFromKillerPovWithInAntiCamp;         // 0x0725(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_726[0x2];                                      // 0x0726(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _chargeKillerProjectileSpawnPercent;               // 0x0728(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_72C[0x4];                                      // 0x072C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UStatusEffect>              _overclockStatusEffectClass;                       // 0x0730(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_738[0x48];                                     // 0x0738(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnGameEventReceived(const struct FGameplayTag& GameplayTag, const struct FGameEventData& GameEventData);
	void ResetIsShootingPod();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K32AnimInstance">();
	}
	static class UK32AnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK32AnimInstance>();
	}
};
static_assert(alignof(UK32AnimInstance) == 0x000010, "Wrong alignment on UK32AnimInstance");
static_assert(sizeof(UK32AnimInstance) == 0x000780, "Wrong size on UK32AnimInstance");
static_assert(offsetof(UK32AnimInstance, _isAimingPodPlacement) == 0x000720, "Member 'UK32AnimInstance::_isAimingPodPlacement' has a wrong offset!");
static_assert(offsetof(UK32AnimInstance, _isShootingPod) == 0x000721, "Member 'UK32AnimInstance::_isShootingPod' has a wrong offset!");
static_assert(offsetof(UK32AnimInstance, _isInOverclockMode) == 0x000722, "Member 'UK32AnimInstance::_isInOverclockMode' has a wrong offset!");
static_assert(offsetof(UK32AnimInstance, _isTeleporting) == 0x000723, "Member 'UK32AnimInstance::_isTeleporting' has a wrong offset!");
static_assert(offsetof(UK32AnimInstance, _isControllingPod) == 0x000724, "Member 'UK32AnimInstance::_isControllingPod' has a wrong offset!");
static_assert(offsetof(UK32AnimInstance, _isTeleportingFromKillerPovWithInAntiCamp) == 0x000725, "Member 'UK32AnimInstance::_isTeleportingFromKillerPovWithInAntiCamp' has a wrong offset!");
static_assert(offsetof(UK32AnimInstance, _chargeKillerProjectileSpawnPercent) == 0x000728, "Member 'UK32AnimInstance::_chargeKillerProjectileSpawnPercent' has a wrong offset!");
static_assert(offsetof(UK32AnimInstance, _overclockStatusEffectClass) == 0x000730, "Member 'UK32AnimInstance::_overclockStatusEffectClass' has a wrong offset!");

// Class TheK32.K32AntiCampZoneIdentifierComponent
// 0x0000 (0x0108 - 0x0108)
class UK32AntiCampZoneIdentifierComponent final : public UObjectPlacementValidationWithRestrictionStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K32AntiCampZoneIdentifierComponent">();
	}
	static class UK32AntiCampZoneIdentifierComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK32AntiCampZoneIdentifierComponent>();
	}
};
static_assert(alignof(UK32AntiCampZoneIdentifierComponent) == 0x000008, "Wrong alignment on UK32AntiCampZoneIdentifierComponent");
static_assert(sizeof(UK32AntiCampZoneIdentifierComponent) == 0x000108, "Wrong size on UK32AntiCampZoneIdentifierComponent");

// Class TheK32.K32AssimilationAnimInstance
// 0x0010 (0x03B0 - 0x03A0)
class UK32AssimilationAnimInstance final : public USurvivorDynamicAccessoryAnimInstance
{
public:
	bool                                          _isAssimilated;                                    // 0x0398(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isDestroyedByEmp;                                 // 0x0399(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isDestroyedByHook;                                // 0x039A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isDestroyedByTeleport;                            // 0x039B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isBeingLookedAtByKillerPod;                       // 0x039C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_39D[0x13];                                     // 0x039D(0x0013)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ResetIsDestroyedByEmp();
	void ResetIsDestroyedByHook();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K32AssimilationAnimInstance">();
	}
	static class UK32AssimilationAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK32AssimilationAnimInstance>();
	}
};
static_assert(alignof(UK32AssimilationAnimInstance) == 0x000010, "Wrong alignment on UK32AssimilationAnimInstance");
static_assert(sizeof(UK32AssimilationAnimInstance) == 0x0003B0, "Wrong size on UK32AssimilationAnimInstance");
static_assert(offsetof(UK32AssimilationAnimInstance, _isAssimilated) == 0x000398, "Member 'UK32AssimilationAnimInstance::_isAssimilated' has a wrong offset!");
static_assert(offsetof(UK32AssimilationAnimInstance, _isDestroyedByEmp) == 0x000399, "Member 'UK32AssimilationAnimInstance::_isDestroyedByEmp' has a wrong offset!");
static_assert(offsetof(UK32AssimilationAnimInstance, _isDestroyedByHook) == 0x00039A, "Member 'UK32AssimilationAnimInstance::_isDestroyedByHook' has a wrong offset!");
static_assert(offsetof(UK32AssimilationAnimInstance, _isDestroyedByTeleport) == 0x00039B, "Member 'UK32AssimilationAnimInstance::_isDestroyedByTeleport' has a wrong offset!");
static_assert(offsetof(UK32AssimilationAnimInstance, _isBeingLookedAtByKillerPod) == 0x00039C, "Member 'UK32AssimilationAnimInstance::_isBeingLookedAtByKillerPod' has a wrong offset!");

// Class TheK32.K32CollectItemInItemBoxInteraction
// 0x0050 (0x0800 - 0x07B0)
class UK32CollectItemInItemBoxInteraction final : public UCollectItemInteraction
{
public:
	struct FDBDTunableRowHandle                   _autoCollectOnItemBoxSpeedUpInteractionFinished;   // 0x07A8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class AK32ItemBox*                            _owningItemBox;                                    // 0x07D0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7D8[0x28];                                     // 0x07D8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K32CollectItemInItemBoxInteraction">();
	}
	static class UK32CollectItemInItemBoxInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK32CollectItemInItemBoxInteraction>();
	}
};
static_assert(alignof(UK32CollectItemInItemBoxInteraction) == 0x000010, "Wrong alignment on UK32CollectItemInItemBoxInteraction");
static_assert(sizeof(UK32CollectItemInItemBoxInteraction) == 0x000800, "Wrong size on UK32CollectItemInItemBoxInteraction");
static_assert(offsetof(UK32CollectItemInItemBoxInteraction, _autoCollectOnItemBoxSpeedUpInteractionFinished) == 0x0007A8, "Member 'UK32CollectItemInItemBoxInteraction::_autoCollectOnItemBoxSpeedUpInteractionFinished' has a wrong offset!");
static_assert(offsetof(UK32CollectItemInItemBoxInteraction, _owningItemBox) == 0x0007D0, "Member 'UK32CollectItemInItemBoxInteraction::_owningItemBox' has a wrong offset!");

// Class TheK32.K32Emp
// 0x01F0 (0x0788 - 0x0598)
class AK32Emp final : public ABaseCamperCollectable
{
public:
	uint8                                         Pad_598[0x8];                                      // 0x0598(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnAcquiredChanged;                                 // 0x05A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FVector                                _customStrafingOffset;                             // 0x05B0(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _strafingOffsetMultiplier;                         // 0x05C8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UK32EmpInteraction*                     _empInteraction;                                   // 0x05F0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoClear, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UChargeableComponent*                   _empInteractionChargeable;                         // 0x05F8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoClear, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _empInteractionSecondsToCharge;                    // 0x0600(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _empRange;                                         // 0x0628(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _empAmmoCount;                                     // 0x0650(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _revealToSurvivorStatusEffectClass;                // 0x0678(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class ACamperPlayer*>                  _authority_assimilatedSurvivorsInRange;            // 0x0680(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class AK32KillerPod*>                  _authority_podsInRange;                            // 0x0690(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	int32                                         _numTargetsInRange;                                // 0x06A0(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isVisible;                                        // 0x06A4(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isAcquiredFromPool;                               // 0x06A5(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6A6[0x2];                                      // 0x06A6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class ADBDPlayer*, class UStatusEffect*> _revealToSurvivorStatusEffects;                    // 0x06A8(0x0050)(ExportObject, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class ADBDPlayer*                             _previousCollector;                                // 0x06F8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_700[0x88];                                     // 0x0700(0x0088)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_OnDropped();
	void Cosmetic_OnEmpInteractionCancelled();
	void Cosmetic_OnEmpInteractionFinished(int32 NumberOfAffectedTargets, class ADBDPlayer* InteractingPlayer);
	void Cosmetic_OnEmpInteractionStarted();
	void Cosmetic_OnNumTargetsInRangeChanged(int32 NumberOfAffectedTargets);
	void Cosmetic_OnPickedUp();
	void Cosmetic_OnVisibilityChanged(bool PreviousIsVisible, bool IsVisible);
	void Multicast_UseEmp(const int32 NumAffectedTargets, class ADBDPlayer* InteractingPlayer);
	void OnEmpInteractionEntered(class ADBDPlayer* InteractingPlayer);
	void OnEmpInteractionFinished(class ADBDPlayer* InteractingPlayer, bool HasInteractionStarted);
	void OnRep_IsAcquiredFromPool();
	void OnRep_IsVisible(bool PreviousIsVisible);
	void OnRep_NumTargetsInRange();
	void SetComponentContextProviders();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K32Emp">();
	}
	static class AK32Emp* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK32Emp>();
	}
};
static_assert(alignof(AK32Emp) == 0x000008, "Wrong alignment on AK32Emp");
static_assert(sizeof(AK32Emp) == 0x000788, "Wrong size on AK32Emp");
static_assert(offsetof(AK32Emp, OnAcquiredChanged) == 0x0005A0, "Member 'AK32Emp::OnAcquiredChanged' has a wrong offset!");
static_assert(offsetof(AK32Emp, _customStrafingOffset) == 0x0005B0, "Member 'AK32Emp::_customStrafingOffset' has a wrong offset!");
static_assert(offsetof(AK32Emp, _strafingOffsetMultiplier) == 0x0005C8, "Member 'AK32Emp::_strafingOffsetMultiplier' has a wrong offset!");
static_assert(offsetof(AK32Emp, _empInteraction) == 0x0005F0, "Member 'AK32Emp::_empInteraction' has a wrong offset!");
static_assert(offsetof(AK32Emp, _empInteractionChargeable) == 0x0005F8, "Member 'AK32Emp::_empInteractionChargeable' has a wrong offset!");
static_assert(offsetof(AK32Emp, _empInteractionSecondsToCharge) == 0x000600, "Member 'AK32Emp::_empInteractionSecondsToCharge' has a wrong offset!");
static_assert(offsetof(AK32Emp, _empRange) == 0x000628, "Member 'AK32Emp::_empRange' has a wrong offset!");
static_assert(offsetof(AK32Emp, _empAmmoCount) == 0x000650, "Member 'AK32Emp::_empAmmoCount' has a wrong offset!");
static_assert(offsetof(AK32Emp, _revealToSurvivorStatusEffectClass) == 0x000678, "Member 'AK32Emp::_revealToSurvivorStatusEffectClass' has a wrong offset!");
static_assert(offsetof(AK32Emp, _authority_assimilatedSurvivorsInRange) == 0x000680, "Member 'AK32Emp::_authority_assimilatedSurvivorsInRange' has a wrong offset!");
static_assert(offsetof(AK32Emp, _authority_podsInRange) == 0x000690, "Member 'AK32Emp::_authority_podsInRange' has a wrong offset!");
static_assert(offsetof(AK32Emp, _numTargetsInRange) == 0x0006A0, "Member 'AK32Emp::_numTargetsInRange' has a wrong offset!");
static_assert(offsetof(AK32Emp, _isVisible) == 0x0006A4, "Member 'AK32Emp::_isVisible' has a wrong offset!");
static_assert(offsetof(AK32Emp, _isAcquiredFromPool) == 0x0006A5, "Member 'AK32Emp::_isAcquiredFromPool' has a wrong offset!");
static_assert(offsetof(AK32Emp, _revealToSurvivorStatusEffects) == 0x0006A8, "Member 'AK32Emp::_revealToSurvivorStatusEffects' has a wrong offset!");
static_assert(offsetof(AK32Emp, _previousCollector) == 0x0006F8, "Member 'AK32Emp::_previousCollector' has a wrong offset!");

// Class TheK32.K32EmpInteraction
// 0x0010 (0x08D0 - 0x08C0)
class UK32EmpInteraction final : public UChargeableInteractionDefinition
{
public:
	uint8                                         Pad_8C0[0x10];                                     // 0x08C0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K32EmpInteraction">();
	}
	static class UK32EmpInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK32EmpInteraction>();
	}
};
static_assert(alignof(UK32EmpInteraction) == 0x000010, "Wrong alignment on UK32EmpInteraction");
static_assert(sizeof(UK32EmpInteraction) == 0x0008D0, "Wrong size on UK32EmpInteraction");

// Class TheK32.K32EmpScoreComponent
// 0x01A8 (0x0250 - 0x00A8)
class UK32EmpScoreComponent final : public UActorComponent
{
public:
	struct FDBDTunableRowHandle                   _minPodsRemovedForManyPodsRemovedScoreEvent;       // 0x00A8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _minUnhookedSurvivorAssimilationsRemovedForManyCleansedScoreEvent; // 0x00D0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _minHookedSurvivorAssimilationsRemovedForManyCleansedScoreEvent; // 0x00F8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _basePodRemovalScoreValue;                         // 0x0120(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _podRemovedScoreEventDepreciationCurve;            // 0x0148(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _unhookedSurvivorsCleansedScoreEventDepreciationCurve; // 0x0150(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _hookedSurvivorsCleansedScoreEventDepreciationCurve; // 0x0158(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_160[0xF0];                                     // 0x0160(0x00F0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K32EmpScoreComponent">();
	}
	static class UK32EmpScoreComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK32EmpScoreComponent>();
	}
};
static_assert(alignof(UK32EmpScoreComponent) == 0x000008, "Wrong alignment on UK32EmpScoreComponent");
static_assert(sizeof(UK32EmpScoreComponent) == 0x000250, "Wrong size on UK32EmpScoreComponent");
static_assert(offsetof(UK32EmpScoreComponent, _minPodsRemovedForManyPodsRemovedScoreEvent) == 0x0000A8, "Member 'UK32EmpScoreComponent::_minPodsRemovedForManyPodsRemovedScoreEvent' has a wrong offset!");
static_assert(offsetof(UK32EmpScoreComponent, _minUnhookedSurvivorAssimilationsRemovedForManyCleansedScoreEvent) == 0x0000D0, "Member 'UK32EmpScoreComponent::_minUnhookedSurvivorAssimilationsRemovedForManyCleansedScoreEvent' has a wrong offset!");
static_assert(offsetof(UK32EmpScoreComponent, _minHookedSurvivorAssimilationsRemovedForManyCleansedScoreEvent) == 0x0000F8, "Member 'UK32EmpScoreComponent::_minHookedSurvivorAssimilationsRemovedForManyCleansedScoreEvent' has a wrong offset!");
static_assert(offsetof(UK32EmpScoreComponent, _basePodRemovalScoreValue) == 0x000120, "Member 'UK32EmpScoreComponent::_basePodRemovalScoreValue' has a wrong offset!");
static_assert(offsetof(UK32EmpScoreComponent, _podRemovedScoreEventDepreciationCurve) == 0x000148, "Member 'UK32EmpScoreComponent::_podRemovedScoreEventDepreciationCurve' has a wrong offset!");
static_assert(offsetof(UK32EmpScoreComponent, _unhookedSurvivorsCleansedScoreEventDepreciationCurve) == 0x000150, "Member 'UK32EmpScoreComponent::_unhookedSurvivorsCleansedScoreEventDepreciationCurve' has a wrong offset!");
static_assert(offsetof(UK32EmpScoreComponent, _hookedSurvivorsCleansedScoreEventDepreciationCurve) == 0x000158, "Member 'UK32EmpScoreComponent::_hookedSurvivorsCleansedScoreEventDepreciationCurve' has a wrong offset!");

// Class TheK32.K32GameStateComponent
// 0x0010 (0x00B8 - 0x00A8)
class UK32GameStateComponent final : public UActorComponent
{
public:
	TArray<class AK32ItemBox*>                    _k32ItemBox;                                       // 0x00A8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K32GameStateComponent">();
	}
	static class UK32GameStateComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK32GameStateComponent>();
	}
};
static_assert(alignof(UK32GameStateComponent) == 0x000008, "Wrong alignment on UK32GameStateComponent");
static_assert(sizeof(UK32GameStateComponent) == 0x0000B8, "Wrong size on UK32GameStateComponent");
static_assert(offsetof(UK32GameStateComponent, _k32ItemBox) == 0x0000A8, "Member 'UK32GameStateComponent::_k32ItemBox' has a wrong offset!");

// Class TheK32.K32ItemBox
// 0x00E8 (0x0490 - 0x03A8)
class AK32ItemBox final : public AInteractable
{
public:
	uint8                                         Pad_3A8[0x8];                                      // 0x03A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UChargeableComponent*                   _chargeable;                                       // 0x03B0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ACollectable*                           _spawnedItem;                                      // 0x03B8(0x0008)(Net, ZeroConstructor, Transient, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        _containingItemSpawnPoint;                         // 0x03C0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        _itemDropPoint;                                    // 0x03C8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EK32ItemBoxState                              _state;                                            // 0x03D0(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3D1[0x7];                                      // 0x03D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UK32ItemBoxSpeedUpInteraction*          _itemBoxSpeedUpInteraction;                        // 0x03D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoClear, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInteractor*                            _interactor;                                       // 0x03E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoClear, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPrimitiveComponent*                    _interactionZone;                                  // 0x03E8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoClear, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDBDOutlineComponent*                   _outlineComponent;                                 // 0x03F0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoClear, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDBDSkeletalMeshComponentBudgeted*      _skeletalMeshComponent;                            // 0x03F8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _inProgressDuration;                               // 0x0400(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _addon12ChargeTimeExtension;                       // 0x0428(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _maxAutoChargeRatio;                               // 0x0450(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	bool                                          _isSurvivorInteracting;                            // 0x0478(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_479[0x7];                                      // 0x0479(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ADBDPlayer*                             _survivorInteracting;                              // 0x0480(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_488[0x8];                                      // 0x0488(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnItemPickup(class ADBDPlayer* Player);
	void Cosmetic_OnStateChanged(EK32ItemBoxState NewState);
	void Cosmetic_OnSurvivorInteractingChanged(bool IsInteracting);
	void Multicast_SetIsChargeTimeExtended(const bool IsAddonExtendingFirstActivationTimer);
	void OnChargeableCompleteEvent(bool COMPLETED, const TArray<class AActor*>& InstigatorsForCompletion);
	void OnRep_IsSurvivorInteracting();
	void OnRep_SpawnedItem();
	void OnRep_State();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K32ItemBox">();
	}
	static class AK32ItemBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK32ItemBox>();
	}
};
static_assert(alignof(AK32ItemBox) == 0x000008, "Wrong alignment on AK32ItemBox");
static_assert(sizeof(AK32ItemBox) == 0x000490, "Wrong size on AK32ItemBox");
static_assert(offsetof(AK32ItemBox, _chargeable) == 0x0003B0, "Member 'AK32ItemBox::_chargeable' has a wrong offset!");
static_assert(offsetof(AK32ItemBox, _spawnedItem) == 0x0003B8, "Member 'AK32ItemBox::_spawnedItem' has a wrong offset!");
static_assert(offsetof(AK32ItemBox, _containingItemSpawnPoint) == 0x0003C0, "Member 'AK32ItemBox::_containingItemSpawnPoint' has a wrong offset!");
static_assert(offsetof(AK32ItemBox, _itemDropPoint) == 0x0003C8, "Member 'AK32ItemBox::_itemDropPoint' has a wrong offset!");
static_assert(offsetof(AK32ItemBox, _state) == 0x0003D0, "Member 'AK32ItemBox::_state' has a wrong offset!");
static_assert(offsetof(AK32ItemBox, _itemBoxSpeedUpInteraction) == 0x0003D8, "Member 'AK32ItemBox::_itemBoxSpeedUpInteraction' has a wrong offset!");
static_assert(offsetof(AK32ItemBox, _interactor) == 0x0003E0, "Member 'AK32ItemBox::_interactor' has a wrong offset!");
static_assert(offsetof(AK32ItemBox, _interactionZone) == 0x0003E8, "Member 'AK32ItemBox::_interactionZone' has a wrong offset!");
static_assert(offsetof(AK32ItemBox, _outlineComponent) == 0x0003F0, "Member 'AK32ItemBox::_outlineComponent' has a wrong offset!");
static_assert(offsetof(AK32ItemBox, _skeletalMeshComponent) == 0x0003F8, "Member 'AK32ItemBox::_skeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(AK32ItemBox, _inProgressDuration) == 0x000400, "Member 'AK32ItemBox::_inProgressDuration' has a wrong offset!");
static_assert(offsetof(AK32ItemBox, _addon12ChargeTimeExtension) == 0x000428, "Member 'AK32ItemBox::_addon12ChargeTimeExtension' has a wrong offset!");
static_assert(offsetof(AK32ItemBox, _maxAutoChargeRatio) == 0x000450, "Member 'AK32ItemBox::_maxAutoChargeRatio' has a wrong offset!");
static_assert(offsetof(AK32ItemBox, _isSurvivorInteracting) == 0x000478, "Member 'AK32ItemBox::_isSurvivorInteracting' has a wrong offset!");
static_assert(offsetof(AK32ItemBox, _survivorInteracting) == 0x000480, "Member 'AK32ItemBox::_survivorInteracting' has a wrong offset!");

// Class TheK32.K32ItemBoxAnimInstance
// 0x0010 (0x0390 - 0x0380)
class UK32ItemBoxAnimInstance final : public UDBDBaseAnimInstance
{
public:
	class AK32ItemBox*                            _owningItemBox;                                    // 0x0380(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EK32ItemBoxState                              _currentState;                                     // 0x0388(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_389[0x7];                                      // 0x0389(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K32ItemBoxAnimInstance">();
	}
	static class UK32ItemBoxAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK32ItemBoxAnimInstance>();
	}
};
static_assert(alignof(UK32ItemBoxAnimInstance) == 0x000010, "Wrong alignment on UK32ItemBoxAnimInstance");
static_assert(sizeof(UK32ItemBoxAnimInstance) == 0x000390, "Wrong size on UK32ItemBoxAnimInstance");
static_assert(offsetof(UK32ItemBoxAnimInstance, _owningItemBox) == 0x000380, "Member 'UK32ItemBoxAnimInstance::_owningItemBox' has a wrong offset!");
static_assert(offsetof(UK32ItemBoxAnimInstance, _currentState) == 0x000388, "Member 'UK32ItemBoxAnimInstance::_currentState' has a wrong offset!");

// Class TheK32.K32ItemBoxIterativeWeightAdjustmentStrategy
// 0x0018 (0x0048 - 0x0030)
class UK32ItemBoxIterativeWeightAdjustmentStrategy final : public UIterativeWeightAdjustmentStrategy
{
public:
	TArray<TScriptInterface<class IWeightedElement>> _selectedSpawners;                                 // 0x0030(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _penaltyFromDistanceToClosestK32ItemBox;           // 0x0040(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K32ItemBoxIterativeWeightAdjustmentStrategy">();
	}
	static class UK32ItemBoxIterativeWeightAdjustmentStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK32ItemBoxIterativeWeightAdjustmentStrategy>();
	}
};
static_assert(alignof(UK32ItemBoxIterativeWeightAdjustmentStrategy) == 0x000008, "Wrong alignment on UK32ItemBoxIterativeWeightAdjustmentStrategy");
static_assert(sizeof(UK32ItemBoxIterativeWeightAdjustmentStrategy) == 0x000048, "Wrong size on UK32ItemBoxIterativeWeightAdjustmentStrategy");
static_assert(offsetof(UK32ItemBoxIterativeWeightAdjustmentStrategy, _selectedSpawners) == 0x000030, "Member 'UK32ItemBoxIterativeWeightAdjustmentStrategy::_selectedSpawners' has a wrong offset!");
static_assert(offsetof(UK32ItemBoxIterativeWeightAdjustmentStrategy, _penaltyFromDistanceToClosestK32ItemBox) == 0x000040, "Member 'UK32ItemBoxIterativeWeightAdjustmentStrategy::_penaltyFromDistanceToClosestK32ItemBox' has a wrong offset!");

// Class TheK32.K32ItemBoxManagerComponent
// 0x0048 (0x00F0 - 0x00A8)
class UK32ItemBoxManagerComponent final : public UActorComponent
{
public:
	struct FDBDTunableRowHandle                   _initialNumberOfInProgressBoxes;                   // 0x00A8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TArray<class AK32ItemBox*>                    _itemBoxes;                                        // 0x00D0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E0[0x10];                                      // 0x00E0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnItemBoxDeactivated(const struct FGameplayTag& GameplayTag, const struct FGameEventData& GameEventData);
	void Authority_OnLevelReadyToPlay();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K32ItemBoxManagerComponent">();
	}
	static class UK32ItemBoxManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK32ItemBoxManagerComponent>();
	}
};
static_assert(alignof(UK32ItemBoxManagerComponent) == 0x000008, "Wrong alignment on UK32ItemBoxManagerComponent");
static_assert(sizeof(UK32ItemBoxManagerComponent) == 0x0000F0, "Wrong size on UK32ItemBoxManagerComponent");
static_assert(offsetof(UK32ItemBoxManagerComponent, _initialNumberOfInProgressBoxes) == 0x0000A8, "Member 'UK32ItemBoxManagerComponent::_initialNumberOfInProgressBoxes' has a wrong offset!");
static_assert(offsetof(UK32ItemBoxManagerComponent, _itemBoxes) == 0x0000D0, "Member 'UK32ItemBoxManagerComponent::_itemBoxes' has a wrong offset!");

// Class TheK32.K32ItemBoxOutlineUpdateStrategy
// 0x00D0 (0x01A0 - 0x00D0)
class UK32ItemBoxOutlineUpdateStrategy final : public UOutlineUpdateStrategy
{
public:
	struct FTunableStat                           _distanceToShowOutline;                            // 0x00D0(0x0080)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _isOutlineVisibleToSurvivorsWithEmp;               // 0x0150(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FLinearColor                           _belowMaxAutoChargeRatioOutlineColor;              // 0x0178(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           _aboveMaxAutoChargeRatioOutlineColor;              // 0x0188(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_198[0x8];                                      // 0x0198(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnDistanceStatValueUpdated(const float Distance);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K32ItemBoxOutlineUpdateStrategy">();
	}
	static class UK32ItemBoxOutlineUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK32ItemBoxOutlineUpdateStrategy>();
	}
};
static_assert(alignof(UK32ItemBoxOutlineUpdateStrategy) == 0x000008, "Wrong alignment on UK32ItemBoxOutlineUpdateStrategy");
static_assert(sizeof(UK32ItemBoxOutlineUpdateStrategy) == 0x0001A0, "Wrong size on UK32ItemBoxOutlineUpdateStrategy");
static_assert(offsetof(UK32ItemBoxOutlineUpdateStrategy, _distanceToShowOutline) == 0x0000D0, "Member 'UK32ItemBoxOutlineUpdateStrategy::_distanceToShowOutline' has a wrong offset!");
static_assert(offsetof(UK32ItemBoxOutlineUpdateStrategy, _isOutlineVisibleToSurvivorsWithEmp) == 0x000150, "Member 'UK32ItemBoxOutlineUpdateStrategy::_isOutlineVisibleToSurvivorsWithEmp' has a wrong offset!");
static_assert(offsetof(UK32ItemBoxOutlineUpdateStrategy, _belowMaxAutoChargeRatioOutlineColor) == 0x000178, "Member 'UK32ItemBoxOutlineUpdateStrategy::_belowMaxAutoChargeRatioOutlineColor' has a wrong offset!");
static_assert(offsetof(UK32ItemBoxOutlineUpdateStrategy, _aboveMaxAutoChargeRatioOutlineColor) == 0x000188, "Member 'UK32ItemBoxOutlineUpdateStrategy::_aboveMaxAutoChargeRatioOutlineColor' has a wrong offset!");

// Class TheK32.K32ItemBoxSpeedUpInteraction
// 0x00A0 (0x0960 - 0x08C0)
class UK32ItemBoxSpeedUpInteraction final : public UChargeableInteractionDefinition
{
public:
	uint8                                         Pad_8C0[0x18];                                     // 0x08C0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTunableStat                           _interactionProgressMultiplier;                    // 0x08D8(0x0080)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_958[0x8];                                      // 0x0958(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnLevelReadyToPlay();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K32ItemBoxSpeedUpInteraction">();
	}
	static class UK32ItemBoxSpeedUpInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK32ItemBoxSpeedUpInteraction>();
	}
};
static_assert(alignof(UK32ItemBoxSpeedUpInteraction) == 0x000010, "Wrong alignment on UK32ItemBoxSpeedUpInteraction");
static_assert(sizeof(UK32ItemBoxSpeedUpInteraction) == 0x000960, "Wrong size on UK32ItemBoxSpeedUpInteraction");
static_assert(offsetof(UK32ItemBoxSpeedUpInteraction, _interactionProgressMultiplier) == 0x0008D8, "Member 'UK32ItemBoxSpeedUpInteraction::_interactionProgressMultiplier' has a wrong offset!");

// Class TheK32.K32KillerInstinctStatusEffect
// 0x0038 (0x03B8 - 0x0380)
class UK32KillerInstinctStatusEffect final : public UKillerInstinctStatusEffect
{
public:
	EK32KillerInstinctType                        _killerInstinctType;                               // 0x0380(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_381[0x37];                                     // 0x0381(0x0037)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K32KillerInstinctStatusEffect">();
	}
	static class UK32KillerInstinctStatusEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK32KillerInstinctStatusEffect>();
	}
};
static_assert(alignof(UK32KillerInstinctStatusEffect) == 0x000008, "Wrong alignment on UK32KillerInstinctStatusEffect");
static_assert(sizeof(UK32KillerInstinctStatusEffect) == 0x0003B8, "Wrong size on UK32KillerInstinctStatusEffect");
static_assert(offsetof(UK32KillerInstinctStatusEffect, _killerInstinctType) == 0x000380, "Member 'UK32KillerInstinctStatusEffect::_killerInstinctType' has a wrong offset!");

// Class TheK32.K32KillerPod
// 0x02A8 (0x0548 - 0x02A0)
class AK32KillerPod final : public AActor
{
public:
	uint8                                         Pad_2A0[0x18];                                     // 0x02A0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnDisabledChanged;                                 // 0x02B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C8[0x18];                                     // 0x02C8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnAcquiredChanged;                                 // 0x02E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   _overlapTestingMeshComponent;                      // 0x02F0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoClear, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMapActorComponent*                     _mapActorComponent;                                // 0x02F8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoClear, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTunableStat                           _podDisableTime;                                   // 0x0300(0x0080)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _killerHearSoundsInPodActivationDelay;             // 0x0380(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _podDisabledPreEndingEffectTime;                   // 0x03A8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FK32KillerPodSettings                  _settings;                                         // 0x03D0(0x0098)(Net, RepNotify, NativeAccessSpecifierPrivate)
	bool                                          _isAcquiredFromPool;                               // 0x0468(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_469[0xB7];                                     // 0x0469(0x00B7)(Fixing Size After Last Property [ Dumper-7 ])
	class UK32PodDangerPredictionComponent*       _dangerPredictionComponent;                        // 0x0520(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAIPerceptionStimuliSourceComponent*    _perceptionStimuliComponent;                       // 0x0528(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_530[0x18];                                     // 0x0530(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnDisabledTimerDone();
	void Authority_OnPodDisabledPreEndingEffectStarted();
	void Cosmetic_IsBlockingPodSpawningChanged(const bool IsBlocking, const float DistanceBetweenPods);
	void Cosmetic_OnControlledByKillerChanged(const struct FK32KillerPodSettings& PreviousSettings, const struct FK32KillerPodSettings& Settings);
	void Cosmetic_OnDestroyedByEmp(class ADBDPlayer* DestroyingSurvivor);
	void Cosmetic_OnDestroyedByManualRemoval();
	void Cosmetic_OnDestroyedByRecycle();
	void Cosmetic_OnDisabledChanged(const struct FK32KillerPodSettings& PreviousSettings, const struct FK32KillerPodSettings& Settings);
	void Cosmetic_OnKillerHearSoundsInPodActivated();
	void Cosmetic_OnKillerHearSoundsInPodDeactivated();
	void Cosmetic_OnSettingsChanged(const struct FK32KillerPodSettings& PreviousSettings, const struct FK32KillerPodSettings& Settings);
	void Multicast_OnDestroyedByEmp(class ADBDPlayer* DestroyingSurvivor);
	void Multicast_OnDestroyedByManualRemoval();
	void Multicast_OnDestroyedByRecycle();
	void Multicast_OnPodDisabled();
	void OnKillerLocallyObservedChanged(const bool IsKillerLocallyObserved);
	void OnKillerSet(class ASlasherPlayer* Killer);
	void OnLevelReadyToPlay();
	void OnRep_IsAcquiredFromPool();
	void OnRep_Settings(const struct FK32KillerPodSettings& PreviousSettings);
	void OnVisibilityChanged(const struct FK32KillerPodSettings& PreviousSettings, const struct FK32KillerPodSettings& Settings);

	class ASlasherPlayer* GetKiller() const;
	struct FK32KillerPodSettings GetSettings() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K32KillerPod">();
	}
	static class AK32KillerPod* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK32KillerPod>();
	}
};
static_assert(alignof(AK32KillerPod) == 0x000008, "Wrong alignment on AK32KillerPod");
static_assert(sizeof(AK32KillerPod) == 0x000548, "Wrong size on AK32KillerPod");
static_assert(offsetof(AK32KillerPod, OnDisabledChanged) == 0x0002B8, "Member 'AK32KillerPod::OnDisabledChanged' has a wrong offset!");
static_assert(offsetof(AK32KillerPod, OnAcquiredChanged) == 0x0002E0, "Member 'AK32KillerPod::OnAcquiredChanged' has a wrong offset!");
static_assert(offsetof(AK32KillerPod, _overlapTestingMeshComponent) == 0x0002F0, "Member 'AK32KillerPod::_overlapTestingMeshComponent' has a wrong offset!");
static_assert(offsetof(AK32KillerPod, _mapActorComponent) == 0x0002F8, "Member 'AK32KillerPod::_mapActorComponent' has a wrong offset!");
static_assert(offsetof(AK32KillerPod, _podDisableTime) == 0x000300, "Member 'AK32KillerPod::_podDisableTime' has a wrong offset!");
static_assert(offsetof(AK32KillerPod, _killerHearSoundsInPodActivationDelay) == 0x000380, "Member 'AK32KillerPod::_killerHearSoundsInPodActivationDelay' has a wrong offset!");
static_assert(offsetof(AK32KillerPod, _podDisabledPreEndingEffectTime) == 0x0003A8, "Member 'AK32KillerPod::_podDisabledPreEndingEffectTime' has a wrong offset!");
static_assert(offsetof(AK32KillerPod, _settings) == 0x0003D0, "Member 'AK32KillerPod::_settings' has a wrong offset!");
static_assert(offsetof(AK32KillerPod, _isAcquiredFromPool) == 0x000468, "Member 'AK32KillerPod::_isAcquiredFromPool' has a wrong offset!");
static_assert(offsetof(AK32KillerPod, _dangerPredictionComponent) == 0x000520, "Member 'AK32KillerPod::_dangerPredictionComponent' has a wrong offset!");
static_assert(offsetof(AK32KillerPod, _perceptionStimuliComponent) == 0x000528, "Member 'AK32KillerPod::_perceptionStimuliComponent' has a wrong offset!");

// Class TheK32.K32KillerPodAimingCrosshairComponent
// 0x0008 (0x00F0 - 0x00E8)
class UK32KillerPodAimingCrosshairComponent final : public UAimingCrosshairComponent
{
public:
	class UCameraComponent*                       _currentPodCamera;                                 // 0x00E8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class UCameraComponent* GetCurrentPodCamera();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K32KillerPodAimingCrosshairComponent">();
	}
	static class UK32KillerPodAimingCrosshairComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK32KillerPodAimingCrosshairComponent>();
	}
};
static_assert(alignof(UK32KillerPodAimingCrosshairComponent) == 0x000008, "Wrong alignment on UK32KillerPodAimingCrosshairComponent");
static_assert(sizeof(UK32KillerPodAimingCrosshairComponent) == 0x0000F0, "Wrong size on UK32KillerPodAimingCrosshairComponent");
static_assert(offsetof(UK32KillerPodAimingCrosshairComponent, _currentPodCamera) == 0x0000E8, "Member 'UK32KillerPodAimingCrosshairComponent::_currentPodCamera' has a wrong offset!");

// Class TheK32.K32KillerPodLockOnCooldownComponent
// 0x00A0 (0x0148 - 0x00A8)
class UK32KillerPodLockOnCooldownComponent final : public UActorComponent
{
public:
	struct FTunableStat                           _cooldownTime;                                     // 0x00A8(0x0080)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_128[0x20];                                     // 0x0128(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K32KillerPodLockOnCooldownComponent">();
	}
	static class UK32KillerPodLockOnCooldownComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK32KillerPodLockOnCooldownComponent>();
	}
};
static_assert(alignof(UK32KillerPodLockOnCooldownComponent) == 0x000008, "Wrong alignment on UK32KillerPodLockOnCooldownComponent");
static_assert(sizeof(UK32KillerPodLockOnCooldownComponent) == 0x000148, "Wrong size on UK32KillerPodLockOnCooldownComponent");
static_assert(offsetof(UK32KillerPodLockOnCooldownComponent, _cooldownTime) == 0x0000A8, "Member 'UK32KillerPodLockOnCooldownComponent::_cooldownTime' has a wrong offset!");

// Class TheK32.K32KillerPodLockOnProgressComponent
// 0x0088 (0x0130 - 0x00A8)
class UK32KillerPodLockOnProgressComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x1];                                       // 0x00A8(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	EAimingCrosshairState                         _crosshairState;                                   // 0x00A9(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_AA[0x2];                                       // 0x00AA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _progress;                                         // 0x00AC(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UK32SurvivorLockedOnTimeComponent*      _currentSurvivorLockedOnTimeComponent;             // 0x00B0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B8[0x78];                                      // 0x00B8(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Server_SetCrosshairState(const EAimingCrosshairState CrosshairState);
	void Server_SetLockOnState(const ELockOnState State, const EAimingCrosshairState CrosshairState, const class ACamperPlayer* SurvivorBeingLockedOn, const ESurvivorLockedOnProgressState SurvivorLockedOnProgressState);

	void OnRep_CrosshairState() const;
	void OnRep_Progress() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K32KillerPodLockOnProgressComponent">();
	}
	static class UK32KillerPodLockOnProgressComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK32KillerPodLockOnProgressComponent>();
	}
};
static_assert(alignof(UK32KillerPodLockOnProgressComponent) == 0x000008, "Wrong alignment on UK32KillerPodLockOnProgressComponent");
static_assert(sizeof(UK32KillerPodLockOnProgressComponent) == 0x000130, "Wrong size on UK32KillerPodLockOnProgressComponent");
static_assert(offsetof(UK32KillerPodLockOnProgressComponent, _crosshairState) == 0x0000A9, "Member 'UK32KillerPodLockOnProgressComponent::_crosshairState' has a wrong offset!");
static_assert(offsetof(UK32KillerPodLockOnProgressComponent, _progress) == 0x0000AC, "Member 'UK32KillerPodLockOnProgressComponent::_progress' has a wrong offset!");
static_assert(offsetof(UK32KillerPodLockOnProgressComponent, _currentSurvivorLockedOnTimeComponent) == 0x0000B0, "Member 'UK32KillerPodLockOnProgressComponent::_currentSurvivorLockedOnTimeComponent' has a wrong offset!");

// Class TheK32.K32KillerPodOutlineUpdateStrategy
// 0x0078 (0x0148 - 0x00D0)
class UK32KillerPodOutlineUpdateStrategy final : public UOutlineUpdateStrategy
{
public:
	float                                         _lastPodShowTime;                                  // 0x00D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           _revealedColorToSurvivor;                          // 0x00D4(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FColor                                 _autoAimAuraColor;                                 // 0x00E4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _autoAimAuraThresholdPercent;                      // 0x00E8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_110[0x38];                                     // 0x0110(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K32KillerPodOutlineUpdateStrategy">();
	}
	static class UK32KillerPodOutlineUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK32KillerPodOutlineUpdateStrategy>();
	}
};
static_assert(alignof(UK32KillerPodOutlineUpdateStrategy) == 0x000008, "Wrong alignment on UK32KillerPodOutlineUpdateStrategy");
static_assert(sizeof(UK32KillerPodOutlineUpdateStrategy) == 0x000148, "Wrong size on UK32KillerPodOutlineUpdateStrategy");
static_assert(offsetof(UK32KillerPodOutlineUpdateStrategy, _lastPodShowTime) == 0x0000D0, "Member 'UK32KillerPodOutlineUpdateStrategy::_lastPodShowTime' has a wrong offset!");
static_assert(offsetof(UK32KillerPodOutlineUpdateStrategy, _revealedColorToSurvivor) == 0x0000D4, "Member 'UK32KillerPodOutlineUpdateStrategy::_revealedColorToSurvivor' has a wrong offset!");
static_assert(offsetof(UK32KillerPodOutlineUpdateStrategy, _autoAimAuraColor) == 0x0000E4, "Member 'UK32KillerPodOutlineUpdateStrategy::_autoAimAuraColor' has a wrong offset!");
static_assert(offsetof(UK32KillerPodOutlineUpdateStrategy, _autoAimAuraThresholdPercent) == 0x0000E8, "Member 'UK32KillerPodOutlineUpdateStrategy::_autoAimAuraThresholdPercent' has a wrong offset!");

// Class TheK32.K32KillerPodPool
// 0x01E0 (0x02E8 - 0x0108)
class UK32KillerPodPool final : public UAuthoritativeActorPoolComponent
{
public:
	struct FTunableStat                           _availableAmmo;                                    // 0x0108(0x0080)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _lastControlledPodLingerTime;                      // 0x0188(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _destroyPodDelay;                                  // 0x01B0(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _initialDestroyPodDelay;                           // 0x01D8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AK32KillerPod>           _controlledPod;                                    // 0x0200(0x0008)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_208[0xE0];                                     // 0x0208(0x00E0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnDestroyPodDelayTimerDone(class ADBDPlayer* LaunchingSurvivor);
	void OnKillerPodAcquiredChanged(const bool IsAcquired);
	void OnKillerPodCreated(class AActor* Actor);
	void OnLevelReadyToPlay();
	void OnLingeringLastControlledPodExpired();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K32KillerPodPool">();
	}
	static class UK32KillerPodPool* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK32KillerPodPool>();
	}
};
static_assert(alignof(UK32KillerPodPool) == 0x000008, "Wrong alignment on UK32KillerPodPool");
static_assert(sizeof(UK32KillerPodPool) == 0x0002E8, "Wrong size on UK32KillerPodPool");
static_assert(offsetof(UK32KillerPodPool, _availableAmmo) == 0x000108, "Member 'UK32KillerPodPool::_availableAmmo' has a wrong offset!");
static_assert(offsetof(UK32KillerPodPool, _lastControlledPodLingerTime) == 0x000188, "Member 'UK32KillerPodPool::_lastControlledPodLingerTime' has a wrong offset!");
static_assert(offsetof(UK32KillerPodPool, _destroyPodDelay) == 0x0001B0, "Member 'UK32KillerPodPool::_destroyPodDelay' has a wrong offset!");
static_assert(offsetof(UK32KillerPodPool, _initialDestroyPodDelay) == 0x0001D8, "Member 'UK32KillerPodPool::_initialDestroyPodDelay' has a wrong offset!");
static_assert(offsetof(UK32KillerPodPool, _controlledPod) == 0x000200, "Member 'UK32KillerPodPool::_controlledPod' has a wrong offset!");

// Class TheK32.K32KillerPodRestrictedZone
// 0x0000 (0x02A0 - 0x02A0)
class AK32KillerPodRestrictedZone : public AActor
{
public:
	class UStaticMeshComponent* GetStaticMesh() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K32KillerPodRestrictedZone">();
	}
	static class AK32KillerPodRestrictedZone* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK32KillerPodRestrictedZone>();
	}
};
static_assert(alignof(AK32KillerPodRestrictedZone) == 0x000008, "Wrong alignment on AK32KillerPodRestrictedZone");
static_assert(sizeof(AK32KillerPodRestrictedZone) == 0x0002A0, "Wrong size on AK32KillerPodRestrictedZone");

// Class TheK32.K32KillerPodSpawningComponent
// 0x04D0 (0x0578 - 0x00A8)
class UK32KillerPodSpawningComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x18];                                      // 0x00A8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _podRemovalRange;                                  // 0x00C0(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _maximumRange;                                     // 0x00E8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _maximumRelativeHeight;                            // 0x0110(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _podSurfaceDistance;                               // 0x0138(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         _worldDetectionTraceSphereSize;                    // 0x0160(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_164[0x4];                                      // 0x0164(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            _surfaceNormalTestTraceSphereSizeCurve;            // 0x0168(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _survivorDetectionSphereSize;                      // 0x0170(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _lineOfSightTraceSphereSize;                       // 0x0174(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _podCollisionToFinalLocationTraceSphereSize;       // 0x0178(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_17C[0x4];                                      // 0x017C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _podInteractableRestrictionRange;                  // 0x0180(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _podWindowRestrictionRange;                        // 0x01A8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _podGeneratorRestrictionRange;                     // 0x01D0(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         _secondaryHitCheckDistance;                        // 0x01F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _secondaryHitCheckBackDistance;                    // 0x01FC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _secondaryHitPitchRotationDegrees;                 // 0x0200(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _secondaryHitYawRotationDegrees;                   // 0x0204(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _floorSearchingLength;                             // 0x0208(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_20C[0x4];                                      // 0x020C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _podSurfaceMinDegreesThreshold;                    // 0x0210(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _podSurfaceMaxDegreesThreshold;                    // 0x0238(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _minimumSpawnDistance;                             // 0x0260(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _requiredAttachmentPoints;                         // 0x0288(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         _attachmentPointGridHorizontalAngle;               // 0x02B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _attachmentPointGridVerticalAngle;                 // 0x02B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _attachmentPointGridLength;                        // 0x02B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2BC[0x4];                                      // 0x02BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _distanceBetweenPods;                              // 0x02C0(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _addon13EffectActivationRange;                     // 0x02E8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _addon13EffectDuration;                            // 0x0310(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UStatusEffect>              _revealSurvivorToKillerStatusEffectClass;          // 0x0338(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _attachmentPointsRays;                             // 0x0340(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         _validationAllowedDistanceOffset;                  // 0x0368(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _indicatorPointToLocationFactor;                   // 0x036C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _traceProfile;                                     // 0x0370(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_37C[0x4];                                      // 0x037C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _invalidShowDelay;                                 // 0x0380(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _invalidTeleportToSurvivorShowDelay;               // 0x03A8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FVector                                _projectileSpawnOffset;                            // 0x03D0(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _forwardProjectileSpawnDistance;                   // 0x03E8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3EC[0x4];                                      // 0x03EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _useAimAssistV2;                                   // 0x03F0(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UCurveFloat*                            _survivorCapsuleHorizontalScaleFactor;             // 0x0418(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            _survivorCapsuleVerticalScaleFactor;               // 0x0420(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_428[0x150];                                    // 0x0428(0x0150)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Multicast_FireKillerProjectile();
	void OnIntroCompleted();
	void Server_FireKillerProjectile(const struct FK32KillerPodSpawningInputData& InputData, const EK32KillerPodSpawningResult ExpectedResult);

	void Cosmetic_OnInvalidPodTriggers(const struct FVector& InvalidLocation) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K32KillerPodSpawningComponent">();
	}
	static class UK32KillerPodSpawningComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK32KillerPodSpawningComponent>();
	}
};
static_assert(alignof(UK32KillerPodSpawningComponent) == 0x000008, "Wrong alignment on UK32KillerPodSpawningComponent");
static_assert(sizeof(UK32KillerPodSpawningComponent) == 0x000578, "Wrong size on UK32KillerPodSpawningComponent");
static_assert(offsetof(UK32KillerPodSpawningComponent, _podRemovalRange) == 0x0000C0, "Member 'UK32KillerPodSpawningComponent::_podRemovalRange' has a wrong offset!");
static_assert(offsetof(UK32KillerPodSpawningComponent, _maximumRange) == 0x0000E8, "Member 'UK32KillerPodSpawningComponent::_maximumRange' has a wrong offset!");
static_assert(offsetof(UK32KillerPodSpawningComponent, _maximumRelativeHeight) == 0x000110, "Member 'UK32KillerPodSpawningComponent::_maximumRelativeHeight' has a wrong offset!");
static_assert(offsetof(UK32KillerPodSpawningComponent, _podSurfaceDistance) == 0x000138, "Member 'UK32KillerPodSpawningComponent::_podSurfaceDistance' has a wrong offset!");
static_assert(offsetof(UK32KillerPodSpawningComponent, _worldDetectionTraceSphereSize) == 0x000160, "Member 'UK32KillerPodSpawningComponent::_worldDetectionTraceSphereSize' has a wrong offset!");
static_assert(offsetof(UK32KillerPodSpawningComponent, _surfaceNormalTestTraceSphereSizeCurve) == 0x000168, "Member 'UK32KillerPodSpawningComponent::_surfaceNormalTestTraceSphereSizeCurve' has a wrong offset!");
static_assert(offsetof(UK32KillerPodSpawningComponent, _survivorDetectionSphereSize) == 0x000170, "Member 'UK32KillerPodSpawningComponent::_survivorDetectionSphereSize' has a wrong offset!");
static_assert(offsetof(UK32KillerPodSpawningComponent, _lineOfSightTraceSphereSize) == 0x000174, "Member 'UK32KillerPodSpawningComponent::_lineOfSightTraceSphereSize' has a wrong offset!");
static_assert(offsetof(UK32KillerPodSpawningComponent, _podCollisionToFinalLocationTraceSphereSize) == 0x000178, "Member 'UK32KillerPodSpawningComponent::_podCollisionToFinalLocationTraceSphereSize' has a wrong offset!");
static_assert(offsetof(UK32KillerPodSpawningComponent, _podInteractableRestrictionRange) == 0x000180, "Member 'UK32KillerPodSpawningComponent::_podInteractableRestrictionRange' has a wrong offset!");
static_assert(offsetof(UK32KillerPodSpawningComponent, _podWindowRestrictionRange) == 0x0001A8, "Member 'UK32KillerPodSpawningComponent::_podWindowRestrictionRange' has a wrong offset!");
static_assert(offsetof(UK32KillerPodSpawningComponent, _podGeneratorRestrictionRange) == 0x0001D0, "Member 'UK32KillerPodSpawningComponent::_podGeneratorRestrictionRange' has a wrong offset!");
static_assert(offsetof(UK32KillerPodSpawningComponent, _secondaryHitCheckDistance) == 0x0001F8, "Member 'UK32KillerPodSpawningComponent::_secondaryHitCheckDistance' has a wrong offset!");
static_assert(offsetof(UK32KillerPodSpawningComponent, _secondaryHitCheckBackDistance) == 0x0001FC, "Member 'UK32KillerPodSpawningComponent::_secondaryHitCheckBackDistance' has a wrong offset!");
static_assert(offsetof(UK32KillerPodSpawningComponent, _secondaryHitPitchRotationDegrees) == 0x000200, "Member 'UK32KillerPodSpawningComponent::_secondaryHitPitchRotationDegrees' has a wrong offset!");
static_assert(offsetof(UK32KillerPodSpawningComponent, _secondaryHitYawRotationDegrees) == 0x000204, "Member 'UK32KillerPodSpawningComponent::_secondaryHitYawRotationDegrees' has a wrong offset!");
static_assert(offsetof(UK32KillerPodSpawningComponent, _floorSearchingLength) == 0x000208, "Member 'UK32KillerPodSpawningComponent::_floorSearchingLength' has a wrong offset!");
static_assert(offsetof(UK32KillerPodSpawningComponent, _podSurfaceMinDegreesThreshold) == 0x000210, "Member 'UK32KillerPodSpawningComponent::_podSurfaceMinDegreesThreshold' has a wrong offset!");
static_assert(offsetof(UK32KillerPodSpawningComponent, _podSurfaceMaxDegreesThreshold) == 0x000238, "Member 'UK32KillerPodSpawningComponent::_podSurfaceMaxDegreesThreshold' has a wrong offset!");
static_assert(offsetof(UK32KillerPodSpawningComponent, _minimumSpawnDistance) == 0x000260, "Member 'UK32KillerPodSpawningComponent::_minimumSpawnDistance' has a wrong offset!");
static_assert(offsetof(UK32KillerPodSpawningComponent, _requiredAttachmentPoints) == 0x000288, "Member 'UK32KillerPodSpawningComponent::_requiredAttachmentPoints' has a wrong offset!");
static_assert(offsetof(UK32KillerPodSpawningComponent, _attachmentPointGridHorizontalAngle) == 0x0002B0, "Member 'UK32KillerPodSpawningComponent::_attachmentPointGridHorizontalAngle' has a wrong offset!");
static_assert(offsetof(UK32KillerPodSpawningComponent, _attachmentPointGridVerticalAngle) == 0x0002B4, "Member 'UK32KillerPodSpawningComponent::_attachmentPointGridVerticalAngle' has a wrong offset!");
static_assert(offsetof(UK32KillerPodSpawningComponent, _attachmentPointGridLength) == 0x0002B8, "Member 'UK32KillerPodSpawningComponent::_attachmentPointGridLength' has a wrong offset!");
static_assert(offsetof(UK32KillerPodSpawningComponent, _distanceBetweenPods) == 0x0002C0, "Member 'UK32KillerPodSpawningComponent::_distanceBetweenPods' has a wrong offset!");
static_assert(offsetof(UK32KillerPodSpawningComponent, _addon13EffectActivationRange) == 0x0002E8, "Member 'UK32KillerPodSpawningComponent::_addon13EffectActivationRange' has a wrong offset!");
static_assert(offsetof(UK32KillerPodSpawningComponent, _addon13EffectDuration) == 0x000310, "Member 'UK32KillerPodSpawningComponent::_addon13EffectDuration' has a wrong offset!");
static_assert(offsetof(UK32KillerPodSpawningComponent, _revealSurvivorToKillerStatusEffectClass) == 0x000338, "Member 'UK32KillerPodSpawningComponent::_revealSurvivorToKillerStatusEffectClass' has a wrong offset!");
static_assert(offsetof(UK32KillerPodSpawningComponent, _attachmentPointsRays) == 0x000340, "Member 'UK32KillerPodSpawningComponent::_attachmentPointsRays' has a wrong offset!");
static_assert(offsetof(UK32KillerPodSpawningComponent, _validationAllowedDistanceOffset) == 0x000368, "Member 'UK32KillerPodSpawningComponent::_validationAllowedDistanceOffset' has a wrong offset!");
static_assert(offsetof(UK32KillerPodSpawningComponent, _indicatorPointToLocationFactor) == 0x00036C, "Member 'UK32KillerPodSpawningComponent::_indicatorPointToLocationFactor' has a wrong offset!");
static_assert(offsetof(UK32KillerPodSpawningComponent, _traceProfile) == 0x000370, "Member 'UK32KillerPodSpawningComponent::_traceProfile' has a wrong offset!");
static_assert(offsetof(UK32KillerPodSpawningComponent, _invalidShowDelay) == 0x000380, "Member 'UK32KillerPodSpawningComponent::_invalidShowDelay' has a wrong offset!");
static_assert(offsetof(UK32KillerPodSpawningComponent, _invalidTeleportToSurvivorShowDelay) == 0x0003A8, "Member 'UK32KillerPodSpawningComponent::_invalidTeleportToSurvivorShowDelay' has a wrong offset!");
static_assert(offsetof(UK32KillerPodSpawningComponent, _projectileSpawnOffset) == 0x0003D0, "Member 'UK32KillerPodSpawningComponent::_projectileSpawnOffset' has a wrong offset!");
static_assert(offsetof(UK32KillerPodSpawningComponent, _forwardProjectileSpawnDistance) == 0x0003E8, "Member 'UK32KillerPodSpawningComponent::_forwardProjectileSpawnDistance' has a wrong offset!");
static_assert(offsetof(UK32KillerPodSpawningComponent, _useAimAssistV2) == 0x0003F0, "Member 'UK32KillerPodSpawningComponent::_useAimAssistV2' has a wrong offset!");
static_assert(offsetof(UK32KillerPodSpawningComponent, _survivorCapsuleHorizontalScaleFactor) == 0x000418, "Member 'UK32KillerPodSpawningComponent::_survivorCapsuleHorizontalScaleFactor' has a wrong offset!");
static_assert(offsetof(UK32KillerPodSpawningComponent, _survivorCapsuleVerticalScaleFactor) == 0x000420, "Member 'UK32KillerPodSpawningComponent::_survivorCapsuleVerticalScaleFactor' has a wrong offset!");

// Class TheK32.K32KillerPodSpawningIndicator
// 0x0038 (0x02D8 - 0x02A0)
class AK32KillerPodSpawningIndicator final : public AActor
{
public:
	struct FK32KillerPodSpawningIndicatorSettings _settings;                                         // 0x02A0(0x0038)(NoDestructor, NativeAccessSpecifierPrivate)

public:
	void Cosmetic_OnSettingsChanged(const struct FK32KillerPodSpawningIndicatorSettings& PreviousSettings, const struct FK32KillerPodSpawningIndicatorSettings& Settings);

	struct FK32KillerPodSpawningIndicatorSettings GetSettings() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K32KillerPodSpawningIndicator">();
	}
	static class AK32KillerPodSpawningIndicator* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK32KillerPodSpawningIndicator>();
	}
};
static_assert(alignof(AK32KillerPodSpawningIndicator) == 0x000008, "Wrong alignment on AK32KillerPodSpawningIndicator");
static_assert(sizeof(AK32KillerPodSpawningIndicator) == 0x0002D8, "Wrong size on AK32KillerPodSpawningIndicator");
static_assert(offsetof(AK32KillerPodSpawningIndicator, _settings) == 0x0002A0, "Member 'AK32KillerPodSpawningIndicator::_settings' has a wrong offset!");

// Class TheK32.K32KillerPodTargetIndicator
// 0x0038 (0x02D8 - 0x02A0)
class AK32KillerPodTargetIndicator final : public AActor
{
public:
	struct FK32KillerPodTargetIndicatorSettings   _settings;                                         // 0x02A0(0x0038)(NoDestructor, NativeAccessSpecifierPrivate)

public:
	void Cosmetic_OnSettingsChanged(const struct FK32KillerPodTargetIndicatorSettings& PreviousSettings, const struct FK32KillerPodTargetIndicatorSettings& Settings);

	struct FK32KillerPodTargetIndicatorSettings GetSettings() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K32KillerPodTargetIndicator">();
	}
	static class AK32KillerPodTargetIndicator* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK32KillerPodTargetIndicator>();
	}
};
static_assert(alignof(AK32KillerPodTargetIndicator) == 0x000008, "Wrong alignment on AK32KillerPodTargetIndicator");
static_assert(sizeof(AK32KillerPodTargetIndicator) == 0x0002D8, "Wrong size on AK32KillerPodTargetIndicator");
static_assert(offsetof(AK32KillerPodTargetIndicator, _settings) == 0x0002A0, "Member 'AK32KillerPodTargetIndicator::_settings' has a wrong offset!");

// Class TheK32.K32KillerPodTargetingComponent
// 0x0058 (0x0100 - 0x00A8)
class UK32KillerPodTargetingComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x58];                                      // 0x00A8(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_Local_NewKillerPodTargeted(class AK32KillerPod* NewTarget);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K32KillerPodTargetingComponent">();
	}
	static class UK32KillerPodTargetingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK32KillerPodTargetingComponent>();
	}
};
static_assert(alignof(UK32KillerPodTargetingComponent) == 0x000008, "Wrong alignment on UK32KillerPodTargetingComponent");
static_assert(sizeof(UK32KillerPodTargetingComponent) == 0x000100, "Wrong size on UK32KillerPodTargetingComponent");

// Class TheK32.K32KillerPodVisionController
// 0x01B0 (0x0450 - 0x02A0)
class AK32KillerPodVisionController final : public AActor
{
public:
	uint8                                         Pad_2A0[0x8];                                      // 0x02A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  _allowedInteractionSemancticsWithPodVision;        // 0x02A8(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  _allowedPodVisionInteractionSemanctic;             // 0x02C8(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _podViewPitchMinimum;                              // 0x02E8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _podViewPitchMaximum;                              // 0x0310(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _collisionDisableTime;                             // 0x0338(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         _observerRotationSpeed;                            // 0x0360(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _minTimeBetweenCameraRotationUpdateRPC;            // 0x0364(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCameraComponent*                       _camera;                                           // 0x0368(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _hasVisionFromKillerPod;                           // 0x0370(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_371[0xDF];                                     // 0x0371(0x00DF)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnCollisionDisableTimerComplete();
	void Authority_OnControlledPodDisabledChanged(const bool IsDisabled);
	void Cosmetic_Local_OnCurrentPodDisabledChanged(const bool IsDisabled);
	void Cosmetic_Local_OnReleasingControlOfPod();
	void Cosmetic_Local_OnTakingControlOfPod();
	void Multicast_OnControlledPodDisabledChanged(const bool IsDisabled);
	void Multicast_SetCameraOrientation(const struct FRotator& NewOrientation);
	void Multicast_SetKillerCollisionDisabledForSurvivors(const bool IsDisabled);
	void Multicast_SetLocationAndRotation(const struct FVector& Location);
	void OnControlledPodUnacquiredFromPool(const bool IsAcquired);
	void OnInteractionStarted(class UInteractionDefinition* Interaction);
	void OnKillerLocallyObservedChanged(const bool IsKillerLocallyObserved);
	void OnKillerSet(class ASlasherPlayer* Killer);
	void OnRep_HasVisionFromKillerPod();
	void Server_ReleaseControlOfPods();
	void Server_SetCameraOrientation(const struct FRotator& NewOrientation);
	void Server_TakeControlOfPod(class AK32KillerPod* KillerPodToBeControlled);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K32KillerPodVisionController">();
	}
	static class AK32KillerPodVisionController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK32KillerPodVisionController>();
	}
};
static_assert(alignof(AK32KillerPodVisionController) == 0x000008, "Wrong alignment on AK32KillerPodVisionController");
static_assert(sizeof(AK32KillerPodVisionController) == 0x000450, "Wrong size on AK32KillerPodVisionController");
static_assert(offsetof(AK32KillerPodVisionController, _allowedInteractionSemancticsWithPodVision) == 0x0002A8, "Member 'AK32KillerPodVisionController::_allowedInteractionSemancticsWithPodVision' has a wrong offset!");
static_assert(offsetof(AK32KillerPodVisionController, _allowedPodVisionInteractionSemanctic) == 0x0002C8, "Member 'AK32KillerPodVisionController::_allowedPodVisionInteractionSemanctic' has a wrong offset!");
static_assert(offsetof(AK32KillerPodVisionController, _podViewPitchMinimum) == 0x0002E8, "Member 'AK32KillerPodVisionController::_podViewPitchMinimum' has a wrong offset!");
static_assert(offsetof(AK32KillerPodVisionController, _podViewPitchMaximum) == 0x000310, "Member 'AK32KillerPodVisionController::_podViewPitchMaximum' has a wrong offset!");
static_assert(offsetof(AK32KillerPodVisionController, _collisionDisableTime) == 0x000338, "Member 'AK32KillerPodVisionController::_collisionDisableTime' has a wrong offset!");
static_assert(offsetof(AK32KillerPodVisionController, _observerRotationSpeed) == 0x000360, "Member 'AK32KillerPodVisionController::_observerRotationSpeed' has a wrong offset!");
static_assert(offsetof(AK32KillerPodVisionController, _minTimeBetweenCameraRotationUpdateRPC) == 0x000364, "Member 'AK32KillerPodVisionController::_minTimeBetweenCameraRotationUpdateRPC' has a wrong offset!");
static_assert(offsetof(AK32KillerPodVisionController, _camera) == 0x000368, "Member 'AK32KillerPodVisionController::_camera' has a wrong offset!");
static_assert(offsetof(AK32KillerPodVisionController, _hasVisionFromKillerPod) == 0x000370, "Member 'AK32KillerPodVisionController::_hasVisionFromKillerPod' has a wrong offset!");

// Class TheK32.K32KillerPodVisionLockOnComponent
// 0x0260 (0x0308 - 0x00A8)
class UK32KillerPodVisionLockOnComponent final : public UActorComponent
{
public:
	float                                         _lineOfSightTraceSphereSize;                       // 0x00A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _lockOnScreenCoveragePercentageY;                  // 0x00B0(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _autoDetectSurvivorRange;                          // 0x00D8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FTunableStat                           _lockOnRange;                                      // 0x0100(0x0080)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FName                                   _survivorProjectileTargetSocketName;               // 0x0180(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _traceProfile;                                     // 0x018C(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _feetOffsetMultiplier;                             // 0x0198(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _lockonableTestRadius;                             // 0x019C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _survivorLineOfSightTestPodLocationOffset;         // 0x01A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1A4[0x4];                                      // 0x01A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UK32KillerInstinctStatusEffect> _podAssimilationKillerInstinctStatusEffect;        // 0x01A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _podAssimilationKillerInstinctDuration;            // 0x01B0(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _autoAimLastLockedOnSurvivorExpiryTime;            // 0x01D8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_200[0x108];                                    // 0x0200(0x0108)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_ShootPodProjectileAtSurvivor(const class AK32KillerPod* CurrentPod, class ACamperPlayer* TargetSurvivor);
	void Multicast_ShootPodProjectileAtSurvivor(const class AK32KillerPod* OriginKillerPod, class ACamperPlayer* TargetSurvivor);
	void Server_LaunchAssimilationProjectile(class ACamperPlayer* TargetSurvivor, class AK32KillerPod* CurrentPod);
	void Server_SetSurvivorBeingLockedOn(class ACamperPlayer* TargetSurvivor, float LockOnRatio);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K32KillerPodVisionLockOnComponent">();
	}
	static class UK32KillerPodVisionLockOnComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK32KillerPodVisionLockOnComponent>();
	}
};
static_assert(alignof(UK32KillerPodVisionLockOnComponent) == 0x000008, "Wrong alignment on UK32KillerPodVisionLockOnComponent");
static_assert(sizeof(UK32KillerPodVisionLockOnComponent) == 0x000308, "Wrong size on UK32KillerPodVisionLockOnComponent");
static_assert(offsetof(UK32KillerPodVisionLockOnComponent, _lineOfSightTraceSphereSize) == 0x0000A8, "Member 'UK32KillerPodVisionLockOnComponent::_lineOfSightTraceSphereSize' has a wrong offset!");
static_assert(offsetof(UK32KillerPodVisionLockOnComponent, _lockOnScreenCoveragePercentageY) == 0x0000B0, "Member 'UK32KillerPodVisionLockOnComponent::_lockOnScreenCoveragePercentageY' has a wrong offset!");
static_assert(offsetof(UK32KillerPodVisionLockOnComponent, _autoDetectSurvivorRange) == 0x0000D8, "Member 'UK32KillerPodVisionLockOnComponent::_autoDetectSurvivorRange' has a wrong offset!");
static_assert(offsetof(UK32KillerPodVisionLockOnComponent, _lockOnRange) == 0x000100, "Member 'UK32KillerPodVisionLockOnComponent::_lockOnRange' has a wrong offset!");
static_assert(offsetof(UK32KillerPodVisionLockOnComponent, _survivorProjectileTargetSocketName) == 0x000180, "Member 'UK32KillerPodVisionLockOnComponent::_survivorProjectileTargetSocketName' has a wrong offset!");
static_assert(offsetof(UK32KillerPodVisionLockOnComponent, _traceProfile) == 0x00018C, "Member 'UK32KillerPodVisionLockOnComponent::_traceProfile' has a wrong offset!");
static_assert(offsetof(UK32KillerPodVisionLockOnComponent, _feetOffsetMultiplier) == 0x000198, "Member 'UK32KillerPodVisionLockOnComponent::_feetOffsetMultiplier' has a wrong offset!");
static_assert(offsetof(UK32KillerPodVisionLockOnComponent, _lockonableTestRadius) == 0x00019C, "Member 'UK32KillerPodVisionLockOnComponent::_lockonableTestRadius' has a wrong offset!");
static_assert(offsetof(UK32KillerPodVisionLockOnComponent, _survivorLineOfSightTestPodLocationOffset) == 0x0001A0, "Member 'UK32KillerPodVisionLockOnComponent::_survivorLineOfSightTestPodLocationOffset' has a wrong offset!");
static_assert(offsetof(UK32KillerPodVisionLockOnComponent, _podAssimilationKillerInstinctStatusEffect) == 0x0001A8, "Member 'UK32KillerPodVisionLockOnComponent::_podAssimilationKillerInstinctStatusEffect' has a wrong offset!");
static_assert(offsetof(UK32KillerPodVisionLockOnComponent, _podAssimilationKillerInstinctDuration) == 0x0001B0, "Member 'UK32KillerPodVisionLockOnComponent::_podAssimilationKillerInstinctDuration' has a wrong offset!");
static_assert(offsetof(UK32KillerPodVisionLockOnComponent, _autoAimLastLockedOnSurvivorExpiryTime) == 0x0001D8, "Member 'UK32KillerPodVisionLockOnComponent::_autoAimLastLockedOnSurvivorExpiryTime' has a wrong offset!");

// Class TheK32.K32KillerProjectileSpawnChargeableInteractionDefinition
// 0x0150 (0x0A10 - 0x08C0)
class UK32KillerProjectileSpawnChargeableInteractionDefinition final : public UChargeableInteractionDefinition
{
public:
	struct FDBDTunableRowHandle                   _reloadTime;                                       // 0x08C0(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _secondsToCharge;                                  // 0x08E8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _dechargeRate;                                     // 0x0910(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _aimAssistRotationScaleMultiplier;                 // 0x0938(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_960[0xB0];                                     // 0x0960(0x00B0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_OnPodShot();
	void Server_SendKillerAimingAtSurvivorGameEvent(const bool IsAiming, class ACamperPlayer* TargetSurvivor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K32KillerProjectileSpawnChargeableInteractionDefinition">();
	}
	static class UK32KillerProjectileSpawnChargeableInteractionDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK32KillerProjectileSpawnChargeableInteractionDefinition>();
	}
};
static_assert(alignof(UK32KillerProjectileSpawnChargeableInteractionDefinition) == 0x000010, "Wrong alignment on UK32KillerProjectileSpawnChargeableInteractionDefinition");
static_assert(sizeof(UK32KillerProjectileSpawnChargeableInteractionDefinition) == 0x000A10, "Wrong size on UK32KillerProjectileSpawnChargeableInteractionDefinition");
static_assert(offsetof(UK32KillerProjectileSpawnChargeableInteractionDefinition, _reloadTime) == 0x0008C0, "Member 'UK32KillerProjectileSpawnChargeableInteractionDefinition::_reloadTime' has a wrong offset!");
static_assert(offsetof(UK32KillerProjectileSpawnChargeableInteractionDefinition, _secondsToCharge) == 0x0008E8, "Member 'UK32KillerProjectileSpawnChargeableInteractionDefinition::_secondsToCharge' has a wrong offset!");
static_assert(offsetof(UK32KillerProjectileSpawnChargeableInteractionDefinition, _dechargeRate) == 0x000910, "Member 'UK32KillerProjectileSpawnChargeableInteractionDefinition::_dechargeRate' has a wrong offset!");
static_assert(offsetof(UK32KillerProjectileSpawnChargeableInteractionDefinition, _aimAssistRotationScaleMultiplier) == 0x000938, "Member 'UK32KillerProjectileSpawnChargeableInteractionDefinition::_aimAssistRotationScaleMultiplier' has a wrong offset!");

// Class TheK32.K32KillerToPodVisionInteractionDefinition
// 0x0060 (0x0980 - 0x0920)
class UK32KillerToPodVisionInteractionDefinition final : public UBasicChargeableInteraction
{
public:
	uint8                                         Pad_920[0x60];                                     // 0x0920(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K32KillerToPodVisionInteractionDefinition">();
	}
	static class UK32KillerToPodVisionInteractionDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK32KillerToPodVisionInteractionDefinition>();
	}
};
static_assert(alignof(UK32KillerToPodVisionInteractionDefinition) == 0x000010, "Wrong alignment on UK32KillerToPodVisionInteractionDefinition");
static_assert(sizeof(UK32KillerToPodVisionInteractionDefinition) == 0x000980, "Wrong size on UK32KillerToPodVisionInteractionDefinition");

// Class TheK32.K32KillerToSurvivorTeleportInteractionDefinition
// 0x0330 (0x0AB0 - 0x0780)
class UK32KillerToSurvivorTeleportInteractionDefinition final : public UInteractionDefinition
{
public:
	struct FDBDTunableRowHandle                   _teleportInDuration;                               // 0x0778(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _snappingDuration;                                 // 0x07A0(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _wakeUpTime;                                       // 0x07C8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _killerCollisionIgnoredLingerTime;                 // 0x07F0(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _teleportDurationExtensionThirdPersonAntiCamp;     // 0x0818(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FTunableStat                           _overclockDuration;                                // 0x0840(0x0080)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FTunableStat                           _overheatDuration;                                 // 0x08C0(0x0080)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UStatusEffect>              _overclockStatusEffect;                            // 0x0940(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UStatusEffect>              _overheatStatusEffect;                             // 0x0948(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _killerSize;                                       // 0x0950(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_954[0x4];                                      // 0x0954(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UK32KillerInstinctStatusEffect> _teleportKillerInstinctStatusEffect;               // 0x0958(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _teleportKillerInstinctDuration;                   // 0x0960(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_988[0x128];                                    // 0x0988(0x0128)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_DisableTeleportVignette(class ASlasherPlayer* Killer);
	void Cosmetic_EnableTeleportVignette(class ASlasherPlayer* Killer);
	void Cosmetic_OnTeleportEnd(class ASlasherPlayer* Killer);
	void Cosmetic_OnTeleportStart(class ASlasherPlayer* Killer, const struct FVector& TeleportEndLocation, const struct FVector& TeleportStartLocation);
	void Multicast_DestroyPallet(class APallet* Pallet);
	void Multicast_OnTeleportEnded(class ADBDPlayer* Player);
	void Multicast_OnTeleportStarted(class ADBDPlayer* Player, const struct FVector& TeleportStartLocation, const struct FVector& TeleportEndLocation);
	void Multicast_SetTeleportTarget(class ACamperPlayer* Survivor, const struct FVector& TeleportEndLocation, const struct FVector& TeleportStartLocation, class AK32KillerPod* InitiatedPod);
	void OnKillerCollisionIngoreLingerComplete(class ADBDPlayer* Player);
	void OnLevelReadyToPlay();
	void Server_SetTeleportTarget(class ACamperPlayer* Survivor, class AK32KillerPod* InitiatedPod);
	void StartTeleportOut(class ADBDPlayer* Player);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K32KillerToSurvivorTeleportInteractionDefinition">();
	}
	static class UK32KillerToSurvivorTeleportInteractionDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK32KillerToSurvivorTeleportInteractionDefinition>();
	}
};
static_assert(alignof(UK32KillerToSurvivorTeleportInteractionDefinition) == 0x000010, "Wrong alignment on UK32KillerToSurvivorTeleportInteractionDefinition");
static_assert(sizeof(UK32KillerToSurvivorTeleportInteractionDefinition) == 0x000AB0, "Wrong size on UK32KillerToSurvivorTeleportInteractionDefinition");
static_assert(offsetof(UK32KillerToSurvivorTeleportInteractionDefinition, _teleportInDuration) == 0x000778, "Member 'UK32KillerToSurvivorTeleportInteractionDefinition::_teleportInDuration' has a wrong offset!");
static_assert(offsetof(UK32KillerToSurvivorTeleportInteractionDefinition, _snappingDuration) == 0x0007A0, "Member 'UK32KillerToSurvivorTeleportInteractionDefinition::_snappingDuration' has a wrong offset!");
static_assert(offsetof(UK32KillerToSurvivorTeleportInteractionDefinition, _wakeUpTime) == 0x0007C8, "Member 'UK32KillerToSurvivorTeleportInteractionDefinition::_wakeUpTime' has a wrong offset!");
static_assert(offsetof(UK32KillerToSurvivorTeleportInteractionDefinition, _killerCollisionIgnoredLingerTime) == 0x0007F0, "Member 'UK32KillerToSurvivorTeleportInteractionDefinition::_killerCollisionIgnoredLingerTime' has a wrong offset!");
static_assert(offsetof(UK32KillerToSurvivorTeleportInteractionDefinition, _teleportDurationExtensionThirdPersonAntiCamp) == 0x000818, "Member 'UK32KillerToSurvivorTeleportInteractionDefinition::_teleportDurationExtensionThirdPersonAntiCamp' has a wrong offset!");
static_assert(offsetof(UK32KillerToSurvivorTeleportInteractionDefinition, _overclockDuration) == 0x000840, "Member 'UK32KillerToSurvivorTeleportInteractionDefinition::_overclockDuration' has a wrong offset!");
static_assert(offsetof(UK32KillerToSurvivorTeleportInteractionDefinition, _overheatDuration) == 0x0008C0, "Member 'UK32KillerToSurvivorTeleportInteractionDefinition::_overheatDuration' has a wrong offset!");
static_assert(offsetof(UK32KillerToSurvivorTeleportInteractionDefinition, _overclockStatusEffect) == 0x000940, "Member 'UK32KillerToSurvivorTeleportInteractionDefinition::_overclockStatusEffect' has a wrong offset!");
static_assert(offsetof(UK32KillerToSurvivorTeleportInteractionDefinition, _overheatStatusEffect) == 0x000948, "Member 'UK32KillerToSurvivorTeleportInteractionDefinition::_overheatStatusEffect' has a wrong offset!");
static_assert(offsetof(UK32KillerToSurvivorTeleportInteractionDefinition, _killerSize) == 0x000950, "Member 'UK32KillerToSurvivorTeleportInteractionDefinition::_killerSize' has a wrong offset!");
static_assert(offsetof(UK32KillerToSurvivorTeleportInteractionDefinition, _teleportKillerInstinctStatusEffect) == 0x000958, "Member 'UK32KillerToSurvivorTeleportInteractionDefinition::_teleportKillerInstinctStatusEffect' has a wrong offset!");
static_assert(offsetof(UK32KillerToSurvivorTeleportInteractionDefinition, _teleportKillerInstinctDuration) == 0x000960, "Member 'UK32KillerToSurvivorTeleportInteractionDefinition::_teleportKillerInstinctDuration' has a wrong offset!");

// Class TheK32.K32OverclockStatusEffectBase
// 0x00C8 (0x0448 - 0x0380)
class UK32OverclockStatusEffectBase final : public UStatusEffect
{
public:
	TSubclassOf<class UStatusEffect>              _overheatStatusEffect;                             // 0x0380(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTunableStat                           _overheatDuration;                                 // 0x0388(0x0080)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_408[0x38];                                     // 0x0408(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	class ACamperPlayer*                          _targetSurvivor;                                   // 0x0440(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Multicast_DestroyPallet(class APallet* Pallet, class ASlasherPlayer* Killer) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K32OverclockStatusEffectBase">();
	}
	static class UK32OverclockStatusEffectBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK32OverclockStatusEffectBase>();
	}
};
static_assert(alignof(UK32OverclockStatusEffectBase) == 0x000008, "Wrong alignment on UK32OverclockStatusEffectBase");
static_assert(sizeof(UK32OverclockStatusEffectBase) == 0x000448, "Wrong size on UK32OverclockStatusEffectBase");
static_assert(offsetof(UK32OverclockStatusEffectBase, _overheatStatusEffect) == 0x000380, "Member 'UK32OverclockStatusEffectBase::_overheatStatusEffect' has a wrong offset!");
static_assert(offsetof(UK32OverclockStatusEffectBase, _overheatDuration) == 0x000388, "Member 'UK32OverclockStatusEffectBase::_overheatDuration' has a wrong offset!");
static_assert(offsetof(UK32OverclockStatusEffectBase, _targetSurvivor) == 0x000440, "Member 'UK32OverclockStatusEffectBase::_targetSurvivor' has a wrong offset!");

// Class TheK32.K32OverheatStatusEffectBase
// 0x0000 (0x0380 - 0x0380)
class UK32OverheatStatusEffectBase final : public UStatusEffect
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K32OverheatStatusEffectBase">();
	}
	static class UK32OverheatStatusEffectBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK32OverheatStatusEffectBase>();
	}
};
static_assert(alignof(UK32OverheatStatusEffectBase) == 0x000008, "Wrong alignment on UK32OverheatStatusEffectBase");
static_assert(sizeof(UK32OverheatStatusEffectBase) == 0x000380, "Wrong size on UK32OverheatStatusEffectBase");

// Class TheK32.K32P01
// 0x0018 (0x0438 - 0x0420)
class UK32P01 final : public UPerk
{
public:
	TSubclassOf<class UStatusEffect>              _K32P01ExhaustedStatusEffect;                      // 0x0420(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _exhaustionDuration[0x3];                          // 0x0428(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_434[0x4];                                      // 0x0434(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetExhaustionDurationAtLevel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K32P01">();
	}
	static class UK32P01* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK32P01>();
	}
};
static_assert(alignof(UK32P01) == 0x000008, "Wrong alignment on UK32P01");
static_assert(sizeof(UK32P01) == 0x000438, "Wrong size on UK32P01");
static_assert(offsetof(UK32P01, _K32P01ExhaustedStatusEffect) == 0x000420, "Member 'UK32P01::_K32P01ExhaustedStatusEffect' has a wrong offset!");
static_assert(offsetof(UK32P01, _exhaustionDuration) == 0x000428, "Member 'UK32P01::_exhaustionDuration' has a wrong offset!");

// Class TheK32.K32P02
// 0x0040 (0x0460 - 0x0420)
class UK32P02 final : public UPerk
{
public:
	TSubclassOf<class UStatusEffect>              _hinderedStatusEffectClass;                        // 0x0420(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _perkRange[0x3];                                   // 0x0428(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _hinderedEffectDuration[0x3];                      // 0x0434(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _perkCooldown[0x3];                                // 0x0440(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_44C[0x14];                                     // 0x044C(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetHinderedEffectDurationAtLevel() const;
	float GetPerkCooldownAtLevel() const;
	float GetPerkRangeAtLevel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K32P02">();
	}
	static class UK32P02* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK32P02>();
	}
};
static_assert(alignof(UK32P02) == 0x000008, "Wrong alignment on UK32P02");
static_assert(sizeof(UK32P02) == 0x000460, "Wrong size on UK32P02");
static_assert(offsetof(UK32P02, _hinderedStatusEffectClass) == 0x000420, "Member 'UK32P02::_hinderedStatusEffectClass' has a wrong offset!");
static_assert(offsetof(UK32P02, _perkRange) == 0x000428, "Member 'UK32P02::_perkRange' has a wrong offset!");
static_assert(offsetof(UK32P02, _hinderedEffectDuration) == 0x000434, "Member 'UK32P02::_hinderedEffectDuration' has a wrong offset!");
static_assert(offsetof(UK32P02, _perkCooldown) == 0x000440, "Member 'UK32P02::_perkCooldown' has a wrong offset!");

// Class TheK32.K32P03
// 0x0038 (0x0458 - 0x0420)
class UK32P03 final : public UPerk
{
public:
	float                                         _hasteStatusEffectPercent;                         // 0x0420(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_424[0x4];                                      // 0x0424(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UStatusEffect>              _hasteStatusEffectClass;                           // 0x0428(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _undetectableStatusEffectClass;                    // 0x0430(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _statusEffectDuration[0x3];                        // 0x0438(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_444[0x4];                                      // 0x0444(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AGenerator*                             _compromisedGenerator;                             // 0x0448(0x0008)(Net, ZeroConstructor, Transient, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AGenerator*                             _lastCompromisedGenerator;                         // 0x0450(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Cosmetic_OnCompromiseCompletedVFX(const class AGenerator* CompromisedGenerator);
	void Cosmetic_OnTriggerCompromiseVFX(const class AGenerator* CompromisedGenerator);
	void OnRep_CompromisedGenerator();

	float GetHastePercent() const;
	float GetStatusEffectDurationAtLevel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K32P03">();
	}
	static class UK32P03* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK32P03>();
	}
};
static_assert(alignof(UK32P03) == 0x000008, "Wrong alignment on UK32P03");
static_assert(sizeof(UK32P03) == 0x000458, "Wrong size on UK32P03");
static_assert(offsetof(UK32P03, _hasteStatusEffectPercent) == 0x000420, "Member 'UK32P03::_hasteStatusEffectPercent' has a wrong offset!");
static_assert(offsetof(UK32P03, _hasteStatusEffectClass) == 0x000428, "Member 'UK32P03::_hasteStatusEffectClass' has a wrong offset!");
static_assert(offsetof(UK32P03, _undetectableStatusEffectClass) == 0x000430, "Member 'UK32P03::_undetectableStatusEffectClass' has a wrong offset!");
static_assert(offsetof(UK32P03, _statusEffectDuration) == 0x000438, "Member 'UK32P03::_statusEffectDuration' has a wrong offset!");
static_assert(offsetof(UK32P03, _compromisedGenerator) == 0x000448, "Member 'UK32P03::_compromisedGenerator' has a wrong offset!");
static_assert(offsetof(UK32P03, _lastCompromisedGenerator) == 0x000450, "Member 'UK32P03::_lastCompromisedGenerator' has a wrong offset!");

// Class TheK32.K32PodDangerPredictionComponent
// 0x0030 (0x0140 - 0x0110)
class UK32PodDangerPredictionComponent final : public UDBDDangerPredictionComponent
{
public:
	float                                         _podMaxRange;                                      // 0x0110(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _podRangeMargin;                                   // 0x0114(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _dangerAreaCostMultiplierForIdlePod;               // 0x0118(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _dangerAreaCostMultiplierForActivePod;             // 0x011C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _activePodWeightPenalty;                           // 0x0120(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _idlePodWeightPenalty;                             // 0x0124(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AK32KillerPod*                          _pod;                                              // 0x0128(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class AActor*>                         _allInGamePlayers;                                 // 0x0130(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K32PodDangerPredictionComponent">();
	}
	static class UK32PodDangerPredictionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK32PodDangerPredictionComponent>();
	}
};
static_assert(alignof(UK32PodDangerPredictionComponent) == 0x000008, "Wrong alignment on UK32PodDangerPredictionComponent");
static_assert(sizeof(UK32PodDangerPredictionComponent) == 0x000140, "Wrong size on UK32PodDangerPredictionComponent");
static_assert(offsetof(UK32PodDangerPredictionComponent, _podMaxRange) == 0x000110, "Member 'UK32PodDangerPredictionComponent::_podMaxRange' has a wrong offset!");
static_assert(offsetof(UK32PodDangerPredictionComponent, _podRangeMargin) == 0x000114, "Member 'UK32PodDangerPredictionComponent::_podRangeMargin' has a wrong offset!");
static_assert(offsetof(UK32PodDangerPredictionComponent, _dangerAreaCostMultiplierForIdlePod) == 0x000118, "Member 'UK32PodDangerPredictionComponent::_dangerAreaCostMultiplierForIdlePod' has a wrong offset!");
static_assert(offsetof(UK32PodDangerPredictionComponent, _dangerAreaCostMultiplierForActivePod) == 0x00011C, "Member 'UK32PodDangerPredictionComponent::_dangerAreaCostMultiplierForActivePod' has a wrong offset!");
static_assert(offsetof(UK32PodDangerPredictionComponent, _activePodWeightPenalty) == 0x000120, "Member 'UK32PodDangerPredictionComponent::_activePodWeightPenalty' has a wrong offset!");
static_assert(offsetof(UK32PodDangerPredictionComponent, _idlePodWeightPenalty) == 0x000124, "Member 'UK32PodDangerPredictionComponent::_idlePodWeightPenalty' has a wrong offset!");
static_assert(offsetof(UK32PodDangerPredictionComponent, _pod) == 0x000128, "Member 'UK32PodDangerPredictionComponent::_pod' has a wrong offset!");
static_assert(offsetof(UK32PodDangerPredictionComponent, _allInGamePlayers) == 0x000130, "Member 'UK32PodDangerPredictionComponent::_allInGamePlayers' has a wrong offset!");

// Class TheK32.K32PodToKillerVisionInteractionDefinition
// 0x0030 (0x0950 - 0x0920)
class UK32PodToKillerVisionInteractionDefinition : public UBasicChargeableInteraction
{
public:
	uint8                                         Pad_920[0x30];                                     // 0x0920(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K32PodToKillerVisionInteractionDefinition">();
	}
	static class UK32PodToKillerVisionInteractionDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK32PodToKillerVisionInteractionDefinition>();
	}
};
static_assert(alignof(UK32PodToKillerVisionInteractionDefinition) == 0x000010, "Wrong alignment on UK32PodToKillerVisionInteractionDefinition");
static_assert(sizeof(UK32PodToKillerVisionInteractionDefinition) == 0x000950, "Wrong size on UK32PodToKillerVisionInteractionDefinition");

// Class TheK32.K32PodToKillerVisionAndDestroyPodInteractionDefinition
// 0x0040 (0x0990 - 0x0950)
class UK32PodToKillerVisionAndDestroyPodInteractionDefinition final : public UK32PodToKillerVisionInteractionDefinition
{
public:
	uint8                                         Pad_950[0x10];                                     // 0x0950(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _initialChargeRatio;                               // 0x0960(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class AK32KillerPod*                          _podToBeDestroyed;                                 // 0x0988(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K32PodToKillerVisionAndDestroyPodInteractionDefinition">();
	}
	static class UK32PodToKillerVisionAndDestroyPodInteractionDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK32PodToKillerVisionAndDestroyPodInteractionDefinition>();
	}
};
static_assert(alignof(UK32PodToKillerVisionAndDestroyPodInteractionDefinition) == 0x000010, "Wrong alignment on UK32PodToKillerVisionAndDestroyPodInteractionDefinition");
static_assert(sizeof(UK32PodToKillerVisionAndDestroyPodInteractionDefinition) == 0x000990, "Wrong size on UK32PodToKillerVisionAndDestroyPodInteractionDefinition");
static_assert(offsetof(UK32PodToKillerVisionAndDestroyPodInteractionDefinition, _initialChargeRatio) == 0x000960, "Member 'UK32PodToKillerVisionAndDestroyPodInteractionDefinition::_initialChargeRatio' has a wrong offset!");
static_assert(offsetof(UK32PodToKillerVisionAndDestroyPodInteractionDefinition, _podToBeDestroyed) == 0x000988, "Member 'UK32PodToKillerVisionAndDestroyPodInteractionDefinition::_podToBeDestroyed' has a wrong offset!");

// Class TheK32.K32PodToKillerVisionWakeupInteractionDefinition
// 0x0050 (0x07D0 - 0x0780)
class UK32PodToKillerVisionWakeupInteractionDefinition final : public UInteractionDefinition
{
public:
	struct FDBDTunableRowHandle                   _regularWakeupTime;                                // 0x0778(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _antiCampWakeupMultiplier;                         // 0x07A0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7C8[0x8];                                      // 0x07C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K32PodToKillerVisionWakeupInteractionDefinition">();
	}
	static class UK32PodToKillerVisionWakeupInteractionDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK32PodToKillerVisionWakeupInteractionDefinition>();
	}
};
static_assert(alignof(UK32PodToKillerVisionWakeupInteractionDefinition) == 0x000010, "Wrong alignment on UK32PodToKillerVisionWakeupInteractionDefinition");
static_assert(sizeof(UK32PodToKillerVisionWakeupInteractionDefinition) == 0x0007D0, "Wrong size on UK32PodToKillerVisionWakeupInteractionDefinition");
static_assert(offsetof(UK32PodToKillerVisionWakeupInteractionDefinition, _regularWakeupTime) == 0x000778, "Member 'UK32PodToKillerVisionWakeupInteractionDefinition::_regularWakeupTime' has a wrong offset!");
static_assert(offsetof(UK32PodToKillerVisionWakeupInteractionDefinition, _antiCampWakeupMultiplier) == 0x0007A0, "Member 'UK32PodToKillerVisionWakeupInteractionDefinition::_antiCampWakeupMultiplier' has a wrong offset!");

// Class TheK32.K32PodToPodVisionInteractionDefinition
// 0x0040 (0x0960 - 0x0920)
class UK32PodToPodVisionInteractionDefinition final : public UBasicChargeableInteraction
{
public:
	EPodVisionTransferDestination                 _podVisionTransferDestination;                     // 0x0920(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_921[0x3F];                                     // 0x0921(0x003F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K32PodToPodVisionInteractionDefinition">();
	}
	static class UK32PodToPodVisionInteractionDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK32PodToPodVisionInteractionDefinition>();
	}
};
static_assert(alignof(UK32PodToPodVisionInteractionDefinition) == 0x000010, "Wrong alignment on UK32PodToPodVisionInteractionDefinition");
static_assert(sizeof(UK32PodToPodVisionInteractionDefinition) == 0x000960, "Wrong size on UK32PodToPodVisionInteractionDefinition");
static_assert(offsetof(UK32PodToPodVisionInteractionDefinition, _podVisionTransferDestination) == 0x000920, "Member 'UK32PodToPodVisionInteractionDefinition::_podVisionTransferDestination' has a wrong offset!");

// Class TheK32.K32Power
// 0x0168 (0x06B8 - 0x0550)
class AK32Power final : public ACollectable
{
public:
	class UInteractor*                            _interactor;                                       // 0x0550(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxPlayerOverlapComponent*             _interactionVolume;                                // 0x0558(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UK32PowerChargePresentationItemProgressComponent* _powerChargePresentationItemProgressComponent;     // 0x0560(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UK32PowerChargePresentationPowerFadeComponent* _powerChargePresentationPowerFadeComponent;        // 0x0568(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UK32AntiCampZoneIdentifierComponent*    _antiCampZoneIdentifierComponent;                  // 0x0570(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AK32KillerPodVisionController> _killerPodVisionControllerClass;                   // 0x0578(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AK32KillerPodTargetIndicator> _killerPodTargetIndicatorClass;                    // 0x0580(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AK32KillerPodSpawningIndicator> _killerPodSpawningIndicatorClass;                  // 0x0588(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UK32SurvivorLockedOnTimeComponent> _survivorLockedOnTimeComponentClass;               // 0x0590(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UStatusEffect>              _blindnessProtectionStatusEffect;                  // 0x0598(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UStatusEffect>              _undetectableWhileInPodsStatusEffect;              // 0x05A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UStatusEffect>              _overclockStatusEffectClass;                       // 0x05A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UStatusEffect>              _survivorChargingEmpHinderedStatusEffectClass;     // 0x05B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _recentlyTeleportedTime;                           // 0x05B8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class AK32KillerPodVisionController*          _killerPodVisionController;                        // 0x05E0(0x0008)(Net, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AK32KillerPodTargetIndicator*           _killerPodTargetIndicator;                         // 0x05E8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AK32KillerPodSpawningIndicator*         _killerPodSpawningIndicator;                       // 0x05F0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UChargeableComponent*                   _killerProjectileSpawnChargeableComponent;         // 0x05F8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAuthoritativeActorPoolComponent*       _empPool;                                          // 0x0600(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoClear, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UK32EmpScoreComponent*                  _empScoreComponent;                                // 0x0608(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoClear, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_610[0x58];                                     // 0x0610(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	class ACamperPlayer*                          _recentlyTeleportedToSurvivor;                     // 0x0668(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _maxTrackedTimeSinceTeleportToSurvivor;            // 0x0670(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FGameplayTagContainer                  _survivorTagsPreventingPower;                      // 0x0698(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K32Power">();
	}
	static class AK32Power* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK32Power>();
	}
};
static_assert(alignof(AK32Power) == 0x000008, "Wrong alignment on AK32Power");
static_assert(sizeof(AK32Power) == 0x0006B8, "Wrong size on AK32Power");
static_assert(offsetof(AK32Power, _interactor) == 0x000550, "Member 'AK32Power::_interactor' has a wrong offset!");
static_assert(offsetof(AK32Power, _interactionVolume) == 0x000558, "Member 'AK32Power::_interactionVolume' has a wrong offset!");
static_assert(offsetof(AK32Power, _powerChargePresentationItemProgressComponent) == 0x000560, "Member 'AK32Power::_powerChargePresentationItemProgressComponent' has a wrong offset!");
static_assert(offsetof(AK32Power, _powerChargePresentationPowerFadeComponent) == 0x000568, "Member 'AK32Power::_powerChargePresentationPowerFadeComponent' has a wrong offset!");
static_assert(offsetof(AK32Power, _antiCampZoneIdentifierComponent) == 0x000570, "Member 'AK32Power::_antiCampZoneIdentifierComponent' has a wrong offset!");
static_assert(offsetof(AK32Power, _killerPodVisionControllerClass) == 0x000578, "Member 'AK32Power::_killerPodVisionControllerClass' has a wrong offset!");
static_assert(offsetof(AK32Power, _killerPodTargetIndicatorClass) == 0x000580, "Member 'AK32Power::_killerPodTargetIndicatorClass' has a wrong offset!");
static_assert(offsetof(AK32Power, _killerPodSpawningIndicatorClass) == 0x000588, "Member 'AK32Power::_killerPodSpawningIndicatorClass' has a wrong offset!");
static_assert(offsetof(AK32Power, _survivorLockedOnTimeComponentClass) == 0x000590, "Member 'AK32Power::_survivorLockedOnTimeComponentClass' has a wrong offset!");
static_assert(offsetof(AK32Power, _blindnessProtectionStatusEffect) == 0x000598, "Member 'AK32Power::_blindnessProtectionStatusEffect' has a wrong offset!");
static_assert(offsetof(AK32Power, _undetectableWhileInPodsStatusEffect) == 0x0005A0, "Member 'AK32Power::_undetectableWhileInPodsStatusEffect' has a wrong offset!");
static_assert(offsetof(AK32Power, _overclockStatusEffectClass) == 0x0005A8, "Member 'AK32Power::_overclockStatusEffectClass' has a wrong offset!");
static_assert(offsetof(AK32Power, _survivorChargingEmpHinderedStatusEffectClass) == 0x0005B0, "Member 'AK32Power::_survivorChargingEmpHinderedStatusEffectClass' has a wrong offset!");
static_assert(offsetof(AK32Power, _recentlyTeleportedTime) == 0x0005B8, "Member 'AK32Power::_recentlyTeleportedTime' has a wrong offset!");
static_assert(offsetof(AK32Power, _killerPodVisionController) == 0x0005E0, "Member 'AK32Power::_killerPodVisionController' has a wrong offset!");
static_assert(offsetof(AK32Power, _killerPodTargetIndicator) == 0x0005E8, "Member 'AK32Power::_killerPodTargetIndicator' has a wrong offset!");
static_assert(offsetof(AK32Power, _killerPodSpawningIndicator) == 0x0005F0, "Member 'AK32Power::_killerPodSpawningIndicator' has a wrong offset!");
static_assert(offsetof(AK32Power, _killerProjectileSpawnChargeableComponent) == 0x0005F8, "Member 'AK32Power::_killerProjectileSpawnChargeableComponent' has a wrong offset!");
static_assert(offsetof(AK32Power, _empPool) == 0x000600, "Member 'AK32Power::_empPool' has a wrong offset!");
static_assert(offsetof(AK32Power, _empScoreComponent) == 0x000608, "Member 'AK32Power::_empScoreComponent' has a wrong offset!");
static_assert(offsetof(AK32Power, _recentlyTeleportedToSurvivor) == 0x000668, "Member 'AK32Power::_recentlyTeleportedToSurvivor' has a wrong offset!");
static_assert(offsetof(AK32Power, _maxTrackedTimeSinceTeleportToSurvivor) == 0x000670, "Member 'AK32Power::_maxTrackedTimeSinceTeleportToSurvivor' has a wrong offset!");
static_assert(offsetof(AK32Power, _survivorTagsPreventingPower) == 0x000698, "Member 'AK32Power::_survivorTagsPreventingPower' has a wrong offset!");

// Class TheK32.K32PowerChargePresentationItemProgressComponent
// 0x0028 (0x00D8 - 0x00B0)
class UK32PowerChargePresentationItemProgressComponent final : public UPresentationItemProgressComponent
{
public:
	uint8                                         Pad_B0[0x28];                                      // 0x00B0(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K32PowerChargePresentationItemProgressComponent">();
	}
	static class UK32PowerChargePresentationItemProgressComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK32PowerChargePresentationItemProgressComponent>();
	}
};
static_assert(alignof(UK32PowerChargePresentationItemProgressComponent) == 0x000008, "Wrong alignment on UK32PowerChargePresentationItemProgressComponent");
static_assert(sizeof(UK32PowerChargePresentationItemProgressComponent) == 0x0000D8, "Wrong size on UK32PowerChargePresentationItemProgressComponent");

// Class TheK32.K32PowerChargePresentationPowerFadeComponent
// 0x0018 (0x00C0 - 0x00A8)
class UK32PowerChargePresentationPowerFadeComponent final : public UPresentationPowerFadeComponent
{
public:
	uint8                                         Pad_A8[0x18];                                      // 0x00A8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K32PowerChargePresentationPowerFadeComponent">();
	}
	static class UK32PowerChargePresentationPowerFadeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK32PowerChargePresentationPowerFadeComponent>();
	}
};
static_assert(alignof(UK32PowerChargePresentationPowerFadeComponent) == 0x000008, "Wrong alignment on UK32PowerChargePresentationPowerFadeComponent");
static_assert(sizeof(UK32PowerChargePresentationPowerFadeComponent) == 0x0000C0, "Wrong size on UK32PowerChargePresentationPowerFadeComponent");

// Class TheK32.K32PowerStatusHandlerComponent
// 0x02E8 (0x0390 - 0x00A8)
class UK32PowerStatusHandlerComponent final : public UActorComponent
{
public:
	float                                         _lineOfSightTraceSphereSize;                       // 0x00A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTunableStat                           _crossAssimilationRange;                           // 0x00B0(0x0080)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FTunableStat                           _crossAssimilationDelay;                           // 0x0130(0x0080)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _affectedByPowerCrossAssimilationBuffer;           // 0x01B0(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FName                                   _survivorProjectileTargetSocketName;               // 0x01D8(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _traceProfile;                                     // 0x01E4(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UK32KillerInstinctStatusEffect> _crossAssimilationKillerInstinctStatusEffect;      // 0x01F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _crossAssimilationKillerInstinctDuration;          // 0x01F8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         _exitedPassageTeleportLocationOffsetXYMultiplier;  // 0x0220(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _exitedPassageTeleportLocationOffsetZ;             // 0x0224(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _maxOldSurvivorLocations;                          // 0x0228(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _survivorLocationOverlapAvoidanceDistance;         // 0x022C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _recentLocationDistanceDelta;                      // 0x0230(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _assimilationCooldownTime;                         // 0x0258(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TArray<struct FK32SurvivorStatus>             _survivorStatusList;                               // 0x0280(0x0010)(Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPrivate)
	uint8                                         Pad_290[0x8];                                      // 0x0290(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class ACamperPlayer*, struct FFastTimer> _assimilationCooldownTimers;                       // 0x0298(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TArray<struct FGameplayTag>                   _survivorTagsToPreventPositionStorage;             // 0x02E8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TMap<class ADBDPlayer*, class APassage*>      _survivorsJustExitedPassage;                       // 0x02F8(0x0050)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_348[0x48];                                     // 0x0348(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnSurvivorAdded(class ACamperPlayer* Survivor);
	void BP_SurvivorScream(class ACamperPlayer* Survivor);
	void Cosmetic_OnAssimilationChanged(const class ACamperPlayer* Survivor, const bool IsAssimilated);
	void Cosmetic_OnAssimilationSpreadingToSurvivor(const class ACamperPlayer* OriginatingSurvivor, const class ACamperPlayer* TargetSurvivor);
	void Cosmetic_OnInRangeOfAssimilationSpreadingSurvivor(const class ACamperPlayer* OriginatingSurvivor, const class ACamperPlayer* TargetSurvivor);
	void Multicast_OnAssimilationSpreadingToSurvivor(const class ACamperPlayer* OriginatingSurvivor, const class ACamperPlayer* TargetSurvivor);
	void Multicast_OnInRangeOfAssimilationSpreadingSurvivor(const class ACamperPlayer* OriginatingSurvivor, const class ACamperPlayer* TargetSurvivor);
	void Multicast_SurvivorScream(class ACamperPlayer* Survivor);
	void OnIntroCompleted();
	void OnRep_SurvivorStatusList(const TArray<struct FK32SurvivorStatus>& OldSurvivorStatus);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K32PowerStatusHandlerComponent">();
	}
	static class UK32PowerStatusHandlerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK32PowerStatusHandlerComponent>();
	}
};
static_assert(alignof(UK32PowerStatusHandlerComponent) == 0x000008, "Wrong alignment on UK32PowerStatusHandlerComponent");
static_assert(sizeof(UK32PowerStatusHandlerComponent) == 0x000390, "Wrong size on UK32PowerStatusHandlerComponent");
static_assert(offsetof(UK32PowerStatusHandlerComponent, _lineOfSightTraceSphereSize) == 0x0000A8, "Member 'UK32PowerStatusHandlerComponent::_lineOfSightTraceSphereSize' has a wrong offset!");
static_assert(offsetof(UK32PowerStatusHandlerComponent, _crossAssimilationRange) == 0x0000B0, "Member 'UK32PowerStatusHandlerComponent::_crossAssimilationRange' has a wrong offset!");
static_assert(offsetof(UK32PowerStatusHandlerComponent, _crossAssimilationDelay) == 0x000130, "Member 'UK32PowerStatusHandlerComponent::_crossAssimilationDelay' has a wrong offset!");
static_assert(offsetof(UK32PowerStatusHandlerComponent, _affectedByPowerCrossAssimilationBuffer) == 0x0001B0, "Member 'UK32PowerStatusHandlerComponent::_affectedByPowerCrossAssimilationBuffer' has a wrong offset!");
static_assert(offsetof(UK32PowerStatusHandlerComponent, _survivorProjectileTargetSocketName) == 0x0001D8, "Member 'UK32PowerStatusHandlerComponent::_survivorProjectileTargetSocketName' has a wrong offset!");
static_assert(offsetof(UK32PowerStatusHandlerComponent, _traceProfile) == 0x0001E4, "Member 'UK32PowerStatusHandlerComponent::_traceProfile' has a wrong offset!");
static_assert(offsetof(UK32PowerStatusHandlerComponent, _crossAssimilationKillerInstinctStatusEffect) == 0x0001F0, "Member 'UK32PowerStatusHandlerComponent::_crossAssimilationKillerInstinctStatusEffect' has a wrong offset!");
static_assert(offsetof(UK32PowerStatusHandlerComponent, _crossAssimilationKillerInstinctDuration) == 0x0001F8, "Member 'UK32PowerStatusHandlerComponent::_crossAssimilationKillerInstinctDuration' has a wrong offset!");
static_assert(offsetof(UK32PowerStatusHandlerComponent, _exitedPassageTeleportLocationOffsetXYMultiplier) == 0x000220, "Member 'UK32PowerStatusHandlerComponent::_exitedPassageTeleportLocationOffsetXYMultiplier' has a wrong offset!");
static_assert(offsetof(UK32PowerStatusHandlerComponent, _exitedPassageTeleportLocationOffsetZ) == 0x000224, "Member 'UK32PowerStatusHandlerComponent::_exitedPassageTeleportLocationOffsetZ' has a wrong offset!");
static_assert(offsetof(UK32PowerStatusHandlerComponent, _maxOldSurvivorLocations) == 0x000228, "Member 'UK32PowerStatusHandlerComponent::_maxOldSurvivorLocations' has a wrong offset!");
static_assert(offsetof(UK32PowerStatusHandlerComponent, _survivorLocationOverlapAvoidanceDistance) == 0x00022C, "Member 'UK32PowerStatusHandlerComponent::_survivorLocationOverlapAvoidanceDistance' has a wrong offset!");
static_assert(offsetof(UK32PowerStatusHandlerComponent, _recentLocationDistanceDelta) == 0x000230, "Member 'UK32PowerStatusHandlerComponent::_recentLocationDistanceDelta' has a wrong offset!");
static_assert(offsetof(UK32PowerStatusHandlerComponent, _assimilationCooldownTime) == 0x000258, "Member 'UK32PowerStatusHandlerComponent::_assimilationCooldownTime' has a wrong offset!");
static_assert(offsetof(UK32PowerStatusHandlerComponent, _survivorStatusList) == 0x000280, "Member 'UK32PowerStatusHandlerComponent::_survivorStatusList' has a wrong offset!");
static_assert(offsetof(UK32PowerStatusHandlerComponent, _assimilationCooldownTimers) == 0x000298, "Member 'UK32PowerStatusHandlerComponent::_assimilationCooldownTimers' has a wrong offset!");
static_assert(offsetof(UK32PowerStatusHandlerComponent, _survivorTagsToPreventPositionStorage) == 0x0002E8, "Member 'UK32PowerStatusHandlerComponent::_survivorTagsToPreventPositionStorage' has a wrong offset!");
static_assert(offsetof(UK32PowerStatusHandlerComponent, _survivorsJustExitedPassage) == 0x0002F8, "Member 'UK32PowerStatusHandlerComponent::_survivorsJustExitedPassage' has a wrong offset!");

// Class TheK32.K32SurvivorAnimInstance
// 0x0020 (0x0600 - 0x05E0)
class UK32SurvivorAnimInstance final : public UBaseSurvivorAnimInstance
{
public:
	bool                                          _isAssimilated;                                    // 0x05E0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isOwnerBeingCarried;                              // 0x05E1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isSpeedingUpEmpGeneration;                        // 0x05E2(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isRetrievingItem;                                 // 0x05E3(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isUsingEmp;                                       // 0x05E4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _hasBeenAssimilatedByAnotherSurvivor;              // 0x05E5(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _hasBeenAssimilatedByKiller;                       // 0x05E6(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _hasBeenCleansedFromAssimilation;                  // 0x05E7(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5E8[0x18];                                     // 0x05E8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ResetHasBeenAssimilatedByAnotherSurvivor();
	void ResetHasBeenAssimilatedByKiller();
	void ResetHasBeenCleansedFromAssimilation();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K32SurvivorAnimInstance">();
	}
	static class UK32SurvivorAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK32SurvivorAnimInstance>();
	}
};
static_assert(alignof(UK32SurvivorAnimInstance) == 0x000010, "Wrong alignment on UK32SurvivorAnimInstance");
static_assert(sizeof(UK32SurvivorAnimInstance) == 0x000600, "Wrong size on UK32SurvivorAnimInstance");
static_assert(offsetof(UK32SurvivorAnimInstance, _isAssimilated) == 0x0005E0, "Member 'UK32SurvivorAnimInstance::_isAssimilated' has a wrong offset!");
static_assert(offsetof(UK32SurvivorAnimInstance, _isOwnerBeingCarried) == 0x0005E1, "Member 'UK32SurvivorAnimInstance::_isOwnerBeingCarried' has a wrong offset!");
static_assert(offsetof(UK32SurvivorAnimInstance, _isSpeedingUpEmpGeneration) == 0x0005E2, "Member 'UK32SurvivorAnimInstance::_isSpeedingUpEmpGeneration' has a wrong offset!");
static_assert(offsetof(UK32SurvivorAnimInstance, _isRetrievingItem) == 0x0005E3, "Member 'UK32SurvivorAnimInstance::_isRetrievingItem' has a wrong offset!");
static_assert(offsetof(UK32SurvivorAnimInstance, _isUsingEmp) == 0x0005E4, "Member 'UK32SurvivorAnimInstance::_isUsingEmp' has a wrong offset!");
static_assert(offsetof(UK32SurvivorAnimInstance, _hasBeenAssimilatedByAnotherSurvivor) == 0x0005E5, "Member 'UK32SurvivorAnimInstance::_hasBeenAssimilatedByAnotherSurvivor' has a wrong offset!");
static_assert(offsetof(UK32SurvivorAnimInstance, _hasBeenAssimilatedByKiller) == 0x0005E6, "Member 'UK32SurvivorAnimInstance::_hasBeenAssimilatedByKiller' has a wrong offset!");
static_assert(offsetof(UK32SurvivorAnimInstance, _hasBeenCleansedFromAssimilation) == 0x0005E7, "Member 'UK32SurvivorAnimInstance::_hasBeenCleansedFromAssimilation' has a wrong offset!");

// Class TheK32.K32SurvivorCosmeticHelperActor
// 0x0040 (0x0348 - 0x0308)
class AK32SurvivorCosmeticHelperActor final : public ASurvivorCosmeticHelperActor
{
public:
	class FName                                   _noseJointName;                                    // 0x0308(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_314[0x34];                                     // 0x0314(0x0034)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_OnIsEffectiveEmpInRangeChanged(const bool IsEffectiveEmpInRange);
	void Cosmetic_OnKillerAimsPodAtSurvivor(const class ADBDPlayer* Killer);
	void Cosmetic_OnKillerLocksOnToSurvivor(const bool IsTargetAssimilated);
	void Cosmetic_OnKillerNoLongerAimsPodAtSurvivor();
	void Cosmetic_OnKillerNoLongerLocksOnToSurvivor();
	void Cosmetic_OnTeleportStart(const struct FVector& TeleportStartLocation, const struct FVector& TeleportEndLocation);
	struct FVector GetNoseLocation();
	void OnKillerAimsPodAtSurvivor(const struct FGameplayTag& GameEventType, const struct FGameEventData& GameEventData);
	void OnKillerLocksOnToSurvivor(const struct FGameplayTag& GameEventType, const struct FGameEventData& GameEventData);
	void OnKillerNoLongerAimsPodAtSurvivor(const struct FGameplayTag& GameEventType, const struct FGameEventData& GameEventData);
	void OnKillerNoLongerLocksOnToSurvivor(const struct FGameplayTag& GameEventType, const struct FGameEventData& GameEventData);
	void OnSurvivorDisguisedOrUndisguised(bool IsDisguised);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K32SurvivorCosmeticHelperActor">();
	}
	static class AK32SurvivorCosmeticHelperActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK32SurvivorCosmeticHelperActor>();
	}
};
static_assert(alignof(AK32SurvivorCosmeticHelperActor) == 0x000008, "Wrong alignment on AK32SurvivorCosmeticHelperActor");
static_assert(sizeof(AK32SurvivorCosmeticHelperActor) == 0x000348, "Wrong size on AK32SurvivorCosmeticHelperActor");
static_assert(offsetof(AK32SurvivorCosmeticHelperActor, _noseJointName) == 0x000308, "Member 'AK32SurvivorCosmeticHelperActor::_noseJointName' has a wrong offset!");

// Class TheK32.K32SurvivorLockedOnTimeComponent
// 0x0140 (0x01E8 - 0x00A8)
class UK32SurvivorLockedOnTimeComponent final : public UActorComponent
{
public:
	struct FDBDTunableRowHandle                   _teleportLockOnTime;                               // 0x00A8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _assimilationLockOnTime;                           // 0x00D0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _antiCampLockOnRateMultiplier;                     // 0x00F8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _retainProgressTime;                               // 0x0120(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _totalTimeToRemoveRequiredLockOn;                  // 0x0148(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class ASlasherPlayer*                         _killer;                                           // 0x0170(0x0008)(Net, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AK32Power*                              _power;                                            // 0x0178(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_180[0x68];                                     // 0x0180(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K32SurvivorLockedOnTimeComponent">();
	}
	static class UK32SurvivorLockedOnTimeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK32SurvivorLockedOnTimeComponent>();
	}
};
static_assert(alignof(UK32SurvivorLockedOnTimeComponent) == 0x000008, "Wrong alignment on UK32SurvivorLockedOnTimeComponent");
static_assert(sizeof(UK32SurvivorLockedOnTimeComponent) == 0x0001E8, "Wrong size on UK32SurvivorLockedOnTimeComponent");
static_assert(offsetof(UK32SurvivorLockedOnTimeComponent, _teleportLockOnTime) == 0x0000A8, "Member 'UK32SurvivorLockedOnTimeComponent::_teleportLockOnTime' has a wrong offset!");
static_assert(offsetof(UK32SurvivorLockedOnTimeComponent, _assimilationLockOnTime) == 0x0000D0, "Member 'UK32SurvivorLockedOnTimeComponent::_assimilationLockOnTime' has a wrong offset!");
static_assert(offsetof(UK32SurvivorLockedOnTimeComponent, _antiCampLockOnRateMultiplier) == 0x0000F8, "Member 'UK32SurvivorLockedOnTimeComponent::_antiCampLockOnRateMultiplier' has a wrong offset!");
static_assert(offsetof(UK32SurvivorLockedOnTimeComponent, _retainProgressTime) == 0x000120, "Member 'UK32SurvivorLockedOnTimeComponent::_retainProgressTime' has a wrong offset!");
static_assert(offsetof(UK32SurvivorLockedOnTimeComponent, _totalTimeToRemoveRequiredLockOn) == 0x000148, "Member 'UK32SurvivorLockedOnTimeComponent::_totalTimeToRemoveRequiredLockOn' has a wrong offset!");
static_assert(offsetof(UK32SurvivorLockedOnTimeComponent, _killer) == 0x000170, "Member 'UK32SurvivorLockedOnTimeComponent::_killer' has a wrong offset!");
static_assert(offsetof(UK32SurvivorLockedOnTimeComponent, _power) == 0x000178, "Member 'UK32SurvivorLockedOnTimeComponent::_power' has a wrong offset!");

// Class TheK32.K32SurvivorStatusComponent
// 0x0008 (0x00B0 - 0x00A8)
class UK32SurvivorStatusComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K32SurvivorStatusComponent">();
	}
	static class UK32SurvivorStatusComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK32SurvivorStatusComponent>();
	}
};
static_assert(alignof(UK32SurvivorStatusComponent) == 0x000008, "Wrong alignment on UK32SurvivorStatusComponent");
static_assert(sizeof(UK32SurvivorStatusComponent) == 0x0000B0, "Wrong size on UK32SurvivorStatusComponent");

// Class TheK32.K32Utilities
// 0x0000 (0x0030 - 0x0030)
class UK32Utilities final : public UBlueprintFunctionLibrary
{
public:
	static bool DoesEmpReach(const struct FVector& LaunchPosition, const struct FVector& TargetLocation, float RangeSquared);
	static class AK32Power* GetK32Power(const class UObject* WorldContextObject);
	static bool IsPodOutlineAndIndicatorVisible(const class ASlasherPlayer* Killer);
	static bool IsSurvivorAbleToBeAffectedByPower(const class ACamperPlayer* Survivor, const class ASlasherPlayer* Killer);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K32Utilities">();
	}
	static class UK32Utilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK32Utilities>();
	}
};
static_assert(alignof(UK32Utilities) == 0x000008, "Wrong alignment on UK32Utilities");
static_assert(sizeof(UK32Utilities) == 0x000030, "Wrong size on UK32Utilities");

}

