#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: TheSpirit

#include "Basic.hpp"

#include "TheSpirit_classes.hpp"
#include "TheSpirit_parameters.hpp"


namespace SDK
{

// Function TheSpirit.OwningPlayerInSpiritHuskRange.OnKillerSet
// (Final, Native, Public)
// Parameters:
// class ASlasherPlayer*                   Killer                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOwningPlayerInSpiritHuskRange::OnKillerSet(class ASlasherPlayer* Killer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OwningPlayerInSpiritHuskRange", "OnKillerSet");

	Params::OwningPlayerInSpiritHuskRange_OnKillerSet Parms{};

	Parms.Killer = Killer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TheSpirit.ActivePhaseWalkInteraction.Cosmetic_ResetChargeVFX
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActivePhaseWalkInteraction::Cosmetic_ResetChargeVFX(class ADBDPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActivePhaseWalkInteraction", "Cosmetic_ResetChargeVFX");

	Params::ActivePhaseWalkInteraction_Cosmetic_ResetChargeVFX Parms{};

	Parms.Player = Player;

	UObject::ProcessEvent(Func, &Parms);
}


// Function TheSpirit.ActivePhaseWalkInteraction.OnPlayerLocallyObservedChanged
// (Final, Native, Private)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActivePhaseWalkInteraction::OnPlayerLocallyObservedChanged(class ADBDPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActivePhaseWalkInteraction", "OnPlayerLocallyObservedChanged");

	Params::ActivePhaseWalkInteraction_OnPlayerLocallyObservedChanged Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TheSpirit.ActivePhaseWalkInteraction.OnPowerCollected
// (Final, Native, Private)
// Parameters:
// class ADBDPlayer*                       Collector                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActivePhaseWalkInteraction::OnPowerCollected(class ADBDPlayer* Collector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActivePhaseWalkInteraction", "OnPowerCollected");

	Params::ActivePhaseWalkInteraction_OnPowerCollected Parms{};

	Parms.Collector = Collector;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TheSpirit.ActivePhaseWalkInteraction.GetChargeTime
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UActivePhaseWalkInteraction::GetChargeTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActivePhaseWalkInteraction", "GetChargeTime");

	Params::ActivePhaseWalkInteraction_GetChargeTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TheSpirit.Rancor.SpawnBubbleAtSurvivorsLocation
// (Event, Protected, BlueprintEvent)

void URancor::SpawnBubbleAtSurvivorsLocation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Rancor", "SpawnBubbleAtSurvivorsLocation");

	UObject::ProcessEvent(Func, nullptr);
}


// Function TheSpirit.Rancor.GetKillerRevealToObsessionDurationAtLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URancor::GetKillerRevealToObsessionDurationAtLevel() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Rancor", "GetKillerRevealToObsessionDurationAtLevel");

	Params::Rancor_GetKillerRevealToObsessionDurationAtLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TheSpirit.Rancor.GetSurvivorRevealDuration
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URancor::GetSurvivorRevealDuration() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Rancor", "GetSurvivorRevealDuration");

	Params::Rancor_GetSurvivorRevealDuration Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TheSpirit.PhaseWalkingComponent.Authority_SetIsInPostActivePhaseWalk
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPhaseWalkingComponent::Authority_SetIsInPostActivePhaseWalk(bool Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PhaseWalkingComponent", "Authority_SetIsInPostActivePhaseWalk");

	Params::PhaseWalkingComponent_Authority_SetIsInPostActivePhaseWalk Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TheSpirit.PhaseWalkingComponent.DBD_RefillActivePhaseWalkCharges
// (Final, Exec, Native, Private)

void UPhaseWalkingComponent::DBD_RefillActivePhaseWalkCharges()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PhaseWalkingComponent", "DBD_RefillActivePhaseWalkCharges");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TheSpirit.PhaseWalkingComponent.Local_EndPhaseWalks
// (Final, Native, Public, BlueprintCallable)

void UPhaseWalkingComponent::Local_EndPhaseWalks()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PhaseWalkingComponent", "Local_EndPhaseWalks");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TheSpirit.PhaseWalkingComponent.Local_PhaseWalk
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FPhaseWalkInfo                   PhaseWalkInfo                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UPhaseWalkingComponent::Local_PhaseWalk(const struct FPhaseWalkInfo& PhaseWalkInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PhaseWalkingComponent", "Local_PhaseWalk");

	Params::PhaseWalkingComponent_Local_PhaseWalk Parms{};

	Parms.PhaseWalkInfo = std::move(PhaseWalkInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TheSpirit.PhaseWalkingComponent.MakePassivePhaseWalkHusksVisible
// (Event, Protected, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FTransform                       HuskTransform                                          (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OpacityValue                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SpeedValue                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPhaseWalkingComponent::MakePassivePhaseWalkHusksVisible(const struct FTransform& HuskTransform, float OpacityValue, float SpeedValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PhaseWalkingComponent", "MakePassivePhaseWalkHusksVisible");

	Params::PhaseWalkingComponent_MakePassivePhaseWalkHusksVisible Parms{};

	Parms.HuskTransform = std::move(HuskTransform);
	Parms.OpacityValue = OpacityValue;
	Parms.SpeedValue = SpeedValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function TheSpirit.PhaseWalkingComponent.ModifyActivePhaseWalkCharges
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Delta                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPhaseWalkingComponent::ModifyActivePhaseWalkCharges(float Delta)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PhaseWalkingComponent", "ModifyActivePhaseWalkCharges");

	Params::PhaseWalkingComponent_ModifyActivePhaseWalkCharges Parms{};

	Parms.Delta = Delta;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TheSpirit.PhaseWalkingComponent.Multicast_Broadcast_PhaseWalk
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// struct FPhaseWalkInfo                   PhaseWalkInfo                                          (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UPhaseWalkingComponent::Multicast_Broadcast_PhaseWalk(const struct FPhaseWalkInfo& PhaseWalkInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PhaseWalkingComponent", "Multicast_Broadcast_PhaseWalk");

	Params::PhaseWalkingComponent_Multicast_Broadcast_PhaseWalk Parms{};

	Parms.PhaseWalkInfo = std::move(PhaseWalkInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TheSpirit.PhaseWalkingComponent.OnInRangeToKillerChanged
// (Final, Native, Private)
// Parameters:
// bool                                    InRange                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ASlasherPlayer*                   Killer                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPhaseWalkingComponent::OnInRangeToKillerChanged(const bool InRange, class ASlasherPlayer* Killer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PhaseWalkingComponent", "OnInRangeToKillerChanged");

	Params::PhaseWalkingComponent_OnInRangeToKillerChanged Parms{};

	Parms.InRange = InRange;
	Parms.Killer = Killer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TheSpirit.PhaseWalkingComponent.OnLevelReadyToPlay
// (Final, Native, Private)

void UPhaseWalkingComponent::OnLevelReadyToPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PhaseWalkingComponent", "OnLevelReadyToPlay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TheSpirit.PhaseWalkingComponent.RefillActivePhaseWalkCharges
// (Final, Native, Protected, BlueprintCallable)

void UPhaseWalkingComponent::RefillActivePhaseWalkCharges()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PhaseWalkingComponent", "RefillActivePhaseWalkCharges");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TheSpirit.PhaseWalkingComponent.Server_Broadcast_PhaseWalk
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// struct FPhaseWalkInfo                   PhaseWalkInfo                                          (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UPhaseWalkingComponent::Server_Broadcast_PhaseWalk(const struct FPhaseWalkInfo& PhaseWalkInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PhaseWalkingComponent", "Server_Broadcast_PhaseWalk");

	Params::PhaseWalkingComponent_Server_Broadcast_PhaseWalk Parms{};

	Parms.PhaseWalkInfo = std::move(PhaseWalkInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TheSpirit.PhaseWalkingComponent.SpawnPassivePhaseWalkHusks
// (Event, Protected, BlueprintEvent)

void UPhaseWalkingComponent::SpawnPassivePhaseWalkHusks()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PhaseWalkingComponent", "SpawnPassivePhaseWalkHusks");

	UObject::ProcessEvent(Func, nullptr);
}


// Function TheSpirit.PhaseWalkingComponent.UpdateKillerVisibility
// (Final, Native, Public, BlueprintCallable)

void UPhaseWalkingComponent::UpdateKillerVisibility()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PhaseWalkingComponent", "UpdateKillerVisibility");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TheSpirit.PhaseWalkingComponent.UpdateSurvivorVisibility
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Visible                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPhaseWalkingComponent::UpdateSurvivorVisibility(bool Visible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PhaseWalkingComponent", "UpdateSurvivorVisibility");

	Params::PhaseWalkingComponent_UpdateSurvivorVisibility Parms{};

	Parms.Visible = Visible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TheSpirit.PhaseWalkingComponent.CanStartActivePhaseWalk
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPhaseWalkingComponent::CanStartActivePhaseWalk() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PhaseWalkingComponent", "CanStartActivePhaseWalk");

	Params::PhaseWalkingComponent_CanStartActivePhaseWalk Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TheSpirit.PhaseWalkingComponent.GetActivePhaseWalkChargePercentage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UPhaseWalkingComponent::GetActivePhaseWalkChargePercentage() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PhaseWalkingComponent", "GetActivePhaseWalkChargePercentage");

	Params::PhaseWalkingComponent_GetActivePhaseWalkChargePercentage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TheSpirit.PhaseWalkingComponent.GetActivePhaseWalkCharges
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UPhaseWalkingComponent::GetActivePhaseWalkCharges() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PhaseWalkingComponent", "GetActivePhaseWalkCharges");

	Params::PhaseWalkingComponent_GetActivePhaseWalkCharges Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TheSpirit.PhaseWalkingComponent.GetDecoySlasherComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDecoySlasherComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDecoySlasherComponent* UPhaseWalkingComponent::GetDecoySlasherComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PhaseWalkingComponent", "GetDecoySlasherComponent");

	Params::PhaseWalkingComponent_GetDecoySlasherComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TheSpirit.PhaseWalkingComponent.GetHusk
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UPhaseWalkingComponent::GetHusk() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PhaseWalkingComponent", "GetHusk");

	Params::PhaseWalkingComponent_GetHusk Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TheSpirit.PhaseWalkingComponent.GetPassivePhaseWalkTimer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FDBDTimer                  ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FDBDTimer UPhaseWalkingComponent::GetPassivePhaseWalkTimer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PhaseWalkingComponent", "GetPassivePhaseWalkTimer");

	Params::PhaseWalkingComponent_GetPassivePhaseWalkTimer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TheSpirit.PhaseWalkingComponent.GetSpiritPassivePhaseWalkHusksCountToSpawn
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UPhaseWalkingComponent::GetSpiritPassivePhaseWalkHusksCountToSpawn() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PhaseWalkingComponent", "GetSpiritPassivePhaseWalkHusksCountToSpawn");

	Params::PhaseWalkingComponent_GetSpiritPassivePhaseWalkHusksCountToSpawn Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TheSpirit.PhaseWalkingComponent.IsActivePhaseWalking
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPhaseWalkingComponent::IsActivePhaseWalking() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PhaseWalkingComponent", "IsActivePhaseWalking");

	Params::PhaseWalkingComponent_IsActivePhaseWalking Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TheSpirit.PhaseWalkingComponent.IsDecoyActive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPhaseWalkingComponent::IsDecoyActive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PhaseWalkingComponent", "IsDecoyActive");

	Params::PhaseWalkingComponent_IsDecoyActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TheSpirit.PhaseWalkingComponent.IsPassivePhaseWalking
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPhaseWalkingComponent::IsPassivePhaseWalking() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PhaseWalkingComponent", "IsPassivePhaseWalking");

	Params::PhaseWalkingComponent_IsPassivePhaseWalking Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TheSpirit.PhaseWalkingComponent.IsPhaseWalking
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPhaseWalkingComponent::IsPhaseWalking() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PhaseWalkingComponent", "IsPhaseWalking");

	Params::PhaseWalkingComponent_IsPhaseWalking Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TheSpirit.SpiritFury.GetPalletToBreakCountAtLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USpiritFury::GetPalletToBreakCountAtLevel() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpiritFury", "GetPalletToBreakCountAtLevel");

	Params::SpiritFury_GetPalletToBreakCountAtLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}

}

