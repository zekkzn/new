#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: TheK23

#include "Basic.hpp"

#include "DBDCompetence_classes.hpp"
#include "AnimationUtilities_structs.hpp"
#include "DataTableUtilities_structs.hpp"
#include "GameplayTags_structs.hpp"
#include "DeadByDaylight_classes.hpp"
#include "StatSystem_structs.hpp"
#include "Engine_classes.hpp"
#include "DBDCosmetic_classes.hpp"
#include "GameplayUtilities_classes.hpp"
#include "Competence_classes.hpp"
#include "DBDInteraction_classes.hpp"
#include "DBDAnimation_classes.hpp"
#include "CoreUObject_classes.hpp"


namespace SDK
{

// Class TheK23.ActivateSuperMode
// 0x0070 (0x07F0 - 0x0780)
class UActivateSuperMode final : public UInteractionDefinition
{
public:
	uint8                                         Pad_778[0x8];                                      // 0x0778(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAnimationMontageDescriptor            _activationMontage;                                // 0x0780(0x0020)(Edit, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _activationDuration;                               // 0x07A0(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _confirmationChargeDuration;                       // 0x07C8(0x0028)(Edit, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActivateSuperMode">();
	}
	static class UActivateSuperMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActivateSuperMode>();
	}
};
static_assert(alignof(UActivateSuperMode) == 0x000010, "Wrong alignment on UActivateSuperMode");
static_assert(sizeof(UActivateSuperMode) == 0x0007F0, "Wrong size on UActivateSuperMode");
static_assert(offsetof(UActivateSuperMode, _activationMontage) == 0x000780, "Member 'UActivateSuperMode::_activationMontage' has a wrong offset!");
static_assert(offsetof(UActivateSuperMode, _activationDuration) == 0x0007A0, "Member 'UActivateSuperMode::_activationDuration' has a wrong offset!");
static_assert(offsetof(UActivateSuperMode, _confirmationChargeDuration) == 0x0007C8, "Member 'UActivateSuperMode::_confirmationChargeDuration' has a wrong offset!");

// Class TheK23.FlurryComboScoreComponent
// 0x0168 (0x0210 - 0x00A8)
class UFlurryComboScoreComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x1C];                                      // 0x00A8(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _comboScore;                                       // 0x00C4(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _timeAddedByComboRank;                             // 0x00C8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _timeForCombo;                                     // 0x00F0(0x0080)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _consecutiveHitsRequiredScore;                     // 0x0170(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TArray<float>                                 _thresholds;                                       // 0x0198(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TArray<float>                                 _thresholdsScoreForAudio;                          // 0x01A8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TArray<struct FGameplayTag>                   _comboScoreEvents;                                 // 0x01B8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1C8[0x40];                                     // 0x01C8(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UStatusEffect>              _comboExtendSuperModeStatusEffectClass;            // 0x0208(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnRep_ComboScore() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlurryComboScoreComponent">();
	}
	static class UFlurryComboScoreComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlurryComboScoreComponent>();
	}
};
static_assert(alignof(UFlurryComboScoreComponent) == 0x000008, "Wrong alignment on UFlurryComboScoreComponent");
static_assert(sizeof(UFlurryComboScoreComponent) == 0x000210, "Wrong size on UFlurryComboScoreComponent");
static_assert(offsetof(UFlurryComboScoreComponent, _comboScore) == 0x0000C4, "Member 'UFlurryComboScoreComponent::_comboScore' has a wrong offset!");
static_assert(offsetof(UFlurryComboScoreComponent, _timeAddedByComboRank) == 0x0000C8, "Member 'UFlurryComboScoreComponent::_timeAddedByComboRank' has a wrong offset!");
static_assert(offsetof(UFlurryComboScoreComponent, _timeForCombo) == 0x0000F0, "Member 'UFlurryComboScoreComponent::_timeForCombo' has a wrong offset!");
static_assert(offsetof(UFlurryComboScoreComponent, _consecutiveHitsRequiredScore) == 0x000170, "Member 'UFlurryComboScoreComponent::_consecutiveHitsRequiredScore' has a wrong offset!");
static_assert(offsetof(UFlurryComboScoreComponent, _thresholds) == 0x000198, "Member 'UFlurryComboScoreComponent::_thresholds' has a wrong offset!");
static_assert(offsetof(UFlurryComboScoreComponent, _thresholdsScoreForAudio) == 0x0001A8, "Member 'UFlurryComboScoreComponent::_thresholdsScoreForAudio' has a wrong offset!");
static_assert(offsetof(UFlurryComboScoreComponent, _comboScoreEvents) == 0x0001B8, "Member 'UFlurryComboScoreComponent::_comboScoreEvents' has a wrong offset!");
static_assert(offsetof(UFlurryComboScoreComponent, _comboExtendSuperModeStatusEffectClass) == 0x000208, "Member 'UFlurryComboScoreComponent::_comboExtendSuperModeStatusEffectClass' has a wrong offset!");

// Class TheK23.FlurryOfKnives
// 0x0550 (0x0E10 - 0x08C0)
class UFlurryOfKnives final : public UChargeableInteractionDefinition
{
public:
	uint8                                         Pad_8C0[0x48];                                     // 0x08C0(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _replicatedNumOfStacksReduction;                   // 0x0908(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isSuperModeThrow;                                 // 0x090C(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_90D[0x8B];                                     // 0x090D(0x008B)(Fixing Size After Last Property [ Dumper-7 ])
	class UStatusEffect*                          _selfSlowEffect;                                   // 0x0998(0x0008)(ExportObject, Net, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _selfSlowStatusEffectClass;                        // 0x09A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _flurryOfKnivesEnterDuration;                      // 0x09A8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _flurryOfKnivesExitDuration;                       // 0x09D0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _chargeTime;                                       // 0x09F8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _baseTimeBetweenThrows;                            // 0x0A20(0x0080)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _throwRateModifierByKnivesThrown;                  // 0x0AA0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _superModeDeactivationBuffer;                      // 0x0AA8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _superModeThrowRateModifier;                       // 0x0AD0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _knivesLaunchSpeed;                                // 0x0AF8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _convergencePointDistance;                         // 0x0B20(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _coneOfFireAngleCurve;                             // 0x0B48(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _consecutiveKnivesStacksDecayTime;                 // 0x0B50(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _maxConsecutiveKnivesStacks;                       // 0x0B78(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _movementSpeedByKnivesThrown;                      // 0x0BA0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _superModeBaseMovementSpeed;                       // 0x0BA8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _baseWalkSpeed;                                    // 0x0BD0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _recoilIntensityByKnivesThrown;                    // 0x0BF8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _recoilDuration;                                   // 0x0C00(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _recoilAngle;                                      // 0x0C28(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _maximumRecoilAngleVariation;                      // 0x0C50(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _rotationSpeedAdjustmentTime;                      // 0x0C78(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _aimingStanceRotationYawScaleAdjustment;           // 0x0CA0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _aimingStanceRotationPitchScaleAdjustment;         // 0x0CC8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _throwingRotationYawScaleAdjustment;               // 0x0CF0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _throwingRotationPitchScaleAdjustment;             // 0x0D18(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _aimingStanceGamepadRotationYawScaleAdjustment;    // 0x0D40(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _aimingStanceGamepadRotationPitchScaleAdjustment;  // 0x0D68(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _throwingGamepadRotationYawScaleAdjustment;        // 0x0D90(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _throwingGamepadRotationPitchScaleAdjustment;      // 0x0DB8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _aimingGamepadPitchCurve;                          // 0x0DE0(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _aimingGamepadYawCurve;                            // 0x0DE8(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _throwingGamepadPitchCurve;                        // 0x0DF0(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _throwingGamepadYawCurve;                          // 0x0DF8(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E00[0x10];                                     // 0x0E00(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Multicast_StartThrowing();
	void OnRep_NumOfStacksReduction();
	void Server_DecreaseConsecutiveKnivesStacks();
	void Server_StartThrowing();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlurryOfKnives">();
	}
	static class UFlurryOfKnives* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlurryOfKnives>();
	}
};
static_assert(alignof(UFlurryOfKnives) == 0x000010, "Wrong alignment on UFlurryOfKnives");
static_assert(sizeof(UFlurryOfKnives) == 0x000E10, "Wrong size on UFlurryOfKnives");
static_assert(offsetof(UFlurryOfKnives, _replicatedNumOfStacksReduction) == 0x000908, "Member 'UFlurryOfKnives::_replicatedNumOfStacksReduction' has a wrong offset!");
static_assert(offsetof(UFlurryOfKnives, _isSuperModeThrow) == 0x00090C, "Member 'UFlurryOfKnives::_isSuperModeThrow' has a wrong offset!");
static_assert(offsetof(UFlurryOfKnives, _selfSlowEffect) == 0x000998, "Member 'UFlurryOfKnives::_selfSlowEffect' has a wrong offset!");
static_assert(offsetof(UFlurryOfKnives, _selfSlowStatusEffectClass) == 0x0009A0, "Member 'UFlurryOfKnives::_selfSlowStatusEffectClass' has a wrong offset!");
static_assert(offsetof(UFlurryOfKnives, _flurryOfKnivesEnterDuration) == 0x0009A8, "Member 'UFlurryOfKnives::_flurryOfKnivesEnterDuration' has a wrong offset!");
static_assert(offsetof(UFlurryOfKnives, _flurryOfKnivesExitDuration) == 0x0009D0, "Member 'UFlurryOfKnives::_flurryOfKnivesExitDuration' has a wrong offset!");
static_assert(offsetof(UFlurryOfKnives, _chargeTime) == 0x0009F8, "Member 'UFlurryOfKnives::_chargeTime' has a wrong offset!");
static_assert(offsetof(UFlurryOfKnives, _baseTimeBetweenThrows) == 0x000A20, "Member 'UFlurryOfKnives::_baseTimeBetweenThrows' has a wrong offset!");
static_assert(offsetof(UFlurryOfKnives, _throwRateModifierByKnivesThrown) == 0x000AA0, "Member 'UFlurryOfKnives::_throwRateModifierByKnivesThrown' has a wrong offset!");
static_assert(offsetof(UFlurryOfKnives, _superModeDeactivationBuffer) == 0x000AA8, "Member 'UFlurryOfKnives::_superModeDeactivationBuffer' has a wrong offset!");
static_assert(offsetof(UFlurryOfKnives, _superModeThrowRateModifier) == 0x000AD0, "Member 'UFlurryOfKnives::_superModeThrowRateModifier' has a wrong offset!");
static_assert(offsetof(UFlurryOfKnives, _knivesLaunchSpeed) == 0x000AF8, "Member 'UFlurryOfKnives::_knivesLaunchSpeed' has a wrong offset!");
static_assert(offsetof(UFlurryOfKnives, _convergencePointDistance) == 0x000B20, "Member 'UFlurryOfKnives::_convergencePointDistance' has a wrong offset!");
static_assert(offsetof(UFlurryOfKnives, _coneOfFireAngleCurve) == 0x000B48, "Member 'UFlurryOfKnives::_coneOfFireAngleCurve' has a wrong offset!");
static_assert(offsetof(UFlurryOfKnives, _consecutiveKnivesStacksDecayTime) == 0x000B50, "Member 'UFlurryOfKnives::_consecutiveKnivesStacksDecayTime' has a wrong offset!");
static_assert(offsetof(UFlurryOfKnives, _maxConsecutiveKnivesStacks) == 0x000B78, "Member 'UFlurryOfKnives::_maxConsecutiveKnivesStacks' has a wrong offset!");
static_assert(offsetof(UFlurryOfKnives, _movementSpeedByKnivesThrown) == 0x000BA0, "Member 'UFlurryOfKnives::_movementSpeedByKnivesThrown' has a wrong offset!");
static_assert(offsetof(UFlurryOfKnives, _superModeBaseMovementSpeed) == 0x000BA8, "Member 'UFlurryOfKnives::_superModeBaseMovementSpeed' has a wrong offset!");
static_assert(offsetof(UFlurryOfKnives, _baseWalkSpeed) == 0x000BD0, "Member 'UFlurryOfKnives::_baseWalkSpeed' has a wrong offset!");
static_assert(offsetof(UFlurryOfKnives, _recoilIntensityByKnivesThrown) == 0x000BF8, "Member 'UFlurryOfKnives::_recoilIntensityByKnivesThrown' has a wrong offset!");
static_assert(offsetof(UFlurryOfKnives, _recoilDuration) == 0x000C00, "Member 'UFlurryOfKnives::_recoilDuration' has a wrong offset!");
static_assert(offsetof(UFlurryOfKnives, _recoilAngle) == 0x000C28, "Member 'UFlurryOfKnives::_recoilAngle' has a wrong offset!");
static_assert(offsetof(UFlurryOfKnives, _maximumRecoilAngleVariation) == 0x000C50, "Member 'UFlurryOfKnives::_maximumRecoilAngleVariation' has a wrong offset!");
static_assert(offsetof(UFlurryOfKnives, _rotationSpeedAdjustmentTime) == 0x000C78, "Member 'UFlurryOfKnives::_rotationSpeedAdjustmentTime' has a wrong offset!");
static_assert(offsetof(UFlurryOfKnives, _aimingStanceRotationYawScaleAdjustment) == 0x000CA0, "Member 'UFlurryOfKnives::_aimingStanceRotationYawScaleAdjustment' has a wrong offset!");
static_assert(offsetof(UFlurryOfKnives, _aimingStanceRotationPitchScaleAdjustment) == 0x000CC8, "Member 'UFlurryOfKnives::_aimingStanceRotationPitchScaleAdjustment' has a wrong offset!");
static_assert(offsetof(UFlurryOfKnives, _throwingRotationYawScaleAdjustment) == 0x000CF0, "Member 'UFlurryOfKnives::_throwingRotationYawScaleAdjustment' has a wrong offset!");
static_assert(offsetof(UFlurryOfKnives, _throwingRotationPitchScaleAdjustment) == 0x000D18, "Member 'UFlurryOfKnives::_throwingRotationPitchScaleAdjustment' has a wrong offset!");
static_assert(offsetof(UFlurryOfKnives, _aimingStanceGamepadRotationYawScaleAdjustment) == 0x000D40, "Member 'UFlurryOfKnives::_aimingStanceGamepadRotationYawScaleAdjustment' has a wrong offset!");
static_assert(offsetof(UFlurryOfKnives, _aimingStanceGamepadRotationPitchScaleAdjustment) == 0x000D68, "Member 'UFlurryOfKnives::_aimingStanceGamepadRotationPitchScaleAdjustment' has a wrong offset!");
static_assert(offsetof(UFlurryOfKnives, _throwingGamepadRotationYawScaleAdjustment) == 0x000D90, "Member 'UFlurryOfKnives::_throwingGamepadRotationYawScaleAdjustment' has a wrong offset!");
static_assert(offsetof(UFlurryOfKnives, _throwingGamepadRotationPitchScaleAdjustment) == 0x000DB8, "Member 'UFlurryOfKnives::_throwingGamepadRotationPitchScaleAdjustment' has a wrong offset!");
static_assert(offsetof(UFlurryOfKnives, _aimingGamepadPitchCurve) == 0x000DE0, "Member 'UFlurryOfKnives::_aimingGamepadPitchCurve' has a wrong offset!");
static_assert(offsetof(UFlurryOfKnives, _aimingGamepadYawCurve) == 0x000DE8, "Member 'UFlurryOfKnives::_aimingGamepadYawCurve' has a wrong offset!");
static_assert(offsetof(UFlurryOfKnives, _throwingGamepadPitchCurve) == 0x000DF0, "Member 'UFlurryOfKnives::_throwingGamepadPitchCurve' has a wrong offset!");
static_assert(offsetof(UFlurryOfKnives, _throwingGamepadYawCurve) == 0x000DF8, "Member 'UFlurryOfKnives::_throwingGamepadYawCurve' has a wrong offset!");

// Class TheK23.HexCrowdControl
// 0x0020 (0x04C0 - 0x04A0)
class UHexCrowdControl final : public UHexPerk
{
public:
	int32                                         _maxNumVaultsBlocked[0x3];                         // 0x04A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4AC[0x4];                                      // 0x04AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class AWindow>>         _authority_blockedVaults;                          // 0x04B0(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HexCrowdControl">();
	}
	static class UHexCrowdControl* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHexCrowdControl>();
	}
};
static_assert(alignof(UHexCrowdControl) == 0x000008, "Wrong alignment on UHexCrowdControl");
static_assert(sizeof(UHexCrowdControl) == 0x0004C0, "Wrong size on UHexCrowdControl");
static_assert(offsetof(UHexCrowdControl, _maxNumVaultsBlocked) == 0x0004A0, "Member 'UHexCrowdControl::_maxNumVaultsBlocked' has a wrong offset!");
static_assert(offsetof(UHexCrowdControl, _authority_blockedVaults) == 0x0004B0, "Member 'UHexCrowdControl::_authority_blockedVaults' has a wrong offset!");

// Class TheK23.TricksterChainedThrowsAddon
// 0x0008 (0x02F0 - 0x02E8)
class UTricksterChainedThrowsAddon : public UItemAddon
{
public:
	int32                                         _consecutiveHits;                                  // 0x02E8(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _resetOnEnteringFlurryInteraction;                 // 0x02EC(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2ED[0x3];                                      // 0x02ED(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TricksterChainedThrowsAddon">();
	}
	static class UTricksterChainedThrowsAddon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTricksterChainedThrowsAddon>();
	}
};
static_assert(alignof(UTricksterChainedThrowsAddon) == 0x000008, "Wrong alignment on UTricksterChainedThrowsAddon");
static_assert(sizeof(UTricksterChainedThrowsAddon) == 0x0002F0, "Wrong size on UTricksterChainedThrowsAddon");
static_assert(offsetof(UTricksterChainedThrowsAddon, _consecutiveHits) == 0x0002E8, "Member 'UTricksterChainedThrowsAddon::_consecutiveHits' has a wrong offset!");
static_assert(offsetof(UTricksterChainedThrowsAddon, _resetOnEnteringFlurryInteraction) == 0x0002EC, "Member 'UTricksterChainedThrowsAddon::_resetOnEnteringFlurryInteraction' has a wrong offset!");

// Class TheK23.IridescentPhotocardAddon
// 0x0008 (0x02F8 - 0x02F0)
class UIridescentPhotocardAddon final : public UTricksterChainedThrowsAddon
{
public:
	float                                         _percentageGainedOnHit;                            // 0x02F0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         _maxConsecutiveHits;                               // 0x02F4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IridescentPhotocardAddon">();
	}
	static class UIridescentPhotocardAddon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIridescentPhotocardAddon>();
	}
};
static_assert(alignof(UIridescentPhotocardAddon) == 0x000008, "Wrong alignment on UIridescentPhotocardAddon");
static_assert(sizeof(UIridescentPhotocardAddon) == 0x0002F8, "Wrong size on UIridescentPhotocardAddon");
static_assert(offsetof(UIridescentPhotocardAddon, _percentageGainedOnHit) == 0x0002F0, "Member 'UIridescentPhotocardAddon::_percentageGainedOnHit' has a wrong offset!");
static_assert(offsetof(UIridescentPhotocardAddon, _maxConsecutiveHits) == 0x0002F4, "Member 'UIridescentPhotocardAddon::_maxConsecutiveHits' has a wrong offset!");

// Class TheK23.K23PowerProgressPresentationComponent
// 0x0000 (0x00B0 - 0x00B0)
class UK23PowerProgressPresentationComponent final : public UPresentationItemProgressComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K23PowerProgressPresentationComponent">();
	}
	static class UK23PowerProgressPresentationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK23PowerProgressPresentationComponent>();
	}
};
static_assert(alignof(UK23PowerProgressPresentationComponent) == 0x000008, "Wrong alignment on UK23PowerProgressPresentationComponent");
static_assert(sizeof(UK23PowerProgressPresentationComponent) == 0x0000B0, "Wrong size on UK23PowerProgressPresentationComponent");

// Class TheK23.K23SurvivorCosmeticHelperActor
// 0x0018 (0x0320 - 0x0308)
class AK23SurvivorCosmeticHelperActor final : public ASurvivorCosmeticHelperActor
{
public:
	uint8                                         Pad_308[0x18];                                     // 0x0308(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_K23CamperHitByKnife(float LacerationPercentage);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K23SurvivorCosmeticHelperActor">();
	}
	static class AK23SurvivorCosmeticHelperActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK23SurvivorCosmeticHelperActor>();
	}
};
static_assert(alignof(AK23SurvivorCosmeticHelperActor) == 0x000008, "Wrong alignment on AK23SurvivorCosmeticHelperActor");
static_assert(sizeof(AK23SurvivorCosmeticHelperActor) == 0x000320, "Wrong size on AK23SurvivorCosmeticHelperActor");

// Class TheK23.KnifeProjectile
// 0x00F0 (0x0498 - 0x03A8)
class AKnifeProjectile final : public AKillerProjectile
{
public:
	class UPrimitiveComponent*                    _worldCollider;                                    // 0x03A8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPrimitiveComponent*                    _camperDetector;                                   // 0x03B0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B8[0x10];                                     // 0x03B8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class ADBDPlayer*>                       _playersAffectedThisThrow;                         // 0x03C8(0x0050)(NativeAccessSpecifierPrivate)
	class UPoolableProjectileComponent*           _poolableActorComponent;                           // 0x0418(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _knifeMaxRange;                                    // 0x0420(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _addonExplosionRadius;                             // 0x0448(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _numberOfAddonBounces;                             // 0x0470(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	void BP_CosmeticOnAddonExplosion(const struct FVector& Location, const struct FVector& Normal);
	void BP_OnLaunchCosmetic(const struct FLaunchInfo& LaunchInfo, bool HasImpactOnLaunch);
	void BP_SetKnifeActive(bool Active);
	void OnProjectileBounce(const struct FHitResult& ImpactResult, const struct FVector& ImpactVelocity);
	void OnWorldColliderHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	void SetKnifeAcquired(bool Acquired);

	float GetAddonExplosionRadius() const;
	bool KnifeCanPierceCampers() const;
	bool ShouldPlayRicochetSound() const;
	bool WasLaunchedDuringSuperMode() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KnifeProjectile">();
	}
	static class AKnifeProjectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKnifeProjectile>();
	}
};
static_assert(alignof(AKnifeProjectile) == 0x000008, "Wrong alignment on AKnifeProjectile");
static_assert(sizeof(AKnifeProjectile) == 0x000498, "Wrong size on AKnifeProjectile");
static_assert(offsetof(AKnifeProjectile, _worldCollider) == 0x0003A8, "Member 'AKnifeProjectile::_worldCollider' has a wrong offset!");
static_assert(offsetof(AKnifeProjectile, _camperDetector) == 0x0003B0, "Member 'AKnifeProjectile::_camperDetector' has a wrong offset!");
static_assert(offsetof(AKnifeProjectile, _playersAffectedThisThrow) == 0x0003C8, "Member 'AKnifeProjectile::_playersAffectedThisThrow' has a wrong offset!");
static_assert(offsetof(AKnifeProjectile, _poolableActorComponent) == 0x000418, "Member 'AKnifeProjectile::_poolableActorComponent' has a wrong offset!");
static_assert(offsetof(AKnifeProjectile, _knifeMaxRange) == 0x000420, "Member 'AKnifeProjectile::_knifeMaxRange' has a wrong offset!");
static_assert(offsetof(AKnifeProjectile, _addonExplosionRadius) == 0x000448, "Member 'AKnifeProjectile::_addonExplosionRadius' has a wrong offset!");
static_assert(offsetof(AKnifeProjectile, _numberOfAddonBounces) == 0x000470, "Member 'AKnifeProjectile::_numberOfAddonBounces' has a wrong offset!");

// Class TheK23.KnifeRack
// 0x0000 (0x02C8 - 0x02C8)
class AKnifeRack final : public ABaseLockerItem
{
public:
	void OnReloadEnded(class ADBDPlayer* Player);
	void OnReloadMontageStarted(float ActionSpeedMultiplier, class ADBDPlayer* Player);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KnifeRack">();
	}
	static class AKnifeRack* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKnifeRack>();
	}
};
static_assert(alignof(AKnifeRack) == 0x000008, "Wrong alignment on AKnifeRack");
static_assert(sizeof(AKnifeRack) == 0x0002C8, "Wrong size on AKnifeRack");

// Class TheK23.KnivesLauncher
// 0x0108 (0x02A0 - 0x0198)
class UKnivesLauncher final : public UKillerProjectileLauncher
{
public:
	struct FDBDTunableRowHandle                   _knifeSpawnOffset;                                 // 0x0198(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _knifeSpawnForwardOffset;                          // 0x01C0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _launchSpeed;                                      // 0x01E8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _maxAmmoTunable;                                   // 0x0210(0x0080)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_290[0x8];                                      // 0x0290(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _isInSuperModeThrow;                               // 0x0298(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_299[0x7];                                      // 0x0299(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 GetLocallyPredictedAmmo() const;
	class AThrowingKnives* GetPower() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KnivesLauncher">();
	}
	static class UKnivesLauncher* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKnivesLauncher>();
	}
};
static_assert(alignof(UKnivesLauncher) == 0x000008, "Wrong alignment on UKnivesLauncher");
static_assert(sizeof(UKnivesLauncher) == 0x0002A0, "Wrong size on UKnivesLauncher");
static_assert(offsetof(UKnivesLauncher, _knifeSpawnOffset) == 0x000198, "Member 'UKnivesLauncher::_knifeSpawnOffset' has a wrong offset!");
static_assert(offsetof(UKnivesLauncher, _knifeSpawnForwardOffset) == 0x0001C0, "Member 'UKnivesLauncher::_knifeSpawnForwardOffset' has a wrong offset!");
static_assert(offsetof(UKnivesLauncher, _launchSpeed) == 0x0001E8, "Member 'UKnivesLauncher::_launchSpeed' has a wrong offset!");
static_assert(offsetof(UKnivesLauncher, _maxAmmoTunable) == 0x000210, "Member 'UKnivesLauncher::_maxAmmoTunable' has a wrong offset!");
static_assert(offsetof(UKnivesLauncher, _isInSuperModeThrow) == 0x000298, "Member 'UKnivesLauncher::_isInSuperModeThrow' has a wrong offset!");

// Class TheK23.KnivesProvider
// 0x0008 (0x0110 - 0x0108)
class UKnivesProvider final : public UAuthoritativeActorPoolComponent
{
public:
	uint8                                         Pad_108[0x8];                                      // 0x0108(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KnivesProvider">();
	}
	static class UKnivesProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKnivesProvider>();
	}
};
static_assert(alignof(UKnivesProvider) == 0x000008, "Wrong alignment on UKnivesProvider");
static_assert(sizeof(UKnivesProvider) == 0x000110, "Wrong size on UKnivesProvider");

// Class TheK23.LacerationComponent
// 0x0428 (0x04D0 - 0x00A8)
class ULacerationComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x38];                                      // 0x00A8(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _laceration;                                       // 0x00E0(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E4[0xC];                                       // 0x00E4(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	class UStatusEffect*                          _onHitSpeedBoost;                                  // 0x00F0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _lacerationOnHitSpeedBoostStatusEffectClass;       // 0x00F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_100[0x18];                                     // 0x0100(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTunableStat                           _maxLaceration;                                    // 0x0118(0x0080)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _lacerationExplosionDamage;                        // 0x0198(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _lacerationRegressionPerSecond;                    // 0x01C0(0x0080)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _lacerationRegressionPerSecondWhileRunning;        // 0x0240(0x0080)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _speedBoostIntensity;                              // 0x02C0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _speedBoostDuration;                               // 0x02E8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _stopTickingRegressionWhileInjured;                // 0x0310(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _stopTickingRegressionWhileInChase;                // 0x0338(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _stopTickingRegressionWithinTerrorRadius;          // 0x0360(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _timeBeforeLacerationDecayStarts;                  // 0x0388(0x0080)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _regressionBufferTimerAlwaysTicks;                 // 0x0408(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _lacerationToRemoveOnBasicAttack;                  // 0x0430(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _thresholdForGraceTimerScoreEvent;                 // 0x0458(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _minThresholdForLowLacerationScoreEvent;           // 0x0480(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _maxThresholdForLowLacerationScoreEvent;           // 0x04A8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	void Cosmetic_OnKnifeHit(float LacerationPercent, bool IsDangerous, bool CausedDamage, bool CausedKO, const struct FVector& ImpactNormal);
	void Multicast_KnifeHit(float NewLaceration, bool CausedDamage, bool CausedKO, const struct FVector& ImpactLocation, const struct FVector& ImpactNormal);
	void OnRepLaceration(float OldLaceration);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LacerationComponent">();
	}
	static class ULacerationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULacerationComponent>();
	}
};
static_assert(alignof(ULacerationComponent) == 0x000008, "Wrong alignment on ULacerationComponent");
static_assert(sizeof(ULacerationComponent) == 0x0004D0, "Wrong size on ULacerationComponent");
static_assert(offsetof(ULacerationComponent, _laceration) == 0x0000E0, "Member 'ULacerationComponent::_laceration' has a wrong offset!");
static_assert(offsetof(ULacerationComponent, _onHitSpeedBoost) == 0x0000F0, "Member 'ULacerationComponent::_onHitSpeedBoost' has a wrong offset!");
static_assert(offsetof(ULacerationComponent, _lacerationOnHitSpeedBoostStatusEffectClass) == 0x0000F8, "Member 'ULacerationComponent::_lacerationOnHitSpeedBoostStatusEffectClass' has a wrong offset!");
static_assert(offsetof(ULacerationComponent, _maxLaceration) == 0x000118, "Member 'ULacerationComponent::_maxLaceration' has a wrong offset!");
static_assert(offsetof(ULacerationComponent, _lacerationExplosionDamage) == 0x000198, "Member 'ULacerationComponent::_lacerationExplosionDamage' has a wrong offset!");
static_assert(offsetof(ULacerationComponent, _lacerationRegressionPerSecond) == 0x0001C0, "Member 'ULacerationComponent::_lacerationRegressionPerSecond' has a wrong offset!");
static_assert(offsetof(ULacerationComponent, _lacerationRegressionPerSecondWhileRunning) == 0x000240, "Member 'ULacerationComponent::_lacerationRegressionPerSecondWhileRunning' has a wrong offset!");
static_assert(offsetof(ULacerationComponent, _speedBoostIntensity) == 0x0002C0, "Member 'ULacerationComponent::_speedBoostIntensity' has a wrong offset!");
static_assert(offsetof(ULacerationComponent, _speedBoostDuration) == 0x0002E8, "Member 'ULacerationComponent::_speedBoostDuration' has a wrong offset!");
static_assert(offsetof(ULacerationComponent, _stopTickingRegressionWhileInjured) == 0x000310, "Member 'ULacerationComponent::_stopTickingRegressionWhileInjured' has a wrong offset!");
static_assert(offsetof(ULacerationComponent, _stopTickingRegressionWhileInChase) == 0x000338, "Member 'ULacerationComponent::_stopTickingRegressionWhileInChase' has a wrong offset!");
static_assert(offsetof(ULacerationComponent, _stopTickingRegressionWithinTerrorRadius) == 0x000360, "Member 'ULacerationComponent::_stopTickingRegressionWithinTerrorRadius' has a wrong offset!");
static_assert(offsetof(ULacerationComponent, _timeBeforeLacerationDecayStarts) == 0x000388, "Member 'ULacerationComponent::_timeBeforeLacerationDecayStarts' has a wrong offset!");
static_assert(offsetof(ULacerationComponent, _regressionBufferTimerAlwaysTicks) == 0x000408, "Member 'ULacerationComponent::_regressionBufferTimerAlwaysTicks' has a wrong offset!");
static_assert(offsetof(ULacerationComponent, _lacerationToRemoveOnBasicAttack) == 0x000430, "Member 'ULacerationComponent::_lacerationToRemoveOnBasicAttack' has a wrong offset!");
static_assert(offsetof(ULacerationComponent, _thresholdForGraceTimerScoreEvent) == 0x000458, "Member 'ULacerationComponent::_thresholdForGraceTimerScoreEvent' has a wrong offset!");
static_assert(offsetof(ULacerationComponent, _minThresholdForLowLacerationScoreEvent) == 0x000480, "Member 'ULacerationComponent::_minThresholdForLowLacerationScoreEvent' has a wrong offset!");
static_assert(offsetof(ULacerationComponent, _maxThresholdForLowLacerationScoreEvent) == 0x0004A8, "Member 'ULacerationComponent::_maxThresholdForLowLacerationScoreEvent' has a wrong offset!");

// Class TheK23.BaseLacerationLevelCondition
// 0x0000 (0x00E0 - 0x00E0)
class UBaseLacerationLevelCondition : public UEventDrivenModifierCondition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseLacerationLevelCondition">();
	}
	static class UBaseLacerationLevelCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseLacerationLevelCondition>();
	}
};
static_assert(alignof(UBaseLacerationLevelCondition) == 0x000008, "Wrong alignment on UBaseLacerationLevelCondition");
static_assert(sizeof(UBaseLacerationLevelCondition) == 0x0000E0, "Wrong size on UBaseLacerationLevelCondition");

// Class TheK23.LacerationLevelCondition
// 0x0008 (0x00E8 - 0x00E0)
class ULacerationLevelCondition final : public UBaseLacerationLevelCondition
{
public:
	float                                         _lacerationLevelRequired;                          // 0x00E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E4[0x4];                                       // 0x00E4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LacerationLevelCondition">();
	}
	static class ULacerationLevelCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULacerationLevelCondition>();
	}
};
static_assert(alignof(ULacerationLevelCondition) == 0x000008, "Wrong alignment on ULacerationLevelCondition");
static_assert(sizeof(ULacerationLevelCondition) == 0x0000E8, "Wrong size on ULacerationLevelCondition");
static_assert(offsetof(ULacerationLevelCondition, _lacerationLevelRequired) == 0x0000E0, "Member 'ULacerationLevelCondition::_lacerationLevelRequired' has a wrong offset!");

// Class TheK23.LacerationAlmostFullCondition
// 0x0008 (0x00E8 - 0x00E0)
class ULacerationAlmostFullCondition final : public UBaseLacerationLevelCondition
{
public:
	float                                         _missingLacerationThreshold;                       // 0x00E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E4[0x4];                                       // 0x00E4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LacerationAlmostFullCondition">();
	}
	static class ULacerationAlmostFullCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULacerationAlmostFullCondition>();
	}
};
static_assert(alignof(ULacerationAlmostFullCondition) == 0x000008, "Wrong alignment on ULacerationAlmostFullCondition");
static_assert(sizeof(ULacerationAlmostFullCondition) == 0x0000E8, "Wrong size on ULacerationAlmostFullCondition");
static_assert(offsetof(ULacerationAlmostFullCondition, _missingLacerationThreshold) == 0x0000E0, "Member 'ULacerationAlmostFullCondition::_missingLacerationThreshold' has a wrong offset!");

// Class TheK23.NoWayOut
// 0x0030 (0x0450 - 0x0420)
class UNoWayOut final : public UPerk
{
public:
	float                                         _exitGatePanelBlockBaseDuration[0x3];              // 0x0420(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _exitGatePanelBlockDurationPerToken[0x3];          // 0x042C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class ACamperPlayer*>                  _hookedSurvivors;                                  // 0x0438(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_448[0x8];                                      // 0x0448(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Multicast_TriggerLoudNoise(class ADBDPlayer* Instigator, class AEscapeDoor* EscapeDoor);

	float GetExitGatePanelBlockBaseDurationAtLevel() const;
	float GetExitGatePanelBlockDurationPerTokenAtLevel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NoWayOut">();
	}
	static class UNoWayOut* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNoWayOut>();
	}
};
static_assert(alignof(UNoWayOut) == 0x000008, "Wrong alignment on UNoWayOut");
static_assert(sizeof(UNoWayOut) == 0x000450, "Wrong size on UNoWayOut");
static_assert(offsetof(UNoWayOut, _exitGatePanelBlockBaseDuration) == 0x000420, "Member 'UNoWayOut::_exitGatePanelBlockBaseDuration' has a wrong offset!");
static_assert(offsetof(UNoWayOut, _exitGatePanelBlockDurationPerToken) == 0x00042C, "Member 'UNoWayOut::_exitGatePanelBlockDurationPerToken' has a wrong offset!");
static_assert(offsetof(UNoWayOut, _hookedSurvivors) == 0x000438, "Member 'UNoWayOut::_hookedSurvivors' has a wrong offset!");

// Class TheK23.ReloadKnives
// 0x0000 (0x07B0 - 0x07B0)
class UReloadKnives final : public UBaseLockerInteraction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReloadKnives">();
	}
	static class UReloadKnives* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReloadKnives>();
	}
};
static_assert(alignof(UReloadKnives) == 0x000010, "Wrong alignment on UReloadKnives");
static_assert(sizeof(UReloadKnives) == 0x0007B0, "Wrong size on UReloadKnives");

// Class TheK23.Starstruck
// 0x0128 (0x0548 - 0x0420)
class UStarstruck final : public UPerk
{
public:
	float                                         _exposedEffectDuration[0x3];                       // 0x0420(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _perkCooldownDuration[0x3];                        // 0x042C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<TWeakObjectPtr<class ACamperPlayer>, TWeakObjectPtr<class UStatusEffect>> _camperExposedEffects;                             // 0x0438(0x0050)(ExportObject, Transient, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_488[0xB8];                                     // 0x0488(0x00B8)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UStatusEffect>              _exposedEffectClass;                               // 0x0540(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	float GetExposedEffectDurationAtLevel() const;
	float GetPerkCooldownDurationAtLevel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Starstruck">();
	}
	static class UStarstruck* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStarstruck>();
	}
};
static_assert(alignof(UStarstruck) == 0x000008, "Wrong alignment on UStarstruck");
static_assert(sizeof(UStarstruck) == 0x000548, "Wrong size on UStarstruck");
static_assert(offsetof(UStarstruck, _exposedEffectDuration) == 0x000420, "Member 'UStarstruck::_exposedEffectDuration' has a wrong offset!");
static_assert(offsetof(UStarstruck, _perkCooldownDuration) == 0x00042C, "Member 'UStarstruck::_perkCooldownDuration' has a wrong offset!");
static_assert(offsetof(UStarstruck, _camperExposedEffects) == 0x000438, "Member 'UStarstruck::_camperExposedEffects' has a wrong offset!");
static_assert(offsetof(UStarstruck, _exposedEffectClass) == 0x000540, "Member 'UStarstruck::_exposedEffectClass' has a wrong offset!");

// Class TheK23.SuperModeDeactivation
// 0x0020 (0x07A0 - 0x0780)
class USuperModeDeactivation final : public UInteractionDefinition
{
public:
	struct FDBDTunableRowHandle                   _deactivationDuration;                             // 0x0778(0x0028)(Edit, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SuperModeDeactivation">();
	}
	static class USuperModeDeactivation* GetDefaultObj()
	{
		return GetDefaultObjImpl<USuperModeDeactivation>();
	}
};
static_assert(alignof(USuperModeDeactivation) == 0x000010, "Wrong alignment on USuperModeDeactivation");
static_assert(sizeof(USuperModeDeactivation) == 0x0007A0, "Wrong size on USuperModeDeactivation");
static_assert(offsetof(USuperModeDeactivation, _deactivationDuration) == 0x000778, "Member 'USuperModeDeactivation::_deactivationDuration' has a wrong offset!");

// Class TheK23.ThrowingKnives
// 0x00A8 (0x05F8 - 0x0550)
class AThrowingKnives final : public ACollectable
{
public:
	uint8                                         Pad_550[0x40];                                     // 0x0550(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	class UFlurryComboScoreComponent*             _flurryScoreComponent;                             // 0x0590(0x0008)(Edit, ExportObject, Net, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTricksterSuperModeComponent*           _superModeComponent;                               // 0x0598(0x0008)(Edit, ExportObject, Net, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UK23PowerProgressPresentationComponent* _superModeChargePresentationComponent;             // 0x05A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPowerChargeComponent*                  _superModeChargeComponent;                         // 0x05A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _tricksterOutOfAmmoStatusEffectClass;              // 0x05B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UKnivesProvider*                        _knivesProvider;                                   // 0x05B8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UKnivesLauncher*                        _knivesLauncher;                                   // 0x05C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class ULacerationComponent>       _lacerationComponentClass;                         // 0x05C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UReloadKnives>              _reloadInteractionClass;                           // 0x05D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _minimumTimeBetweenBroadcast;                      // 0x05D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5DC[0x1C];                                     // 0x05DC(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_SpawnReloadInteractionOnLockers();
	void Cosmetic_OnComboFinished(bool IsSRankCombo);
	void Cosmetic_OnComboScoreChanged(float ScoreNormalizedForAudio);
	void Cosmetic_OnLaunch();
	void Cosmetic_OnUsePowerWhenInCooldown();
	void Cosmetic_OnUsePowerWhenOutOfAmmo();
	void Multicast_OnUsePowerWhenInCooldown();
	void Multicast_OnUsePowerWhenOutOfAmmo();
	void OnItemUsedStateChanged(bool Pressed);

	class UKnivesLauncher* GetLauncher() const;
	class ASlasherPlayer* GetSlasher() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ThrowingKnives">();
	}
	static class AThrowingKnives* GetDefaultObj()
	{
		return GetDefaultObjImpl<AThrowingKnives>();
	}
};
static_assert(alignof(AThrowingKnives) == 0x000008, "Wrong alignment on AThrowingKnives");
static_assert(sizeof(AThrowingKnives) == 0x0005F8, "Wrong size on AThrowingKnives");
static_assert(offsetof(AThrowingKnives, _flurryScoreComponent) == 0x000590, "Member 'AThrowingKnives::_flurryScoreComponent' has a wrong offset!");
static_assert(offsetof(AThrowingKnives, _superModeComponent) == 0x000598, "Member 'AThrowingKnives::_superModeComponent' has a wrong offset!");
static_assert(offsetof(AThrowingKnives, _superModeChargePresentationComponent) == 0x0005A0, "Member 'AThrowingKnives::_superModeChargePresentationComponent' has a wrong offset!");
static_assert(offsetof(AThrowingKnives, _superModeChargeComponent) == 0x0005A8, "Member 'AThrowingKnives::_superModeChargeComponent' has a wrong offset!");
static_assert(offsetof(AThrowingKnives, _tricksterOutOfAmmoStatusEffectClass) == 0x0005B0, "Member 'AThrowingKnives::_tricksterOutOfAmmoStatusEffectClass' has a wrong offset!");
static_assert(offsetof(AThrowingKnives, _knivesProvider) == 0x0005B8, "Member 'AThrowingKnives::_knivesProvider' has a wrong offset!");
static_assert(offsetof(AThrowingKnives, _knivesLauncher) == 0x0005C0, "Member 'AThrowingKnives::_knivesLauncher' has a wrong offset!");
static_assert(offsetof(AThrowingKnives, _lacerationComponentClass) == 0x0005C8, "Member 'AThrowingKnives::_lacerationComponentClass' has a wrong offset!");
static_assert(offsetof(AThrowingKnives, _reloadInteractionClass) == 0x0005D0, "Member 'AThrowingKnives::_reloadInteractionClass' has a wrong offset!");
static_assert(offsetof(AThrowingKnives, _minimumTimeBetweenBroadcast) == 0x0005D8, "Member 'AThrowingKnives::_minimumTimeBetweenBroadcast' has a wrong offset!");

// Class TheK23.ThrowingKnivesHitSubAnimInstance
// 0x0050 (0x0630 - 0x05E0)
class UThrowingKnivesHitSubAnimInstance final : public UBaseSurvivorAnimInstance
{
public:
	uint8                                         Pad_5E0[0x8];                                      // 0x05E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _hitByKnifeTrigger;                                // 0x05E8(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _knifeHitCausedKOTrigger;                          // 0x05E9(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _knifeHitCausedDamageTrigger;                      // 0x05EA(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _useAlternateHitReactionState;                     // 0x05EB(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _knifeHitStateHitAngle;                            // 0x05EC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _alternateKnifeHitStateHitAngle;                   // 0x05F0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isCrawling;                                       // 0x05F4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _hitByKnifeTriggerEventDriven;                     // 0x05F5(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _knifeHitCausedDamageTriggerEventDriven;           // 0x05F6(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _knifeHitCausedKOTriggerEventDriven;               // 0x05F7(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5F8[0x38];                                     // 0x05F8(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ThrowingKnivesHitSubAnimInstance">();
	}
	static class UThrowingKnivesHitSubAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UThrowingKnivesHitSubAnimInstance>();
	}
};
static_assert(alignof(UThrowingKnivesHitSubAnimInstance) == 0x000010, "Wrong alignment on UThrowingKnivesHitSubAnimInstance");
static_assert(sizeof(UThrowingKnivesHitSubAnimInstance) == 0x000630, "Wrong size on UThrowingKnivesHitSubAnimInstance");
static_assert(offsetof(UThrowingKnivesHitSubAnimInstance, _hitByKnifeTrigger) == 0x0005E8, "Member 'UThrowingKnivesHitSubAnimInstance::_hitByKnifeTrigger' has a wrong offset!");
static_assert(offsetof(UThrowingKnivesHitSubAnimInstance, _knifeHitCausedKOTrigger) == 0x0005E9, "Member 'UThrowingKnivesHitSubAnimInstance::_knifeHitCausedKOTrigger' has a wrong offset!");
static_assert(offsetof(UThrowingKnivesHitSubAnimInstance, _knifeHitCausedDamageTrigger) == 0x0005EA, "Member 'UThrowingKnivesHitSubAnimInstance::_knifeHitCausedDamageTrigger' has a wrong offset!");
static_assert(offsetof(UThrowingKnivesHitSubAnimInstance, _useAlternateHitReactionState) == 0x0005EB, "Member 'UThrowingKnivesHitSubAnimInstance::_useAlternateHitReactionState' has a wrong offset!");
static_assert(offsetof(UThrowingKnivesHitSubAnimInstance, _knifeHitStateHitAngle) == 0x0005EC, "Member 'UThrowingKnivesHitSubAnimInstance::_knifeHitStateHitAngle' has a wrong offset!");
static_assert(offsetof(UThrowingKnivesHitSubAnimInstance, _alternateKnifeHitStateHitAngle) == 0x0005F0, "Member 'UThrowingKnivesHitSubAnimInstance::_alternateKnifeHitStateHitAngle' has a wrong offset!");
static_assert(offsetof(UThrowingKnivesHitSubAnimInstance, _isCrawling) == 0x0005F4, "Member 'UThrowingKnivesHitSubAnimInstance::_isCrawling' has a wrong offset!");
static_assert(offsetof(UThrowingKnivesHitSubAnimInstance, _hitByKnifeTriggerEventDriven) == 0x0005F5, "Member 'UThrowingKnivesHitSubAnimInstance::_hitByKnifeTriggerEventDriven' has a wrong offset!");
static_assert(offsetof(UThrowingKnivesHitSubAnimInstance, _knifeHitCausedDamageTriggerEventDriven) == 0x0005F6, "Member 'UThrowingKnivesHitSubAnimInstance::_knifeHitCausedDamageTriggerEventDriven' has a wrong offset!");
static_assert(offsetof(UThrowingKnivesHitSubAnimInstance, _knifeHitCausedKOTriggerEventDriven) == 0x0005F7, "Member 'UThrowingKnivesHitSubAnimInstance::_knifeHitCausedKOTriggerEventDriven' has a wrong offset!");

// Class TheK23.TricksterAnimInstance
// 0x0080 (0x07A0 - 0x0720)
class UTricksterAnimInstance final : public UKillerAnimInstance
{
public:
	bool                                          _isAiming;                                         // 0x0720(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_721[0x3];                                      // 0x0721(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _isThrowInputPressed;                              // 0x0724(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isThrowingWithLeftArm;                            // 0x0728(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isThrowingWithRightArm;                           // 0x0729(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_72A[0x2];                                      // 0x072A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _throwPlayRate;                                    // 0x072C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _baseThrowDuration;                                // 0x0730(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _consecutiveKnivesThrownStacks;                    // 0x0734(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _timeSinceLastKnifeLaunched;                       // 0x0738(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _currentAmmoCount;                                 // 0x073C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isInSuperMode;                                    // 0x0740(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isInActivation;                                   // 0x0741(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_742[0x2];                                      // 0x0742(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _activationDuration;                               // 0x0744(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isInDeactivation;                                 // 0x0748(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_749[0x3];                                      // 0x0749(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _deactivationDuration;                             // 0x074C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_750[0x40];                                     // 0x0750(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	class AThrowingKnives*                        _throwingKnives;                                   // 0x0790(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_798[0x8];                                      // 0x0798(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TricksterAnimInstance">();
	}
	static class UTricksterAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTricksterAnimInstance>();
	}
};
static_assert(alignof(UTricksterAnimInstance) == 0x000010, "Wrong alignment on UTricksterAnimInstance");
static_assert(sizeof(UTricksterAnimInstance) == 0x0007A0, "Wrong size on UTricksterAnimInstance");
static_assert(offsetof(UTricksterAnimInstance, _isAiming) == 0x000720, "Member 'UTricksterAnimInstance::_isAiming' has a wrong offset!");
static_assert(offsetof(UTricksterAnimInstance, _isThrowInputPressed) == 0x000724, "Member 'UTricksterAnimInstance::_isThrowInputPressed' has a wrong offset!");
static_assert(offsetof(UTricksterAnimInstance, _isThrowingWithLeftArm) == 0x000728, "Member 'UTricksterAnimInstance::_isThrowingWithLeftArm' has a wrong offset!");
static_assert(offsetof(UTricksterAnimInstance, _isThrowingWithRightArm) == 0x000729, "Member 'UTricksterAnimInstance::_isThrowingWithRightArm' has a wrong offset!");
static_assert(offsetof(UTricksterAnimInstance, _throwPlayRate) == 0x00072C, "Member 'UTricksterAnimInstance::_throwPlayRate' has a wrong offset!");
static_assert(offsetof(UTricksterAnimInstance, _baseThrowDuration) == 0x000730, "Member 'UTricksterAnimInstance::_baseThrowDuration' has a wrong offset!");
static_assert(offsetof(UTricksterAnimInstance, _consecutiveKnivesThrownStacks) == 0x000734, "Member 'UTricksterAnimInstance::_consecutiveKnivesThrownStacks' has a wrong offset!");
static_assert(offsetof(UTricksterAnimInstance, _timeSinceLastKnifeLaunched) == 0x000738, "Member 'UTricksterAnimInstance::_timeSinceLastKnifeLaunched' has a wrong offset!");
static_assert(offsetof(UTricksterAnimInstance, _currentAmmoCount) == 0x00073C, "Member 'UTricksterAnimInstance::_currentAmmoCount' has a wrong offset!");
static_assert(offsetof(UTricksterAnimInstance, _isInSuperMode) == 0x000740, "Member 'UTricksterAnimInstance::_isInSuperMode' has a wrong offset!");
static_assert(offsetof(UTricksterAnimInstance, _isInActivation) == 0x000741, "Member 'UTricksterAnimInstance::_isInActivation' has a wrong offset!");
static_assert(offsetof(UTricksterAnimInstance, _activationDuration) == 0x000744, "Member 'UTricksterAnimInstance::_activationDuration' has a wrong offset!");
static_assert(offsetof(UTricksterAnimInstance, _isInDeactivation) == 0x000748, "Member 'UTricksterAnimInstance::_isInDeactivation' has a wrong offset!");
static_assert(offsetof(UTricksterAnimInstance, _deactivationDuration) == 0x00074C, "Member 'UTricksterAnimInstance::_deactivationDuration' has a wrong offset!");
static_assert(offsetof(UTricksterAnimInstance, _throwingKnives) == 0x000790, "Member 'UTricksterAnimInstance::_throwingKnives' has a wrong offset!");

// Class TheK23.TricksterCharacterVFXInterface
// 0x0000 (0x0030 - 0x0030)
class ITricksterCharacterVFXInterface final : public IInterface
{
public:
	void HideWeapon();
	void SetIsInCooldown(bool IsInCooldown);
	void SetIsSuperModeReady(bool IsSuperModeReady);
	void SetKnivesVisibility(bool LeftKnife, bool RightKnife);
	void SetSuperModeActive(bool Active);
	void ShowWeapon();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TricksterCharacterVFXInterface">();
	}
	static class ITricksterCharacterVFXInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ITricksterCharacterVFXInterface>();
	}
};
static_assert(alignof(ITricksterCharacterVFXInterface) == 0x000008, "Wrong alignment on ITricksterCharacterVFXInterface");
static_assert(sizeof(ITricksterCharacterVFXInterface) == 0x000030, "Wrong size on ITricksterCharacterVFXInterface");

// Class TheK23.TricksterSuperModeComponent
// 0x0228 (0x02D0 - 0x00A8)
class UTricksterSuperModeComponent final : public UActorComponent
{
public:
	bool                                          _isInSuperMode;                                    // 0x00A8(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isSuperModeReady;                                 // 0x00A9(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isInCooldown;                                     // 0x00AA(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_AB[0xD];                                       // 0x00AB(0x000D)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _chargesToAddOnKnifeHit;                           // 0x00B8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _superModeMaxCharge;                               // 0x00E0(0x0080)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _superModeReadyDepletionPerSecond;                 // 0x0160(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _superModeActiveDuration;                          // 0x0188(0x0080)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_208[0x60];                                     // 0x0208(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _superModeCooldown;                                // 0x0268(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _shouldDisableFlurryDuringCooldown;                // 0x0290(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B8[0x10];                                     // 0x02B8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UStatusEffect>              _comboExtendSuperModeStatusEffectClass;            // 0x02C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void InitSuperModeMaxCharge();
	void OnRepIsInCooldown();
	void OnRepIsInSuperMode();
	void OnRepIsSuperModeReady();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TricksterSuperModeComponent">();
	}
	static class UTricksterSuperModeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTricksterSuperModeComponent>();
	}
};
static_assert(alignof(UTricksterSuperModeComponent) == 0x000008, "Wrong alignment on UTricksterSuperModeComponent");
static_assert(sizeof(UTricksterSuperModeComponent) == 0x0002D0, "Wrong size on UTricksterSuperModeComponent");
static_assert(offsetof(UTricksterSuperModeComponent, _isInSuperMode) == 0x0000A8, "Member 'UTricksterSuperModeComponent::_isInSuperMode' has a wrong offset!");
static_assert(offsetof(UTricksterSuperModeComponent, _isSuperModeReady) == 0x0000A9, "Member 'UTricksterSuperModeComponent::_isSuperModeReady' has a wrong offset!");
static_assert(offsetof(UTricksterSuperModeComponent, _isInCooldown) == 0x0000AA, "Member 'UTricksterSuperModeComponent::_isInCooldown' has a wrong offset!");
static_assert(offsetof(UTricksterSuperModeComponent, _chargesToAddOnKnifeHit) == 0x0000B8, "Member 'UTricksterSuperModeComponent::_chargesToAddOnKnifeHit' has a wrong offset!");
static_assert(offsetof(UTricksterSuperModeComponent, _superModeMaxCharge) == 0x0000E0, "Member 'UTricksterSuperModeComponent::_superModeMaxCharge' has a wrong offset!");
static_assert(offsetof(UTricksterSuperModeComponent, _superModeReadyDepletionPerSecond) == 0x000160, "Member 'UTricksterSuperModeComponent::_superModeReadyDepletionPerSecond' has a wrong offset!");
static_assert(offsetof(UTricksterSuperModeComponent, _superModeActiveDuration) == 0x000188, "Member 'UTricksterSuperModeComponent::_superModeActiveDuration' has a wrong offset!");
static_assert(offsetof(UTricksterSuperModeComponent, _superModeCooldown) == 0x000268, "Member 'UTricksterSuperModeComponent::_superModeCooldown' has a wrong offset!");
static_assert(offsetof(UTricksterSuperModeComponent, _shouldDisableFlurryDuringCooldown) == 0x000290, "Member 'UTricksterSuperModeComponent::_shouldDisableFlurryDuringCooldown' has a wrong offset!");
static_assert(offsetof(UTricksterSuperModeComponent, _comboExtendSuperModeStatusEffectClass) == 0x0002C8, "Member 'UTricksterSuperModeComponent::_comboExtendSuperModeStatusEffectClass' has a wrong offset!");

// Class TheK23.TriggerTimerOnLacerationAlmostFullEffect
// 0x0010 (0x0390 - 0x0380)
class UTriggerTimerOnLacerationAlmostFullEffect final : public UStatusEffect
{
public:
	class ULacerationComponent*                   _lacerationComponent;                              // 0x0380(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _duration;                                         // 0x0388(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_38C[0x4];                                      // 0x038C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TriggerTimerOnLacerationAlmostFullEffect">();
	}
	static class UTriggerTimerOnLacerationAlmostFullEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTriggerTimerOnLacerationAlmostFullEffect>();
	}
};
static_assert(alignof(UTriggerTimerOnLacerationAlmostFullEffect) == 0x000008, "Wrong alignment on UTriggerTimerOnLacerationAlmostFullEffect");
static_assert(sizeof(UTriggerTimerOnLacerationAlmostFullEffect) == 0x000390, "Wrong size on UTriggerTimerOnLacerationAlmostFullEffect");
static_assert(offsetof(UTriggerTimerOnLacerationAlmostFullEffect, _lacerationComponent) == 0x000380, "Member 'UTriggerTimerOnLacerationAlmostFullEffect::_lacerationComponent' has a wrong offset!");
static_assert(offsetof(UTriggerTimerOnLacerationAlmostFullEffect, _duration) == 0x000388, "Member 'UTriggerTimerOnLacerationAlmostFullEffect::_duration' has a wrong offset!");

}

