#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: TheK30

#include "Basic.hpp"

#include "DataTableUtilities_structs.hpp"
#include "StatSystem_structs.hpp"
#include "Engine_structs.hpp"
#include "CoreUObject_structs.hpp"


namespace SDK
{

// Enum TheK30.ESwapToState
// NumValues: 0x0004
enum class ESwapToState : uint8
{
	ReadyToBeSpawned                         = 0,
	CoolingDown                              = 1,
	AlreadyActiveGuard                       = 2,
	ESwapToState_MAX                         = 3,
};

// Enum TheK30.EPowerState
// NumValues: 0x0009
enum class EPowerState : uint8
{
	None                                     = 0,
	Ready                                    = 1,
	Charging                                 = 2,
	DrawPathStarted                          = 3,
	Snapping                                 = 4,
	SnappingDone                             = 5,
	DrawPathDone                             = 6,
	Cooldown                                 = 7,
	EPowerState_MAX                          = 8,
};

// Enum TheK30.EDrawPatrolExitReason
// NumValues: 0x0005
enum class EDrawPatrolExitReason : uint8
{
	None                                     = 0,
	Success                                  = 1,
	PatrolDenied                             = 2,
	PatrolCancel                             = 3,
	EDrawPatrolExitReason_MAX                = 4,
};

// Enum TheK30.EIdlePostStopOperation
// NumValues: 0x0003
enum class EIdlePostStopOperation : uint8
{
	None                                     = 0,
	TriggerUsualCooldown                     = 1,
	EIdlePostStopOperation_MAX               = 2,
};

// Enum TheK30.ETrailDirection
// NumValues: 0x0003
enum class ETrailDirection : uint8
{
	Forward                                  = 0,
	Backward                                 = 1,
	ETrailDirection_MAX                      = 2,
};

// Enum TheK30.EPatrolState
// NumValues: 0x0004
enum class EPatrolState : uint8
{
	None                                     = 0,
	StartingUp                               = 1,
	Patrolling                               = 2,
	EPatrolState_MAX                         = 3,
};

// Enum TheK30.EGuardHuntEndReason
// NumValues: 0x000B
enum class EGuardHuntEndReason : uint8
{
	TimerExpired                             = 0,
	GuardHitSurvivor                         = 1,
	SurvivorCapturedFlag                     = 2,
	UnhookedSurvivor                         = 3,
	KillerDamagedSurvivor                    = 4,
	GuardPulledSurvivorOutOfLocker           = 5,
	KillerPowerPrevented                     = 6,
	Interrupted                              = 7,
	SurvivorTeleportedAway                   = 8,
	UnexpectedError                          = 9,
	EGuardHuntEndReason_MAX                  = 10,
};

// ScriptStruct TheK30.ActivationState
// 0x0010 (0x0010 - 0x0000)
struct FActivationState final
{
public:
	class ADBDPlayer*                             HuntedSurvivor;                                    // 0x0000(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScaledFlagActivationTime;                          // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FActivationState) == 0x000008, "Wrong alignment on FActivationState");
static_assert(sizeof(FActivationState) == 0x000010, "Wrong size on FActivationState");
static_assert(offsetof(FActivationState, HuntedSurvivor) == 0x000000, "Member 'FActivationState::HuntedSurvivor' has a wrong offset!");
static_assert(offsetof(FActivationState, ScaledFlagActivationTime) == 0x000008, "Member 'FActivationState::ScaledFlagActivationTime' has a wrong offset!");

// ScriptStruct TheK30.PostDrawPatrolHasteApplier
// 0x0038 (0x0038 - 0x0000)
struct FPostDrawPatrolHasteApplier final
{
public:
	TSubclassOf<class UStatusEffect>              _hasteClass;                                       // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _hasteValue;                                       // 0x0008(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _hasteDurationByPathLength;                        // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FPostDrawPatrolHasteApplier) == 0x000008, "Wrong alignment on FPostDrawPatrolHasteApplier");
static_assert(sizeof(FPostDrawPatrolHasteApplier) == 0x000038, "Wrong size on FPostDrawPatrolHasteApplier");
static_assert(offsetof(FPostDrawPatrolHasteApplier, _hasteClass) == 0x000000, "Member 'FPostDrawPatrolHasteApplier::_hasteClass' has a wrong offset!");
static_assert(offsetof(FPostDrawPatrolHasteApplier, _hasteValue) == 0x000008, "Member 'FPostDrawPatrolHasteApplier::_hasteValue' has a wrong offset!");
static_assert(offsetof(FPostDrawPatrolHasteApplier, _hasteDurationByPathLength) == 0x000030, "Member 'FPostDrawPatrolHasteApplier::_hasteDurationByPathLength' has a wrong offset!");

// ScriptStruct TheK30.DrawPatrolSnappingHandler
// 0x0098 (0x0098 - 0x0000)
struct FDrawPatrolSnappingHandler final
{
public:
	struct FDBDTunableRowHandle                   _snappingDistance;                                 // 0x0000(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _previewSnappingTime;                              // 0x0028(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_50[0x48];                                      // 0x0050(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDrawPatrolSnappingHandler) == 0x000008, "Wrong alignment on FDrawPatrolSnappingHandler");
static_assert(sizeof(FDrawPatrolSnappingHandler) == 0x000098, "Wrong size on FDrawPatrolSnappingHandler");
static_assert(offsetof(FDrawPatrolSnappingHandler, _snappingDistance) == 0x000000, "Member 'FDrawPatrolSnappingHandler::_snappingDistance' has a wrong offset!");
static_assert(offsetof(FDrawPatrolSnappingHandler, _previewSnappingTime) == 0x000028, "Member 'FDrawPatrolSnappingHandler::_previewSnappingTime' has a wrong offset!");

// ScriptStruct TheK30.FloatingCameraHandler
// 0x0100 (0x0100 - 0x0000)
struct FFloatingCameraHandler final
{
public:
	struct FDBDTunableRowHandle                   _drawPathModeYawInputLimit;                        // 0x0000(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _floatingCameraMaxSpeed;                           // 0x0028(0x0080)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _floatingCameraAccelerationMultiplier;             // 0x00A8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _strafeMovementSpeedMultiplier;                    // 0x00D0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F8[0x8];                                       // 0x00F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFloatingCameraHandler) == 0x000008, "Wrong alignment on FFloatingCameraHandler");
static_assert(sizeof(FFloatingCameraHandler) == 0x000100, "Wrong size on FFloatingCameraHandler");
static_assert(offsetof(FFloatingCameraHandler, _drawPathModeYawInputLimit) == 0x000000, "Member 'FFloatingCameraHandler::_drawPathModeYawInputLimit' has a wrong offset!");
static_assert(offsetof(FFloatingCameraHandler, _floatingCameraMaxSpeed) == 0x000028, "Member 'FFloatingCameraHandler::_floatingCameraMaxSpeed' has a wrong offset!");
static_assert(offsetof(FFloatingCameraHandler, _floatingCameraAccelerationMultiplier) == 0x0000A8, "Member 'FFloatingCameraHandler::_floatingCameraAccelerationMultiplier' has a wrong offset!");
static_assert(offsetof(FFloatingCameraHandler, _strafeMovementSpeedMultiplier) == 0x0000D0, "Member 'FFloatingCameraHandler::_strafeMovementSpeedMultiplier' has a wrong offset!");

// ScriptStruct TheK30.GuardAddedProxy
// 0x0018 (0x0018 - 0x0000)
struct FGuardAddedProxy final
{
public:
	TSubclassOf<class AKnightGuard>               _applicableGuard;                                  // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8[0x10];                                       // 0x0008(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGuardAddedProxy) == 0x000008, "Wrong alignment on FGuardAddedProxy");
static_assert(sizeof(FGuardAddedProxy) == 0x000018, "Wrong size on FGuardAddedProxy");
static_assert(offsetof(FGuardAddedProxy, _applicableGuard) == 0x000000, "Member 'FGuardAddedProxy::_applicableGuard' has a wrong offset!");

// ScriptStruct TheK30.GuardInstanceContainer
// 0x0040 (0x0040 - 0x0000)
struct FGuardInstanceContainer final
{
public:
	class AKnightGuard*                           Instance;                                          // 0x0000(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x38];                                       // 0x0008(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGuardInstanceContainer) == 0x000008, "Wrong alignment on FGuardInstanceContainer");
static_assert(sizeof(FGuardInstanceContainer) == 0x000040, "Wrong size on FGuardInstanceContainer");
static_assert(offsetof(FGuardInstanceContainer, Instance) == 0x000000, "Member 'FGuardInstanceContainer::Instance' has a wrong offset!");

// ScriptStruct TheK30.StatusEffectApplier
// 0x0070 (0x0070 - 0x0000)
struct FStatusEffectApplier final
{
public:
	TArray<TSubclassOf<class UStatusEffect>>      _statusEffectClasses;                              // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	float                                         _lifetime;                                         // 0x0010(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _customParam;                                      // 0x0014(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _shouldDisplay;                                    // 0x0018(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_19[0x57];                                      // 0x0019(0x0057)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStatusEffectApplier) == 0x000008, "Wrong alignment on FStatusEffectApplier");
static_assert(sizeof(FStatusEffectApplier) == 0x000070, "Wrong size on FStatusEffectApplier");
static_assert(offsetof(FStatusEffectApplier, _statusEffectClasses) == 0x000000, "Member 'FStatusEffectApplier::_statusEffectClasses' has a wrong offset!");
static_assert(offsetof(FStatusEffectApplier, _lifetime) == 0x000010, "Member 'FStatusEffectApplier::_lifetime' has a wrong offset!");
static_assert(offsetof(FStatusEffectApplier, _customParam) == 0x000014, "Member 'FStatusEffectApplier::_customParam' has a wrong offset!");
static_assert(offsetof(FStatusEffectApplier, _shouldDisplay) == 0x000018, "Member 'FStatusEffectApplier::_shouldDisplay' has a wrong offset!");

// ScriptStruct TheK30.TrailSettings
// 0x0068 (0x0068 - 0x0000)
struct FTrailSettings final
{
public:
	struct FDBDTunableRowHandle                   MaximumDistanceBetweenVisualNodes;                 // 0x0000(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FDBDTunableRowHandle                   MinimumDistanceBetweenVisualNodesToDoSweepTest;    // 0x0028(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         CapsuleHalfHeight;                                 // 0x0050(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CapsuleRadius;                                     // 0x0054(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             CollisionChannel;                                  // 0x0058(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ATrailNode>                 _trailNodeClass;                                   // 0x0060(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTrailSettings) == 0x000008, "Wrong alignment on FTrailSettings");
static_assert(sizeof(FTrailSettings) == 0x000068, "Wrong size on FTrailSettings");
static_assert(offsetof(FTrailSettings, MaximumDistanceBetweenVisualNodes) == 0x000000, "Member 'FTrailSettings::MaximumDistanceBetweenVisualNodes' has a wrong offset!");
static_assert(offsetof(FTrailSettings, MinimumDistanceBetweenVisualNodesToDoSweepTest) == 0x000028, "Member 'FTrailSettings::MinimumDistanceBetweenVisualNodesToDoSweepTest' has a wrong offset!");
static_assert(offsetof(FTrailSettings, CapsuleHalfHeight) == 0x000050, "Member 'FTrailSettings::CapsuleHalfHeight' has a wrong offset!");
static_assert(offsetof(FTrailSettings, CapsuleRadius) == 0x000054, "Member 'FTrailSettings::CapsuleRadius' has a wrong offset!");
static_assert(offsetof(FTrailSettings, CollisionChannel) == 0x000058, "Member 'FTrailSettings::CollisionChannel' has a wrong offset!");
static_assert(offsetof(FTrailSettings, _trailNodeClass) == 0x000060, "Member 'FTrailSettings::_trailNodeClass' has a wrong offset!");

// ScriptStruct TheK30.TrailData
// 0x0030 (0x0030 - 0x0000)
struct FTrailData final
{
public:
	TArray<class ATrailNode*>                     _visualNodes;                                      // 0x0000(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<struct FVector>                        _navigationWaypoints;                              // 0x0010(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class AActor*                                 _owner;                                            // 0x0020(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isCompleted;                                      // 0x0028(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTrailData) == 0x000008, "Wrong alignment on FTrailData");
static_assert(sizeof(FTrailData) == 0x000030, "Wrong size on FTrailData");
static_assert(offsetof(FTrailData, _visualNodes) == 0x000000, "Member 'FTrailData::_visualNodes' has a wrong offset!");
static_assert(offsetof(FTrailData, _navigationWaypoints) == 0x000010, "Member 'FTrailData::_navigationWaypoints' has a wrong offset!");
static_assert(offsetof(FTrailData, _owner) == 0x000020, "Member 'FTrailData::_owner' has a wrong offset!");
static_assert(offsetof(FTrailData, _isCompleted) == 0x000028, "Member 'FTrailData::_isCompleted' has a wrong offset!");

}

