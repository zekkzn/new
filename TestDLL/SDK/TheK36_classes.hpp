#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: TheK36

#include "Basic.hpp"

#include "DeadByDaylight_structs.hpp"
#include "DeadByDaylight_classes.hpp"
#include "GameplayUtilities_classes.hpp"
#include "DBDBots_classes.hpp"
#include "DataTableUtilities_structs.hpp"
#include "DBDAnimation_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "Engine_classes.hpp"
#include "DBDSharedTypes_structs.hpp"
#include "DBDGameplay_classes.hpp"
#include "DBDInteraction_classes.hpp"
#include "TheK36_structs.hpp"
#include "GameplayTags_structs.hpp"
#include "StatSystem_structs.hpp"
#include "DBDCompetence_classes.hpp"
#include "AnimationUtilities_structs.hpp"
#include "DBDCosmetic_classes.hpp"


namespace SDK
{

// Class TheK36.K36PowerAddon16
// 0x0060 (0x0348 - 0x02E8)
class UK36PowerAddon16 final : public UItemAddon
{
public:
	TSubclassOf<class UStatusEffect>              _mangledStatusEffectClass;                         // 0x02E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _hemorrhageStatusEffectClass;                      // 0x02F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _mangledEffectLifetime;                            // 0x02F8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _hemorrhageEffectLifetime;                         // 0x0320(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K36PowerAddon16">();
	}
	static class UK36PowerAddon16* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK36PowerAddon16>();
	}
};
static_assert(alignof(UK36PowerAddon16) == 0x000008, "Wrong alignment on UK36PowerAddon16");
static_assert(sizeof(UK36PowerAddon16) == 0x000348, "Wrong size on UK36PowerAddon16");
static_assert(offsetof(UK36PowerAddon16, _mangledStatusEffectClass) == 0x0002E8, "Member 'UK36PowerAddon16::_mangledStatusEffectClass' has a wrong offset!");
static_assert(offsetof(UK36PowerAddon16, _hemorrhageStatusEffectClass) == 0x0002F0, "Member 'UK36PowerAddon16::_hemorrhageStatusEffectClass' has a wrong offset!");
static_assert(offsetof(UK36PowerAddon16, _mangledEffectLifetime) == 0x0002F8, "Member 'UK36PowerAddon16::_mangledEffectLifetime' has a wrong offset!");
static_assert(offsetof(UK36PowerAddon16, _hemorrhageEffectLifetime) == 0x000320, "Member 'UK36PowerAddon16::_hemorrhageEffectLifetime' has a wrong offset!");

// Class TheK36.AISkill_FindCollectable_K36TreasureChest
// 0x0128 (0x04B8 - 0x0390)
class UAISkill_FindCollectable_K36TreasureChest final : public UAISkill_FindCollectable_Searchable
{
public:
	struct FAITunableParameter                    AverageItemCountDifferenceWeight;                  // 0x0390(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    HighMagicItemCountWeightPenalty;                   // 0x03F0(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         HighMagicItemCountThreshold;                       // 0x0450(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_454[0x4];                                      // 0x0454(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAITunableParameter                    OpenedWeightBonus;                                 // 0x0458(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_FindCollectable_K36TreasureChest">();
	}
	static class UAISkill_FindCollectable_K36TreasureChest* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_FindCollectable_K36TreasureChest>();
	}
};
static_assert(alignof(UAISkill_FindCollectable_K36TreasureChest) == 0x000008, "Wrong alignment on UAISkill_FindCollectable_K36TreasureChest");
static_assert(sizeof(UAISkill_FindCollectable_K36TreasureChest) == 0x0004B8, "Wrong size on UAISkill_FindCollectable_K36TreasureChest");
static_assert(offsetof(UAISkill_FindCollectable_K36TreasureChest, AverageItemCountDifferenceWeight) == 0x000390, "Member 'UAISkill_FindCollectable_K36TreasureChest::AverageItemCountDifferenceWeight' has a wrong offset!");
static_assert(offsetof(UAISkill_FindCollectable_K36TreasureChest, HighMagicItemCountWeightPenalty) == 0x0003F0, "Member 'UAISkill_FindCollectable_K36TreasureChest::HighMagicItemCountWeightPenalty' has a wrong offset!");
static_assert(offsetof(UAISkill_FindCollectable_K36TreasureChest, HighMagicItemCountThreshold) == 0x000450, "Member 'UAISkill_FindCollectable_K36TreasureChest::HighMagicItemCountThreshold' has a wrong offset!");
static_assert(offsetof(UAISkill_FindCollectable_K36TreasureChest, OpenedWeightBonus) == 0x000458, "Member 'UAISkill_FindCollectable_K36TreasureChest::OpenedWeightBonus' has a wrong offset!");

// Class TheK36.K36PowerAddon17
// 0x0058 (0x0340 - 0x02E8)
class UK36PowerAddon17 final : public UItemAddon
{
public:
	TSubclassOf<class UStatusEffect>              _undetectableStatusEffectClass;                    // 0x02E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _undetectableEffectLifetime;                       // 0x02F0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TArray<struct FGameplayTag>                   _spellCooldownStateTags;                           // 0x0318(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class UStatusEffect*                          _authority_undetectableStatusEffect;               // 0x0328(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_330[0x10];                                     // 0x0330(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K36PowerAddon17">();
	}
	static class UK36PowerAddon17* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK36PowerAddon17>();
	}
};
static_assert(alignof(UK36PowerAddon17) == 0x000008, "Wrong alignment on UK36PowerAddon17");
static_assert(sizeof(UK36PowerAddon17) == 0x000340, "Wrong size on UK36PowerAddon17");
static_assert(offsetof(UK36PowerAddon17, _undetectableStatusEffectClass) == 0x0002E8, "Member 'UK36PowerAddon17::_undetectableStatusEffectClass' has a wrong offset!");
static_assert(offsetof(UK36PowerAddon17, _undetectableEffectLifetime) == 0x0002F0, "Member 'UK36PowerAddon17::_undetectableEffectLifetime' has a wrong offset!");
static_assert(offsetof(UK36PowerAddon17, _spellCooldownStateTags) == 0x000318, "Member 'UK36PowerAddon17::_spellCooldownStateTags' has a wrong offset!");
static_assert(offsetof(UK36PowerAddon17, _authority_undetectableStatusEffect) == 0x000328, "Member 'UK36PowerAddon17::_authority_undetectableStatusEffect' has a wrong offset!");

// Class TheK36.AISkill_FindInteractable_K36ArtifactInvisibleLocker
// 0x0308 (0x0610 - 0x0308)
class UAISkill_FindInteractable_K36ArtifactInvisibleLocker final : public UAISkill_FindInteractable
{
public:
	float                                         TriggerInvisibilityTime;                           // 0x0308(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30C[0x4];                                      // 0x030C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAITunableParameter                    AverageHookStageDifferenceWeight;                  // 0x0310(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    MaxValidLockerDistance;                            // 0x0370(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    MinimumRequiredGoalWeight;                         // 0x03D0(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    LastSurvivorWeight;                                // 0x0430(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    MaxClosestSurvivorDistance;                        // 0x0490(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    ClosestSurvivorInjuredWeightPenalty;               // 0x04F0(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    ClosestSurvivorMaxHookWeightPenalty;               // 0x0550(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    ClosestSurvivorDistanceMaxWeightPenalty;           // 0x05B0(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_FindInteractable_K36ArtifactInvisibleLocker">();
	}
	static class UAISkill_FindInteractable_K36ArtifactInvisibleLocker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_FindInteractable_K36ArtifactInvisibleLocker>();
	}
};
static_assert(alignof(UAISkill_FindInteractable_K36ArtifactInvisibleLocker) == 0x000008, "Wrong alignment on UAISkill_FindInteractable_K36ArtifactInvisibleLocker");
static_assert(sizeof(UAISkill_FindInteractable_K36ArtifactInvisibleLocker) == 0x000610, "Wrong size on UAISkill_FindInteractable_K36ArtifactInvisibleLocker");
static_assert(offsetof(UAISkill_FindInteractable_K36ArtifactInvisibleLocker, TriggerInvisibilityTime) == 0x000308, "Member 'UAISkill_FindInteractable_K36ArtifactInvisibleLocker::TriggerInvisibilityTime' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_K36ArtifactInvisibleLocker, AverageHookStageDifferenceWeight) == 0x000310, "Member 'UAISkill_FindInteractable_K36ArtifactInvisibleLocker::AverageHookStageDifferenceWeight' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_K36ArtifactInvisibleLocker, MaxValidLockerDistance) == 0x000370, "Member 'UAISkill_FindInteractable_K36ArtifactInvisibleLocker::MaxValidLockerDistance' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_K36ArtifactInvisibleLocker, MinimumRequiredGoalWeight) == 0x0003D0, "Member 'UAISkill_FindInteractable_K36ArtifactInvisibleLocker::MinimumRequiredGoalWeight' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_K36ArtifactInvisibleLocker, LastSurvivorWeight) == 0x000430, "Member 'UAISkill_FindInteractable_K36ArtifactInvisibleLocker::LastSurvivorWeight' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_K36ArtifactInvisibleLocker, MaxClosestSurvivorDistance) == 0x000490, "Member 'UAISkill_FindInteractable_K36ArtifactInvisibleLocker::MaxClosestSurvivorDistance' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_K36ArtifactInvisibleLocker, ClosestSurvivorInjuredWeightPenalty) == 0x0004F0, "Member 'UAISkill_FindInteractable_K36ArtifactInvisibleLocker::ClosestSurvivorInjuredWeightPenalty' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_K36ArtifactInvisibleLocker, ClosestSurvivorMaxHookWeightPenalty) == 0x000550, "Member 'UAISkill_FindInteractable_K36ArtifactInvisibleLocker::ClosestSurvivorMaxHookWeightPenalty' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_K36ArtifactInvisibleLocker, ClosestSurvivorDistanceMaxWeightPenalty) == 0x0005B0, "Member 'UAISkill_FindInteractable_K36ArtifactInvisibleLocker::ClosestSurvivorDistanceMaxWeightPenalty' has a wrong offset!");

// Class TheK36.K36PowerAddon18
// 0x0028 (0x0338 - 0x0310)
class UK36PowerAddon18 final : public UImposeStatusEffectOnEventAddon
{
public:
	struct FDBDTunableRowHandle                   _guaranteedMimicAmount;                            // 0x0310(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K36PowerAddon18">();
	}
	static class UK36PowerAddon18* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK36PowerAddon18>();
	}
};
static_assert(alignof(UK36PowerAddon18) == 0x000008, "Wrong alignment on UK36PowerAddon18");
static_assert(sizeof(UK36PowerAddon18) == 0x000338, "Wrong size on UK36PowerAddon18");
static_assert(offsetof(UK36PowerAddon18, _guaranteedMimicAmount) == 0x000310, "Member 'UK36PowerAddon18::_guaranteedMimicAmount' has a wrong offset!");

// Class TheK36.AISkill_FindInteractable_K36ArtifactInvisibleUnhook
// 0x0428 (0x0730 - 0x0308)
class UAISkill_FindInteractable_K36ArtifactInvisibleUnhook final : public UAISkill_FindInteractable
{
public:
	float                                         MaxLockerToHookDistance;                           // 0x0308(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinLockerToHookDistance;                           // 0x030C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxLockerToPathDistance;                           // 0x0310(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KillerAverageDistanceLerpSpeed;                    // 0x0314(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 UnhookInteractionID;                               // 0x0318(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    HookedAllyWeightAtMinDistance;                     // 0x0328(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    HookedAllyMaxDistance;                             // 0x0388(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    AllyDangerStateGoalWeight;                         // 0x03E8(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    MaxHookTimeGoalWeight;                             // 0x0448(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    HumanAllyHookedGoalWeight;                         // 0x04A8(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    IdealKillerAverageDistanceFromHook;                // 0x0508(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    MaxKillerAverageProximityWeight;                   // 0x0568(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    BotDangerStateGoalWeight;                          // 0x05C8(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    IncapacitatedAlliesGoalWeight;                     // 0x0628(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<TWeakObjectPtr<class ACamperPlayer>, float> _hookedSurvivorsDistances;                         // 0x0688(0x0050)(NativeAccessSpecifierPrivate)
	class UInteractor*                            _currentHookGoalInteractor;                        // 0x06D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6E0[0x50];                                     // 0x06E0(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_FindInteractable_K36ArtifactInvisibleUnhook">();
	}
	static class UAISkill_FindInteractable_K36ArtifactInvisibleUnhook* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_FindInteractable_K36ArtifactInvisibleUnhook>();
	}
};
static_assert(alignof(UAISkill_FindInteractable_K36ArtifactInvisibleUnhook) == 0x000008, "Wrong alignment on UAISkill_FindInteractable_K36ArtifactInvisibleUnhook");
static_assert(sizeof(UAISkill_FindInteractable_K36ArtifactInvisibleUnhook) == 0x000730, "Wrong size on UAISkill_FindInteractable_K36ArtifactInvisibleUnhook");
static_assert(offsetof(UAISkill_FindInteractable_K36ArtifactInvisibleUnhook, MaxLockerToHookDistance) == 0x000308, "Member 'UAISkill_FindInteractable_K36ArtifactInvisibleUnhook::MaxLockerToHookDistance' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_K36ArtifactInvisibleUnhook, MinLockerToHookDistance) == 0x00030C, "Member 'UAISkill_FindInteractable_K36ArtifactInvisibleUnhook::MinLockerToHookDistance' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_K36ArtifactInvisibleUnhook, MaxLockerToPathDistance) == 0x000310, "Member 'UAISkill_FindInteractable_K36ArtifactInvisibleUnhook::MaxLockerToPathDistance' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_K36ArtifactInvisibleUnhook, KillerAverageDistanceLerpSpeed) == 0x000314, "Member 'UAISkill_FindInteractable_K36ArtifactInvisibleUnhook::KillerAverageDistanceLerpSpeed' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_K36ArtifactInvisibleUnhook, UnhookInteractionID) == 0x000318, "Member 'UAISkill_FindInteractable_K36ArtifactInvisibleUnhook::UnhookInteractionID' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_K36ArtifactInvisibleUnhook, HookedAllyWeightAtMinDistance) == 0x000328, "Member 'UAISkill_FindInteractable_K36ArtifactInvisibleUnhook::HookedAllyWeightAtMinDistance' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_K36ArtifactInvisibleUnhook, HookedAllyMaxDistance) == 0x000388, "Member 'UAISkill_FindInteractable_K36ArtifactInvisibleUnhook::HookedAllyMaxDistance' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_K36ArtifactInvisibleUnhook, AllyDangerStateGoalWeight) == 0x0003E8, "Member 'UAISkill_FindInteractable_K36ArtifactInvisibleUnhook::AllyDangerStateGoalWeight' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_K36ArtifactInvisibleUnhook, MaxHookTimeGoalWeight) == 0x000448, "Member 'UAISkill_FindInteractable_K36ArtifactInvisibleUnhook::MaxHookTimeGoalWeight' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_K36ArtifactInvisibleUnhook, HumanAllyHookedGoalWeight) == 0x0004A8, "Member 'UAISkill_FindInteractable_K36ArtifactInvisibleUnhook::HumanAllyHookedGoalWeight' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_K36ArtifactInvisibleUnhook, IdealKillerAverageDistanceFromHook) == 0x000508, "Member 'UAISkill_FindInteractable_K36ArtifactInvisibleUnhook::IdealKillerAverageDistanceFromHook' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_K36ArtifactInvisibleUnhook, MaxKillerAverageProximityWeight) == 0x000568, "Member 'UAISkill_FindInteractable_K36ArtifactInvisibleUnhook::MaxKillerAverageProximityWeight' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_K36ArtifactInvisibleUnhook, BotDangerStateGoalWeight) == 0x0005C8, "Member 'UAISkill_FindInteractable_K36ArtifactInvisibleUnhook::BotDangerStateGoalWeight' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_K36ArtifactInvisibleUnhook, IncapacitatedAlliesGoalWeight) == 0x000628, "Member 'UAISkill_FindInteractable_K36ArtifactInvisibleUnhook::IncapacitatedAlliesGoalWeight' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_K36ArtifactInvisibleUnhook, _hookedSurvivorsDistances) == 0x000688, "Member 'UAISkill_FindInteractable_K36ArtifactInvisibleUnhook::_hookedSurvivorsDistances' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_K36ArtifactInvisibleUnhook, _currentHookGoalInteractor) == 0x0006D8, "Member 'UAISkill_FindInteractable_K36ArtifactInvisibleUnhook::_currentHookGoalInteractor' has a wrong offset!");

// Class TheK36.K36PowerChargePresentationItemProgressComponent
// 0x0000 (0x00B0 - 0x00B0)
class UK36PowerChargePresentationItemProgressComponent final : public UPresentationItemProgressComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K36PowerChargePresentationItemProgressComponent">();
	}
	static class UK36PowerChargePresentationItemProgressComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK36PowerChargePresentationItemProgressComponent>();
	}
};
static_assert(alignof(UK36PowerChargePresentationItemProgressComponent) == 0x000008, "Wrong alignment on UK36PowerChargePresentationItemProgressComponent");
static_assert(sizeof(UK36PowerChargePresentationItemProgressComponent) == 0x0000B0, "Wrong size on UK36PowerChargePresentationItemProgressComponent");

// Class TheK36.AISkill_FindInteractable_K36ArtifactTeleportationLocker
// 0x01E8 (0x04F0 - 0x0308)
class UAISkill_FindInteractable_K36ArtifactTeleportationLocker final : public UAISkill_FindInteractable
{
public:
	struct FAITunableParameter                    AverageHookStageDifferenceWeight;                  // 0x0308(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    PerMeterAwayWeight;                                // 0x0368(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    MinimumRequiredGoalWeight;                         // 0x03C8(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    LastSurvivorWeight;                                // 0x0428(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    MaxValidDistance;                                  // 0x0488(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         MinimumGeneratorRepairPercent;                     // 0x04E8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4EC[0x4];                                      // 0x04EC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_FindInteractable_K36ArtifactTeleportationLocker">();
	}
	static class UAISkill_FindInteractable_K36ArtifactTeleportationLocker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_FindInteractable_K36ArtifactTeleportationLocker>();
	}
};
static_assert(alignof(UAISkill_FindInteractable_K36ArtifactTeleportationLocker) == 0x000008, "Wrong alignment on UAISkill_FindInteractable_K36ArtifactTeleportationLocker");
static_assert(sizeof(UAISkill_FindInteractable_K36ArtifactTeleportationLocker) == 0x0004F0, "Wrong size on UAISkill_FindInteractable_K36ArtifactTeleportationLocker");
static_assert(offsetof(UAISkill_FindInteractable_K36ArtifactTeleportationLocker, AverageHookStageDifferenceWeight) == 0x000308, "Member 'UAISkill_FindInteractable_K36ArtifactTeleportationLocker::AverageHookStageDifferenceWeight' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_K36ArtifactTeleportationLocker, PerMeterAwayWeight) == 0x000368, "Member 'UAISkill_FindInteractable_K36ArtifactTeleportationLocker::PerMeterAwayWeight' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_K36ArtifactTeleportationLocker, MinimumRequiredGoalWeight) == 0x0003C8, "Member 'UAISkill_FindInteractable_K36ArtifactTeleportationLocker::MinimumRequiredGoalWeight' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_K36ArtifactTeleportationLocker, LastSurvivorWeight) == 0x000428, "Member 'UAISkill_FindInteractable_K36ArtifactTeleportationLocker::LastSurvivorWeight' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_K36ArtifactTeleportationLocker, MaxValidDistance) == 0x000488, "Member 'UAISkill_FindInteractable_K36ArtifactTeleportationLocker::MaxValidDistance' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_K36ArtifactTeleportationLocker, MinimumGeneratorRepairPercent) == 0x0004E8, "Member 'UAISkill_FindInteractable_K36ArtifactTeleportationLocker::MinimumGeneratorRepairPercent' has a wrong offset!");

// Class TheK36.K36PresentationPowerFadeOutComponent
// 0x0000 (0x00A8 - 0x00A8)
class UK36PresentationPowerFadeOutComponent final : public UPresentationPowerFadeComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K36PresentationPowerFadeOutComponent">();
	}
	static class UK36PresentationPowerFadeOutComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK36PresentationPowerFadeOutComponent>();
	}
};
static_assert(alignof(UK36PresentationPowerFadeOutComponent) == 0x000008, "Wrong alignment on UK36PresentationPowerFadeOutComponent");
static_assert(sizeof(UK36PresentationPowerFadeOutComponent) == 0x0000A8, "Wrong size on UK36PresentationPowerFadeOutComponent");

// Class TheK36.AISkill_Interaction_K36Invisible
// 0x0000 (0x0280 - 0x0280)
class UAISkill_Interaction_K36Invisible final : public UAISkill_Interaction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_Interaction_K36Invisible">();
	}
	static class UAISkill_Interaction_K36Invisible* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_Interaction_K36Invisible>();
	}
};
static_assert(alignof(UAISkill_Interaction_K36Invisible) == 0x000008, "Wrong alignment on UAISkill_Interaction_K36Invisible");
static_assert(sizeof(UAISkill_Interaction_K36Invisible) == 0x000280, "Wrong size on UAISkill_Interaction_K36Invisible");

// Class TheK36.K36AfterFlyVelocityCalculationStrategy
// 0x0078 (0x0120 - 0x00A8)
class UK36AfterFlyVelocityCalculationStrategy final : public UBaseCharacterVelocityCalculationStrategy
{
public:
	struct FDBDTunableRowHandle                   _brakingDeceleration;                              // 0x00A8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _friction;                                         // 0x00D0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _minimumVelocityToOverrideDecelerationValues;      // 0x00F8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K36AfterFlyVelocityCalculationStrategy">();
	}
	static class UK36AfterFlyVelocityCalculationStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK36AfterFlyVelocityCalculationStrategy>();
	}
};
static_assert(alignof(UK36AfterFlyVelocityCalculationStrategy) == 0x000008, "Wrong alignment on UK36AfterFlyVelocityCalculationStrategy");
static_assert(sizeof(UK36AfterFlyVelocityCalculationStrategy) == 0x000120, "Wrong size on UK36AfterFlyVelocityCalculationStrategy");
static_assert(offsetof(UK36AfterFlyVelocityCalculationStrategy, _brakingDeceleration) == 0x0000A8, "Member 'UK36AfterFlyVelocityCalculationStrategy::_brakingDeceleration' has a wrong offset!");
static_assert(offsetof(UK36AfterFlyVelocityCalculationStrategy, _friction) == 0x0000D0, "Member 'UK36AfterFlyVelocityCalculationStrategy::_friction' has a wrong offset!");
static_assert(offsetof(UK36AfterFlyVelocityCalculationStrategy, _minimumVelocityToOverrideDecelerationValues) == 0x0000F8, "Member 'UK36AfterFlyVelocityCalculationStrategy::_minimumVelocityToOverrideDecelerationValues' has a wrong offset!");

// Class TheK36.K36AnimInstance
// 0x0010 (0x0730 - 0x0720)
class UK36AnimInstance final : public UKillerAnimInstance
{
public:
	bool                                          _isSelectingSpell;                                 // 0x0720(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isChargingFlySpell;                               // 0x0721(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isFlySpellCharged;                                // 0x0722(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isFlying;                                         // 0x0723(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isEndingFly;                                      // 0x0724(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isChargingFOTDSpell;                              // 0x0725(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isFOTDSpellCharged;                               // 0x0726(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isActivatingFOTDSpell;                            // 0x0727(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isChargingDetectionSpell;                         // 0x0728(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isDetectionSpellCharged;                          // 0x0729(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isActivatingDetectionSpell;                       // 0x072A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isChargingMageHand;                               // 0x072B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isMageHandCharged;                                // 0x072C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isActivatingMageHandSpell;                        // 0x072D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_72E[0x2];                                      // 0x072E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K36AnimInstance">();
	}
	static class UK36AnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK36AnimInstance>();
	}
};
static_assert(alignof(UK36AnimInstance) == 0x000010, "Wrong alignment on UK36AnimInstance");
static_assert(sizeof(UK36AnimInstance) == 0x000730, "Wrong size on UK36AnimInstance");
static_assert(offsetof(UK36AnimInstance, _isSelectingSpell) == 0x000720, "Member 'UK36AnimInstance::_isSelectingSpell' has a wrong offset!");
static_assert(offsetof(UK36AnimInstance, _isChargingFlySpell) == 0x000721, "Member 'UK36AnimInstance::_isChargingFlySpell' has a wrong offset!");
static_assert(offsetof(UK36AnimInstance, _isFlySpellCharged) == 0x000722, "Member 'UK36AnimInstance::_isFlySpellCharged' has a wrong offset!");
static_assert(offsetof(UK36AnimInstance, _isFlying) == 0x000723, "Member 'UK36AnimInstance::_isFlying' has a wrong offset!");
static_assert(offsetof(UK36AnimInstance, _isEndingFly) == 0x000724, "Member 'UK36AnimInstance::_isEndingFly' has a wrong offset!");
static_assert(offsetof(UK36AnimInstance, _isChargingFOTDSpell) == 0x000725, "Member 'UK36AnimInstance::_isChargingFOTDSpell' has a wrong offset!");
static_assert(offsetof(UK36AnimInstance, _isFOTDSpellCharged) == 0x000726, "Member 'UK36AnimInstance::_isFOTDSpellCharged' has a wrong offset!");
static_assert(offsetof(UK36AnimInstance, _isActivatingFOTDSpell) == 0x000727, "Member 'UK36AnimInstance::_isActivatingFOTDSpell' has a wrong offset!");
static_assert(offsetof(UK36AnimInstance, _isChargingDetectionSpell) == 0x000728, "Member 'UK36AnimInstance::_isChargingDetectionSpell' has a wrong offset!");
static_assert(offsetof(UK36AnimInstance, _isDetectionSpellCharged) == 0x000729, "Member 'UK36AnimInstance::_isDetectionSpellCharged' has a wrong offset!");
static_assert(offsetof(UK36AnimInstance, _isActivatingDetectionSpell) == 0x00072A, "Member 'UK36AnimInstance::_isActivatingDetectionSpell' has a wrong offset!");
static_assert(offsetof(UK36AnimInstance, _isChargingMageHand) == 0x00072B, "Member 'UK36AnimInstance::_isChargingMageHand' has a wrong offset!");
static_assert(offsetof(UK36AnimInstance, _isMageHandCharged) == 0x00072C, "Member 'UK36AnimInstance::_isMageHandCharged' has a wrong offset!");
static_assert(offsetof(UK36AnimInstance, _isActivatingMageHandSpell) == 0x00072D, "Member 'UK36AnimInstance::_isActivatingMageHandSpell' has a wrong offset!");

// Class TheK36.K36ArtifactPowerComponent
// 0x0180 (0x0228 - 0x00A8)
class UK36ArtifactPowerComponent : public UActorComponent
{
public:
	struct FDBDTunableRowHandle                   _onLockerOpenedSmokeEffectTimeWindow;              // 0x00A8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_D0[0x20];                                      // 0x00D0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class ALocker>>         _cachedInGameLockers;                              // 0x00F0(0x0010)(Net, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<TWeakObjectPtr<class ALocker>>         _basementLockers;                                  // 0x0100(0x0010)(Net, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_110[0x8];                                      // 0x0110(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _basementBoxShrinkSize;                            // 0x0118(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_11C[0x4];                                      // 0x011C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _killerInstinctDuration;                           // 0x0120(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _brokenStatusEffectDuration;                       // 0x0148(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _killerInstinctStatusEffectClass;                  // 0x0170(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _brokenStatusEffectClass;                          // 0x0178(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class AK36MagicItemArtifact>   _artifact;                                         // 0x0180(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           _lockerShimmerOutlineColorForSurvivor;             // 0x0188(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_198[0x8];                                      // 0x0198(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _maxDistanceForShimmerEffect;                      // 0x01A0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1C8[0x60];                                     // 0x01C8(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnLevelReadyToPlay();
	void Cosmetic_ApplySmokeEffectOnLocker(class ALocker* Locker);
	void Cosmetic_ApplySmokeVfxOnOpenedLocker(class ALocker* Locker, EPlayerTeam PlayerTeam);
	void OnRep_Artifact();
	void OnSurvivorDamageStateChanged(ECamperDamageState OldDamageState, ECamperDamageState NewDamageState);

	class ACamperPlayer* GetOwningSurvivor() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K36ArtifactPowerComponent">();
	}
	static class UK36ArtifactPowerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK36ArtifactPowerComponent>();
	}
};
static_assert(alignof(UK36ArtifactPowerComponent) == 0x000008, "Wrong alignment on UK36ArtifactPowerComponent");
static_assert(sizeof(UK36ArtifactPowerComponent) == 0x000228, "Wrong size on UK36ArtifactPowerComponent");
static_assert(offsetof(UK36ArtifactPowerComponent, _onLockerOpenedSmokeEffectTimeWindow) == 0x0000A8, "Member 'UK36ArtifactPowerComponent::_onLockerOpenedSmokeEffectTimeWindow' has a wrong offset!");
static_assert(offsetof(UK36ArtifactPowerComponent, _cachedInGameLockers) == 0x0000F0, "Member 'UK36ArtifactPowerComponent::_cachedInGameLockers' has a wrong offset!");
static_assert(offsetof(UK36ArtifactPowerComponent, _basementLockers) == 0x000100, "Member 'UK36ArtifactPowerComponent::_basementLockers' has a wrong offset!");
static_assert(offsetof(UK36ArtifactPowerComponent, _basementBoxShrinkSize) == 0x000118, "Member 'UK36ArtifactPowerComponent::_basementBoxShrinkSize' has a wrong offset!");
static_assert(offsetof(UK36ArtifactPowerComponent, _killerInstinctDuration) == 0x000120, "Member 'UK36ArtifactPowerComponent::_killerInstinctDuration' has a wrong offset!");
static_assert(offsetof(UK36ArtifactPowerComponent, _brokenStatusEffectDuration) == 0x000148, "Member 'UK36ArtifactPowerComponent::_brokenStatusEffectDuration' has a wrong offset!");
static_assert(offsetof(UK36ArtifactPowerComponent, _killerInstinctStatusEffectClass) == 0x000170, "Member 'UK36ArtifactPowerComponent::_killerInstinctStatusEffectClass' has a wrong offset!");
static_assert(offsetof(UK36ArtifactPowerComponent, _brokenStatusEffectClass) == 0x000178, "Member 'UK36ArtifactPowerComponent::_brokenStatusEffectClass' has a wrong offset!");
static_assert(offsetof(UK36ArtifactPowerComponent, _artifact) == 0x000180, "Member 'UK36ArtifactPowerComponent::_artifact' has a wrong offset!");
static_assert(offsetof(UK36ArtifactPowerComponent, _lockerShimmerOutlineColorForSurvivor) == 0x000188, "Member 'UK36ArtifactPowerComponent::_lockerShimmerOutlineColorForSurvivor' has a wrong offset!");
static_assert(offsetof(UK36ArtifactPowerComponent, _maxDistanceForShimmerEffect) == 0x0001A0, "Member 'UK36ArtifactPowerComponent::_maxDistanceForShimmerEffect' has a wrong offset!");

// Class TheK36.K36ArtifactInvisibilityPowerComponent
// 0x0070 (0x0298 - 0x0228)
class UK36ArtifactInvisibilityPowerComponent final : public UK36ArtifactPowerComponent
{
public:
	TSubclassOf<class UK36InvisibilityStatusEffect> _invisibilityStatusEffectClass;                    // 0x0228(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UK36InvisibilityStatusEffect*           _invisibilityStatusEffect;                         // 0x0230(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _invisibilityStatusEffectDuration;                 // 0x0238(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_260[0x38];                                     // 0x0260(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnSurvivorDamageStateChanged(ECamperDamageState OldState, ECamperDamageState NewState);
	void Multi_TriggerLockerVFXEffects(class ALocker* Locker);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K36ArtifactInvisibilityPowerComponent">();
	}
	static class UK36ArtifactInvisibilityPowerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK36ArtifactInvisibilityPowerComponent>();
	}
};
static_assert(alignof(UK36ArtifactInvisibilityPowerComponent) == 0x000008, "Wrong alignment on UK36ArtifactInvisibilityPowerComponent");
static_assert(sizeof(UK36ArtifactInvisibilityPowerComponent) == 0x000298, "Wrong size on UK36ArtifactInvisibilityPowerComponent");
static_assert(offsetof(UK36ArtifactInvisibilityPowerComponent, _invisibilityStatusEffectClass) == 0x000228, "Member 'UK36ArtifactInvisibilityPowerComponent::_invisibilityStatusEffectClass' has a wrong offset!");
static_assert(offsetof(UK36ArtifactInvisibilityPowerComponent, _invisibilityStatusEffect) == 0x000230, "Member 'UK36ArtifactInvisibilityPowerComponent::_invisibilityStatusEffect' has a wrong offset!");
static_assert(offsetof(UK36ArtifactInvisibilityPowerComponent, _invisibilityStatusEffectDuration) == 0x000238, "Member 'UK36ArtifactInvisibilityPowerComponent::_invisibilityStatusEffectDuration' has a wrong offset!");

// Class TheK36.K36ArtifactTeleportationPowerComponent
// 0x00D8 (0x0300 - 0x0228)
class UK36ArtifactTeleportationPowerComponent final : public UK36ArtifactPowerComponent
{
public:
	struct FDBDTunableRowHandle                   _timeLockerAuraActive;                             // 0x0228(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _minDistanceFromLocker;                            // 0x0250(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_278[0x8];                                      // 0x0278(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _loudNoiseMaxAudibleDistance;                      // 0x0280(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FLinearColor                           _lockerOutlineColorForSurvivor;                    // 0x02A8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B8[0x48];                                     // 0x02B8(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnPlayerFastEnteredLocker(const struct FGameplayTag& GameplayTag, const struct FGameEventData& GameEventData);
	void Authority_TriggerExitFromLocker();
	void Multicast_TriggerExitFromLocker(class ALocker* InitialLocker, class ALocker* TargetLocker);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K36ArtifactTeleportationPowerComponent">();
	}
	static class UK36ArtifactTeleportationPowerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK36ArtifactTeleportationPowerComponent>();
	}
};
static_assert(alignof(UK36ArtifactTeleportationPowerComponent) == 0x000008, "Wrong alignment on UK36ArtifactTeleportationPowerComponent");
static_assert(sizeof(UK36ArtifactTeleportationPowerComponent) == 0x000300, "Wrong size on UK36ArtifactTeleportationPowerComponent");
static_assert(offsetof(UK36ArtifactTeleportationPowerComponent, _timeLockerAuraActive) == 0x000228, "Member 'UK36ArtifactTeleportationPowerComponent::_timeLockerAuraActive' has a wrong offset!");
static_assert(offsetof(UK36ArtifactTeleportationPowerComponent, _minDistanceFromLocker) == 0x000250, "Member 'UK36ArtifactTeleportationPowerComponent::_minDistanceFromLocker' has a wrong offset!");
static_assert(offsetof(UK36ArtifactTeleportationPowerComponent, _loudNoiseMaxAudibleDistance) == 0x000280, "Member 'UK36ArtifactTeleportationPowerComponent::_loudNoiseMaxAudibleDistance' has a wrong offset!");
static_assert(offsetof(UK36ArtifactTeleportationPowerComponent, _lockerOutlineColorForSurvivor) == 0x0002A8, "Member 'UK36ArtifactTeleportationPowerComponent::_lockerOutlineColorForSurvivor' has a wrong offset!");

// Class TheK36.K36BaseMoriInteraction
// 0x0010 (0x09E0 - 0x09D0)
#pragma pack(push, 0x1)
class alignas(0x10) UK36BaseMoriInteraction : public UKillInteractionDefinition
{
public:
	uint8                                         Pad_9D0[0x8];                                      // 0x09D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K36BaseMoriInteraction">();
	}
	static class UK36BaseMoriInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK36BaseMoriInteraction>();
	}
};
#pragma pack(pop)
static_assert(alignof(UK36BaseMoriInteraction) == 0x000010, "Wrong alignment on UK36BaseMoriInteraction");
static_assert(sizeof(UK36BaseMoriInteraction) == 0x0009E0, "Wrong size on UK36BaseMoriInteraction");

// Class TheK36.K36MageHandBaseState
// 0x0038 (0x0088 - 0x0050)
class UK36MageHandBaseState : public UBaseReplicatedState
{
public:
	bool                                          _authority_registerOnPalletStateChanged;           // 0x0050(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _authority_disableMageEndOnPalletBreak;            // 0x0051(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _resetMageHandStatePredictedStateStackOnEnter;     // 0x0052(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _disableMageHandOnPalletStun;                      // 0x0053(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_54[0x34];                                      // 0x0054(0x0034)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K36MageHandBaseState">();
	}
	static class UK36MageHandBaseState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK36MageHandBaseState>();
	}
};
static_assert(alignof(UK36MageHandBaseState) == 0x000008, "Wrong alignment on UK36MageHandBaseState");
static_assert(sizeof(UK36MageHandBaseState) == 0x000088, "Wrong size on UK36MageHandBaseState");
static_assert(offsetof(UK36MageHandBaseState, _authority_registerOnPalletStateChanged) == 0x000050, "Member 'UK36MageHandBaseState::_authority_registerOnPalletStateChanged' has a wrong offset!");
static_assert(offsetof(UK36MageHandBaseState, _authority_disableMageEndOnPalletBreak) == 0x000051, "Member 'UK36MageHandBaseState::_authority_disableMageEndOnPalletBreak' has a wrong offset!");
static_assert(offsetof(UK36MageHandBaseState, _resetMageHandStatePredictedStateStackOnEnter) == 0x000052, "Member 'UK36MageHandBaseState::_resetMageHandStatePredictedStateStackOnEnter' has a wrong offset!");
static_assert(offsetof(UK36MageHandBaseState, _disableMageHandOnPalletStun) == 0x000053, "Member 'UK36MageHandBaseState::_disableMageHandOnPalletStun' has a wrong offset!");

// Class TheK36.K36BlockPalletInteractionsState
// 0x0000 (0x0088 - 0x0088)
class UK36BlockPalletInteractionsState : public UK36MageHandBaseState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K36BlockPalletInteractionsState">();
	}
	static class UK36BlockPalletInteractionsState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK36BlockPalletInteractionsState>();
	}
};
static_assert(alignof(UK36BlockPalletInteractionsState) == 0x000008, "Wrong alignment on UK36BlockPalletInteractionsState");
static_assert(sizeof(UK36BlockPalletInteractionsState) == 0x000088, "Wrong size on UK36BlockPalletInteractionsState");

// Class TheK36.K36CheatComponent
// 0x0000 (0x00A8 - 0x00A8)
class UK36CheatComponent final : public UDLCCheatComponent
{
public:
	void DBD_K36EquipMagicItemOnLocalSurvivor(const class FString& MagicItemTypeName, const class FString& SpellCounterType, const class FString& LocalPlayerId);
	void DBD_K36ShowSpectralEntityCollisions(bool ShowCollisions, bool AlsoShowNearMissCollisions);

	void DBD_K36FillTreasureChestsWithLegendaryMagicItems(const class FString& MagicItemClassName) const;
	void DBD_K36PrintMagicItemInventoryContents() const;
	void DBD_K36ResetAllTreasureChests() const;
	void DBD_K36ResetOpenTreasureChests() const;
	void DBD_K36SetForcedDiceValueOnAllTreasureChests(int32 ForcedRollValue) const;
	void DBD_K36SpawnEyeOfVecnaOnLocallyControlledSurvivor(const class FString& LocalPlayerId) const;
	void DBD_K36SpawnHandOfVecnaOnLocallyControlledSurvivor(const class FString& LocalPlayerId) const;
	void DBD_K36TriggerDiceRollOnSurvivor(int32 Result) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K36CheatComponent">();
	}
	static class UK36CheatComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK36CheatComponent>();
	}
};
static_assert(alignof(UK36CheatComponent) == 0x000008, "Wrong alignment on UK36CheatComponent");
static_assert(sizeof(UK36CheatComponent) == 0x0000A8, "Wrong size on UK36CheatComponent");

// Class TheK36.K36CollectItemFromTreasureChestInteraction
// 0x0030 (0x07E0 - 0x07B0)
class UK36CollectItemFromTreasureChestInteraction : public UCollectItemInteraction
{
public:
	FMulticastInlineDelegateProperty_             OnMagicItemCollectedFromChest;                     // 0x07A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnShittyItemCollectedFromChest;                    // 0x07B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C8[0x18];                                     // 0x07C8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K36CollectItemFromTreasureChestInteraction">();
	}
	static class UK36CollectItemFromTreasureChestInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK36CollectItemFromTreasureChestInteraction>();
	}
};
static_assert(alignof(UK36CollectItemFromTreasureChestInteraction) == 0x000010, "Wrong alignment on UK36CollectItemFromTreasureChestInteraction");
static_assert(sizeof(UK36CollectItemFromTreasureChestInteraction) == 0x0007E0, "Wrong size on UK36CollectItemFromTreasureChestInteraction");
static_assert(offsetof(UK36CollectItemFromTreasureChestInteraction, OnMagicItemCollectedFromChest) == 0x0007A8, "Member 'UK36CollectItemFromTreasureChestInteraction::OnMagicItemCollectedFromChest' has a wrong offset!");
static_assert(offsetof(UK36CollectItemFromTreasureChestInteraction, OnShittyItemCollectedFromChest) == 0x0007B8, "Member 'UK36CollectItemFromTreasureChestInteraction::OnShittyItemCollectedFromChest' has a wrong offset!");

// Class TheK36.K36D20Dice
// 0x0010 (0x02B0 - 0x02A0)
class AK36D20Dice final : public AActor
{
public:
	class USceneComponent*                        _rootComponent;                                    // 0x02A0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   _staticMesh;                                       // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void Cosmetic_PlayDiceRoll(int32 DiceRollResult, EK36DiceRollOutcome DiceRollOutcome);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K36D20Dice">();
	}
	static class AK36D20Dice* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK36D20Dice>();
	}
};
static_assert(alignof(AK36D20Dice) == 0x000008, "Wrong alignment on AK36D20Dice");
static_assert(sizeof(AK36D20Dice) == 0x0002B0, "Wrong size on AK36D20Dice");
static_assert(offsetof(AK36D20Dice, _rootComponent) == 0x0002A0, "Member 'AK36D20Dice::_rootComponent' has a wrong offset!");
static_assert(offsetof(AK36D20Dice, _staticMesh) == 0x0002A8, "Member 'AK36D20Dice::_staticMesh' has a wrong offset!");

// Class TheK36.K36D20VisualDiceRollerComponent
// 0x0040 (0x00E8 - 0x00A8)
class UK36D20VisualDiceRollerComponent final : public UActorComponent
{
public:
	TSubclassOf<class AK36D20Dice>                _diceClass;                                        // 0x00A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AK36D20Dice*                            _playerDice;                                       // 0x00B0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                _relativeLocationFromCamera;                       // 0x00B8(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                _attachedToCameraScale;                            // 0x00D0(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K36D20VisualDiceRollerComponent">();
	}
	static class UK36D20VisualDiceRollerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK36D20VisualDiceRollerComponent>();
	}
};
static_assert(alignof(UK36D20VisualDiceRollerComponent) == 0x000008, "Wrong alignment on UK36D20VisualDiceRollerComponent");
static_assert(sizeof(UK36D20VisualDiceRollerComponent) == 0x0000E8, "Wrong size on UK36D20VisualDiceRollerComponent");
static_assert(offsetof(UK36D20VisualDiceRollerComponent, _diceClass) == 0x0000A8, "Member 'UK36D20VisualDiceRollerComponent::_diceClass' has a wrong offset!");
static_assert(offsetof(UK36D20VisualDiceRollerComponent, _playerDice) == 0x0000B0, "Member 'UK36D20VisualDiceRollerComponent::_playerDice' has a wrong offset!");
static_assert(offsetof(UK36D20VisualDiceRollerComponent, _relativeLocationFromCamera) == 0x0000B8, "Member 'UK36D20VisualDiceRollerComponent::_relativeLocationFromCamera' has a wrong offset!");
static_assert(offsetof(UK36D20VisualDiceRollerComponent, _attachedToCameraScale) == 0x0000D0, "Member 'UK36D20VisualDiceRollerComponent::_attachedToCameraScale' has a wrong offset!");

// Class TheK36.K36SpellInteraction
// 0x0580 (0x0E40 - 0x08C0)
#pragma pack(push, 0x1)
class alignas(0x10) UK36SpellInteraction : public UChargeableInteractionDefinition
{
public:
	uint8                                         Pad_8C0[0x18];                                     // 0x08C0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _chargeSpellTime;                                  // 0x08D8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _isChargingSpellStateTag;                          // 0x0900(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _isSpellChargedStateTag;                           // 0x090C(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _isActivatingSpellStateTag;                        // 0x0918(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _isSpellOnNonCancelledCooldownStateTag;            // 0x0924(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _spellChargeStartGameEvent;                        // 0x0930(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _spellTriggeredGameEvent;                          // 0x093C(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _activationTime;                                   // 0x0948(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _activatedExitDuration;                            // 0x0970(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _cancelExitDuration;                               // 0x0998(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FTunableStat                           _initialSpellCooldown;                             // 0x09C0(0x0080)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FTunableStat                           _activatedSpellCooldownTime;                       // 0x0A40(0x0080)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _cancelledSpellCooldownTime;                       // 0x0AC0(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_AE8[0x30];                                     // 0x0AE8(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class ASlasherPlayer>          _owningKiller;                                     // 0x0B18(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _endInteractionOnSpellActivated;                   // 0x0B20(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B21[0x7];                                      // 0x0B21(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FK36SpellActivationData                _spellActivationData;                              // 0x0B28(0x0010)(Net, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B38[0x8];                                      // 0x0B38(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _cooldownPreventionThresholdInSeconds;             // 0x0B40(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _cooldownReductionAfterSuccessfullBasicAttack;     // 0x0B68(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class UChargeableComponent*                   _replicatedChargeableComponent;                    // 0x0B90(0x0008)(ExportObject, Net, ZeroConstructor, InstancedReference, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UK36SpellData*                          _spellData;                                        // 0x0B98(0x0008)(Net, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_BA0[0x18];                                     // 0x0BA0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<struct FK36SpellSpeedCurveTypeData>      _speedCurvesData;                                  // 0x0BB8(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C08[0x230];                                    // 0x0C08(0x0230)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnIntroCompleted();
	void OnRep_OwningKiller();
	void OnRep_ReplicatedChargeableComponent();
	void OnRep_SpellActivationData(const struct FK36SpellActivationData& PreviousActivationData);
	void Server_ActivateSpell(class ASlasherPlayer* Killer, class UObject* CustomObjectParameter);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K36SpellInteraction">();
	}
	static class UK36SpellInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK36SpellInteraction>();
	}
};
#pragma pack(pop)
static_assert(alignof(UK36SpellInteraction) == 0x000010, "Wrong alignment on UK36SpellInteraction");
static_assert(sizeof(UK36SpellInteraction) == 0x000E40, "Wrong size on UK36SpellInteraction");
static_assert(offsetof(UK36SpellInteraction, _chargeSpellTime) == 0x0008D8, "Member 'UK36SpellInteraction::_chargeSpellTime' has a wrong offset!");
static_assert(offsetof(UK36SpellInteraction, _isChargingSpellStateTag) == 0x000900, "Member 'UK36SpellInteraction::_isChargingSpellStateTag' has a wrong offset!");
static_assert(offsetof(UK36SpellInteraction, _isSpellChargedStateTag) == 0x00090C, "Member 'UK36SpellInteraction::_isSpellChargedStateTag' has a wrong offset!");
static_assert(offsetof(UK36SpellInteraction, _isActivatingSpellStateTag) == 0x000918, "Member 'UK36SpellInteraction::_isActivatingSpellStateTag' has a wrong offset!");
static_assert(offsetof(UK36SpellInteraction, _isSpellOnNonCancelledCooldownStateTag) == 0x000924, "Member 'UK36SpellInteraction::_isSpellOnNonCancelledCooldownStateTag' has a wrong offset!");
static_assert(offsetof(UK36SpellInteraction, _spellChargeStartGameEvent) == 0x000930, "Member 'UK36SpellInteraction::_spellChargeStartGameEvent' has a wrong offset!");
static_assert(offsetof(UK36SpellInteraction, _spellTriggeredGameEvent) == 0x00093C, "Member 'UK36SpellInteraction::_spellTriggeredGameEvent' has a wrong offset!");
static_assert(offsetof(UK36SpellInteraction, _activationTime) == 0x000948, "Member 'UK36SpellInteraction::_activationTime' has a wrong offset!");
static_assert(offsetof(UK36SpellInteraction, _activatedExitDuration) == 0x000970, "Member 'UK36SpellInteraction::_activatedExitDuration' has a wrong offset!");
static_assert(offsetof(UK36SpellInteraction, _cancelExitDuration) == 0x000998, "Member 'UK36SpellInteraction::_cancelExitDuration' has a wrong offset!");
static_assert(offsetof(UK36SpellInteraction, _initialSpellCooldown) == 0x0009C0, "Member 'UK36SpellInteraction::_initialSpellCooldown' has a wrong offset!");
static_assert(offsetof(UK36SpellInteraction, _activatedSpellCooldownTime) == 0x000A40, "Member 'UK36SpellInteraction::_activatedSpellCooldownTime' has a wrong offset!");
static_assert(offsetof(UK36SpellInteraction, _cancelledSpellCooldownTime) == 0x000AC0, "Member 'UK36SpellInteraction::_cancelledSpellCooldownTime' has a wrong offset!");
static_assert(offsetof(UK36SpellInteraction, _owningKiller) == 0x000B18, "Member 'UK36SpellInteraction::_owningKiller' has a wrong offset!");
static_assert(offsetof(UK36SpellInteraction, _endInteractionOnSpellActivated) == 0x000B20, "Member 'UK36SpellInteraction::_endInteractionOnSpellActivated' has a wrong offset!");
static_assert(offsetof(UK36SpellInteraction, _spellActivationData) == 0x000B28, "Member 'UK36SpellInteraction::_spellActivationData' has a wrong offset!");
static_assert(offsetof(UK36SpellInteraction, _cooldownPreventionThresholdInSeconds) == 0x000B40, "Member 'UK36SpellInteraction::_cooldownPreventionThresholdInSeconds' has a wrong offset!");
static_assert(offsetof(UK36SpellInteraction, _cooldownReductionAfterSuccessfullBasicAttack) == 0x000B68, "Member 'UK36SpellInteraction::_cooldownReductionAfterSuccessfullBasicAttack' has a wrong offset!");
static_assert(offsetof(UK36SpellInteraction, _replicatedChargeableComponent) == 0x000B90, "Member 'UK36SpellInteraction::_replicatedChargeableComponent' has a wrong offset!");
static_assert(offsetof(UK36SpellInteraction, _spellData) == 0x000B98, "Member 'UK36SpellInteraction::_spellData' has a wrong offset!");
static_assert(offsetof(UK36SpellInteraction, _speedCurvesData) == 0x000BB8, "Member 'UK36SpellInteraction::_speedCurvesData' has a wrong offset!");

// Class TheK36.K36DetectionSpellInteraction
// 0x0150 (0x0F90 - 0x0E40)
class UK36DetectionSpellInteraction final : public UK36SpellInteraction
{
public:
	struct FDBDTunableRowHandle                   _spawnDistanceFromKiller;                          // 0x0E38(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _trajectoryPreviewLength;                          // 0x0E60(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _trajectoryPreviewWidth;                           // 0x0E88(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _trajectoryPreviewHeight;                          // 0x0EB0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TSubclassOf<class AK36DispellingSphere>       _dispellingSphereClass;                            // 0x0ED8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _timeToGetControlsBack;                            // 0x0EE0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _pitchYawScalingAfterLaunchingSphere;              // 0x0EE4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AK36DispellingSphere*                   _dispellingSphere;                                 // 0x0EE8(0x0008)(Net, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_EF0[0x48];                                     // 0x0EF0(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _hasLaunchedSphere;                                // 0x0F38(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F39[0x57];                                     // 0x0F39(0x0057)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Server_RequestSphereLaunch(class ASlasherPlayer* Killer, const struct FVector& SphereLocation, const struct FRotator& LaunchDirection);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K36DetectionSpellInteraction">();
	}
	static class UK36DetectionSpellInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK36DetectionSpellInteraction>();
	}
};
static_assert(alignof(UK36DetectionSpellInteraction) == 0x000010, "Wrong alignment on UK36DetectionSpellInteraction");
static_assert(sizeof(UK36DetectionSpellInteraction) == 0x000F90, "Wrong size on UK36DetectionSpellInteraction");
static_assert(offsetof(UK36DetectionSpellInteraction, _spawnDistanceFromKiller) == 0x000E38, "Member 'UK36DetectionSpellInteraction::_spawnDistanceFromKiller' has a wrong offset!");
static_assert(offsetof(UK36DetectionSpellInteraction, _trajectoryPreviewLength) == 0x000E60, "Member 'UK36DetectionSpellInteraction::_trajectoryPreviewLength' has a wrong offset!");
static_assert(offsetof(UK36DetectionSpellInteraction, _trajectoryPreviewWidth) == 0x000E88, "Member 'UK36DetectionSpellInteraction::_trajectoryPreviewWidth' has a wrong offset!");
static_assert(offsetof(UK36DetectionSpellInteraction, _trajectoryPreviewHeight) == 0x000EB0, "Member 'UK36DetectionSpellInteraction::_trajectoryPreviewHeight' has a wrong offset!");
static_assert(offsetof(UK36DetectionSpellInteraction, _dispellingSphereClass) == 0x000ED8, "Member 'UK36DetectionSpellInteraction::_dispellingSphereClass' has a wrong offset!");
static_assert(offsetof(UK36DetectionSpellInteraction, _timeToGetControlsBack) == 0x000EE0, "Member 'UK36DetectionSpellInteraction::_timeToGetControlsBack' has a wrong offset!");
static_assert(offsetof(UK36DetectionSpellInteraction, _pitchYawScalingAfterLaunchingSphere) == 0x000EE4, "Member 'UK36DetectionSpellInteraction::_pitchYawScalingAfterLaunchingSphere' has a wrong offset!");
static_assert(offsetof(UK36DetectionSpellInteraction, _dispellingSphere) == 0x000EE8, "Member 'UK36DetectionSpellInteraction::_dispellingSphere' has a wrong offset!");
static_assert(offsetof(UK36DetectionSpellInteraction, _hasLaunchedSphere) == 0x000F38, "Member 'UK36DetectionSpellInteraction::_hasLaunchedSphere' has a wrong offset!");

// Class TheK36.K36DetectionSpellKillerInstinctStatusEffect
// 0x0090 (0x0410 - 0x0380)
class UK36DetectionSpellKillerInstinctStatusEffect final : public UKillerInstinctStatusEffect
{
public:
	struct FTunableStat                           _killerInstinctLingerDuration;                     // 0x0380(0x0080)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_400[0x10];                                     // 0x0400(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetLingeringDuration() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K36DetectionSpellKillerInstinctStatusEffect">();
	}
	static class UK36DetectionSpellKillerInstinctStatusEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK36DetectionSpellKillerInstinctStatusEffect>();
	}
};
static_assert(alignof(UK36DetectionSpellKillerInstinctStatusEffect) == 0x000008, "Wrong alignment on UK36DetectionSpellKillerInstinctStatusEffect");
static_assert(sizeof(UK36DetectionSpellKillerInstinctStatusEffect) == 0x000410, "Wrong size on UK36DetectionSpellKillerInstinctStatusEffect");
static_assert(offsetof(UK36DetectionSpellKillerInstinctStatusEffect, _killerInstinctLingerDuration) == 0x000380, "Member 'UK36DetectionSpellKillerInstinctStatusEffect::_killerInstinctLingerDuration' has a wrong offset!");

// Class TheK36.K36DetectionSphereDangerPredictionComponent
// 0x0020 (0x0130 - 0x0110)
class UK36DetectionSphereDangerPredictionComponent final : public UDBDDangerPredictionComponent
{
public:
	float                                         _sphereRadiusMargin;                               // 0x0110(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_114[0x1C];                                     // 0x0114(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K36DetectionSphereDangerPredictionComponent">();
	}
	static class UK36DetectionSphereDangerPredictionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK36DetectionSphereDangerPredictionComponent>();
	}
};
static_assert(alignof(UK36DetectionSphereDangerPredictionComponent) == 0x000008, "Wrong alignment on UK36DetectionSphereDangerPredictionComponent");
static_assert(sizeof(UK36DetectionSphereDangerPredictionComponent) == 0x000130, "Wrong size on UK36DetectionSphereDangerPredictionComponent");
static_assert(offsetof(UK36DetectionSphereDangerPredictionComponent, _sphereRadiusMargin) == 0x000110, "Member 'UK36DetectionSphereDangerPredictionComponent::_sphereRadiusMargin' has a wrong offset!");

// Class TheK36.K36DetectionSphereOutlineUpdateStrategy
// 0x0008 (0x0150 - 0x0148)
class UK36DetectionSphereOutlineUpdateStrategy final : public USourceBasedOutlineUpdateStrategy
{
public:
	uint8                                         Pad_148[0x8];                                      // 0x0148(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K36DetectionSphereOutlineUpdateStrategy">();
	}
	static class UK36DetectionSphereOutlineUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK36DetectionSphereOutlineUpdateStrategy>();
	}
};
static_assert(alignof(UK36DetectionSphereOutlineUpdateStrategy) == 0x000008, "Wrong alignment on UK36DetectionSphereOutlineUpdateStrategy");
static_assert(sizeof(UK36DetectionSphereOutlineUpdateStrategy) == 0x000150, "Wrong size on UK36DetectionSphereOutlineUpdateStrategy");

// Class TheK36.K36DisableMagicItemsStatusEffect
// 0x0048 (0x03C8 - 0x0380)
class UK36DisableMagicItemsStatusEffect final : public UStatusEffect
{
public:
	struct FDBDTunableRowHandle                   _lingerTimeAfterLeavingDetectionZone;              // 0x0380(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3A8[0x10];                                     // 0x03A8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameplayTag>                   _stateTagsRequiredForStatusEffectActivation;       // 0x03B8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K36DisableMagicItemsStatusEffect">();
	}
	static class UK36DisableMagicItemsStatusEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK36DisableMagicItemsStatusEffect>();
	}
};
static_assert(alignof(UK36DisableMagicItemsStatusEffect) == 0x000008, "Wrong alignment on UK36DisableMagicItemsStatusEffect");
static_assert(sizeof(UK36DisableMagicItemsStatusEffect) == 0x0003C8, "Wrong size on UK36DisableMagicItemsStatusEffect");
static_assert(offsetof(UK36DisableMagicItemsStatusEffect, _lingerTimeAfterLeavingDetectionZone) == 0x000380, "Member 'UK36DisableMagicItemsStatusEffect::_lingerTimeAfterLeavingDetectionZone' has a wrong offset!");
static_assert(offsetof(UK36DisableMagicItemsStatusEffect, _stateTagsRequiredForStatusEffectActivation) == 0x0003B8, "Member 'UK36DisableMagicItemsStatusEffect::_stateTagsRequiredForStatusEffectActivation' has a wrong offset!");

// Class TheK36.K36DispellingSphere
// 0x02F8 (0x0598 - 0x02A0)
class AK36DispellingSphere final : public AActor
{
public:
	uint8                                         Pad_2A0[0x20];                                     // 0x02A0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        _rootComponent;                                    // 0x02C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   _staticMeshComponent;                              // 0x02C8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USphereComponent*                       _survivorDetectionStartComponent;                  // 0x02D0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USphereComponent*                       _survivorDetectionEndComponent;                    // 0x02D8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDBDOutlineComponent*                   _outlineComponent;                                 // 0x02E0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UK36DetectionSphereOutlineUpdateStrategy* _outlineStrategy;                                  // 0x02E8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkComponent*                           _akComponent;                                      // 0x02F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UK36DetectionSphereDangerPredictionComponent* _dangerPredictionComponent;                        // 0x02F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTunableStat                           _maximumSpeed;                                     // 0x0300(0x0080)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _activeStateDuration;                              // 0x0380(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _disappearingDuration;                             // 0x03A8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _velocityMultiplierCurve;                          // 0x03D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   _killerAttachmentSocketName;                       // 0x03D8(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3E4[0x4];                                      // 0x03E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UK36DispellingSphereStatusEffect> _dispellingSphereStatusEffectClass;                // 0x03E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UK36DispellingSphereStatusEffect*> _dispellingSphereStatusEffects;                    // 0x03F0(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class ACamperPlayer*>                  _survivorsInArea;                                  // 0x0400(0x0010)(Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPrivate)
	uint8                                         Pad_410[0x10];                                     // 0x0410(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	EK36DetectionSphereState                      _state;                                            // 0x0420(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_421[0x3F];                                     // 0x0421(0x003F)(Fixing Size After Last Property [ Dumper-7 ])
	class UGameplayTagContainerComponent*         _objectState;                                      // 0x0460(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _survivorDetectionEndRadiusSizeIncrease;           // 0x0468(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_46C[0x10];                                     // 0x046C(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _initialVelocitySpeedDecrease;                     // 0x047C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_480[0x18];                                     // 0x0480(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class ASlasherPlayer>          _cachedKiller;                                     // 0x0498(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSet<struct FK36DetectionSphereSizeData>      _stateSizeData;                                    // 0x04A0(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4F0[0xA8];                                     // 0x04F0(0x00A8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnSurvivorDetectionEnd(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void Authority_OnSurvivorDetectionStart(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void Cosmetic_OnStateChanged(EK36DetectionSphereState NewState, EK36DetectionSphereState PreviousState);
	void Cosmetic_RadiusUpdated(float NewRadiusValue);
	void Cosmetic_SetVisibility(bool IsVisible);
	void OnLocallyObservedPawnChanged();
	void OnRep_CachedKiller();
	void OnRep_State(EK36DetectionSphereState PreviousState);
	void OnRep_SurvivorsInArea();

	EK36DetectionSphereState GetState() const;
	bool GetVisibility() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K36DispellingSphere">();
	}
	static class AK36DispellingSphere* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK36DispellingSphere>();
	}
};
static_assert(alignof(AK36DispellingSphere) == 0x000008, "Wrong alignment on AK36DispellingSphere");
static_assert(sizeof(AK36DispellingSphere) == 0x000598, "Wrong size on AK36DispellingSphere");
static_assert(offsetof(AK36DispellingSphere, _rootComponent) == 0x0002C0, "Member 'AK36DispellingSphere::_rootComponent' has a wrong offset!");
static_assert(offsetof(AK36DispellingSphere, _staticMeshComponent) == 0x0002C8, "Member 'AK36DispellingSphere::_staticMeshComponent' has a wrong offset!");
static_assert(offsetof(AK36DispellingSphere, _survivorDetectionStartComponent) == 0x0002D0, "Member 'AK36DispellingSphere::_survivorDetectionStartComponent' has a wrong offset!");
static_assert(offsetof(AK36DispellingSphere, _survivorDetectionEndComponent) == 0x0002D8, "Member 'AK36DispellingSphere::_survivorDetectionEndComponent' has a wrong offset!");
static_assert(offsetof(AK36DispellingSphere, _outlineComponent) == 0x0002E0, "Member 'AK36DispellingSphere::_outlineComponent' has a wrong offset!");
static_assert(offsetof(AK36DispellingSphere, _outlineStrategy) == 0x0002E8, "Member 'AK36DispellingSphere::_outlineStrategy' has a wrong offset!");
static_assert(offsetof(AK36DispellingSphere, _akComponent) == 0x0002F0, "Member 'AK36DispellingSphere::_akComponent' has a wrong offset!");
static_assert(offsetof(AK36DispellingSphere, _dangerPredictionComponent) == 0x0002F8, "Member 'AK36DispellingSphere::_dangerPredictionComponent' has a wrong offset!");
static_assert(offsetof(AK36DispellingSphere, _maximumSpeed) == 0x000300, "Member 'AK36DispellingSphere::_maximumSpeed' has a wrong offset!");
static_assert(offsetof(AK36DispellingSphere, _activeStateDuration) == 0x000380, "Member 'AK36DispellingSphere::_activeStateDuration' has a wrong offset!");
static_assert(offsetof(AK36DispellingSphere, _disappearingDuration) == 0x0003A8, "Member 'AK36DispellingSphere::_disappearingDuration' has a wrong offset!");
static_assert(offsetof(AK36DispellingSphere, _velocityMultiplierCurve) == 0x0003D0, "Member 'AK36DispellingSphere::_velocityMultiplierCurve' has a wrong offset!");
static_assert(offsetof(AK36DispellingSphere, _killerAttachmentSocketName) == 0x0003D8, "Member 'AK36DispellingSphere::_killerAttachmentSocketName' has a wrong offset!");
static_assert(offsetof(AK36DispellingSphere, _dispellingSphereStatusEffectClass) == 0x0003E8, "Member 'AK36DispellingSphere::_dispellingSphereStatusEffectClass' has a wrong offset!");
static_assert(offsetof(AK36DispellingSphere, _dispellingSphereStatusEffects) == 0x0003F0, "Member 'AK36DispellingSphere::_dispellingSphereStatusEffects' has a wrong offset!");
static_assert(offsetof(AK36DispellingSphere, _survivorsInArea) == 0x000400, "Member 'AK36DispellingSphere::_survivorsInArea' has a wrong offset!");
static_assert(offsetof(AK36DispellingSphere, _state) == 0x000420, "Member 'AK36DispellingSphere::_state' has a wrong offset!");
static_assert(offsetof(AK36DispellingSphere, _objectState) == 0x000460, "Member 'AK36DispellingSphere::_objectState' has a wrong offset!");
static_assert(offsetof(AK36DispellingSphere, _survivorDetectionEndRadiusSizeIncrease) == 0x000468, "Member 'AK36DispellingSphere::_survivorDetectionEndRadiusSizeIncrease' has a wrong offset!");
static_assert(offsetof(AK36DispellingSphere, _initialVelocitySpeedDecrease) == 0x00047C, "Member 'AK36DispellingSphere::_initialVelocitySpeedDecrease' has a wrong offset!");
static_assert(offsetof(AK36DispellingSphere, _cachedKiller) == 0x000498, "Member 'AK36DispellingSphere::_cachedKiller' has a wrong offset!");
static_assert(offsetof(AK36DispellingSphere, _stateSizeData) == 0x0004A0, "Member 'AK36DispellingSphere::_stateSizeData' has a wrong offset!");

// Class TheK36.K36DispellingSphereStatusEffect
// 0x00C8 (0x0448 - 0x0380)
class UK36DispellingSphereStatusEffect final : public UStatusEffect
{
public:
	struct FDBDTunableRowHandle                   _screamDuration;                                   // 0x0380(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _exhaustionStatusEffectClass;                      // 0x03A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _brokenStatusEffectClass;                          // 0x03B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _exhaustedStatusEffectLifetime;                    // 0x03B8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _brokenStatusEffectLifetime;                       // 0x03E0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TArray<TSubclassOf<class UStatusEffect>>      _childStatusEffectClasses;                         // 0x0408(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<class UStatusEffect*>                  _childStatusEffects;                               // 0x0418(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_428[0x20];                                     // 0x0428(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K36DispellingSphereStatusEffect">();
	}
	static class UK36DispellingSphereStatusEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK36DispellingSphereStatusEffect>();
	}
};
static_assert(alignof(UK36DispellingSphereStatusEffect) == 0x000008, "Wrong alignment on UK36DispellingSphereStatusEffect");
static_assert(sizeof(UK36DispellingSphereStatusEffect) == 0x000448, "Wrong size on UK36DispellingSphereStatusEffect");
static_assert(offsetof(UK36DispellingSphereStatusEffect, _screamDuration) == 0x000380, "Member 'UK36DispellingSphereStatusEffect::_screamDuration' has a wrong offset!");
static_assert(offsetof(UK36DispellingSphereStatusEffect, _exhaustionStatusEffectClass) == 0x0003A8, "Member 'UK36DispellingSphereStatusEffect::_exhaustionStatusEffectClass' has a wrong offset!");
static_assert(offsetof(UK36DispellingSphereStatusEffect, _brokenStatusEffectClass) == 0x0003B0, "Member 'UK36DispellingSphereStatusEffect::_brokenStatusEffectClass' has a wrong offset!");
static_assert(offsetof(UK36DispellingSphereStatusEffect, _exhaustedStatusEffectLifetime) == 0x0003B8, "Member 'UK36DispellingSphereStatusEffect::_exhaustedStatusEffectLifetime' has a wrong offset!");
static_assert(offsetof(UK36DispellingSphereStatusEffect, _brokenStatusEffectLifetime) == 0x0003E0, "Member 'UK36DispellingSphereStatusEffect::_brokenStatusEffectLifetime' has a wrong offset!");
static_assert(offsetof(UK36DispellingSphereStatusEffect, _childStatusEffectClasses) == 0x000408, "Member 'UK36DispellingSphereStatusEffect::_childStatusEffectClasses' has a wrong offset!");
static_assert(offsetof(UK36DispellingSphereStatusEffect, _childStatusEffects) == 0x000418, "Member 'UK36DispellingSphereStatusEffect::_childStatusEffects' has a wrong offset!");

// Class TheK36.K36DnDManagerComponent
// 0x01F0 (0x0298 - 0x00A8)
class UK36DnDManagerComponent final : public UKillerSpecificGameStateComponent
{
public:
	TArray<struct FK36SurvivorMimicEscapesData>   _survivorsMimicEscapesData;                        // 0x00A8(0x0010)(Net, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FK36MagicItemClassData>         _magicItemClasses;                                 // 0x00B8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TArray<struct FK36ShittyItem>                 _shittyItemData;                                   // 0x00C8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TArray<class UK36SpellCounterData*>           _spellCounterData;                                 // 0x00D8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _maxValueOfShittyItem;                             // 0x00E8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _defaultMaxNumberOfMimics;                         // 0x0110(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _minRollValueToIncreaseItemVariety;                // 0x0138(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _minRollValueEnsuringNewItemOrSpellCounterToPlayer; // 0x0160(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _minimumAmountOfMimics;                            // 0x0188(0x0080)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _artifactSpawnPercentageCurve;                     // 0x0208(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         _numberOfAdditionalChances;                        // 0x0210(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_214[0x4];                                      // 0x0214(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AK36MagicItem*>                  _authority_spawnedMagicItems;                      // 0x0218(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class AK36MagicItemArtifact*>          _authority_spawnedMagicItemArtifacts;              // 0x0228(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class ASlasherPlayer>          _associatedKiller;                                 // 0x0238(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_240[0x58];                                     // 0x0240(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnLevelReadyToPlay();
	void OnRep_AssociatedKiller();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K36DnDManagerComponent">();
	}
	static class UK36DnDManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK36DnDManagerComponent>();
	}
};
static_assert(alignof(UK36DnDManagerComponent) == 0x000008, "Wrong alignment on UK36DnDManagerComponent");
static_assert(sizeof(UK36DnDManagerComponent) == 0x000298, "Wrong size on UK36DnDManagerComponent");
static_assert(offsetof(UK36DnDManagerComponent, _survivorsMimicEscapesData) == 0x0000A8, "Member 'UK36DnDManagerComponent::_survivorsMimicEscapesData' has a wrong offset!");
static_assert(offsetof(UK36DnDManagerComponent, _magicItemClasses) == 0x0000B8, "Member 'UK36DnDManagerComponent::_magicItemClasses' has a wrong offset!");
static_assert(offsetof(UK36DnDManagerComponent, _shittyItemData) == 0x0000C8, "Member 'UK36DnDManagerComponent::_shittyItemData' has a wrong offset!");
static_assert(offsetof(UK36DnDManagerComponent, _spellCounterData) == 0x0000D8, "Member 'UK36DnDManagerComponent::_spellCounterData' has a wrong offset!");
static_assert(offsetof(UK36DnDManagerComponent, _maxValueOfShittyItem) == 0x0000E8, "Member 'UK36DnDManagerComponent::_maxValueOfShittyItem' has a wrong offset!");
static_assert(offsetof(UK36DnDManagerComponent, _defaultMaxNumberOfMimics) == 0x000110, "Member 'UK36DnDManagerComponent::_defaultMaxNumberOfMimics' has a wrong offset!");
static_assert(offsetof(UK36DnDManagerComponent, _minRollValueToIncreaseItemVariety) == 0x000138, "Member 'UK36DnDManagerComponent::_minRollValueToIncreaseItemVariety' has a wrong offset!");
static_assert(offsetof(UK36DnDManagerComponent, _minRollValueEnsuringNewItemOrSpellCounterToPlayer) == 0x000160, "Member 'UK36DnDManagerComponent::_minRollValueEnsuringNewItemOrSpellCounterToPlayer' has a wrong offset!");
static_assert(offsetof(UK36DnDManagerComponent, _minimumAmountOfMimics) == 0x000188, "Member 'UK36DnDManagerComponent::_minimumAmountOfMimics' has a wrong offset!");
static_assert(offsetof(UK36DnDManagerComponent, _artifactSpawnPercentageCurve) == 0x000208, "Member 'UK36DnDManagerComponent::_artifactSpawnPercentageCurve' has a wrong offset!");
static_assert(offsetof(UK36DnDManagerComponent, _numberOfAdditionalChances) == 0x000210, "Member 'UK36DnDManagerComponent::_numberOfAdditionalChances' has a wrong offset!");
static_assert(offsetof(UK36DnDManagerComponent, _authority_spawnedMagicItems) == 0x000218, "Member 'UK36DnDManagerComponent::_authority_spawnedMagicItems' has a wrong offset!");
static_assert(offsetof(UK36DnDManagerComponent, _authority_spawnedMagicItemArtifacts) == 0x000228, "Member 'UK36DnDManagerComponent::_authority_spawnedMagicItemArtifacts' has a wrong offset!");
static_assert(offsetof(UK36DnDManagerComponent, _associatedKiller) == 0x000238, "Member 'UK36DnDManagerComponent::_associatedKiller' has a wrong offset!");

// Class TheK36.K36EscapeFromMimicChestInteraction
// 0x0150 (0x0A10 - 0x08C0)
class UK36EscapeFromMimicChestInteraction final : public UChargeableInteractionDefinition
{
public:
	uint8                                         Pad_8C0[0x8];                                      // 0x08C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _skillCheckWarningTime;                            // 0x08C8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _numSkillChecksToEscape;                           // 0x08F0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _numberOfTimesEscapingMimicBeforeScoreAmountDecrease; // 0x0918(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _reducedScorePercentage;                           // 0x0940(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _bitAnimationDuration;                             // 0x0968(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FAnimationMontageDescriptor            _mimicGrabMontageID;                               // 0x0990(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FAnimationMontageDescriptor            _mimicInjureSurvivorAnimationID;                   // 0x09B0(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FAnimationMontageDescriptor            _mimicReleasesSurvivorAnimationID;                 // 0x09D0(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	bool                                          _hasFailedSkillCheck;                              // 0x09F0(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_9F1[0xF];                                      // 0x09F1(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _hasSufferedHealthStateChangeNonRelatedToMimic;    // 0x0A00(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A01[0xF];                                      // 0x0A01(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnSurvivorDamageStateChanged(ECamperDamageState OldDamageState, ECamperDamageState NewDamageState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K36EscapeFromMimicChestInteraction">();
	}
	static class UK36EscapeFromMimicChestInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK36EscapeFromMimicChestInteraction>();
	}
};
static_assert(alignof(UK36EscapeFromMimicChestInteraction) == 0x000010, "Wrong alignment on UK36EscapeFromMimicChestInteraction");
static_assert(sizeof(UK36EscapeFromMimicChestInteraction) == 0x000A10, "Wrong size on UK36EscapeFromMimicChestInteraction");
static_assert(offsetof(UK36EscapeFromMimicChestInteraction, _skillCheckWarningTime) == 0x0008C8, "Member 'UK36EscapeFromMimicChestInteraction::_skillCheckWarningTime' has a wrong offset!");
static_assert(offsetof(UK36EscapeFromMimicChestInteraction, _numSkillChecksToEscape) == 0x0008F0, "Member 'UK36EscapeFromMimicChestInteraction::_numSkillChecksToEscape' has a wrong offset!");
static_assert(offsetof(UK36EscapeFromMimicChestInteraction, _numberOfTimesEscapingMimicBeforeScoreAmountDecrease) == 0x000918, "Member 'UK36EscapeFromMimicChestInteraction::_numberOfTimesEscapingMimicBeforeScoreAmountDecrease' has a wrong offset!");
static_assert(offsetof(UK36EscapeFromMimicChestInteraction, _reducedScorePercentage) == 0x000940, "Member 'UK36EscapeFromMimicChestInteraction::_reducedScorePercentage' has a wrong offset!");
static_assert(offsetof(UK36EscapeFromMimicChestInteraction, _bitAnimationDuration) == 0x000968, "Member 'UK36EscapeFromMimicChestInteraction::_bitAnimationDuration' has a wrong offset!");
static_assert(offsetof(UK36EscapeFromMimicChestInteraction, _mimicGrabMontageID) == 0x000990, "Member 'UK36EscapeFromMimicChestInteraction::_mimicGrabMontageID' has a wrong offset!");
static_assert(offsetof(UK36EscapeFromMimicChestInteraction, _mimicInjureSurvivorAnimationID) == 0x0009B0, "Member 'UK36EscapeFromMimicChestInteraction::_mimicInjureSurvivorAnimationID' has a wrong offset!");
static_assert(offsetof(UK36EscapeFromMimicChestInteraction, _mimicReleasesSurvivorAnimationID) == 0x0009D0, "Member 'UK36EscapeFromMimicChestInteraction::_mimicReleasesSurvivorAnimationID' has a wrong offset!");
static_assert(offsetof(UK36EscapeFromMimicChestInteraction, _hasFailedSkillCheck) == 0x0009F0, "Member 'UK36EscapeFromMimicChestInteraction::_hasFailedSkillCheck' has a wrong offset!");
static_assert(offsetof(UK36EscapeFromMimicChestInteraction, _hasSufferedHealthStateChangeNonRelatedToMimic) == 0x000A00, "Member 'UK36EscapeFromMimicChestInteraction::_hasSufferedHealthStateChangeNonRelatedToMimic' has a wrong offset!");

// Class TheK36.K36FlightOfTheDamnedSpellInteraction
// 0x0250 (0x1090 - 0x0E40)
class UK36FlightOfTheDamnedSpellInteraction final : public UK36SpellInteraction
{
public:
	struct FDBDTunableRowHandle                   _chargeMinPitchValue;                              // 0x0E38(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _chargeMaxPitchValue;                              // 0x0E60(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _pitchScaleValue;                                  // 0x0E88(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _numberSpectralEntitiesPopulationAmount;           // 0x0EB0(0x0080)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _spawnDistanceFromKiller;                          // 0x0F30(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _angleBetweenSpectralEntities;                     // 0x0F58(0x0080)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _trajectoryPreviewLength;                          // 0x0FD8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _trajectoryPreviewWidth;                           // 0x1000(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _trajectoryPreviewHeightOffset;                    // 0x1028(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TSubclassOf<class AK36FOTDSpectralEntity>     _spectralEntityClass;                              // 0x1050(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class AK36FOTDSpectralEntity*>         _spectralEntities;                                 // 0x1058(0x0010)(Net, ZeroConstructor, Transient, RepNotify, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1068[0x28];                                    // 0x1068(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_SpectralEntities();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K36FlightOfTheDamnedSpellInteraction">();
	}
	static class UK36FlightOfTheDamnedSpellInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK36FlightOfTheDamnedSpellInteraction>();
	}
};
static_assert(alignof(UK36FlightOfTheDamnedSpellInteraction) == 0x000010, "Wrong alignment on UK36FlightOfTheDamnedSpellInteraction");
static_assert(sizeof(UK36FlightOfTheDamnedSpellInteraction) == 0x001090, "Wrong size on UK36FlightOfTheDamnedSpellInteraction");
static_assert(offsetof(UK36FlightOfTheDamnedSpellInteraction, _chargeMinPitchValue) == 0x000E38, "Member 'UK36FlightOfTheDamnedSpellInteraction::_chargeMinPitchValue' has a wrong offset!");
static_assert(offsetof(UK36FlightOfTheDamnedSpellInteraction, _chargeMaxPitchValue) == 0x000E60, "Member 'UK36FlightOfTheDamnedSpellInteraction::_chargeMaxPitchValue' has a wrong offset!");
static_assert(offsetof(UK36FlightOfTheDamnedSpellInteraction, _pitchScaleValue) == 0x000E88, "Member 'UK36FlightOfTheDamnedSpellInteraction::_pitchScaleValue' has a wrong offset!");
static_assert(offsetof(UK36FlightOfTheDamnedSpellInteraction, _numberSpectralEntitiesPopulationAmount) == 0x000EB0, "Member 'UK36FlightOfTheDamnedSpellInteraction::_numberSpectralEntitiesPopulationAmount' has a wrong offset!");
static_assert(offsetof(UK36FlightOfTheDamnedSpellInteraction, _spawnDistanceFromKiller) == 0x000F30, "Member 'UK36FlightOfTheDamnedSpellInteraction::_spawnDistanceFromKiller' has a wrong offset!");
static_assert(offsetof(UK36FlightOfTheDamnedSpellInteraction, _angleBetweenSpectralEntities) == 0x000F58, "Member 'UK36FlightOfTheDamnedSpellInteraction::_angleBetweenSpectralEntities' has a wrong offset!");
static_assert(offsetof(UK36FlightOfTheDamnedSpellInteraction, _trajectoryPreviewLength) == 0x000FD8, "Member 'UK36FlightOfTheDamnedSpellInteraction::_trajectoryPreviewLength' has a wrong offset!");
static_assert(offsetof(UK36FlightOfTheDamnedSpellInteraction, _trajectoryPreviewWidth) == 0x001000, "Member 'UK36FlightOfTheDamnedSpellInteraction::_trajectoryPreviewWidth' has a wrong offset!");
static_assert(offsetof(UK36FlightOfTheDamnedSpellInteraction, _trajectoryPreviewHeightOffset) == 0x001028, "Member 'UK36FlightOfTheDamnedSpellInteraction::_trajectoryPreviewHeightOffset' has a wrong offset!");
static_assert(offsetof(UK36FlightOfTheDamnedSpellInteraction, _spectralEntityClass) == 0x001050, "Member 'UK36FlightOfTheDamnedSpellInteraction::_spectralEntityClass' has a wrong offset!");
static_assert(offsetof(UK36FlightOfTheDamnedSpellInteraction, _spectralEntities) == 0x001058, "Member 'UK36FlightOfTheDamnedSpellInteraction::_spectralEntities' has a wrong offset!");

// Class TheK36.K36FlyingCollisionDisablerStatusEffects
// 0x0088 (0x0408 - 0x0380)
class UK36FlyingCollisionDisablerStatusEffects final : public UStatusEffect
{
public:
	uint8                                         Pad_380[0x68];                                     // 0x0380(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UIgnoreWindowsCollisionsComponent> _ignoreWindowsCollisionsComponentClass;            // 0x03E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UIgnoreWindowsCollisionsComponent*      _ignoreWindowsCollisionsComponent;                 // 0x03F0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UIgnorePalletsCollisionsComponent> _ignorePalletsCollisionsComponentClass;            // 0x03F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UIgnorePalletsCollisionsComponent*      _ignorePalletsCollisionsComponent;                 // 0x0400(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K36FlyingCollisionDisablerStatusEffects">();
	}
	static class UK36FlyingCollisionDisablerStatusEffects* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK36FlyingCollisionDisablerStatusEffects>();
	}
};
static_assert(alignof(UK36FlyingCollisionDisablerStatusEffects) == 0x000008, "Wrong alignment on UK36FlyingCollisionDisablerStatusEffects");
static_assert(sizeof(UK36FlyingCollisionDisablerStatusEffects) == 0x000408, "Wrong size on UK36FlyingCollisionDisablerStatusEffects");
static_assert(offsetof(UK36FlyingCollisionDisablerStatusEffects, _ignoreWindowsCollisionsComponentClass) == 0x0003E8, "Member 'UK36FlyingCollisionDisablerStatusEffects::_ignoreWindowsCollisionsComponentClass' has a wrong offset!");
static_assert(offsetof(UK36FlyingCollisionDisablerStatusEffects, _ignoreWindowsCollisionsComponent) == 0x0003F0, "Member 'UK36FlyingCollisionDisablerStatusEffects::_ignoreWindowsCollisionsComponent' has a wrong offset!");
static_assert(offsetof(UK36FlyingCollisionDisablerStatusEffects, _ignorePalletsCollisionsComponentClass) == 0x0003F8, "Member 'UK36FlyingCollisionDisablerStatusEffects::_ignorePalletsCollisionsComponentClass' has a wrong offset!");
static_assert(offsetof(UK36FlyingCollisionDisablerStatusEffects, _ignorePalletsCollisionsComponent) == 0x000400, "Member 'UK36FlyingCollisionDisablerStatusEffects::_ignorePalletsCollisionsComponent' has a wrong offset!");

// Class TheK36.K36FlySpellInteraction
// 0x0410 (0x1250 - 0x0E40)
class UK36FlySpellInteraction final : public UK36SpellInteraction
{
public:
	TSubclassOf<class UK36AfterFlyVelocityCalculationStrategy> _afterFlyAdditiveStrategyClass;                    // 0x0E38(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UK36AfterFlyVelocityCalculationStrategy* _afterFlyAdditiveStrategy;                         // 0x0E40(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UK36FlyingCollisionDisablerStatusEffects> _flySpellCollisionHandlerStatusEffectClass;        // 0x0E48(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _maximumFlyingTime;                                // 0x0E50(0x0080)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _chargeMinPitchValue;                              // 0x0ED0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _chargeMaxPitchValue;                              // 0x0EF8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _pitchScaleValue;                                  // 0x0F20(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _flyingYawScale;                                   // 0x0F48(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	float                                         _yawAdjustTime;                                    // 0x0F70(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F74[0x4];                                      // 0x0F74(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _fovChangeTime;                                    // 0x0F78(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _fovZoomCurve;                                     // 0x0FA0(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _flyingSpeedCurve;                                 // 0x0FA8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _flyingSpeedCurveScalingDuration;                  // 0x0FB0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _decellerationTimeAfterFlying;                     // 0x0FD8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _timeForFlyEndAudioWarning;                        // 0x1000(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _timeTooSlowToStopFlying;                          // 0x1028(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _maxNumberOfTimesFlyTriggeredBeforeReducedScoreGiven; // 0x1050(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _reducedScorePercentage;                           // 0x1078(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	float                                         _minimumMovementSpeedToBeConsideredNonIdle;        // 0x10A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_10A4[0x1AC];                                   // 0x10A4(0x01AC)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Server_StopFlying(class ASlasherPlayer* Killer);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K36FlySpellInteraction">();
	}
	static class UK36FlySpellInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK36FlySpellInteraction>();
	}
};
static_assert(alignof(UK36FlySpellInteraction) == 0x000010, "Wrong alignment on UK36FlySpellInteraction");
static_assert(sizeof(UK36FlySpellInteraction) == 0x001250, "Wrong size on UK36FlySpellInteraction");
static_assert(offsetof(UK36FlySpellInteraction, _afterFlyAdditiveStrategyClass) == 0x000E38, "Member 'UK36FlySpellInteraction::_afterFlyAdditiveStrategyClass' has a wrong offset!");
static_assert(offsetof(UK36FlySpellInteraction, _afterFlyAdditiveStrategy) == 0x000E40, "Member 'UK36FlySpellInteraction::_afterFlyAdditiveStrategy' has a wrong offset!");
static_assert(offsetof(UK36FlySpellInteraction, _flySpellCollisionHandlerStatusEffectClass) == 0x000E48, "Member 'UK36FlySpellInteraction::_flySpellCollisionHandlerStatusEffectClass' has a wrong offset!");
static_assert(offsetof(UK36FlySpellInteraction, _maximumFlyingTime) == 0x000E50, "Member 'UK36FlySpellInteraction::_maximumFlyingTime' has a wrong offset!");
static_assert(offsetof(UK36FlySpellInteraction, _chargeMinPitchValue) == 0x000ED0, "Member 'UK36FlySpellInteraction::_chargeMinPitchValue' has a wrong offset!");
static_assert(offsetof(UK36FlySpellInteraction, _chargeMaxPitchValue) == 0x000EF8, "Member 'UK36FlySpellInteraction::_chargeMaxPitchValue' has a wrong offset!");
static_assert(offsetof(UK36FlySpellInteraction, _pitchScaleValue) == 0x000F20, "Member 'UK36FlySpellInteraction::_pitchScaleValue' has a wrong offset!");
static_assert(offsetof(UK36FlySpellInteraction, _flyingYawScale) == 0x000F48, "Member 'UK36FlySpellInteraction::_flyingYawScale' has a wrong offset!");
static_assert(offsetof(UK36FlySpellInteraction, _yawAdjustTime) == 0x000F70, "Member 'UK36FlySpellInteraction::_yawAdjustTime' has a wrong offset!");
static_assert(offsetof(UK36FlySpellInteraction, _fovChangeTime) == 0x000F78, "Member 'UK36FlySpellInteraction::_fovChangeTime' has a wrong offset!");
static_assert(offsetof(UK36FlySpellInteraction, _fovZoomCurve) == 0x000FA0, "Member 'UK36FlySpellInteraction::_fovZoomCurve' has a wrong offset!");
static_assert(offsetof(UK36FlySpellInteraction, _flyingSpeedCurve) == 0x000FA8, "Member 'UK36FlySpellInteraction::_flyingSpeedCurve' has a wrong offset!");
static_assert(offsetof(UK36FlySpellInteraction, _flyingSpeedCurveScalingDuration) == 0x000FB0, "Member 'UK36FlySpellInteraction::_flyingSpeedCurveScalingDuration' has a wrong offset!");
static_assert(offsetof(UK36FlySpellInteraction, _decellerationTimeAfterFlying) == 0x000FD8, "Member 'UK36FlySpellInteraction::_decellerationTimeAfterFlying' has a wrong offset!");
static_assert(offsetof(UK36FlySpellInteraction, _timeForFlyEndAudioWarning) == 0x001000, "Member 'UK36FlySpellInteraction::_timeForFlyEndAudioWarning' has a wrong offset!");
static_assert(offsetof(UK36FlySpellInteraction, _timeTooSlowToStopFlying) == 0x001028, "Member 'UK36FlySpellInteraction::_timeTooSlowToStopFlying' has a wrong offset!");
static_assert(offsetof(UK36FlySpellInteraction, _maxNumberOfTimesFlyTriggeredBeforeReducedScoreGiven) == 0x001050, "Member 'UK36FlySpellInteraction::_maxNumberOfTimesFlyTriggeredBeforeReducedScoreGiven' has a wrong offset!");
static_assert(offsetof(UK36FlySpellInteraction, _reducedScorePercentage) == 0x001078, "Member 'UK36FlySpellInteraction::_reducedScorePercentage' has a wrong offset!");
static_assert(offsetof(UK36FlySpellInteraction, _minimumMovementSpeedToBeConsideredNonIdle) == 0x0010A0, "Member 'UK36FlySpellInteraction::_minimumMovementSpeedToBeConsideredNonIdle' has a wrong offset!");

// Class TheK36.K36FOTDDangerPredictionComponent
// 0x00F0 (0x0200 - 0x0110)
class UK36FOTDDangerPredictionComponent final : public UDBDDangerPredictionComponent
{
public:
	float                                         _crouchRangeFromSpectralEntity;                    // 0x0110(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _crouchRangeFromPathCenter;                        // 0x0114(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _crouchMinimumHeightDifference;                    // 0x0118(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _crouchMaximumHeightDifference;                    // 0x011C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FAIRoll                                _unseenCrouchChance;                               // 0x0120(0x00C8)(Edit, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1E8[0x18];                                     // 0x01E8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K36FOTDDangerPredictionComponent">();
	}
	static class UK36FOTDDangerPredictionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK36FOTDDangerPredictionComponent>();
	}
};
static_assert(alignof(UK36FOTDDangerPredictionComponent) == 0x000008, "Wrong alignment on UK36FOTDDangerPredictionComponent");
static_assert(sizeof(UK36FOTDDangerPredictionComponent) == 0x000200, "Wrong size on UK36FOTDDangerPredictionComponent");
static_assert(offsetof(UK36FOTDDangerPredictionComponent, _crouchRangeFromSpectralEntity) == 0x000110, "Member 'UK36FOTDDangerPredictionComponent::_crouchRangeFromSpectralEntity' has a wrong offset!");
static_assert(offsetof(UK36FOTDDangerPredictionComponent, _crouchRangeFromPathCenter) == 0x000114, "Member 'UK36FOTDDangerPredictionComponent::_crouchRangeFromPathCenter' has a wrong offset!");
static_assert(offsetof(UK36FOTDDangerPredictionComponent, _crouchMinimumHeightDifference) == 0x000118, "Member 'UK36FOTDDangerPredictionComponent::_crouchMinimumHeightDifference' has a wrong offset!");
static_assert(offsetof(UK36FOTDDangerPredictionComponent, _crouchMaximumHeightDifference) == 0x00011C, "Member 'UK36FOTDDangerPredictionComponent::_crouchMaximumHeightDifference' has a wrong offset!");
static_assert(offsetof(UK36FOTDDangerPredictionComponent, _unseenCrouchChance) == 0x000120, "Member 'UK36FOTDDangerPredictionComponent::_unseenCrouchChance' has a wrong offset!");

// Class TheK36.K36FOTDSpectralEntity
// 0x0468 (0x0708 - 0x02A0)
class AK36FOTDSpectralEntity final : public AActor
{
public:
	uint8                                         Pad_2A0[0x10];                                     // 0x02A0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        _root;                                             // 0x02B0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        _heightComponent;                                  // 0x02B8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   _staticMeshComponent;                              // 0x02C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCapsuleComponent*                      _damageCollision;                                  // 0x02C8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USphereComponent*                       _nearMissCollisionComponent;                       // 0x02D0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDBDOutlineComponent*                   _outlineComponent;                                 // 0x02D8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkComponent*                           _akComponent;                                      // 0x02E0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UK36FOTDSpectralEntityOutlineUpdateStrategy* _outlineUpdateStrategyComponent;                   // 0x02E8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UK36FOTDDangerPredictionComponent*      _dangerPredictionComponent;                        // 0x02F0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EK36FOTDSpectralEntityState                   _state;                                            // 0x02F8(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2F9[0x7];                                      // 0x02F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UStatusEffect>              _killerInstinctStatusEffectClass;                  // 0x0300(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _revealSurvivorAuraStatusEffectClass;              // 0x0308(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _killerInstinctStatusEffectLifetime;               // 0x0310(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _nearMissRevealSurvivorAuraStatusEffectLifetime;   // 0x0338(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _summonTime;                                       // 0x0360(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _despawnTime;                                      // 0x0388(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _activeMovementMaximumSpeed;                       // 0x03B0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _maximumTravelDistance;                            // 0x03D8(0x0080)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _spectralEntityHeight;                             // 0x0458(0x0080)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _activeStateMovementCurve;                         // 0x04D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _despawnStateMovementCurve;                        // 0x04E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGameplayTagContainerComponent*         _objectState;                                      // 0x04E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4F0[0x38];                                     // 0x04F0(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstance*                      _defaultSpawnAnimationMaterial;                    // 0x0528(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstance*                      _defaultLoopAnimationMaterial;                     // 0x0530(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_538[0x10];                                     // 0x0538(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftObjectPtr<class UMaterialInstance>> _spectralEntitySpawningMaterialSoftReferences;     // 0x0548(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<class UMaterialInstance*>              _spectralEntitySpawningMaterials;                  // 0x0558(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	int32                                         _spectralEntityIndex;                              // 0x0568(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_56C[0x4C];                                     // 0x056C(0x004C)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class ASlasherPlayer>          _owningKiller;                                     // 0x05B8(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5C0[0x148];                                    // 0x05C0(0x0148)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnCollisionOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool FromSweep, const struct FHitResult& SweepResult);
	void Authority_OnNearMissCollisionOverlapEnd(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void Cosmetic_OnHitSurvivor(class ACamperPlayer* SurvivorHit);
	void Cosmetic_OnStateChanged(EK36FOTDSpectralEntityState PreviousState, EK36FOTDSpectralEntityState CurrentState, float CustomParameter);
	void Multicast_SetLocationAndRotation(const struct FVector& Position, const struct FRotator& Rotation);
	void Multicast_TriggerHitSurvivorCosmetic(class ACamperPlayer* TargetSurvivor);
	void OnIntroCompleted();
	void OnRep_OwningKiller();
	void OnRep_State(EK36FOTDSpectralEntityState PreviousState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K36FOTDSpectralEntity">();
	}
	static class AK36FOTDSpectralEntity* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK36FOTDSpectralEntity>();
	}
};
static_assert(alignof(AK36FOTDSpectralEntity) == 0x000008, "Wrong alignment on AK36FOTDSpectralEntity");
static_assert(sizeof(AK36FOTDSpectralEntity) == 0x000708, "Wrong size on AK36FOTDSpectralEntity");
static_assert(offsetof(AK36FOTDSpectralEntity, _root) == 0x0002B0, "Member 'AK36FOTDSpectralEntity::_root' has a wrong offset!");
static_assert(offsetof(AK36FOTDSpectralEntity, _heightComponent) == 0x0002B8, "Member 'AK36FOTDSpectralEntity::_heightComponent' has a wrong offset!");
static_assert(offsetof(AK36FOTDSpectralEntity, _staticMeshComponent) == 0x0002C0, "Member 'AK36FOTDSpectralEntity::_staticMeshComponent' has a wrong offset!");
static_assert(offsetof(AK36FOTDSpectralEntity, _damageCollision) == 0x0002C8, "Member 'AK36FOTDSpectralEntity::_damageCollision' has a wrong offset!");
static_assert(offsetof(AK36FOTDSpectralEntity, _nearMissCollisionComponent) == 0x0002D0, "Member 'AK36FOTDSpectralEntity::_nearMissCollisionComponent' has a wrong offset!");
static_assert(offsetof(AK36FOTDSpectralEntity, _outlineComponent) == 0x0002D8, "Member 'AK36FOTDSpectralEntity::_outlineComponent' has a wrong offset!");
static_assert(offsetof(AK36FOTDSpectralEntity, _akComponent) == 0x0002E0, "Member 'AK36FOTDSpectralEntity::_akComponent' has a wrong offset!");
static_assert(offsetof(AK36FOTDSpectralEntity, _outlineUpdateStrategyComponent) == 0x0002E8, "Member 'AK36FOTDSpectralEntity::_outlineUpdateStrategyComponent' has a wrong offset!");
static_assert(offsetof(AK36FOTDSpectralEntity, _dangerPredictionComponent) == 0x0002F0, "Member 'AK36FOTDSpectralEntity::_dangerPredictionComponent' has a wrong offset!");
static_assert(offsetof(AK36FOTDSpectralEntity, _state) == 0x0002F8, "Member 'AK36FOTDSpectralEntity::_state' has a wrong offset!");
static_assert(offsetof(AK36FOTDSpectralEntity, _killerInstinctStatusEffectClass) == 0x000300, "Member 'AK36FOTDSpectralEntity::_killerInstinctStatusEffectClass' has a wrong offset!");
static_assert(offsetof(AK36FOTDSpectralEntity, _revealSurvivorAuraStatusEffectClass) == 0x000308, "Member 'AK36FOTDSpectralEntity::_revealSurvivorAuraStatusEffectClass' has a wrong offset!");
static_assert(offsetof(AK36FOTDSpectralEntity, _killerInstinctStatusEffectLifetime) == 0x000310, "Member 'AK36FOTDSpectralEntity::_killerInstinctStatusEffectLifetime' has a wrong offset!");
static_assert(offsetof(AK36FOTDSpectralEntity, _nearMissRevealSurvivorAuraStatusEffectLifetime) == 0x000338, "Member 'AK36FOTDSpectralEntity::_nearMissRevealSurvivorAuraStatusEffectLifetime' has a wrong offset!");
static_assert(offsetof(AK36FOTDSpectralEntity, _summonTime) == 0x000360, "Member 'AK36FOTDSpectralEntity::_summonTime' has a wrong offset!");
static_assert(offsetof(AK36FOTDSpectralEntity, _despawnTime) == 0x000388, "Member 'AK36FOTDSpectralEntity::_despawnTime' has a wrong offset!");
static_assert(offsetof(AK36FOTDSpectralEntity, _activeMovementMaximumSpeed) == 0x0003B0, "Member 'AK36FOTDSpectralEntity::_activeMovementMaximumSpeed' has a wrong offset!");
static_assert(offsetof(AK36FOTDSpectralEntity, _maximumTravelDistance) == 0x0003D8, "Member 'AK36FOTDSpectralEntity::_maximumTravelDistance' has a wrong offset!");
static_assert(offsetof(AK36FOTDSpectralEntity, _spectralEntityHeight) == 0x000458, "Member 'AK36FOTDSpectralEntity::_spectralEntityHeight' has a wrong offset!");
static_assert(offsetof(AK36FOTDSpectralEntity, _activeStateMovementCurve) == 0x0004D8, "Member 'AK36FOTDSpectralEntity::_activeStateMovementCurve' has a wrong offset!");
static_assert(offsetof(AK36FOTDSpectralEntity, _despawnStateMovementCurve) == 0x0004E0, "Member 'AK36FOTDSpectralEntity::_despawnStateMovementCurve' has a wrong offset!");
static_assert(offsetof(AK36FOTDSpectralEntity, _objectState) == 0x0004E8, "Member 'AK36FOTDSpectralEntity::_objectState' has a wrong offset!");
static_assert(offsetof(AK36FOTDSpectralEntity, _defaultSpawnAnimationMaterial) == 0x000528, "Member 'AK36FOTDSpectralEntity::_defaultSpawnAnimationMaterial' has a wrong offset!");
static_assert(offsetof(AK36FOTDSpectralEntity, _defaultLoopAnimationMaterial) == 0x000530, "Member 'AK36FOTDSpectralEntity::_defaultLoopAnimationMaterial' has a wrong offset!");
static_assert(offsetof(AK36FOTDSpectralEntity, _spectralEntitySpawningMaterialSoftReferences) == 0x000548, "Member 'AK36FOTDSpectralEntity::_spectralEntitySpawningMaterialSoftReferences' has a wrong offset!");
static_assert(offsetof(AK36FOTDSpectralEntity, _spectralEntitySpawningMaterials) == 0x000558, "Member 'AK36FOTDSpectralEntity::_spectralEntitySpawningMaterials' has a wrong offset!");
static_assert(offsetof(AK36FOTDSpectralEntity, _spectralEntityIndex) == 0x000568, "Member 'AK36FOTDSpectralEntity::_spectralEntityIndex' has a wrong offset!");
static_assert(offsetof(AK36FOTDSpectralEntity, _owningKiller) == 0x0005B8, "Member 'AK36FOTDSpectralEntity::_owningKiller' has a wrong offset!");

// Class TheK36.K36FOTDSpectralEntityOutlineUpdateStrategy
// 0x0038 (0x0180 - 0x0148)
class UK36FOTDSpectralEntityOutlineUpdateStrategy final : public USourceBasedOutlineUpdateStrategy
{
public:
	uint8                                         Pad_148[0x8];                                      // 0x0148(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _survivorDefaultMaxDistanceToSeeAura;              // 0x0150(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_178[0x8];                                      // 0x0178(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K36FOTDSpectralEntityOutlineUpdateStrategy">();
	}
	static class UK36FOTDSpectralEntityOutlineUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK36FOTDSpectralEntityOutlineUpdateStrategy>();
	}
};
static_assert(alignof(UK36FOTDSpectralEntityOutlineUpdateStrategy) == 0x000008, "Wrong alignment on UK36FOTDSpectralEntityOutlineUpdateStrategy");
static_assert(sizeof(UK36FOTDSpectralEntityOutlineUpdateStrategy) == 0x000180, "Wrong size on UK36FOTDSpectralEntityOutlineUpdateStrategy");
static_assert(offsetof(UK36FOTDSpectralEntityOutlineUpdateStrategy, _survivorDefaultMaxDistanceToSeeAura) == 0x000150, "Member 'UK36FOTDSpectralEntityOutlineUpdateStrategy::_survivorDefaultMaxDistanceToSeeAura' has a wrong offset!");

// Class TheK36.K36FXInterface
// 0x0000 (0x0030 - 0x0030)
class IK36FXInterface final : public IInterface
{
public:
	void Cosmetic_CreateSpellAtSpellSlotPosition(EK36SpellSlot SelectedSpellSlot, EK36SpellType SpellType, class UNiagaraSystem* MenuVFXInstance);
	void Cosmetic_OnFOVChanged(float NewFOV);
	void Cosmetic_OnKillerStartMoving();
	void Cosmetic_OnMoriEnded();
	void Cosmetic_OnMoriStarted();
	void Cosmetic_OnSpellCooldownEnded(EK36SpellType SpellType);
	void Cosmetic_OnSpellCooldownStarted(EK36SpellType SpellType);
	void Cosmetic_OnSpellEnded(EK36SpellType SpellType);
	void Cosmetic_SetSelectedSpell(EK36SpellType SpellType);
	void Cosmetic_SetSpellMenuVisibility(bool IsSpellMenuVisible);
	void Cosmetic_SetSpellVignetteVisibility(bool IsVisible);
	void Cosmetic_SpellActivated(EK36SpellType SpellType);
	void Cosmetic_SpellCancelled(EK36SpellType SpellType);
	void Cosmetic_SpellChargeCompleted(EK36SpellType SpellType);
	void Cosmetic_SpellChargeStart(EK36SpellType SpellType);
	void Cosmetic_TriggerAlmostStopFlySFX();
	void Cosmetic_TriggerSpellAudioSFX(class UAkAudioEvent* SpellCastAkEvent);
	void Cosmetic_TriggerStopFlyingSFX();
	void Cosmetic_TriggerSurvivorDetectedSFX();
	void Cosmetic_UpdateSpellCooldownCompletionPercentage(EK36SpellType SpellType, float CooldownPercentage);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K36FXInterface">();
	}
	static class IK36FXInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IK36FXInterface>();
	}
};
static_assert(alignof(IK36FXInterface) == 0x000008, "Wrong alignment on IK36FXInterface");
static_assert(sizeof(IK36FXInterface) == 0x000030, "Wrong size on IK36FXInterface");

// Class TheK36.K36InvisibilityStatusEffect
// 0x00B0 (0x0430 - 0x0380)
class UK36InvisibilityStatusEffect final : public UStatusEffect
{
public:
	struct FDBDTunableRowHandle                   _effectLifetime;                                   // 0x0380(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _preEndingEffectTime;                              // 0x03A8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _afterInvisibilityStatusEffectLifetime;            // 0x03D0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _afterInvisibilityStatusEffectClass;               // 0x03F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_400[0x30];                                     // 0x0400(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnLocallyObservedPawnChanged();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K36InvisibilityStatusEffect">();
	}
	static class UK36InvisibilityStatusEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK36InvisibilityStatusEffect>();
	}
};
static_assert(alignof(UK36InvisibilityStatusEffect) == 0x000008, "Wrong alignment on UK36InvisibilityStatusEffect");
static_assert(sizeof(UK36InvisibilityStatusEffect) == 0x000430, "Wrong size on UK36InvisibilityStatusEffect");
static_assert(offsetof(UK36InvisibilityStatusEffect, _effectLifetime) == 0x000380, "Member 'UK36InvisibilityStatusEffect::_effectLifetime' has a wrong offset!");
static_assert(offsetof(UK36InvisibilityStatusEffect, _preEndingEffectTime) == 0x0003A8, "Member 'UK36InvisibilityStatusEffect::_preEndingEffectTime' has a wrong offset!");
static_assert(offsetof(UK36InvisibilityStatusEffect, _afterInvisibilityStatusEffectLifetime) == 0x0003D0, "Member 'UK36InvisibilityStatusEffect::_afterInvisibilityStatusEffectLifetime' has a wrong offset!");
static_assert(offsetof(UK36InvisibilityStatusEffect, _afterInvisibilityStatusEffectClass) == 0x0003F8, "Member 'UK36InvisibilityStatusEffect::_afterInvisibilityStatusEffectClass' has a wrong offset!");

// Class TheK36.K36MageHand
// 0x0140 (0x03E0 - 0x02A0)
class AK36MageHand final : public AActor
{
public:
	uint8                                         Pad_2A0[0x20];                                     // 0x02A0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        _rootComponent;                                    // 0x02C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDBDSkeletalMeshComponentBudgeted*      _skeletalMeshComponent;                            // 0x02C8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDBDOutlineComponent*                   _outlineComponent;                                 // 0x02D0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UK36MageHandOutlineUpdateStrategy*      _outlineStrategy;                                  // 0x02D8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkComponent*                           _akComponent;                                      // 0x02E0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStateController*                       _stateController;                                  // 0x02E8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMontagePlayer*                         _montagePlayer;                                    // 0x02F0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class APallet*                                _targetPallet;                                     // 0x02F8(0x0008)(Net, ZeroConstructor, Transient, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class ASlasherPlayer>          _owningKiller;                                     // 0x0300(0x0008)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                _offsetFromPallet;                                 // 0x0308(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _maxNumberOfTimesMageHandTriggeredBeforeHalfScoreGiven; // 0x0320(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _reducedScorePercentage;                           // 0x0348(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class UGameplayTagContainerComponent*         _objectState;                                      // 0x0370(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_378[0x68];                                     // 0x0378(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_OnMageHandAppear();
	void Cosmetic_OnMageHandDisappear();
	void Cosmetic_OnStateChanged(const struct FGameplayTag& NewStateID);
	void OnRep_TargetPallet(class APallet* PreviousPallet);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K36MageHand">();
	}
	static class AK36MageHand* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK36MageHand>();
	}
};
static_assert(alignof(AK36MageHand) == 0x000008, "Wrong alignment on AK36MageHand");
static_assert(sizeof(AK36MageHand) == 0x0003E0, "Wrong size on AK36MageHand");
static_assert(offsetof(AK36MageHand, _rootComponent) == 0x0002C0, "Member 'AK36MageHand::_rootComponent' has a wrong offset!");
static_assert(offsetof(AK36MageHand, _skeletalMeshComponent) == 0x0002C8, "Member 'AK36MageHand::_skeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(AK36MageHand, _outlineComponent) == 0x0002D0, "Member 'AK36MageHand::_outlineComponent' has a wrong offset!");
static_assert(offsetof(AK36MageHand, _outlineStrategy) == 0x0002D8, "Member 'AK36MageHand::_outlineStrategy' has a wrong offset!");
static_assert(offsetof(AK36MageHand, _akComponent) == 0x0002E0, "Member 'AK36MageHand::_akComponent' has a wrong offset!");
static_assert(offsetof(AK36MageHand, _stateController) == 0x0002E8, "Member 'AK36MageHand::_stateController' has a wrong offset!");
static_assert(offsetof(AK36MageHand, _montagePlayer) == 0x0002F0, "Member 'AK36MageHand::_montagePlayer' has a wrong offset!");
static_assert(offsetof(AK36MageHand, _targetPallet) == 0x0002F8, "Member 'AK36MageHand::_targetPallet' has a wrong offset!");
static_assert(offsetof(AK36MageHand, _owningKiller) == 0x000300, "Member 'AK36MageHand::_owningKiller' has a wrong offset!");
static_assert(offsetof(AK36MageHand, _offsetFromPallet) == 0x000308, "Member 'AK36MageHand::_offsetFromPallet' has a wrong offset!");
static_assert(offsetof(AK36MageHand, _maxNumberOfTimesMageHandTriggeredBeforeHalfScoreGiven) == 0x000320, "Member 'AK36MageHand::_maxNumberOfTimesMageHandTriggeredBeforeHalfScoreGiven' has a wrong offset!");
static_assert(offsetof(AK36MageHand, _reducedScorePercentage) == 0x000348, "Member 'AK36MageHand::_reducedScorePercentage' has a wrong offset!");
static_assert(offsetof(AK36MageHand, _objectState) == 0x000370, "Member 'AK36MageHand::_objectState' has a wrong offset!");

// Class TheK36.K36MageHandAnimInstance
// 0x0010 (0x0390 - 0x0380)
class UK36MageHandAnimInstance final : public UDBDBaseAnimInstance
{
public:
	bool                                          _isVisible;                                        // 0x0380(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isWaitingToBlockUpPallet;                         // 0x0381(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isWaitingToLiftPallet;                            // 0x0382(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isLiftingPallet;                                  // 0x0383(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isBlockingPallet;                                 // 0x0384(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isBreakingPallet;                                 // 0x0385(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_386[0xA];                                      // 0x0386(0x000A)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K36MageHandAnimInstance">();
	}
	static class UK36MageHandAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK36MageHandAnimInstance>();
	}
};
static_assert(alignof(UK36MageHandAnimInstance) == 0x000010, "Wrong alignment on UK36MageHandAnimInstance");
static_assert(sizeof(UK36MageHandAnimInstance) == 0x000390, "Wrong size on UK36MageHandAnimInstance");
static_assert(offsetof(UK36MageHandAnimInstance, _isVisible) == 0x000380, "Member 'UK36MageHandAnimInstance::_isVisible' has a wrong offset!");
static_assert(offsetof(UK36MageHandAnimInstance, _isWaitingToBlockUpPallet) == 0x000381, "Member 'UK36MageHandAnimInstance::_isWaitingToBlockUpPallet' has a wrong offset!");
static_assert(offsetof(UK36MageHandAnimInstance, _isWaitingToLiftPallet) == 0x000382, "Member 'UK36MageHandAnimInstance::_isWaitingToLiftPallet' has a wrong offset!");
static_assert(offsetof(UK36MageHandAnimInstance, _isLiftingPallet) == 0x000383, "Member 'UK36MageHandAnimInstance::_isLiftingPallet' has a wrong offset!");
static_assert(offsetof(UK36MageHandAnimInstance, _isBlockingPallet) == 0x000384, "Member 'UK36MageHandAnimInstance::_isBlockingPallet' has a wrong offset!");
static_assert(offsetof(UK36MageHandAnimInstance, _isBreakingPallet) == 0x000385, "Member 'UK36MageHandAnimInstance::_isBreakingPallet' has a wrong offset!");

// Class TheK36.K36MageHandBlockingUpPalletState
// 0x00C8 (0x0150 - 0x0088)
class UK36MageHandBlockingUpPalletState final : public UK36BlockPalletInteractionsState
{
public:
	struct FTunableStat                           _blockDuration;                                    // 0x0088(0x0080)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FGameplayTag                           _stateID;                                          // 0x0108(0x000C)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTag                           _gameEventToTriggerOnStateEnter;                   // 0x0114(0x000C)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_120[0x30];                                     // 0x0120(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K36MageHandBlockingUpPalletState">();
	}
	static class UK36MageHandBlockingUpPalletState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK36MageHandBlockingUpPalletState>();
	}
};
static_assert(alignof(UK36MageHandBlockingUpPalletState) == 0x000008, "Wrong alignment on UK36MageHandBlockingUpPalletState");
static_assert(sizeof(UK36MageHandBlockingUpPalletState) == 0x000150, "Wrong size on UK36MageHandBlockingUpPalletState");
static_assert(offsetof(UK36MageHandBlockingUpPalletState, _blockDuration) == 0x000088, "Member 'UK36MageHandBlockingUpPalletState::_blockDuration' has a wrong offset!");
static_assert(offsetof(UK36MageHandBlockingUpPalletState, _stateID) == 0x000108, "Member 'UK36MageHandBlockingUpPalletState::_stateID' has a wrong offset!");
static_assert(offsetof(UK36MageHandBlockingUpPalletState, _gameEventToTriggerOnStateEnter) == 0x000114, "Member 'UK36MageHandBlockingUpPalletState::_gameEventToTriggerOnStateEnter' has a wrong offset!");

// Class TheK36.K36MageHandBreakPalletState
// 0x00B0 (0x0138 - 0x0088)
class UK36MageHandBreakPalletState final : public UK36BlockPalletInteractionsState
{
public:
	struct FAnimationMontageDescriptor            _breakUpPalletMontage;                             // 0x0088(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _timeToBreakPallet;                                // 0x00A8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	float                                         _destroyPalletAnimTimePercentage;                  // 0x00D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D4[0x64];                                      // 0x00D4(0x0064)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K36MageHandBreakPalletState">();
	}
	static class UK36MageHandBreakPalletState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK36MageHandBreakPalletState>();
	}
};
static_assert(alignof(UK36MageHandBreakPalletState) == 0x000008, "Wrong alignment on UK36MageHandBreakPalletState");
static_assert(sizeof(UK36MageHandBreakPalletState) == 0x000138, "Wrong size on UK36MageHandBreakPalletState");
static_assert(offsetof(UK36MageHandBreakPalletState, _breakUpPalletMontage) == 0x000088, "Member 'UK36MageHandBreakPalletState::_breakUpPalletMontage' has a wrong offset!");
static_assert(offsetof(UK36MageHandBreakPalletState, _timeToBreakPallet) == 0x0000A8, "Member 'UK36MageHandBreakPalletState::_timeToBreakPallet' has a wrong offset!");
static_assert(offsetof(UK36MageHandBreakPalletState, _destroyPalletAnimTimePercentage) == 0x0000D0, "Member 'UK36MageHandBreakPalletState::_destroyPalletAnimTimePercentage' has a wrong offset!");

// Class TheK36.K36MageHandLiftingPalletState
// 0x00D0 (0x0158 - 0x0088)
class UK36MageHandLiftingPalletState final : public UK36BlockPalletInteractionsState
{
public:
	struct FAnimationMontageDescriptor            _liftUpPalletMontage;                              // 0x0088(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _timeToLiftPallet;                                 // 0x00A8(0x0080)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_128[0x30];                                     // 0x0128(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K36MageHandLiftingPalletState">();
	}
	static class UK36MageHandLiftingPalletState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK36MageHandLiftingPalletState>();
	}
};
static_assert(alignof(UK36MageHandLiftingPalletState) == 0x000008, "Wrong alignment on UK36MageHandLiftingPalletState");
static_assert(sizeof(UK36MageHandLiftingPalletState) == 0x000158, "Wrong size on UK36MageHandLiftingPalletState");
static_assert(offsetof(UK36MageHandLiftingPalletState, _liftUpPalletMontage) == 0x000088, "Member 'UK36MageHandLiftingPalletState::_liftUpPalletMontage' has a wrong offset!");
static_assert(offsetof(UK36MageHandLiftingPalletState, _timeToLiftPallet) == 0x0000A8, "Member 'UK36MageHandLiftingPalletState::_timeToLiftPallet' has a wrong offset!");

// Class TheK36.K36MageHandOutlineUpdateStrategy
// 0x0008 (0x0150 - 0x0148)
class UK36MageHandOutlineUpdateStrategy final : public USourceBasedOutlineUpdateStrategy
{
public:
	uint8                                         Pad_148[0x8];                                      // 0x0148(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K36MageHandOutlineUpdateStrategy">();
	}
	static class UK36MageHandOutlineUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK36MageHandOutlineUpdateStrategy>();
	}
};
static_assert(alignof(UK36MageHandOutlineUpdateStrategy) == 0x000008, "Wrong alignment on UK36MageHandOutlineUpdateStrategy");
static_assert(sizeof(UK36MageHandOutlineUpdateStrategy) == 0x000150, "Wrong size on UK36MageHandOutlineUpdateStrategy");

// Class TheK36.K36MageHandPalletSelectionComponent
// 0x0270 (0x0318 - 0x00A8)
class UK36MageHandPalletSelectionComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x10];                                      // 0x00A8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   _actorIndicatorClass;                              // 0x00B8(0x0038)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ADBDActorIndicator*                     _actorIndicator;                                   // 0x00F0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _minDotProductValue;                               // 0x00F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _minDotProductValueForDistanceSelection;           // 0x00FC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _indicatorZOffsetValueForFallenPallet;             // 0x0100(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_104[0x4];                                      // 0x0104(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _maxDistanceFromPalletToBeSelectable;              // 0x0108(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_130[0x8];                                      // 0x0130(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _maxDistanceFromPalletToBeHighlightable;           // 0x0138(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_160[0x4];                                      // 0x0160(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           _outlineColorWhenCurrentAimTarget;                 // 0x0164(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           _outlineColorWhenPotentialAimTarget;               // 0x0174(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_184[0x4];                                      // 0x0184(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             _animationMappingsDB;                              // 0x0188(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   _palletMiddleSocketLocation;                       // 0x0190(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_19C[0x4];                                      // 0x019C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AK36MageHandSurvivorPalletSelectionVFX> _survivorPalletSelectionHighlightVFXClass;         // 0x01A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class AK36MageHandSurvivorPalletSelectionVFX*> _survivorPalletSelectionHighlightVFX;              // 0x01A8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1B8[0x160];                                    // 0x01B8(0x0160)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_ActivateHighlightOnPallet(class APallet* Pallet);
	void Cosmetic_DeactivateHighlightOnPallet(class APallet* TargetPallet);
	void OnLevelReadyToPlay();
	void OnLocallyObservedPawnChanged();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K36MageHandPalletSelectionComponent">();
	}
	static class UK36MageHandPalletSelectionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK36MageHandPalletSelectionComponent>();
	}
};
static_assert(alignof(UK36MageHandPalletSelectionComponent) == 0x000008, "Wrong alignment on UK36MageHandPalletSelectionComponent");
static_assert(sizeof(UK36MageHandPalletSelectionComponent) == 0x000318, "Wrong size on UK36MageHandPalletSelectionComponent");
static_assert(offsetof(UK36MageHandPalletSelectionComponent, _actorIndicatorClass) == 0x0000B8, "Member 'UK36MageHandPalletSelectionComponent::_actorIndicatorClass' has a wrong offset!");
static_assert(offsetof(UK36MageHandPalletSelectionComponent, _actorIndicator) == 0x0000F0, "Member 'UK36MageHandPalletSelectionComponent::_actorIndicator' has a wrong offset!");
static_assert(offsetof(UK36MageHandPalletSelectionComponent, _minDotProductValue) == 0x0000F8, "Member 'UK36MageHandPalletSelectionComponent::_minDotProductValue' has a wrong offset!");
static_assert(offsetof(UK36MageHandPalletSelectionComponent, _minDotProductValueForDistanceSelection) == 0x0000FC, "Member 'UK36MageHandPalletSelectionComponent::_minDotProductValueForDistanceSelection' has a wrong offset!");
static_assert(offsetof(UK36MageHandPalletSelectionComponent, _indicatorZOffsetValueForFallenPallet) == 0x000100, "Member 'UK36MageHandPalletSelectionComponent::_indicatorZOffsetValueForFallenPallet' has a wrong offset!");
static_assert(offsetof(UK36MageHandPalletSelectionComponent, _maxDistanceFromPalletToBeSelectable) == 0x000108, "Member 'UK36MageHandPalletSelectionComponent::_maxDistanceFromPalletToBeSelectable' has a wrong offset!");
static_assert(offsetof(UK36MageHandPalletSelectionComponent, _maxDistanceFromPalletToBeHighlightable) == 0x000138, "Member 'UK36MageHandPalletSelectionComponent::_maxDistanceFromPalletToBeHighlightable' has a wrong offset!");
static_assert(offsetof(UK36MageHandPalletSelectionComponent, _outlineColorWhenCurrentAimTarget) == 0x000164, "Member 'UK36MageHandPalletSelectionComponent::_outlineColorWhenCurrentAimTarget' has a wrong offset!");
static_assert(offsetof(UK36MageHandPalletSelectionComponent, _outlineColorWhenPotentialAimTarget) == 0x000174, "Member 'UK36MageHandPalletSelectionComponent::_outlineColorWhenPotentialAimTarget' has a wrong offset!");
static_assert(offsetof(UK36MageHandPalletSelectionComponent, _animationMappingsDB) == 0x000188, "Member 'UK36MageHandPalletSelectionComponent::_animationMappingsDB' has a wrong offset!");
static_assert(offsetof(UK36MageHandPalletSelectionComponent, _palletMiddleSocketLocation) == 0x000190, "Member 'UK36MageHandPalletSelectionComponent::_palletMiddleSocketLocation' has a wrong offset!");
static_assert(offsetof(UK36MageHandPalletSelectionComponent, _survivorPalletSelectionHighlightVFXClass) == 0x0001A0, "Member 'UK36MageHandPalletSelectionComponent::_survivorPalletSelectionHighlightVFXClass' has a wrong offset!");
static_assert(offsetof(UK36MageHandPalletSelectionComponent, _survivorPalletSelectionHighlightVFX) == 0x0001A8, "Member 'UK36MageHandPalletSelectionComponent::_survivorPalletSelectionHighlightVFX' has a wrong offset!");

// Class TheK36.K36MageHandSpellInteraction
// 0x0020 (0x0E60 - 0x0E40)
class UK36MageHandSpellInteraction final : public UK36SpellInteraction
{
public:
	TSubclassOf<class AK36MageHand>               _mageHandClass;                                    // 0x0E38(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AK36MageHand*                           _mageHand;                                         // 0x0E40(0x0008)(Net, ZeroConstructor, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UK36MageHandPalletSelectionComponent> _palletSelectionComponentClass;                    // 0x0E48(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UK36MageHandPalletSelectionComponent*   _palletSelectionComponent;                         // 0x0E50(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E58[0x8];                                      // 0x0E58(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_MageHand();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K36MageHandSpellInteraction">();
	}
	static class UK36MageHandSpellInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK36MageHandSpellInteraction>();
	}
};
static_assert(alignof(UK36MageHandSpellInteraction) == 0x000010, "Wrong alignment on UK36MageHandSpellInteraction");
static_assert(sizeof(UK36MageHandSpellInteraction) == 0x000E60, "Wrong size on UK36MageHandSpellInteraction");
static_assert(offsetof(UK36MageHandSpellInteraction, _mageHandClass) == 0x000E38, "Member 'UK36MageHandSpellInteraction::_mageHandClass' has a wrong offset!");
static_assert(offsetof(UK36MageHandSpellInteraction, _mageHand) == 0x000E40, "Member 'UK36MageHandSpellInteraction::_mageHand' has a wrong offset!");
static_assert(offsetof(UK36MageHandSpellInteraction, _palletSelectionComponentClass) == 0x000E48, "Member 'UK36MageHandSpellInteraction::_palletSelectionComponentClass' has a wrong offset!");
static_assert(offsetof(UK36MageHandSpellInteraction, _palletSelectionComponent) == 0x000E50, "Member 'UK36MageHandSpellInteraction::_palletSelectionComponent' has a wrong offset!");

// Class TheK36.K36MageHandSurvivorPalletSelectionVFX
// 0x0008 (0x02A8 - 0x02A0)
class AK36MageHandSurvivorPalletSelectionVFX final : public AActor
{
public:
	uint8                                         Pad_2A0[0x8];                                      // 0x02A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_SethighlightActivationState(bool IsActive);

	class APallet* GetTargetPallet() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K36MageHandSurvivorPalletSelectionVFX">();
	}
	static class AK36MageHandSurvivorPalletSelectionVFX* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK36MageHandSurvivorPalletSelectionVFX>();
	}
};
static_assert(alignof(AK36MageHandSurvivorPalletSelectionVFX) == 0x000008, "Wrong alignment on AK36MageHandSurvivorPalletSelectionVFX");
static_assert(sizeof(AK36MageHandSurvivorPalletSelectionVFX) == 0x0002A8, "Wrong size on AK36MageHandSurvivorPalletSelectionVFX");

// Class TheK36.K36MageHandWaitingToBlockPalletState
// 0x0058 (0x00E0 - 0x0088)
class UK36MageHandWaitingToBlockPalletState final : public UK36MageHandBaseState
{
public:
	struct FDBDTunableRowHandle                   _timeBeforeBlockingPallet;                         // 0x0088(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B0[0x30];                                      // 0x00B0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K36MageHandWaitingToBlockPalletState">();
	}
	static class UK36MageHandWaitingToBlockPalletState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK36MageHandWaitingToBlockPalletState>();
	}
};
static_assert(alignof(UK36MageHandWaitingToBlockPalletState) == 0x000008, "Wrong alignment on UK36MageHandWaitingToBlockPalletState");
static_assert(sizeof(UK36MageHandWaitingToBlockPalletState) == 0x0000E0, "Wrong size on UK36MageHandWaitingToBlockPalletState");
static_assert(offsetof(UK36MageHandWaitingToBlockPalletState, _timeBeforeBlockingPallet) == 0x000088, "Member 'UK36MageHandWaitingToBlockPalletState::_timeBeforeBlockingPallet' has a wrong offset!");

// Class TheK36.K36MageHandWaitingToLiftPalletState
// 0x0060 (0x00E8 - 0x0088)
class UK36MageHandWaitingToLiftPalletState final : public UK36BlockPalletInteractionsState
{
public:
	struct FDBDTunableRowHandle                   _minimumTimeInPalletFallenStateBeforeLift;         // 0x0088(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B0[0x38];                                      // 0x00B0(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K36MageHandWaitingToLiftPalletState">();
	}
	static class UK36MageHandWaitingToLiftPalletState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK36MageHandWaitingToLiftPalletState>();
	}
};
static_assert(alignof(UK36MageHandWaitingToLiftPalletState) == 0x000008, "Wrong alignment on UK36MageHandWaitingToLiftPalletState");
static_assert(sizeof(UK36MageHandWaitingToLiftPalletState) == 0x0000E8, "Wrong size on UK36MageHandWaitingToLiftPalletState");
static_assert(offsetof(UK36MageHandWaitingToLiftPalletState, _minimumTimeInPalletFallenStateBeforeLift) == 0x000088, "Member 'UK36MageHandWaitingToLiftPalletState::_minimumTimeInPalletFallenStateBeforeLift' has a wrong offset!");

// Class TheK36.K36MagicItem
// 0x00E8 (0x0638 - 0x0550)
class AK36MagicItem : public ACollectable
{
public:
	uint8                                         Pad_550[0x10];                                     // 0x0550(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	EK36MagicItemType                             _magicItemType;                                    // 0x0560(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EK36MagicItemRarity                           _magicItemRarity;                                  // 0x0561(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_562[0x6];                                      // 0x0562(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        _rootComponent;                                    // 0x0568(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   _staticMesh;                                       // 0x0570(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UK36SpellCounterStatusEffect*           _imposedStatusEffect;                              // 0x0578(0x0008)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EK36MagicItemState                            _magicItemState;                                   // 0x0580(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_581[0x7];                                      // 0x0581(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UK36SpellCounterData*                   _spellCounter;                                     // 0x0588(0x0008)(Net, ZeroConstructor, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_590[0xA8];                                     // 0x0590(0x00A8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_OnCollectingPlayerLocallyObservedChanged(class ADBDPlayer* Collector, bool IsLocallyObserved);
	void Cosmetic_OnMagicItemCollected(class UNiagaraSystem* PlayerAttachedNiagaraSystem, class ADBDPlayer* NewCollectingPlayer);
	void Cosmetic_OnMagicItemRemovedFromPlayer();
	void Cosmetic_OnSpellCounterActiveStateChanged(bool IsActive);
	void Cosmetic_SetMagicItemVisibility(class ADBDPlayer* Player, bool ShouldKillerVfxBeVisible, bool ShouldSurvivorVfxBeVisible, bool IsInstant);
	void OnLocallyObservedPawnChanged();
	void OnRep_ImposedStatusEffect(class UK36SpellCounterStatusEffect* PreviouslyImposedEffect);
	void OnRep_MagicItemState();
	void OnRep_SpellCounterData();

	EK36MagicItemType GetMagicItemType() const;
	class UK36SpellCounterData* GetSpellCounterData() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K36MagicItem">();
	}
	static class AK36MagicItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK36MagicItem>();
	}
};
static_assert(alignof(AK36MagicItem) == 0x000008, "Wrong alignment on AK36MagicItem");
static_assert(sizeof(AK36MagicItem) == 0x000638, "Wrong size on AK36MagicItem");
static_assert(offsetof(AK36MagicItem, _magicItemType) == 0x000560, "Member 'AK36MagicItem::_magicItemType' has a wrong offset!");
static_assert(offsetof(AK36MagicItem, _magicItemRarity) == 0x000561, "Member 'AK36MagicItem::_magicItemRarity' has a wrong offset!");
static_assert(offsetof(AK36MagicItem, _rootComponent) == 0x000568, "Member 'AK36MagicItem::_rootComponent' has a wrong offset!");
static_assert(offsetof(AK36MagicItem, _staticMesh) == 0x000570, "Member 'AK36MagicItem::_staticMesh' has a wrong offset!");
static_assert(offsetof(AK36MagicItem, _imposedStatusEffect) == 0x000578, "Member 'AK36MagicItem::_imposedStatusEffect' has a wrong offset!");
static_assert(offsetof(AK36MagicItem, _magicItemState) == 0x000580, "Member 'AK36MagicItem::_magicItemState' has a wrong offset!");
static_assert(offsetof(AK36MagicItem, _spellCounter) == 0x000588, "Member 'AK36MagicItem::_spellCounter' has a wrong offset!");

// Class TheK36.K36MagicItemArtifact
// 0x01C0 (0x07F8 - 0x0638)
class AK36MagicItemArtifact final : public AK36MagicItem
{
public:
	class UInteractor*                            _interactor;                                       // 0x0638(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UK36MergeWithArtifactInteraction*       _mergeWithArtifactInteraction;                     // 0x0640(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UChargeableComponent*                   _chargeableComponent;                              // 0x0648(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UK36RecoverArtifactInteraction> _recoverArtifactInteractionClass;                  // 0x0650(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftClassPtr<class UClass>                   _artifactPowerComponentClass;                      // 0x0658(0x0038)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UK36ArtifactPowerComponent*             _artifactPowerComponent;                           // 0x0690(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNiagaraSystem*                         _chestRevealNiagaraSystem;                         // 0x0698(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTag                           _mergeStateTag;                                    // 0x06A0(0x000C)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   _attachmentSocketName;                             // 0x06AC(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _mergeWithVecnaArtifactChargeDuration;             // 0x06B8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class ACamperPlayer>           _mergedSurvivor;                                   // 0x06E0(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _hasCustomSkeletalMesh;                            // 0x06E8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6E9[0x10F];                                    // 0x06E9(0x010F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_DissolveArtifact();
	void Cosmetic_OnMagicArtifactMergedWithPlayer(class ACamperPlayer* Survivor);
	void Cosmetic_UpdateIsArtifactPowerAvailable(bool IsAvailable);
	void DissolveArtifact();
	void OnRep_MergedSurvivor();
	void OnSurvivorDamageStateChanged(ECamperDamageState OldDamageState, ECamperDamageState NewDamageState);

	bool HasBeenAssimilated() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K36MagicItemArtifact">();
	}
	static class AK36MagicItemArtifact* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK36MagicItemArtifact>();
	}
};
static_assert(alignof(AK36MagicItemArtifact) == 0x000008, "Wrong alignment on AK36MagicItemArtifact");
static_assert(sizeof(AK36MagicItemArtifact) == 0x0007F8, "Wrong size on AK36MagicItemArtifact");
static_assert(offsetof(AK36MagicItemArtifact, _interactor) == 0x000638, "Member 'AK36MagicItemArtifact::_interactor' has a wrong offset!");
static_assert(offsetof(AK36MagicItemArtifact, _mergeWithArtifactInteraction) == 0x000640, "Member 'AK36MagicItemArtifact::_mergeWithArtifactInteraction' has a wrong offset!");
static_assert(offsetof(AK36MagicItemArtifact, _chargeableComponent) == 0x000648, "Member 'AK36MagicItemArtifact::_chargeableComponent' has a wrong offset!");
static_assert(offsetof(AK36MagicItemArtifact, _recoverArtifactInteractionClass) == 0x000650, "Member 'AK36MagicItemArtifact::_recoverArtifactInteractionClass' has a wrong offset!");
static_assert(offsetof(AK36MagicItemArtifact, _artifactPowerComponentClass) == 0x000658, "Member 'AK36MagicItemArtifact::_artifactPowerComponentClass' has a wrong offset!");
static_assert(offsetof(AK36MagicItemArtifact, _artifactPowerComponent) == 0x000690, "Member 'AK36MagicItemArtifact::_artifactPowerComponent' has a wrong offset!");
static_assert(offsetof(AK36MagicItemArtifact, _chestRevealNiagaraSystem) == 0x000698, "Member 'AK36MagicItemArtifact::_chestRevealNiagaraSystem' has a wrong offset!");
static_assert(offsetof(AK36MagicItemArtifact, _mergeStateTag) == 0x0006A0, "Member 'AK36MagicItemArtifact::_mergeStateTag' has a wrong offset!");
static_assert(offsetof(AK36MagicItemArtifact, _attachmentSocketName) == 0x0006AC, "Member 'AK36MagicItemArtifact::_attachmentSocketName' has a wrong offset!");
static_assert(offsetof(AK36MagicItemArtifact, _mergeWithVecnaArtifactChargeDuration) == 0x0006B8, "Member 'AK36MagicItemArtifact::_mergeWithVecnaArtifactChargeDuration' has a wrong offset!");
static_assert(offsetof(AK36MagicItemArtifact, _mergedSurvivor) == 0x0006E0, "Member 'AK36MagicItemArtifact::_mergedSurvivor' has a wrong offset!");
static_assert(offsetof(AK36MagicItemArtifact, _hasCustomSkeletalMesh) == 0x0006E8, "Member 'AK36MagicItemArtifact::_hasCustomSkeletalMesh' has a wrong offset!");

// Class TheK36.K36MergeWithArtifactInteraction
// 0x0010 (0x08D0 - 0x08C0)
class UK36MergeWithArtifactInteraction final : public UChargeableInteractionDefinition
{
public:
	uint8                                         Pad_8C0[0x10];                                     // 0x08C0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K36MergeWithArtifactInteraction">();
	}
	static class UK36MergeWithArtifactInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK36MergeWithArtifactInteraction>();
	}
};
static_assert(alignof(UK36MergeWithArtifactInteraction) == 0x000010, "Wrong alignment on UK36MergeWithArtifactInteraction");
static_assert(sizeof(UK36MergeWithArtifactInteraction) == 0x0008D0, "Wrong size on UK36MergeWithArtifactInteraction");

// Class TheK36.K36MiniMageHand
// 0x0020 (0x0378 - 0x0358)
class AK36MiniMageHand final : public AAnimationFollowerActor
{
public:
	class FName                                   _survivorBoneSocketToAttachTo;                     // 0x0358(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_364[0x14];                                     // 0x0364(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K36MiniMageHand">();
	}
	static class AK36MiniMageHand* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK36MiniMageHand>();
	}
};
static_assert(alignof(AK36MiniMageHand) == 0x000008, "Wrong alignment on AK36MiniMageHand");
static_assert(sizeof(AK36MiniMageHand) == 0x000378, "Wrong size on AK36MiniMageHand");
static_assert(offsetof(AK36MiniMageHand, _survivorBoneSocketToAttachTo) == 0x000358, "Member 'AK36MiniMageHand::_survivorBoneSocketToAttachTo' has a wrong offset!");

// Class TheK36.K36MoriInteraction
// 0x0040 (0x0A20 - 0x09E0)
class UK36MoriInteraction final : public UK36BaseMoriInteraction
{
public:
	TSubclassOf<class AK36MoriSurvivorSkeleton>   _moriSkeletonClass;                                // 0x09D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AK36MoriSurvivorSkeleton*               _survivorMoriSkeleton;                             // 0x09E0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_9E8[0x38];                                     // 0x09E8(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K36MoriInteraction">();
	}
	static class UK36MoriInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK36MoriInteraction>();
	}
};
static_assert(alignof(UK36MoriInteraction) == 0x000010, "Wrong alignment on UK36MoriInteraction");
static_assert(sizeof(UK36MoriInteraction) == 0x000A20, "Wrong size on UK36MoriInteraction");
static_assert(offsetof(UK36MoriInteraction, _moriSkeletonClass) == 0x0009D8, "Member 'UK36MoriInteraction::_moriSkeletonClass' has a wrong offset!");
static_assert(offsetof(UK36MoriInteraction, _survivorMoriSkeleton) == 0x0009E0, "Member 'UK36MoriInteraction::_survivorMoriSkeleton' has a wrong offset!");

// Class TheK36.K36MoriSurvivorSkeleton
// 0x0018 (0x02B8 - 0x02A0)
class AK36MoriSurvivorSkeleton final : public AActor
{
public:
	class USceneComponent*                        _rootComponent;                                    // 0x02A0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDBDSkeletalMeshComponentBudgeted*      _budgetedSkeletalMeshComponent;                    // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMontagePlayer*                         _montagePlayerComponent;                           // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void Cosmetic_OnMontageStarted();
	void OnMontageStarted(const struct FAnimationMontageDescriptor& AnimMontageID, const float PlayRate);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K36MoriSurvivorSkeleton">();
	}
	static class AK36MoriSurvivorSkeleton* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK36MoriSurvivorSkeleton>();
	}
};
static_assert(alignof(AK36MoriSurvivorSkeleton) == 0x000008, "Wrong alignment on AK36MoriSurvivorSkeleton");
static_assert(sizeof(AK36MoriSurvivorSkeleton) == 0x0002B8, "Wrong size on AK36MoriSurvivorSkeleton");
static_assert(offsetof(AK36MoriSurvivorSkeleton, _rootComponent) == 0x0002A0, "Member 'AK36MoriSurvivorSkeleton::_rootComponent' has a wrong offset!");
static_assert(offsetof(AK36MoriSurvivorSkeleton, _budgetedSkeletalMeshComponent) == 0x0002A8, "Member 'AK36MoriSurvivorSkeleton::_budgetedSkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(AK36MoriSurvivorSkeleton, _montagePlayerComponent) == 0x0002B0, "Member 'AK36MoriSurvivorSkeleton::_montagePlayerComponent' has a wrong offset!");

// Class TheK36.K36OpenTreasureChestInteraction
// 0x00A0 (0x0960 - 0x08C0)
class UK36OpenTreasureChestInteraction final : public UChargeableInteractionDefinition
{
public:
	uint8                                         Pad_8C0[0x10];                                     // 0x08C0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _diceRollWaitDuration;                             // 0x08D0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FAnimationMontageDescriptor            _openChestSuccessAnimationID;                      // 0x08F8(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	bool                                          _isDiceRollFinished;                               // 0x0918(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_919[0x47];                                     // 0x0919(0x0047)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Multicast_TriggerEscapeMimicInteraction(class ACamperPlayer* Survivor);
	void OnRep_IsDiceRollFinished();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K36OpenTreasureChestInteraction">();
	}
	static class UK36OpenTreasureChestInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK36OpenTreasureChestInteraction>();
	}
};
static_assert(alignof(UK36OpenTreasureChestInteraction) == 0x000010, "Wrong alignment on UK36OpenTreasureChestInteraction");
static_assert(sizeof(UK36OpenTreasureChestInteraction) == 0x000960, "Wrong size on UK36OpenTreasureChestInteraction");
static_assert(offsetof(UK36OpenTreasureChestInteraction, _diceRollWaitDuration) == 0x0008D0, "Member 'UK36OpenTreasureChestInteraction::_diceRollWaitDuration' has a wrong offset!");
static_assert(offsetof(UK36OpenTreasureChestInteraction, _openChestSuccessAnimationID) == 0x0008F8, "Member 'UK36OpenTreasureChestInteraction::_openChestSuccessAnimationID' has a wrong offset!");
static_assert(offsetof(UK36OpenTreasureChestInteraction, _isDiceRollFinished) == 0x000918, "Member 'UK36OpenTreasureChestInteraction::_isDiceRollFinished' has a wrong offset!");

// Class TheK36.K36P01
// 0x0030 (0x04D0 - 0x04A0)
class UK36P01 final : public USpawningEffectPerk
{
public:
	TSubclassOf<class UStatusEffect>              _obliviousStatusEffectClass;                       // 0x04A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _obliviousStatusEffectDuration[0x3];               // 0x04A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4B4[0x4];                                      // 0x04B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UStatusEffect*                          _obliviousStatusEffect;                            // 0x04B8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class ACollectable*>                   _depletedSurvivorItems;                            // 0x04C0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	void Authority_OnIntroComplete();

	float GetK36P01ObliviousStatusEffectDurationAtLevel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K36P01">();
	}
	static class UK36P01* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK36P01>();
	}
};
static_assert(alignof(UK36P01) == 0x000008, "Wrong alignment on UK36P01");
static_assert(sizeof(UK36P01) == 0x0004D0, "Wrong size on UK36P01");
static_assert(offsetof(UK36P01, _obliviousStatusEffectClass) == 0x0004A0, "Member 'UK36P01::_obliviousStatusEffectClass' has a wrong offset!");
static_assert(offsetof(UK36P01, _obliviousStatusEffectDuration) == 0x0004A8, "Member 'UK36P01::_obliviousStatusEffectDuration' has a wrong offset!");
static_assert(offsetof(UK36P01, _obliviousStatusEffect) == 0x0004B8, "Member 'UK36P01::_obliviousStatusEffect' has a wrong offset!");
static_assert(offsetof(UK36P01, _depletedSurvivorItems) == 0x0004C0, "Member 'UK36P01::_depletedSurvivorItems' has a wrong offset!");

// Class TheK36.K36P02
// 0x0020 (0x0440 - 0x0420)
class UK36P02 final : public UPerk
{
public:
	TSubclassOf<class UStatusEffect>              _exhaustedStatusEffect;                            // 0x0420(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _exhaustedDuration[0x3];                           // 0x0428(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _cooldownDuration;                                 // 0x0434(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _rangeFromKiller;                                  // 0x0438(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_43C[0x4];                                      // 0x043C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetExhaustedDurationAtLevel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K36P02">();
	}
	static class UK36P02* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK36P02>();
	}
};
static_assert(alignof(UK36P02) == 0x000008, "Wrong alignment on UK36P02");
static_assert(sizeof(UK36P02) == 0x000440, "Wrong size on UK36P02");
static_assert(offsetof(UK36P02, _exhaustedStatusEffect) == 0x000420, "Member 'UK36P02::_exhaustedStatusEffect' has a wrong offset!");
static_assert(offsetof(UK36P02, _exhaustedDuration) == 0x000428, "Member 'UK36P02::_exhaustedDuration' has a wrong offset!");
static_assert(offsetof(UK36P02, _cooldownDuration) == 0x000434, "Member 'UK36P02::_cooldownDuration' has a wrong offset!");
static_assert(offsetof(UK36P02, _rangeFromKiller) == 0x000438, "Member 'UK36P02::_rangeFromKiller' has a wrong offset!");

// Class TheK36.K36P03
// 0x0000 (0x04A0 - 0x04A0)
class UK36P03 final : public USpawningEffectPerk
{
public:
	float GetVaultSpeedIncreasesAtLevel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K36P03">();
	}
	static class UK36P03* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK36P03>();
	}
};
static_assert(alignof(UK36P03) == 0x000008, "Wrong alignment on UK36P03");
static_assert(sizeof(UK36P03) == 0x0004A0, "Wrong size on UK36P03");

// Class TheK36.K36PalletFlyCollisionHandlerComponent
// 0x0000 (0x05F0 - 0x05F0)
class UK36PalletFlyCollisionHandlerComponent final : public UIgnoreCollisionsPalletHandlerComponent
{
public:
	void OnComponentEndOverlapWithKiller(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K36PalletFlyCollisionHandlerComponent">();
	}
	static class UK36PalletFlyCollisionHandlerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK36PalletFlyCollisionHandlerComponent>();
	}
};
static_assert(alignof(UK36PalletFlyCollisionHandlerComponent) == 0x000010, "Wrong alignment on UK36PalletFlyCollisionHandlerComponent");
static_assert(sizeof(UK36PalletFlyCollisionHandlerComponent) == 0x0005F0, "Wrong size on UK36PalletFlyCollisionHandlerComponent");

// Class TheK36.K36Power
// 0x0138 (0x0730 - 0x05F8)
class AK36Power final : public AKillerPower
{
public:
	TSubclassOf<class AK36SpellTrajectoryPreviewer> _spellTrajectoryPreviewerClass;                    // 0x05F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AK36SpellTrajectoryPreviewer*           _spellTrajectoryPreviewer;                         // 0x0600(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UK36PowerChargePresentationItemProgressComponent* _powerChargePresentationItemProgress;              // 0x0608(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UK36PresentationPowerFadeOutComponent*  _powerFadeOutComponent;                            // 0x0610(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class AAnimationFollowerActor>    _moriSkeletonsAnimationFollowerActorClass;         // 0x0618(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class AAnimationFollowerActor>    _miniMageHandAnimationFollowerActorClass;          // 0x0620(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class AK36Spikes>                 _spikesActorClass;                                 // 0x0628(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AK36Spikes*                             _spikesActor;                                      // 0x0630(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         _defaultNumberOfMoriSkeletons;                     // 0x0638(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         _switchNumberOfMoriSkeletons;                      // 0x063C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             _vecnaArtifactAnimationMappingsTables;             // 0x0640(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _timeToAttackAfterActivatingSpellToTriggerScoreEvent; // 0x0648(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class FName                                   _miniMageHandSocketName;                           // 0x0670(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _minimumTimeBetweenKillerStartMovingEventsTriggered; // 0x067C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_680[0xB0];                                     // 0x0680(0x00B0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K36Power">();
	}
	static class AK36Power* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK36Power>();
	}
};
static_assert(alignof(AK36Power) == 0x000008, "Wrong alignment on AK36Power");
static_assert(sizeof(AK36Power) == 0x000730, "Wrong size on AK36Power");
static_assert(offsetof(AK36Power, _spellTrajectoryPreviewerClass) == 0x0005F8, "Member 'AK36Power::_spellTrajectoryPreviewerClass' has a wrong offset!");
static_assert(offsetof(AK36Power, _spellTrajectoryPreviewer) == 0x000600, "Member 'AK36Power::_spellTrajectoryPreviewer' has a wrong offset!");
static_assert(offsetof(AK36Power, _powerChargePresentationItemProgress) == 0x000608, "Member 'AK36Power::_powerChargePresentationItemProgress' has a wrong offset!");
static_assert(offsetof(AK36Power, _powerFadeOutComponent) == 0x000610, "Member 'AK36Power::_powerFadeOutComponent' has a wrong offset!");
static_assert(offsetof(AK36Power, _moriSkeletonsAnimationFollowerActorClass) == 0x000618, "Member 'AK36Power::_moriSkeletonsAnimationFollowerActorClass' has a wrong offset!");
static_assert(offsetof(AK36Power, _miniMageHandAnimationFollowerActorClass) == 0x000620, "Member 'AK36Power::_miniMageHandAnimationFollowerActorClass' has a wrong offset!");
static_assert(offsetof(AK36Power, _spikesActorClass) == 0x000628, "Member 'AK36Power::_spikesActorClass' has a wrong offset!");
static_assert(offsetof(AK36Power, _spikesActor) == 0x000630, "Member 'AK36Power::_spikesActor' has a wrong offset!");
static_assert(offsetof(AK36Power, _defaultNumberOfMoriSkeletons) == 0x000638, "Member 'AK36Power::_defaultNumberOfMoriSkeletons' has a wrong offset!");
static_assert(offsetof(AK36Power, _switchNumberOfMoriSkeletons) == 0x00063C, "Member 'AK36Power::_switchNumberOfMoriSkeletons' has a wrong offset!");
static_assert(offsetof(AK36Power, _vecnaArtifactAnimationMappingsTables) == 0x000640, "Member 'AK36Power::_vecnaArtifactAnimationMappingsTables' has a wrong offset!");
static_assert(offsetof(AK36Power, _timeToAttackAfterActivatingSpellToTriggerScoreEvent) == 0x000648, "Member 'AK36Power::_timeToAttackAfterActivatingSpellToTriggerScoreEvent' has a wrong offset!");
static_assert(offsetof(AK36Power, _miniMageHandSocketName) == 0x000670, "Member 'AK36Power::_miniMageHandSocketName' has a wrong offset!");
static_assert(offsetof(AK36Power, _minimumTimeBetweenKillerStartMovingEventsTriggered) == 0x00067C, "Member 'AK36Power::_minimumTimeBetweenKillerStartMovingEventsTriggered' has a wrong offset!");

// Class TheK36.K36PowerAddon15
// 0x00C0 (0x03A8 - 0x02E8)
class UK36PowerAddon15 final : public UItemAddon
{
public:
	TSubclassOf<class UStatusEffect>              _revealEffectToImposeOnSurvivor;                   // 0x02E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _revealEffectLifetime;                             // 0x02F0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _distanceBetweenSurvivorAndChest;                  // 0x0318(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_340[0x68];                                     // 0x0340(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K36PowerAddon15">();
	}
	static class UK36PowerAddon15* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK36PowerAddon15>();
	}
};
static_assert(alignof(UK36PowerAddon15) == 0x000008, "Wrong alignment on UK36PowerAddon15");
static_assert(sizeof(UK36PowerAddon15) == 0x0003A8, "Wrong size on UK36PowerAddon15");
static_assert(offsetof(UK36PowerAddon15, _revealEffectToImposeOnSurvivor) == 0x0002E8, "Member 'UK36PowerAddon15::_revealEffectToImposeOnSurvivor' has a wrong offset!");
static_assert(offsetof(UK36PowerAddon15, _revealEffectLifetime) == 0x0002F0, "Member 'UK36PowerAddon15::_revealEffectLifetime' has a wrong offset!");
static_assert(offsetof(UK36PowerAddon15, _distanceBetweenSurvivorAndChest) == 0x000318, "Member 'UK36PowerAddon15::_distanceBetweenSurvivorAndChest' has a wrong offset!");

// Class TheK36.K36RadialSelectionComponent
// 0x0080 (0x0128 - 0x00A8)
class UK36RadialSelectionComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x58];                                      // 0x00A8(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRadialMenuParameters                  _radialMenuParameters;                             // 0x0100(0x0024)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	float                                         _debugShowTimeAfterMenuCloses;                     // 0x0124(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K36RadialSelectionComponent">();
	}
	static class UK36RadialSelectionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK36RadialSelectionComponent>();
	}
};
static_assert(alignof(UK36RadialSelectionComponent) == 0x000008, "Wrong alignment on UK36RadialSelectionComponent");
static_assert(sizeof(UK36RadialSelectionComponent) == 0x000128, "Wrong size on UK36RadialSelectionComponent");
static_assert(offsetof(UK36RadialSelectionComponent, _radialMenuParameters) == 0x000100, "Member 'UK36RadialSelectionComponent::_radialMenuParameters' has a wrong offset!");
static_assert(offsetof(UK36RadialSelectionComponent, _debugShowTimeAfterMenuCloses) == 0x000124, "Member 'UK36RadialSelectionComponent::_debugShowTimeAfterMenuCloses' has a wrong offset!");

// Class TheK36.K36RecoverArtifactInteraction
// 0x0020 (0x0A00 - 0x09E0)
class UK36RecoverArtifactInteraction final : public UK36BaseMoriInteraction
{
public:
	struct FAnimationMontageDescriptor            _miniMoriMontage;                                  // 0x09D8(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_9F8[0x8];                                      // 0x09F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K36RecoverArtifactInteraction">();
	}
	static class UK36RecoverArtifactInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK36RecoverArtifactInteraction>();
	}
};
static_assert(alignof(UK36RecoverArtifactInteraction) == 0x000010, "Wrong alignment on UK36RecoverArtifactInteraction");
static_assert(sizeof(UK36RecoverArtifactInteraction) == 0x000A00, "Wrong size on UK36RecoverArtifactInteraction");
static_assert(offsetof(UK36RecoverArtifactInteraction, _miniMoriMontage) == 0x0009D8, "Member 'UK36RecoverArtifactInteraction::_miniMoriMontage' has a wrong offset!");

// Class TheK36.K36SelectSpellInteraction
// 0x0120 (0x08A0 - 0x0780)
class UK36SelectSpellInteraction final : public UInteractionDefinition
{
public:
	struct FDBDTunableRowHandle                   _yawScale;                                         // 0x0778(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _pitchScale;                                       // 0x07A0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _yawPitchAdjustTime;                               // 0x07C8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class UK36RadialSelectionComponent*           _radialSelectionComponent;                         // 0x07F0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FRadialMenuParameters                  _radialMenuParameters;                             // 0x07F8(0x0024)(Edit, Transient, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_81C[0x4];                                      // 0x081C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FK36SpellSelectionOptionsParameters> _spellSelectionOptionParameters;                   // 0x0820(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_830[0x70];                                     // 0x0830(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K36SelectSpellInteraction">();
	}
	static class UK36SelectSpellInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK36SelectSpellInteraction>();
	}
};
static_assert(alignof(UK36SelectSpellInteraction) == 0x000010, "Wrong alignment on UK36SelectSpellInteraction");
static_assert(sizeof(UK36SelectSpellInteraction) == 0x0008A0, "Wrong size on UK36SelectSpellInteraction");
static_assert(offsetof(UK36SelectSpellInteraction, _yawScale) == 0x000778, "Member 'UK36SelectSpellInteraction::_yawScale' has a wrong offset!");
static_assert(offsetof(UK36SelectSpellInteraction, _pitchScale) == 0x0007A0, "Member 'UK36SelectSpellInteraction::_pitchScale' has a wrong offset!");
static_assert(offsetof(UK36SelectSpellInteraction, _yawPitchAdjustTime) == 0x0007C8, "Member 'UK36SelectSpellInteraction::_yawPitchAdjustTime' has a wrong offset!");
static_assert(offsetof(UK36SelectSpellInteraction, _radialSelectionComponent) == 0x0007F0, "Member 'UK36SelectSpellInteraction::_radialSelectionComponent' has a wrong offset!");
static_assert(offsetof(UK36SelectSpellInteraction, _radialMenuParameters) == 0x0007F8, "Member 'UK36SelectSpellInteraction::_radialMenuParameters' has a wrong offset!");
static_assert(offsetof(UK36SelectSpellInteraction, _spellSelectionOptionParameters) == 0x000820, "Member 'UK36SelectSpellInteraction::_spellSelectionOptionParameters' has a wrong offset!");

// Class TheK36.K36SpellCounterData
// 0x0130 (0x0168 - 0x0038)
class UK36SpellCounterData final : public UDataAsset
{
public:
	TSubclassOf<class UK36SpellCounterStatusEffect> _counterStatusEffect;                              // 0x0038(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UK36SpellData*                          _associatedSpell;                                  // 0x0040(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FText                                   _spellCounterName;                                 // 0x0048(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class FText                                   _spellCounterDescription;                          // 0x0060(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UTexture2D>              _uiIcon;                                           // 0x0078(0x0038)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTag                           _spellActivationEvent;                             // 0x00B0(0x000C)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<struct FK36MagicItemNiagaraSystemByColorBlindSetting> _bracersNiagaraSystemColorBlindSettingOverrides;   // 0x00C0(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TSet<struct FK36MagicItemNiagaraSystemByColorBlindSetting> _bootsNiagaraSystemColorBlindSettingOverrides;     // 0x0110(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class UNiagaraSystem*                         _chestRevealNiagaraSystem;                         // 0x0160(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K36SpellCounterData">();
	}
	static class UK36SpellCounterData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK36SpellCounterData>();
	}
};
static_assert(alignof(UK36SpellCounterData) == 0x000008, "Wrong alignment on UK36SpellCounterData");
static_assert(sizeof(UK36SpellCounterData) == 0x000168, "Wrong size on UK36SpellCounterData");
static_assert(offsetof(UK36SpellCounterData, _counterStatusEffect) == 0x000038, "Member 'UK36SpellCounterData::_counterStatusEffect' has a wrong offset!");
static_assert(offsetof(UK36SpellCounterData, _associatedSpell) == 0x000040, "Member 'UK36SpellCounterData::_associatedSpell' has a wrong offset!");
static_assert(offsetof(UK36SpellCounterData, _spellCounterName) == 0x000048, "Member 'UK36SpellCounterData::_spellCounterName' has a wrong offset!");
static_assert(offsetof(UK36SpellCounterData, _spellCounterDescription) == 0x000060, "Member 'UK36SpellCounterData::_spellCounterDescription' has a wrong offset!");
static_assert(offsetof(UK36SpellCounterData, _uiIcon) == 0x000078, "Member 'UK36SpellCounterData::_uiIcon' has a wrong offset!");
static_assert(offsetof(UK36SpellCounterData, _spellActivationEvent) == 0x0000B0, "Member 'UK36SpellCounterData::_spellActivationEvent' has a wrong offset!");
static_assert(offsetof(UK36SpellCounterData, _bracersNiagaraSystemColorBlindSettingOverrides) == 0x0000C0, "Member 'UK36SpellCounterData::_bracersNiagaraSystemColorBlindSettingOverrides' has a wrong offset!");
static_assert(offsetof(UK36SpellCounterData, _bootsNiagaraSystemColorBlindSettingOverrides) == 0x000110, "Member 'UK36SpellCounterData::_bootsNiagaraSystemColorBlindSettingOverrides' has a wrong offset!");
static_assert(offsetof(UK36SpellCounterData, _chestRevealNiagaraSystem) == 0x000160, "Member 'UK36SpellCounterData::_chestRevealNiagaraSystem' has a wrong offset!");

// Class TheK36.K36SpellCounterStatusEffect
// 0x00A0 (0x0420 - 0x0380)
class UK36SpellCounterStatusEffect final : public UStatusEffect
{
public:
	uint8                                         Pad_380[0x18];                                     // 0x0380(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           _statusEffectsTriggerEvent;                        // 0x0398(0x000C)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3A4[0x4];                                      // 0x03A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FK36EventBasedCounterStatusEffectInfo> _eventBasedStatusEffects;                          // 0x03A8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TArray<class UStatusEffect*>                  _imposedStatusEffects;                             // 0x03B8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	bool                                          _isSpellCounterActive;                             // 0x03C8(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3C9[0x7];                                      // 0x03C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AActor>                     _watchedActorClass;                                // 0x03D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTag                           _watchedActorsStateTag;                            // 0x03D8(0x000C)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3E4[0x4];                                      // 0x03E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         _watchedActors;                                    // 0x03E8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3F8[0x28];                                     // 0x03F8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_IsSpellCounterActive();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K36SpellCounterStatusEffect">();
	}
	static class UK36SpellCounterStatusEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK36SpellCounterStatusEffect>();
	}
};
static_assert(alignof(UK36SpellCounterStatusEffect) == 0x000008, "Wrong alignment on UK36SpellCounterStatusEffect");
static_assert(sizeof(UK36SpellCounterStatusEffect) == 0x000420, "Wrong size on UK36SpellCounterStatusEffect");
static_assert(offsetof(UK36SpellCounterStatusEffect, _statusEffectsTriggerEvent) == 0x000398, "Member 'UK36SpellCounterStatusEffect::_statusEffectsTriggerEvent' has a wrong offset!");
static_assert(offsetof(UK36SpellCounterStatusEffect, _eventBasedStatusEffects) == 0x0003A8, "Member 'UK36SpellCounterStatusEffect::_eventBasedStatusEffects' has a wrong offset!");
static_assert(offsetof(UK36SpellCounterStatusEffect, _imposedStatusEffects) == 0x0003B8, "Member 'UK36SpellCounterStatusEffect::_imposedStatusEffects' has a wrong offset!");
static_assert(offsetof(UK36SpellCounterStatusEffect, _isSpellCounterActive) == 0x0003C8, "Member 'UK36SpellCounterStatusEffect::_isSpellCounterActive' has a wrong offset!");
static_assert(offsetof(UK36SpellCounterStatusEffect, _watchedActorClass) == 0x0003D0, "Member 'UK36SpellCounterStatusEffect::_watchedActorClass' has a wrong offset!");
static_assert(offsetof(UK36SpellCounterStatusEffect, _watchedActorsStateTag) == 0x0003D8, "Member 'UK36SpellCounterStatusEffect::_watchedActorsStateTag' has a wrong offset!");
static_assert(offsetof(UK36SpellCounterStatusEffect, _watchedActors) == 0x0003E8, "Member 'UK36SpellCounterStatusEffect::_watchedActors' has a wrong offset!");

// Class TheK36.K36SpellData
// 0x0040 (0x0078 - 0x0038)
class UK36SpellData final : public UDataAsset
{
public:
	TSubclassOf<class UK36SpellInteraction>       _spellInteractionClass;                            // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         _powerIconID;                                      // 0x0040(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EK36SpellType                                 _spellType;                                        // 0x0041(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_42[0x6];                                       // 0x0042(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          _spellStartChargeAkEvent;                          // 0x0048(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          _spellActivatedAkEvent;                            // 0x0050(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          _spellCancelledAkEvent;                            // 0x0058(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraSystem*                         _spellMenuVFX;                                     // 0x0060(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _selectSpellGameEvent;                             // 0x0068(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K36SpellData">();
	}
	static class UK36SpellData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK36SpellData>();
	}
};
static_assert(alignof(UK36SpellData) == 0x000008, "Wrong alignment on UK36SpellData");
static_assert(sizeof(UK36SpellData) == 0x000078, "Wrong size on UK36SpellData");
static_assert(offsetof(UK36SpellData, _spellInteractionClass) == 0x000038, "Member 'UK36SpellData::_spellInteractionClass' has a wrong offset!");
static_assert(offsetof(UK36SpellData, _powerIconID) == 0x000040, "Member 'UK36SpellData::_powerIconID' has a wrong offset!");
static_assert(offsetof(UK36SpellData, _spellType) == 0x000041, "Member 'UK36SpellData::_spellType' has a wrong offset!");
static_assert(offsetof(UK36SpellData, _spellStartChargeAkEvent) == 0x000048, "Member 'UK36SpellData::_spellStartChargeAkEvent' has a wrong offset!");
static_assert(offsetof(UK36SpellData, _spellActivatedAkEvent) == 0x000050, "Member 'UK36SpellData::_spellActivatedAkEvent' has a wrong offset!");
static_assert(offsetof(UK36SpellData, _spellCancelledAkEvent) == 0x000058, "Member 'UK36SpellData::_spellCancelledAkEvent' has a wrong offset!");
static_assert(offsetof(UK36SpellData, _spellMenuVFX) == 0x000060, "Member 'UK36SpellData::_spellMenuVFX' has a wrong offset!");
static_assert(offsetof(UK36SpellData, _selectSpellGameEvent) == 0x000068, "Member 'UK36SpellData::_selectSpellGameEvent' has a wrong offset!");

// Class TheK36.K36SpellManagerComponent
// 0x00A0 (0x0148 - 0x00A8)
class UK36SpellManagerComponent final : public UActorComponent
{
public:
	class UK36SpellData*                          _topSpellData;                                     // 0x00A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UK36SpellData*                          _bottomSpellData;                                  // 0x00B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UK36SpellData*                          _leftSpellData;                                    // 0x00B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UK36SpellData*                          _rightSpellData;                                   // 0x00C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EK36SpellSlot                                 _currentlySelectedSpellSlot;                       // 0x00C8(0x0001)(Edit, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C9[0x7];                                       // 0x00C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FK36SpellSlotData>              _spellsData;                                       // 0x00D0(0x0010)(Net, ZeroConstructor, RepNotify, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FVector2D                              _initialOffset;                                    // 0x00E0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FVector2D>                      _numberOfSpellsInitialPositions;                   // 0x00F0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	float                                         _spellOffsetFromCenter;                            // 0x0100(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_104[0x4];                                      // 0x0104(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameplayTag>                   _spellVignetteInvisibleStateTag;                   // 0x0108(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_118[0x30];                                     // 0x0118(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnLevelReadyToPlay();
	void OnRep_CurrentlySelectedSpellSlot();
	void OnRep_SpellsData();
	void Server_SetSelectedSpellSlot(EK36SpellSlot SelectedSpellSlot);
	void Server_SetSelectedSpellSlot_Unreliable(EK36SpellSlot SelectedSpellSlot);
	void UpdateSpellVignetteVFXActivationState();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K36SpellManagerComponent">();
	}
	static class UK36SpellManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK36SpellManagerComponent>();
	}
};
static_assert(alignof(UK36SpellManagerComponent) == 0x000008, "Wrong alignment on UK36SpellManagerComponent");
static_assert(sizeof(UK36SpellManagerComponent) == 0x000148, "Wrong size on UK36SpellManagerComponent");
static_assert(offsetof(UK36SpellManagerComponent, _topSpellData) == 0x0000A8, "Member 'UK36SpellManagerComponent::_topSpellData' has a wrong offset!");
static_assert(offsetof(UK36SpellManagerComponent, _bottomSpellData) == 0x0000B0, "Member 'UK36SpellManagerComponent::_bottomSpellData' has a wrong offset!");
static_assert(offsetof(UK36SpellManagerComponent, _leftSpellData) == 0x0000B8, "Member 'UK36SpellManagerComponent::_leftSpellData' has a wrong offset!");
static_assert(offsetof(UK36SpellManagerComponent, _rightSpellData) == 0x0000C0, "Member 'UK36SpellManagerComponent::_rightSpellData' has a wrong offset!");
static_assert(offsetof(UK36SpellManagerComponent, _currentlySelectedSpellSlot) == 0x0000C8, "Member 'UK36SpellManagerComponent::_currentlySelectedSpellSlot' has a wrong offset!");
static_assert(offsetof(UK36SpellManagerComponent, _spellsData) == 0x0000D0, "Member 'UK36SpellManagerComponent::_spellsData' has a wrong offset!");
static_assert(offsetof(UK36SpellManagerComponent, _initialOffset) == 0x0000E0, "Member 'UK36SpellManagerComponent::_initialOffset' has a wrong offset!");
static_assert(offsetof(UK36SpellManagerComponent, _numberOfSpellsInitialPositions) == 0x0000F0, "Member 'UK36SpellManagerComponent::_numberOfSpellsInitialPositions' has a wrong offset!");
static_assert(offsetof(UK36SpellManagerComponent, _spellOffsetFromCenter) == 0x000100, "Member 'UK36SpellManagerComponent::_spellOffsetFromCenter' has a wrong offset!");
static_assert(offsetof(UK36SpellManagerComponent, _spellVignetteInvisibleStateTag) == 0x000108, "Member 'UK36SpellManagerComponent::_spellVignetteInvisibleStateTag' has a wrong offset!");

// Class TheK36.K36SpellTrajectoryPreviewer
// 0x0050 (0x02F0 - 0x02A0)
class AK36SpellTrajectoryPreviewer final : public AActor
{
public:
	class USceneComponent*                        _root;                                             // 0x02A0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UStaticMeshComponent>       _trajectoryMeshComponentClass;                     // 0x02A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UStaticMeshComponent*>           _trajectoryPreviewerMeshes;                        // 0x02B0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C0[0x8];                                      // 0x02C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _materialLoopTime;                                 // 0x02C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2CC[0x24];                                     // 0x02CC(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K36SpellTrajectoryPreviewer">();
	}
	static class AK36SpellTrajectoryPreviewer* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK36SpellTrajectoryPreviewer>();
	}
};
static_assert(alignof(AK36SpellTrajectoryPreviewer) == 0x000008, "Wrong alignment on AK36SpellTrajectoryPreviewer");
static_assert(sizeof(AK36SpellTrajectoryPreviewer) == 0x0002F0, "Wrong size on AK36SpellTrajectoryPreviewer");
static_assert(offsetof(AK36SpellTrajectoryPreviewer, _root) == 0x0002A0, "Member 'AK36SpellTrajectoryPreviewer::_root' has a wrong offset!");
static_assert(offsetof(AK36SpellTrajectoryPreviewer, _trajectoryMeshComponentClass) == 0x0002A8, "Member 'AK36SpellTrajectoryPreviewer::_trajectoryMeshComponentClass' has a wrong offset!");
static_assert(offsetof(AK36SpellTrajectoryPreviewer, _trajectoryPreviewerMeshes) == 0x0002B0, "Member 'AK36SpellTrajectoryPreviewer::_trajectoryPreviewerMeshes' has a wrong offset!");
static_assert(offsetof(AK36SpellTrajectoryPreviewer, _materialLoopTime) == 0x0002C8, "Member 'AK36SpellTrajectoryPreviewer::_materialLoopTime' has a wrong offset!");

// Class TheK36.K36Spikes
// 0x0038 (0x02D8 - 0x02A0)
class AK36Spikes final : public AActor
{
public:
	class USceneComponent*                        _rootComponent;                                    // 0x02A0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   _staticMeshComponent;                              // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _moriAttachSocket;                                 // 0x02B0(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2BC[0x1C];                                     // 0x02BC(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BreakablesSpikesAppears();
	void Cosmetic_SetVisibility(bool IsVisible);
	void GeneratorSpikesAppears();
	void MoriSpikesAppears();
	void PalletSpikesAppears();
	void SetSpikesVisibility(bool Visibility, bool Forced);

	EK36SpikesEventType GetSpikesEventType() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K36Spikes">();
	}
	static class AK36Spikes* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK36Spikes>();
	}
};
static_assert(alignof(AK36Spikes) == 0x000008, "Wrong alignment on AK36Spikes");
static_assert(sizeof(AK36Spikes) == 0x0002D8, "Wrong size on AK36Spikes");
static_assert(offsetof(AK36Spikes, _rootComponent) == 0x0002A0, "Member 'AK36Spikes::_rootComponent' has a wrong offset!");
static_assert(offsetof(AK36Spikes, _staticMeshComponent) == 0x0002A8, "Member 'AK36Spikes::_staticMeshComponent' has a wrong offset!");
static_assert(offsetof(AK36Spikes, _moriAttachSocket) == 0x0002B0, "Member 'AK36Spikes::_moriAttachSocket' has a wrong offset!");

// Class TheK36.K36SurvivorAnimInstance
// 0x0010 (0x05F0 - 0x05E0)
class UK36SurvivorAnimInstance final : public UBaseSurvivorAnimInstance
{
public:
	bool                                          _hasMergedWithVecnaHand;                           // 0x05E0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isPlayingMergeWithHandOutAnimation;               // 0x05E1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isPlayingMergeWithEyeOutAnimation;                // 0x05E2(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isIdle;                                           // 0x05E3(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isFemale;                                         // 0x05E4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5E5[0xB];                                      // 0x05E5(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K36SurvivorAnimInstance">();
	}
	static class UK36SurvivorAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK36SurvivorAnimInstance>();
	}
};
static_assert(alignof(UK36SurvivorAnimInstance) == 0x000010, "Wrong alignment on UK36SurvivorAnimInstance");
static_assert(sizeof(UK36SurvivorAnimInstance) == 0x0005F0, "Wrong size on UK36SurvivorAnimInstance");
static_assert(offsetof(UK36SurvivorAnimInstance, _hasMergedWithVecnaHand) == 0x0005E0, "Member 'UK36SurvivorAnimInstance::_hasMergedWithVecnaHand' has a wrong offset!");
static_assert(offsetof(UK36SurvivorAnimInstance, _isPlayingMergeWithHandOutAnimation) == 0x0005E1, "Member 'UK36SurvivorAnimInstance::_isPlayingMergeWithHandOutAnimation' has a wrong offset!");
static_assert(offsetof(UK36SurvivorAnimInstance, _isPlayingMergeWithEyeOutAnimation) == 0x0005E2, "Member 'UK36SurvivorAnimInstance::_isPlayingMergeWithEyeOutAnimation' has a wrong offset!");
static_assert(offsetof(UK36SurvivorAnimInstance, _isIdle) == 0x0005E3, "Member 'UK36SurvivorAnimInstance::_isIdle' has a wrong offset!");
static_assert(offsetof(UK36SurvivorAnimInstance, _isFemale) == 0x0005E4, "Member 'UK36SurvivorAnimInstance::_isFemale' has a wrong offset!");

// Class TheK36.K36SurvivorCosmeticHelperActor
// 0x0058 (0x0360 - 0x0308)
class AK36SurvivorCosmeticHelperActor final : public ASurvivorCosmeticHelperActor
{
public:
	uint8                                         Pad_308[0x58];                                     // 0x0308(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_DissolveArtifacts();
	void Cosmetic_OnImposedScreamOnDetectedWhileInjured();
	void Cosmetic_OnInvisibilityPreEnd();
	void Cosmetic_OnMergeWithEyeArtifact(class AK36MagicItemArtifact* Artifact);
	void Cosmetic_OnMergeWithHandArtifact(class AK36MagicItemArtifact* Artifact);
	void Cosmetic_OnSurvivorDetectedByDetectionSpell();
	void Cosmetic_OnSurvivorIsInvisibleChanged(bool IsInvisible, bool IsObservingKiller);
	void Cosmetic_OnSurvivorTeleportTriggered(class ALocker* StartLocker, class ALocker* EndLocker);
	struct FVector GetBoneInitialLocation(class FName BoneName);
	void OnLocallyObservedPawnChanged();
	void OnSurvivorDamageStateChanged(ECamperDamageState OldDamageState, ECamperDamageState NewDamageState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K36SurvivorCosmeticHelperActor">();
	}
	static class AK36SurvivorCosmeticHelperActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK36SurvivorCosmeticHelperActor>();
	}
};
static_assert(alignof(AK36SurvivorCosmeticHelperActor) == 0x000008, "Wrong alignment on AK36SurvivorCosmeticHelperActor");
static_assert(sizeof(AK36SurvivorCosmeticHelperActor) == 0x000360, "Wrong size on AK36SurvivorCosmeticHelperActor");

// Class TheK36.K36SurvivorMagicItemInventoryComponent
// 0x00D0 (0x0178 - 0x00A8)
class UK36SurvivorMagicItemInventoryComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FK36MagicItemSlotData>          _magicItemSlots;                                   // 0x00B0(0x0010)(Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C0[0xB8];                                      // 0x00C0(0x00B8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_MagicItemSlots();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K36SurvivorMagicItemInventoryComponent">();
	}
	static class UK36SurvivorMagicItemInventoryComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK36SurvivorMagicItemInventoryComponent>();
	}
};
static_assert(alignof(UK36SurvivorMagicItemInventoryComponent) == 0x000008, "Wrong alignment on UK36SurvivorMagicItemInventoryComponent");
static_assert(sizeof(UK36SurvivorMagicItemInventoryComponent) == 0x000178, "Wrong size on UK36SurvivorMagicItemInventoryComponent");
static_assert(offsetof(UK36SurvivorMagicItemInventoryComponent, _magicItemSlots) == 0x0000B0, "Member 'UK36SurvivorMagicItemInventoryComponent::_magicItemSlots' has a wrong offset!");

// Class TheK36.K36TreasureChest
// 0x0220 (0x05C8 - 0x03A8)
class AK36TreasureChest final : public AInteractable
{
public:
	uint8                                         Pad_3A8[0x18];                                     // 0x03A8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        _rootComponent;                                    // 0x03C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoClear, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          _collisionComponent;                               // 0x03C8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoClear, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDBDSkeletalMeshComponentBudgeted*      _skeletalMeshComponent;                            // 0x03D0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoClear, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDBDSkeletalMeshComponentBudgeted*      _mimicSkeletalMeshComponent;                       // 0x03D8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoClear, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDBDSkeletalMeshComponentBudgeted*      _mimicDisguiseMeshComponent;                       // 0x03E0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoClear, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMontagePlayer*                         _montagePlayer;                                    // 0x03E8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoClear, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimationMontageSlave*                 _montageFollower;                                  // 0x03F0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoClear, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class ACollectable>            _itemInChest;                                      // 0x03F8(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ACamperPlayer*                          _trappedSurvivor;                                  // 0x0400(0x0008)(Net, ZeroConstructor, Transient, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EK36TreasureChestState                        _treasureChestState;                               // 0x0408(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_409[0x7];                                      // 0x0409(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTimerObject*                           _resetTimer;                                       // 0x0410(0x0008)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   _magicItemSocketName;                              // 0x0418(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_424[0x4];                                      // 0x0424(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraSystem*                         _defaultItemInChestNiagaraSystem;                  // 0x0428(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNiagaraSystem*                         _killerPOVNiagaraSystem;                           // 0x0430(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDBDOutlineComponent*                   _outlineComponent;                                 // 0x0438(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UK36TreasureChestOutlineUpdateStrategy* _treasureOutlineUpdateStrategy;                    // 0x0440(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBoxComponent*                          _interactionZone;                                  // 0x0448(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInteractor*                            _interactor;                                       // 0x0450(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UChargeableComponent*                   _openTreasureChestChargeableComponent;             // 0x0458(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UK36OpenTreasureChestInteraction*       _openTreasureChestInteraction;                     // 0x0460(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoClear, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UK36EscapeFromMimicChestInteraction*    _escapeFromMimicInteraction;                       // 0x0468(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoClear, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UChargeableComponent*                   _escapeFromMimicChargeableComponent;               // 0x0470(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoClear, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UK36CollectItemFromTreasureChestInteraction* _collectItemFromTreasureChestInteraction;          // 0x0478(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoClear, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _openTreasureChestSecondsToCharge;                 // 0x0480(0x0028)(Edit, DisableEditOnInstance, NoClear, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _escapeFromMimicSecondsToCharge;                   // 0x04A8(0x0028)(Edit, DisableEditOnInstance, NoClear, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _resetDuration;                                    // 0x04D0(0x0028)(Edit, DisableEditOnInstance, NoClear, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _mimicSwapTimerDuration;                           // 0x04F8(0x0028)(Edit, DisableEditOnInstance, NoClear, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _mimicDisguisesItselfTime;                         // 0x0520(0x0028)(Edit, DisableEditOnInstance, NoClear, NativeAccessSpecifierPrivate)
	int32                                         _rollValue;                                        // 0x0548(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_54C[0x4];                                      // 0x054C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraSystem*                         _currentSmokeVFX;                                  // 0x0550(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_558[0x8];                                      // 0x0558(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _hasBeenRevealedAsMimic;                           // 0x0560(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_561[0x67];                                     // 0x0561(0x0067)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_OnDiceRollTriggered(class ADBDPlayer* RollingPlayer);
	void Cosmetic_OnMimicSwappedToDisguisedVersion();
	void Cosmetic_OnTreasureChestOpenedWithMagicItem();
	void Cosmetic_OnTreasureChestStateChanged(EK36TreasureChestState PreviousTreasureChestState, EK36TreasureChestState NewTreasureChestState);
	void Cosmetic_OnTreasureChestSwappedToMimic();
	void Cosmetic_UpdateIsSurvivorTrappedFX(bool IsSurvivorTrapped);
	void Cosmetic_UpdateTreasureChestOpenVFX(class UNiagaraSystem* NewItemChestRevealNiagaraSystem);
	void Cosmetic_UpdateTreasureChestResetState(float ResetElapsedTimePercent);
	void Multicast_TriggerDiceRoll(class ACamperPlayer* Survivor, int32 DiceRollValue);
	void OnLocallyObservedPawnChanged();
	void OnRep_HasBeenRevealedAsMimic();
	void OnRep_ItemInChest();
	void OnRep_ResetTimer();
	void OnRep_TrappedSurvivor(class ACamperPlayer* PreviousTrappedSurvivor);
	void OnRep_TreasureChestState(EK36TreasureChestState PreviousChestState);

	EK36TreasureChestState GetTreasureChestState() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K36TreasureChest">();
	}
	static class AK36TreasureChest* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK36TreasureChest>();
	}
};
static_assert(alignof(AK36TreasureChest) == 0x000008, "Wrong alignment on AK36TreasureChest");
static_assert(sizeof(AK36TreasureChest) == 0x0005C8, "Wrong size on AK36TreasureChest");
static_assert(offsetof(AK36TreasureChest, _rootComponent) == 0x0003C0, "Member 'AK36TreasureChest::_rootComponent' has a wrong offset!");
static_assert(offsetof(AK36TreasureChest, _collisionComponent) == 0x0003C8, "Member 'AK36TreasureChest::_collisionComponent' has a wrong offset!");
static_assert(offsetof(AK36TreasureChest, _skeletalMeshComponent) == 0x0003D0, "Member 'AK36TreasureChest::_skeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(AK36TreasureChest, _mimicSkeletalMeshComponent) == 0x0003D8, "Member 'AK36TreasureChest::_mimicSkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(AK36TreasureChest, _mimicDisguiseMeshComponent) == 0x0003E0, "Member 'AK36TreasureChest::_mimicDisguiseMeshComponent' has a wrong offset!");
static_assert(offsetof(AK36TreasureChest, _montagePlayer) == 0x0003E8, "Member 'AK36TreasureChest::_montagePlayer' has a wrong offset!");
static_assert(offsetof(AK36TreasureChest, _montageFollower) == 0x0003F0, "Member 'AK36TreasureChest::_montageFollower' has a wrong offset!");
static_assert(offsetof(AK36TreasureChest, _itemInChest) == 0x0003F8, "Member 'AK36TreasureChest::_itemInChest' has a wrong offset!");
static_assert(offsetof(AK36TreasureChest, _trappedSurvivor) == 0x000400, "Member 'AK36TreasureChest::_trappedSurvivor' has a wrong offset!");
static_assert(offsetof(AK36TreasureChest, _treasureChestState) == 0x000408, "Member 'AK36TreasureChest::_treasureChestState' has a wrong offset!");
static_assert(offsetof(AK36TreasureChest, _resetTimer) == 0x000410, "Member 'AK36TreasureChest::_resetTimer' has a wrong offset!");
static_assert(offsetof(AK36TreasureChest, _magicItemSocketName) == 0x000418, "Member 'AK36TreasureChest::_magicItemSocketName' has a wrong offset!");
static_assert(offsetof(AK36TreasureChest, _defaultItemInChestNiagaraSystem) == 0x000428, "Member 'AK36TreasureChest::_defaultItemInChestNiagaraSystem' has a wrong offset!");
static_assert(offsetof(AK36TreasureChest, _killerPOVNiagaraSystem) == 0x000430, "Member 'AK36TreasureChest::_killerPOVNiagaraSystem' has a wrong offset!");
static_assert(offsetof(AK36TreasureChest, _outlineComponent) == 0x000438, "Member 'AK36TreasureChest::_outlineComponent' has a wrong offset!");
static_assert(offsetof(AK36TreasureChest, _treasureOutlineUpdateStrategy) == 0x000440, "Member 'AK36TreasureChest::_treasureOutlineUpdateStrategy' has a wrong offset!");
static_assert(offsetof(AK36TreasureChest, _interactionZone) == 0x000448, "Member 'AK36TreasureChest::_interactionZone' has a wrong offset!");
static_assert(offsetof(AK36TreasureChest, _interactor) == 0x000450, "Member 'AK36TreasureChest::_interactor' has a wrong offset!");
static_assert(offsetof(AK36TreasureChest, _openTreasureChestChargeableComponent) == 0x000458, "Member 'AK36TreasureChest::_openTreasureChestChargeableComponent' has a wrong offset!");
static_assert(offsetof(AK36TreasureChest, _openTreasureChestInteraction) == 0x000460, "Member 'AK36TreasureChest::_openTreasureChestInteraction' has a wrong offset!");
static_assert(offsetof(AK36TreasureChest, _escapeFromMimicInteraction) == 0x000468, "Member 'AK36TreasureChest::_escapeFromMimicInteraction' has a wrong offset!");
static_assert(offsetof(AK36TreasureChest, _escapeFromMimicChargeableComponent) == 0x000470, "Member 'AK36TreasureChest::_escapeFromMimicChargeableComponent' has a wrong offset!");
static_assert(offsetof(AK36TreasureChest, _collectItemFromTreasureChestInteraction) == 0x000478, "Member 'AK36TreasureChest::_collectItemFromTreasureChestInteraction' has a wrong offset!");
static_assert(offsetof(AK36TreasureChest, _openTreasureChestSecondsToCharge) == 0x000480, "Member 'AK36TreasureChest::_openTreasureChestSecondsToCharge' has a wrong offset!");
static_assert(offsetof(AK36TreasureChest, _escapeFromMimicSecondsToCharge) == 0x0004A8, "Member 'AK36TreasureChest::_escapeFromMimicSecondsToCharge' has a wrong offset!");
static_assert(offsetof(AK36TreasureChest, _resetDuration) == 0x0004D0, "Member 'AK36TreasureChest::_resetDuration' has a wrong offset!");
static_assert(offsetof(AK36TreasureChest, _mimicSwapTimerDuration) == 0x0004F8, "Member 'AK36TreasureChest::_mimicSwapTimerDuration' has a wrong offset!");
static_assert(offsetof(AK36TreasureChest, _mimicDisguisesItselfTime) == 0x000520, "Member 'AK36TreasureChest::_mimicDisguisesItselfTime' has a wrong offset!");
static_assert(offsetof(AK36TreasureChest, _rollValue) == 0x000548, "Member 'AK36TreasureChest::_rollValue' has a wrong offset!");
static_assert(offsetof(AK36TreasureChest, _currentSmokeVFX) == 0x000550, "Member 'AK36TreasureChest::_currentSmokeVFX' has a wrong offset!");
static_assert(offsetof(AK36TreasureChest, _hasBeenRevealedAsMimic) == 0x000560, "Member 'AK36TreasureChest::_hasBeenRevealedAsMimic' has a wrong offset!");

// Class TheK36.K36TreasureChestAnimInstance
// 0x0010 (0x0390 - 0x0380)
class UK36TreasureChestAnimInstance final : public UDBDBaseAnimInstance
{
public:
	bool                                          _isIdleMimic;                                      // 0x0380(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isOpened;                                         // 0x0381(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isClosed;                                         // 0x0382(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isCharging;                                       // 0x0383(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isRolling;                                        // 0x0384(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isChest;                                          // 0x0385(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isStruggling;                                     // 0x0386(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isRevealedMimic;                                  // 0x0387(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_388[0x8];                                      // 0x0388(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K36TreasureChestAnimInstance">();
	}
	static class UK36TreasureChestAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK36TreasureChestAnimInstance>();
	}
};
static_assert(alignof(UK36TreasureChestAnimInstance) == 0x000010, "Wrong alignment on UK36TreasureChestAnimInstance");
static_assert(sizeof(UK36TreasureChestAnimInstance) == 0x000390, "Wrong size on UK36TreasureChestAnimInstance");
static_assert(offsetof(UK36TreasureChestAnimInstance, _isIdleMimic) == 0x000380, "Member 'UK36TreasureChestAnimInstance::_isIdleMimic' has a wrong offset!");
static_assert(offsetof(UK36TreasureChestAnimInstance, _isOpened) == 0x000381, "Member 'UK36TreasureChestAnimInstance::_isOpened' has a wrong offset!");
static_assert(offsetof(UK36TreasureChestAnimInstance, _isClosed) == 0x000382, "Member 'UK36TreasureChestAnimInstance::_isClosed' has a wrong offset!");
static_assert(offsetof(UK36TreasureChestAnimInstance, _isCharging) == 0x000383, "Member 'UK36TreasureChestAnimInstance::_isCharging' has a wrong offset!");
static_assert(offsetof(UK36TreasureChestAnimInstance, _isRolling) == 0x000384, "Member 'UK36TreasureChestAnimInstance::_isRolling' has a wrong offset!");
static_assert(offsetof(UK36TreasureChestAnimInstance, _isChest) == 0x000385, "Member 'UK36TreasureChestAnimInstance::_isChest' has a wrong offset!");
static_assert(offsetof(UK36TreasureChestAnimInstance, _isStruggling) == 0x000386, "Member 'UK36TreasureChestAnimInstance::_isStruggling' has a wrong offset!");
static_assert(offsetof(UK36TreasureChestAnimInstance, _isRevealedMimic) == 0x000387, "Member 'UK36TreasureChestAnimInstance::_isRevealedMimic' has a wrong offset!");

// Class TheK36.K36TreasureChestOutlineUpdateStrategy
// 0x0058 (0x01A0 - 0x0148)
class UK36TreasureChestOutlineUpdateStrategy final : public USourceBasedOutlineUpdateStrategy
{
public:
	struct FDBDTunableRowHandle                   _chestDistanceNoMagicItem;                         // 0x0148(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _chestDistanceWithMagicItem;                       // 0x0170(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_198[0x8];                                      // 0x0198(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K36TreasureChestOutlineUpdateStrategy">();
	}
	static class UK36TreasureChestOutlineUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK36TreasureChestOutlineUpdateStrategy>();
	}
};
static_assert(alignof(UK36TreasureChestOutlineUpdateStrategy) == 0x000008, "Wrong alignment on UK36TreasureChestOutlineUpdateStrategy");
static_assert(sizeof(UK36TreasureChestOutlineUpdateStrategy) == 0x0001A0, "Wrong size on UK36TreasureChestOutlineUpdateStrategy");
static_assert(offsetof(UK36TreasureChestOutlineUpdateStrategy, _chestDistanceNoMagicItem) == 0x000148, "Member 'UK36TreasureChestOutlineUpdateStrategy::_chestDistanceNoMagicItem' has a wrong offset!");
static_assert(offsetof(UK36TreasureChestOutlineUpdateStrategy, _chestDistanceWithMagicItem) == 0x000170, "Member 'UK36TreasureChestOutlineUpdateStrategy::_chestDistanceWithMagicItem' has a wrong offset!");

// Class TheK36.K36Utilities
// 0x0000 (0x0030 - 0x0030)
class UK36Utilities final : public UBlueprintFunctionLibrary
{
public:
	static TArray<class AK36MagicItemArtifact*> GetArtifactsOnSurvivor(const class ACamperPlayer* Survivor);
	static class UK36DnDManagerComponent* GetDnDManagerComponent(const class UObject* WorldContextObject);
	static class AK36Power* GetK36Power(const class ASlasherPlayer* Killer);
	static class UK36SpellManagerComponent* GetK36SpellManagerComponent(const class ASlasherPlayer* Killer);
	static class UK36SelectSpellInteraction* GetSelectSpellInteraction(const class ASlasherPlayer* Killer);
	static class AK36SpellTrajectoryPreviewer* GetSpellTrajectoryPreviewer(const class ASlasherPlayer* Killer);
	static class AK36Spikes* GetSpikes(const class ASlasherPlayer* Killer);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K36Utilities">();
	}
	static class UK36Utilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK36Utilities>();
	}
};
static_assert(alignof(UK36Utilities) == 0x000008, "Wrong alignment on UK36Utilities");
static_assert(sizeof(UK36Utilities) == 0x000030, "Wrong size on UK36Utilities");

// Class TheK36.K36VecnaHandAnimInstance
// 0x0020 (0x0370 - 0x0350)
class UK36VecnaHandAnimInstance final : public UAnimInstance
{
public:
	uint8                                         Pad_350[0x8];                                      // 0x0350(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _hasMergedWithSurvivor;                            // 0x0358(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_359[0x3];                                      // 0x0359(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class USkeletalMeshComponent>  _copyMesh;                                         // 0x035C(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_364[0xC];                                      // 0x0364(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K36VecnaHandAnimInstance">();
	}
	static class UK36VecnaHandAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK36VecnaHandAnimInstance>();
	}
};
static_assert(alignof(UK36VecnaHandAnimInstance) == 0x000010, "Wrong alignment on UK36VecnaHandAnimInstance");
static_assert(sizeof(UK36VecnaHandAnimInstance) == 0x000370, "Wrong size on UK36VecnaHandAnimInstance");
static_assert(offsetof(UK36VecnaHandAnimInstance, _hasMergedWithSurvivor) == 0x000358, "Member 'UK36VecnaHandAnimInstance::_hasMergedWithSurvivor' has a wrong offset!");
static_assert(offsetof(UK36VecnaHandAnimInstance, _copyMesh) == 0x00035C, "Member 'UK36VecnaHandAnimInstance::_copyMesh' has a wrong offset!");

// Class TheK36.K36WindowFlyCollisionHandlerComponent
// 0x0030 (0x0620 - 0x05F0)
class UK36WindowFlyCollisionHandlerComponent final : public UIgnoreCollisionsWindowHandlerComponent
{
public:
	struct FDBDTunableRowHandle                   _timeToBlockWindowAfterPassingThrough;             // 0x05F0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_618[0x8];                                      // 0x0618(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnComponentEndOverlapWithKiller(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K36WindowFlyCollisionHandlerComponent">();
	}
	static class UK36WindowFlyCollisionHandlerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK36WindowFlyCollisionHandlerComponent>();
	}
};
static_assert(alignof(UK36WindowFlyCollisionHandlerComponent) == 0x000010, "Wrong alignment on UK36WindowFlyCollisionHandlerComponent");
static_assert(sizeof(UK36WindowFlyCollisionHandlerComponent) == 0x000620, "Wrong size on UK36WindowFlyCollisionHandlerComponent");
static_assert(offsetof(UK36WindowFlyCollisionHandlerComponent, _timeToBlockWindowAfterPassingThrough) == 0x0005F0, "Member 'UK36WindowFlyCollisionHandlerComponent::_timeToBlockWindowAfterPassingThrough' has a wrong offset!");

// Class TheK36.OwningPlayerInDroppedNotSpecialSurvivorCollectableRange
// 0x0068 (0x0160 - 0x00F8)
class UOwningPlayerInDroppedNotSpecialSurvivorCollectableRange final : public UAnyActorPairQueryRangeIsTrue
{
public:
	float                                         _aurasRevealedRange;                               // 0x00F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_FC[0x4];                                       // 0x00FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         _activeItems;                                      // 0x0100(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_110[0x50];                                     // 0x0110(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnIntroComplete();
	void OnItemDestroyed(class AActor* DestroyedActor);
	void OnItemStateChanged(const ECollectableState State);
	void OnSurvivorItemDropped(const struct FGameplayTag& GameplayTag, const struct FGameEventData& GameEventData);
	void OnSurvivorItemPicked(const struct FGameplayTag& GameplayTag, const struct FGameEventData& GameEventData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OwningPlayerInDroppedNotSpecialSurvivorCollectableRange">();
	}
	static class UOwningPlayerInDroppedNotSpecialSurvivorCollectableRange* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOwningPlayerInDroppedNotSpecialSurvivorCollectableRange>();
	}
};
static_assert(alignof(UOwningPlayerInDroppedNotSpecialSurvivorCollectableRange) == 0x000008, "Wrong alignment on UOwningPlayerInDroppedNotSpecialSurvivorCollectableRange");
static_assert(sizeof(UOwningPlayerInDroppedNotSpecialSurvivorCollectableRange) == 0x000160, "Wrong size on UOwningPlayerInDroppedNotSpecialSurvivorCollectableRange");
static_assert(offsetof(UOwningPlayerInDroppedNotSpecialSurvivorCollectableRange, _aurasRevealedRange) == 0x0000F8, "Member 'UOwningPlayerInDroppedNotSpecialSurvivorCollectableRange::_aurasRevealedRange' has a wrong offset!");
static_assert(offsetof(UOwningPlayerInDroppedNotSpecialSurvivorCollectableRange, _activeItems) == 0x000100, "Member 'UOwningPlayerInDroppedNotSpecialSurvivorCollectableRange::_activeItems' has a wrong offset!");

}

