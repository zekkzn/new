#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: TheK25

#include "Basic.hpp"

#include "GameplayTags_structs.hpp"
#include "DeadByDaylight_structs.hpp"
#include "Projectile_structs.hpp"
#include "DBDSharedTypes_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "Engine_structs.hpp"
#include "TheK25_structs.hpp"


namespace SDK::Params
{

// Function TheK25.K25Projectile.Cosmetic_OnProjectileDeactivated
// 0x0020 (0x0020 - 0x0000)
struct K25Projectile_Cosmetic_OnProjectileDeactivated final
{
public:
	struct FK25ProjectileDeactivationData         DeactivationData;                                  // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25Projectile_Cosmetic_OnProjectileDeactivated) == 0x000008, "Wrong alignment on K25Projectile_Cosmetic_OnProjectileDeactivated");
static_assert(sizeof(K25Projectile_Cosmetic_OnProjectileDeactivated) == 0x000020, "Wrong size on K25Projectile_Cosmetic_OnProjectileDeactivated");
static_assert(offsetof(K25Projectile_Cosmetic_OnProjectileDeactivated, DeactivationData) == 0x000000, "Member 'K25Projectile_Cosmetic_OnProjectileDeactivated::DeactivationData' has a wrong offset!");

// Function TheK25.K25Projectile.OnProjectileStopped
// 0x00F0 (0x00F0 - 0x0000)
struct K25Projectile_OnProjectileStopped final
{
public:
	struct FHitResult                             Result;                                            // 0x0000(0x00F0)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25Projectile_OnProjectileStopped) == 0x000008, "Wrong alignment on K25Projectile_OnProjectileStopped");
static_assert(sizeof(K25Projectile_OnProjectileStopped) == 0x0000F0, "Wrong size on K25Projectile_OnProjectileStopped");
static_assert(offsetof(K25Projectile_OnProjectileStopped, Result) == 0x000000, "Member 'K25Projectile_OnProjectileStopped::Result' has a wrong offset!");

// Function TheK25.K25Projectile.Server_RequestDisableProjectile
// 0x0001 (0x0001 - 0x0000)
struct K25Projectile_Server_RequestDisableProjectile final
{
public:
	EK25ProjectileDeactivateReason                DeactivateReason;                                  // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25Projectile_Server_RequestDisableProjectile) == 0x000001, "Wrong alignment on K25Projectile_Server_RequestDisableProjectile");
static_assert(sizeof(K25Projectile_Server_RequestDisableProjectile) == 0x000001, "Wrong size on K25Projectile_Server_RequestDisableProjectile");
static_assert(offsetof(K25Projectile_Server_RequestDisableProjectile, DeactivateReason) == 0x000000, "Member 'K25Projectile_Server_RequestDisableProjectile::DeactivateReason' has a wrong offset!");

// Function TheK25.K25Projectile.GetChainAttachmentLocation
// 0x0018 (0x0018 - 0x0000)
struct K25Projectile_GetChainAttachmentLocation final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25Projectile_GetChainAttachmentLocation) == 0x000008, "Wrong alignment on K25Projectile_GetChainAttachmentLocation");
static_assert(sizeof(K25Projectile_GetChainAttachmentLocation) == 0x000018, "Wrong size on K25Projectile_GetChainAttachmentLocation");
static_assert(offsetof(K25Projectile_GetChainAttachmentLocation, ReturnValue) == 0x000000, "Member 'K25Projectile_GetChainAttachmentLocation::ReturnValue' has a wrong offset!");

// Function TheK25.K25Projectile.GetMovementComponent
// 0x0008 (0x0008 - 0x0000)
struct K25Projectile_GetMovementComponent final
{
public:
	class UDBDProjectileMovementComponent*        ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25Projectile_GetMovementComponent) == 0x000008, "Wrong alignment on K25Projectile_GetMovementComponent");
static_assert(sizeof(K25Projectile_GetMovementComponent) == 0x000008, "Wrong size on K25Projectile_GetMovementComponent");
static_assert(offsetof(K25Projectile_GetMovementComponent, ReturnValue) == 0x000000, "Member 'K25Projectile_GetMovementComponent::ReturnValue' has a wrong offset!");

// Function TheK25.K25UncontrolledProjectile.Authority_OnDamageStateChanged
// 0x0002 (0x0002 - 0x0000)
struct K25UncontrolledProjectile_Authority_OnDamageStateChanged final
{
public:
	ECamperDamageState                            OldDamageState;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECamperDamageState                            CurrentDamageState;                                // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25UncontrolledProjectile_Authority_OnDamageStateChanged) == 0x000001, "Wrong alignment on K25UncontrolledProjectile_Authority_OnDamageStateChanged");
static_assert(sizeof(K25UncontrolledProjectile_Authority_OnDamageStateChanged) == 0x000002, "Wrong size on K25UncontrolledProjectile_Authority_OnDamageStateChanged");
static_assert(offsetof(K25UncontrolledProjectile_Authority_OnDamageStateChanged, OldDamageState) == 0x000000, "Member 'K25UncontrolledProjectile_Authority_OnDamageStateChanged::OldDamageState' has a wrong offset!");
static_assert(offsetof(K25UncontrolledProjectile_Authority_OnDamageStateChanged, CurrentDamageState) == 0x000001, "Member 'K25UncontrolledProjectile_Authority_OnDamageStateChanged::CurrentDamageState' has a wrong offset!");

// Function TheK25.K25AttackSubAnimInstance.OnAttackStart
// 0x0001 (0x0001 - 0x0000)
struct K25AttackSubAnimInstance_OnAttackStart final
{
public:
	EAttackType                                   AttackType;                                        // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25AttackSubAnimInstance_OnAttackStart) == 0x000001, "Wrong alignment on K25AttackSubAnimInstance_OnAttackStart");
static_assert(sizeof(K25AttackSubAnimInstance_OnAttackStart) == 0x000001, "Wrong size on K25AttackSubAnimInstance_OnAttackStart");
static_assert(offsetof(K25AttackSubAnimInstance_OnAttackStart, AttackType) == 0x000000, "Member 'K25AttackSubAnimInstance_OnAttackStart::AttackType' has a wrong offset!");

// Function TheK25.K25ProjectileReplicationComponent.Multicast_DeactivateProjectile
// 0x0028 (0x0028 - 0x0000)
struct K25ProjectileReplicationComponent_Multicast_DeactivateProjectile final
{
public:
	class AK25Projectile*                         Projectile;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FK25ProjectileDeactivationData         DeactivationData;                                  // 0x0008(0x0020)(ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25ProjectileReplicationComponent_Multicast_DeactivateProjectile) == 0x000008, "Wrong alignment on K25ProjectileReplicationComponent_Multicast_DeactivateProjectile");
static_assert(sizeof(K25ProjectileReplicationComponent_Multicast_DeactivateProjectile) == 0x000028, "Wrong size on K25ProjectileReplicationComponent_Multicast_DeactivateProjectile");
static_assert(offsetof(K25ProjectileReplicationComponent_Multicast_DeactivateProjectile, Projectile) == 0x000000, "Member 'K25ProjectileReplicationComponent_Multicast_DeactivateProjectile::Projectile' has a wrong offset!");
static_assert(offsetof(K25ProjectileReplicationComponent_Multicast_DeactivateProjectile, DeactivationData) == 0x000008, "Member 'K25ProjectileReplicationComponent_Multicast_DeactivateProjectile::DeactivationData' has a wrong offset!");

// Function TheK25.K25ProjectileReplicationComponent.Multicast_SetAttachedChain
// 0x0048 (0x0048 - 0x0000)
struct K25ProjectileReplicationComponent_Multicast_SetAttachedChain final
{
public:
	class AK25Projectile*                         Projectile;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AK25Chain*                              ChainToAttach;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLaunchInfo                            LaunchInfo;                                        // 0x0010(0x0038)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25ProjectileReplicationComponent_Multicast_SetAttachedChain) == 0x000008, "Wrong alignment on K25ProjectileReplicationComponent_Multicast_SetAttachedChain");
static_assert(sizeof(K25ProjectileReplicationComponent_Multicast_SetAttachedChain) == 0x000048, "Wrong size on K25ProjectileReplicationComponent_Multicast_SetAttachedChain");
static_assert(offsetof(K25ProjectileReplicationComponent_Multicast_SetAttachedChain, Projectile) == 0x000000, "Member 'K25ProjectileReplicationComponent_Multicast_SetAttachedChain::Projectile' has a wrong offset!");
static_assert(offsetof(K25ProjectileReplicationComponent_Multicast_SetAttachedChain, ChainToAttach) == 0x000008, "Member 'K25ProjectileReplicationComponent_Multicast_SetAttachedChain::ChainToAttach' has a wrong offset!");
static_assert(offsetof(K25ProjectileReplicationComponent_Multicast_SetAttachedChain, LaunchInfo) == 0x000010, "Member 'K25ProjectileReplicationComponent_Multicast_SetAttachedChain::LaunchInfo' has a wrong offset!");

// Function TheK25.K25UncontrolledProjectileReplicationComponent.Multicast_LaunchProjectile
// 0x0040 (0x0040 - 0x0000)
struct K25UncontrolledProjectileReplicationComponent_Multicast_LaunchProjectile final
{
public:
	class AK25UncontrolledProjectile*             Projectile;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLaunchInfo                            LaunchInfo;                                        // 0x0008(0x0038)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25UncontrolledProjectileReplicationComponent_Multicast_LaunchProjectile) == 0x000008, "Wrong alignment on K25UncontrolledProjectileReplicationComponent_Multicast_LaunchProjectile");
static_assert(sizeof(K25UncontrolledProjectileReplicationComponent_Multicast_LaunchProjectile) == 0x000040, "Wrong size on K25UncontrolledProjectileReplicationComponent_Multicast_LaunchProjectile");
static_assert(offsetof(K25UncontrolledProjectileReplicationComponent_Multicast_LaunchProjectile, Projectile) == 0x000000, "Member 'K25UncontrolledProjectileReplicationComponent_Multicast_LaunchProjectile::Projectile' has a wrong offset!");
static_assert(offsetof(K25UncontrolledProjectileReplicationComponent_Multicast_LaunchProjectile, LaunchInfo) == 0x000008, "Member 'K25UncontrolledProjectileReplicationComponent_Multicast_LaunchProjectile::LaunchInfo' has a wrong offset!");

// Function TheK25.K25Utilities.GetK25ControlledProjectile
// 0x0010 (0x0010 - 0x0000)
struct K25Utilities_GetK25ControlledProjectile final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AK25ControlledProjectile*               ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25Utilities_GetK25ControlledProjectile) == 0x000008, "Wrong alignment on K25Utilities_GetK25ControlledProjectile");
static_assert(sizeof(K25Utilities_GetK25ControlledProjectile) == 0x000010, "Wrong size on K25Utilities_GetK25ControlledProjectile");
static_assert(offsetof(K25Utilities_GetK25ControlledProjectile, WorldContextObject) == 0x000000, "Member 'K25Utilities_GetK25ControlledProjectile::WorldContextObject' has a wrong offset!");
static_assert(offsetof(K25Utilities_GetK25ControlledProjectile, ReturnValue) == 0x000008, "Member 'K25Utilities_GetK25ControlledProjectile::ReturnValue' has a wrong offset!");

// Function TheK25.K25Utilities.GetK25Gateway
// 0x0010 (0x0010 - 0x0000)
struct K25Utilities_GetK25Gateway final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AK25Gateway*                            ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25Utilities_GetK25Gateway) == 0x000008, "Wrong alignment on K25Utilities_GetK25Gateway");
static_assert(sizeof(K25Utilities_GetK25Gateway) == 0x000010, "Wrong size on K25Utilities_GetK25Gateway");
static_assert(offsetof(K25Utilities_GetK25Gateway, WorldContextObject) == 0x000000, "Member 'K25Utilities_GetK25Gateway::WorldContextObject' has a wrong offset!");
static_assert(offsetof(K25Utilities_GetK25Gateway, ReturnValue) == 0x000008, "Member 'K25Utilities_GetK25Gateway::ReturnValue' has a wrong offset!");

// Function TheK25.K25Utilities.GetK25Husk
// 0x0010 (0x0010 - 0x0000)
struct K25Utilities_GetK25Husk final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AK25Husk*                               ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25Utilities_GetK25Husk) == 0x000008, "Wrong alignment on K25Utilities_GetK25Husk");
static_assert(sizeof(K25Utilities_GetK25Husk) == 0x000010, "Wrong size on K25Utilities_GetK25Husk");
static_assert(offsetof(K25Utilities_GetK25Husk, WorldContextObject) == 0x000000, "Member 'K25Utilities_GetK25Husk::WorldContextObject' has a wrong offset!");
static_assert(offsetof(K25Utilities_GetK25Husk, ReturnValue) == 0x000008, "Member 'K25Utilities_GetK25Husk::ReturnValue' has a wrong offset!");

// Function TheK25.K25Utilities.GetK25Power
// 0x0010 (0x0010 - 0x0000)
struct K25Utilities_GetK25Power final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AK25Power*                              ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25Utilities_GetK25Power) == 0x000008, "Wrong alignment on K25Utilities_GetK25Power");
static_assert(sizeof(K25Utilities_GetK25Power) == 0x000010, "Wrong size on K25Utilities_GetK25Power");
static_assert(offsetof(K25Utilities_GetK25Power, WorldContextObject) == 0x000000, "Member 'K25Utilities_GetK25Power::WorldContextObject' has a wrong offset!");
static_assert(offsetof(K25Utilities_GetK25Power, ReturnValue) == 0x000008, "Member 'K25Utilities_GetK25Power::ReturnValue' has a wrong offset!");

// Function TheK25.K25Utilities.GetLamentConfiguration
// 0x0010 (0x0010 - 0x0000)
struct K25Utilities_GetLamentConfiguration final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ALamentConfiguration*                   ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25Utilities_GetLamentConfiguration) == 0x000008, "Wrong alignment on K25Utilities_GetLamentConfiguration");
static_assert(sizeof(K25Utilities_GetLamentConfiguration) == 0x000010, "Wrong size on K25Utilities_GetLamentConfiguration");
static_assert(offsetof(K25Utilities_GetLamentConfiguration, WorldContextObject) == 0x000000, "Member 'K25Utilities_GetLamentConfiguration::WorldContextObject' has a wrong offset!");
static_assert(offsetof(K25Utilities_GetLamentConfiguration, ReturnValue) == 0x000008, "Member 'K25Utilities_GetLamentConfiguration::ReturnValue' has a wrong offset!");

// Function TheK25.LamentConfiguration.Authority_OnEndGameOver
// 0x0040 (0x0040 - 0x0000)
struct LamentConfiguration_Authority_OnEndGameOver final
{
public:
	struct FGameplayTag                           GameEventType;                                     // 0x0000(0x000C)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameEventData                         GameEventData;                                     // 0x0010(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LamentConfiguration_Authority_OnEndGameOver) == 0x000008, "Wrong alignment on LamentConfiguration_Authority_OnEndGameOver");
static_assert(sizeof(LamentConfiguration_Authority_OnEndGameOver) == 0x000040, "Wrong size on LamentConfiguration_Authority_OnEndGameOver");
static_assert(offsetof(LamentConfiguration_Authority_OnEndGameOver, GameEventType) == 0x000000, "Member 'LamentConfiguration_Authority_OnEndGameOver::GameEventType' has a wrong offset!");
static_assert(offsetof(LamentConfiguration_Authority_OnEndGameOver, GameEventData) == 0x000010, "Member 'LamentConfiguration_Authority_OnEndGameOver::GameEventData' has a wrong offset!");

// Function TheK25.LamentConfiguration.Authority_OnGameEnded
// 0x0040 (0x0040 - 0x0000)
struct LamentConfiguration_Authority_OnGameEnded final
{
public:
	struct FGameplayTag                           GameEventType;                                     // 0x0000(0x000C)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameEventData                         GameEventData;                                     // 0x0010(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LamentConfiguration_Authority_OnGameEnded) == 0x000008, "Wrong alignment on LamentConfiguration_Authority_OnGameEnded");
static_assert(sizeof(LamentConfiguration_Authority_OnGameEnded) == 0x000040, "Wrong size on LamentConfiguration_Authority_OnGameEnded");
static_assert(offsetof(LamentConfiguration_Authority_OnGameEnded, GameEventType) == 0x000000, "Member 'LamentConfiguration_Authority_OnGameEnded::GameEventType' has a wrong offset!");
static_assert(offsetof(LamentConfiguration_Authority_OnGameEnded, GameEventData) == 0x000010, "Member 'LamentConfiguration_Authority_OnGameEnded::GameEventData' has a wrong offset!");

// Function TheK25.LamentConfiguration.Authority_OnOverlapBegin
// 0x0110 (0x0110 - 0x0000)
struct LamentConfiguration_Authority_OnOverlapBegin final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Other;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x00F0)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(LamentConfiguration_Authority_OnOverlapBegin) == 0x000008, "Wrong alignment on LamentConfiguration_Authority_OnOverlapBegin");
static_assert(sizeof(LamentConfiguration_Authority_OnOverlapBegin) == 0x000110, "Wrong size on LamentConfiguration_Authority_OnOverlapBegin");
static_assert(offsetof(LamentConfiguration_Authority_OnOverlapBegin, OverlappedComponent) == 0x000000, "Member 'LamentConfiguration_Authority_OnOverlapBegin::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(LamentConfiguration_Authority_OnOverlapBegin, Other) == 0x000008, "Member 'LamentConfiguration_Authority_OnOverlapBegin::Other' has a wrong offset!");
static_assert(offsetof(LamentConfiguration_Authority_OnOverlapBegin, OtherComp) == 0x000010, "Member 'LamentConfiguration_Authority_OnOverlapBegin::OtherComp' has a wrong offset!");
static_assert(offsetof(LamentConfiguration_Authority_OnOverlapBegin, OtherBodyIndex) == 0x000018, "Member 'LamentConfiguration_Authority_OnOverlapBegin::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(LamentConfiguration_Authority_OnOverlapBegin, bFromSweep) == 0x00001C, "Member 'LamentConfiguration_Authority_OnOverlapBegin::bFromSweep' has a wrong offset!");
static_assert(offsetof(LamentConfiguration_Authority_OnOverlapBegin, SweepResult) == 0x000020, "Member 'LamentConfiguration_Authority_OnOverlapBegin::SweepResult' has a wrong offset!");

// Function TheK25.LamentConfiguration.Authority_OnOverlapEnd
// 0x0020 (0x0020 - 0x0000)
struct LamentConfiguration_Authority_OnOverlapEnd final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LamentConfiguration_Authority_OnOverlapEnd) == 0x000008, "Wrong alignment on LamentConfiguration_Authority_OnOverlapEnd");
static_assert(sizeof(LamentConfiguration_Authority_OnOverlapEnd) == 0x000020, "Wrong size on LamentConfiguration_Authority_OnOverlapEnd");
static_assert(offsetof(LamentConfiguration_Authority_OnOverlapEnd, OverlappedComponent) == 0x000000, "Member 'LamentConfiguration_Authority_OnOverlapEnd::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(LamentConfiguration_Authority_OnOverlapEnd, OtherActor) == 0x000008, "Member 'LamentConfiguration_Authority_OnOverlapEnd::OtherActor' has a wrong offset!");
static_assert(offsetof(LamentConfiguration_Authority_OnOverlapEnd, OtherComp) == 0x000010, "Member 'LamentConfiguration_Authority_OnOverlapEnd::OtherComp' has a wrong offset!");
static_assert(offsetof(LamentConfiguration_Authority_OnOverlapEnd, OtherBodyIndex) == 0x000018, "Member 'LamentConfiguration_Authority_OnOverlapEnd::OtherBodyIndex' has a wrong offset!");

// Function TheK25.LamentConfiguration.Authority_OnSurvivorHitByControlledProjectile
// 0x0040 (0x0040 - 0x0000)
struct LamentConfiguration_Authority_OnSurvivorHitByControlledProjectile final
{
public:
	struct FGameplayTag                           GameEventType;                                     // 0x0000(0x000C)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameEventData                         GameEventData;                                     // 0x0010(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LamentConfiguration_Authority_OnSurvivorHitByControlledProjectile) == 0x000008, "Wrong alignment on LamentConfiguration_Authority_OnSurvivorHitByControlledProjectile");
static_assert(sizeof(LamentConfiguration_Authority_OnSurvivorHitByControlledProjectile) == 0x000040, "Wrong size on LamentConfiguration_Authority_OnSurvivorHitByControlledProjectile");
static_assert(offsetof(LamentConfiguration_Authority_OnSurvivorHitByControlledProjectile, GameEventType) == 0x000000, "Member 'LamentConfiguration_Authority_OnSurvivorHitByControlledProjectile::GameEventType' has a wrong offset!");
static_assert(offsetof(LamentConfiguration_Authority_OnSurvivorHitByControlledProjectile, GameEventData) == 0x000010, "Member 'LamentConfiguration_Authority_OnSurvivorHitByControlledProjectile::GameEventData' has a wrong offset!");

// Function TheK25.LamentConfiguration.Authority_RespawnLamentConfiguration
// 0x0001 (0x0001 - 0x0000)
struct LamentConfiguration_Authority_RespawnLamentConfiguration final
{
public:
	bool                                          TriggerChainHuntUponSpawning;                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LamentConfiguration_Authority_RespawnLamentConfiguration) == 0x000001, "Wrong alignment on LamentConfiguration_Authority_RespawnLamentConfiguration");
static_assert(sizeof(LamentConfiguration_Authority_RespawnLamentConfiguration) == 0x000001, "Wrong size on LamentConfiguration_Authority_RespawnLamentConfiguration");
static_assert(offsetof(LamentConfiguration_Authority_RespawnLamentConfiguration, TriggerChainHuntUponSpawning) == 0x000000, "Member 'LamentConfiguration_Authority_RespawnLamentConfiguration::TriggerChainHuntUponSpawning' has a wrong offset!");

// Function TheK25.LamentConfiguration.Cosmetic_EndSolvingCube
// 0x0001 (0x0001 - 0x0000)
struct LamentConfiguration_Cosmetic_EndSolvingCube final
{
public:
	bool                                          HasBeenSolved;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LamentConfiguration_Cosmetic_EndSolvingCube) == 0x000001, "Wrong alignment on LamentConfiguration_Cosmetic_EndSolvingCube");
static_assert(sizeof(LamentConfiguration_Cosmetic_EndSolvingCube) == 0x000001, "Wrong size on LamentConfiguration_Cosmetic_EndSolvingCube");
static_assert(offsetof(LamentConfiguration_Cosmetic_EndSolvingCube, HasBeenSolved) == 0x000000, "Member 'LamentConfiguration_Cosmetic_EndSolvingCube::HasBeenSolved' has a wrong offset!");

// Function TheK25.LamentConfiguration.Cosmetic_OnChainHuntChargeStart
// 0x0004 (0x0004 - 0x0000)
struct LamentConfiguration_Cosmetic_OnChainHuntChargeStart final
{
public:
	float                                         ChargeTime;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LamentConfiguration_Cosmetic_OnChainHuntChargeStart) == 0x000004, "Wrong alignment on LamentConfiguration_Cosmetic_OnChainHuntChargeStart");
static_assert(sizeof(LamentConfiguration_Cosmetic_OnChainHuntChargeStart) == 0x000004, "Wrong size on LamentConfiguration_Cosmetic_OnChainHuntChargeStart");
static_assert(offsetof(LamentConfiguration_Cosmetic_OnChainHuntChargeStart, ChargeTime) == 0x000000, "Member 'LamentConfiguration_Cosmetic_OnChainHuntChargeStart::ChargeTime' has a wrong offset!");

// Function TheK25.LamentConfiguration.Cosmetic_OnHoldingSurvivorHostageEnd
// 0x0001 (0x0001 - 0x0000)
struct LamentConfiguration_Cosmetic_OnHoldingSurvivorHostageEnd final
{
public:
	bool                                          HasEndedThroughKillerAttack;                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LamentConfiguration_Cosmetic_OnHoldingSurvivorHostageEnd) == 0x000001, "Wrong alignment on LamentConfiguration_Cosmetic_OnHoldingSurvivorHostageEnd");
static_assert(sizeof(LamentConfiguration_Cosmetic_OnHoldingSurvivorHostageEnd) == 0x000001, "Wrong size on LamentConfiguration_Cosmetic_OnHoldingSurvivorHostageEnd");
static_assert(offsetof(LamentConfiguration_Cosmetic_OnHoldingSurvivorHostageEnd, HasEndedThroughKillerAttack) == 0x000000, "Member 'LamentConfiguration_Cosmetic_OnHoldingSurvivorHostageEnd::HasEndedThroughKillerAttack' has a wrong offset!");

// Function TheK25.LamentConfiguration.Cosmetic_OnHoldingSurvivorHostageStart
// 0x0004 (0x0004 - 0x0000)
struct LamentConfiguration_Cosmetic_OnHoldingSurvivorHostageStart final
{
public:
	float                                         HostageDuration;                                   // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LamentConfiguration_Cosmetic_OnHoldingSurvivorHostageStart) == 0x000004, "Wrong alignment on LamentConfiguration_Cosmetic_OnHoldingSurvivorHostageStart");
static_assert(sizeof(LamentConfiguration_Cosmetic_OnHoldingSurvivorHostageStart) == 0x000004, "Wrong size on LamentConfiguration_Cosmetic_OnHoldingSurvivorHostageStart");
static_assert(offsetof(LamentConfiguration_Cosmetic_OnHoldingSurvivorHostageStart, HostageDuration) == 0x000000, "Member 'LamentConfiguration_Cosmetic_OnHoldingSurvivorHostageStart::HostageDuration' has a wrong offset!");

// Function TheK25.LamentConfiguration.Cosmetic_OnKillerDownedSurvivorHoldingLamentConfiguration
// 0x0010 (0x0010 - 0x0000)
struct LamentConfiguration_Cosmetic_OnKillerDownedSurvivorHoldingLamentConfiguration final
{
public:
	class ASlasherPlayer*                         Killer;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACamperPlayer*                          SurvivorDowned;                                    // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LamentConfiguration_Cosmetic_OnKillerDownedSurvivorHoldingLamentConfiguration) == 0x000008, "Wrong alignment on LamentConfiguration_Cosmetic_OnKillerDownedSurvivorHoldingLamentConfiguration");
static_assert(sizeof(LamentConfiguration_Cosmetic_OnKillerDownedSurvivorHoldingLamentConfiguration) == 0x000010, "Wrong size on LamentConfiguration_Cosmetic_OnKillerDownedSurvivorHoldingLamentConfiguration");
static_assert(offsetof(LamentConfiguration_Cosmetic_OnKillerDownedSurvivorHoldingLamentConfiguration, Killer) == 0x000000, "Member 'LamentConfiguration_Cosmetic_OnKillerDownedSurvivorHoldingLamentConfiguration::Killer' has a wrong offset!");
static_assert(offsetof(LamentConfiguration_Cosmetic_OnKillerDownedSurvivorHoldingLamentConfiguration, SurvivorDowned) == 0x000008, "Member 'LamentConfiguration_Cosmetic_OnKillerDownedSurvivorHoldingLamentConfiguration::SurvivorDowned' has a wrong offset!");

// Function TheK25.LamentConfiguration.Multicast_CorrectLamentConfigurationPosition
// 0x0018 (0x0018 - 0x0000)
struct LamentConfiguration_Multicast_CorrectLamentConfigurationPosition final
{
public:
	struct FVector                                NewPosition;                                       // 0x0000(0x0018)(ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LamentConfiguration_Multicast_CorrectLamentConfigurationPosition) == 0x000008, "Wrong alignment on LamentConfiguration_Multicast_CorrectLamentConfigurationPosition");
static_assert(sizeof(LamentConfiguration_Multicast_CorrectLamentConfigurationPosition) == 0x000018, "Wrong size on LamentConfiguration_Multicast_CorrectLamentConfigurationPosition");
static_assert(offsetof(LamentConfiguration_Multicast_CorrectLamentConfigurationPosition, NewPosition) == 0x000000, "Member 'LamentConfiguration_Multicast_CorrectLamentConfigurationPosition::NewPosition' has a wrong offset!");

// Function TheK25.LamentConfiguration.Multicast_DownedSurvivorHoldingLamentConfiguration
// 0x0008 (0x0008 - 0x0000)
struct LamentConfiguration_Multicast_DownedSurvivorHoldingLamentConfiguration final
{
public:
	class ACamperPlayer*                          Survivor;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LamentConfiguration_Multicast_DownedSurvivorHoldingLamentConfiguration) == 0x000008, "Wrong alignment on LamentConfiguration_Multicast_DownedSurvivorHoldingLamentConfiguration");
static_assert(sizeof(LamentConfiguration_Multicast_DownedSurvivorHoldingLamentConfiguration) == 0x000008, "Wrong size on LamentConfiguration_Multicast_DownedSurvivorHoldingLamentConfiguration");
static_assert(offsetof(LamentConfiguration_Multicast_DownedSurvivorHoldingLamentConfiguration, Survivor) == 0x000000, "Member 'LamentConfiguration_Multicast_DownedSurvivorHoldingLamentConfiguration::Survivor' has a wrong offset!");

// Function TheK25.LamentConfiguration.Multicast_TriggerKillerPickUpSFX
// 0x0010 (0x0010 - 0x0000)
struct LamentConfiguration_Multicast_TriggerKillerPickUpSFX final
{
public:
	TArray<class ACamperPlayer*>                  AffectedSurvivors;                                 // 0x0000(0x0010)(ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LamentConfiguration_Multicast_TriggerKillerPickUpSFX) == 0x000008, "Wrong alignment on LamentConfiguration_Multicast_TriggerKillerPickUpSFX");
static_assert(sizeof(LamentConfiguration_Multicast_TriggerKillerPickUpSFX) == 0x000010, "Wrong size on LamentConfiguration_Multicast_TriggerKillerPickUpSFX");
static_assert(offsetof(LamentConfiguration_Multicast_TriggerKillerPickUpSFX, AffectedSurvivors) == 0x000000, "Member 'LamentConfiguration_Multicast_TriggerKillerPickUpSFX::AffectedSurvivors' has a wrong offset!");

// Function TheK25.LamentConfiguration.OnCamperEscaped
// 0x0040 (0x0040 - 0x0000)
struct LamentConfiguration_OnCamperEscaped final
{
public:
	struct FGameplayTag                           GameEventType;                                     // 0x0000(0x000C)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameEventData                         GameEventData;                                     // 0x0010(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LamentConfiguration_OnCamperEscaped) == 0x000008, "Wrong alignment on LamentConfiguration_OnCamperEscaped");
static_assert(sizeof(LamentConfiguration_OnCamperEscaped) == 0x000040, "Wrong size on LamentConfiguration_OnCamperEscaped");
static_assert(offsetof(LamentConfiguration_OnCamperEscaped, GameEventType) == 0x000000, "Member 'LamentConfiguration_OnCamperEscaped::GameEventType' has a wrong offset!");
static_assert(offsetof(LamentConfiguration_OnCamperEscaped, GameEventData) == 0x000010, "Member 'LamentConfiguration_OnCamperEscaped::GameEventData' has a wrong offset!");

// Function TheK25.LamentConfiguration.OnRep_SurvivorHeldHostage
// 0x0008 (0x0008 - 0x0000)
struct LamentConfiguration_OnRep_SurvivorHeldHostage final
{
public:
	class ACamperPlayer*                          OldSurvivorHeldHostage;                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LamentConfiguration_OnRep_SurvivorHeldHostage) == 0x000008, "Wrong alignment on LamentConfiguration_OnRep_SurvivorHeldHostage");
static_assert(sizeof(LamentConfiguration_OnRep_SurvivorHeldHostage) == 0x000008, "Wrong size on LamentConfiguration_OnRep_SurvivorHeldHostage");
static_assert(offsetof(LamentConfiguration_OnRep_SurvivorHeldHostage, OldSurvivorHeldHostage) == 0x000000, "Member 'LamentConfiguration_OnRep_SurvivorHeldHostage::OldSurvivorHeldHostage' has a wrong offset!");

// Function TheK25.LamentConfiguration.TriggerKillerPickUpSFX
// 0x0010 (0x0010 - 0x0000)
struct LamentConfiguration_TriggerKillerPickUpSFX final
{
public:
	TArray<class ACamperPlayer*>                  AffectedSurvivors;                                 // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LamentConfiguration_TriggerKillerPickUpSFX) == 0x000008, "Wrong alignment on LamentConfiguration_TriggerKillerPickUpSFX");
static_assert(sizeof(LamentConfiguration_TriggerKillerPickUpSFX) == 0x000010, "Wrong size on LamentConfiguration_TriggerKillerPickUpSFX");
static_assert(offsetof(LamentConfiguration_TriggerKillerPickUpSFX, AffectedSurvivors) == 0x000000, "Member 'LamentConfiguration_TriggerKillerPickUpSFX::AffectedSurvivors' has a wrong offset!");

// Function TheK25.LamentConfiguration.GetChainHuntProgressPercentage
// 0x0004 (0x0004 - 0x0000)
struct LamentConfiguration_GetChainHuntProgressPercentage final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LamentConfiguration_GetChainHuntProgressPercentage) == 0x000004, "Wrong alignment on LamentConfiguration_GetChainHuntProgressPercentage");
static_assert(sizeof(LamentConfiguration_GetChainHuntProgressPercentage) == 0x000004, "Wrong size on LamentConfiguration_GetChainHuntProgressPercentage");
static_assert(offsetof(LamentConfiguration_GetChainHuntProgressPercentage, ReturnValue) == 0x000000, "Member 'LamentConfiguration_GetChainHuntProgressPercentage::ReturnValue' has a wrong offset!");

// Function TheK25.ChainAttachedGateBlockerEffect.OnSurvivorDamageStateChanged
// 0x0002 (0x0002 - 0x0000)
struct ChainAttachedGateBlockerEffect_OnSurvivorDamageStateChanged final
{
public:
	ECamperDamageState                            OldState;                                          // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECamperDamageState                            NewState;                                          // 0x0001(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ChainAttachedGateBlockerEffect_OnSurvivorDamageStateChanged) == 0x000001, "Wrong alignment on ChainAttachedGateBlockerEffect_OnSurvivorDamageStateChanged");
static_assert(sizeof(ChainAttachedGateBlockerEffect_OnSurvivorDamageStateChanged) == 0x000002, "Wrong size on ChainAttachedGateBlockerEffect_OnSurvivorDamageStateChanged");
static_assert(offsetof(ChainAttachedGateBlockerEffect_OnSurvivorDamageStateChanged, OldState) == 0x000000, "Member 'ChainAttachedGateBlockerEffect_OnSurvivorDamageStateChanged::OldState' has a wrong offset!");
static_assert(offsetof(ChainAttachedGateBlockerEffect_OnSurvivorDamageStateChanged, NewState) == 0x000001, "Member 'ChainAttachedGateBlockerEffect_OnSurvivorDamageStateChanged::NewState' has a wrong offset!");

// Function TheK25.LamentConfigurationChainHuntComponent.GetChainHuntProgressPercentage
// 0x0004 (0x0004 - 0x0000)
struct LamentConfigurationChainHuntComponent_GetChainHuntProgressPercentage final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LamentConfigurationChainHuntComponent_GetChainHuntProgressPercentage) == 0x000004, "Wrong alignment on LamentConfigurationChainHuntComponent_GetChainHuntProgressPercentage");
static_assert(sizeof(LamentConfigurationChainHuntComponent_GetChainHuntProgressPercentage) == 0x000004, "Wrong size on LamentConfigurationChainHuntComponent_GetChainHuntProgressPercentage");
static_assert(offsetof(LamentConfigurationChainHuntComponent_GetChainHuntProgressPercentage, ReturnValue) == 0x000000, "Member 'LamentConfigurationChainHuntComponent_GetChainHuntProgressPercentage::ReturnValue' has a wrong offset!");

// Function TheK25.K25Chain.Cosmetic_OnChainAttachedToSurvivor
// 0x0001 (0x0001 - 0x0000)
struct K25Chain_Cosmetic_OnChainAttachedToSurvivor final
{
public:
	bool                                          WasReachingSurvivorAnchorPoint;                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25Chain_Cosmetic_OnChainAttachedToSurvivor) == 0x000001, "Wrong alignment on K25Chain_Cosmetic_OnChainAttachedToSurvivor");
static_assert(sizeof(K25Chain_Cosmetic_OnChainAttachedToSurvivor) == 0x000001, "Wrong size on K25Chain_Cosmetic_OnChainAttachedToSurvivor");
static_assert(offsetof(K25Chain_Cosmetic_OnChainAttachedToSurvivor, WasReachingSurvivorAnchorPoint) == 0x000000, "Member 'K25Chain_Cosmetic_OnChainAttachedToSurvivor::WasReachingSurvivorAnchorPoint' has a wrong offset!");

// Function TheK25.K25Chain.Cosmetic_OnChainDetachedFromSurvivor
// 0x0001 (0x0001 - 0x0000)
struct K25Chain_Cosmetic_OnChainDetachedFromSurvivor final
{
public:
	EK25ChainDetachmentReason                     DetachmentReason;                                  // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25Chain_Cosmetic_OnChainDetachedFromSurvivor) == 0x000001, "Wrong alignment on K25Chain_Cosmetic_OnChainDetachedFromSurvivor");
static_assert(sizeof(K25Chain_Cosmetic_OnChainDetachedFromSurvivor) == 0x000001, "Wrong size on K25Chain_Cosmetic_OnChainDetachedFromSurvivor");
static_assert(offsetof(K25Chain_Cosmetic_OnChainDetachedFromSurvivor, DetachmentReason) == 0x000000, "Member 'K25Chain_Cosmetic_OnChainDetachedFromSurvivor::DetachmentReason' has a wrong offset!");

// Function TheK25.K25Chain.Cosmetic_OnSurvivorStoppedRemovingChainSFX
// 0x0001 (0x0001 - 0x0000)
struct K25Chain_Cosmetic_OnSurvivorStoppedRemovingChainSFX final
{
public:
	bool                                          HasRemovedChainDueToInteraction;                   // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25Chain_Cosmetic_OnSurvivorStoppedRemovingChainSFX) == 0x000001, "Wrong alignment on K25Chain_Cosmetic_OnSurvivorStoppedRemovingChainSFX");
static_assert(sizeof(K25Chain_Cosmetic_OnSurvivorStoppedRemovingChainSFX) == 0x000001, "Wrong size on K25Chain_Cosmetic_OnSurvivorStoppedRemovingChainSFX");
static_assert(offsetof(K25Chain_Cosmetic_OnSurvivorStoppedRemovingChainSFX, HasRemovedChainDueToInteraction) == 0x000000, "Member 'K25Chain_Cosmetic_OnSurvivorStoppedRemovingChainSFX::HasRemovedChainDueToInteraction' has a wrong offset!");

// Function TheK25.K25Chain.SetInstancedMeshComponent
// 0x0008 (0x0008 - 0x0000)
struct K25Chain_SetInstancedMeshComponent final
{
public:
	class UInstancedStaticMeshComponent*          InstancedMesh;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25Chain_SetInstancedMeshComponent) == 0x000008, "Wrong alignment on K25Chain_SetInstancedMeshComponent");
static_assert(sizeof(K25Chain_SetInstancedMeshComponent) == 0x000008, "Wrong size on K25Chain_SetInstancedMeshComponent");
static_assert(offsetof(K25Chain_SetInstancedMeshComponent, InstancedMesh) == 0x000000, "Member 'K25Chain_SetInstancedMeshComponent::InstancedMesh' has a wrong offset!");

// Function TheK25.K25Chain.SetSplineComponent
// 0x0008 (0x0008 - 0x0000)
struct K25Chain_SetSplineComponent final
{
public:
	class USplineComponent*                       Component;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25Chain_SetSplineComponent) == 0x000008, "Wrong alignment on K25Chain_SetSplineComponent");
static_assert(sizeof(K25Chain_SetSplineComponent) == 0x000008, "Wrong size on K25Chain_SetSplineComponent");
static_assert(offsetof(K25Chain_SetSplineComponent, Component) == 0x000000, "Member 'K25Chain_SetSplineComponent::Component' has a wrong offset!");

// Function TheK25.K25Chain.GetChainEndLocation
// 0x0018 (0x0018 - 0x0000)
struct K25Chain_GetChainEndLocation final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25Chain_GetChainEndLocation) == 0x000008, "Wrong alignment on K25Chain_GetChainEndLocation");
static_assert(sizeof(K25Chain_GetChainEndLocation) == 0x000018, "Wrong size on K25Chain_GetChainEndLocation");
static_assert(offsetof(K25Chain_GetChainEndLocation, ReturnValue) == 0x000000, "Member 'K25Chain_GetChainEndLocation::ReturnValue' has a wrong offset!");

// Function TheK25.K25Chain.GetChainStartLocation
// 0x0018 (0x0018 - 0x0000)
struct K25Chain_GetChainStartLocation final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25Chain_GetChainStartLocation) == 0x000008, "Wrong alignment on K25Chain_GetChainStartLocation");
static_assert(sizeof(K25Chain_GetChainStartLocation) == 0x000018, "Wrong size on K25Chain_GetChainStartLocation");
static_assert(offsetof(K25Chain_GetChainStartLocation, ReturnValue) == 0x000000, "Member 'K25Chain_GetChainStartLocation::ReturnValue' has a wrong offset!");

// Function TheK25.K25Chain.GetSurvivorChainAttachmentAnchor
// 0x0008 (0x0008 - 0x0000)
struct K25Chain_GetSurvivorChainAttachmentAnchor final
{
public:
	class AK25SurvivorChainAttachmentAnchor*      ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25Chain_GetSurvivorChainAttachmentAnchor) == 0x000008, "Wrong alignment on K25Chain_GetSurvivorChainAttachmentAnchor");
static_assert(sizeof(K25Chain_GetSurvivorChainAttachmentAnchor) == 0x000008, "Wrong size on K25Chain_GetSurvivorChainAttachmentAnchor");
static_assert(offsetof(K25Chain_GetSurvivorChainAttachmentAnchor, ReturnValue) == 0x000000, "Member 'K25Chain_GetSurvivorChainAttachmentAnchor::ReturnValue' has a wrong offset!");

// Function TheK25.K25Chain.IsAttachedToControlledProjectile
// 0x0001 (0x0001 - 0x0000)
struct K25Chain_IsAttachedToControlledProjectile final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25Chain_IsAttachedToControlledProjectile) == 0x000001, "Wrong alignment on K25Chain_IsAttachedToControlledProjectile");
static_assert(sizeof(K25Chain_IsAttachedToControlledProjectile) == 0x000001, "Wrong size on K25Chain_IsAttachedToControlledProjectile");
static_assert(offsetof(K25Chain_IsAttachedToControlledProjectile, ReturnValue) == 0x000000, "Member 'K25Chain_IsAttachedToControlledProjectile::ReturnValue' has a wrong offset!");

// Function TheK25.K25ChainAttachmentReplicationComponent.Multicast_AttachChainToAnchor
// 0x0018 (0x0018 - 0x0000)
struct K25ChainAttachmentReplicationComponent_Multicast_AttachChainToAnchor final
{
public:
	class UK25SurvivorChainAttachmentComponent*   ChainAttachementComponent;                         // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AK25Chain*                              ChainToAttach;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AK25SurvivorChainAttachmentAnchor*      AnchorPoint;                                       // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25ChainAttachmentReplicationComponent_Multicast_AttachChainToAnchor) == 0x000008, "Wrong alignment on K25ChainAttachmentReplicationComponent_Multicast_AttachChainToAnchor");
static_assert(sizeof(K25ChainAttachmentReplicationComponent_Multicast_AttachChainToAnchor) == 0x000018, "Wrong size on K25ChainAttachmentReplicationComponent_Multicast_AttachChainToAnchor");
static_assert(offsetof(K25ChainAttachmentReplicationComponent_Multicast_AttachChainToAnchor, ChainAttachementComponent) == 0x000000, "Member 'K25ChainAttachmentReplicationComponent_Multicast_AttachChainToAnchor::ChainAttachementComponent' has a wrong offset!");
static_assert(offsetof(K25ChainAttachmentReplicationComponent_Multicast_AttachChainToAnchor, ChainToAttach) == 0x000008, "Member 'K25ChainAttachmentReplicationComponent_Multicast_AttachChainToAnchor::ChainToAttach' has a wrong offset!");
static_assert(offsetof(K25ChainAttachmentReplicationComponent_Multicast_AttachChainToAnchor, AnchorPoint) == 0x000010, "Member 'K25ChainAttachmentReplicationComponent_Multicast_AttachChainToAnchor::AnchorPoint' has a wrong offset!");

// Function TheK25.K25ChainAttachmentReplicationComponent.Multicast_DetachChains
// 0x0030 (0x0030 - 0x0000)
struct K25ChainAttachmentReplicationComponent_Multicast_DetachChains final
{
public:
	class UK25SurvivorChainAttachmentComponent*   ChainAttachementComponent;                         // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AK25Chain*>                      ChainsToDetach;                                    // 0x0008(0x0010)(ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	EK25ChainDetachmentReason                     DetachmentReason;                                  // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AK25Chain*>                      ChainsAttached;                                    // 0x0020(0x0010)(ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25ChainAttachmentReplicationComponent_Multicast_DetachChains) == 0x000008, "Wrong alignment on K25ChainAttachmentReplicationComponent_Multicast_DetachChains");
static_assert(sizeof(K25ChainAttachmentReplicationComponent_Multicast_DetachChains) == 0x000030, "Wrong size on K25ChainAttachmentReplicationComponent_Multicast_DetachChains");
static_assert(offsetof(K25ChainAttachmentReplicationComponent_Multicast_DetachChains, ChainAttachementComponent) == 0x000000, "Member 'K25ChainAttachmentReplicationComponent_Multicast_DetachChains::ChainAttachementComponent' has a wrong offset!");
static_assert(offsetof(K25ChainAttachmentReplicationComponent_Multicast_DetachChains, ChainsToDetach) == 0x000008, "Member 'K25ChainAttachmentReplicationComponent_Multicast_DetachChains::ChainsToDetach' has a wrong offset!");
static_assert(offsetof(K25ChainAttachmentReplicationComponent_Multicast_DetachChains, DetachmentReason) == 0x000018, "Member 'K25ChainAttachmentReplicationComponent_Multicast_DetachChains::DetachmentReason' has a wrong offset!");
static_assert(offsetof(K25ChainAttachmentReplicationComponent_Multicast_DetachChains, ChainsAttached) == 0x000020, "Member 'K25ChainAttachmentReplicationComponent_Multicast_DetachChains::ChainsAttached' has a wrong offset!");

// Function TheK25.K25ChainAttachmentReplicationComponent.Multicast_LaunchInstantHitChainTowardsSurvivor
// 0x0028 (0x0028 - 0x0000)
struct K25ChainAttachmentReplicationComponent_Multicast_LaunchInstantHitChainTowardsSurvivor final
{
public:
	class AK25Chain*                              NewChainToAttach;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AK25SurvivorChainAttachmentAnchor*      TargetAnchor;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                StartPosition;                                     // 0x0010(0x0018)(ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25ChainAttachmentReplicationComponent_Multicast_LaunchInstantHitChainTowardsSurvivor) == 0x000008, "Wrong alignment on K25ChainAttachmentReplicationComponent_Multicast_LaunchInstantHitChainTowardsSurvivor");
static_assert(sizeof(K25ChainAttachmentReplicationComponent_Multicast_LaunchInstantHitChainTowardsSurvivor) == 0x000028, "Wrong size on K25ChainAttachmentReplicationComponent_Multicast_LaunchInstantHitChainTowardsSurvivor");
static_assert(offsetof(K25ChainAttachmentReplicationComponent_Multicast_LaunchInstantHitChainTowardsSurvivor, NewChainToAttach) == 0x000000, "Member 'K25ChainAttachmentReplicationComponent_Multicast_LaunchInstantHitChainTowardsSurvivor::NewChainToAttach' has a wrong offset!");
static_assert(offsetof(K25ChainAttachmentReplicationComponent_Multicast_LaunchInstantHitChainTowardsSurvivor, TargetAnchor) == 0x000008, "Member 'K25ChainAttachmentReplicationComponent_Multicast_LaunchInstantHitChainTowardsSurvivor::TargetAnchor' has a wrong offset!");
static_assert(offsetof(K25ChainAttachmentReplicationComponent_Multicast_LaunchInstantHitChainTowardsSurvivor, StartPosition) == 0x000010, "Member 'K25ChainAttachmentReplicationComponent_Multicast_LaunchInstantHitChainTowardsSurvivor::StartPosition' has a wrong offset!");

// Function TheK25.K25ChainAttachmentReplicationComponent.Multicast_StartChainReelback
// 0x0008 (0x0008 - 0x0000)
struct K25ChainAttachmentReplicationComponent_Multicast_StartChainReelback final
{
public:
	class AK25Chain*                              ChainToAttach;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25ChainAttachmentReplicationComponent_Multicast_StartChainReelback) == 0x000008, "Wrong alignment on K25ChainAttachmentReplicationComponent_Multicast_StartChainReelback");
static_assert(sizeof(K25ChainAttachmentReplicationComponent_Multicast_StartChainReelback) == 0x000008, "Wrong size on K25ChainAttachmentReplicationComponent_Multicast_StartChainReelback");
static_assert(offsetof(K25ChainAttachmentReplicationComponent_Multicast_StartChainReelback, ChainToAttach) == 0x000000, "Member 'K25ChainAttachmentReplicationComponent_Multicast_StartChainReelback::ChainToAttach' has a wrong offset!");

// Function TheK25.K25ChainHuntEffectsComponent.Cosmetic_ActivateChainHuntEffects
// 0x0001 (0x0001 - 0x0000)
struct K25ChainHuntEffectsComponent_Cosmetic_ActivateChainHuntEffects final
{
public:
	bool                                          HasChainHuntStarted;                               // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25ChainHuntEffectsComponent_Cosmetic_ActivateChainHuntEffects) == 0x000001, "Wrong alignment on K25ChainHuntEffectsComponent_Cosmetic_ActivateChainHuntEffects");
static_assert(sizeof(K25ChainHuntEffectsComponent_Cosmetic_ActivateChainHuntEffects) == 0x000001, "Wrong size on K25ChainHuntEffectsComponent_Cosmetic_ActivateChainHuntEffects");
static_assert(offsetof(K25ChainHuntEffectsComponent_Cosmetic_ActivateChainHuntEffects, HasChainHuntStarted) == 0x000000, "Member 'K25ChainHuntEffectsComponent_Cosmetic_ActivateChainHuntEffects::HasChainHuntStarted' has a wrong offset!");

// Function TheK25.K25ChainHuntEffectsComponent.GetOwningPlayer
// 0x0008 (0x0008 - 0x0000)
struct K25ChainHuntEffectsComponent_GetOwningPlayer final
{
public:
	class ADBDPlayer*                             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25ChainHuntEffectsComponent_GetOwningPlayer) == 0x000008, "Wrong alignment on K25ChainHuntEffectsComponent_GetOwningPlayer");
static_assert(sizeof(K25ChainHuntEffectsComponent_GetOwningPlayer) == 0x000008, "Wrong size on K25ChainHuntEffectsComponent_GetOwningPlayer");
static_assert(offsetof(K25ChainHuntEffectsComponent_GetOwningPlayer, ReturnValue) == 0x000000, "Member 'K25ChainHuntEffectsComponent_GetOwningPlayer::ReturnValue' has a wrong offset!");

// Function TheK25.K25ChainLocomotionSurvivorAnimInstance.OnChainAttached
// 0x0010 (0x0010 - 0x0000)
struct K25ChainLocomotionSurvivorAnimInstance_OnChainAttached final
{
public:
	class AK25Chain*                              Chain;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AK25SurvivorChainAttachmentAnchor*      ChainAttachmentAnchor;                             // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25ChainLocomotionSurvivorAnimInstance_OnChainAttached) == 0x000008, "Wrong alignment on K25ChainLocomotionSurvivorAnimInstance_OnChainAttached");
static_assert(sizeof(K25ChainLocomotionSurvivorAnimInstance_OnChainAttached) == 0x000010, "Wrong size on K25ChainLocomotionSurvivorAnimInstance_OnChainAttached");
static_assert(offsetof(K25ChainLocomotionSurvivorAnimInstance_OnChainAttached, Chain) == 0x000000, "Member 'K25ChainLocomotionSurvivorAnimInstance_OnChainAttached::Chain' has a wrong offset!");
static_assert(offsetof(K25ChainLocomotionSurvivorAnimInstance_OnChainAttached, ChainAttachmentAnchor) == 0x000008, "Member 'K25ChainLocomotionSurvivorAnimInstance_OnChainAttached::ChainAttachmentAnchor' has a wrong offset!");

// Function TheK25.K25ChainLocomotionSurvivorAnimInstance.OnChainDetached
// 0x0018 (0x0018 - 0x0000)
struct K25ChainLocomotionSurvivorAnimInstance_OnChainDetached final
{
public:
	class AK25Chain*                              Chain;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AK25SurvivorChainAttachmentAnchor*      ChainAttachmentAnchor;                             // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EK25ChainDetachmentReason                     DetachmentReason;                                  // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(K25ChainLocomotionSurvivorAnimInstance_OnChainDetached) == 0x000008, "Wrong alignment on K25ChainLocomotionSurvivorAnimInstance_OnChainDetached");
static_assert(sizeof(K25ChainLocomotionSurvivorAnimInstance_OnChainDetached) == 0x000018, "Wrong size on K25ChainLocomotionSurvivorAnimInstance_OnChainDetached");
static_assert(offsetof(K25ChainLocomotionSurvivorAnimInstance_OnChainDetached, Chain) == 0x000000, "Member 'K25ChainLocomotionSurvivorAnimInstance_OnChainDetached::Chain' has a wrong offset!");
static_assert(offsetof(K25ChainLocomotionSurvivorAnimInstance_OnChainDetached, ChainAttachmentAnchor) == 0x000008, "Member 'K25ChainLocomotionSurvivorAnimInstance_OnChainDetached::ChainAttachmentAnchor' has a wrong offset!");
static_assert(offsetof(K25ChainLocomotionSurvivorAnimInstance_OnChainDetached, DetachmentReason) == 0x000010, "Member 'K25ChainLocomotionSurvivorAnimInstance_OnChainDetached::DetachmentReason' has a wrong offset!");

// Function TheK25.K25ChainStrikeBaseState.GetK25Gateway
// 0x0008 (0x0008 - 0x0000)
struct K25ChainStrikeBaseState_GetK25Gateway final
{
public:
	class AK25Gateway*                            ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25ChainStrikeBaseState_GetK25Gateway) == 0x000008, "Wrong alignment on K25ChainStrikeBaseState_GetK25Gateway");
static_assert(sizeof(K25ChainStrikeBaseState_GetK25Gateway) == 0x000008, "Wrong size on K25ChainStrikeBaseState_GetK25Gateway");
static_assert(offsetof(K25ChainStrikeBaseState_GetK25Gateway, ReturnValue) == 0x000000, "Member 'K25ChainStrikeBaseState_GetK25Gateway::ReturnValue' has a wrong offset!");

// Function TheK25.K25ChainStrikeBaseState.GetK25Power
// 0x0008 (0x0008 - 0x0000)
struct K25ChainStrikeBaseState_GetK25Power final
{
public:
	class AK25Power*                              ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25ChainStrikeBaseState_GetK25Power) == 0x000008, "Wrong alignment on K25ChainStrikeBaseState_GetK25Power");
static_assert(sizeof(K25ChainStrikeBaseState_GetK25Power) == 0x000008, "Wrong size on K25ChainStrikeBaseState_GetK25Power");
static_assert(offsetof(K25ChainStrikeBaseState_GetK25Power, ReturnValue) == 0x000000, "Member 'K25ChainStrikeBaseState_GetK25Power::ReturnValue' has a wrong offset!");

// Function TheK25.K25ChainStrikeBaseState.GetPlayerOwner
// 0x0008 (0x0008 - 0x0000)
struct K25ChainStrikeBaseState_GetPlayerOwner final
{
public:
	class ADBDPlayer*                             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25ChainStrikeBaseState_GetPlayerOwner) == 0x000008, "Wrong alignment on K25ChainStrikeBaseState_GetPlayerOwner");
static_assert(sizeof(K25ChainStrikeBaseState_GetPlayerOwner) == 0x000008, "Wrong size on K25ChainStrikeBaseState_GetPlayerOwner");
static_assert(offsetof(K25ChainStrikeBaseState_GetPlayerOwner, ReturnValue) == 0x000000, "Member 'K25ChainStrikeBaseState_GetPlayerOwner::ReturnValue' has a wrong offset!");

// Function TheK25.K25ChainStrikeInteraction.Cosmetic_ResetAllVignetteValues
// 0x0008 (0x0008 - 0x0000)
struct K25ChainStrikeInteraction_Cosmetic_ResetAllVignetteValues final
{
public:
	class ASlasherPlayer*                         Killer;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25ChainStrikeInteraction_Cosmetic_ResetAllVignetteValues) == 0x000008, "Wrong alignment on K25ChainStrikeInteraction_Cosmetic_ResetAllVignetteValues");
static_assert(sizeof(K25ChainStrikeInteraction_Cosmetic_ResetAllVignetteValues) == 0x000008, "Wrong size on K25ChainStrikeInteraction_Cosmetic_ResetAllVignetteValues");
static_assert(offsetof(K25ChainStrikeInteraction_Cosmetic_ResetAllVignetteValues, Killer) == 0x000000, "Member 'K25ChainStrikeInteraction_Cosmetic_ResetAllVignetteValues::Killer' has a wrong offset!");

// Function TheK25.K25ChainStrikeInteraction.Cosmetic_TriggerGatewayPossessionEffects
// 0x0004 (0x0004 - 0x0000)
struct K25ChainStrikeInteraction_Cosmetic_TriggerGatewayPossessionEffects final
{
public:
	float                                         TransitionTime;                                    // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25ChainStrikeInteraction_Cosmetic_TriggerGatewayPossessionEffects) == 0x000004, "Wrong alignment on K25ChainStrikeInteraction_Cosmetic_TriggerGatewayPossessionEffects");
static_assert(sizeof(K25ChainStrikeInteraction_Cosmetic_TriggerGatewayPossessionEffects) == 0x000004, "Wrong size on K25ChainStrikeInteraction_Cosmetic_TriggerGatewayPossessionEffects");
static_assert(offsetof(K25ChainStrikeInteraction_Cosmetic_TriggerGatewayPossessionEffects, TransitionTime) == 0x000000, "Member 'K25ChainStrikeInteraction_Cosmetic_TriggerGatewayPossessionEffects::TransitionTime' has a wrong offset!");

// Function TheK25.K25ChainStrikeInteraction.Cosmetic_TriggerKillerRepossessionFadeInEffects
// 0x0010 (0x0010 - 0x0000)
struct K25ChainStrikeInteraction_Cosmetic_TriggerKillerRepossessionFadeInEffects final
{
public:
	class ASlasherPlayer*                         Killer;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasHitSurvivor;                                    // 0x0008(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          PreventAudioTriggers;                              // 0x0009(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(K25ChainStrikeInteraction_Cosmetic_TriggerKillerRepossessionFadeInEffects) == 0x000008, "Wrong alignment on K25ChainStrikeInteraction_Cosmetic_TriggerKillerRepossessionFadeInEffects");
static_assert(sizeof(K25ChainStrikeInteraction_Cosmetic_TriggerKillerRepossessionFadeInEffects) == 0x000010, "Wrong size on K25ChainStrikeInteraction_Cosmetic_TriggerKillerRepossessionFadeInEffects");
static_assert(offsetof(K25ChainStrikeInteraction_Cosmetic_TriggerKillerRepossessionFadeInEffects, Killer) == 0x000000, "Member 'K25ChainStrikeInteraction_Cosmetic_TriggerKillerRepossessionFadeInEffects::Killer' has a wrong offset!");
static_assert(offsetof(K25ChainStrikeInteraction_Cosmetic_TriggerKillerRepossessionFadeInEffects, HasHitSurvivor) == 0x000008, "Member 'K25ChainStrikeInteraction_Cosmetic_TriggerKillerRepossessionFadeInEffects::HasHitSurvivor' has a wrong offset!");
static_assert(offsetof(K25ChainStrikeInteraction_Cosmetic_TriggerKillerRepossessionFadeInEffects, PreventAudioTriggers) == 0x000009, "Member 'K25ChainStrikeInteraction_Cosmetic_TriggerKillerRepossessionFadeInEffects::PreventAudioTriggers' has a wrong offset!");

// Function TheK25.K25ChainStrikeInteraction.Cosmetic_TriggerKillerRepossessionFadeOutEffects
// 0x0010 (0x0010 - 0x0000)
struct K25ChainStrikeInteraction_Cosmetic_TriggerKillerRepossessionFadeOutEffects final
{
public:
	class ASlasherPlayer*                         Killer;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          PreventAudioTriggers;                              // 0x0008(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(K25ChainStrikeInteraction_Cosmetic_TriggerKillerRepossessionFadeOutEffects) == 0x000008, "Wrong alignment on K25ChainStrikeInteraction_Cosmetic_TriggerKillerRepossessionFadeOutEffects");
static_assert(sizeof(K25ChainStrikeInteraction_Cosmetic_TriggerKillerRepossessionFadeOutEffects) == 0x000010, "Wrong size on K25ChainStrikeInteraction_Cosmetic_TriggerKillerRepossessionFadeOutEffects");
static_assert(offsetof(K25ChainStrikeInteraction_Cosmetic_TriggerKillerRepossessionFadeOutEffects, Killer) == 0x000000, "Member 'K25ChainStrikeInteraction_Cosmetic_TriggerKillerRepossessionFadeOutEffects::Killer' has a wrong offset!");
static_assert(offsetof(K25ChainStrikeInteraction_Cosmetic_TriggerKillerRepossessionFadeOutEffects, PreventAudioTriggers) == 0x000008, "Member 'K25ChainStrikeInteraction_Cosmetic_TriggerKillerRepossessionFadeOutEffects::PreventAudioTriggers' has a wrong offset!");

// Function TheK25.K25ChainStrikeInteraction.Multicast_AddStateTagToPlayer
// 0x000C (0x000C - 0x0000)
struct K25ChainStrikeInteraction_Multicast_AddStateTagToPlayer final
{
public:
	struct FGameplayTag                           Tag;                                               // 0x0000(0x000C)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25ChainStrikeInteraction_Multicast_AddStateTagToPlayer) == 0x000004, "Wrong alignment on K25ChainStrikeInteraction_Multicast_AddStateTagToPlayer");
static_assert(sizeof(K25ChainStrikeInteraction_Multicast_AddStateTagToPlayer) == 0x00000C, "Wrong size on K25ChainStrikeInteraction_Multicast_AddStateTagToPlayer");
static_assert(offsetof(K25ChainStrikeInteraction_Multicast_AddStateTagToPlayer, Tag) == 0x000000, "Member 'K25ChainStrikeInteraction_Multicast_AddStateTagToPlayer::Tag' has a wrong offset!");

// Function TheK25.K25ChainStrikeInteraction.Multicast_RemoveStateTagFromPlayer
// 0x000C (0x000C - 0x0000)
struct K25ChainStrikeInteraction_Multicast_RemoveStateTagFromPlayer final
{
public:
	struct FGameplayTag                           Tag;                                               // 0x0000(0x000C)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25ChainStrikeInteraction_Multicast_RemoveStateTagFromPlayer) == 0x000004, "Wrong alignment on K25ChainStrikeInteraction_Multicast_RemoveStateTagFromPlayer");
static_assert(sizeof(K25ChainStrikeInteraction_Multicast_RemoveStateTagFromPlayer) == 0x00000C, "Wrong size on K25ChainStrikeInteraction_Multicast_RemoveStateTagFromPlayer");
static_assert(offsetof(K25ChainStrikeInteraction_Multicast_RemoveStateTagFromPlayer, Tag) == 0x000000, "Member 'K25ChainStrikeInteraction_Multicast_RemoveStateTagFromPlayer::Tag' has a wrong offset!");

// Function TheK25.K25ChainStrikeInteraction.Multicast_SetFallbackEndReason
// 0x0001 (0x0001 - 0x0000)
struct K25ChainStrikeInteraction_Multicast_SetFallbackEndReason final
{
public:
	EChainStrikeEndReason                         ChainStrikeEndReason;                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25ChainStrikeInteraction_Multicast_SetFallbackEndReason) == 0x000001, "Wrong alignment on K25ChainStrikeInteraction_Multicast_SetFallbackEndReason");
static_assert(sizeof(K25ChainStrikeInteraction_Multicast_SetFallbackEndReason) == 0x000001, "Wrong size on K25ChainStrikeInteraction_Multicast_SetFallbackEndReason");
static_assert(offsetof(K25ChainStrikeInteraction_Multicast_SetFallbackEndReason, ChainStrikeEndReason) == 0x000000, "Member 'K25ChainStrikeInteraction_Multicast_SetFallbackEndReason::ChainStrikeEndReason' has a wrong offset!");

// Function TheK25.K25ChainStrikeInteraction.Server_AddStateTagToPlayer
// 0x000C (0x000C - 0x0000)
struct K25ChainStrikeInteraction_Server_AddStateTagToPlayer final
{
public:
	struct FGameplayTag                           Tag;                                               // 0x0000(0x000C)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25ChainStrikeInteraction_Server_AddStateTagToPlayer) == 0x000004, "Wrong alignment on K25ChainStrikeInteraction_Server_AddStateTagToPlayer");
static_assert(sizeof(K25ChainStrikeInteraction_Server_AddStateTagToPlayer) == 0x00000C, "Wrong size on K25ChainStrikeInteraction_Server_AddStateTagToPlayer");
static_assert(offsetof(K25ChainStrikeInteraction_Server_AddStateTagToPlayer, Tag) == 0x000000, "Member 'K25ChainStrikeInteraction_Server_AddStateTagToPlayer::Tag' has a wrong offset!");

// Function TheK25.K25ChainStrikeInteraction.Server_RemoveStateTagFromPlayer
// 0x000C (0x000C - 0x0000)
struct K25ChainStrikeInteraction_Server_RemoveStateTagFromPlayer final
{
public:
	struct FGameplayTag                           Tag;                                               // 0x0000(0x000C)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25ChainStrikeInteraction_Server_RemoveStateTagFromPlayer) == 0x000004, "Wrong alignment on K25ChainStrikeInteraction_Server_RemoveStateTagFromPlayer");
static_assert(sizeof(K25ChainStrikeInteraction_Server_RemoveStateTagFromPlayer) == 0x00000C, "Wrong size on K25ChainStrikeInteraction_Server_RemoveStateTagFromPlayer");
static_assert(offsetof(K25ChainStrikeInteraction_Server_RemoveStateTagFromPlayer, Tag) == 0x000000, "Member 'K25ChainStrikeInteraction_Server_RemoveStateTagFromPlayer::Tag' has a wrong offset!");

// Function TheK25.K25ChainStrikeInteraction.Server_SetFallbackEndReason
// 0x0001 (0x0001 - 0x0000)
struct K25ChainStrikeInteraction_Server_SetFallbackEndReason final
{
public:
	EChainStrikeEndReason                         ChainStrikeEndReason;                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25ChainStrikeInteraction_Server_SetFallbackEndReason) == 0x000001, "Wrong alignment on K25ChainStrikeInteraction_Server_SetFallbackEndReason");
static_assert(sizeof(K25ChainStrikeInteraction_Server_SetFallbackEndReason) == 0x000001, "Wrong size on K25ChainStrikeInteraction_Server_SetFallbackEndReason");
static_assert(offsetof(K25ChainStrikeInteraction_Server_SetFallbackEndReason, ChainStrikeEndReason) == 0x000000, "Member 'K25ChainStrikeInteraction_Server_SetFallbackEndReason::ChainStrikeEndReason' has a wrong offset!");

// Function TheK25.K25ChainStrikeInteraction.Server_SetShouldIncrementChargeableComponent
// 0x0001 (0x0001 - 0x0000)
struct K25ChainStrikeInteraction_Server_SetShouldIncrementChargeableComponent final
{
public:
	bool                                          ShouldIncrement;                                   // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25ChainStrikeInteraction_Server_SetShouldIncrementChargeableComponent) == 0x000001, "Wrong alignment on K25ChainStrikeInteraction_Server_SetShouldIncrementChargeableComponent");
static_assert(sizeof(K25ChainStrikeInteraction_Server_SetShouldIncrementChargeableComponent) == 0x000001, "Wrong size on K25ChainStrikeInteraction_Server_SetShouldIncrementChargeableComponent");
static_assert(offsetof(K25ChainStrikeInteraction_Server_SetShouldIncrementChargeableComponent, ShouldIncrement) == 0x000000, "Member 'K25ChainStrikeInteraction_Server_SetShouldIncrementChargeableComponent::ShouldIncrement' has a wrong offset!");

// Function TheK25.K25ChainStrikeInteraction.Server_UpdateCameraViewTargetForObservers
// 0x0001 (0x0001 - 0x0000)
struct K25ChainStrikeInteraction_Server_UpdateCameraViewTargetForObservers final
{
public:
	EChainStrikeCameraViewTarget                  NewViewTarget;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25ChainStrikeInteraction_Server_UpdateCameraViewTargetForObservers) == 0x000001, "Wrong alignment on K25ChainStrikeInteraction_Server_UpdateCameraViewTargetForObservers");
static_assert(sizeof(K25ChainStrikeInteraction_Server_UpdateCameraViewTargetForObservers) == 0x000001, "Wrong size on K25ChainStrikeInteraction_Server_UpdateCameraViewTargetForObservers");
static_assert(offsetof(K25ChainStrikeInteraction_Server_UpdateCameraViewTargetForObservers, NewViewTarget) == 0x000000, "Member 'K25ChainStrikeInteraction_Server_UpdateCameraViewTargetForObservers::NewViewTarget' has a wrong offset!");

// Function TheK25.K25ChainStrikeReplicationComponent.Multicast_EndChainStrike
// 0x0010 (0x0010 - 0x0000)
struct K25ChainStrikeReplicationComponent_Multicast_EndChainStrike final
{
public:
	class UK25ChainStrikeInteraction*             Interaction;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EChainStrikeEndReason                         EndReason;                                         // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(K25ChainStrikeReplicationComponent_Multicast_EndChainStrike) == 0x000008, "Wrong alignment on K25ChainStrikeReplicationComponent_Multicast_EndChainStrike");
static_assert(sizeof(K25ChainStrikeReplicationComponent_Multicast_EndChainStrike) == 0x000010, "Wrong size on K25ChainStrikeReplicationComponent_Multicast_EndChainStrike");
static_assert(offsetof(K25ChainStrikeReplicationComponent_Multicast_EndChainStrike, Interaction) == 0x000000, "Member 'K25ChainStrikeReplicationComponent_Multicast_EndChainStrike::Interaction' has a wrong offset!");
static_assert(offsetof(K25ChainStrikeReplicationComponent_Multicast_EndChainStrike, EndReason) == 0x000008, "Member 'K25ChainStrikeReplicationComponent_Multicast_EndChainStrike::EndReason' has a wrong offset!");

// Function TheK25.K25ChainStrikeReplicationComponent.Server_EndChainStrike
// 0x0010 (0x0010 - 0x0000)
struct K25ChainStrikeReplicationComponent_Server_EndChainStrike final
{
public:
	class UK25ChainStrikeInteraction*             Interaction;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EChainStrikeEndReason                         EndReason;                                         // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(K25ChainStrikeReplicationComponent_Server_EndChainStrike) == 0x000008, "Wrong alignment on K25ChainStrikeReplicationComponent_Server_EndChainStrike");
static_assert(sizeof(K25ChainStrikeReplicationComponent_Server_EndChainStrike) == 0x000010, "Wrong size on K25ChainStrikeReplicationComponent_Server_EndChainStrike");
static_assert(offsetof(K25ChainStrikeReplicationComponent_Server_EndChainStrike, Interaction) == 0x000000, "Member 'K25ChainStrikeReplicationComponent_Server_EndChainStrike::Interaction' has a wrong offset!");
static_assert(offsetof(K25ChainStrikeReplicationComponent_Server_EndChainStrike, EndReason) == 0x000008, "Member 'K25ChainStrikeReplicationComponent_Server_EndChainStrike::EndReason' has a wrong offset!");

// Function TheK25.K25CheatComponent.DBD_K25ComeToPositionLamentConfiguration
// 0x000C (0x000C - 0x0000)
struct K25CheatComponent_DBD_K25ComeToPositionLamentConfiguration final
{
public:
	float                                         X;                                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Y;                                                 // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Z;                                                 // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25CheatComponent_DBD_K25ComeToPositionLamentConfiguration) == 0x000004, "Wrong alignment on K25CheatComponent_DBD_K25ComeToPositionLamentConfiguration");
static_assert(sizeof(K25CheatComponent_DBD_K25ComeToPositionLamentConfiguration) == 0x00000C, "Wrong size on K25CheatComponent_DBD_K25ComeToPositionLamentConfiguration");
static_assert(offsetof(K25CheatComponent_DBD_K25ComeToPositionLamentConfiguration, X) == 0x000000, "Member 'K25CheatComponent_DBD_K25ComeToPositionLamentConfiguration::X' has a wrong offset!");
static_assert(offsetof(K25CheatComponent_DBD_K25ComeToPositionLamentConfiguration, Y) == 0x000004, "Member 'K25CheatComponent_DBD_K25ComeToPositionLamentConfiguration::Y' has a wrong offset!");
static_assert(offsetof(K25CheatComponent_DBD_K25ComeToPositionLamentConfiguration, Z) == 0x000008, "Member 'K25CheatComponent_DBD_K25ComeToPositionLamentConfiguration::Z' has a wrong offset!");

// Function TheK25.K25CheatComponent.DBD_K25ForceRemoveAllChainsOnClosestsSurvivorToPosition
// 0x000C (0x000C - 0x0000)
struct K25CheatComponent_DBD_K25ForceRemoveAllChainsOnClosestsSurvivorToPosition final
{
public:
	float                                         X;                                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Y;                                                 // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Z;                                                 // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25CheatComponent_DBD_K25ForceRemoveAllChainsOnClosestsSurvivorToPosition) == 0x000004, "Wrong alignment on K25CheatComponent_DBD_K25ForceRemoveAllChainsOnClosestsSurvivorToPosition");
static_assert(sizeof(K25CheatComponent_DBD_K25ForceRemoveAllChainsOnClosestsSurvivorToPosition) == 0x00000C, "Wrong size on K25CheatComponent_DBD_K25ForceRemoveAllChainsOnClosestsSurvivorToPosition");
static_assert(offsetof(K25CheatComponent_DBD_K25ForceRemoveAllChainsOnClosestsSurvivorToPosition, X) == 0x000000, "Member 'K25CheatComponent_DBD_K25ForceRemoveAllChainsOnClosestsSurvivorToPosition::X' has a wrong offset!");
static_assert(offsetof(K25CheatComponent_DBD_K25ForceRemoveAllChainsOnClosestsSurvivorToPosition, Y) == 0x000004, "Member 'K25CheatComponent_DBD_K25ForceRemoveAllChainsOnClosestsSurvivorToPosition::Y' has a wrong offset!");
static_assert(offsetof(K25CheatComponent_DBD_K25ForceRemoveAllChainsOnClosestsSurvivorToPosition, Z) == 0x000008, "Member 'K25CheatComponent_DBD_K25ForceRemoveAllChainsOnClosestsSurvivorToPosition::Z' has a wrong offset!");

// Function TheK25.K25CheatComponent.DBD_K25RevealLamentConfigurationLocation
// 0x0004 (0x0004 - 0x0000)
struct K25CheatComponent_DBD_K25RevealLamentConfigurationLocation final
{
public:
	float                                         TimeDisplayed;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25CheatComponent_DBD_K25RevealLamentConfigurationLocation) == 0x000004, "Wrong alignment on K25CheatComponent_DBD_K25RevealLamentConfigurationLocation");
static_assert(sizeof(K25CheatComponent_DBD_K25RevealLamentConfigurationLocation) == 0x000004, "Wrong size on K25CheatComponent_DBD_K25RevealLamentConfigurationLocation");
static_assert(offsetof(K25CheatComponent_DBD_K25RevealLamentConfigurationLocation, TimeDisplayed) == 0x000000, "Member 'K25CheatComponent_DBD_K25RevealLamentConfigurationLocation::TimeDisplayed' has a wrong offset!");

// Function TheK25.K25CheatComponent.DBD_K25SetPowerNoCooldown
// 0x0001 (0x0001 - 0x0000)
struct K25CheatComponent_DBD_K25SetPowerNoCooldown final
{
public:
	bool                                          NoCooldown;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25CheatComponent_DBD_K25SetPowerNoCooldown) == 0x000001, "Wrong alignment on K25CheatComponent_DBD_K25SetPowerNoCooldown");
static_assert(sizeof(K25CheatComponent_DBD_K25SetPowerNoCooldown) == 0x000001, "Wrong size on K25CheatComponent_DBD_K25SetPowerNoCooldown");
static_assert(offsetof(K25CheatComponent_DBD_K25SetPowerNoCooldown, NoCooldown) == 0x000000, "Member 'K25CheatComponent_DBD_K25SetPowerNoCooldown::NoCooldown' has a wrong offset!");

// Function TheK25.K25CheatComponent.DBD_K25ShowAllLamentConfigurationSpawnPoints
// 0x0004 (0x0004 - 0x0000)
struct K25CheatComponent_DBD_K25ShowAllLamentConfigurationSpawnPoints final
{
public:
	float                                         TimeDisplayed;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25CheatComponent_DBD_K25ShowAllLamentConfigurationSpawnPoints) == 0x000004, "Wrong alignment on K25CheatComponent_DBD_K25ShowAllLamentConfigurationSpawnPoints");
static_assert(sizeof(K25CheatComponent_DBD_K25ShowAllLamentConfigurationSpawnPoints) == 0x000004, "Wrong size on K25CheatComponent_DBD_K25ShowAllLamentConfigurationSpawnPoints");
static_assert(offsetof(K25CheatComponent_DBD_K25ShowAllLamentConfigurationSpawnPoints, TimeDisplayed) == 0x000000, "Member 'K25CheatComponent_DBD_K25ShowAllLamentConfigurationSpawnPoints::TimeDisplayed' has a wrong offset!");

// Function TheK25.K25CheatComponent.DBD_K25TriggerUncontrolledChainsOnAllSurvivors
// 0x0004 (0x0004 - 0x0000)
struct K25CheatComponent_DBD_K25TriggerUncontrolledChainsOnAllSurvivors final
{
public:
	int32                                         NumbChains;                                        // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25CheatComponent_DBD_K25TriggerUncontrolledChainsOnAllSurvivors) == 0x000004, "Wrong alignment on K25CheatComponent_DBD_K25TriggerUncontrolledChainsOnAllSurvivors");
static_assert(sizeof(K25CheatComponent_DBD_K25TriggerUncontrolledChainsOnAllSurvivors) == 0x000004, "Wrong size on K25CheatComponent_DBD_K25TriggerUncontrolledChainsOnAllSurvivors");
static_assert(offsetof(K25CheatComponent_DBD_K25TriggerUncontrolledChainsOnAllSurvivors, NumbChains) == 0x000000, "Member 'K25CheatComponent_DBD_K25TriggerUncontrolledChainsOnAllSurvivors::NumbChains' has a wrong offset!");

// Function TheK25.K25CheatComponent.DBD_K25TriggerUncontrolledChainsOnClosestsSurvivorToPosition
// 0x0010 (0x0010 - 0x0000)
struct K25CheatComponent_DBD_K25TriggerUncontrolledChainsOnClosestsSurvivorToPosition final
{
public:
	float                                         X;                                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Y;                                                 // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Z;                                                 // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumbChains;                                        // 0x000C(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25CheatComponent_DBD_K25TriggerUncontrolledChainsOnClosestsSurvivorToPosition) == 0x000004, "Wrong alignment on K25CheatComponent_DBD_K25TriggerUncontrolledChainsOnClosestsSurvivorToPosition");
static_assert(sizeof(K25CheatComponent_DBD_K25TriggerUncontrolledChainsOnClosestsSurvivorToPosition) == 0x000010, "Wrong size on K25CheatComponent_DBD_K25TriggerUncontrolledChainsOnClosestsSurvivorToPosition");
static_assert(offsetof(K25CheatComponent_DBD_K25TriggerUncontrolledChainsOnClosestsSurvivorToPosition, X) == 0x000000, "Member 'K25CheatComponent_DBD_K25TriggerUncontrolledChainsOnClosestsSurvivorToPosition::X' has a wrong offset!");
static_assert(offsetof(K25CheatComponent_DBD_K25TriggerUncontrolledChainsOnClosestsSurvivorToPosition, Y) == 0x000004, "Member 'K25CheatComponent_DBD_K25TriggerUncontrolledChainsOnClosestsSurvivorToPosition::Y' has a wrong offset!");
static_assert(offsetof(K25CheatComponent_DBD_K25TriggerUncontrolledChainsOnClosestsSurvivorToPosition, Z) == 0x000008, "Member 'K25CheatComponent_DBD_K25TriggerUncontrolledChainsOnClosestsSurvivorToPosition::Z' has a wrong offset!");
static_assert(offsetof(K25CheatComponent_DBD_K25TriggerUncontrolledChainsOnClosestsSurvivorToPosition, NumbChains) == 0x00000C, "Member 'K25CheatComponent_DBD_K25TriggerUncontrolledChainsOnClosestsSurvivorToPosition::NumbChains' has a wrong offset!");

// Function TheK25.K25CheatComponent.DBD_K25TriggerUncontrolledChainsOnLocalSurvivor
// 0x0004 (0x0004 - 0x0000)
struct K25CheatComponent_DBD_K25TriggerUncontrolledChainsOnLocalSurvivor final
{
public:
	int32                                         NumbChains;                                        // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25CheatComponent_DBD_K25TriggerUncontrolledChainsOnLocalSurvivor) == 0x000004, "Wrong alignment on K25CheatComponent_DBD_K25TriggerUncontrolledChainsOnLocalSurvivor");
static_assert(sizeof(K25CheatComponent_DBD_K25TriggerUncontrolledChainsOnLocalSurvivor) == 0x000004, "Wrong size on K25CheatComponent_DBD_K25TriggerUncontrolledChainsOnLocalSurvivor");
static_assert(offsetof(K25CheatComponent_DBD_K25TriggerUncontrolledChainsOnLocalSurvivor, NumbChains) == 0x000000, "Member 'K25CheatComponent_DBD_K25TriggerUncontrolledChainsOnLocalSurvivor::NumbChains' has a wrong offset!");

// Function TheK25.K25ControlledProjectile.Server_ProcessPitchInput
// 0x0008 (0x0008 - 0x0000)
struct K25ControlledProjectile_Server_ProcessPitchInput final
{
public:
	float                                         DeltaTime;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScaledInput;                                       // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25ControlledProjectile_Server_ProcessPitchInput) == 0x000004, "Wrong alignment on K25ControlledProjectile_Server_ProcessPitchInput");
static_assert(sizeof(K25ControlledProjectile_Server_ProcessPitchInput) == 0x000008, "Wrong size on K25ControlledProjectile_Server_ProcessPitchInput");
static_assert(offsetof(K25ControlledProjectile_Server_ProcessPitchInput, DeltaTime) == 0x000000, "Member 'K25ControlledProjectile_Server_ProcessPitchInput::DeltaTime' has a wrong offset!");
static_assert(offsetof(K25ControlledProjectile_Server_ProcessPitchInput, ScaledInput) == 0x000004, "Member 'K25ControlledProjectile_Server_ProcessPitchInput::ScaledInput' has a wrong offset!");

// Function TheK25.K25ControlledProjectile.Server_ProcessYawInput
// 0x0008 (0x0008 - 0x0000)
struct K25ControlledProjectile_Server_ProcessYawInput final
{
public:
	float                                         DeltaTime;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScaledInput;                                       // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25ControlledProjectile_Server_ProcessYawInput) == 0x000004, "Wrong alignment on K25ControlledProjectile_Server_ProcessYawInput");
static_assert(sizeof(K25ControlledProjectile_Server_ProcessYawInput) == 0x000008, "Wrong size on K25ControlledProjectile_Server_ProcessYawInput");
static_assert(offsetof(K25ControlledProjectile_Server_ProcessYawInput, DeltaTime) == 0x000000, "Member 'K25ControlledProjectile_Server_ProcessYawInput::DeltaTime' has a wrong offset!");
static_assert(offsetof(K25ControlledProjectile_Server_ProcessYawInput, ScaledInput) == 0x000004, "Member 'K25ControlledProjectile_Server_ProcessYawInput::ScaledInput' has a wrong offset!");

// Function TheK25.K25Gateway.Cosmetic_SetIsGatewayPositionValid
// 0x0001 (0x0001 - 0x0000)
struct K25Gateway_Cosmetic_SetIsGatewayPositionValid final
{
public:
	bool                                          IsGatewayPlacementValid;                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25Gateway_Cosmetic_SetIsGatewayPositionValid) == 0x000001, "Wrong alignment on K25Gateway_Cosmetic_SetIsGatewayPositionValid");
static_assert(sizeof(K25Gateway_Cosmetic_SetIsGatewayPositionValid) == 0x000001, "Wrong size on K25Gateway_Cosmetic_SetIsGatewayPositionValid");
static_assert(offsetof(K25Gateway_Cosmetic_SetIsGatewayPositionValid, IsGatewayPlacementValid) == 0x000000, "Member 'K25Gateway_Cosmetic_SetIsGatewayPositionValid::IsGatewayPlacementValid' has a wrong offset!");

// Function TheK25.K25Gateway.Cosmetic_SetKillerVisualVisibility
// 0x0001 (0x0001 - 0x0000)
struct K25Gateway_Cosmetic_SetKillerVisualVisibility final
{
public:
	bool                                          IsVisible;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25Gateway_Cosmetic_SetKillerVisualVisibility) == 0x000001, "Wrong alignment on K25Gateway_Cosmetic_SetKillerVisualVisibility");
static_assert(sizeof(K25Gateway_Cosmetic_SetKillerVisualVisibility) == 0x000001, "Wrong size on K25Gateway_Cosmetic_SetKillerVisualVisibility");
static_assert(offsetof(K25Gateway_Cosmetic_SetKillerVisualVisibility, IsVisible) == 0x000000, "Member 'K25Gateway_Cosmetic_SetKillerVisualVisibility::IsVisible' has a wrong offset!");

// Function TheK25.K25Gateway.Cosmetic_TriggerGatewayPossessedEffects
// 0x0004 (0x0004 - 0x0000)
struct K25Gateway_Cosmetic_TriggerGatewayPossessedEffects final
{
public:
	float                                         TransitionTime;                                    // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25Gateway_Cosmetic_TriggerGatewayPossessedEffects) == 0x000004, "Wrong alignment on K25Gateway_Cosmetic_TriggerGatewayPossessedEffects");
static_assert(sizeof(K25Gateway_Cosmetic_TriggerGatewayPossessedEffects) == 0x000004, "Wrong size on K25Gateway_Cosmetic_TriggerGatewayPossessedEffects");
static_assert(offsetof(K25Gateway_Cosmetic_TriggerGatewayPossessedEffects, TransitionTime) == 0x000000, "Member 'K25Gateway_Cosmetic_TriggerGatewayPossessedEffects::TransitionTime' has a wrong offset!");

// Function TheK25.K25Gateway.Multicast_SetGatewayLocation
// 0x0018 (0x0018 - 0x0000)
struct K25Gateway_Multicast_SetGatewayLocation final
{
public:
	struct FVector                                PossessionLocation;                                // 0x0000(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25Gateway_Multicast_SetGatewayLocation) == 0x000008, "Wrong alignment on K25Gateway_Multicast_SetGatewayLocation");
static_assert(sizeof(K25Gateway_Multicast_SetGatewayLocation) == 0x000018, "Wrong size on K25Gateway_Multicast_SetGatewayLocation");
static_assert(offsetof(K25Gateway_Multicast_SetGatewayLocation, PossessionLocation) == 0x000000, "Member 'K25Gateway_Multicast_SetGatewayLocation::PossessionLocation' has a wrong offset!");

// Function TheK25.K25Gateway.Multicast_SetGatewayOrientation
// 0x0018 (0x0018 - 0x0000)
struct K25Gateway_Multicast_SetGatewayOrientation final
{
public:
	struct FRotator                               Rotation;                                          // 0x0000(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25Gateway_Multicast_SetGatewayOrientation) == 0x000008, "Wrong alignment on K25Gateway_Multicast_SetGatewayOrientation");
static_assert(sizeof(K25Gateway_Multicast_SetGatewayOrientation) == 0x000018, "Wrong size on K25Gateway_Multicast_SetGatewayOrientation");
static_assert(offsetof(K25Gateway_Multicast_SetGatewayOrientation, Rotation) == 0x000000, "Member 'K25Gateway_Multicast_SetGatewayOrientation::Rotation' has a wrong offset!");

// Function TheK25.K25Gateway.Multicast_SetGatewayTargetLocation
// 0x0020 (0x0020 - 0x0000)
struct K25Gateway_Multicast_SetGatewayTargetLocation final
{
public:
	struct FVector                                TargetLocation;                                    // 0x0000(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsValidLocation;                                   // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(K25Gateway_Multicast_SetGatewayTargetLocation) == 0x000008, "Wrong alignment on K25Gateway_Multicast_SetGatewayTargetLocation");
static_assert(sizeof(K25Gateway_Multicast_SetGatewayTargetLocation) == 0x000020, "Wrong size on K25Gateway_Multicast_SetGatewayTargetLocation");
static_assert(offsetof(K25Gateway_Multicast_SetGatewayTargetLocation, TargetLocation) == 0x000000, "Member 'K25Gateway_Multicast_SetGatewayTargetLocation::TargetLocation' has a wrong offset!");
static_assert(offsetof(K25Gateway_Multicast_SetGatewayTargetLocation, IsValidLocation) == 0x000018, "Member 'K25Gateway_Multicast_SetGatewayTargetLocation::IsValidLocation' has a wrong offset!");

// Function TheK25.K25Gateway.Server_SetGatewayOrientation
// 0x0018 (0x0018 - 0x0000)
struct K25Gateway_Server_SetGatewayOrientation final
{
public:
	struct FRotator                               Rotation;                                          // 0x0000(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25Gateway_Server_SetGatewayOrientation) == 0x000008, "Wrong alignment on K25Gateway_Server_SetGatewayOrientation");
static_assert(sizeof(K25Gateway_Server_SetGatewayOrientation) == 0x000018, "Wrong size on K25Gateway_Server_SetGatewayOrientation");
static_assert(offsetof(K25Gateway_Server_SetGatewayOrientation, Rotation) == 0x000000, "Member 'K25Gateway_Server_SetGatewayOrientation::Rotation' has a wrong offset!");

// Function TheK25.K25Gateway.Server_SetGatewayTargetLocation
// 0x0020 (0x0020 - 0x0000)
struct K25Gateway_Server_SetGatewayTargetLocation final
{
public:
	struct FVector                                TargetLocation;                                    // 0x0000(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsValidLocation;                                   // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(K25Gateway_Server_SetGatewayTargetLocation) == 0x000008, "Wrong alignment on K25Gateway_Server_SetGatewayTargetLocation");
static_assert(sizeof(K25Gateway_Server_SetGatewayTargetLocation) == 0x000020, "Wrong size on K25Gateway_Server_SetGatewayTargetLocation");
static_assert(offsetof(K25Gateway_Server_SetGatewayTargetLocation, TargetLocation) == 0x000000, "Member 'K25Gateway_Server_SetGatewayTargetLocation::TargetLocation' has a wrong offset!");
static_assert(offsetof(K25Gateway_Server_SetGatewayTargetLocation, IsValidLocation) == 0x000018, "Member 'K25Gateway_Server_SetGatewayTargetLocation::IsValidLocation' has a wrong offset!");

// Function TheK25.K25Gateway.Server_SetIsGatewayBeingPositionned
// 0x0001 (0x0001 - 0x0000)
struct K25Gateway_Server_SetIsGatewayBeingPositionned final
{
public:
	bool                                          IsBeingPositionned;                                // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25Gateway_Server_SetIsGatewayBeingPositionned) == 0x000001, "Wrong alignment on K25Gateway_Server_SetIsGatewayBeingPositionned");
static_assert(sizeof(K25Gateway_Server_SetIsGatewayBeingPositionned) == 0x000001, "Wrong size on K25Gateway_Server_SetIsGatewayBeingPositionned");
static_assert(offsetof(K25Gateway_Server_SetIsGatewayBeingPositionned, IsBeingPositionned) == 0x000000, "Member 'K25Gateway_Server_SetIsGatewayBeingPositionned::IsBeingPositionned' has a wrong offset!");

// Function TheK25.K25Gateway.Server_StartGatewayPossession
// 0x0030 (0x0030 - 0x0000)
struct K25Gateway_Server_StartGatewayPossession final
{
public:
	struct FVector                                PossessionLocation;                                // 0x0000(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               GatewayRotation;                                   // 0x0018(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25Gateway_Server_StartGatewayPossession) == 0x000008, "Wrong alignment on K25Gateway_Server_StartGatewayPossession");
static_assert(sizeof(K25Gateway_Server_StartGatewayPossession) == 0x000030, "Wrong size on K25Gateway_Server_StartGatewayPossession");
static_assert(offsetof(K25Gateway_Server_StartGatewayPossession, PossessionLocation) == 0x000000, "Member 'K25Gateway_Server_StartGatewayPossession::PossessionLocation' has a wrong offset!");
static_assert(offsetof(K25Gateway_Server_StartGatewayPossession, GatewayRotation) == 0x000018, "Member 'K25Gateway_Server_StartGatewayPossession::GatewayRotation' has a wrong offset!");

// Function TheK25.K25Gateway.GetCameraComponent
// 0x0008 (0x0008 - 0x0000)
struct K25Gateway_GetCameraComponent final
{
public:
	class UCameraComponent*                       ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25Gateway_GetCameraComponent) == 0x000008, "Wrong alignment on K25Gateway_GetCameraComponent");
static_assert(sizeof(K25Gateway_GetCameraComponent) == 0x000008, "Wrong size on K25Gateway_GetCameraComponent");
static_assert(offsetof(K25Gateway_GetCameraComponent, ReturnValue) == 0x000000, "Member 'K25Gateway_GetCameraComponent::ReturnValue' has a wrong offset!");

// Function TheK25.K25Gateway.IsGatewayPossessed
// 0x0001 (0x0001 - 0x0000)
struct K25Gateway_IsGatewayPossessed final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25Gateway_IsGatewayPossessed) == 0x000001, "Wrong alignment on K25Gateway_IsGatewayPossessed");
static_assert(sizeof(K25Gateway_IsGatewayPossessed) == 0x000001, "Wrong size on K25Gateway_IsGatewayPossessed");
static_assert(offsetof(K25Gateway_IsGatewayPossessed, ReturnValue) == 0x000000, "Member 'K25Gateway_IsGatewayPossessed::ReturnValue' has a wrong offset!");

// Function TheK25.K25LamentConfigurationTeleportIndicator.Cosmetic_UpdateIndicatorVisibility
// 0x0001 (0x0001 - 0x0000)
struct K25LamentConfigurationTeleportIndicator_Cosmetic_UpdateIndicatorVisibility final
{
public:
	bool                                          IsVisible;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25LamentConfigurationTeleportIndicator_Cosmetic_UpdateIndicatorVisibility) == 0x000001, "Wrong alignment on K25LamentConfigurationTeleportIndicator_Cosmetic_UpdateIndicatorVisibility");
static_assert(sizeof(K25LamentConfigurationTeleportIndicator_Cosmetic_UpdateIndicatorVisibility) == 0x000001, "Wrong size on K25LamentConfigurationTeleportIndicator_Cosmetic_UpdateIndicatorVisibility");
static_assert(offsetof(K25LamentConfigurationTeleportIndicator_Cosmetic_UpdateIndicatorVisibility, IsVisible) == 0x000000, "Member 'K25LamentConfigurationTeleportIndicator_Cosmetic_UpdateIndicatorVisibility::IsVisible' has a wrong offset!");

// Function TheK25.K25P01.Authority_OnBlockTimerDone
// 0x0008 (0x0008 - 0x0000)
struct K25P01_Authority_OnBlockTimerDone final
{
public:
	class AGenerator*                             Generator;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25P01_Authority_OnBlockTimerDone) == 0x000008, "Wrong alignment on K25P01_Authority_OnBlockTimerDone");
static_assert(sizeof(K25P01_Authority_OnBlockTimerDone) == 0x000008, "Wrong size on K25P01_Authority_OnBlockTimerDone");
static_assert(offsetof(K25P01_Authority_OnBlockTimerDone, Generator) == 0x000000, "Member 'K25P01_Authority_OnBlockTimerDone::Generator' has a wrong offset!");

// Function TheK25.K25P01.GetGeneratorBlockDuration
// 0x0004 (0x0004 - 0x0000)
struct K25P01_GetGeneratorBlockDuration final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25P01_GetGeneratorBlockDuration) == 0x000004, "Wrong alignment on K25P01_GetGeneratorBlockDuration");
static_assert(sizeof(K25P01_GetGeneratorBlockDuration) == 0x000004, "Wrong size on K25P01_GetGeneratorBlockDuration");
static_assert(offsetof(K25P01_GetGeneratorBlockDuration, ReturnValue) == 0x000000, "Member 'K25P01_GetGeneratorBlockDuration::ReturnValue' has a wrong offset!");

// Function TheK25.K25P02.GetTotemAuraRevealRadius
// 0x0004 (0x0004 - 0x0000)
struct K25P02_GetTotemAuraRevealRadius final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25P02_GetTotemAuraRevealRadius) == 0x000004, "Wrong alignment on K25P02_GetTotemAuraRevealRadius");
static_assert(sizeof(K25P02_GetTotemAuraRevealRadius) == 0x000004, "Wrong size on K25P02_GetTotemAuraRevealRadius");
static_assert(offsetof(K25P02_GetTotemAuraRevealRadius, ReturnValue) == 0x000000, "Member 'K25P02_GetTotemAuraRevealRadius::ReturnValue' has a wrong offset!");

// Function TheK25.K25P02.GetTotemBlockerDuration
// 0x0004 (0x0004 - 0x0000)
struct K25P02_GetTotemBlockerDuration final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25P02_GetTotemBlockerDuration) == 0x000004, "Wrong alignment on K25P02_GetTotemBlockerDuration");
static_assert(sizeof(K25P02_GetTotemBlockerDuration) == 0x000004, "Wrong size on K25P02_GetTotemBlockerDuration");
static_assert(offsetof(K25P02_GetTotemBlockerDuration, ReturnValue) == 0x000000, "Member 'K25P02_GetTotemBlockerDuration::ReturnValue' has a wrong offset!");

// Function TheK25.K25P02.GetTotemBlockerHasLifetime
// 0x0001 (0x0001 - 0x0000)
struct K25P02_GetTotemBlockerHasLifetime final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25P02_GetTotemBlockerHasLifetime) == 0x000001, "Wrong alignment on K25P02_GetTotemBlockerHasLifetime");
static_assert(sizeof(K25P02_GetTotemBlockerHasLifetime) == 0x000001, "Wrong size on K25P02_GetTotemBlockerHasLifetime");
static_assert(offsetof(K25P02_GetTotemBlockerHasLifetime, ReturnValue) == 0x000000, "Member 'K25P02_GetTotemBlockerHasLifetime::ReturnValue' has a wrong offset!");

// Function TheK25.K25P03.OnCamperUnhookedFromScourgeHook
// 0x0030 (0x0030 - 0x0000)
struct K25P03_OnCamperUnhookedFromScourgeHook final
{
public:
	struct FGameEventData                         GameEventData;                                     // 0x0000(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25P03_OnCamperUnhookedFromScourgeHook) == 0x000008, "Wrong alignment on K25P03_OnCamperUnhookedFromScourgeHook");
static_assert(sizeof(K25P03_OnCamperUnhookedFromScourgeHook) == 0x000030, "Wrong size on K25P03_OnCamperUnhookedFromScourgeHook");
static_assert(offsetof(K25P03_OnCamperUnhookedFromScourgeHook, GameEventData) == 0x000000, "Member 'K25P03_OnCamperUnhookedFromScourgeHook::GameEventData' has a wrong offset!");

// Function TheK25.K25P03.OnDamageStateChanged
// 0x0040 (0x0040 - 0x0000)
struct K25P03_OnDamageStateChanged final
{
public:
	struct FGameplayTag                           GameplayTag;                                       // 0x0000(0x000C)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameEventData                         GameEventData;                                     // 0x0010(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25P03_OnDamageStateChanged) == 0x000008, "Wrong alignment on K25P03_OnDamageStateChanged");
static_assert(sizeof(K25P03_OnDamageStateChanged) == 0x000040, "Wrong size on K25P03_OnDamageStateChanged");
static_assert(offsetof(K25P03_OnDamageStateChanged, GameplayTag) == 0x000000, "Member 'K25P03_OnDamageStateChanged::GameplayTag' has a wrong offset!");
static_assert(offsetof(K25P03_OnDamageStateChanged, GameEventData) == 0x000010, "Member 'K25P03_OnDamageStateChanged::GameEventData' has a wrong offset!");

// Function TheK25.K25P03.OnSurvivorRemoved
// 0x0008 (0x0008 - 0x0000)
struct K25P03_OnSurvivorRemoved final
{
public:
	class ACamperPlayer*                          Survivor;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25P03_OnSurvivorRemoved) == 0x000008, "Wrong alignment on K25P03_OnSurvivorRemoved");
static_assert(sizeof(K25P03_OnSurvivorRemoved) == 0x000008, "Wrong size on K25P03_OnSurvivorRemoved");
static_assert(offsetof(K25P03_OnSurvivorRemoved, Survivor) == 0x000000, "Member 'K25P03_OnSurvivorRemoved::Survivor' has a wrong offset!");

// Function TheK25.K25P03.GetActionSpeedDebuffPercentageAtLevel
// 0x0004 (0x0004 - 0x0000)
struct K25P03_GetActionSpeedDebuffPercentageAtLevel final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25P03_GetActionSpeedDebuffPercentageAtLevel) == 0x000004, "Wrong alignment on K25P03_GetActionSpeedDebuffPercentageAtLevel");
static_assert(sizeof(K25P03_GetActionSpeedDebuffPercentageAtLevel) == 0x000004, "Wrong size on K25P03_GetActionSpeedDebuffPercentageAtLevel");
static_assert(offsetof(K25P03_GetActionSpeedDebuffPercentageAtLevel, ReturnValue) == 0x000000, "Member 'K25P03_GetActionSpeedDebuffPercentageAtLevel::ReturnValue' has a wrong offset!");

// Function TheK25.K25P03.GetMangledHemorrhageEffectLifetimeAtLevel
// 0x0004 (0x0004 - 0x0000)
struct K25P03_GetMangledHemorrhageEffectLifetimeAtLevel final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25P03_GetMangledHemorrhageEffectLifetimeAtLevel) == 0x000004, "Wrong alignment on K25P03_GetMangledHemorrhageEffectLifetimeAtLevel");
static_assert(sizeof(K25P03_GetMangledHemorrhageEffectLifetimeAtLevel) == 0x000004, "Wrong size on K25P03_GetMangledHemorrhageEffectLifetimeAtLevel");
static_assert(offsetof(K25P03_GetMangledHemorrhageEffectLifetimeAtLevel, ReturnValue) == 0x000000, "Member 'K25P03_GetMangledHemorrhageEffectLifetimeAtLevel::ReturnValue' has a wrong offset!");

// Function TheK25.K25Power.Cosmetic_OnKillerInterruptOpenHatchSFX
// 0x0008 (0x0008 - 0x0000)
struct K25Power_Cosmetic_OnKillerInterruptOpenHatchSFX final
{
public:
	class ASlasherPlayer*                         Killer;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25Power_Cosmetic_OnKillerInterruptOpenHatchSFX) == 0x000008, "Wrong alignment on K25Power_Cosmetic_OnKillerInterruptOpenHatchSFX");
static_assert(sizeof(K25Power_Cosmetic_OnKillerInterruptOpenHatchSFX) == 0x000008, "Wrong size on K25Power_Cosmetic_OnKillerInterruptOpenHatchSFX");
static_assert(offsetof(K25Power_Cosmetic_OnKillerInterruptOpenHatchSFX, Killer) == 0x000000, "Member 'K25Power_Cosmetic_OnKillerInterruptOpenHatchSFX::Killer' has a wrong offset!");

// Function TheK25.K25Power.Cosmetic_OnKillerInterruptSFX
// 0x0008 (0x0008 - 0x0000)
struct K25Power_Cosmetic_OnKillerInterruptSFX final
{
public:
	class ASlasherPlayer*                         Killer;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25Power_Cosmetic_OnKillerInterruptSFX) == 0x000008, "Wrong alignment on K25Power_Cosmetic_OnKillerInterruptSFX");
static_assert(sizeof(K25Power_Cosmetic_OnKillerInterruptSFX) == 0x000008, "Wrong size on K25Power_Cosmetic_OnKillerInterruptSFX");
static_assert(offsetof(K25Power_Cosmetic_OnKillerInterruptSFX, Killer) == 0x000000, "Member 'K25Power_Cosmetic_OnKillerInterruptSFX::Killer' has a wrong offset!");

// Function TheK25.K25Power.OnKillerAdded
// 0x0008 (0x0008 - 0x0000)
struct K25Power_OnKillerAdded final
{
public:
	class ASlasherPlayer*                         Killer;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25Power_OnKillerAdded) == 0x000008, "Wrong alignment on K25Power_OnKillerAdded");
static_assert(sizeof(K25Power_OnKillerAdded) == 0x000008, "Wrong size on K25Power_OnKillerAdded");
static_assert(offsetof(K25Power_OnKillerAdded, Killer) == 0x000000, "Member 'K25Power_OnKillerAdded::Killer' has a wrong offset!");

// Function TheK25.K25Power.OnSurvivorAdded
// 0x0010 (0x0010 - 0x0000)
struct K25Power_OnSurvivorAdded final
{
public:
	class ACamperPlayer*                          Survivor;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ASlasherPlayer*                         Killer;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25Power_OnSurvivorAdded) == 0x000008, "Wrong alignment on K25Power_OnSurvivorAdded");
static_assert(sizeof(K25Power_OnSurvivorAdded) == 0x000010, "Wrong size on K25Power_OnSurvivorAdded");
static_assert(offsetof(K25Power_OnSurvivorAdded, Survivor) == 0x000000, "Member 'K25Power_OnSurvivorAdded::Survivor' has a wrong offset!");
static_assert(offsetof(K25Power_OnSurvivorAdded, Killer) == 0x000008, "Member 'K25Power_OnSurvivorAdded::Killer' has a wrong offset!");

// Function TheK25.K25SolveLamentConfigurationInteraction.Authority_OnSkillCheckResponseAuthority
// 0x0018 (0x0018 - 0x0000)
struct K25SolveLamentConfigurationInteraction_Authority_OnSkillCheckResponseAuthority final
{
public:
	bool                                          Success;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Bonus;                                             // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class ADBDPlayer*                             Player;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TriggerLoudNoise;                                  // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESkillCheckCustomType                         Type;                                              // 0x0011(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(K25SolveLamentConfigurationInteraction_Authority_OnSkillCheckResponseAuthority) == 0x000008, "Wrong alignment on K25SolveLamentConfigurationInteraction_Authority_OnSkillCheckResponseAuthority");
static_assert(sizeof(K25SolveLamentConfigurationInteraction_Authority_OnSkillCheckResponseAuthority) == 0x000018, "Wrong size on K25SolveLamentConfigurationInteraction_Authority_OnSkillCheckResponseAuthority");
static_assert(offsetof(K25SolveLamentConfigurationInteraction_Authority_OnSkillCheckResponseAuthority, Success) == 0x000000, "Member 'K25SolveLamentConfigurationInteraction_Authority_OnSkillCheckResponseAuthority::Success' has a wrong offset!");
static_assert(offsetof(K25SolveLamentConfigurationInteraction_Authority_OnSkillCheckResponseAuthority, Bonus) == 0x000001, "Member 'K25SolveLamentConfigurationInteraction_Authority_OnSkillCheckResponseAuthority::Bonus' has a wrong offset!");
static_assert(offsetof(K25SolveLamentConfigurationInteraction_Authority_OnSkillCheckResponseAuthority, Player) == 0x000008, "Member 'K25SolveLamentConfigurationInteraction_Authority_OnSkillCheckResponseAuthority::Player' has a wrong offset!");
static_assert(offsetof(K25SolveLamentConfigurationInteraction_Authority_OnSkillCheckResponseAuthority, TriggerLoudNoise) == 0x000010, "Member 'K25SolveLamentConfigurationInteraction_Authority_OnSkillCheckResponseAuthority::TriggerLoudNoise' has a wrong offset!");
static_assert(offsetof(K25SolveLamentConfigurationInteraction_Authority_OnSkillCheckResponseAuthority, Type) == 0x000011, "Member 'K25SolveLamentConfigurationInteraction_Authority_OnSkillCheckResponseAuthority::Type' has a wrong offset!");

// Function TheK25.K25SolveLamentConfigurationInteraction.Cosmetic_TriggerKillerStoppedInteractionViaAttackSFX
// 0x0008 (0x0008 - 0x0000)
struct K25SolveLamentConfigurationInteraction_Cosmetic_TriggerKillerStoppedInteractionViaAttackSFX final
{
public:
	class ASlasherPlayer*                         Killer;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25SolveLamentConfigurationInteraction_Cosmetic_TriggerKillerStoppedInteractionViaAttackSFX) == 0x000008, "Wrong alignment on K25SolveLamentConfigurationInteraction_Cosmetic_TriggerKillerStoppedInteractionViaAttackSFX");
static_assert(sizeof(K25SolveLamentConfigurationInteraction_Cosmetic_TriggerKillerStoppedInteractionViaAttackSFX) == 0x000008, "Wrong size on K25SolveLamentConfigurationInteraction_Cosmetic_TriggerKillerStoppedInteractionViaAttackSFX");
static_assert(offsetof(K25SolveLamentConfigurationInteraction_Cosmetic_TriggerKillerStoppedInteractionViaAttackSFX, Killer) == 0x000000, "Member 'K25SolveLamentConfigurationInteraction_Cosmetic_TriggerKillerStoppedInteractionViaAttackSFX::Killer' has a wrong offset!");

// Function TheK25.K25SolveLamentConfigurationInteraction.Multicast_TriggerKillerStoppedInteractionViaAttackSFX
// 0x0008 (0x0008 - 0x0000)
struct K25SolveLamentConfigurationInteraction_Multicast_TriggerKillerStoppedInteractionViaAttackSFX final
{
public:
	class ASlasherPlayer*                         Killer;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25SolveLamentConfigurationInteraction_Multicast_TriggerKillerStoppedInteractionViaAttackSFX) == 0x000008, "Wrong alignment on K25SolveLamentConfigurationInteraction_Multicast_TriggerKillerStoppedInteractionViaAttackSFX");
static_assert(sizeof(K25SolveLamentConfigurationInteraction_Multicast_TriggerKillerStoppedInteractionViaAttackSFX) == 0x000008, "Wrong size on K25SolveLamentConfigurationInteraction_Multicast_TriggerKillerStoppedInteractionViaAttackSFX");
static_assert(offsetof(K25SolveLamentConfigurationInteraction_Multicast_TriggerKillerStoppedInteractionViaAttackSFX, Killer) == 0x000000, "Member 'K25SolveLamentConfigurationInteraction_Multicast_TriggerKillerStoppedInteractionViaAttackSFX::Killer' has a wrong offset!");

// Function TheK25.K25SurvivorChainAttachmentAnchor.Cosmetic_OnChainAttached
// 0x0008 (0x0008 - 0x0000)
struct K25SurvivorChainAttachmentAnchor_Cosmetic_OnChainAttached final
{
public:
	class AK25Chain*                              ChainToAttach;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25SurvivorChainAttachmentAnchor_Cosmetic_OnChainAttached) == 0x000008, "Wrong alignment on K25SurvivorChainAttachmentAnchor_Cosmetic_OnChainAttached");
static_assert(sizeof(K25SurvivorChainAttachmentAnchor_Cosmetic_OnChainAttached) == 0x000008, "Wrong size on K25SurvivorChainAttachmentAnchor_Cosmetic_OnChainAttached");
static_assert(offsetof(K25SurvivorChainAttachmentAnchor_Cosmetic_OnChainAttached, ChainToAttach) == 0x000000, "Member 'K25SurvivorChainAttachmentAnchor_Cosmetic_OnChainAttached::ChainToAttach' has a wrong offset!");

// Function TheK25.K25SurvivorChainAttachmentAnchor.Cosmetic_OnChainDetached
// 0x0008 (0x0008 - 0x0000)
struct K25SurvivorChainAttachmentAnchor_Cosmetic_OnChainDetached final
{
public:
	class AK25Chain*                              ChainToDetach;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25SurvivorChainAttachmentAnchor_Cosmetic_OnChainDetached) == 0x000008, "Wrong alignment on K25SurvivorChainAttachmentAnchor_Cosmetic_OnChainDetached");
static_assert(sizeof(K25SurvivorChainAttachmentAnchor_Cosmetic_OnChainDetached) == 0x000008, "Wrong size on K25SurvivorChainAttachmentAnchor_Cosmetic_OnChainDetached");
static_assert(offsetof(K25SurvivorChainAttachmentAnchor_Cosmetic_OnChainDetached, ChainToDetach) == 0x000000, "Member 'K25SurvivorChainAttachmentAnchor_Cosmetic_OnChainDetached::ChainToDetach' has a wrong offset!");

// Function TheK25.K25SurvivorChainAttachmentAnchor.GetChainAttachmentData
// 0x0038 (0x0038 - 0x0000)
struct K25SurvivorChainAttachmentAnchor_GetChainAttachmentData final
{
public:
	struct FK25SurvivorChainAttachmentData        ReturnValue;                                       // 0x0000(0x0038)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25SurvivorChainAttachmentAnchor_GetChainAttachmentData) == 0x000008, "Wrong alignment on K25SurvivorChainAttachmentAnchor_GetChainAttachmentData");
static_assert(sizeof(K25SurvivorChainAttachmentAnchor_GetChainAttachmentData) == 0x000038, "Wrong size on K25SurvivorChainAttachmentAnchor_GetChainAttachmentData");
static_assert(offsetof(K25SurvivorChainAttachmentAnchor_GetChainAttachmentData, ReturnValue) == 0x000000, "Member 'K25SurvivorChainAttachmentAnchor_GetChainAttachmentData::ReturnValue' has a wrong offset!");

// Function TheK25.K25SurvivorChainAttachmentAnchor.GetChainAttachmentLocation
// 0x0018 (0x0018 - 0x0000)
struct K25SurvivorChainAttachmentAnchor_GetChainAttachmentLocation final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25SurvivorChainAttachmentAnchor_GetChainAttachmentLocation) == 0x000008, "Wrong alignment on K25SurvivorChainAttachmentAnchor_GetChainAttachmentLocation");
static_assert(sizeof(K25SurvivorChainAttachmentAnchor_GetChainAttachmentLocation) == 0x000018, "Wrong size on K25SurvivorChainAttachmentAnchor_GetChainAttachmentLocation");
static_assert(offsetof(K25SurvivorChainAttachmentAnchor_GetChainAttachmentLocation, ReturnValue) == 0x000000, "Member 'K25SurvivorChainAttachmentAnchor_GetChainAttachmentLocation::ReturnValue' has a wrong offset!");

// Function TheK25.K25SurvivorChainAttachmentAnchor.GetChainPullDirectionAngle
// 0x0004 (0x0004 - 0x0000)
struct K25SurvivorChainAttachmentAnchor_GetChainPullDirectionAngle final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25SurvivorChainAttachmentAnchor_GetChainPullDirectionAngle) == 0x000004, "Wrong alignment on K25SurvivorChainAttachmentAnchor_GetChainPullDirectionAngle");
static_assert(sizeof(K25SurvivorChainAttachmentAnchor_GetChainPullDirectionAngle) == 0x000004, "Wrong size on K25SurvivorChainAttachmentAnchor_GetChainPullDirectionAngle");
static_assert(offsetof(K25SurvivorChainAttachmentAnchor_GetChainPullDirectionAngle, ReturnValue) == 0x000000, "Member 'K25SurvivorChainAttachmentAnchor_GetChainPullDirectionAngle::ReturnValue' has a wrong offset!");

// Function TheK25.K25SurvivorChainAttachmentAnchor.GetChainsPullDirection
// 0x0018 (0x0018 - 0x0000)
struct K25SurvivorChainAttachmentAnchor_GetChainsPullDirection final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25SurvivorChainAttachmentAnchor_GetChainsPullDirection) == 0x000008, "Wrong alignment on K25SurvivorChainAttachmentAnchor_GetChainsPullDirection");
static_assert(sizeof(K25SurvivorChainAttachmentAnchor_GetChainsPullDirection) == 0x000018, "Wrong size on K25SurvivorChainAttachmentAnchor_GetChainsPullDirection");
static_assert(offsetof(K25SurvivorChainAttachmentAnchor_GetChainsPullDirection, ReturnValue) == 0x000000, "Member 'K25SurvivorChainAttachmentAnchor_GetChainsPullDirection::ReturnValue' has a wrong offset!");

// Function TheK25.K25SurvivorChainAttachmentAnchor.GetChainsPullLocation
// 0x0018 (0x0018 - 0x0000)
struct K25SurvivorChainAttachmentAnchor_GetChainsPullLocation final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25SurvivorChainAttachmentAnchor_GetChainsPullLocation) == 0x000008, "Wrong alignment on K25SurvivorChainAttachmentAnchor_GetChainsPullLocation");
static_assert(sizeof(K25SurvivorChainAttachmentAnchor_GetChainsPullLocation) == 0x000018, "Wrong size on K25SurvivorChainAttachmentAnchor_GetChainsPullLocation");
static_assert(offsetof(K25SurvivorChainAttachmentAnchor_GetChainsPullLocation, ReturnValue) == 0x000000, "Member 'K25SurvivorChainAttachmentAnchor_GetChainsPullLocation::ReturnValue' has a wrong offset!");

// Function TheK25.K25SurvivorChainAttachmentAnchor.GetNumberOfChainsAttached
// 0x0004 (0x0004 - 0x0000)
struct K25SurvivorChainAttachmentAnchor_GetNumberOfChainsAttached final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25SurvivorChainAttachmentAnchor_GetNumberOfChainsAttached) == 0x000004, "Wrong alignment on K25SurvivorChainAttachmentAnchor_GetNumberOfChainsAttached");
static_assert(sizeof(K25SurvivorChainAttachmentAnchor_GetNumberOfChainsAttached) == 0x000004, "Wrong size on K25SurvivorChainAttachmentAnchor_GetNumberOfChainsAttached");
static_assert(offsetof(K25SurvivorChainAttachmentAnchor_GetNumberOfChainsAttached, ReturnValue) == 0x000000, "Member 'K25SurvivorChainAttachmentAnchor_GetNumberOfChainsAttached::ReturnValue' has a wrong offset!");

// Function TheK25.K25SurvivorChainAttachmentComponent.Cosmetic_TriggerHitSurvivorInExitAreaSFX
// 0x0008 (0x0008 - 0x0000)
struct K25SurvivorChainAttachmentComponent_Cosmetic_TriggerHitSurvivorInExitAreaSFX final
{
public:
	class ASlasherPlayer*                         Killer;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25SurvivorChainAttachmentComponent_Cosmetic_TriggerHitSurvivorInExitAreaSFX) == 0x000008, "Wrong alignment on K25SurvivorChainAttachmentComponent_Cosmetic_TriggerHitSurvivorInExitAreaSFX");
static_assert(sizeof(K25SurvivorChainAttachmentComponent_Cosmetic_TriggerHitSurvivorInExitAreaSFX) == 0x000008, "Wrong size on K25SurvivorChainAttachmentComponent_Cosmetic_TriggerHitSurvivorInExitAreaSFX");
static_assert(offsetof(K25SurvivorChainAttachmentComponent_Cosmetic_TriggerHitSurvivorInExitAreaSFX, Killer) == 0x000000, "Member 'K25SurvivorChainAttachmentComponent_Cosmetic_TriggerHitSurvivorInExitAreaSFX::Killer' has a wrong offset!");

// Function TheK25.K25SurvivorChainAttachmentComponent.Multicast_TriggerHitSurvivorInExitAreaSFX
// 0x0008 (0x0008 - 0x0000)
struct K25SurvivorChainAttachmentComponent_Multicast_TriggerHitSurvivorInExitAreaSFX final
{
public:
	class ASlasherPlayer*                         Killer;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25SurvivorChainAttachmentComponent_Multicast_TriggerHitSurvivorInExitAreaSFX) == 0x000008, "Wrong alignment on K25SurvivorChainAttachmentComponent_Multicast_TriggerHitSurvivorInExitAreaSFX");
static_assert(sizeof(K25SurvivorChainAttachmentComponent_Multicast_TriggerHitSurvivorInExitAreaSFX) == 0x000008, "Wrong size on K25SurvivorChainAttachmentComponent_Multicast_TriggerHitSurvivorInExitAreaSFX");
static_assert(offsetof(K25SurvivorChainAttachmentComponent_Multicast_TriggerHitSurvivorInExitAreaSFX, Killer) == 0x000000, "Member 'K25SurvivorChainAttachmentComponent_Multicast_TriggerHitSurvivorInExitAreaSFX::Killer' has a wrong offset!");

// Function TheK25.K25SurvivorChainAttachmentComponent.GetFirstChainToRelease
// 0x0008 (0x0008 - 0x0000)
struct K25SurvivorChainAttachmentComponent_GetFirstChainToRelease final
{
public:
	class AK25Chain*                              ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25SurvivorChainAttachmentComponent_GetFirstChainToRelease) == 0x000008, "Wrong alignment on K25SurvivorChainAttachmentComponent_GetFirstChainToRelease");
static_assert(sizeof(K25SurvivorChainAttachmentComponent_GetFirstChainToRelease) == 0x000008, "Wrong size on K25SurvivorChainAttachmentComponent_GetFirstChainToRelease");
static_assert(offsetof(K25SurvivorChainAttachmentComponent_GetFirstChainToRelease, ReturnValue) == 0x000000, "Member 'K25SurvivorChainAttachmentComponent_GetFirstChainToRelease::ReturnValue' has a wrong offset!");

// Function TheK25.K25SurvivorChainHuntEffectsComponent.GetOwningSurvivor
// 0x0008 (0x0008 - 0x0000)
struct K25SurvivorChainHuntEffectsComponent_GetOwningSurvivor final
{
public:
	class ACamperPlayer*                          ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25SurvivorChainHuntEffectsComponent_GetOwningSurvivor) == 0x000008, "Wrong alignment on K25SurvivorChainHuntEffectsComponent_GetOwningSurvivor");
static_assert(sizeof(K25SurvivorChainHuntEffectsComponent_GetOwningSurvivor) == 0x000008, "Wrong size on K25SurvivorChainHuntEffectsComponent_GetOwningSurvivor");
static_assert(offsetof(K25SurvivorChainHuntEffectsComponent_GetOwningSurvivor, ReturnValue) == 0x000000, "Member 'K25SurvivorChainHuntEffectsComponent_GetOwningSurvivor::ReturnValue' has a wrong offset!");

// Function TheK25.K25SurvivorChainTargetterComponent.Authority_OnSurvivorHealthStateChanged
// 0x0002 (0x0002 - 0x0000)
struct K25SurvivorChainTargetterComponent_Authority_OnSurvivorHealthStateChanged final
{
public:
	ECamperDamageState                            OldDamageState;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECamperDamageState                            CurrentDamageState;                                // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25SurvivorChainTargetterComponent_Authority_OnSurvivorHealthStateChanged) == 0x000001, "Wrong alignment on K25SurvivorChainTargetterComponent_Authority_OnSurvivorHealthStateChanged");
static_assert(sizeof(K25SurvivorChainTargetterComponent_Authority_OnSurvivorHealthStateChanged) == 0x000002, "Wrong size on K25SurvivorChainTargetterComponent_Authority_OnSurvivorHealthStateChanged");
static_assert(offsetof(K25SurvivorChainTargetterComponent_Authority_OnSurvivorHealthStateChanged, OldDamageState) == 0x000000, "Member 'K25SurvivorChainTargetterComponent_Authority_OnSurvivorHealthStateChanged::OldDamageState' has a wrong offset!");
static_assert(offsetof(K25SurvivorChainTargetterComponent_Authority_OnSurvivorHealthStateChanged, CurrentDamageState) == 0x000001, "Member 'K25SurvivorChainTargetterComponent_Authority_OnSurvivorHealthStateChanged::CurrentDamageState' has a wrong offset!");

// Function TheK25.K25SurvivorChainTargetterComponent.Multicast_DebugPositionFind
// 0x0070 (0x0070 - 0x0000)
struct K25SurvivorChainTargetterComponent_Multicast_DebugPositionFind final
{
public:
	struct FVector                                StartSweepPosition;                                // 0x0000(0x0018)(ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                EndSweepPosition;                                  // 0x0018(0x0018)(ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasFoundPosition;                                  // 0x0030(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                FoundPosition;                                     // 0x0038(0x0018)(ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasFoundCollision;                                 // 0x0050(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                CollisionPosition;                                 // 0x0058(0x0018)(ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25SurvivorChainTargetterComponent_Multicast_DebugPositionFind) == 0x000008, "Wrong alignment on K25SurvivorChainTargetterComponent_Multicast_DebugPositionFind");
static_assert(sizeof(K25SurvivorChainTargetterComponent_Multicast_DebugPositionFind) == 0x000070, "Wrong size on K25SurvivorChainTargetterComponent_Multicast_DebugPositionFind");
static_assert(offsetof(K25SurvivorChainTargetterComponent_Multicast_DebugPositionFind, StartSweepPosition) == 0x000000, "Member 'K25SurvivorChainTargetterComponent_Multicast_DebugPositionFind::StartSweepPosition' has a wrong offset!");
static_assert(offsetof(K25SurvivorChainTargetterComponent_Multicast_DebugPositionFind, EndSweepPosition) == 0x000018, "Member 'K25SurvivorChainTargetterComponent_Multicast_DebugPositionFind::EndSweepPosition' has a wrong offset!");
static_assert(offsetof(K25SurvivorChainTargetterComponent_Multicast_DebugPositionFind, HasFoundPosition) == 0x000030, "Member 'K25SurvivorChainTargetterComponent_Multicast_DebugPositionFind::HasFoundPosition' has a wrong offset!");
static_assert(offsetof(K25SurvivorChainTargetterComponent_Multicast_DebugPositionFind, FoundPosition) == 0x000038, "Member 'K25SurvivorChainTargetterComponent_Multicast_DebugPositionFind::FoundPosition' has a wrong offset!");
static_assert(offsetof(K25SurvivorChainTargetterComponent_Multicast_DebugPositionFind, HasFoundCollision) == 0x000050, "Member 'K25SurvivorChainTargetterComponent_Multicast_DebugPositionFind::HasFoundCollision' has a wrong offset!");
static_assert(offsetof(K25SurvivorChainTargetterComponent_Multicast_DebugPositionFind, CollisionPosition) == 0x000058, "Member 'K25SurvivorChainTargetterComponent_Multicast_DebugPositionFind::CollisionPosition' has a wrong offset!");

// Function TheK25.K25TeleportInteraction.Cosmetic_TeleportAbortedEffects
// 0x0008 (0x0008 - 0x0000)
struct K25TeleportInteraction_Cosmetic_TeleportAbortedEffects final
{
public:
	class ASlasherPlayer*                         Killer;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25TeleportInteraction_Cosmetic_TeleportAbortedEffects) == 0x000008, "Wrong alignment on K25TeleportInteraction_Cosmetic_TeleportAbortedEffects");
static_assert(sizeof(K25TeleportInteraction_Cosmetic_TeleportAbortedEffects) == 0x000008, "Wrong size on K25TeleportInteraction_Cosmetic_TeleportAbortedEffects");
static_assert(offsetof(K25TeleportInteraction_Cosmetic_TeleportAbortedEffects, Killer) == 0x000000, "Member 'K25TeleportInteraction_Cosmetic_TeleportAbortedEffects::Killer' has a wrong offset!");

// Function TheK25.K25TeleportInteraction.Cosmetic_TeleportEndEffects
// 0x0008 (0x0008 - 0x0000)
struct K25TeleportInteraction_Cosmetic_TeleportEndEffects final
{
public:
	class ASlasherPlayer*                         Killer;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25TeleportInteraction_Cosmetic_TeleportEndEffects) == 0x000008, "Wrong alignment on K25TeleportInteraction_Cosmetic_TeleportEndEffects");
static_assert(sizeof(K25TeleportInteraction_Cosmetic_TeleportEndEffects) == 0x000008, "Wrong size on K25TeleportInteraction_Cosmetic_TeleportEndEffects");
static_assert(offsetof(K25TeleportInteraction_Cosmetic_TeleportEndEffects, Killer) == 0x000000, "Member 'K25TeleportInteraction_Cosmetic_TeleportEndEffects::Killer' has a wrong offset!");

// Function TheK25.K25TeleportInteraction.Cosmetic_TeleportStartEffects
// 0x0008 (0x0008 - 0x0000)
struct K25TeleportInteraction_Cosmetic_TeleportStartEffects final
{
public:
	class ASlasherPlayer*                         Killer;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25TeleportInteraction_Cosmetic_TeleportStartEffects) == 0x000008, "Wrong alignment on K25TeleportInteraction_Cosmetic_TeleportStartEffects");
static_assert(sizeof(K25TeleportInteraction_Cosmetic_TeleportStartEffects) == 0x000008, "Wrong size on K25TeleportInteraction_Cosmetic_TeleportStartEffects");
static_assert(offsetof(K25TeleportInteraction_Cosmetic_TeleportStartEffects, Killer) == 0x000000, "Member 'K25TeleportInteraction_Cosmetic_TeleportStartEffects::Killer' has a wrong offset!");

// Function TheK25.K25TeleportInteraction.Multicast_InitializeHusk
// 0x0030 (0x0030 - 0x0000)
struct K25TeleportInteraction_Multicast_InitializeHusk final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0018(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25TeleportInteraction_Multicast_InitializeHusk) == 0x000008, "Wrong alignment on K25TeleportInteraction_Multicast_InitializeHusk");
static_assert(sizeof(K25TeleportInteraction_Multicast_InitializeHusk) == 0x000030, "Wrong size on K25TeleportInteraction_Multicast_InitializeHusk");
static_assert(offsetof(K25TeleportInteraction_Multicast_InitializeHusk, Location) == 0x000000, "Member 'K25TeleportInteraction_Multicast_InitializeHusk::Location' has a wrong offset!");
static_assert(offsetof(K25TeleportInteraction_Multicast_InitializeHusk, Rotation) == 0x000018, "Member 'K25TeleportInteraction_Multicast_InitializeHusk::Rotation' has a wrong offset!");

// Function TheK25.K25TeleportInteraction.Multicast_TeleportKillerToTargetPosition
// 0x0038 (0x0038 - 0x0000)
struct K25TeleportInteraction_Multicast_TeleportKillerToTargetPosition final
{
public:
	class ASlasherPlayer*                         Killer;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0008(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0020(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25TeleportInteraction_Multicast_TeleportKillerToTargetPosition) == 0x000008, "Wrong alignment on K25TeleportInteraction_Multicast_TeleportKillerToTargetPosition");
static_assert(sizeof(K25TeleportInteraction_Multicast_TeleportKillerToTargetPosition) == 0x000038, "Wrong size on K25TeleportInteraction_Multicast_TeleportKillerToTargetPosition");
static_assert(offsetof(K25TeleportInteraction_Multicast_TeleportKillerToTargetPosition, Killer) == 0x000000, "Member 'K25TeleportInteraction_Multicast_TeleportKillerToTargetPosition::Killer' has a wrong offset!");
static_assert(offsetof(K25TeleportInteraction_Multicast_TeleportKillerToTargetPosition, Location) == 0x000008, "Member 'K25TeleportInteraction_Multicast_TeleportKillerToTargetPosition::Location' has a wrong offset!");
static_assert(offsetof(K25TeleportInteraction_Multicast_TeleportKillerToTargetPosition, Rotation) == 0x000020, "Member 'K25TeleportInteraction_Multicast_TeleportKillerToTargetPosition::Rotation' has a wrong offset!");

// Function TheK25.K25WeaponAnimInstance.OnAttackStart
// 0x0001 (0x0001 - 0x0000)
struct K25WeaponAnimInstance_OnAttackStart final
{
public:
	EAttackType                                   AttackType;                                        // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25WeaponAnimInstance_OnAttackStart) == 0x000001, "Wrong alignment on K25WeaponAnimInstance_OnAttackStart");
static_assert(sizeof(K25WeaponAnimInstance_OnAttackStart) == 0x000001, "Wrong size on K25WeaponAnimInstance_OnAttackStart");
static_assert(offsetof(K25WeaponAnimInstance_OnAttackStart, AttackType) == 0x000000, "Member 'K25WeaponAnimInstance_OnAttackStart::AttackType' has a wrong offset!");

}

