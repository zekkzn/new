#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Projectile

#include "Basic.hpp"

#include "GameplayTags_structs.hpp"
#include "Engine_classes.hpp"
#include "Projectile_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"


namespace SDK
{

// Class Projectile.SingleProjectileProviderComponent
// 0x0030 (0x00D8 - 0x00A8)
class USingleProjectileProviderComponent : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ABaseProjectile>            _projectileClass;                                  // 0x00B0(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABaseProjectile*                        _projectile;                                       // 0x00B8(0x0008)(Net, ZeroConstructor, Transient, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C0[0x18];                                      // 0x00C0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_Projectile();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SingleProjectileProviderComponent">();
	}
	static class USingleProjectileProviderComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USingleProjectileProviderComponent>();
	}
};
static_assert(alignof(USingleProjectileProviderComponent) == 0x000008, "Wrong alignment on USingleProjectileProviderComponent");
static_assert(sizeof(USingleProjectileProviderComponent) == 0x0000D8, "Wrong size on USingleProjectileProviderComponent");
static_assert(offsetof(USingleProjectileProviderComponent, _projectileClass) == 0x0000B0, "Member 'USingleProjectileProviderComponent::_projectileClass' has a wrong offset!");
static_assert(offsetof(USingleProjectileProviderComponent, _projectile) == 0x0000B8, "Member 'USingleProjectileProviderComponent::_projectile' has a wrong offset!");

// Class Projectile.BaseProjectileLauncher
// 0x00F0 (0x0198 - 0x00A8)
class UBaseProjectileLauncher : public UActorComponent
{
public:
	struct FGameplayTag                           IsOutOfAmmoTag;                                    // 0x00A8(0x000C)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B4[0x34];                                      // 0x00B4(0x0034)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _requireLaunchImpactDetection;                     // 0x00E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _hasInfiniteAmmunition;                            // 0x00E9(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_EA[0x6];                                       // 0x00EA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ABaseProjectile>            ProjectileClass;                                   // 0x00F0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         _ammo;                                             // 0x00F8(0x0004)(Edit, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         _maxAmmo;                                          // 0x00FC(0x0004)(Edit, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _canLaunchWhileOutOfAmmo;                          // 0x0100(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_101[0x2F];                                     // 0x0101(0x002F)(Fixing Size After Last Property [ Dumper-7 ])
	class ABaseProjectile*                        _debugProjectile;                                  // 0x0130(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_138[0x58];                                     // 0x0138(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	class UBaseProjectileReplicationComponent*    _projectileReplicationComponent;                   // 0x0190(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Authority_AddMaxAmmo(int32 AmmoToAdd);
	void Authority_Launch();
	void Authority_Reload();
	void Authority_ReturnAmmoUnits(int32 AmountOfAmmoUnitsReturned);
	void Authority_SetMaxAmmo(int32 NewMaxAmmo, bool IsMaxAmmoImmutable);
	void Cosmetic_OnOutOfAmmo();
	void Local_Launch();
	void OnLaunch(const struct FLaunchInfo& LaunchInfo, class ABaseProjectile* Projectile);
	void OnRep_Ammo(int32 OldAmmo);
	void OnRep_MaxAmmo(int32 OldMaxAmmo);
	void Server_Launch(const struct FLaunchInfo& LaunchInfo, class ABaseProjectile* Projectile);
	void Server_LaunchWithImpact(const struct FLaunchInfo& LaunchInfo, const struct FImpactInfo& ImpactInfo, class ABaseProjectile* Projectile);
	void SetProjectileProvider(TScriptInterface<class IProjectileProvider> ProjectileProvider);
	void SetProjectileVar(class FName VarName, float Value);

	int32 GetAmmo() const;
	struct FVector GetLaunchDirection() const;
	struct FVector GetLaunchDirectionAtViewAndThrowPowerRatio(const struct FRotator& ViewRotation, float ThrowPowerRatio) const;
	struct FVector GetLaunchPosition() const;
	float GetLaunchSpeed() const;
	float GetLaunchSpeedAtThrowPowerRatio(float ThrowPowerRatio) const;
	class APawn* GetOwningPawn() const;
	class ABaseProjectile* GetProjectileToLaunch() const;
	bool HasAuthority() const;
	bool HasProjectile() const;
	bool IsAmmoFull() const;
	bool IsLocallyControlled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseProjectileLauncher">();
	}
	static class UBaseProjectileLauncher* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseProjectileLauncher>();
	}
};
static_assert(alignof(UBaseProjectileLauncher) == 0x000008, "Wrong alignment on UBaseProjectileLauncher");
static_assert(sizeof(UBaseProjectileLauncher) == 0x000198, "Wrong size on UBaseProjectileLauncher");
static_assert(offsetof(UBaseProjectileLauncher, IsOutOfAmmoTag) == 0x0000A8, "Member 'UBaseProjectileLauncher::IsOutOfAmmoTag' has a wrong offset!");
static_assert(offsetof(UBaseProjectileLauncher, _requireLaunchImpactDetection) == 0x0000E8, "Member 'UBaseProjectileLauncher::_requireLaunchImpactDetection' has a wrong offset!");
static_assert(offsetof(UBaseProjectileLauncher, _hasInfiniteAmmunition) == 0x0000E9, "Member 'UBaseProjectileLauncher::_hasInfiniteAmmunition' has a wrong offset!");
static_assert(offsetof(UBaseProjectileLauncher, ProjectileClass) == 0x0000F0, "Member 'UBaseProjectileLauncher::ProjectileClass' has a wrong offset!");
static_assert(offsetof(UBaseProjectileLauncher, _ammo) == 0x0000F8, "Member 'UBaseProjectileLauncher::_ammo' has a wrong offset!");
static_assert(offsetof(UBaseProjectileLauncher, _maxAmmo) == 0x0000FC, "Member 'UBaseProjectileLauncher::_maxAmmo' has a wrong offset!");
static_assert(offsetof(UBaseProjectileLauncher, _canLaunchWhileOutOfAmmo) == 0x000100, "Member 'UBaseProjectileLauncher::_canLaunchWhileOutOfAmmo' has a wrong offset!");
static_assert(offsetof(UBaseProjectileLauncher, _debugProjectile) == 0x000130, "Member 'UBaseProjectileLauncher::_debugProjectile' has a wrong offset!");
static_assert(offsetof(UBaseProjectileLauncher, _projectileReplicationComponent) == 0x000190, "Member 'UBaseProjectileLauncher::_projectileReplicationComponent' has a wrong offset!");

// Class Projectile.ProjectileProvider
// 0x0000 (0x0030 - 0x0030)
class IProjectileProvider final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProjectileProvider">();
	}
	static class IProjectileProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<IProjectileProvider>();
	}
};
static_assert(alignof(IProjectileProvider) == 0x000008, "Wrong alignment on IProjectileProvider");
static_assert(sizeof(IProjectileProvider) == 0x000030, "Wrong size on IProjectileProvider");

// Class Projectile.DBDProjectileMovementComponent
// 0x0090 (0x02E0 - 0x0250)
class UDBDProjectileMovementComponent : public UProjectileMovementComponent
{
public:
	uint8                                         Pad_250[0x10];                                     // 0x0250(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnComponentToSweepCollisionBP;                     // 0x0260(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_270[0x18];                                     // 0x0270(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FComponentSweepInfo>            _componentsToSweep;                                // 0x0288(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	struct FVector                                _previousPosition;                                 // 0x0298(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USceneComponent*                        _cachedUpdatedComponent;                           // 0x02B0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                _initialLocation;                                  // 0x02B8(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _distanceTravelled;                                // 0x02D0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _hasMaximumDistance;                               // 0x02D4(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D5[0x3];                                      // 0x02D5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _maximumTravelDistance;                            // 0x02D8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2DC[0x4];                                      // 0x02DC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddComponentToSweep(class UPrimitiveComponent* Component);
	void OnComponentToSweepCollisionBP__DelegateSignature(class UPrimitiveComponent* PrimitiveComponent, const struct FHitResult& HitResult);

	const struct FVector GetPreviousLocation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDProjectileMovementComponent">();
	}
	static class UDBDProjectileMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDProjectileMovementComponent>();
	}
};
static_assert(alignof(UDBDProjectileMovementComponent) == 0x000010, "Wrong alignment on UDBDProjectileMovementComponent");
static_assert(sizeof(UDBDProjectileMovementComponent) == 0x0002E0, "Wrong size on UDBDProjectileMovementComponent");
static_assert(offsetof(UDBDProjectileMovementComponent, OnComponentToSweepCollisionBP) == 0x000260, "Member 'UDBDProjectileMovementComponent::OnComponentToSweepCollisionBP' has a wrong offset!");
static_assert(offsetof(UDBDProjectileMovementComponent, _componentsToSweep) == 0x000288, "Member 'UDBDProjectileMovementComponent::_componentsToSweep' has a wrong offset!");
static_assert(offsetof(UDBDProjectileMovementComponent, _previousPosition) == 0x000298, "Member 'UDBDProjectileMovementComponent::_previousPosition' has a wrong offset!");
static_assert(offsetof(UDBDProjectileMovementComponent, _cachedUpdatedComponent) == 0x0002B0, "Member 'UDBDProjectileMovementComponent::_cachedUpdatedComponent' has a wrong offset!");
static_assert(offsetof(UDBDProjectileMovementComponent, _initialLocation) == 0x0002B8, "Member 'UDBDProjectileMovementComponent::_initialLocation' has a wrong offset!");
static_assert(offsetof(UDBDProjectileMovementComponent, _distanceTravelled) == 0x0002D0, "Member 'UDBDProjectileMovementComponent::_distanceTravelled' has a wrong offset!");
static_assert(offsetof(UDBDProjectileMovementComponent, _hasMaximumDistance) == 0x0002D4, "Member 'UDBDProjectileMovementComponent::_hasMaximumDistance' has a wrong offset!");
static_assert(offsetof(UDBDProjectileMovementComponent, _maximumTravelDistance) == 0x0002D8, "Member 'UDBDProjectileMovementComponent::_maximumTravelDistance' has a wrong offset!");

// Class Projectile.PhysicsBasedProjectileMovementComponent
// 0x0000 (0x02E0 - 0x02E0)
class UPhysicsBasedProjectileMovementComponent : public UDBDProjectileMovementComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PhysicsBasedProjectileMovementComponent">();
	}
	static class UPhysicsBasedProjectileMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPhysicsBasedProjectileMovementComponent>();
	}
};
static_assert(alignof(UPhysicsBasedProjectileMovementComponent) == 0x000010, "Wrong alignment on UPhysicsBasedProjectileMovementComponent");
static_assert(sizeof(UPhysicsBasedProjectileMovementComponent) == 0x0002E0, "Wrong size on UPhysicsBasedProjectileMovementComponent");

// Class Projectile.BaseProjectile
// 0x0080 (0x0320 - 0x02A0)
class ABaseProjectile : public AActor
{
public:
	float                                         OnImpactAINoiseEventRange;                         // 0x02A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A4[0x44];                                     // 0x02A4(0x0044)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _multicastLaunch;                                  // 0x02E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _allowMultipleHits;                                // 0x02E9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2EA[0x6];                                      // 0x02EA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  _semanticGameplayTags;                             // 0x02F0(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          _notifyClientOfServerHitValidationResult;          // 0x0310(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_311[0x7];                                      // 0x0311(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBaseProjectileReplicationComponent*    _replicationComponent;                             // 0x0318(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	bool Authority_TryDetectCollision(const struct FImpactInfo& ImpactInfo, bool Force);
	bool IsValidImpactDetection(const struct FImpactInfo& ImpactInfo);
	bool IsValidPlayerDetection(const struct FImpactInfo& ImpactInfo);
	bool Local_OnPlayerDetected(const struct FImpactInfo& ImpactInfo, const struct FVector& ProjectileLocation);
	bool Local_SweepImpactCollision(const struct FVector& Start, const struct FVector& End, const struct FRotator& ColliderRotation, struct FHitResult* OutHit);
	bool Local_TryDetectCollision(const struct FImpactInfo& ImpactInfo, bool Force);
	void OnDetectCollision(const struct FImpactInfo& ImpactInfo);
	void OnDetectPlayer(const struct FImpactInfo& ImpactInfo);
	void OnLaunch(const struct FLaunchInfo& LaunchInfo, bool HasImpactOnLaunch);
	void OnSetActive(const bool Active);

	float GetAddLauncherVeloctyFactor() const;
	class UPrimitiveComponent* GetImpactPrimitiveComponent() const;
	class UBaseProjectileLauncher* GetLauncher() const;
	bool IsOwningPawnLocallyControlled() const;
	bool SphereTraceSingle(const struct FVector& Start, const struct FVector& End, class USphereComponent* Sphere, struct FHitResult* OutHitResult) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseProjectile">();
	}
	static class ABaseProjectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABaseProjectile>();
	}
};
static_assert(alignof(ABaseProjectile) == 0x000008, "Wrong alignment on ABaseProjectile");
static_assert(sizeof(ABaseProjectile) == 0x000320, "Wrong size on ABaseProjectile");
static_assert(offsetof(ABaseProjectile, OnImpactAINoiseEventRange) == 0x0002A0, "Member 'ABaseProjectile::OnImpactAINoiseEventRange' has a wrong offset!");
static_assert(offsetof(ABaseProjectile, _multicastLaunch) == 0x0002E8, "Member 'ABaseProjectile::_multicastLaunch' has a wrong offset!");
static_assert(offsetof(ABaseProjectile, _allowMultipleHits) == 0x0002E9, "Member 'ABaseProjectile::_allowMultipleHits' has a wrong offset!");
static_assert(offsetof(ABaseProjectile, _semanticGameplayTags) == 0x0002F0, "Member 'ABaseProjectile::_semanticGameplayTags' has a wrong offset!");
static_assert(offsetof(ABaseProjectile, _notifyClientOfServerHitValidationResult) == 0x000310, "Member 'ABaseProjectile::_notifyClientOfServerHitValidationResult' has a wrong offset!");
static_assert(offsetof(ABaseProjectile, _replicationComponent) == 0x000318, "Member 'ABaseProjectile::_replicationComponent' has a wrong offset!");

// Class Projectile.PhysicsBasedProjectile
// 0x0008 (0x0328 - 0x0320)
class APhysicsBasedProjectile : public ABaseProjectile
{
public:
	class UPhysicsBasedProjectileMovementComponent* Movement;                                          // 0x0320(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PhysicsBasedProjectile">();
	}
	static class APhysicsBasedProjectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<APhysicsBasedProjectile>();
	}
};
static_assert(alignof(APhysicsBasedProjectile) == 0x000008, "Wrong alignment on APhysicsBasedProjectile");
static_assert(sizeof(APhysicsBasedProjectile) == 0x000328, "Wrong size on APhysicsBasedProjectile");
static_assert(offsetof(APhysicsBasedProjectile, Movement) == 0x000320, "Member 'APhysicsBasedProjectile::Movement' has a wrong offset!");

// Class Projectile.AuthoritativePoolProjectileProviderAdapter
// 0x0010 (0x0040 - 0x0030)
class UAuthoritativePoolProjectileProviderAdapter final : public UObject
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAuthoritativeActorPoolComponent*       _pool;                                             // 0x0038(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Init(class UAuthoritativeActorPoolComponent* Pool);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AuthoritativePoolProjectileProviderAdapter">();
	}
	static class UAuthoritativePoolProjectileProviderAdapter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAuthoritativePoolProjectileProviderAdapter>();
	}
};
static_assert(alignof(UAuthoritativePoolProjectileProviderAdapter) == 0x000008, "Wrong alignment on UAuthoritativePoolProjectileProviderAdapter");
static_assert(sizeof(UAuthoritativePoolProjectileProviderAdapter) == 0x000040, "Wrong size on UAuthoritativePoolProjectileProviderAdapter");
static_assert(offsetof(UAuthoritativePoolProjectileProviderAdapter, _pool) == 0x000038, "Member 'UAuthoritativePoolProjectileProviderAdapter::_pool' has a wrong offset!");

// Class Projectile.BaseProjectileReplicationComponent
// 0x0000 (0x00A8 - 0x00A8)
class UBaseProjectileReplicationComponent : public UActorComponent
{
public:
	void Client_LaunchRefusedByServer(class ABaseProjectile* Projectile);
	void Client_ReceiveDetectPlayerValidation(class ABaseProjectile* Projectile, bool Success);
	void Multicast_DetectImpact(class ABaseProjectile* Projectile, const struct FImpactInfo& ImpactInfo);
	void Multicast_DetectPlayer(class ABaseProjectile* Projectile, const struct FImpactInfo& ImpactInfo);
	void Multicast_OnLaunch(class ABaseProjectile* Projectile, const struct FLaunchInfo& LaunchInfo);
	void Multicast_OnLaunchWithImpact(class ABaseProjectile* Projectile, const struct FLaunchInfo& LaunchInfo, const struct FImpactInfo& ImpactInfo);
	void Multicast_SendAuthorityDetectPlayer(class ABaseProjectile* Projectile, const struct FImpactInfo& ImpactInfo);
	void Server_TryDetectPlayer(class ABaseProjectile* Projectile, const struct FImpactInfo& ImpactInfo, const struct FVector_NetQuantize100& ProjectileLocation, const struct FVector_NetQuantize10& ProjectileRotation, const float TargetLocationTimestamp);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseProjectileReplicationComponent">();
	}
	static class UBaseProjectileReplicationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseProjectileReplicationComponent>();
	}
};
static_assert(alignof(UBaseProjectileReplicationComponent) == 0x000008, "Wrong alignment on UBaseProjectileReplicationComponent");
static_assert(sizeof(UBaseProjectileReplicationComponent) == 0x0000A8, "Wrong size on UBaseProjectileReplicationComponent");

}

