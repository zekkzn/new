#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: DeadByDaylight

#include "Basic.hpp"

#include "Projectile_classes.hpp"
#include "DBDSharedTypes_structs.hpp"
#include "Customization_structs.hpp"
#include "AIModule_structs.hpp"
#include "AIModule_classes.hpp"
#include "GameplayTags_structs.hpp"
#include "OnlineSubsystemUtils_classes.hpp"
#include "DeadByDaylight_structs.hpp"
#include "AnimationUtilities_structs.hpp"
#include "AnimationUtilities_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "StatSystem_structs.hpp"
#include "Activation_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "GameplayTagUtilities_structs.hpp"
#include "Competence_structs.hpp"
#include "Competence_classes.hpp"
#include "SocialParty_classes.hpp"
#include "DataTableUtilities_structs.hpp"
#include "PhysicsCore_structs.hpp"
#include "DBDUIViewInterfaces_structs.hpp"
#include "SlateCore_structs.hpp"
#include "DBDUIViewsMobile_classes.hpp"
#include "AkAudio_structs.hpp"
#include "AkAudio_classes.hpp"
#include "SystemUtilities_structs.hpp"
#include "SystemUtilities_classes.hpp"
#include "NetworkUtilities_structs.hpp"
#include "UMG_classes.hpp"
#include "NavigationSystem_classes.hpp"
#include "GFXUtilities_classes.hpp"
#include "VFXUtilities_classes.hpp"
#include "PlatformsProviders_structs.hpp"
#include "OnlinePresence_structs.hpp"
#include "SignificanceUtilities_classes.hpp"
#include "Slate_structs.hpp"
#include "DBDAnimationBudgetAllocator_classes.hpp"
#include "Niagara_structs.hpp"
#include "ReversibleActionSystem_classes.hpp"
#include "DBDAudio_classes.hpp"
#include "GameplayUtilities_classes.hpp"


namespace SDK
{

// Class DeadByDaylight.DBDAuthentication
// 0x0028 (0x0058 - 0x0030)
class UDBDAuthentication final : public UObject
{
public:
	TArray<struct FAuthenticationInfo>            _localInfos;                                       // 0x0030(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<struct FAuthenticationInfo>            _remoteInfos;                                      // 0x0040(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class UDBDGameInstance*                       _gameInstance;                                     // 0x0050(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDAuthentication">();
	}
	static class UDBDAuthentication* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDAuthentication>();
	}
};
static_assert(alignof(UDBDAuthentication) == 0x000008, "Wrong alignment on UDBDAuthentication");
static_assert(sizeof(UDBDAuthentication) == 0x000058, "Wrong size on UDBDAuthentication");
static_assert(offsetof(UDBDAuthentication, _localInfos) == 0x000030, "Member 'UDBDAuthentication::_localInfos' has a wrong offset!");
static_assert(offsetof(UDBDAuthentication, _remoteInfos) == 0x000040, "Member 'UDBDAuthentication::_remoteInfos' has a wrong offset!");
static_assert(offsetof(UDBDAuthentication, _gameInstance) == 0x000050, "Member 'UDBDAuthentication::_gameInstance' has a wrong offset!");

// Class DeadByDaylight.HudStateComponent
// 0x0038 (0x00E0 - 0x00A8)
class UHudStateComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x30];                                      // 0x00A8(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _isHudVisible;                                     // 0x00D8(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isSurvivorActivityHUDForciblyVisible;             // 0x00D9(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_DA[0x6];                                       // 0x00DA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_IsHudVisible(const bool OldValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HudStateComponent">();
	}
	static class UHudStateComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHudStateComponent>();
	}
};
static_assert(alignof(UHudStateComponent) == 0x000008, "Wrong alignment on UHudStateComponent");
static_assert(sizeof(UHudStateComponent) == 0x0000E0, "Wrong size on UHudStateComponent");
static_assert(offsetof(UHudStateComponent, _isHudVisible) == 0x0000D8, "Member 'UHudStateComponent::_isHudVisible' has a wrong offset!");
static_assert(offsetof(UHudStateComponent, _isSurvivorActivityHUDForciblyVisible) == 0x0000D9, "Member 'UHudStateComponent::_isSurvivorActivityHUDForciblyVisible' has a wrong offset!");

// Class DeadByDaylight.StoreCollectionsSubsystem
// 0x0030 (0x0068 - 0x0038)
class UStoreCollectionsSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x30];                                      // 0x0038(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StoreCollectionsSubsystem">();
	}
	static class UStoreCollectionsSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStoreCollectionsSubsystem>();
	}
};
static_assert(alignof(UStoreCollectionsSubsystem) == 0x000008, "Wrong alignment on UStoreCollectionsSubsystem");
static_assert(sizeof(UStoreCollectionsSubsystem) == 0x000068, "Wrong size on UStoreCollectionsSubsystem");

// Class DeadByDaylight.RestrictedPlacementAreaStrategy
// 0x0078 (0x00A8 - 0x0030)
class URestrictedPlacementAreaStrategy : public UObject
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   RestrictedRadius;                                  // 0x0040(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_68[0x4];                                       // 0x0068(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _useTunableForHeight;                              // 0x006C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6D[0x3];                                       // 0x006D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _maxHeightRestriction;                             // 0x0070(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _maxHeightRestrictionTunable;                      // 0x0078(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	bool                                          _shouldInitializeOnIntroCompleteInsteadOfLevelReadyToPlay; // 0x00A0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RestrictedPlacementAreaStrategy">();
	}
	static class URestrictedPlacementAreaStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<URestrictedPlacementAreaStrategy>();
	}
};
static_assert(alignof(URestrictedPlacementAreaStrategy) == 0x000008, "Wrong alignment on URestrictedPlacementAreaStrategy");
static_assert(sizeof(URestrictedPlacementAreaStrategy) == 0x0000A8, "Wrong size on URestrictedPlacementAreaStrategy");
static_assert(offsetof(URestrictedPlacementAreaStrategy, RestrictedRadius) == 0x000040, "Member 'URestrictedPlacementAreaStrategy::RestrictedRadius' has a wrong offset!");
static_assert(offsetof(URestrictedPlacementAreaStrategy, _useTunableForHeight) == 0x00006C, "Member 'URestrictedPlacementAreaStrategy::_useTunableForHeight' has a wrong offset!");
static_assert(offsetof(URestrictedPlacementAreaStrategy, _maxHeightRestriction) == 0x000070, "Member 'URestrictedPlacementAreaStrategy::_maxHeightRestriction' has a wrong offset!");
static_assert(offsetof(URestrictedPlacementAreaStrategy, _maxHeightRestrictionTunable) == 0x000078, "Member 'URestrictedPlacementAreaStrategy::_maxHeightRestrictionTunable' has a wrong offset!");
static_assert(offsetof(URestrictedPlacementAreaStrategy, _shouldInitializeOnIntroCompleteInsteadOfLevelReadyToPlay) == 0x0000A0, "Member 'URestrictedPlacementAreaStrategy::_shouldInitializeOnIntroCompleteInsteadOfLevelReadyToPlay' has a wrong offset!");

// Class DeadByDaylight.DBDPlayerControllerBase
// 0x00E8 (0x0948 - 0x0860)
class ADBDPlayerControllerBase : public APlayerController
{
public:
	uint8                                         Pad_860[0x58];                                     // 0x0860(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnPlayerStateChanged;                              // 0x08B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C8[0x40];                                     // 0x08C8(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 _EOSProductId;                                     // 0x0908(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_918[0x18];                                     // 0x0918(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class ADBDPlayer*                             _mainCharacter;                                    // 0x0930(0x0008)(Net, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_938[0x10];                                     // 0x0938(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Client(const class FString& CommandLine);
	void Client_CallConsoleCmdOnClient(const class FString& CommandLine);
	void Client_DisplayChatMessage(const class FString& ChatIdentifier, int32 PlayerIndex, const class FString& MirrorsId, const class FString& Msg);
	void Client_EACBeginSession();
	void Client_EACDestroySession();
	void Client_EACMessageFromServer(const TArray<uint8>& Message);
	void Client_FinishedPlaying();
	void Client_GameEnded();
	void Client_RequestPlayerProfile();
	void Client_SendLogs(const TArray<class FString>& Ensures);
	void Client_SendServerAuthentication(const class FString& AuthServerTicket, uint64 SteamId, uint32 TicketLength);
	void Client_SendWarning(bool PenaltyStarts, float Seconds);
	void DBD_BuildFromMap(const class FString& Map);
	void DBD_BuildFromPlayerCount(int32 Count);
	void DBD_BuildFromPremadeMap(const class FString& Map);
	void DBD_BuildFromSeed(int32 Seed);
	void DBD_BuildFromTile(int32 MatrixX, int32 MatrixY, int32 Rotation, const class FString& Param_Name);
	void DBD_DebugSendChatMessage(const class FString& Msg);
	void DBD_FillAllScoreCategories();
	void DBD_FillScoreCategory(int32 Category);
	void DBD_FireTestScore(int32 Category, float Value);
	void DBD_SetCurrentCharacterPrestigeDatesFuture();
	void DBD_SetCurrentCharacterPrestigeDatesNow();
	void DBD_SetCurrentCharacterPrestigeDatesPast();
	void DBD_UpdateLocalStats();
	void Server(const class FString& CommandLine);
	void Server_CallConsoleCmdOnServer(const class FString& CommandLine);
	void Server_EACMessageFromClient(const TArray<uint8>& Message);
	void Server_ReceivePlayerProfile(const struct FPlayerSavedProfileDataShared& SavedProfileData, const struct FPlayerLoadoutData& PlayerLoadout);
	void Server_SendClientAuthentication(const class FString& AuthClientTicket, uint64 SteamId, uint32 TicketLength);
	void Server_SendMessage(const class FString& Message);
	void Server_SetConsecutiveMatchStreak(int32 ConsecutiveMatch);
	void Server_SetPlayerCard(const class FString& badgeId, const class FString& bannerId);
	void Server_UpdateReplicatedPips(int32 PipsToAdd);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDPlayerControllerBase">();
	}
	static class ADBDPlayerControllerBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDPlayerControllerBase>();
	}
};
static_assert(alignof(ADBDPlayerControllerBase) == 0x000008, "Wrong alignment on ADBDPlayerControllerBase");
static_assert(sizeof(ADBDPlayerControllerBase) == 0x000948, "Wrong size on ADBDPlayerControllerBase");
static_assert(offsetof(ADBDPlayerControllerBase, OnPlayerStateChanged) == 0x0008B8, "Member 'ADBDPlayerControllerBase::OnPlayerStateChanged' has a wrong offset!");
static_assert(offsetof(ADBDPlayerControllerBase, _EOSProductId) == 0x000908, "Member 'ADBDPlayerControllerBase::_EOSProductId' has a wrong offset!");
static_assert(offsetof(ADBDPlayerControllerBase, _mainCharacter) == 0x000930, "Member 'ADBDPlayerControllerBase::_mainCharacter' has a wrong offset!");

// Class DeadByDaylight.DBDPlayerController_Menu
// 0x0000 (0x0948 - 0x0948)
class ADBDPlayerController_Menu final : public ADBDPlayerControllerBase
{
public:
	void Authority_SetPlayerReady(bool IsReady);
	void Authority_TogglePlayerReadyState();
	void Server_GamePresetDataFromClient(const struct FGamePresetData& GameState);
	void Server_SetCharacterData(int32 CharacterIndex, const struct FPlayerDataSync& PlayerDataSync);
	void Server_SetCharacterLevel(int32 CharacterLevel, int32 PrestigeLevel, bool CallOnRep);
	void Server_SetCustomizationCharm(class FName CharmId, int8 SlotIndex);
	void Server_SetCustomizationMeshes(const struct FCharacterCustomization& Customization);
	void Server_SetEquipedPerks(const TArray<class FName>& PerkIds, const TArray<int32>& PerkLevels, bool CallOnRep, bool AreRandomPerks);
	void Server_SetPlayerLoadout(const struct FPlayerLoadoutData& DesiredLoadout);
	void Server_SetPlayerReady(bool IsReady);
	void Server_SetReadyToTravel();
	void SetPlayerReady(bool IsReady);
	void TogglePlayerReadyState();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDPlayerController_Menu">();
	}
	static class ADBDPlayerController_Menu* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDPlayerController_Menu>();
	}
};
static_assert(alignof(ADBDPlayerController_Menu) == 0x000008, "Wrong alignment on ADBDPlayerController_Menu");
static_assert(sizeof(ADBDPlayerController_Menu) == 0x000948, "Wrong size on ADBDPlayerController_Menu");

// Class DeadByDaylight.GameplayModifierContainer
// 0x0160 (0x0248 - 0x00E8)
class UGameplayModifierContainer : public UBaseModifierContainer
{
public:
	uint8                                         Pad_E8[0x90];                                      // 0x00E8(0x0090)(Fixing Size After Last Property [ Dumper-7 ])
	struct FModifierTickableConditionReplicatedData _tickableConditionsData;                           // 0x0178(0x0018)(Net, Transient, RepNotify, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FOperationConditionsReplicatedData     _operationConditionsData;                          // 0x0190(0x0018)(Net, Transient, RepNotify, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class FName>                           _tags;                                             // 0x01A8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	bool                                          UseApplyFunction;                                  // 0x01B8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          BroadcastStatusView;                               // 0x01B9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1BA[0x2];                                      // 0x01BA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   StatusViewID;                                      // 0x01BC(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _autoInitializeOnBeginPlay;                        // 0x01C8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _canOptimizeTickActivation;                        // 0x01C9(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1CA[0x5E];                                     // 0x01CA(0x005E)(Fixing Size After Last Property [ Dumper-7 ])
	class UTimerObject*                           _activationTimer;                                  // 0x0228(0x0008)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_230[0x8];                                      // 0x0230(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UCompetenceOperation*>           _competenceOperations;                             // 0x0238(0x0010)(Edit, ExportObject, Net, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	void Apply(float DeltaTime);
	void Authority_ClearActivationTimer();
	void Authority_InstantiateGameplayModifierConditions();
	void Authority_SetActivationTimerPaused(const bool Paused);
	void Authority_TriggerActivationTimer(float ActivationTime);
	void ListenToDispatcherGameEvent(const struct FGameplayTag& EventType);
	void OnApplyBegin();
	void OnApplyEnd();
	void OnGameEventDispatched(const struct FGameplayTag& GameEventType, const struct FGameEventData& GameEventData);
	void OnInitialized();
	void OnInitialized_Internal();
	void OnLevelReadyToPlay();
	void OnRep_ActivationTimer();
	void OnRep_ModifierData();
	void OnRep_OperationConditionsData(const struct FOperationConditionsReplicatedData& OldOperationConditionsData);
	void OnRep_TickableConditionsData(const struct FModifierTickableConditionReplicatedData& OldTickableConditionsData);
	void RemoveAllFlags();
	void RemoveAllModifiers();
	void RemoveModifier(const struct FGameplayTag& Type);
	void SetFlag(const struct FGameplayTag& Flag, bool FlagValue);
	void SetModifierValue(const struct FGameplayTag& Type, float GameplayModifierValue);
	void UnlistenToAllDispatcherGameEvents();
	void UnlistenToDispatcherGameEvent(const struct FGameplayTag& EventType);
	void UpdateIsApplicable();

	void FireActiveStatusViewEvent(class FName Param_StatusViewID, class FName UniqueSourceID, const struct FStatusViewSource& StatusViewSource) const;
	float GetActivationTimerDuration() const;
	float GetActivationTimerElapsedTime() const;
	float GetActivationTimerElapsedTimePercent() const;
	float GetActivationTimerPercentRemaining() const;
	float GetActivationTimerRemainingTime() const;
	int32 GetIconFilePathIndex() const;
	EInventoryItemType GetInventoryItemType() const;
	int32 GetLevelToDisplay() const;
	float GetModifierValue(const struct FGameplayTag& Type) const;
	class UGameplayModifierContainer* GetOriginatingEffect() const;
	class ADBDPlayer* GetOwningPlayer() const;
	float GetPercentageFill() const;
	float GetRemainingLifetime() const;
	bool HasFlag(const struct FGameplayTag& Flag) const;
	bool HasModifierOfType(const struct FGameplayTag& Type) const;
	bool IsActivationTimerActive() const;
	bool IsActivationTimerDone() const;
	bool IsStatusViewActive() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayModifierContainer">();
	}
	static class UGameplayModifierContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayModifierContainer>();
	}
};
static_assert(alignof(UGameplayModifierContainer) == 0x000008, "Wrong alignment on UGameplayModifierContainer");
static_assert(sizeof(UGameplayModifierContainer) == 0x000248, "Wrong size on UGameplayModifierContainer");
static_assert(offsetof(UGameplayModifierContainer, _tickableConditionsData) == 0x000178, "Member 'UGameplayModifierContainer::_tickableConditionsData' has a wrong offset!");
static_assert(offsetof(UGameplayModifierContainer, _operationConditionsData) == 0x000190, "Member 'UGameplayModifierContainer::_operationConditionsData' has a wrong offset!");
static_assert(offsetof(UGameplayModifierContainer, _tags) == 0x0001A8, "Member 'UGameplayModifierContainer::_tags' has a wrong offset!");
static_assert(offsetof(UGameplayModifierContainer, UseApplyFunction) == 0x0001B8, "Member 'UGameplayModifierContainer::UseApplyFunction' has a wrong offset!");
static_assert(offsetof(UGameplayModifierContainer, BroadcastStatusView) == 0x0001B9, "Member 'UGameplayModifierContainer::BroadcastStatusView' has a wrong offset!");
static_assert(offsetof(UGameplayModifierContainer, StatusViewID) == 0x0001BC, "Member 'UGameplayModifierContainer::StatusViewID' has a wrong offset!");
static_assert(offsetof(UGameplayModifierContainer, _autoInitializeOnBeginPlay) == 0x0001C8, "Member 'UGameplayModifierContainer::_autoInitializeOnBeginPlay' has a wrong offset!");
static_assert(offsetof(UGameplayModifierContainer, _canOptimizeTickActivation) == 0x0001C9, "Member 'UGameplayModifierContainer::_canOptimizeTickActivation' has a wrong offset!");
static_assert(offsetof(UGameplayModifierContainer, _activationTimer) == 0x000228, "Member 'UGameplayModifierContainer::_activationTimer' has a wrong offset!");
static_assert(offsetof(UGameplayModifierContainer, _competenceOperations) == 0x000238, "Member 'UGameplayModifierContainer::_competenceOperations' has a wrong offset!");

// Class DeadByDaylight.Competence
// 0x0098 (0x02E0 - 0x0248)
class UCompetence : public UGameplayModifierContainer
{
public:
	uint8                                         Pad_248[0x30];                                     // 0x0248(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UBasePerkIconStrategy>      PerkIconStrategyClass;                             // 0x0278(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_280[0x18];                                     // 0x0280(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnTokenCountChangedBP;                             // 0x0298(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UTimerObject*                           _cooldownTimer;                                    // 0x02A8(0x0008)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B0[0x8];                                      // 0x02B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UTimerObject*                           _hudIconTimer;                                     // 0x02B8(0x0008)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          SetInactiveDuringCooldown;                         // 0x02C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C1[0x7];                                      // 0x02C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBasePerkIconStrategy*                  _perkIconStrategy;                                 // 0x02C8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         _tokenCount;                                       // 0x02D0(0x0004)(BlueprintVisible, Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         _maxTokenCount;                                    // 0x02D4(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EPerkTokenSoundStrategy                       _tokenSoundStrategy;                               // 0x02D8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D9[0x7];                                      // 0x02D9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_DecrementToken();
	void Authority_IncrementToken();
	void Authority_SetMaxTokenCount(int32 Value);
	void Authority_SetTokenCount(int32 Value);
	void Authority_TriggerCooldownTimer(const float Duration);
	void Authority_TriggerHudIconTimer(float Duration);
	void OnRep_TokenCount(int32 OldCount);

	class UTimerObject* GetCooldownTimer() const;
	float GetHudIconTimerElapsedTimePercent() const;
	float GetHudIconTimerRemainingTime() const;
	int32 GetMaxTokenCount() const;
	class UBasePerkIconStrategy* GetPerkIconStrategy() const;
	int32 GetTokenCount() const;
	bool IsCooldownTimerDone() const;
	bool IsHudIconTimerActive() const;
	bool IsHudIconTimerDone() const;
	void OnRep_CooldownTimer() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Competence">();
	}
	static class UCompetence* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCompetence>();
	}
};
static_assert(alignof(UCompetence) == 0x000008, "Wrong alignment on UCompetence");
static_assert(sizeof(UCompetence) == 0x0002E0, "Wrong size on UCompetence");
static_assert(offsetof(UCompetence, PerkIconStrategyClass) == 0x000278, "Member 'UCompetence::PerkIconStrategyClass' has a wrong offset!");
static_assert(offsetof(UCompetence, OnTokenCountChangedBP) == 0x000298, "Member 'UCompetence::OnTokenCountChangedBP' has a wrong offset!");
static_assert(offsetof(UCompetence, _cooldownTimer) == 0x0002A8, "Member 'UCompetence::_cooldownTimer' has a wrong offset!");
static_assert(offsetof(UCompetence, _hudIconTimer) == 0x0002B8, "Member 'UCompetence::_hudIconTimer' has a wrong offset!");
static_assert(offsetof(UCompetence, SetInactiveDuringCooldown) == 0x0002C0, "Member 'UCompetence::SetInactiveDuringCooldown' has a wrong offset!");
static_assert(offsetof(UCompetence, _perkIconStrategy) == 0x0002C8, "Member 'UCompetence::_perkIconStrategy' has a wrong offset!");
static_assert(offsetof(UCompetence, _tokenCount) == 0x0002D0, "Member 'UCompetence::_tokenCount' has a wrong offset!");
static_assert(offsetof(UCompetence, _maxTokenCount) == 0x0002D4, "Member 'UCompetence::_maxTokenCount' has a wrong offset!");
static_assert(offsetof(UCompetence, _tokenSoundStrategy) == 0x0002D8, "Member 'UCompetence::_tokenSoundStrategy' has a wrong offset!");

// Class DeadByDaylight.PerkManager
// 0x02C0 (0x0368 - 0x00A8)
class UPerkManager final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x28];                                      // 0x00A8(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class UPerkCollectionComponent*               _perks;                                            // 0x00D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStatusEffectCollectionComponent*       _statusEffects;                                    // 0x00D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USkillCollectionComponent*              _skills;                                           // 0x00E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E8[0x280];                                     // 0x00E8(0x0280)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UStatusEffect* Authority_ImposeNewStatusEffectOfClassOrChangeLifeTime(TSubclassOf<class UStatusEffect> EffectClass, class ADBDPlayer* OriginatingPlayer, float Lifetime, float CustomParam, class UGameplayModifierContainer* OriginatingEffect, bool ShouldDisplay);
	class UStatusEffect* Authority_ImposeStatusEffectFromTemplate(class UStatusEffect* EffectTemplate, class ADBDPlayer* OriginatingPlayer, float CustomParam, class UGameplayModifierContainer* OriginatingEffect, bool ShouldDisplay, float Lifetime);
	class UStatusEffect* Authority_ImposeStatusEffectOfClass(TSubclassOf<class UStatusEffect> EffectClass, class ADBDPlayer* OriginatingPlayer, float CustomParam, class UGameplayModifierContainer* OriginatingEffect, bool ShouldDisplay, float Lifetime);
	void Authority_RemovePerks();
	void Authority_RemoveStatusEffect(class UStatusEffect* StatusEffect);
	void Authority_RemoveStatusEffectByClass(const class UClass* EffectClass, bool bRemoveAllOfSameClass);
	void Authority_SpawnPerk(class FName PerkId, int32 PerkLevel);

	TArray<class UGameplayModifierContainer*> GetAllSourcesWithFlag(const struct FGameplayTag& Flag) const;
	TArray<class UGameplayModifierContainer*> GetAllSourcesWithModifier(const struct FGameplayTag& Type) const;
	TArray<class UStatusEffect*> GetAllStatusEffects() const;
	TArray<class UStatusEffect*> GetAllStatusEffectsByClass(const class UClass* Type) const;
	TArray<class UStatusEffect*> GetAllStatusEffectsByID(const class FName& ID) const;
	float GetAveragePerkModifierValue(const struct FGameplayTag& Type) const;
	float GetCompoundedModifierValue(const struct FGameplayTag& Type) const;
	float GetMultiplicativeModifierValue(const struct FGameplayTag& Type) const;
	float GetMultiplicativeModifierValueOfContainerWithCompoundNegative(const struct FGameplayTagContainer& Container) const;
	float GetMultiplicativeModifierValueWithCompoundNegative(const struct FGameplayTag& Type) const;
	class UPerk* GetPerk(class FName ID) const;
	float GetPerkModifier(const struct FGameplayTag& Type) const;
	float GetPerkModifierAdditiveValue(const struct FGameplayTag& Type, const float BaseValue) const;
	float GetPerkModifierMaxValue(const struct FGameplayTag& Type) const;
	float GetPerkModifierMaxValueAndSource(const struct FGameplayTag& Type, class UGameplayModifierContainer** OutSource) const;
	float GetPerkModifierMinValue(const struct FGameplayTag& Type, float StartValue) const;
	float GetPerkModifierMinValueAndSource(const struct FGameplayTag& Type, float StartValue, class UGameplayModifierContainer** OutSource) const;
	const TArray<class UPerk*> GetPerks() const;
	class UGameplayModifierContainer* GetSourceWithFlag(const struct FGameplayTag& Flag) const;
	class UGameplayModifierContainer* GetSourceWithModifier(const struct FGameplayTag& Type) const;
	class UStatusEffect* GetStatusEffectByClass(const class UClass* Type) const;
	bool HasAllCharacterPerksEquipped() const;
	bool HasAnyAddonWithTag(class FName Tag) const;
	bool HasPerkFlag(const struct FGameplayTag& Flag) const;
	bool HasPerkFlagFromSource(const struct FGameplayTag& Flag, EGameplayModifierSource ModifierSource) const;
	bool HasPerkFlags(const TArray<struct FGameplayTag>& Param_Flags) const;
	bool HasPerkModifierOfType(const struct FGameplayTag& Type) const;
	bool HasPerkSubFlag(const struct FGameplayTag& SubFlag) const;
	bool HasStatusEffect(const class FName StatusEffectId) const;
	bool HasStatusEffectOfClass(const class UClass* Type) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PerkManager">();
	}
	static class UPerkManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPerkManager>();
	}
};
static_assert(alignof(UPerkManager) == 0x000008, "Wrong alignment on UPerkManager");
static_assert(sizeof(UPerkManager) == 0x000368, "Wrong size on UPerkManager");
static_assert(offsetof(UPerkManager, _perks) == 0x0000D0, "Member 'UPerkManager::_perks' has a wrong offset!");
static_assert(offsetof(UPerkManager, _statusEffects) == 0x0000D8, "Member 'UPerkManager::_statusEffects' has a wrong offset!");
static_assert(offsetof(UPerkManager, _skills) == 0x0000E0, "Member 'UPerkManager::_skills' has a wrong offset!");

// Class DeadByDaylight.StillnessTrackerComponent
// 0x0048 (0x00F0 - 0x00A8)
class UStillnessTrackerComponent : public UActorComponent
{
public:
	float                                         SpeedThreshold;                                    // 0x00A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceThreshold;                                 // 0x00AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceDecay;                                     // 0x00B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DecayWhileMoving;                                  // 0x00B4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B5[0x3];                                       // 0x00B5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StillnessThreshhold;                               // 0x00B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StillnessTimerLimit;                               // 0x00BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DecaySpeedMultiplier;                              // 0x00C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C4[0x8];                                       // 0x00C4(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class ADBDPlayer>              _trackedPlayer;                                    // 0x00CC(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D4[0x1C];                                      // 0x00D4(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void StartTracking();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StillnessTrackerComponent">();
	}
	static class UStillnessTrackerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStillnessTrackerComponent>();
	}
};
static_assert(alignof(UStillnessTrackerComponent) == 0x000008, "Wrong alignment on UStillnessTrackerComponent");
static_assert(sizeof(UStillnessTrackerComponent) == 0x0000F0, "Wrong size on UStillnessTrackerComponent");
static_assert(offsetof(UStillnessTrackerComponent, SpeedThreshold) == 0x0000A8, "Member 'UStillnessTrackerComponent::SpeedThreshold' has a wrong offset!");
static_assert(offsetof(UStillnessTrackerComponent, DistanceThreshold) == 0x0000AC, "Member 'UStillnessTrackerComponent::DistanceThreshold' has a wrong offset!");
static_assert(offsetof(UStillnessTrackerComponent, DistanceDecay) == 0x0000B0, "Member 'UStillnessTrackerComponent::DistanceDecay' has a wrong offset!");
static_assert(offsetof(UStillnessTrackerComponent, DecayWhileMoving) == 0x0000B4, "Member 'UStillnessTrackerComponent::DecayWhileMoving' has a wrong offset!");
static_assert(offsetof(UStillnessTrackerComponent, StillnessThreshhold) == 0x0000B8, "Member 'UStillnessTrackerComponent::StillnessThreshhold' has a wrong offset!");
static_assert(offsetof(UStillnessTrackerComponent, StillnessTimerLimit) == 0x0000BC, "Member 'UStillnessTrackerComponent::StillnessTimerLimit' has a wrong offset!");
static_assert(offsetof(UStillnessTrackerComponent, DecaySpeedMultiplier) == 0x0000C0, "Member 'UStillnessTrackerComponent::DecaySpeedMultiplier' has a wrong offset!");
static_assert(offsetof(UStillnessTrackerComponent, _trackedPlayer) == 0x0000CC, "Member 'UStillnessTrackerComponent::_trackedPlayer' has a wrong offset!");

// Class DeadByDaylight.CamperStillnessTrackerComponent
// 0x0060 (0x0150 - 0x00F0)
class UCamperStillnessTrackerComponent final : public UStillnessTrackerComponent
{
public:
	float                                         ChickenShitModifier;                               // 0x00F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LoudNoiseTime;                                     // 0x00F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F8[0x10];                                      // 0x00F8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 ExposerSpawnTimes;                                 // 0x0108(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<float>                                 ExposerDespawnTimes;                               // 0x0118(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TSubclassOf<class ACamperExposerInstance>     _exposerInstanceToSpawn;                           // 0x0128(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class ACamperExposerInstance*>         _exposerInstances;                                 // 0x0130(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class UExposerInteriorZoneComponent*          _interiorZone;                                     // 0x0140(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_148[0x8];                                      // 0x0148(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EnterInteriorZone(class UExposerInteriorZoneComponent* Zone);
	void ExitInteriorZone(class UExposerInteriorZoneComponent* Zone);
	void OnLevelReadyToPlay();
	void OnOverlapEnter(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnOverlapExit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CamperStillnessTrackerComponent">();
	}
	static class UCamperStillnessTrackerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCamperStillnessTrackerComponent>();
	}
};
static_assert(alignof(UCamperStillnessTrackerComponent) == 0x000008, "Wrong alignment on UCamperStillnessTrackerComponent");
static_assert(sizeof(UCamperStillnessTrackerComponent) == 0x000150, "Wrong size on UCamperStillnessTrackerComponent");
static_assert(offsetof(UCamperStillnessTrackerComponent, ChickenShitModifier) == 0x0000F0, "Member 'UCamperStillnessTrackerComponent::ChickenShitModifier' has a wrong offset!");
static_assert(offsetof(UCamperStillnessTrackerComponent, LoudNoiseTime) == 0x0000F4, "Member 'UCamperStillnessTrackerComponent::LoudNoiseTime' has a wrong offset!");
static_assert(offsetof(UCamperStillnessTrackerComponent, ExposerSpawnTimes) == 0x000108, "Member 'UCamperStillnessTrackerComponent::ExposerSpawnTimes' has a wrong offset!");
static_assert(offsetof(UCamperStillnessTrackerComponent, ExposerDespawnTimes) == 0x000118, "Member 'UCamperStillnessTrackerComponent::ExposerDespawnTimes' has a wrong offset!");
static_assert(offsetof(UCamperStillnessTrackerComponent, _exposerInstanceToSpawn) == 0x000128, "Member 'UCamperStillnessTrackerComponent::_exposerInstanceToSpawn' has a wrong offset!");
static_assert(offsetof(UCamperStillnessTrackerComponent, _exposerInstances) == 0x000130, "Member 'UCamperStillnessTrackerComponent::_exposerInstances' has a wrong offset!");
static_assert(offsetof(UCamperStillnessTrackerComponent, _interiorZone) == 0x000140, "Member 'UCamperStillnessTrackerComponent::_interiorZone' has a wrong offset!");

// Class DeadByDaylight.InteractionProficiency
// 0x0018 (0x0048 - 0x0030)
class UInteractionProficiency : public UObject
{
public:
	TArray<class FString>                         InteractionIds;                                    // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool GetIsActive(const class UChargeableInteractionDefinition* ChargeableInteraction, const class ADBDPlayer* Player) const;
	int32 GetLevel(const class UChargeableInteractionDefinition* ChargeableInteraction, const class ADBDPlayer* Player) const;
	EStatusEffectType GetType(const float Value) const;
	float GetValue(const class UChargeableInteractionDefinition* ChargeableInteraction, const class ADBDPlayer* Player) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionProficiency">();
	}
	static class UInteractionProficiency* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionProficiency>();
	}
};
static_assert(alignof(UInteractionProficiency) == 0x000008, "Wrong alignment on UInteractionProficiency");
static_assert(sizeof(UInteractionProficiency) == 0x000048, "Wrong size on UInteractionProficiency");
static_assert(offsetof(UInteractionProficiency, InteractionIds) == 0x000030, "Member 'UInteractionProficiency::InteractionIds' has a wrong offset!");

// Class DeadByDaylight.BlindingFXComponent
// 0x0050 (0x00F8 - 0x00A8)
class UBlindingFXComponent : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x14];                                      // 0x00A8(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   _blindnessIntensityParameter;                      // 0x00BC(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _blindnessMaterialCurve;                           // 0x00C8(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _blindnessCurve;                                   // 0x00D0(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPostProcessComponent*                  _postProcess;                                      // 0x00D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               _postProcessMaterial;                              // 0x00E0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E8[0x10];                                      // 0x00E8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetPostProcess(class UPostProcessComponent* Value);
	void SetPostProcessMaterial(class UMaterialInstanceDynamic* Value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlindingFXComponent">();
	}
	static class UBlindingFXComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlindingFXComponent>();
	}
};
static_assert(alignof(UBlindingFXComponent) == 0x000008, "Wrong alignment on UBlindingFXComponent");
static_assert(sizeof(UBlindingFXComponent) == 0x0000F8, "Wrong size on UBlindingFXComponent");
static_assert(offsetof(UBlindingFXComponent, _blindnessIntensityParameter) == 0x0000BC, "Member 'UBlindingFXComponent::_blindnessIntensityParameter' has a wrong offset!");
static_assert(offsetof(UBlindingFXComponent, _blindnessMaterialCurve) == 0x0000C8, "Member 'UBlindingFXComponent::_blindnessMaterialCurve' has a wrong offset!");
static_assert(offsetof(UBlindingFXComponent, _blindnessCurve) == 0x0000D0, "Member 'UBlindingFXComponent::_blindnessCurve' has a wrong offset!");
static_assert(offsetof(UBlindingFXComponent, _postProcess) == 0x0000D8, "Member 'UBlindingFXComponent::_postProcess' has a wrong offset!");
static_assert(offsetof(UBlindingFXComponent, _postProcessMaterial) == 0x0000E0, "Member 'UBlindingFXComponent::_postProcessMaterial' has a wrong offset!");

// Class DeadByDaylight.ScreenshotToolViewAsset
// 0x0118 (0x0150 - 0x0038)
class UScreenshotToolViewAsset final : public UDataAsset
{
public:
	struct FScreenshotViewSetting                 Charm;                                             // 0x0038(0x0028)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FScreenshotViewSetting                 SurvivorHead;                                      // 0x0060(0x0028)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FScreenshotViewSetting                 SurvivorTorso;                                     // 0x0088(0x0028)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FScreenshotViewSetting                 SurvivorLegs;                                      // 0x00B0(0x0028)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FScreenshotViewSetting                 KillerHead;                                        // 0x00D8(0x0028)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FScreenshotViewSetting                 KillerBody;                                        // 0x0100(0x0028)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FScreenshotViewSetting                 KillerWeapon;                                      // 0x0128(0x0028)(Edit, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScreenshotToolViewAsset">();
	}
	static class UScreenshotToolViewAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScreenshotToolViewAsset>();
	}
};
static_assert(alignof(UScreenshotToolViewAsset) == 0x000008, "Wrong alignment on UScreenshotToolViewAsset");
static_assert(sizeof(UScreenshotToolViewAsset) == 0x000150, "Wrong size on UScreenshotToolViewAsset");
static_assert(offsetof(UScreenshotToolViewAsset, Charm) == 0x000038, "Member 'UScreenshotToolViewAsset::Charm' has a wrong offset!");
static_assert(offsetof(UScreenshotToolViewAsset, SurvivorHead) == 0x000060, "Member 'UScreenshotToolViewAsset::SurvivorHead' has a wrong offset!");
static_assert(offsetof(UScreenshotToolViewAsset, SurvivorTorso) == 0x000088, "Member 'UScreenshotToolViewAsset::SurvivorTorso' has a wrong offset!");
static_assert(offsetof(UScreenshotToolViewAsset, SurvivorLegs) == 0x0000B0, "Member 'UScreenshotToolViewAsset::SurvivorLegs' has a wrong offset!");
static_assert(offsetof(UScreenshotToolViewAsset, KillerHead) == 0x0000D8, "Member 'UScreenshotToolViewAsset::KillerHead' has a wrong offset!");
static_assert(offsetof(UScreenshotToolViewAsset, KillerBody) == 0x000100, "Member 'UScreenshotToolViewAsset::KillerBody' has a wrong offset!");
static_assert(offsetof(UScreenshotToolViewAsset, KillerWeapon) == 0x000128, "Member 'UScreenshotToolViewAsset::KillerWeapon' has a wrong offset!");

// Class DeadByDaylight.StatusEffect
// 0x0138 (0x0380 - 0x0248)
class UStatusEffect : public UGameplayModifierContainer
{
public:
	uint8                                         Pad_248[0x48];                                     // 0x0248(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayModifierData                  ModifierData;                                      // 0x0290(0x0030)(Edit, Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	bool                                          ShouldDisplay;                                     // 0x02C0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C1[0x3];                                      // 0x02C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CustomParam;                                       // 0x02C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _removeOnRemainingLifetimeEnded;                   // 0x02C8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          BroadcastAsStatusEffectWhenApplicable;             // 0x02C9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          BroadcastAsStatusEffectByActivationTimer;          // 0x02CA(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          BroadcastAsStatusEffectWhenLifeRemains;            // 0x02CB(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          BroadcastAsStatusEffectByFunction;                 // 0x02CC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          BroadcastAsStatusEffectAlways;                     // 0x02CD(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          BroadcastAsStatusEffectManual;                     // 0x02CE(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          BroadcastOriginatorGameEventNotificationWhenFirstApplicable; // 0x02CF(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          ShouldHideStatusEffectIconForOriginatingPlayer;    // 0x02D0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          ShouldHideStatusEffectIconByFunction;              // 0x02D1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _forceActivationTimerDisplay;                      // 0x02D2(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D3[0x5];                                      // 0x02D3(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FStatusEffectInitializationData        _statusInitializationData;                         // 0x02D8(0x0028)(Net, Transient, RepNotify, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	bool                                          _shouldBroadcastAsStatusEffect;                    // 0x0300(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_301[0x37];                                     // 0x0301(0x0037)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftClassPtr<class UClass>>           _nonStackingEffects;                               // 0x0338(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	float                                         _statusEffectIconPercentage;                       // 0x0348(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_34C[0x34];                                     // 0x034C(0x0034)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_End();
	void Authority_EndSelf();
	void Authority_OnOriginatingPlayerEndPlay(class AActor* Actor, EEndPlayReason EndPlayReason);
	void Authority_RemoveSelf();
	void Authority_SetRemainingLifetime(float Lifetime);
	void Authority_Start(const float Duration);
	void BroadcastGameEventNotification(const struct FGameplayNotificationData& NotificationData, bool AddToHistory);
	void BroadcastOriginatorGameEventNotification();
	void InitializeLifetime(float Lifetime);
	void Multicast_SetRemainingLifetime(float Lifetime);
	void Multicast_SetRemainingLifetimeInitialized(bool RemainingLifetimeInitialized);
	void OnLifetimeEnded();
	void OnLifetimeStarted();
	void OnRep_ShouldDisplay();
	void OnRep_ShouldOriginatingPlayerChange();
	void OnRep_StatusInitializationData();
	void OnShouldDisplayChanged(bool CurrentValue);
	void OnShouldOriginatingPlayerChange();
	void SetShouldDisplay(bool On);
	void SetStatusEffectIconPercentage(float Value);

	void FireActiveStatusEffectEvent(float Percentage, int32 LevelToDisplay) const;
	float GetCustomParam() const;
	float GetLifetimeDuration() const;
	class ADBDPlayer* GetOriginatingPlayer() const;
	bool GetShouldDisplay() const;
	float GetStatusEffectCooldownRate() const;
	EStatusEffectType GetStatusEffectType() const;
	bool IsInOriginatorRange() const;
	bool IsKillerInOriginatorRange(float AdditiveRangeModifier) const;
	bool IsOriginatorAlive() const;
	bool IsOriginatorHooked() const;
	bool ShouldDisplayStatusEffectIcon() const;
	bool ShouldHideStatusEffectIcon() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StatusEffect">();
	}
	static class UStatusEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStatusEffect>();
	}
};
static_assert(alignof(UStatusEffect) == 0x000008, "Wrong alignment on UStatusEffect");
static_assert(sizeof(UStatusEffect) == 0x000380, "Wrong size on UStatusEffect");
static_assert(offsetof(UStatusEffect, ModifierData) == 0x000290, "Member 'UStatusEffect::ModifierData' has a wrong offset!");
static_assert(offsetof(UStatusEffect, ShouldDisplay) == 0x0002C0, "Member 'UStatusEffect::ShouldDisplay' has a wrong offset!");
static_assert(offsetof(UStatusEffect, CustomParam) == 0x0002C4, "Member 'UStatusEffect::CustomParam' has a wrong offset!");
static_assert(offsetof(UStatusEffect, _removeOnRemainingLifetimeEnded) == 0x0002C8, "Member 'UStatusEffect::_removeOnRemainingLifetimeEnded' has a wrong offset!");
static_assert(offsetof(UStatusEffect, BroadcastAsStatusEffectWhenApplicable) == 0x0002C9, "Member 'UStatusEffect::BroadcastAsStatusEffectWhenApplicable' has a wrong offset!");
static_assert(offsetof(UStatusEffect, BroadcastAsStatusEffectByActivationTimer) == 0x0002CA, "Member 'UStatusEffect::BroadcastAsStatusEffectByActivationTimer' has a wrong offset!");
static_assert(offsetof(UStatusEffect, BroadcastAsStatusEffectWhenLifeRemains) == 0x0002CB, "Member 'UStatusEffect::BroadcastAsStatusEffectWhenLifeRemains' has a wrong offset!");
static_assert(offsetof(UStatusEffect, BroadcastAsStatusEffectByFunction) == 0x0002CC, "Member 'UStatusEffect::BroadcastAsStatusEffectByFunction' has a wrong offset!");
static_assert(offsetof(UStatusEffect, BroadcastAsStatusEffectAlways) == 0x0002CD, "Member 'UStatusEffect::BroadcastAsStatusEffectAlways' has a wrong offset!");
static_assert(offsetof(UStatusEffect, BroadcastAsStatusEffectManual) == 0x0002CE, "Member 'UStatusEffect::BroadcastAsStatusEffectManual' has a wrong offset!");
static_assert(offsetof(UStatusEffect, BroadcastOriginatorGameEventNotificationWhenFirstApplicable) == 0x0002CF, "Member 'UStatusEffect::BroadcastOriginatorGameEventNotificationWhenFirstApplicable' has a wrong offset!");
static_assert(offsetof(UStatusEffect, ShouldHideStatusEffectIconForOriginatingPlayer) == 0x0002D0, "Member 'UStatusEffect::ShouldHideStatusEffectIconForOriginatingPlayer' has a wrong offset!");
static_assert(offsetof(UStatusEffect, ShouldHideStatusEffectIconByFunction) == 0x0002D1, "Member 'UStatusEffect::ShouldHideStatusEffectIconByFunction' has a wrong offset!");
static_assert(offsetof(UStatusEffect, _forceActivationTimerDisplay) == 0x0002D2, "Member 'UStatusEffect::_forceActivationTimerDisplay' has a wrong offset!");
static_assert(offsetof(UStatusEffect, _statusInitializationData) == 0x0002D8, "Member 'UStatusEffect::_statusInitializationData' has a wrong offset!");
static_assert(offsetof(UStatusEffect, _shouldBroadcastAsStatusEffect) == 0x000300, "Member 'UStatusEffect::_shouldBroadcastAsStatusEffect' has a wrong offset!");
static_assert(offsetof(UStatusEffect, _nonStackingEffects) == 0x000338, "Member 'UStatusEffect::_nonStackingEffects' has a wrong offset!");
static_assert(offsetof(UStatusEffect, _statusEffectIconPercentage) == 0x000348, "Member 'UStatusEffect::_statusEffectIconPercentage' has a wrong offset!");

// Class DeadByDaylight.DBDAttackSubstate
// 0x00E8 (0x0118 - 0x0030)
class UDBDAttackSubstate : public UObject
{
public:
	struct FStatProperty                          _duration;                                         // 0x0030(0x0088)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UCurveFloat*                            _speedCurve;                                       // 0x00B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _montage;                                          // 0x00C0(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_CC[0x4];                                       // 0x00CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            _currentCurve;                                     // 0x00D0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D8[0x40];                                      // 0x00D8(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDAttackSubstate">();
	}
	static class UDBDAttackSubstate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDAttackSubstate>();
	}
};
static_assert(alignof(UDBDAttackSubstate) == 0x000008, "Wrong alignment on UDBDAttackSubstate");
static_assert(sizeof(UDBDAttackSubstate) == 0x000118, "Wrong size on UDBDAttackSubstate");
static_assert(offsetof(UDBDAttackSubstate, _duration) == 0x000030, "Member 'UDBDAttackSubstate::_duration' has a wrong offset!");
static_assert(offsetof(UDBDAttackSubstate, _speedCurve) == 0x0000B8, "Member 'UDBDAttackSubstate::_speedCurve' has a wrong offset!");
static_assert(offsetof(UDBDAttackSubstate, _montage) == 0x0000C0, "Member 'UDBDAttackSubstate::_montage' has a wrong offset!");
static_assert(offsetof(UDBDAttackSubstate, _currentCurve) == 0x0000D0, "Member 'UDBDAttackSubstate::_currentCurve' has a wrong offset!");

// Class DeadByDaylight.DBDAttackHittingSubstate
// 0x0088 (0x01A0 - 0x0118)
class UDBDAttackHittingSubstate : public UDBDAttackSubstate
{
public:
	struct FStatProperty                          _hittingPercentDamageBegin;                        // 0x0118(0x0088)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDAttackHittingSubstate">();
	}
	static class UDBDAttackHittingSubstate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDAttackHittingSubstate>();
	}
};
static_assert(alignof(UDBDAttackHittingSubstate) == 0x000008, "Wrong alignment on UDBDAttackHittingSubstate");
static_assert(sizeof(UDBDAttackHittingSubstate) == 0x0001A0, "Wrong size on UDBDAttackHittingSubstate");
static_assert(offsetof(UDBDAttackHittingSubstate, _hittingPercentDamageBegin) == 0x000118, "Member 'UDBDAttackHittingSubstate::_hittingPercentDamageBegin' has a wrong offset!");

// Class DeadByDaylight.OutlineUpdateStrategy
// 0x0028 (0x00D0 - 0x00A8)
class UOutlineUpdateStrategy : public UActorComponent
{
public:
	TArray<struct FGameplayTag>                   _requiredPlayerStateTags;                          // 0x00A8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FGameplayTag>                   _preventativePlayerStateTags;                      // 0x00B8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UDBDOutlineComponent*                   _outlineComponent;                                 // 0x00C8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OutlineUpdateStrategy">();
	}
	static class UOutlineUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOutlineUpdateStrategy>();
	}
};
static_assert(alignof(UOutlineUpdateStrategy) == 0x000008, "Wrong alignment on UOutlineUpdateStrategy");
static_assert(sizeof(UOutlineUpdateStrategy) == 0x0000D0, "Wrong size on UOutlineUpdateStrategy");
static_assert(offsetof(UOutlineUpdateStrategy, _requiredPlayerStateTags) == 0x0000A8, "Member 'UOutlineUpdateStrategy::_requiredPlayerStateTags' has a wrong offset!");
static_assert(offsetof(UOutlineUpdateStrategy, _preventativePlayerStateTags) == 0x0000B8, "Member 'UOutlineUpdateStrategy::_preventativePlayerStateTags' has a wrong offset!");
static_assert(offsetof(UOutlineUpdateStrategy, _outlineComponent) == 0x0000C8, "Member 'UOutlineUpdateStrategy::_outlineComponent' has a wrong offset!");

// Class DeadByDaylight.SourceBasedOutlineUpdateStrategy
// 0x0078 (0x0148 - 0x00D0)
class USourceBasedOutlineUpdateStrategy : public UOutlineUpdateStrategy
{
public:
	struct FLinearColor                           _defaultColorForSurvivor;                          // 0x00D0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           _defaultColorForSlasher;                           // 0x00E0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F0[0x58];                                      // 0x00F0(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SourceBasedOutlineUpdateStrategy">();
	}
	static class USourceBasedOutlineUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<USourceBasedOutlineUpdateStrategy>();
	}
};
static_assert(alignof(USourceBasedOutlineUpdateStrategy) == 0x000008, "Wrong alignment on USourceBasedOutlineUpdateStrategy");
static_assert(sizeof(USourceBasedOutlineUpdateStrategy) == 0x000148, "Wrong size on USourceBasedOutlineUpdateStrategy");
static_assert(offsetof(USourceBasedOutlineUpdateStrategy, _defaultColorForSurvivor) == 0x0000D0, "Member 'USourceBasedOutlineUpdateStrategy::_defaultColorForSurvivor' has a wrong offset!");
static_assert(offsetof(USourceBasedOutlineUpdateStrategy, _defaultColorForSlasher) == 0x0000E0, "Member 'USourceBasedOutlineUpdateStrategy::_defaultColorForSlasher' has a wrong offset!");

// Class DeadByDaylight.SeanceRitualOutlineUpdateStrategy
// 0x0000 (0x0148 - 0x0148)
class USeanceRitualOutlineUpdateStrategy final : public USourceBasedOutlineUpdateStrategy
{
public:
	struct FLinearColor GetRevealColorToSurvivor() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SeanceRitualOutlineUpdateStrategy">();
	}
	static class USeanceRitualOutlineUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<USeanceRitualOutlineUpdateStrategy>();
	}
};
static_assert(alignof(USeanceRitualOutlineUpdateStrategy) == 0x000008, "Wrong alignment on USeanceRitualOutlineUpdateStrategy");
static_assert(sizeof(USeanceRitualOutlineUpdateStrategy) == 0x000148, "Wrong size on USeanceRitualOutlineUpdateStrategy");

// Class DeadByDaylight.DBDBaseGameMode
// 0x0068 (0x0400 - 0x0398)
class ADBDBaseGameMode : public AGameMode
{
public:
	uint8                                         Pad_398[0x8];                                      // 0x0398(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDataTableDropdown                     DebugSpecialEvent;                                 // 0x03A0(0x0030)(Edit, NativeAccessSpecifierPrivate)
	struct FDataTableDropdown                     DebugGameType;                                     // 0x03D0(0x0030)(Edit, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDBaseGameMode">();
	}
	static class ADBDBaseGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDBaseGameMode>();
	}
};
static_assert(alignof(ADBDBaseGameMode) == 0x000008, "Wrong alignment on ADBDBaseGameMode");
static_assert(sizeof(ADBDBaseGameMode) == 0x000400, "Wrong size on ADBDBaseGameMode");
static_assert(offsetof(ADBDBaseGameMode, DebugSpecialEvent) == 0x0003A0, "Member 'ADBDBaseGameMode::DebugSpecialEvent' has a wrong offset!");
static_assert(offsetof(ADBDBaseGameMode, DebugGameType) == 0x0003D0, "Member 'ADBDBaseGameMode::DebugGameType' has a wrong offset!");

// Class DeadByDaylight.DBDBaseMatchGameMode
// 0x0020 (0x0420 - 0x0400)
class ADBDBaseMatchGameMode : public ADBDBaseGameMode
{
public:
	TArray<TSubclassOf<class AGameObjectiveBase>> _gameObjectiveClasses;                             // 0x0400(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	class UEndGameComponent*                      _endGameComponent;                                 // 0x0410(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ANetworkFenceActor*                     _theFence;                                         // 0x0418(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class UEndGameComponent* GetEndGameComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDBaseMatchGameMode">();
	}
	static class ADBDBaseMatchGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDBaseMatchGameMode>();
	}
};
static_assert(alignof(ADBDBaseMatchGameMode) == 0x000008, "Wrong alignment on ADBDBaseMatchGameMode");
static_assert(sizeof(ADBDBaseMatchGameMode) == 0x000420, "Wrong size on ADBDBaseMatchGameMode");
static_assert(offsetof(ADBDBaseMatchGameMode, _gameObjectiveClasses) == 0x000400, "Member 'ADBDBaseMatchGameMode::_gameObjectiveClasses' has a wrong offset!");
static_assert(offsetof(ADBDBaseMatchGameMode, _endGameComponent) == 0x000410, "Member 'ADBDBaseMatchGameMode::_endGameComponent' has a wrong offset!");
static_assert(offsetof(ADBDBaseMatchGameMode, _theFence) == 0x000418, "Member 'ADBDBaseMatchGameMode::_theFence' has a wrong offset!");

// Class DeadByDaylight.DBDGameMode
// 0x01C8 (0x05E8 - 0x0420)
class ADBDGameMode : public ADBDBaseMatchGameMode
{
public:
	uint8                                         Pad_420[0x58];                                     // 0x0420(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnPlayersLoadoutsCreated;                          // 0x0478(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class APlayerController>          _killerPlayerControllerClass;                      // 0x0488(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoClear, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class APlayerController>          _survivorPlayerControllerClass;                    // 0x0490(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoClear, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_498[0x38];                                     // 0x0498(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 KillerCreationPositions;                           // 0x04D0(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPrivate)
	class UStatusEffect*                          _gateBlockedStatus;                                // 0x04E0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4E8[0xA0];                                     // 0x04E8(0x00A0)(Fixing Size After Last Property [ Dumper-7 ])
	class UNavmeshGeneratorComponent*             _navmeshGeneratorComponent;                        // 0x0588(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_590[0x30];                                     // 0x0590(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class APlayerStart*>                   _killerSpawnPoints;                                // 0x05C0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class APlayerStart*>                   _survivorSpawnPoints;                              // 0x05D0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class APlayerStart*                           _observerSpawnPoint;                               // 0x05E0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void HostGame();
	void InitializeEscapeRequirements();
	void LevelLoaded(const class FString& LevelName);
	void SetPlayerCount(int32 PlayerAmount);

	bool AreLoadoutsCreated() const;
	bool IsEscapeOpen() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDGameMode">();
	}
	static class ADBDGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDGameMode>();
	}
};
static_assert(alignof(ADBDGameMode) == 0x000008, "Wrong alignment on ADBDGameMode");
static_assert(sizeof(ADBDGameMode) == 0x0005E8, "Wrong size on ADBDGameMode");
static_assert(offsetof(ADBDGameMode, OnPlayersLoadoutsCreated) == 0x000478, "Member 'ADBDGameMode::OnPlayersLoadoutsCreated' has a wrong offset!");
static_assert(offsetof(ADBDGameMode, _killerPlayerControllerClass) == 0x000488, "Member 'ADBDGameMode::_killerPlayerControllerClass' has a wrong offset!");
static_assert(offsetof(ADBDGameMode, _survivorPlayerControllerClass) == 0x000490, "Member 'ADBDGameMode::_survivorPlayerControllerClass' has a wrong offset!");
static_assert(offsetof(ADBDGameMode, KillerCreationPositions) == 0x0004D0, "Member 'ADBDGameMode::KillerCreationPositions' has a wrong offset!");
static_assert(offsetof(ADBDGameMode, _gateBlockedStatus) == 0x0004E0, "Member 'ADBDGameMode::_gateBlockedStatus' has a wrong offset!");
static_assert(offsetof(ADBDGameMode, _navmeshGeneratorComponent) == 0x000588, "Member 'ADBDGameMode::_navmeshGeneratorComponent' has a wrong offset!");
static_assert(offsetof(ADBDGameMode, _killerSpawnPoints) == 0x0005C0, "Member 'ADBDGameMode::_killerSpawnPoints' has a wrong offset!");
static_assert(offsetof(ADBDGameMode, _survivorSpawnPoints) == 0x0005D0, "Member 'ADBDGameMode::_survivorSpawnPoints' has a wrong offset!");
static_assert(offsetof(ADBDGameMode, _observerSpawnPoint) == 0x0005E0, "Member 'ADBDGameMode::_observerSpawnPoint' has a wrong offset!");

// Class DeadByDaylight.DBDDebugGameMode
// 0x00F8 (0x06E0 - 0x05E8)
class ADBDDebugGameMode final : public ADBDGameMode
{
public:
	uint8                                         Pad_5E8[0x8];                                      // 0x05E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class ADBDPlayerController*, int32>      LoadoutIndex;                                      // 0x05F0(0x0050)(NativeAccessSpecifierPrivate)
	TSet<class ADBDPlayer*>                       PlayersWithItems;                                  // 0x0640(0x0050)(NativeAccessSpecifierPrivate)
	TArray<struct FCamperLoadout>                 CamperPawnOverrides;                               // 0x0690(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FSlasherLoadout>                SlasherPawnOverrides;                              // 0x06A0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FDebugQuestModelExtArchiveObjective> _questObjectives;                                  // 0x06B0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	int32                                         _spawnSurvivorBotsCount;                           // 0x06C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _disableSpawnedSurvivorAI;                         // 0x06C4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6C5[0x3];                                      // 0x06C5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _spawnKillerBotsCount;                             // 0x06C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _disableSpawnedKillerAI;                           // 0x06CC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6CD[0x13];                                     // 0x06CD(0x0013)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDDebugGameMode">();
	}
	static class ADBDDebugGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDDebugGameMode>();
	}
};
static_assert(alignof(ADBDDebugGameMode) == 0x000008, "Wrong alignment on ADBDDebugGameMode");
static_assert(sizeof(ADBDDebugGameMode) == 0x0006E0, "Wrong size on ADBDDebugGameMode");
static_assert(offsetof(ADBDDebugGameMode, LoadoutIndex) == 0x0005F0, "Member 'ADBDDebugGameMode::LoadoutIndex' has a wrong offset!");
static_assert(offsetof(ADBDDebugGameMode, PlayersWithItems) == 0x000640, "Member 'ADBDDebugGameMode::PlayersWithItems' has a wrong offset!");
static_assert(offsetof(ADBDDebugGameMode, CamperPawnOverrides) == 0x000690, "Member 'ADBDDebugGameMode::CamperPawnOverrides' has a wrong offset!");
static_assert(offsetof(ADBDDebugGameMode, SlasherPawnOverrides) == 0x0006A0, "Member 'ADBDDebugGameMode::SlasherPawnOverrides' has a wrong offset!");
static_assert(offsetof(ADBDDebugGameMode, _questObjectives) == 0x0006B0, "Member 'ADBDDebugGameMode::_questObjectives' has a wrong offset!");
static_assert(offsetof(ADBDDebugGameMode, _spawnSurvivorBotsCount) == 0x0006C0, "Member 'ADBDDebugGameMode::_spawnSurvivorBotsCount' has a wrong offset!");
static_assert(offsetof(ADBDDebugGameMode, _disableSpawnedSurvivorAI) == 0x0006C4, "Member 'ADBDDebugGameMode::_disableSpawnedSurvivorAI' has a wrong offset!");
static_assert(offsetof(ADBDDebugGameMode, _spawnKillerBotsCount) == 0x0006C8, "Member 'ADBDDebugGameMode::_spawnKillerBotsCount' has a wrong offset!");
static_assert(offsetof(ADBDDebugGameMode, _disableSpawnedKillerAI) == 0x0006CC, "Member 'ADBDDebugGameMode::_disableSpawnedKillerAI' has a wrong offset!");

// Class DeadByDaylight.InteractionDefinition
// 0x04C0 (0x0780 - 0x02C0)
#pragma pack(push, 0x1)
class alignas(0x10) UInteractionDefinition : public USceneComponent
{
public:
	uint8                                         Pad_2C0[0x40];                                     // 0x02C0(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 InteractionID;                                     // 0x0300(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SnapTime;                                          // 0x0310(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ResetCameraDuringSnap;                             // 0x0314(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsInteractionCancelled;                            // 0x0315(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AllowStartInteractionFromHeldInput;                // 0x0316(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          StopInteractionOnMontageComplete;                  // 0x0317(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          StopInteractionOnMontageBlendingOut;               // 0x0318(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          StopInteractionOnTimerExpire;                      // 0x0319(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          StopInteractionOnHeightDelta;                      // 0x031A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          StopEnterMontageOnExit;                            // 0x031B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          StopUpdateMontageOnExit;                           // 0x031C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IgnoreStrafeAnimFix;                               // 0x031D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInteractionAnimation                         InteractionAnimation;                              // 0x031E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CamperCanInteract;                                 // 0x031F(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SlasherCanInteract;                                // 0x0320(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AllowInputPersistence;                             // 0x0321(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SnapPosition;                                      // 0x0322(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SweepOnFinalSnap;                                  // 0x0323(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SnapRotation;                                      // 0x0324(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_325[0x3];                                      // 0x0325(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SnapStopDistance;                                  // 0x0328(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TestClearPathDuringSnap;                           // 0x032C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MustBeClosestPlayerToSnapPoint;                    // 0x032D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CheckInteractableIsInPlayerView;                   // 0x032E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32F[0x1];                                      // 0x032F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CheckInteractableInViewSphereSweepRadius;          // 0x0330(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_334[0x4];                                      // 0x0334(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                CheckInteractableInViewOffset;                     // 0x0338(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CheckInteractableInViewOffsetDistanceToHitPoint;   // 0x0350(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsInterruptibleIfTestClearPathDuringSnapFails;     // 0x0354(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TestPlayerOrientationOnSnap;                       // 0x0355(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ScaleEnterAnimationToTime;                         // 0x0356(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ScaleMainAnimationToTime;                          // 0x0357(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ScaleExitAnimationToTime;                          // 0x0358(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnapBackType                                 SnapBackType;                                      // 0x0359(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnapBackPositionType                         SnapBackPositionType;                              // 0x035A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35B[0x5];                                      // 0x035B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              SnapBackPositionOffset;                            // 0x0360(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SnapToInitialRotationDuringSnapBack;               // 0x0370(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseStartSnapTimeForSnapExitTime;                   // 0x0371(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanInteractWhileIncapacitated;                     // 0x0372(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanInteractWhileCloaked;                           // 0x0373(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanInteractWhileAttacking;                         // 0x0374(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanInteractWhileChainLinked;                       // 0x0375(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanInteractWhileShocked;                           // 0x0376(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanInteractWhileUnhookingSelf;                     // 0x0377(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanInteractWhileCarrying;                          // 0x0378(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AllowNavigation;                                   // 0x0379(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AllowNavigationInput;                              // 0x037A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AllowRotation;                                     // 0x037B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseCameraMontageMode;                              // 0x037C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          OwnerBlocksAttack;                                 // 0x037D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsHighPriority;                                    // 0x037E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AllowOverridingWhenNotForced;                      // 0x037F(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IgnoreOverlapOnInteractable;                       // 0x0380(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseAuthoritativeMovement;                          // 0x0381(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanBeAuthoritativePushedDuringEnter;               // 0x0382(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanBeAuthoritativePushedDuringUpdate;              // 0x0383(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanBeAuthoritativePushedDuringExit;                // 0x0384(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanAuthoritativePush;                              // 0x0385(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CancelOnHit;                                       // 0x0386(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CancelOnAttack;                                    // 0x0387(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HideItem;                                          // 0x0388(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ContinueCachingLastSafeItemDropLocation;           // 0x0389(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AutoBindToParentInteractor;                        // 0x038A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AutoBindToParentZone;                              // 0x038B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CancelOnMoveInitialDelay;                          // 0x038C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CancelOnMoveInput;                                 // 0x0390(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CancelOnMoveInputOnlyWhenRunning;                  // 0x0394(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          BotsCanCancelOnMoveInput;                          // 0x0395(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_396[0x2];                                      // 0x0396(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 ProgressBasedSkillChecks;                          // 0x0398(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          CanCrouch;                                         // 0x03A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AffectsStillness;                                  // 0x03A9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ConsideredIdle;                                    // 0x03AA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          BlockSelfInteract;                                 // 0x03AB(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InteractionTime;                                   // 0x03AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInputInteractionType                         InteractionInputType;                              // 0x03B0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NoInputInteraction;                                // 0x03B1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          StopInteractionOnInputRelease;                     // 0x03B2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AllowHitMontageWhenInteracting;                    // 0x03B3(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShowBasicInteractionIcon;                          // 0x03B4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B5[0x3];                                      // 0x03B5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UInterruptionDefinition*>        _interruptionDefinitions;                          // 0x03B8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnInteractionEnteredDelegate;                      // 0x03C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D8[0x30];                                     // 0x03D8(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnInteractionFinishedDelegate;                     // 0x0408(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_418[0x18];                                     // 0x0418(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnInteractionInterruptedStartDelegate;             // 0x0430(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnInteractionInterruptedStartedDelegate;           // 0x0440(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnInteractionInterruptedEndDelegate;               // 0x0450(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnInteractionAnimNotify;                           // 0x0460(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          DebugUnavailability;                               // 0x0470(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInputInteractionType                         SecondaryActionInputType;                          // 0x0471(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_472[0x1E];                                     // 0x0472(0x001E)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            NavigationSpeedCurveEnter;                         // 0x0490(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            NavigationSpeedCurve;                              // 0x0498(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            NavigationSpeedCurveExit;                          // 0x04A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _shouldCheckInteractedUpon;                        // 0x04A8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EInteractionOwnership                         OwnershipUsability;                                // 0x04A9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4AA[0x2];                                      // 0x04AA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ExitInteractionTime;                               // 0x04AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          ApplyModifiersToExitTime;                          // 0x04B0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4B1[0x7];                                      // 0x04B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   InteractionDescriptionText;                        // 0x04B8(0x0018)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	bool                                          InteractionCanBeToggled;                           // 0x04D0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsOverridingInputToggleReleasePromptMessage;       // 0x04D1(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4D2[0x6];                                      // 0x04D2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 InputToggleReleasePromptMessage;                   // 0x04D8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IgnoreSprintToCancelSetting;                       // 0x04E8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          ForceWithSprintToCancelSetting;                    // 0x04E9(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4EA[0x2];                                      // 0x04EA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InteractionHeightDeltaMax;                         // 0x04EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaximumVelocity;                                   // 0x04F0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4F4[0x4];                                      // 0x04F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAnimationMontageDescriptor            EnterMontage;                                      // 0x04F8(0x0020)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FAnimationMontageDescriptor            UpdateMontage;                                     // 0x0518(0x0020)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FAnimationMontageDescriptor            ExitMontage;                                       // 0x0538(0x0020)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	TArray<class FName>                           EnterMontageVariantCycle;                          // 0x0558(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class FName>                           UpdateMontageVariantCycle;                         // 0x0568(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class FName>                           ExitMontageVariantCycle;                           // 0x0578(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class FName                                   SnapSocketName;                                    // 0x0588(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _canBeAttachedToAnyZone;                           // 0x0594(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isInterruptibleBySacrifice;                       // 0x0595(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IgnoreStun;                                        // 0x0596(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_597[0x1];                                      // 0x0597(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  _tags;                                             // 0x0598(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _objectStateTag;                                   // 0x05B8(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5C4[0x4];                                      // 0x05C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, struct FSecondaryInteractionProperties> _secondaryInteractions;                            // 0x05C8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	bool                                          _useHoldPrompt;                                    // 0x0618(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _allowInteractionInNarrowSpaces;                   // 0x0619(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _allowIKSensorDuringInteraction;                   // 0x061A(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _overrideSlashableRelativeLocation;                // 0x061B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_61C[0x4];                                      // 0x061C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                _slashableRelativeLocation;                        // 0x0620(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_638[0x8];                                      // 0x0638(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FActivationDefinition                  _activationDefinition;                             // 0x0640(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	bool                                          _startUpdateMontageDuringEnter;                    // 0x0668(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_669[0x7];                                      // 0x0669(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UInteractor*                            _interactor;                                       // 0x0670(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UInteractionDefinition*>         _mutuallyExclusiveInteractionsClient;              // 0x0678(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class UPrimitiveComponent*                    _zone;                                             // 0x0688(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EInputInteractionType                         _cancelInputType;                                  // 0x0690(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_691[0x7];                                      // 0x0691(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  _preventingTags;                                   // 0x0698(0x0020)(Edit, NativeAccessSpecifierPrivate)
	struct FGameplayTagContainer                  _disablingTags;                                    // 0x06B8(0x0020)(Edit, NativeAccessSpecifierPrivate)
	TArray<class UPlayerInteractionHandler*>      _evaluatingInteractionHandlers;                    // 0x06D8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FSecondaryInteractionProperties        DEPRECATED_SecondaryInteractionProperties;         // 0x06E8(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UTexture2D>              _interactionIconPromptOverride;                    // 0x0720(0x0038)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_758[0x20];                                     // 0x0758(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddDisablingTags(const struct FGameplayTag& TagToAdd);
	void AddMutuallyExclusiveInteraction(class UInteractionDefinition* Interaction);
	void AttachToInteractor(class UInteractor* Interactor);
	void AttachToZone(class UPrimitiveComponent* Zone);
	void Authority_CompleteCharge(class ADBDPlayer* Character);
	void Authority_OnInteractionAuthorized(class ADBDPlayer* Player);
	class ADBDPlayer* GetPlayerDependency(const class ADBDPlayer* InteractingPlayer);
	void InteractionEnteredDelegate__DelegateSignature(class ADBDPlayer* Player);
	void InteractionFinishedDelegate__DelegateSignature();
	void InteractionInterruptedDelegate__DelegateSignature();
	void OnInteractionAnimNotifyEvent(class FName NotifyId, class ADBDPlayer* Player);
	void OnInteractionCancelled(class ADBDPlayer* Player);
	void OnInteractionEnterEnd(class ADBDPlayer* Player);
	void OnInteractionEnterStart(class ADBDPlayer* Player, float ActualSnapTime);
	void OnInteractionEnterTick(class ADBDPlayer* Player, float DeltaTime);
	void OnInteractionExitEnd(class ADBDPlayer* Player);
	void OnInteractionExitStart(class ADBDPlayer* Player);
	void OnInteractionExitTick(class ADBDPlayer* Player, float DeltaTime);
	void OnInteractionFinished(class ADBDPlayer* Player, bool HasInteractionStarted);
	void OnInteractionInit(class ADBDPlayer* Player);
	void OnInteractionInterruptEnd(class ADBDPlayer* Player, class UInterruptionDefinition* CurrentInterruption, class ADBDPlayer* InterruptingPlayer);
	void OnInteractionInterruptStart(class ADBDPlayer* Player, class UInterruptionDefinition* CurrentInterruption, class ADBDPlayer* InterruptingPlayer);
	void OnInteractionInterruptStarted(class ADBDPlayer* Player, class UInterruptionDefinition* CurrentInterruption, class ADBDPlayer* InterruptingPlayer);
	void OnInteractionUpdateEnd(class ADBDPlayer* Player);
	void OnInteractionUpdateMontageReachedMiddle(class ADBDPlayer* Player);
	void OnInteractionUpdateStart(class ADBDPlayer* Player);
	void OnInteractionUpdateTick(class ADBDPlayer* Player, float DeltaTime);
	void OnInterruptorUpdateStart(class UInterruptionDefinition* CurrentInterruption, class ADBDPlayer* Interruptor, class ADBDPlayer* Interruptee);
	void OnUpdateMontageStart(class ADBDPlayer* Player);
	void RemoveDisablingTags(const struct FGameplayTag& TagToRemove);
	void RemoveExclusiveInteraction(class UInteractionDefinition* Interaction);
	void ResetSlashableLocation(class ADBDPlayer* Player);
	void SetSecondaryActionInputType(EInputInteractionType InputType);
	void UpdateSlashableLocation(class ADBDPlayer* Player);

	float CalculateSnapTimeForConstantMaxNormalMovementSpeed(const class ADBDPlayer* Player, float SpeedBoost) const;
	float CalculateSnapTimeForConstantSpeed(const class ADBDPlayer* Player, const float Speed) const;
	bool CanOverrideInteraction(const class UInteractionDefinition* Interaction) const;
	EInteractionComparisonPriority ComparePriorityToInteraction(const class UInteractionDefinition* Interaction) const;
	bool DoesPlayerHaveClearPath(const class ADBDPlayer* Player) const;
	float GetActionSpeedMultiplier(const class ADBDPlayer* Character) const;
	float GetActorHeightDelta(const class ADBDPlayer* Player) const;
	TArray<class AActor*> GetActorsToIgnoreOverlap() const;
	struct FVector GetActualSnapPointPosition(const class ADBDPlayer* Player) const;
	struct FVector GetActualSnapPointPositionAtStart(const class ADBDPlayer* Player) const;
	bool GetAllowNavigation(const class ADBDPlayer* Player) const;
	float GetChargePercent() const;
	struct FMontagePlaybackDefinition GetEnterAnimationPlayBackDefinition(const class ADBDPlayer* Player, bool Follower) const;
	struct FAnimationMontageDescriptor GetEnterMontage(const class ADBDPlayer* Player) const;
	struct FMontagePlaybackDefinition GetExitAnimationPlayBackDefinition(const class ADBDPlayer* Player, bool Follower) const;
	float GetExitAnimationPlayRate(const class ADBDPlayer* Player) const;
	struct FAnimationMontageDescriptor GetExitMontage(const class ADBDPlayer* Player) const;
	struct FVector GetFocalPointPosition(const class ADBDPlayer* Player) const;
	class AInteractable* GetInteractable() const;
	const class FText GetInteractionDescriptionText() const;
	float GetInteractionExitTime(const class ADBDPlayer* Character) const;
	class FString GetInteractionText(const class ADBDPlayer* Player) const;
	float GetInteractionTime(const class ADBDPlayer* Character) const;
	float GetInteractionTimeMultiplier(const class ADBDPlayer* Character) const;
	class UInteractor* GetInteractor() const;
	const TArray<class UInterruptionDefinition*> GetInterruptionDefinitions() const;
	struct FRotator GetRotationToSnapPoint(const class ADBDPlayer* Player) const;
	struct FRotator GetRotationToSnapPointAtStart(const class ADBDPlayer* Player) const;
	EInputInteractionType GetSecondaryActionInputType(const class UObject* WorldContextObject) const;
	struct FVector GetSlashableRelativeLocation() const;
	float GetSnapDistance(const class ADBDPlayer* Player) const;
	float GetSnapDistanceAtStart(const class ADBDPlayer* Player) const;
	struct FVector GetSnapPointPosition(const class ADBDPlayer* Player) const;
	struct FVector GetSnapPointPositionAtStart(const class ADBDPlayer* Player) const;
	class FName GetSnapSocketName(const class ADBDPlayer* Player) const;
	float GetSnapTime(const class ADBDPlayer* Player) const;
	float GetSnapTimeAtStart(const class ADBDPlayer* Player) const;
	struct FMontagePlaybackDefinition GetUpdateAnimationPlayBackDefinition(const class ADBDPlayer* Player, bool Follower) const;
	float GetUpdateAnimationPlayRate(const class ADBDPlayer* Player) const;
	struct FAnimationMontageDescriptor GetUpdateMontage(const class ADBDPlayer* Player) const;
	bool IsCancelable(const class ADBDPlayer* Player) const;
	bool IsCharacterFacingInteractorDirection(const class ADBDPlayer* Player) const;
	bool IsInputPressed(const class ADBDPlayer* Player) const;
	bool IsInteractableInPlayerView(const class ADBDPlayer* Player) const;
	bool IsInteractionDone(const class ADBDPlayer* Player, EInputInteractionType InteractionType) const;
	bool IsInteractionPossible(const class ADBDPlayer* Player, EInputInteractionType InteractionType, bool PerformClientCheck, bool PerformHeightCheck, bool IsBotPredictionCheck) const;
	bool IsInteractionPossibleBP(const class ADBDPlayer* Player, EInputInteractionType InteractionType) const;
	bool IsInteractionPossibleClient(const class ADBDPlayer* Player, EInputInteractionType InteractionType) const;
	bool IsInteractionUsingOffering(const class ADBDPlayer* Player) const;
	bool IsInterruptionPossible(const class ADBDPlayer* Interruptor, const class ADBDPlayer* Interruptee, const class UInterruptionDefinition* Interruption) const;
	bool IsSupportedCharacterType(const class ADBDPlayer* Player) const;
	bool ShouldStartUpdateMontageDuringEnter(const class ADBDPlayer* Character) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionDefinition">();
	}
	static class UInteractionDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionDefinition>();
	}
};
#pragma pack(pop)
static_assert(alignof(UInteractionDefinition) == 0x000010, "Wrong alignment on UInteractionDefinition");
static_assert(sizeof(UInteractionDefinition) == 0x000780, "Wrong size on UInteractionDefinition");
static_assert(offsetof(UInteractionDefinition, InteractionID) == 0x000300, "Member 'UInteractionDefinition::InteractionID' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, SnapTime) == 0x000310, "Member 'UInteractionDefinition::SnapTime' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, ResetCameraDuringSnap) == 0x000314, "Member 'UInteractionDefinition::ResetCameraDuringSnap' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, IsInteractionCancelled) == 0x000315, "Member 'UInteractionDefinition::IsInteractionCancelled' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, AllowStartInteractionFromHeldInput) == 0x000316, "Member 'UInteractionDefinition::AllowStartInteractionFromHeldInput' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, StopInteractionOnMontageComplete) == 0x000317, "Member 'UInteractionDefinition::StopInteractionOnMontageComplete' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, StopInteractionOnMontageBlendingOut) == 0x000318, "Member 'UInteractionDefinition::StopInteractionOnMontageBlendingOut' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, StopInteractionOnTimerExpire) == 0x000319, "Member 'UInteractionDefinition::StopInteractionOnTimerExpire' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, StopInteractionOnHeightDelta) == 0x00031A, "Member 'UInteractionDefinition::StopInteractionOnHeightDelta' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, StopEnterMontageOnExit) == 0x00031B, "Member 'UInteractionDefinition::StopEnterMontageOnExit' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, StopUpdateMontageOnExit) == 0x00031C, "Member 'UInteractionDefinition::StopUpdateMontageOnExit' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, IgnoreStrafeAnimFix) == 0x00031D, "Member 'UInteractionDefinition::IgnoreStrafeAnimFix' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, InteractionAnimation) == 0x00031E, "Member 'UInteractionDefinition::InteractionAnimation' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, CamperCanInteract) == 0x00031F, "Member 'UInteractionDefinition::CamperCanInteract' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, SlasherCanInteract) == 0x000320, "Member 'UInteractionDefinition::SlasherCanInteract' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, AllowInputPersistence) == 0x000321, "Member 'UInteractionDefinition::AllowInputPersistence' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, SnapPosition) == 0x000322, "Member 'UInteractionDefinition::SnapPosition' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, SweepOnFinalSnap) == 0x000323, "Member 'UInteractionDefinition::SweepOnFinalSnap' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, SnapRotation) == 0x000324, "Member 'UInteractionDefinition::SnapRotation' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, SnapStopDistance) == 0x000328, "Member 'UInteractionDefinition::SnapStopDistance' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, TestClearPathDuringSnap) == 0x00032C, "Member 'UInteractionDefinition::TestClearPathDuringSnap' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, MustBeClosestPlayerToSnapPoint) == 0x00032D, "Member 'UInteractionDefinition::MustBeClosestPlayerToSnapPoint' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, CheckInteractableIsInPlayerView) == 0x00032E, "Member 'UInteractionDefinition::CheckInteractableIsInPlayerView' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, CheckInteractableInViewSphereSweepRadius) == 0x000330, "Member 'UInteractionDefinition::CheckInteractableInViewSphereSweepRadius' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, CheckInteractableInViewOffset) == 0x000338, "Member 'UInteractionDefinition::CheckInteractableInViewOffset' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, CheckInteractableInViewOffsetDistanceToHitPoint) == 0x000350, "Member 'UInteractionDefinition::CheckInteractableInViewOffsetDistanceToHitPoint' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, IsInterruptibleIfTestClearPathDuringSnapFails) == 0x000354, "Member 'UInteractionDefinition::IsInterruptibleIfTestClearPathDuringSnapFails' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, TestPlayerOrientationOnSnap) == 0x000355, "Member 'UInteractionDefinition::TestPlayerOrientationOnSnap' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, ScaleEnterAnimationToTime) == 0x000356, "Member 'UInteractionDefinition::ScaleEnterAnimationToTime' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, ScaleMainAnimationToTime) == 0x000357, "Member 'UInteractionDefinition::ScaleMainAnimationToTime' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, ScaleExitAnimationToTime) == 0x000358, "Member 'UInteractionDefinition::ScaleExitAnimationToTime' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, SnapBackType) == 0x000359, "Member 'UInteractionDefinition::SnapBackType' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, SnapBackPositionType) == 0x00035A, "Member 'UInteractionDefinition::SnapBackPositionType' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, SnapBackPositionOffset) == 0x000360, "Member 'UInteractionDefinition::SnapBackPositionOffset' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, SnapToInitialRotationDuringSnapBack) == 0x000370, "Member 'UInteractionDefinition::SnapToInitialRotationDuringSnapBack' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, UseStartSnapTimeForSnapExitTime) == 0x000371, "Member 'UInteractionDefinition::UseStartSnapTimeForSnapExitTime' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, CanInteractWhileIncapacitated) == 0x000372, "Member 'UInteractionDefinition::CanInteractWhileIncapacitated' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, CanInteractWhileCloaked) == 0x000373, "Member 'UInteractionDefinition::CanInteractWhileCloaked' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, CanInteractWhileAttacking) == 0x000374, "Member 'UInteractionDefinition::CanInteractWhileAttacking' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, CanInteractWhileChainLinked) == 0x000375, "Member 'UInteractionDefinition::CanInteractWhileChainLinked' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, CanInteractWhileShocked) == 0x000376, "Member 'UInteractionDefinition::CanInteractWhileShocked' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, CanInteractWhileUnhookingSelf) == 0x000377, "Member 'UInteractionDefinition::CanInteractWhileUnhookingSelf' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, CanInteractWhileCarrying) == 0x000378, "Member 'UInteractionDefinition::CanInteractWhileCarrying' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, AllowNavigation) == 0x000379, "Member 'UInteractionDefinition::AllowNavigation' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, AllowNavigationInput) == 0x00037A, "Member 'UInteractionDefinition::AllowNavigationInput' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, AllowRotation) == 0x00037B, "Member 'UInteractionDefinition::AllowRotation' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, UseCameraMontageMode) == 0x00037C, "Member 'UInteractionDefinition::UseCameraMontageMode' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, OwnerBlocksAttack) == 0x00037D, "Member 'UInteractionDefinition::OwnerBlocksAttack' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, IsHighPriority) == 0x00037E, "Member 'UInteractionDefinition::IsHighPriority' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, AllowOverridingWhenNotForced) == 0x00037F, "Member 'UInteractionDefinition::AllowOverridingWhenNotForced' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, IgnoreOverlapOnInteractable) == 0x000380, "Member 'UInteractionDefinition::IgnoreOverlapOnInteractable' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, UseAuthoritativeMovement) == 0x000381, "Member 'UInteractionDefinition::UseAuthoritativeMovement' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, CanBeAuthoritativePushedDuringEnter) == 0x000382, "Member 'UInteractionDefinition::CanBeAuthoritativePushedDuringEnter' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, CanBeAuthoritativePushedDuringUpdate) == 0x000383, "Member 'UInteractionDefinition::CanBeAuthoritativePushedDuringUpdate' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, CanBeAuthoritativePushedDuringExit) == 0x000384, "Member 'UInteractionDefinition::CanBeAuthoritativePushedDuringExit' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, CanAuthoritativePush) == 0x000385, "Member 'UInteractionDefinition::CanAuthoritativePush' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, CancelOnHit) == 0x000386, "Member 'UInteractionDefinition::CancelOnHit' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, CancelOnAttack) == 0x000387, "Member 'UInteractionDefinition::CancelOnAttack' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, HideItem) == 0x000388, "Member 'UInteractionDefinition::HideItem' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, ContinueCachingLastSafeItemDropLocation) == 0x000389, "Member 'UInteractionDefinition::ContinueCachingLastSafeItemDropLocation' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, AutoBindToParentInteractor) == 0x00038A, "Member 'UInteractionDefinition::AutoBindToParentInteractor' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, AutoBindToParentZone) == 0x00038B, "Member 'UInteractionDefinition::AutoBindToParentZone' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, CancelOnMoveInitialDelay) == 0x00038C, "Member 'UInteractionDefinition::CancelOnMoveInitialDelay' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, CancelOnMoveInput) == 0x000390, "Member 'UInteractionDefinition::CancelOnMoveInput' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, CancelOnMoveInputOnlyWhenRunning) == 0x000394, "Member 'UInteractionDefinition::CancelOnMoveInputOnlyWhenRunning' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, BotsCanCancelOnMoveInput) == 0x000395, "Member 'UInteractionDefinition::BotsCanCancelOnMoveInput' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, ProgressBasedSkillChecks) == 0x000398, "Member 'UInteractionDefinition::ProgressBasedSkillChecks' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, CanCrouch) == 0x0003A8, "Member 'UInteractionDefinition::CanCrouch' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, AffectsStillness) == 0x0003A9, "Member 'UInteractionDefinition::AffectsStillness' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, ConsideredIdle) == 0x0003AA, "Member 'UInteractionDefinition::ConsideredIdle' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, BlockSelfInteract) == 0x0003AB, "Member 'UInteractionDefinition::BlockSelfInteract' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, InteractionTime) == 0x0003AC, "Member 'UInteractionDefinition::InteractionTime' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, InteractionInputType) == 0x0003B0, "Member 'UInteractionDefinition::InteractionInputType' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, NoInputInteraction) == 0x0003B1, "Member 'UInteractionDefinition::NoInputInteraction' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, StopInteractionOnInputRelease) == 0x0003B2, "Member 'UInteractionDefinition::StopInteractionOnInputRelease' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, AllowHitMontageWhenInteracting) == 0x0003B3, "Member 'UInteractionDefinition::AllowHitMontageWhenInteracting' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, ShowBasicInteractionIcon) == 0x0003B4, "Member 'UInteractionDefinition::ShowBasicInteractionIcon' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, _interruptionDefinitions) == 0x0003B8, "Member 'UInteractionDefinition::_interruptionDefinitions' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, OnInteractionEnteredDelegate) == 0x0003C8, "Member 'UInteractionDefinition::OnInteractionEnteredDelegate' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, OnInteractionFinishedDelegate) == 0x000408, "Member 'UInteractionDefinition::OnInteractionFinishedDelegate' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, OnInteractionInterruptedStartDelegate) == 0x000430, "Member 'UInteractionDefinition::OnInteractionInterruptedStartDelegate' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, OnInteractionInterruptedStartedDelegate) == 0x000440, "Member 'UInteractionDefinition::OnInteractionInterruptedStartedDelegate' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, OnInteractionInterruptedEndDelegate) == 0x000450, "Member 'UInteractionDefinition::OnInteractionInterruptedEndDelegate' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, OnInteractionAnimNotify) == 0x000460, "Member 'UInteractionDefinition::OnInteractionAnimNotify' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, DebugUnavailability) == 0x000470, "Member 'UInteractionDefinition::DebugUnavailability' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, SecondaryActionInputType) == 0x000471, "Member 'UInteractionDefinition::SecondaryActionInputType' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, NavigationSpeedCurveEnter) == 0x000490, "Member 'UInteractionDefinition::NavigationSpeedCurveEnter' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, NavigationSpeedCurve) == 0x000498, "Member 'UInteractionDefinition::NavigationSpeedCurve' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, NavigationSpeedCurveExit) == 0x0004A0, "Member 'UInteractionDefinition::NavigationSpeedCurveExit' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, _shouldCheckInteractedUpon) == 0x0004A8, "Member 'UInteractionDefinition::_shouldCheckInteractedUpon' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, OwnershipUsability) == 0x0004A9, "Member 'UInteractionDefinition::OwnershipUsability' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, ExitInteractionTime) == 0x0004AC, "Member 'UInteractionDefinition::ExitInteractionTime' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, ApplyModifiersToExitTime) == 0x0004B0, "Member 'UInteractionDefinition::ApplyModifiersToExitTime' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, InteractionDescriptionText) == 0x0004B8, "Member 'UInteractionDefinition::InteractionDescriptionText' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, InteractionCanBeToggled) == 0x0004D0, "Member 'UInteractionDefinition::InteractionCanBeToggled' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, IsOverridingInputToggleReleasePromptMessage) == 0x0004D1, "Member 'UInteractionDefinition::IsOverridingInputToggleReleasePromptMessage' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, InputToggleReleasePromptMessage) == 0x0004D8, "Member 'UInteractionDefinition::InputToggleReleasePromptMessage' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, IgnoreSprintToCancelSetting) == 0x0004E8, "Member 'UInteractionDefinition::IgnoreSprintToCancelSetting' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, ForceWithSprintToCancelSetting) == 0x0004E9, "Member 'UInteractionDefinition::ForceWithSprintToCancelSetting' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, InteractionHeightDeltaMax) == 0x0004EC, "Member 'UInteractionDefinition::InteractionHeightDeltaMax' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, MaximumVelocity) == 0x0004F0, "Member 'UInteractionDefinition::MaximumVelocity' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, EnterMontage) == 0x0004F8, "Member 'UInteractionDefinition::EnterMontage' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, UpdateMontage) == 0x000518, "Member 'UInteractionDefinition::UpdateMontage' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, ExitMontage) == 0x000538, "Member 'UInteractionDefinition::ExitMontage' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, EnterMontageVariantCycle) == 0x000558, "Member 'UInteractionDefinition::EnterMontageVariantCycle' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, UpdateMontageVariantCycle) == 0x000568, "Member 'UInteractionDefinition::UpdateMontageVariantCycle' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, ExitMontageVariantCycle) == 0x000578, "Member 'UInteractionDefinition::ExitMontageVariantCycle' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, SnapSocketName) == 0x000588, "Member 'UInteractionDefinition::SnapSocketName' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, _canBeAttachedToAnyZone) == 0x000594, "Member 'UInteractionDefinition::_canBeAttachedToAnyZone' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, _isInterruptibleBySacrifice) == 0x000595, "Member 'UInteractionDefinition::_isInterruptibleBySacrifice' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, IgnoreStun) == 0x000596, "Member 'UInteractionDefinition::IgnoreStun' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, _tags) == 0x000598, "Member 'UInteractionDefinition::_tags' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, _objectStateTag) == 0x0005B8, "Member 'UInteractionDefinition::_objectStateTag' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, _secondaryInteractions) == 0x0005C8, "Member 'UInteractionDefinition::_secondaryInteractions' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, _useHoldPrompt) == 0x000618, "Member 'UInteractionDefinition::_useHoldPrompt' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, _allowInteractionInNarrowSpaces) == 0x000619, "Member 'UInteractionDefinition::_allowInteractionInNarrowSpaces' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, _allowIKSensorDuringInteraction) == 0x00061A, "Member 'UInteractionDefinition::_allowIKSensorDuringInteraction' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, _overrideSlashableRelativeLocation) == 0x00061B, "Member 'UInteractionDefinition::_overrideSlashableRelativeLocation' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, _slashableRelativeLocation) == 0x000620, "Member 'UInteractionDefinition::_slashableRelativeLocation' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, _activationDefinition) == 0x000640, "Member 'UInteractionDefinition::_activationDefinition' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, _startUpdateMontageDuringEnter) == 0x000668, "Member 'UInteractionDefinition::_startUpdateMontageDuringEnter' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, _interactor) == 0x000670, "Member 'UInteractionDefinition::_interactor' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, _mutuallyExclusiveInteractionsClient) == 0x000678, "Member 'UInteractionDefinition::_mutuallyExclusiveInteractionsClient' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, _zone) == 0x000688, "Member 'UInteractionDefinition::_zone' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, _cancelInputType) == 0x000690, "Member 'UInteractionDefinition::_cancelInputType' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, _preventingTags) == 0x000698, "Member 'UInteractionDefinition::_preventingTags' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, _disablingTags) == 0x0006B8, "Member 'UInteractionDefinition::_disablingTags' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, _evaluatingInteractionHandlers) == 0x0006D8, "Member 'UInteractionDefinition::_evaluatingInteractionHandlers' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, DEPRECATED_SecondaryInteractionProperties) == 0x0006E8, "Member 'UInteractionDefinition::DEPRECATED_SecondaryInteractionProperties' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, _interactionIconPromptOverride) == 0x000720, "Member 'UInteractionDefinition::_interactionIconPromptOverride' has a wrong offset!");

// Class DeadByDaylight.TileBank
// 0x0160 (0x0190 - 0x0030)
class UTileBank final : public UObject
{
public:
	uint8                                         Pad_30[0x140];                                     // 0x0030(0x0140)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ATile*>                          _outOfWorldTileBlueprints;                         // 0x0170(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class ATile*>                          _allTileBlueprints;                                // 0x0180(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TileBank">();
	}
	static class UTileBank* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTileBank>();
	}
};
static_assert(alignof(UTileBank) == 0x000008, "Wrong alignment on UTileBank");
static_assert(sizeof(UTileBank) == 0x000190, "Wrong size on UTileBank");
static_assert(offsetof(UTileBank, _outOfWorldTileBlueprints) == 0x000170, "Member 'UTileBank::_outOfWorldTileBlueprints' has a wrong offset!");
static_assert(offsetof(UTileBank, _allTileBlueprints) == 0x000180, "Member 'UTileBank::_allTileBlueprints' has a wrong offset!");

// Class DeadByDaylight.Skill
// 0x0068 (0x0348 - 0x02E0)
class USkill : public UCompetence
{
public:
	struct FGameplayModifierData                  ModifierData;                                      // 0x02E0(0x0030)(Edit, Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_310[0x30];                                     // 0x0310(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSkillInitializationData               _skillInitializationData;                          // 0x0340(0x0001)(Net, Transient, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_341[0x7];                                      // 0x0341(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_SkillInitializationData();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Skill">();
	}
	static class USkill* GetDefaultObj()
	{
		return GetDefaultObjImpl<USkill>();
	}
};
static_assert(alignof(USkill) == 0x000008, "Wrong alignment on USkill");
static_assert(sizeof(USkill) == 0x000348, "Wrong size on USkill");
static_assert(offsetof(USkill, ModifierData) == 0x0002E0, "Member 'USkill::ModifierData' has a wrong offset!");
static_assert(offsetof(USkill, _skillInitializationData) == 0x000340, "Member 'USkill::_skillInitializationData' has a wrong offset!");

// Class DeadByDaylight.DBDPartyFacade
// 0x0010 (0x04D8 - 0x04C8)
class UDBDPartyFacade final : public UPartyFacade
{
public:
	uint8                                         Pad_4C8[0x10];                                     // 0x04C8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDPartyFacade">();
	}
	static class UDBDPartyFacade* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDPartyFacade>();
	}
};
static_assert(alignof(UDBDPartyFacade) == 0x000008, "Wrong alignment on UDBDPartyFacade");
static_assert(sizeof(UDBDPartyFacade) == 0x0004D8, "Wrong size on UDBDPartyFacade");

// Class DeadByDaylight.ActorSpawner2Component
// 0x0000 (0x0310 - 0x0310)
class UActorSpawner2Component final : public UChildActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActorSpawner2Component">();
	}
	static class UActorSpawner2Component* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActorSpawner2Component>();
	}
};
static_assert(alignof(UActorSpawner2Component) == 0x000010, "Wrong alignment on UActorSpawner2Component");
static_assert(sizeof(UActorSpawner2Component) == 0x000310, "Wrong size on UActorSpawner2Component");

// Class DeadByDaylight.DBDTimeTravelManager
// 0x0070 (0x00A0 - 0x0030)
class UDBDTimeTravelManager final : public UObject
{
public:
	uint8                                         Pad_30[0x70];                                      // 0x0030(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDTimeTravelManager">();
	}
	static class UDBDTimeTravelManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDTimeTravelManager>();
	}
};
static_assert(alignof(UDBDTimeTravelManager) == 0x000008, "Wrong alignment on UDBDTimeTravelManager");
static_assert(sizeof(UDBDTimeTravelManager) == 0x0000A0, "Wrong size on UDBDTimeTravelManager");

// Class DeadByDaylight.AssetLibrary
// 0x0080 (0x00B0 - 0x0030)
class UAssetLibrary : public UObject
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UObjectLibrary*                         _objectLibrary;                                    // 0x0038(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_40[0x64];                                      // 0x0040(0x0064)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SecondsDelayBetweenBatch;                          // 0x00A4(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AssetLibrary">();
	}
	static class UAssetLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAssetLibrary>();
	}
};
static_assert(alignof(UAssetLibrary) == 0x000008, "Wrong alignment on UAssetLibrary");
static_assert(sizeof(UAssetLibrary) == 0x0000B0, "Wrong size on UAssetLibrary");
static_assert(offsetof(UAssetLibrary, _objectLibrary) == 0x000038, "Member 'UAssetLibrary::_objectLibrary' has a wrong offset!");
static_assert(offsetof(UAssetLibrary, SecondsDelayBetweenBatch) == 0x0000A4, "Member 'UAssetLibrary::SecondsDelayBetweenBatch' has a wrong offset!");

// Class DeadByDaylight.Interactable
// 0x0108 (0x03A8 - 0x02A0)
class AInteractable : public AActor
{
public:
	uint8                                         Pad_2A0[0x68];                                     // 0x02A0(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	class UPrimitiveComponent*                    _singleZone;                                       // 0x0308(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _useSingleZone;                                    // 0x0310(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_311[0x7];                                      // 0x0311(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UInteractor*>                    _interactors;                                      // 0x0318(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UInteractableTransformOptimizer*        _transformOptimizer;                               // 0x0328(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_330[0x20];                                     // 0x0330(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class UPrimitiveComponent*, struct FInteractionArray> _zoneToInteractions;                               // 0x0350(0x0050)(Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class UGameplayTagContainerComponent*         _interactableObjectState;                          // 0x03A0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void AttachEveryInteractionToZone(class UPrimitiveComponent* Zone);
	void AuthorityRequestCancelOngoingInteractions(bool OnlyOnHitCancelableInteractions);
	void OnInteractorLockChanged(bool Locked, class ADBDPlayer* InteractingPlayer);
	void OnLevelReadyToPlay();
	void OnLevelReadyToPlay_Native();
	void PreInterruptionEvent(class ADBDPlayer* Interruptor, class ADBDPlayer* Interruptee, class UInterruptionDefinition* Interruption);
	void SetInteractorsUsable(bool Usable, class UInteractor* Exception);
	void SetSingleZone(class UPrimitiveComponent* Zone);

	TArray<class ADBDPlayer*> Authority_GetInteractingPlayers() const;
	struct FVector GetFocalPointPosition(const class ADBDPlayer* Player, const class UInteractionDefinition* Definition) const;
	TArray<class ADBDPlayer*> GetInteractingPlayersRaw() const;
	TArray<class UInteractor*> GetInteractors() const;
	class UGameplayTagContainerComponent* GetObjectState() const;
	class ADBDPlayer* GetPlayerOwner() const;
	bool HasAnOngoingInteraction() const;
	bool IsInteractingWith(const class ADBDPlayer* Player) const;
	bool IsInteractionDone(class ADBDPlayer* Player, const class UInteractor* Interactor, const class UInteractionDefinition* Definition, EInputInteractionType InteractionType) const;
	bool IsInterruptionPossible(const class ADBDPlayer* Interruptor, const class ADBDPlayer* Interruptee, const class UInteractor* Interactor, const class UInteractionDefinition* Definition, const class UInterruptionDefinition* Interruption) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Interactable">();
	}
	static class AInteractable* GetDefaultObj()
	{
		return GetDefaultObjImpl<AInteractable>();
	}
};
static_assert(alignof(AInteractable) == 0x000008, "Wrong alignment on AInteractable");
static_assert(sizeof(AInteractable) == 0x0003A8, "Wrong size on AInteractable");
static_assert(offsetof(AInteractable, _singleZone) == 0x000308, "Member 'AInteractable::_singleZone' has a wrong offset!");
static_assert(offsetof(AInteractable, _useSingleZone) == 0x000310, "Member 'AInteractable::_useSingleZone' has a wrong offset!");
static_assert(offsetof(AInteractable, _interactors) == 0x000318, "Member 'AInteractable::_interactors' has a wrong offset!");
static_assert(offsetof(AInteractable, _transformOptimizer) == 0x000328, "Member 'AInteractable::_transformOptimizer' has a wrong offset!");
static_assert(offsetof(AInteractable, _zoneToInteractions) == 0x000350, "Member 'AInteractable::_zoneToInteractions' has a wrong offset!");
static_assert(offsetof(AInteractable, _interactableObjectState) == 0x0003A0, "Member 'AInteractable::_interactableObjectState' has a wrong offset!");

// Class DeadByDaylight.OfferingSequenceAssets
// 0x0030 (0x02D0 - 0x02A0)
class AOfferingSequenceAssets final : public AActor
{
public:
	float                                         SpaceBetweenCards;                                 // 0x02A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A4[0x4];                                      // 0x02A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AOfferingCard>              DefaultCardClass;                                  // 0x02A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UOfferingCardAnim>          DefaultCardAnimation;                              // 0x02B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FOfferingRevealDelays>          OfferingRevealDelays;                              // 0x02B8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class AActor*                                 CardsParent;                                       // 0x02C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void PlayFadeIn();
	void PlayFadeOut();
	void PlaySmoke();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OfferingSequenceAssets">();
	}
	static class AOfferingSequenceAssets* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOfferingSequenceAssets>();
	}
};
static_assert(alignof(AOfferingSequenceAssets) == 0x000008, "Wrong alignment on AOfferingSequenceAssets");
static_assert(sizeof(AOfferingSequenceAssets) == 0x0002D0, "Wrong size on AOfferingSequenceAssets");
static_assert(offsetof(AOfferingSequenceAssets, SpaceBetweenCards) == 0x0002A0, "Member 'AOfferingSequenceAssets::SpaceBetweenCards' has a wrong offset!");
static_assert(offsetof(AOfferingSequenceAssets, DefaultCardClass) == 0x0002A8, "Member 'AOfferingSequenceAssets::DefaultCardClass' has a wrong offset!");
static_assert(offsetof(AOfferingSequenceAssets, DefaultCardAnimation) == 0x0002B0, "Member 'AOfferingSequenceAssets::DefaultCardAnimation' has a wrong offset!");
static_assert(offsetof(AOfferingSequenceAssets, OfferingRevealDelays) == 0x0002B8, "Member 'AOfferingSequenceAssets::OfferingRevealDelays' has a wrong offset!");
static_assert(offsetof(AOfferingSequenceAssets, CardsParent) == 0x0002C8, "Member 'AOfferingSequenceAssets::CardsParent' has a wrong offset!");

// Class DeadByDaylight.Collectable
// 0x01A8 (0x0550 - 0x03A8)
class ACollectable : public AInteractable
{
public:
	uint8                                         Pad_3A8[0x48];                                     // 0x03A8(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          DisplayUsePercent;                                 // 0x03F0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAtlantaItemProgressionBarEnum                ProgressBar;                                       // 0x03F1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          OverrideItemIndex;                                 // 0x03F2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3F3[0x1];                                      // 0x03F3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         OverridenItemIndex;                                // 0x03F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          StrafeOnUse;                                       // 0x03F8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          VisibleWhenEquipped;                               // 0x03F9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          StopRunningOnUse;                                  // 0x03FA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemHandPosition                             HandPosition;                                      // 0x03FB(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DisableArmOverrideDuringInteractions;              // 0x03FC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasUseInteraction;                                 // 0x03FD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RemoveInteractionsOnInteractorChange;              // 0x03FE(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollectableCategory                          Category;                                          // 0x03FF(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ItemId;                                            // 0x0400(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          FromPlayerSpawn;                                   // 0x040C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_40D[0x3];                                      // 0x040D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UItemModifier*                          BaseItemModifier;                                  // 0x0410(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UItemModifier*                          ItemModifier1;                                     // 0x0418(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UItemModifier*                          ItemModifier2;                                     // 0x0420(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShouldRegisterToOnSurvivorAdded;                   // 0x0428(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_429[0x67];                                     // 0x0429(0x0067)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          BeingCollected;                                    // 0x0490(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          BeingDropped;                                      // 0x0491(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _beingConsumedByEntity;                            // 0x0492(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_493[0x5];                                      // 0x0493(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UInteractor*                            _itemInteractor;                                   // 0x0498(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDBDSkeletalMeshComponentBudgeted*      _mesh;                                             // 0x04A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EInputInteractionType                         _displayedInputType;                               // 0x04A8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isKeyPromptForceDisabled;                         // 0x04A9(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isBoundToFirstCollector;                          // 0x04AA(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isCursedItem;                                     // 0x04AB(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isSpecialItem;                                    // 0x04AC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _useInventoryCount;                                // 0x04AD(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAttachToSocketNameEnum                       _attachToSocketName;                               // 0x04AE(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EInventoryType                                _collectInInventoryType;                           // 0x04AF(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4B0[0x18];                                     // 0x04B0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        _placementOrigin;                                  // 0x04C8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4D0[0x18];                                     // 0x04D0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class ADBDPlayer*                             _collector;                                        // 0x04E8(0x0008)(Net, ZeroConstructor, Transient, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ADBDPlayer*                             _firstCollector;                                   // 0x04F0(0x0008)(Net, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ECollectableState                             _state;                                            // 0x04F8(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4F9[0x7];                                      // 0x04F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UItemAddon*>                     _itemAddons;                                       // 0x0500(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UItemModifier*>                  _itemModifiers;                                    // 0x0510(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	int32                                         _itemCount;                                        // 0x0520(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_524[0x4];                                      // 0x0524(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ASearchable*                            _attachedSearchable;                               // 0x0528(0x0008)(Net, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTag                           _stateTagForCollector;                             // 0x0530(0x000C)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTag                           _stateTagEquippedForCollector;                     // 0x053C(0x000C)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ELoadoutItemType                              _itemType;                                         // 0x0548(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _discardOnDrop;                                    // 0x0549(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _discardWhenConsumed;                              // 0x054A(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _disableAttachmentReplication;                     // 0x054B(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_54C[0x2];                                      // 0x054C(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _isInUse;                                          // 0x054E(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _aimOnUse;                                         // 0x054F(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	bool Authority_AddItemAddon(class UItemAddon* Addon);
	void Authority_Discard();
	void Authority_OnCollectorEndPlay(class AActor* Actor, EEndPlayReason EndPlayReason);
	void Authority_OnConsumed(bool ForceDiscard);
	void Authority_RemoveItemAddon(class UItemAddon* Addon);
	void Authority_Use();
	void Authority_UseReleased();
	void BP_OnSurvivorAdded(class ACamperPlayer* Survivor);
	void CallOnCollectorSetBP(TDelegate<void(class ADBDPlayer* Player)> Callback);
	void OnCollectorSetBPDelegate__DelegateSignature(class ADBDPlayer* Player);
	void DebugPrintStats();
	TArray<class UItemAddon*> GetItemAddons();
	void Local_Dropped_Location(class ADBDPlayer* DroppedBy, const struct FVector& Location, const struct FRotator& Rotation);
	void Multicast_Collected(class ADBDPlayer* Collector, EInventoryType InventoryType);
	void Multicast_Dropped(class ADBDPlayer* DroppedBy, const struct FVector& Location, const struct FRotator& Rotation, EItemDropType ItemDropType);
	void Multicast_RemoveAllAddons();
	void Multicast_RemoveItemAddon(class UItemAddon* Addon);
	void Multicast_Use();
	void Multicast_UseReleased(class ADBDPlayer* Collector);
	void OnActivateDissolveItem();
	void OnAddonsAdded(const TArray<class UItemAddon*>& Addons);
	void OnAddonsRemoved(const TArray<class UItemAddon*>& Addons);
	void OnCollectorSet(class ADBDPlayer* Collector);
	void OnCollectorSetBP__DelegateSignature(class ADBDPlayer* Player);
	void OnCustomizationChanged();
	void OnDropped(class ADBDPlayer* DroppingPlayer);
	void OnPostItemAddonsCreation(class ADBDPlayer* Player);
	void OnRep_Collector(class ADBDPlayer* OldCollector);
	void OnRep_State();
	void OnUse();
	void OnUseReleased(class ADBDPlayer* Collector);
	void SetCount(int32 Count);
	void SetDisplayedInputType(const EInputInteractionType DisplayedInputType);
	void SetIsKeyPromptForceDisabled(const bool IsKeyPromptForceDisabled);
	void SetItemInteractor(class UInteractor* Interactor);
	void SetVisibilityEvent(bool Visibility);

	bool CanBeCollected(const class ADBDPlayer* Collector, const bool AssumeWillDropItem) const;
	bool CanBeDropped(const class ADBDPlayer* Dropper) const;
	bool CanUse(const class ADBDPlayer* Player) const;
	class ADBDPlayer* GetCollector() const;
	int32 GetCount() const;
	EInputInteractionType GetDisplayedInputType() const;
	class FString GetIconFilePath() const;
	uint8 GetItemIconIndex() const;
	class UInteractor* GetItemInteractor() const;
	float GetModifierMax(const struct FGameplayTag& ModifierType, float DefaultValue) const;
	float GetModifierSum(const struct FGameplayTag& ModifierType, float DefaultValue) const;
	float GetUsePercentLeft() const;
	bool HasGameplayModifierFlag(const struct FGameplayTag& ModifierFlag) const;
	bool IsCollected() const;
	bool IsCountDisplayForced() const;
	bool IsCursedItem() const;
	bool IsEquipped() const;
	bool IsInSearchable() const;
	bool IsKeyPromptForceDisabled() const;
	bool IsLocallyControlled() const;
	bool IsOnGround() const;
	bool IsPickable() const;
	bool IsRechargeable() const;
	bool IsSpecialItem() const;
	bool IsStored() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Collectable">();
	}
	static class ACollectable* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACollectable>();
	}
};
static_assert(alignof(ACollectable) == 0x000008, "Wrong alignment on ACollectable");
static_assert(sizeof(ACollectable) == 0x000550, "Wrong size on ACollectable");
static_assert(offsetof(ACollectable, DisplayUsePercent) == 0x0003F0, "Member 'ACollectable::DisplayUsePercent' has a wrong offset!");
static_assert(offsetof(ACollectable, ProgressBar) == 0x0003F1, "Member 'ACollectable::ProgressBar' has a wrong offset!");
static_assert(offsetof(ACollectable, OverrideItemIndex) == 0x0003F2, "Member 'ACollectable::OverrideItemIndex' has a wrong offset!");
static_assert(offsetof(ACollectable, OverridenItemIndex) == 0x0003F4, "Member 'ACollectable::OverridenItemIndex' has a wrong offset!");
static_assert(offsetof(ACollectable, StrafeOnUse) == 0x0003F8, "Member 'ACollectable::StrafeOnUse' has a wrong offset!");
static_assert(offsetof(ACollectable, VisibleWhenEquipped) == 0x0003F9, "Member 'ACollectable::VisibleWhenEquipped' has a wrong offset!");
static_assert(offsetof(ACollectable, StopRunningOnUse) == 0x0003FA, "Member 'ACollectable::StopRunningOnUse' has a wrong offset!");
static_assert(offsetof(ACollectable, HandPosition) == 0x0003FB, "Member 'ACollectable::HandPosition' has a wrong offset!");
static_assert(offsetof(ACollectable, DisableArmOverrideDuringInteractions) == 0x0003FC, "Member 'ACollectable::DisableArmOverrideDuringInteractions' has a wrong offset!");
static_assert(offsetof(ACollectable, HasUseInteraction) == 0x0003FD, "Member 'ACollectable::HasUseInteraction' has a wrong offset!");
static_assert(offsetof(ACollectable, RemoveInteractionsOnInteractorChange) == 0x0003FE, "Member 'ACollectable::RemoveInteractionsOnInteractorChange' has a wrong offset!");
static_assert(offsetof(ACollectable, Category) == 0x0003FF, "Member 'ACollectable::Category' has a wrong offset!");
static_assert(offsetof(ACollectable, ItemId) == 0x000400, "Member 'ACollectable::ItemId' has a wrong offset!");
static_assert(offsetof(ACollectable, FromPlayerSpawn) == 0x00040C, "Member 'ACollectable::FromPlayerSpawn' has a wrong offset!");
static_assert(offsetof(ACollectable, BaseItemModifier) == 0x000410, "Member 'ACollectable::BaseItemModifier' has a wrong offset!");
static_assert(offsetof(ACollectable, ItemModifier1) == 0x000418, "Member 'ACollectable::ItemModifier1' has a wrong offset!");
static_assert(offsetof(ACollectable, ItemModifier2) == 0x000420, "Member 'ACollectable::ItemModifier2' has a wrong offset!");
static_assert(offsetof(ACollectable, ShouldRegisterToOnSurvivorAdded) == 0x000428, "Member 'ACollectable::ShouldRegisterToOnSurvivorAdded' has a wrong offset!");
static_assert(offsetof(ACollectable, BeingCollected) == 0x000490, "Member 'ACollectable::BeingCollected' has a wrong offset!");
static_assert(offsetof(ACollectable, BeingDropped) == 0x000491, "Member 'ACollectable::BeingDropped' has a wrong offset!");
static_assert(offsetof(ACollectable, _beingConsumedByEntity) == 0x000492, "Member 'ACollectable::_beingConsumedByEntity' has a wrong offset!");
static_assert(offsetof(ACollectable, _itemInteractor) == 0x000498, "Member 'ACollectable::_itemInteractor' has a wrong offset!");
static_assert(offsetof(ACollectable, _mesh) == 0x0004A0, "Member 'ACollectable::_mesh' has a wrong offset!");
static_assert(offsetof(ACollectable, _displayedInputType) == 0x0004A8, "Member 'ACollectable::_displayedInputType' has a wrong offset!");
static_assert(offsetof(ACollectable, _isKeyPromptForceDisabled) == 0x0004A9, "Member 'ACollectable::_isKeyPromptForceDisabled' has a wrong offset!");
static_assert(offsetof(ACollectable, _isBoundToFirstCollector) == 0x0004AA, "Member 'ACollectable::_isBoundToFirstCollector' has a wrong offset!");
static_assert(offsetof(ACollectable, _isCursedItem) == 0x0004AB, "Member 'ACollectable::_isCursedItem' has a wrong offset!");
static_assert(offsetof(ACollectable, _isSpecialItem) == 0x0004AC, "Member 'ACollectable::_isSpecialItem' has a wrong offset!");
static_assert(offsetof(ACollectable, _useInventoryCount) == 0x0004AD, "Member 'ACollectable::_useInventoryCount' has a wrong offset!");
static_assert(offsetof(ACollectable, _attachToSocketName) == 0x0004AE, "Member 'ACollectable::_attachToSocketName' has a wrong offset!");
static_assert(offsetof(ACollectable, _collectInInventoryType) == 0x0004AF, "Member 'ACollectable::_collectInInventoryType' has a wrong offset!");
static_assert(offsetof(ACollectable, _placementOrigin) == 0x0004C8, "Member 'ACollectable::_placementOrigin' has a wrong offset!");
static_assert(offsetof(ACollectable, _collector) == 0x0004E8, "Member 'ACollectable::_collector' has a wrong offset!");
static_assert(offsetof(ACollectable, _firstCollector) == 0x0004F0, "Member 'ACollectable::_firstCollector' has a wrong offset!");
static_assert(offsetof(ACollectable, _state) == 0x0004F8, "Member 'ACollectable::_state' has a wrong offset!");
static_assert(offsetof(ACollectable, _itemAddons) == 0x000500, "Member 'ACollectable::_itemAddons' has a wrong offset!");
static_assert(offsetof(ACollectable, _itemModifiers) == 0x000510, "Member 'ACollectable::_itemModifiers' has a wrong offset!");
static_assert(offsetof(ACollectable, _itemCount) == 0x000520, "Member 'ACollectable::_itemCount' has a wrong offset!");
static_assert(offsetof(ACollectable, _attachedSearchable) == 0x000528, "Member 'ACollectable::_attachedSearchable' has a wrong offset!");
static_assert(offsetof(ACollectable, _stateTagForCollector) == 0x000530, "Member 'ACollectable::_stateTagForCollector' has a wrong offset!");
static_assert(offsetof(ACollectable, _stateTagEquippedForCollector) == 0x00053C, "Member 'ACollectable::_stateTagEquippedForCollector' has a wrong offset!");
static_assert(offsetof(ACollectable, _itemType) == 0x000548, "Member 'ACollectable::_itemType' has a wrong offset!");
static_assert(offsetof(ACollectable, _discardOnDrop) == 0x000549, "Member 'ACollectable::_discardOnDrop' has a wrong offset!");
static_assert(offsetof(ACollectable, _discardWhenConsumed) == 0x00054A, "Member 'ACollectable::_discardWhenConsumed' has a wrong offset!");
static_assert(offsetof(ACollectable, _disableAttachmentReplication) == 0x00054B, "Member 'ACollectable::_disableAttachmentReplication' has a wrong offset!");
static_assert(offsetof(ACollectable, _isInUse) == 0x00054E, "Member 'ACollectable::_isInUse' has a wrong offset!");
static_assert(offsetof(ACollectable, _aimOnUse) == 0x00054F, "Member 'ACollectable::_aimOnUse' has a wrong offset!");

// Class DeadByDaylight.DecalMaskedMaterialsList
// 0x0060 (0x0098 - 0x0038)
class UDecalMaskedMaterialsList final : public UDataAsset
{
public:
	class UStaticMesh*                            DecalPlaneStaticMesh;                              // 0x0038(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DecalPlaneExtent;                                  // 0x0040(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, class UMaterialInterface*>  DecalMaskedMaterials;                              // 0x0048(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DecalMaskedMaterialsList">();
	}
	static class UDecalMaskedMaterialsList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDecalMaskedMaterialsList>();
	}
};
static_assert(alignof(UDecalMaskedMaterialsList) == 0x000008, "Wrong alignment on UDecalMaskedMaterialsList");
static_assert(sizeof(UDecalMaskedMaterialsList) == 0x000098, "Wrong size on UDecalMaskedMaterialsList");
static_assert(offsetof(UDecalMaskedMaterialsList, DecalPlaneStaticMesh) == 0x000038, "Member 'UDecalMaskedMaterialsList::DecalPlaneStaticMesh' has a wrong offset!");
static_assert(offsetof(UDecalMaskedMaterialsList, DecalPlaneExtent) == 0x000040, "Member 'UDecalMaskedMaterialsList::DecalPlaneExtent' has a wrong offset!");
static_assert(offsetof(UDecalMaskedMaterialsList, DecalMaskedMaterials) == 0x000048, "Member 'UDecalMaskedMaterialsList::DecalMaskedMaterials' has a wrong offset!");

// Class DeadByDaylight.DBDInstancedFoliageComponent
// 0x0068 (0x0110 - 0x00A8)
class UDBDInstancedFoliageComponent final : public UActorComponent
{
public:
	int32                                         NextBaseId;                                        // 0x00A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, class USceneComponent*>           InstanceBaseMap;                                   // 0x00B0(0x0050)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, EditConst, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FDBDFoliageInfo>                Foliage;                                           // 0x0100(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDInstancedFoliageComponent">();
	}
	static class UDBDInstancedFoliageComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDInstancedFoliageComponent>();
	}
};
static_assert(alignof(UDBDInstancedFoliageComponent) == 0x000008, "Wrong alignment on UDBDInstancedFoliageComponent");
static_assert(sizeof(UDBDInstancedFoliageComponent) == 0x000110, "Wrong size on UDBDInstancedFoliageComponent");
static_assert(offsetof(UDBDInstancedFoliageComponent, NextBaseId) == 0x0000A8, "Member 'UDBDInstancedFoliageComponent::NextBaseId' has a wrong offset!");
static_assert(offsetof(UDBDInstancedFoliageComponent, InstanceBaseMap) == 0x0000B0, "Member 'UDBDInstancedFoliageComponent::InstanceBaseMap' has a wrong offset!");
static_assert(offsetof(UDBDInstancedFoliageComponent, Foliage) == 0x000100, "Member 'UDBDInstancedFoliageComponent::Foliage' has a wrong offset!");

// Class DeadByDaylight.DBDAttackObstructSubstate
// 0x0000 (0x0118 - 0x0118)
class UDBDAttackObstructSubstate : public UDBDAttackSubstate
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDAttackObstructSubstate">();
	}
	static class UDBDAttackObstructSubstate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDAttackObstructSubstate>();
	}
};
static_assert(alignof(UDBDAttackObstructSubstate) == 0x000008, "Wrong alignment on UDBDAttackObstructSubstate");
static_assert(sizeof(UDBDAttackObstructSubstate) == 0x000118, "Wrong size on UDBDAttackObstructSubstate");

// Class DeadByDaylight.AICharacterBehaviour
// 0x0028 (0x0058 - 0x0030)
class UAICharacterBehaviour : public UObject
{
public:
	uint8                                         Pad_30[0x28];                                      // 0x0030(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Pause();
	void Resume();
	void SetEnable(bool Enable);
	void Start();
	void Stop();
	void Update(float DeltaTime);

	bool IsEnabled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AICharacterBehaviour">();
	}
	static class UAICharacterBehaviour* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAICharacterBehaviour>();
	}
};
static_assert(alignof(UAICharacterBehaviour) == 0x000008, "Wrong alignment on UAICharacterBehaviour");
static_assert(sizeof(UAICharacterBehaviour) == 0x000058, "Wrong size on UAICharacterBehaviour");

// Class DeadByDaylight.AISlasherMoveToGrabSurvivorBehaviour
// 0x0030 (0x0088 - 0x0058)
class UAISlasherMoveToGrabSurvivorBehaviour final : public UAICharacterBehaviour
{
public:
	class UAISlasherMoveToGrabSurvivorBehaviourData* _behaviourData;                                    // 0x0058(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ASlasherPlayer*                         _slasherPlayer;                                    // 0x0060(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ADBDAIPlayerController*                 _slasherAIPlayerController;                        // 0x0068(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_70[0x18];                                      // 0x0070(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISlasherMoveToGrabSurvivorBehaviour">();
	}
	static class UAISlasherMoveToGrabSurvivorBehaviour* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISlasherMoveToGrabSurvivorBehaviour>();
	}
};
static_assert(alignof(UAISlasherMoveToGrabSurvivorBehaviour) == 0x000008, "Wrong alignment on UAISlasherMoveToGrabSurvivorBehaviour");
static_assert(sizeof(UAISlasherMoveToGrabSurvivorBehaviour) == 0x000088, "Wrong size on UAISlasherMoveToGrabSurvivorBehaviour");
static_assert(offsetof(UAISlasherMoveToGrabSurvivorBehaviour, _behaviourData) == 0x000058, "Member 'UAISlasherMoveToGrabSurvivorBehaviour::_behaviourData' has a wrong offset!");
static_assert(offsetof(UAISlasherMoveToGrabSurvivorBehaviour, _slasherPlayer) == 0x000060, "Member 'UAISlasherMoveToGrabSurvivorBehaviour::_slasherPlayer' has a wrong offset!");
static_assert(offsetof(UAISlasherMoveToGrabSurvivorBehaviour, _slasherAIPlayerController) == 0x000068, "Member 'UAISlasherMoveToGrabSurvivorBehaviour::_slasherAIPlayerController' has a wrong offset!");

// Class DeadByDaylight.NavmeshGeneratorComponent
// 0x0038 (0x00E0 - 0x00A8)
class UNavmeshGeneratorComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x28];                                      // 0x00A8(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ANavMeshBoundsVolume*>           _availableNavmeshBoundsVolumes;                    // 0x00D0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavmeshGeneratorComponent">();
	}
	static class UNavmeshGeneratorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavmeshGeneratorComponent>();
	}
};
static_assert(alignof(UNavmeshGeneratorComponent) == 0x000008, "Wrong alignment on UNavmeshGeneratorComponent");
static_assert(sizeof(UNavmeshGeneratorComponent) == 0x0000E0, "Wrong size on UNavmeshGeneratorComponent");
static_assert(offsetof(UNavmeshGeneratorComponent, _availableNavmeshBoundsVolumes) == 0x0000D0, "Member 'UNavmeshGeneratorComponent::_availableNavmeshBoundsVolumes' has a wrong offset!");

// Class DeadByDaylight.BasePerkIconStrategy
// 0x0008 (0x0038 - 0x0030)
class UBasePerkIconStrategy : public UObject
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetDisplayPercent(const class UCompetence* Competence) const;
	bool GetIsRechargeable(const class UCompetence* Competence) const;
	bool GetIsRechargeableActive(const class UCompetence* Competence) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BasePerkIconStrategy">();
	}
	static class UBasePerkIconStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBasePerkIconStrategy>();
	}
};
static_assert(alignof(UBasePerkIconStrategy) == 0x000008, "Wrong alignment on UBasePerkIconStrategy");
static_assert(sizeof(UBasePerkIconStrategy) == 0x000038, "Wrong size on UBasePerkIconStrategy");

// Class DeadByDaylight.DBDRemotePlayer
// 0x0000 (0x1E68 - 0x1E68)
class UDBDRemotePlayer final : public UIpConnection
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDRemotePlayer">();
	}
	static class UDBDRemotePlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDRemotePlayer>();
	}
};
static_assert(alignof(UDBDRemotePlayer) == 0x000008, "Wrong alignment on UDBDRemotePlayer");
static_assert(sizeof(UDBDRemotePlayer) == 0x001E68, "Wrong size on UDBDRemotePlayer");

// Class DeadByDaylight.ChargeableInteractionDefinition
// 0x0140 (0x08C0 - 0x0780)
class UChargeableInteractionDefinition : public UInteractionDefinition
{
public:
	uint8                                         Pad_778[0x30];                                     // 0x0778(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             SkillCheckResponseAestheticDelegate;               // 0x07A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             SkillCheckResponseAuthorityDelegate;               // 0x07B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          StopInteractionOnChargeComplete;                   // 0x07C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasProgressivelyHarderSkillChecks;                 // 0x07C9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7CA[0x2];                                      // 0x07CA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ProgressiveDifficultyModifier;                     // 0x07CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EChargeableInteractionBarType                 ProgressBarType;                                   // 0x07D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7D1[0x7];                                      // 0x07D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 ProgressPips;                                      // 0x07D8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          HideProgressBar;                                   // 0x07E8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShowItemIcon;                                      // 0x07E9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AddChargeOnInteractionUpdateTick;                  // 0x07EA(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          ResetChargeOnInteractionFinished;                  // 0x07EB(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          ResetChargeOnInteractionChargeCompleted;           // 0x07EC(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          ToggleCrouchSlashableCapsule;                      // 0x07ED(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7EE[0x2];                                      // 0x07EE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class UChargeableComponent*                   _chargeableComponent;                              // 0x07F0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _tutorialChargeableMultiplier;                     // 0x07F8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7FC[0x54];                                     // 0x07FC(0x0054)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          ShowSpeedProficiencyForMultipleInteractors;        // 0x0850(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_851[0x7];                                      // 0x0851(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  _interactionSpecificActionSpeedTags;               // 0x0858(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FGameplayTagContainer                  _interactionSpecificActionSpeedMultiplicativeTags; // 0x0878(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FGameplayTagContainer                  _interactionSpecificActionDurationAdditiveTags;    // 0x0898(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8B8[0x8];                                      // 0x08B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_AddCharge(float DeltaSeconds, class ADBDPlayer* Character, bool IsChargeFromItem);
	void Authority_ChargeWithItem(float DeltaSeconds, class ACollectable* Item, class ADBDPlayer* Character);
	void Authority_ResetCharge(class ADBDPlayer* Character);
	void OnInteractionCompletionStateChanged(class ADBDPlayer* Player, bool Complete);
	void OnSkillCheckResponseAesthetic(bool Success, bool Bonus, class ADBDPlayer* Player, bool TriggerLoudNoise, bool HadInput, ESkillCheckCustomType Type);
	void OnSkillCheckResponseAestheticBP(class ADBDPlayer* Player, bool Success, bool Bonus, bool HadInput, ESkillCheckCustomType Type);
	void OnSkillCheckResponseAuthority(bool Success, bool Bonus, class ADBDPlayer* Player, bool TriggerLoudNoise, bool HadInput, ESkillCheckCustomType Type);
	void OnSkillCheckResponseAuthorityBP(class ADBDPlayer* Player, bool Success, bool Bonus, bool HadInput, ESkillCheckCustomType Type);
	void SetChargeableComponent(class UChargeableComponent* ChargeableComponent, bool IsNullAllowed);
	void SetSecondsToCharge(float SecondsToCharge);
	void SetSpeedBase(float SpeedBase);
	void SetTutorialChargeableMultiplier(float MultiplierValue);

	float GetAdditiveChargeTimeReductionAsMultiplier(const class ADBDPlayer* Character) const;
	float GetAdditiveLuckBonus(const class ADBDPlayer* Character) const;
	float GetBonusSkillCheckSuccessPercentReward(const class ADBDPlayer* Player) const;
	float GetBonusSkillCheckZoneSizeModifier(const class ADBDPlayer* Character) const;
	class UChargeableComponent* GetChargeableComponent() const;
	float GetChargeAmountForTime(float DeltaSeconds, class ADBDPlayer* Character) const;
	float GetChargeSpeedModifier(const class ADBDPlayer* Character) const;
	float GetGoodSkillCheckSuccessPercentReward(const class ADBDPlayer* Player) const;
	float GetInteractionChargeSpeedMultiplier(const class ADBDPlayer* Character) const;
	float GetItemEfficiencyModifier(const class ADBDPlayer* Character) const;
	float GetMaxCharge() const;
	float GetMultiplicativeLuckBonus(const class ADBDPlayer* Character) const;
	float GetPerkMultiplier(const class ADBDPlayer* Character) const;
	int32 GetPipsPassed() const;
	float GetSkillCheckCharge(class ADBDPlayer* Player, bool Success, bool Bonus, ESkillCheckCustomType Type) const;
	float GetSkillCheckDifficulityModifier(const class ADBDPlayer* Character) const;
	float GetSkillCheckFailurePercentPenalty(const class ADBDPlayer* Player) const;
	float GetSkillCheckFailureTimePenalty() const;
	float GetSkillCheckProbability(const class ADBDPlayer* InteractingPlayer) const;
	float GetSuccessProbability() const;
	float GetTunableValue(class FName TunableValueID, float DefaultValue) const;
	bool HasSkillCheckHappened(const class ADBDPlayer* Character) const;
	bool IsChargeComplete() const;
	bool ShouldShowSpeedProficiencyForMultipleInteractors() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChargeableInteractionDefinition">();
	}
	static class UChargeableInteractionDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChargeableInteractionDefinition>();
	}
};
static_assert(alignof(UChargeableInteractionDefinition) == 0x000010, "Wrong alignment on UChargeableInteractionDefinition");
static_assert(sizeof(UChargeableInteractionDefinition) == 0x0008C0, "Wrong size on UChargeableInteractionDefinition");
static_assert(offsetof(UChargeableInteractionDefinition, SkillCheckResponseAestheticDelegate) == 0x0007A8, "Member 'UChargeableInteractionDefinition::SkillCheckResponseAestheticDelegate' has a wrong offset!");
static_assert(offsetof(UChargeableInteractionDefinition, SkillCheckResponseAuthorityDelegate) == 0x0007B8, "Member 'UChargeableInteractionDefinition::SkillCheckResponseAuthorityDelegate' has a wrong offset!");
static_assert(offsetof(UChargeableInteractionDefinition, StopInteractionOnChargeComplete) == 0x0007C8, "Member 'UChargeableInteractionDefinition::StopInteractionOnChargeComplete' has a wrong offset!");
static_assert(offsetof(UChargeableInteractionDefinition, HasProgressivelyHarderSkillChecks) == 0x0007C9, "Member 'UChargeableInteractionDefinition::HasProgressivelyHarderSkillChecks' has a wrong offset!");
static_assert(offsetof(UChargeableInteractionDefinition, ProgressiveDifficultyModifier) == 0x0007CC, "Member 'UChargeableInteractionDefinition::ProgressiveDifficultyModifier' has a wrong offset!");
static_assert(offsetof(UChargeableInteractionDefinition, ProgressBarType) == 0x0007D0, "Member 'UChargeableInteractionDefinition::ProgressBarType' has a wrong offset!");
static_assert(offsetof(UChargeableInteractionDefinition, ProgressPips) == 0x0007D8, "Member 'UChargeableInteractionDefinition::ProgressPips' has a wrong offset!");
static_assert(offsetof(UChargeableInteractionDefinition, HideProgressBar) == 0x0007E8, "Member 'UChargeableInteractionDefinition::HideProgressBar' has a wrong offset!");
static_assert(offsetof(UChargeableInteractionDefinition, ShowItemIcon) == 0x0007E9, "Member 'UChargeableInteractionDefinition::ShowItemIcon' has a wrong offset!");
static_assert(offsetof(UChargeableInteractionDefinition, AddChargeOnInteractionUpdateTick) == 0x0007EA, "Member 'UChargeableInteractionDefinition::AddChargeOnInteractionUpdateTick' has a wrong offset!");
static_assert(offsetof(UChargeableInteractionDefinition, ResetChargeOnInteractionFinished) == 0x0007EB, "Member 'UChargeableInteractionDefinition::ResetChargeOnInteractionFinished' has a wrong offset!");
static_assert(offsetof(UChargeableInteractionDefinition, ResetChargeOnInteractionChargeCompleted) == 0x0007EC, "Member 'UChargeableInteractionDefinition::ResetChargeOnInteractionChargeCompleted' has a wrong offset!");
static_assert(offsetof(UChargeableInteractionDefinition, ToggleCrouchSlashableCapsule) == 0x0007ED, "Member 'UChargeableInteractionDefinition::ToggleCrouchSlashableCapsule' has a wrong offset!");
static_assert(offsetof(UChargeableInteractionDefinition, _chargeableComponent) == 0x0007F0, "Member 'UChargeableInteractionDefinition::_chargeableComponent' has a wrong offset!");
static_assert(offsetof(UChargeableInteractionDefinition, _tutorialChargeableMultiplier) == 0x0007F8, "Member 'UChargeableInteractionDefinition::_tutorialChargeableMultiplier' has a wrong offset!");
static_assert(offsetof(UChargeableInteractionDefinition, ShowSpeedProficiencyForMultipleInteractors) == 0x000850, "Member 'UChargeableInteractionDefinition::ShowSpeedProficiencyForMultipleInteractors' has a wrong offset!");
static_assert(offsetof(UChargeableInteractionDefinition, _interactionSpecificActionSpeedTags) == 0x000858, "Member 'UChargeableInteractionDefinition::_interactionSpecificActionSpeedTags' has a wrong offset!");
static_assert(offsetof(UChargeableInteractionDefinition, _interactionSpecificActionSpeedMultiplicativeTags) == 0x000878, "Member 'UChargeableInteractionDefinition::_interactionSpecificActionSpeedMultiplicativeTags' has a wrong offset!");
static_assert(offsetof(UChargeableInteractionDefinition, _interactionSpecificActionDurationAdditiveTags) == 0x000898, "Member 'UChargeableInteractionDefinition::_interactionSpecificActionDurationAdditiveTags' has a wrong offset!");

// Class DeadByDaylight.DBDHud
// 0x0050 (0x0080 - 0x0030)
class UDBDHud final : public UObject
{
public:
	TMap<class FName, class AStatusView*>         _statusViews;                                      // 0x0030(0x0050)(NativeAccessSpecifierPrivate)

public:
	void RemoveStatusViewOnDestroy(class AActor* Actor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDHud">();
	}
	static class UDBDHud* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDHud>();
	}
};
static_assert(alignof(UDBDHud) == 0x000008, "Wrong alignment on UDBDHud");
static_assert(sizeof(UDBDHud) == 0x000080, "Wrong size on UDBDHud");
static_assert(offsetof(UDBDHud, _statusViews) == 0x000030, "Member 'UDBDHud::_statusViews' has a wrong offset!");

// Class DeadByDaylight.DBDNetworkUtilities
// 0x0000 (0x0030 - 0x0030)
class UDBDNetworkUtilities final : public UBlueprintFunctionLibrary
{
public:
	static bool IsOnDedicatedServerNetwork(const class UObject* WorldContextObject);
	static bool IsRunningDedicatedServerFlow();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDNetworkUtilities">();
	}
	static class UDBDNetworkUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDNetworkUtilities>();
	}
};
static_assert(alignof(UDBDNetworkUtilities) == 0x000008, "Wrong alignment on UDBDNetworkUtilities");
static_assert(sizeof(UDBDNetworkUtilities) == 0x000030, "Wrong size on UDBDNetworkUtilities");

// Class DeadByDaylight.ItemModifier
// 0x0060 (0x02A8 - 0x0248)
class UItemModifier : public UGameplayModifierContainer
{
public:
	struct FGameplayModifierData                  ModifierData;                                      // 0x0248(0x0030)(Edit, Net, RepNotify, NativeAccessSpecifierPublic)
	uint8                                         Pad_278[0x30];                                     // 0x0278(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AuthoritySetItemCount(int32 ItemCount);
	void AuthoritySetItemEnergy(float Energy);
	void AuthoritySetItemMaxEnergy(float Energy);
	void HandleIncreaseCharge();
	void HandleIncreaseItemCount();
	void HandleIncreaseMaxCharge();

	class ACollectable* GetBaseItem() const;
	int32 GetItemCount() const;
	float GetItemEnergy() const;
	float GetItemMaxEnergy() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemModifier">();
	}
	static class UItemModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemModifier>();
	}
};
static_assert(alignof(UItemModifier) == 0x000008, "Wrong alignment on UItemModifier");
static_assert(sizeof(UItemModifier) == 0x0002A8, "Wrong size on UItemModifier");
static_assert(offsetof(UItemModifier, ModifierData) == 0x000248, "Member 'UItemModifier::ModifierData' has a wrong offset!");

// Class DeadByDaylight.PlayerScoreEmitter
// 0x0008 (0x0038 - 0x0030)
class UPlayerScoreEmitter : public UObject
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerScoreEmitter">();
	}
	static class UPlayerScoreEmitter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerScoreEmitter>();
	}
};
static_assert(alignof(UPlayerScoreEmitter) == 0x000008, "Wrong alignment on UPlayerScoreEmitter");
static_assert(sizeof(UPlayerScoreEmitter) == 0x000038, "Wrong size on UPlayerScoreEmitter");

// Class DeadByDaylight.DBDTagUtilities
// 0x0000 (0x0030 - 0x0030)
class UDBDTagUtilities final : public UBlueprintFunctionLibrary
{
public:
	static bool ActorHasReplicatedTag(const class AActor* Actor, class FName Tag);
	static void GetAllActorsOfClassWithReplicatedTag(const class UObject* WorldContextObject, TSubclassOf<class AActor> ActorClass, class FName Tag, TArray<class AActor*>* OutActors);
	static void GetAllActorsWithReplicatedTag(const class UObject* WorldContextObject, class FName Tag, TArray<class AActor*>* OutActors);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDTagUtilities">();
	}
	static class UDBDTagUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDTagUtilities>();
	}
};
static_assert(alignof(UDBDTagUtilities) == 0x000008, "Wrong alignment on UDBDTagUtilities");
static_assert(sizeof(UDBDTagUtilities) == 0x000030, "Wrong size on UDBDTagUtilities");

// Class DeadByDaylight.DBDAttackUtilities
// 0x0000 (0x0030 - 0x0030)
class UDBDAttackUtilities final : public UBlueprintFunctionLibrary
{
public:
	static float GetCurrentAttackSubstateRemainingTime(const class AActor* Attacker);
	static EAttackType GetCurrentAttackType(const class AActor* Attacker);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDAttackUtilities">();
	}
	static class UDBDAttackUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDAttackUtilities>();
	}
};
static_assert(alignof(UDBDAttackUtilities) == 0x000008, "Wrong alignment on UDBDAttackUtilities");
static_assert(sizeof(UDBDAttackUtilities) == 0x000030, "Wrong size on UDBDAttackUtilities");

// Class DeadByDaylight.AbstractAnalyticsManager
// 0x0000 (0x0038 - 0x0038)
class UAbstractAnalyticsManager : public UGameInstanceSubsystem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbstractAnalyticsManager">();
	}
	static class UAbstractAnalyticsManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbstractAnalyticsManager>();
	}
};
static_assert(alignof(UAbstractAnalyticsManager) == 0x000008, "Wrong alignment on UAbstractAnalyticsManager");
static_assert(sizeof(UAbstractAnalyticsManager) == 0x000038, "Wrong size on UAbstractAnalyticsManager");

// Class DeadByDaylight.ClientStartupInitializerInterface
// 0x0000 (0x0030 - 0x0030)
class IClientStartupInitializerInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClientStartupInitializerInterface">();
	}
	static class IClientStartupInitializerInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IClientStartupInitializerInterface>();
	}
};
static_assert(alignof(IClientStartupInitializerInterface) == 0x000008, "Wrong alignment on IClientStartupInitializerInterface");
static_assert(sizeof(IClientStartupInitializerInterface) == 0x000030, "Wrong size on IClientStartupInitializerInterface");

// Class DeadByDaylight.BaseSpawnConditionStrategy
// 0x0000 (0x0030 - 0x0030)
class UBaseSpawnConditionStrategy : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseSpawnConditionStrategy">();
	}
	static class UBaseSpawnConditionStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseSpawnConditionStrategy>();
	}
};
static_assert(alignof(UBaseSpawnConditionStrategy) == 0x000008, "Wrong alignment on UBaseSpawnConditionStrategy");
static_assert(sizeof(UBaseSpawnConditionStrategy) == 0x000030, "Wrong size on UBaseSpawnConditionStrategy");

// Class DeadByDaylight.ItemAddon
// 0x0040 (0x02E8 - 0x02A8)
class UItemAddon : public UItemModifier
{
public:
	TSubclassOf<class ACollectable>               BaseItemType;                                      // 0x02A8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _needsSetup;                                       // 0x02B0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B1[0x3];                                      // 0x02B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _maxTokenCount;                                    // 0x02B4(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B8[0x1C];                                     // 0x02B8(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _tokenCount;                                       // 0x02D4(0x0004)(BlueprintVisible, Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FItemAddonInitializationData           _addonInitializationData;                          // 0x02D8(0x0002)(Net, Transient, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2DA[0x2];                                      // 0x02DA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class ACollectable>            _baseItem;                                         // 0x02DC(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2E4[0x4];                                      // 0x02E4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_ApplyMetaModifiers();
	void Authority_DecrementToken();
	void Authority_IncrementToken();
	void Authority_OnCollectableDropped(class ADBDPlayer* Player);
	void Authority_OnCollectablePickedUp(class ADBDPlayer* Player);
	void Authority_SetMaxTokenCount(int32 Value);
	void Authority_SetTokenCount(int32 Value);
	void DebugPrintStats();
	void OnPostItemAddonsCreation(class ADBDPlayer* Player, class ACollectable* Item);
	void OnRep_AddonInitializationData();
	void OnRep_BaseItem();
	void OnRep_TokenCount(int32 OldCount);
	void SetUpAddon();

	int32 GetMaxTokenCount() const;
	int32 GetTokenCount() const;
	bool IsReadyForSetUp() const;
	bool IsSecondaryAction() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemAddon">();
	}
	static class UItemAddon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemAddon>();
	}
};
static_assert(alignof(UItemAddon) == 0x000008, "Wrong alignment on UItemAddon");
static_assert(sizeof(UItemAddon) == 0x0002E8, "Wrong size on UItemAddon");
static_assert(offsetof(UItemAddon, BaseItemType) == 0x0002A8, "Member 'UItemAddon::BaseItemType' has a wrong offset!");
static_assert(offsetof(UItemAddon, _needsSetup) == 0x0002B0, "Member 'UItemAddon::_needsSetup' has a wrong offset!");
static_assert(offsetof(UItemAddon, _maxTokenCount) == 0x0002B4, "Member 'UItemAddon::_maxTokenCount' has a wrong offset!");
static_assert(offsetof(UItemAddon, _tokenCount) == 0x0002D4, "Member 'UItemAddon::_tokenCount' has a wrong offset!");
static_assert(offsetof(UItemAddon, _addonInitializationData) == 0x0002D8, "Member 'UItemAddon::_addonInitializationData' has a wrong offset!");
static_assert(offsetof(UItemAddon, _baseItem) == 0x0002DC, "Member 'UItemAddon::_baseItem' has a wrong offset!");

// Class DeadByDaylight.CharacterChaseVisualComponent
// 0x00A8 (0x0150 - 0x00A8)
class UCharacterChaseVisualComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnChaseStartEvent;                                 // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnChaseEndEvent;                                   // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UMaterialHelperUnaffectedStaticMeshComponent* _vignetteMeshComp;                                 // 0x00C8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                _relativeLocation;                                 // 0x00D0(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                _relativeScale;                                    // 0x00E8(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FRotator                               _relativeRotation;                                 // 0x0100(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	float                                         _fovModifyFactor;                                  // 0x0118(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_11C[0x34];                                     // 0x011C(0x0034)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAllChaseEnd();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterChaseVisualComponent">();
	}
	static class UCharacterChaseVisualComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterChaseVisualComponent>();
	}
};
static_assert(alignof(UCharacterChaseVisualComponent) == 0x000008, "Wrong alignment on UCharacterChaseVisualComponent");
static_assert(sizeof(UCharacterChaseVisualComponent) == 0x000150, "Wrong size on UCharacterChaseVisualComponent");
static_assert(offsetof(UCharacterChaseVisualComponent, OnChaseStartEvent) == 0x0000A8, "Member 'UCharacterChaseVisualComponent::OnChaseStartEvent' has a wrong offset!");
static_assert(offsetof(UCharacterChaseVisualComponent, OnChaseEndEvent) == 0x0000B8, "Member 'UCharacterChaseVisualComponent::OnChaseEndEvent' has a wrong offset!");
static_assert(offsetof(UCharacterChaseVisualComponent, _vignetteMeshComp) == 0x0000C8, "Member 'UCharacterChaseVisualComponent::_vignetteMeshComp' has a wrong offset!");
static_assert(offsetof(UCharacterChaseVisualComponent, _relativeLocation) == 0x0000D0, "Member 'UCharacterChaseVisualComponent::_relativeLocation' has a wrong offset!");
static_assert(offsetof(UCharacterChaseVisualComponent, _relativeScale) == 0x0000E8, "Member 'UCharacterChaseVisualComponent::_relativeScale' has a wrong offset!");
static_assert(offsetof(UCharacterChaseVisualComponent, _relativeRotation) == 0x000100, "Member 'UCharacterChaseVisualComponent::_relativeRotation' has a wrong offset!");
static_assert(offsetof(UCharacterChaseVisualComponent, _fovModifyFactor) == 0x000118, "Member 'UCharacterChaseVisualComponent::_fovModifyFactor' has a wrong offset!");

// Class DeadByDaylight.PalletPulldownBlockable
// 0x0000 (0x0030 - 0x0030)
class IPalletPulldownBlockable final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalletPulldownBlockable">();
	}
	static class IPalletPulldownBlockable* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPalletPulldownBlockable>();
	}
};
static_assert(alignof(IPalletPulldownBlockable) == 0x000008, "Wrong alignment on IPalletPulldownBlockable");
static_assert(sizeof(IPalletPulldownBlockable) == 0x000030, "Wrong size on IPalletPulldownBlockable");

// Class DeadByDaylight.BaseTrap
// 0x0008 (0x0558 - 0x0550)
class ABaseTrap : public ACollectable
{
public:
	bool                                          _isTrapSet;                                        // 0x0550(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_551[0x7];                                      // 0x0551(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetIsTrapSet(const bool Value);

	bool IsTrapSet() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseTrap">();
	}
	static class ABaseTrap* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABaseTrap>();
	}
};
static_assert(alignof(ABaseTrap) == 0x000008, "Wrong alignment on ABaseTrap");
static_assert(sizeof(ABaseTrap) == 0x000558, "Wrong size on ABaseTrap");
static_assert(offsetof(ABaseTrap, _isTrapSet) == 0x000550, "Member 'ABaseTrap::_isTrapSet' has a wrong offset!");

// Class DeadByDaylight.StateMachine
// 0x0078 (0x0120 - 0x00A8)
class alignas(0x10) UStateMachine : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x9];                                       // 0x00A8(0x0009)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _enableJoinInProgress;                             // 0x00B1(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B2[0x56];                                      // 0x00B2(0x0056)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<uint16>                                _netStateIDStackInitial;                           // 0x0108(0x0010)(Net, ZeroConstructor, Transient, RepNotify, NativeAccessSpecifierPrivate)
	uint8                                         Pad_118[0x8];                                      // 0x0118(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Multicast_SetStateStack(const TArray<uint16>& NetStateIDStack);
	void NetIDStackChanged();
	void Server_SetStateStack(const TArray<uint16>& NetStateIDStack);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StateMachine">();
	}
	static class UStateMachine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStateMachine>();
	}
};
static_assert(alignof(UStateMachine) == 0x000010, "Wrong alignment on UStateMachine");
static_assert(sizeof(UStateMachine) == 0x000120, "Wrong size on UStateMachine");
static_assert(offsetof(UStateMachine, _enableJoinInProgress) == 0x0000B1, "Member 'UStateMachine::_enableJoinInProgress' has a wrong offset!");
static_assert(offsetof(UStateMachine, _netStateIDStackInitial) == 0x000108, "Member 'UStateMachine::_netStateIDStackInitial' has a wrong offset!");

// Class DeadByDaylight.DBDPlayerData
// 0x00A0 (0x0148 - 0x00A8)
class UDBDPlayerData final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnItemUseButtonStateChanged;                       // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_B8[0x78];                                      // 0x00B8(0x0078)(Fixing Size After Last Property [ Dumper-7 ])
	struct FYawAndPitchRotator_NetQuantize16      _controlRotation;                                  // 0x0130(0x0018)(Net, NoDestructor, NativeAccessSpecifierPrivate)

public:
	void OnItemUseButtonStateChanged__DelegateSignature(bool IsPressed);
	void Server_CampaignDataSynced();
	void Server_LoadoutSpawned();
	void Server_NotifyAIPawnReady();
	void Server_RenderingFeaturesCompleted();
	void Server_SetIntroCompleted();
	void Server_SetKillerSpecificComponentReady();
	void Server_SetMapSpecificComponentReady();
	void Server_SetMutatorComponentReady();
	void Server_SetPlayerReady();

	struct FRotator GetControlRotation() const;
	bool IsInteractionInputPressed(EInputInteractionType InteractionType) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDPlayerData">();
	}
	static class UDBDPlayerData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDPlayerData>();
	}
};
static_assert(alignof(UDBDPlayerData) == 0x000008, "Wrong alignment on UDBDPlayerData");
static_assert(sizeof(UDBDPlayerData) == 0x000148, "Wrong size on UDBDPlayerData");
static_assert(offsetof(UDBDPlayerData, OnItemUseButtonStateChanged) == 0x0000A8, "Member 'UDBDPlayerData::OnItemUseButtonStateChanged' has a wrong offset!");
static_assert(offsetof(UDBDPlayerData, _controlRotation) == 0x000130, "Member 'UDBDPlayerData::_controlRotation' has a wrong offset!");

// Class DeadByDaylight.CurveFloatNetIdSubsystem
// 0x0060 (0x0098 - 0x0038)
class UCurveFloatNetIdSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x60];                                      // 0x0038(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CurveFloatNetIdSubsystem">();
	}
	static class UCurveFloatNetIdSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCurveFloatNetIdSubsystem>();
	}
};
static_assert(alignof(UCurveFloatNetIdSubsystem) == 0x000008, "Wrong alignment on UCurveFloatNetIdSubsystem");
static_assert(sizeof(UCurveFloatNetIdSubsystem) == 0x000098, "Wrong size on UCurveFloatNetIdSubsystem");

// Class DeadByDaylight.Perk
// 0x0140 (0x0420 - 0x02E0)
class UPerk : public UCompetence
{
public:
	uint8                                         Pad_2E0[0x30];                                     // 0x02E0(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayModifierData                  PerkLevelData[0x3];                                // 0x0310(0x0030)(Edit, Net, EditFixedSize, RepNotify, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A0[0x60];                                     // 0x03A0(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _isUsable;                                         // 0x0400(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _keepImposedStatusEffectsOnEndPlay;                // 0x0401(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          BroadcastWhenApplicable;                           // 0x0402(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          BroadcastOnTimer;                                  // 0x0403(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          BroadcastCooldownTimer;                            // 0x0404(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          BroadcastInactiveCooldownTimer;                    // 0x0405(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          BroadcastAlways;                                   // 0x0406(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_407[0x1];                                      // 0x0407(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPerkInitializationData                _perkInitializationData;                           // 0x0408(0x0008)(Net, Transient, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_410[0x8];                                      // 0x0410(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UInteractionDefinition*                 _activatableInteraction;                           // 0x0418(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Authority_SetIsUsable(bool Value);
	void FireActivePerkEvent(const float Percentage, const int32 ChargeCount);
	struct FGameplayModifierData GetGameplayModifierData();
	void OnRep_PerkInitializationData();
	void SetIsUsable(bool Value);

	bool GetIsUsable() const;
	int32 GetPerkLevel() const;
	void OnRep_IsUsable() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Perk">();
	}
	static class UPerk* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPerk>();
	}
};
static_assert(alignof(UPerk) == 0x000008, "Wrong alignment on UPerk");
static_assert(sizeof(UPerk) == 0x000420, "Wrong size on UPerk");
static_assert(offsetof(UPerk, PerkLevelData) == 0x000310, "Member 'UPerk::PerkLevelData' has a wrong offset!");
static_assert(offsetof(UPerk, _isUsable) == 0x000400, "Member 'UPerk::_isUsable' has a wrong offset!");
static_assert(offsetof(UPerk, _keepImposedStatusEffectsOnEndPlay) == 0x000401, "Member 'UPerk::_keepImposedStatusEffectsOnEndPlay' has a wrong offset!");
static_assert(offsetof(UPerk, BroadcastWhenApplicable) == 0x000402, "Member 'UPerk::BroadcastWhenApplicable' has a wrong offset!");
static_assert(offsetof(UPerk, BroadcastOnTimer) == 0x000403, "Member 'UPerk::BroadcastOnTimer' has a wrong offset!");
static_assert(offsetof(UPerk, BroadcastCooldownTimer) == 0x000404, "Member 'UPerk::BroadcastCooldownTimer' has a wrong offset!");
static_assert(offsetof(UPerk, BroadcastInactiveCooldownTimer) == 0x000405, "Member 'UPerk::BroadcastInactiveCooldownTimer' has a wrong offset!");
static_assert(offsetof(UPerk, BroadcastAlways) == 0x000406, "Member 'UPerk::BroadcastAlways' has a wrong offset!");
static_assert(offsetof(UPerk, _perkInitializationData) == 0x000408, "Member 'UPerk::_perkInitializationData' has a wrong offset!");
static_assert(offsetof(UPerk, _activatableInteraction) == 0x000418, "Member 'UPerk::_activatableInteraction' has a wrong offset!");

// Class DeadByDaylight.DBDAttack
// 0x0378 (0x0420 - 0x00A8)
class alignas(0x10) UDBDAttack : public UActorComponent
{
public:
	uint8                                         Pad_A8[0xB8];                                      // 0x00A8(0x00B8)(Fixing Size After Last Property [ Dumper-7 ])
	EAttackType                                   _attackType;                                       // 0x0160(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _useMontage;                                       // 0x0161(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EDetectionZone                                _damageZone;                                       // 0x0162(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EDetectionZone                                _lockZone;                                         // 0x0163(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EDetectionZone                                _obstructionZone;                                  // 0x0164(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_165[0x3];                                      // 0x0165(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FStatProperty                          _maxAccelerationMultiplier;                        // 0x0168(0x0088)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          _onlyApplyAccelerationMultiplierWhenWalking;       // 0x01F0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1F1[0x7];                                      // 0x01F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDAttackTargetTracker                _targetTracker;                                    // 0x01F8(0x00B8)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<EAttackSubstate, TSubclassOf<class UDBDAttackSubstate>> _stateClasses;                                     // 0x02B0(0x0050)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<class ACharacter*>                     _localAlreadyHitTargets;                           // 0x0300(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class ADBDPlayer*>                     _hitTargets;                                       // 0x0310(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TSet<class ADBDPlayer*>                       _targetsAwaitingServerValidation;                  // 0x0320(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_370[0x30];                                     // 0x0370(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EAttackSubstate, class UDBDAttackSubstate*> _states;                                           // 0x03A0(0x0050)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3F0[0x27];                                     // 0x03F0(0x0027)(Fixing Size After Last Property [ Dumper-7 ])
	EHitValidatorConfigName                       _hitValidationConfigName;                          // 0x0417(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_418[0x8];                                      // 0x0418(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Client_ReceiveAttackSubstateRequestResult(const struct FAttackSubstateRequestResult& Result);
	void Client_ReceiveHitResult(class ADBDPlayer* Target, bool IsValid, const struct FActionPredictionKey& PredictionKey);
	void Local_OnMovementChanged(class ACharacter* Character, EMovementMode PrevMovementMode, uint8 PreviousCustomMode);
	void Multicast_ClearTargets();
	void Multicast_HitAttackableComponent(class UAttackableComponent* AttackableComponent);
	void Multicast_HitTarget(class ADBDPlayer* Target, bool HitCosmeticOnly);
	void Multicast_RequestStateChange(const EAttackSubstate State);
	void Multicast_SendPostHitTargetData(class ADBDPlayer* OwningKiller, class ADBDPlayer* Target, const struct FPostAttackData& AttackData);
	void Server_ClearTargets();
	void Server_HitDestroyableActorAttackableComponent(class UAttackableComponent* AttackableComponent);
	void Server_HitTarget(class ADBDPlayer* Target, const float TargetLocationTimestamp, const struct FActionPredictionKey& PredictionKey);
	void Server_RequestStateChange(const EAttackSubstate State);

	class UDBDAttackSubstate* GetAttackSubstate(const EAttackSubstate State) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDAttack">();
	}
	static class UDBDAttack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDAttack>();
	}
};
static_assert(alignof(UDBDAttack) == 0x000010, "Wrong alignment on UDBDAttack");
static_assert(sizeof(UDBDAttack) == 0x000420, "Wrong size on UDBDAttack");
static_assert(offsetof(UDBDAttack, _attackType) == 0x000160, "Member 'UDBDAttack::_attackType' has a wrong offset!");
static_assert(offsetof(UDBDAttack, _useMontage) == 0x000161, "Member 'UDBDAttack::_useMontage' has a wrong offset!");
static_assert(offsetof(UDBDAttack, _damageZone) == 0x000162, "Member 'UDBDAttack::_damageZone' has a wrong offset!");
static_assert(offsetof(UDBDAttack, _lockZone) == 0x000163, "Member 'UDBDAttack::_lockZone' has a wrong offset!");
static_assert(offsetof(UDBDAttack, _obstructionZone) == 0x000164, "Member 'UDBDAttack::_obstructionZone' has a wrong offset!");
static_assert(offsetof(UDBDAttack, _maxAccelerationMultiplier) == 0x000168, "Member 'UDBDAttack::_maxAccelerationMultiplier' has a wrong offset!");
static_assert(offsetof(UDBDAttack, _onlyApplyAccelerationMultiplierWhenWalking) == 0x0001F0, "Member 'UDBDAttack::_onlyApplyAccelerationMultiplierWhenWalking' has a wrong offset!");
static_assert(offsetof(UDBDAttack, _targetTracker) == 0x0001F8, "Member 'UDBDAttack::_targetTracker' has a wrong offset!");
static_assert(offsetof(UDBDAttack, _stateClasses) == 0x0002B0, "Member 'UDBDAttack::_stateClasses' has a wrong offset!");
static_assert(offsetof(UDBDAttack, _localAlreadyHitTargets) == 0x000300, "Member 'UDBDAttack::_localAlreadyHitTargets' has a wrong offset!");
static_assert(offsetof(UDBDAttack, _hitTargets) == 0x000310, "Member 'UDBDAttack::_hitTargets' has a wrong offset!");
static_assert(offsetof(UDBDAttack, _targetsAwaitingServerValidation) == 0x000320, "Member 'UDBDAttack::_targetsAwaitingServerValidation' has a wrong offset!");
static_assert(offsetof(UDBDAttack, _states) == 0x0003A0, "Member 'UDBDAttack::_states' has a wrong offset!");
static_assert(offsetof(UDBDAttack, _hitValidationConfigName) == 0x000417, "Member 'UDBDAttack::_hitValidationConfigName' has a wrong offset!");

// Class DeadByDaylight.DBDOutlineComponent
// 0x00F0 (0x0440 - 0x0350)
class UDBDOutlineComponent final : public UBatchMeshCommands
{
public:
	float                                         InterpolationSpeed;                                // 0x0350(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShouldBeAboveOutlines;                             // 0x0354(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ForceOutlineFarAway;                               // 0x0355(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          LimitToCustomDepthObjects;                         // 0x0356(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          FadeOutAsClosingIn;                                // 0x0357(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsAlwaysVisible;                                   // 0x0358(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_359[0x3];                                      // 0x0359(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinimumOutlineDistanceWhenIsAlwaysVisible;         // 0x035C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinimumOutlineDistance;                            // 0x0360(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_364[0x4];                                      // 0x0364(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 OutlineName;                                       // 0x0368(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_378[0x58];                                     // 0x0378(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDOutlineRenderStrategySelector      _renderStrategySelector;                           // 0x03D0(0x0040)(Transient, NativeAccessSpecifierPrivate)
	class UBatchMeshCommands*                     _batchMeshCommands;                                // 0x0410(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_418[0x10];                                     // 0x0418(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UBaseOutlineRenderStrategy*             _renderingStrategy;                                // 0x0428(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_430[0x10];                                     // 0x0430(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitBatcher();
	void OnLevelReadyToPlay();
	void RefreshOutlineComponent();
	void ResetToTransparent();
	void SetFadeIntensity(float FadeIntensity);
	void SetFadeTexture(class UTexture* InFadeTexture);
	void SetIsOccludingOutlines(const bool IsOccluding);
	void SetMaterialCopyTarget(class UMaterialInterface* InMaterialToCopy);
	void SetMinimumOutlineDistance(float DistanceWhenIsAlwaysVisible, float Distance);
	void SetOutlineIntensity(float OutlineIntensity);
	void SetOutlineMaterialOverride(const struct FGameplayTag& OverrideName);
	void SetTargetColor(const struct FLinearColor& Color);

	const struct FLinearColor GetTargetColor() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDOutlineComponent">();
	}
	static class UDBDOutlineComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDOutlineComponent>();
	}
};
static_assert(alignof(UDBDOutlineComponent) == 0x000010, "Wrong alignment on UDBDOutlineComponent");
static_assert(sizeof(UDBDOutlineComponent) == 0x000440, "Wrong size on UDBDOutlineComponent");
static_assert(offsetof(UDBDOutlineComponent, InterpolationSpeed) == 0x000350, "Member 'UDBDOutlineComponent::InterpolationSpeed' has a wrong offset!");
static_assert(offsetof(UDBDOutlineComponent, ShouldBeAboveOutlines) == 0x000354, "Member 'UDBDOutlineComponent::ShouldBeAboveOutlines' has a wrong offset!");
static_assert(offsetof(UDBDOutlineComponent, ForceOutlineFarAway) == 0x000355, "Member 'UDBDOutlineComponent::ForceOutlineFarAway' has a wrong offset!");
static_assert(offsetof(UDBDOutlineComponent, LimitToCustomDepthObjects) == 0x000356, "Member 'UDBDOutlineComponent::LimitToCustomDepthObjects' has a wrong offset!");
static_assert(offsetof(UDBDOutlineComponent, FadeOutAsClosingIn) == 0x000357, "Member 'UDBDOutlineComponent::FadeOutAsClosingIn' has a wrong offset!");
static_assert(offsetof(UDBDOutlineComponent, IsAlwaysVisible) == 0x000358, "Member 'UDBDOutlineComponent::IsAlwaysVisible' has a wrong offset!");
static_assert(offsetof(UDBDOutlineComponent, MinimumOutlineDistanceWhenIsAlwaysVisible) == 0x00035C, "Member 'UDBDOutlineComponent::MinimumOutlineDistanceWhenIsAlwaysVisible' has a wrong offset!");
static_assert(offsetof(UDBDOutlineComponent, MinimumOutlineDistance) == 0x000360, "Member 'UDBDOutlineComponent::MinimumOutlineDistance' has a wrong offset!");
static_assert(offsetof(UDBDOutlineComponent, OutlineName) == 0x000368, "Member 'UDBDOutlineComponent::OutlineName' has a wrong offset!");
static_assert(offsetof(UDBDOutlineComponent, _renderStrategySelector) == 0x0003D0, "Member 'UDBDOutlineComponent::_renderStrategySelector' has a wrong offset!");
static_assert(offsetof(UDBDOutlineComponent, _batchMeshCommands) == 0x000410, "Member 'UDBDOutlineComponent::_batchMeshCommands' has a wrong offset!");
static_assert(offsetof(UDBDOutlineComponent, _renderingStrategy) == 0x000428, "Member 'UDBDOutlineComponent::_renderingStrategy' has a wrong offset!");

// Class DeadByDaylight.CustomWidgetWrapper
// 0x0050 (0x01E8 - 0x0198)
class UCustomWidgetWrapper : public UCanvasPanel
{
public:
	FMulticastInlineDelegateProperty_             OnVersion;                                         // 0x0198(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ID;                                                // 0x01A8(0x000C)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B4[0x4];                                      // 0x01B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCustomWidgetWrapper*                   ManuallyParentWrapper;                             // 0x01B8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UCustomWidgetWrapper*>           ManuallyChildWrappers;                             // 0x01C0(0x0010)(Edit, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UCustomWidgetWrapperInitializer*        InitializerWidget;                                 // 0x01D0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D8[0x10];                                     // 0x01D8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyOpacity(float Opacity);
	void ApplyScale(float Scale);
	void ApplyVersion(int32 Version);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomWidgetWrapper">();
	}
	static class UCustomWidgetWrapper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomWidgetWrapper>();
	}
};
static_assert(alignof(UCustomWidgetWrapper) == 0x000008, "Wrong alignment on UCustomWidgetWrapper");
static_assert(sizeof(UCustomWidgetWrapper) == 0x0001E8, "Wrong size on UCustomWidgetWrapper");
static_assert(offsetof(UCustomWidgetWrapper, OnVersion) == 0x000198, "Member 'UCustomWidgetWrapper::OnVersion' has a wrong offset!");
static_assert(offsetof(UCustomWidgetWrapper, ID) == 0x0001A8, "Member 'UCustomWidgetWrapper::ID' has a wrong offset!");
static_assert(offsetof(UCustomWidgetWrapper, ManuallyParentWrapper) == 0x0001B8, "Member 'UCustomWidgetWrapper::ManuallyParentWrapper' has a wrong offset!");
static_assert(offsetof(UCustomWidgetWrapper, ManuallyChildWrappers) == 0x0001C0, "Member 'UCustomWidgetWrapper::ManuallyChildWrappers' has a wrong offset!");
static_assert(offsetof(UCustomWidgetWrapper, InitializerWidget) == 0x0001D0, "Member 'UCustomWidgetWrapper::InitializerWidget' has a wrong offset!");

// Class DeadByDaylight.CustomWidgetWrapper_HudEditor
// 0x00E8 (0x02D0 - 0x01E8)
class UCustomWidgetWrapper_HudEditor final : public UCustomWidgetWrapper
{
public:
	float                                         MinOpacity;                                        // 0x01E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxOpacity;                                        // 0x01EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinScale;                                          // 0x01F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxScale;                                          // 0x01F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NbVersions;                                        // 0x01F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HideUnderOpacity;                                  // 0x01FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 HiddenStatusTintColor;                             // 0x0200(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HiddenStatusOpacity;                               // 0x0204(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OverlapAboveSizeRatio;                             // 0x0208(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20C[0x4];                                      // 0x020C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  IgnoreOverlapIds;                                  // 0x0210(0x0020)(Edit, NativeAccessSpecifierPublic)
	struct FHudEditorDragFromParentAxisLimit      ParentDragLimitX;                                  // 0x0230(0x0014)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FHudEditorDragFromParentAxisLimit      ParentDragLimitY;                                  // 0x0244(0x0014)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          IsEditingHudByInput;                               // 0x0258(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_259[0x3];                                      // 0x0259(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FColor                                 OverlapStatusTintColor;                            // 0x025C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_260[0x70];                                     // 0x0260(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddToTranslation(const struct FVector2D& Translation);
	void ApplyScaleWithOverlappingWrappers(float Scale, class UWidget* Widget, const TArray<class UCustomWidgetWrapper_HudEditor*>& AllEditableWrappers, bool NeedDetectOverlapping);
	void ClampToViewport();
	void FlipPositionWithChildLinkWidget();
	void FlipScreenPosition();

	bool CanEditOpacity() const;
	bool CanEditScale() const;
	float GetOpacity() const;
	float GetScale() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomWidgetWrapper_HudEditor">();
	}
	static class UCustomWidgetWrapper_HudEditor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomWidgetWrapper_HudEditor>();
	}
};
static_assert(alignof(UCustomWidgetWrapper_HudEditor) == 0x000008, "Wrong alignment on UCustomWidgetWrapper_HudEditor");
static_assert(sizeof(UCustomWidgetWrapper_HudEditor) == 0x0002D0, "Wrong size on UCustomWidgetWrapper_HudEditor");
static_assert(offsetof(UCustomWidgetWrapper_HudEditor, MinOpacity) == 0x0001E8, "Member 'UCustomWidgetWrapper_HudEditor::MinOpacity' has a wrong offset!");
static_assert(offsetof(UCustomWidgetWrapper_HudEditor, MaxOpacity) == 0x0001EC, "Member 'UCustomWidgetWrapper_HudEditor::MaxOpacity' has a wrong offset!");
static_assert(offsetof(UCustomWidgetWrapper_HudEditor, MinScale) == 0x0001F0, "Member 'UCustomWidgetWrapper_HudEditor::MinScale' has a wrong offset!");
static_assert(offsetof(UCustomWidgetWrapper_HudEditor, MaxScale) == 0x0001F4, "Member 'UCustomWidgetWrapper_HudEditor::MaxScale' has a wrong offset!");
static_assert(offsetof(UCustomWidgetWrapper_HudEditor, NbVersions) == 0x0001F8, "Member 'UCustomWidgetWrapper_HudEditor::NbVersions' has a wrong offset!");
static_assert(offsetof(UCustomWidgetWrapper_HudEditor, HideUnderOpacity) == 0x0001FC, "Member 'UCustomWidgetWrapper_HudEditor::HideUnderOpacity' has a wrong offset!");
static_assert(offsetof(UCustomWidgetWrapper_HudEditor, HiddenStatusTintColor) == 0x000200, "Member 'UCustomWidgetWrapper_HudEditor::HiddenStatusTintColor' has a wrong offset!");
static_assert(offsetof(UCustomWidgetWrapper_HudEditor, HiddenStatusOpacity) == 0x000204, "Member 'UCustomWidgetWrapper_HudEditor::HiddenStatusOpacity' has a wrong offset!");
static_assert(offsetof(UCustomWidgetWrapper_HudEditor, OverlapAboveSizeRatio) == 0x000208, "Member 'UCustomWidgetWrapper_HudEditor::OverlapAboveSizeRatio' has a wrong offset!");
static_assert(offsetof(UCustomWidgetWrapper_HudEditor, IgnoreOverlapIds) == 0x000210, "Member 'UCustomWidgetWrapper_HudEditor::IgnoreOverlapIds' has a wrong offset!");
static_assert(offsetof(UCustomWidgetWrapper_HudEditor, ParentDragLimitX) == 0x000230, "Member 'UCustomWidgetWrapper_HudEditor::ParentDragLimitX' has a wrong offset!");
static_assert(offsetof(UCustomWidgetWrapper_HudEditor, ParentDragLimitY) == 0x000244, "Member 'UCustomWidgetWrapper_HudEditor::ParentDragLimitY' has a wrong offset!");
static_assert(offsetof(UCustomWidgetWrapper_HudEditor, IsEditingHudByInput) == 0x000258, "Member 'UCustomWidgetWrapper_HudEditor::IsEditingHudByInput' has a wrong offset!");
static_assert(offsetof(UCustomWidgetWrapper_HudEditor, OverlapStatusTintColor) == 0x00025C, "Member 'UCustomWidgetWrapper_HudEditor::OverlapStatusTintColor' has a wrong offset!");

// Class DeadByDaylight.FeatureGate
// 0x0140 (0x0178 - 0x0038)
class UFeatureGate final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x140];                                     // 0x0038(0x0140)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FeatureGate">();
	}
	static class UFeatureGate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFeatureGate>();
	}
};
static_assert(alignof(UFeatureGate) == 0x000008, "Wrong alignment on UFeatureGate");
static_assert(sizeof(UFeatureGate) == 0x000178, "Wrong size on UFeatureGate");

// Class DeadByDaylight.DBDBasePlayer
// 0x00E0 (0x0730 - 0x0650)
#pragma pack(push, 0x1)
class alignas(0x10) ADBDBasePlayer : public ACharacter
{
public:
	uint8                                         Pad_650[0x8];                                      // 0x0650(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnCustomizationChanged;                            // 0x0658(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_668[0x20];                                     // 0x0668(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  _semanticGameplayTags;                             // 0x0688(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UBaseGroundDetectorComponent*           _leftFootGroundDetector;                           // 0x06A8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBaseGroundDetectorComponent*           _rightFootGroundDetector;                          // 0x06B0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBaseGroundDetectorComponent*           _leftFrontFootGroundDetector;                      // 0x06B8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBaseGroundDetectorComponent*           _rightFrontFootGroundDetector;                     // 0x06C0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMontagePlayer*                         _montagePlayer;                                    // 0x06C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6D0[0x8];                                      // 0x06D0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _characterIndex;                                   // 0x06D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6DC[0x4C];                                     // 0x06DC(0x004C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DBD_SwapCosmetics(class FName CosmeticId);
	void Multicast_SwapCosmetics(class FName CosmeticId);
	void OnAnimInstanceChanged();
	void OnCurrentMontageBlendingOut(class UAnimMontage* MontageAsset, bool Interrupted);
	void OnCurrentMontageComplete(class UAnimMontage* MontageAsset, bool Interrupted);
	class UAnimMontage* PlayMontage(const struct FAnimationMontageDescriptor& AnimMontageID, float PlayRate, bool IsFollower);
	void StopMontage();
	bool TeleportWithClothHandling(const struct FVector& Location, const struct FRotator& Rotation, bool CheckCollisions);

	class UAnimInstance* GetAnimInstance() const;
	void GetAnimTags(TArray<class FName>* OutTags) const;
	class UAkComponent* GetAudioComponent() const;
	int32 GetCharacterIndex() const;
	class FName GetCharacterName() const;
	class UCustomizedAudioComponent* GetCustomizedAudio() const;
	class UCustomizedSkeletalMesh* GetCustomizedSkeletalMesh() const;
	class FString GetLeftFootAudioSurfaceName() const;
	EPhysicalSurface GetLeftFootSurfaceType() const;
	class FString GetLeftFrontFootAudioSurfaceName() const;
	EPhysicalSurface GetLeftFrontFootSurfaceType() const;
	class UAnimMontage* GetMontage(const struct FAnimationMontageDescriptor& AnimMontageID) const;
	float GetMontageLength(const struct FAnimationMontageDescriptor& AnimMontageID) const;
	struct FMontagePlaybackDefinition GetMontagePlaybackDefinition(const struct FAnimationMontageDescriptor& AnimMontageID, float PlayRate, bool IsFollower) const;
	class UMontagePlayer* GetMontagePlayer() const;
	class FString GetRightFootAudioSurfaceName() const;
	EPhysicalSurface GetRightFootSurfaceType() const;
	class FString GetRightFrontFootAudioSurfaceName() const;
	EPhysicalSurface GetRightFrontFootSurfaceType() const;
	const struct FGameplayTagContainer GetSemanticTag() const;
	bool GetShowBlindDebugInfo() const;
	bool IsPlayingAnyMontage() const;
	bool IsPlayingMontage(const struct FAnimationMontageDescriptor& AnimMontageID) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDBasePlayer">();
	}
	static class ADBDBasePlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDBasePlayer>();
	}
};
#pragma pack(pop)
static_assert(alignof(ADBDBasePlayer) == 0x000010, "Wrong alignment on ADBDBasePlayer");
static_assert(sizeof(ADBDBasePlayer) == 0x000730, "Wrong size on ADBDBasePlayer");
static_assert(offsetof(ADBDBasePlayer, OnCustomizationChanged) == 0x000658, "Member 'ADBDBasePlayer::OnCustomizationChanged' has a wrong offset!");
static_assert(offsetof(ADBDBasePlayer, _semanticGameplayTags) == 0x000688, "Member 'ADBDBasePlayer::_semanticGameplayTags' has a wrong offset!");
static_assert(offsetof(ADBDBasePlayer, _leftFootGroundDetector) == 0x0006A8, "Member 'ADBDBasePlayer::_leftFootGroundDetector' has a wrong offset!");
static_assert(offsetof(ADBDBasePlayer, _rightFootGroundDetector) == 0x0006B0, "Member 'ADBDBasePlayer::_rightFootGroundDetector' has a wrong offset!");
static_assert(offsetof(ADBDBasePlayer, _leftFrontFootGroundDetector) == 0x0006B8, "Member 'ADBDBasePlayer::_leftFrontFootGroundDetector' has a wrong offset!");
static_assert(offsetof(ADBDBasePlayer, _rightFrontFootGroundDetector) == 0x0006C0, "Member 'ADBDBasePlayer::_rightFrontFootGroundDetector' has a wrong offset!");
static_assert(offsetof(ADBDBasePlayer, _montagePlayer) == 0x0006C8, "Member 'ADBDBasePlayer::_montagePlayer' has a wrong offset!");
static_assert(offsetof(ADBDBasePlayer, _characterIndex) == 0x0006D8, "Member 'ADBDBasePlayer::_characterIndex' has a wrong offset!");

// Class DeadByDaylight.WalesCypherHandler
// 0x0010 (0x0048 - 0x0038)
class UWalesCypherHandler final : public ULocalPlayerSubsystem
{
public:
	class UWalesCypherParameters*                 _walesCypherParams;                                // 0x0038(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WalesCypherHandler">();
	}
	static class UWalesCypherHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWalesCypherHandler>();
	}
};
static_assert(alignof(UWalesCypherHandler) == 0x000008, "Wrong alignment on UWalesCypherHandler");
static_assert(sizeof(UWalesCypherHandler) == 0x000048, "Wrong size on UWalesCypherHandler");
static_assert(offsetof(UWalesCypherHandler, _walesCypherParams) == 0x000038, "Member 'UWalesCypherHandler::_walesCypherParams' has a wrong offset!");

// Class DeadByDaylight.BaseHitValidationConfigurator
// 0x0008 (0x00B0 - 0x00A8)
class UBaseHitValidationConfigurator : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseHitValidationConfigurator">();
	}
	static class UBaseHitValidationConfigurator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseHitValidationConfigurator>();
	}
};
static_assert(alignof(UBaseHitValidationConfigurator) == 0x000008, "Wrong alignment on UBaseHitValidationConfigurator");
static_assert(sizeof(UBaseHitValidationConfigurator) == 0x0000B0, "Wrong size on UBaseHitValidationConfigurator");

// Class DeadByDaylight.ObjectPlacementValidationStrategy
// 0x0000 (0x00A8 - 0x00A8)
class UObjectPlacementValidationStrategy : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ObjectPlacementValidationStrategy">();
	}
	static class UObjectPlacementValidationStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UObjectPlacementValidationStrategy>();
	}
};
static_assert(alignof(UObjectPlacementValidationStrategy) == 0x000008, "Wrong alignment on UObjectPlacementValidationStrategy");
static_assert(sizeof(UObjectPlacementValidationStrategy) == 0x0000A8, "Wrong size on UObjectPlacementValidationStrategy");

// Class DeadByDaylight.DefaultObjectPlacementValidationStrategy
// 0x0050 (0x00F8 - 0x00A8)
class UDefaultObjectPlacementValidationStrategy : public UObjectPlacementValidationStrategy
{
public:
	TArray<class AActor*>                         _ignoredActors;                                    // 0x00A8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	struct FVector                                _objectPlacementRaycastStart;                      // 0x00B8(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                _objectPlacementRaycastEnd;                        // 0x00D0(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FFloatRange                            _objectHeightRangeAroundBaseLocation;              // 0x00E8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DefaultObjectPlacementValidationStrategy">();
	}
	static class UDefaultObjectPlacementValidationStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDefaultObjectPlacementValidationStrategy>();
	}
};
static_assert(alignof(UDefaultObjectPlacementValidationStrategy) == 0x000008, "Wrong alignment on UDefaultObjectPlacementValidationStrategy");
static_assert(sizeof(UDefaultObjectPlacementValidationStrategy) == 0x0000F8, "Wrong size on UDefaultObjectPlacementValidationStrategy");
static_assert(offsetof(UDefaultObjectPlacementValidationStrategy, _ignoredActors) == 0x0000A8, "Member 'UDefaultObjectPlacementValidationStrategy::_ignoredActors' has a wrong offset!");
static_assert(offsetof(UDefaultObjectPlacementValidationStrategy, _objectPlacementRaycastStart) == 0x0000B8, "Member 'UDefaultObjectPlacementValidationStrategy::_objectPlacementRaycastStart' has a wrong offset!");
static_assert(offsetof(UDefaultObjectPlacementValidationStrategy, _objectPlacementRaycastEnd) == 0x0000D0, "Member 'UDefaultObjectPlacementValidationStrategy::_objectPlacementRaycastEnd' has a wrong offset!");
static_assert(offsetof(UDefaultObjectPlacementValidationStrategy, _objectHeightRangeAroundBaseLocation) == 0x0000E8, "Member 'UDefaultObjectPlacementValidationStrategy::_objectHeightRangeAroundBaseLocation' has a wrong offset!");

// Class DeadByDaylight.ObjectPlacementValidationWithRestrictionStrategy
// 0x0010 (0x0108 - 0x00F8)
class UObjectPlacementValidationWithRestrictionStrategy : public UDefaultObjectPlacementValidationStrategy
{
public:
	TArray<class URestrictedPlacementAreaStrategy*> _restrictedAreas;                                  // 0x00F8(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, NoClear, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	void OnIntroComplete();
	void OnLevelReadyToPlay();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ObjectPlacementValidationWithRestrictionStrategy">();
	}
	static class UObjectPlacementValidationWithRestrictionStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UObjectPlacementValidationWithRestrictionStrategy>();
	}
};
static_assert(alignof(UObjectPlacementValidationWithRestrictionStrategy) == 0x000008, "Wrong alignment on UObjectPlacementValidationWithRestrictionStrategy");
static_assert(sizeof(UObjectPlacementValidationWithRestrictionStrategy) == 0x000108, "Wrong size on UObjectPlacementValidationWithRestrictionStrategy");
static_assert(offsetof(UObjectPlacementValidationWithRestrictionStrategy, _restrictedAreas) == 0x0000F8, "Member 'UObjectPlacementValidationWithRestrictionStrategy::_restrictedAreas' has a wrong offset!");

// Class DeadByDaylight.CharacterCollection
// 0x02D8 (0x0380 - 0x00A8)
class UCharacterCollection final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0xF0];                                      // 0x00A8(0x00F0)(Fixing Size After Last Property [ Dumper-7 ])
	class ASlasherPlayer*                         _killer;                                           // 0x0198(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSet<class ASlasherPlayer*>                   _killers;                                          // 0x01A0(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TSet<class ACamperPlayer*>                    _survivors;                                        // 0x01F0(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TSet<class ADBDPlayer*>                       _mainDBDPlayers;                                   // 0x0240(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TSet<class ADBDPlayer*>                       _otherCharacters;                                  // 0x0290(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TSet<class ACharacter*>                       _nonPlayableCharacters;                            // 0x02E0(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TSet<class ACharacter*>                       _allCharacters;                                    // 0x0330(0x0050)(Transient, NativeAccessSpecifierPrivate)

public:
	const TArray<class ADBDPlayer*> GetAllDBDPlayers() const;
	class ASlasherPlayer* GetKiller() const;
	const TSet<class ASlasherPlayer*> GetKillers() const;
	const TSet<class ADBDPlayer*> GetMainDBDPlayers() const;
	const TSet<class ADBDPlayer*> GetOtherCharacters() const;
	const TSet<class ACamperPlayer*> GetSurvivors() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterCollection">();
	}
	static class UCharacterCollection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterCollection>();
	}
};
static_assert(alignof(UCharacterCollection) == 0x000008, "Wrong alignment on UCharacterCollection");
static_assert(sizeof(UCharacterCollection) == 0x000380, "Wrong size on UCharacterCollection");
static_assert(offsetof(UCharacterCollection, _killer) == 0x000198, "Member 'UCharacterCollection::_killer' has a wrong offset!");
static_assert(offsetof(UCharacterCollection, _killers) == 0x0001A0, "Member 'UCharacterCollection::_killers' has a wrong offset!");
static_assert(offsetof(UCharacterCollection, _survivors) == 0x0001F0, "Member 'UCharacterCollection::_survivors' has a wrong offset!");
static_assert(offsetof(UCharacterCollection, _mainDBDPlayers) == 0x000240, "Member 'UCharacterCollection::_mainDBDPlayers' has a wrong offset!");
static_assert(offsetof(UCharacterCollection, _otherCharacters) == 0x000290, "Member 'UCharacterCollection::_otherCharacters' has a wrong offset!");
static_assert(offsetof(UCharacterCollection, _nonPlayableCharacters) == 0x0002E0, "Member 'UCharacterCollection::_nonPlayableCharacters' has a wrong offset!");
static_assert(offsetof(UCharacterCollection, _allCharacters) == 0x000330, "Member 'UCharacterCollection::_allCharacters' has a wrong offset!");

// Class DeadByDaylight.LevelReadyToPlayPlayerComponent
// 0x0070 (0x0118 - 0x00A8)
class ULevelReadyToPlayPlayerComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x40];                                      // 0x00A8(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLevelReadyToPlayRequirements>  _levelReadyToPlayRequirementsTarget;               // 0x00E8(0x0010)(Net, ZeroConstructor, Transient, RepNotify, NativeAccessSpecifierPrivate)
	TArray<struct FLevelReadyToPlayRequirements>  _levelReadyToPlayRequirementState;                 // 0x00F8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_108[0x10];                                     // 0x0108(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_LevelReadyToPlayRequirementsTarget();
	void Server_SetIsReadyToPlay(const struct FFilesInformation& HackInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelReadyToPlayPlayerComponent">();
	}
	static class ULevelReadyToPlayPlayerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULevelReadyToPlayPlayerComponent>();
	}
};
static_assert(alignof(ULevelReadyToPlayPlayerComponent) == 0x000008, "Wrong alignment on ULevelReadyToPlayPlayerComponent");
static_assert(sizeof(ULevelReadyToPlayPlayerComponent) == 0x000118, "Wrong size on ULevelReadyToPlayPlayerComponent");
static_assert(offsetof(ULevelReadyToPlayPlayerComponent, _levelReadyToPlayRequirementsTarget) == 0x0000E8, "Member 'ULevelReadyToPlayPlayerComponent::_levelReadyToPlayRequirementsTarget' has a wrong offset!");
static_assert(offsetof(ULevelReadyToPlayPlayerComponent, _levelReadyToPlayRequirementState) == 0x0000F8, "Member 'ULevelReadyToPlayPlayerComponent::_levelReadyToPlayRequirementState' has a wrong offset!");

// Class DeadByDaylight.KillerProjectile
// 0x0080 (0x03A8 - 0x0328)
class AKillerProjectile : public APhysicsBasedProjectile
{
public:
	uint8                                         Pad_328[0x48];                                     // 0x0328(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           _killerProjectileAttemptGameEventTag;              // 0x0370(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_37C[0x4];                                      // 0x037C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UHitValidatorConfigurator*              _hitValidatorConfigurator;                         // 0x0380(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHitValidatorComponent*                 _hitValidatorComponent;                            // 0x0388(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EHitValidatorConfigName                       _hitValidationConfigName;                          // 0x0390(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_391[0x17];                                     // 0x0391(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetActiveSlashable(bool Active);

	class ASlasherPlayer* GetLaunchingKiller() const;
	class UPrimitiveComponent* GetPlayerPrimitiveComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerProjectile">();
	}
	static class AKillerProjectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKillerProjectile>();
	}
};
static_assert(alignof(AKillerProjectile) == 0x000008, "Wrong alignment on AKillerProjectile");
static_assert(sizeof(AKillerProjectile) == 0x0003A8, "Wrong size on AKillerProjectile");
static_assert(offsetof(AKillerProjectile, _killerProjectileAttemptGameEventTag) == 0x000370, "Member 'AKillerProjectile::_killerProjectileAttemptGameEventTag' has a wrong offset!");
static_assert(offsetof(AKillerProjectile, _hitValidatorConfigurator) == 0x000380, "Member 'AKillerProjectile::_hitValidatorConfigurator' has a wrong offset!");
static_assert(offsetof(AKillerProjectile, _hitValidatorComponent) == 0x000388, "Member 'AKillerProjectile::_hitValidatorComponent' has a wrong offset!");
static_assert(offsetof(AKillerProjectile, _hitValidationConfigName) == 0x000390, "Member 'AKillerProjectile::_hitValidationConfigName' has a wrong offset!");

// Class DeadByDaylight.CurrencyDisplayable
// 0x0068 (0x0308 - 0x02A0)
class ACurrencyDisplayable final : public AActor
{
public:
	uint8                                         Pad_2A0[0x8];                                      // 0x02A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UDBDSkeletalMeshComponentBudgeted*      SkeletalMeshComponent;                             // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<ECurrencyType, class USkeletalMesh*>     _currencyMeshes;                                   // 0x02B0(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_300[0x8];                                      // 0x0300(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BeginDestroySequence_Internal();
	void FinishSpawningCurrency(ECurrencyType CurrencyType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CurrencyDisplayable">();
	}
	static class ACurrencyDisplayable* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACurrencyDisplayable>();
	}
};
static_assert(alignof(ACurrencyDisplayable) == 0x000008, "Wrong alignment on ACurrencyDisplayable");
static_assert(sizeof(ACurrencyDisplayable) == 0x000308, "Wrong size on ACurrencyDisplayable");
static_assert(offsetof(ACurrencyDisplayable, SkeletalMeshComponent) == 0x0002A8, "Member 'ACurrencyDisplayable::SkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(ACurrencyDisplayable, _currencyMeshes) == 0x0002B0, "Member 'ACurrencyDisplayable::_currencyMeshes' has a wrong offset!");

// Class DeadByDaylight.SpawnElementTrackerComponent
// 0x0010 (0x00B8 - 0x00A8)
class USpawnElementTrackerComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x10];                                      // 0x00A8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpawnElementTrackerComponent">();
	}
	static class USpawnElementTrackerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpawnElementTrackerComponent>();
	}
};
static_assert(alignof(USpawnElementTrackerComponent) == 0x000008, "Wrong alignment on USpawnElementTrackerComponent");
static_assert(sizeof(USpawnElementTrackerComponent) == 0x0000B8, "Wrong size on USpawnElementTrackerComponent");

// Class DeadByDaylight.DBDAttackOpenSubstate
// 0x0000 (0x0118 - 0x0118)
class UDBDAttackOpenSubstate : public UDBDAttackSubstate
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDAttackOpenSubstate">();
	}
	static class UDBDAttackOpenSubstate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDAttackOpenSubstate>();
	}
};
static_assert(alignof(UDBDAttackOpenSubstate) == 0x000008, "Wrong alignment on UDBDAttackOpenSubstate");
static_assert(sizeof(UDBDAttackOpenSubstate) == 0x000118, "Wrong size on UDBDAttackOpenSubstate");

// Class DeadByDaylight.PlayerInteractable
// 0x0038 (0x03E0 - 0x03A8)
class APlayerInteractable : public AInteractable
{
public:
	class UPrimitiveComponent*                    _mainInteractionZone;                              // 0x03A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractor*                            _selfInteractionsInteractor;                       // 0x03B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        _rootComponent;                                    // 0x03B8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C0[0x20];                                     // 0x03C0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitInteractable(class ADBDPlayer* Player);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerInteractable">();
	}
	static class APlayerInteractable* GetDefaultObj()
	{
		return GetDefaultObjImpl<APlayerInteractable>();
	}
};
static_assert(alignof(APlayerInteractable) == 0x000008, "Wrong alignment on APlayerInteractable");
static_assert(sizeof(APlayerInteractable) == 0x0003E0, "Wrong size on APlayerInteractable");
static_assert(offsetof(APlayerInteractable, _mainInteractionZone) == 0x0003A8, "Member 'APlayerInteractable::_mainInteractionZone' has a wrong offset!");
static_assert(offsetof(APlayerInteractable, _selfInteractionsInteractor) == 0x0003B0, "Member 'APlayerInteractable::_selfInteractionsInteractor' has a wrong offset!");
static_assert(offsetof(APlayerInteractable, _rootComponent) == 0x0003B8, "Member 'APlayerInteractable::_rootComponent' has a wrong offset!");

// Class DeadByDaylight.GhostStalkedUIData
// 0x0000 (0x0030 - 0x0030)
class IGhostStalkedUIData final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GhostStalkedUIData">();
	}
	static class IGhostStalkedUIData* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGhostStalkedUIData>();
	}
};
static_assert(alignof(IGhostStalkedUIData) == 0x000008, "Wrong alignment on IGhostStalkedUIData");
static_assert(sizeof(IGhostStalkedUIData) == 0x000030, "Wrong size on IGhostStalkedUIData");

// Class DeadByDaylight.CompetenceAction
// 0x0010 (0x0040 - 0x0030)
class UCompetenceAction : public UObject
{
public:
	class UGameplayModifierContainer*             _owningContainer;                                  // 0x0030(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnApplyBegin();
	void OnApplyEnd();

	class ADBDPlayer* GetOwningPlayer() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CompetenceAction">();
	}
	static class UCompetenceAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCompetenceAction>();
	}
};
static_assert(alignof(UCompetenceAction) == 0x000008, "Wrong alignment on UCompetenceAction");
static_assert(sizeof(UCompetenceAction) == 0x000040, "Wrong size on UCompetenceAction");
static_assert(offsetof(UCompetenceAction, _owningContainer) == 0x000030, "Member 'UCompetenceAction::_owningContainer' has a wrong offset!");

// Class DeadByDaylight.DBDNavEvadeLoopComponent
// 0x00B0 (0x0158 - 0x00A8)
class UDBDNavEvadeLoopComponent final : public UActorComponent
{
public:
	struct FVector                                EvadeDoorExtent;                                   // 0x00A8(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EvadeDoorFrontPointOffset;                         // 0x00C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EvadeDoorSideOffset;                               // 0x00C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SideBlockerOffset;                                 // 0x00C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoSnapPointsUpHeight;                            // 0x00CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoSnapPointsDownHeight;                          // 0x00D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             AutoSnapCollisionChannel;                          // 0x00D4(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D5[0x3];                                       // 0x00D5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UNavigationQueryFilter>     EvadeLoopFilterClass;                              // 0x00D8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinSafetyLength;                                   // 0x00E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSafetyLength;                                   // 0x00E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAIEvadeLoopSides                             LimitToSide;                                       // 0x00E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RequiresEvadeLoopModifier;                         // 0x00E9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DebugEditMode;                                     // 0x00EA(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DrawDebugFilter;                                   // 0x00EB(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EC[0x6C];                                      // 0x00EC(0x006C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnLevelReadyToPlay();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDNavEvadeLoopComponent">();
	}
	static class UDBDNavEvadeLoopComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDNavEvadeLoopComponent>();
	}
};
static_assert(alignof(UDBDNavEvadeLoopComponent) == 0x000008, "Wrong alignment on UDBDNavEvadeLoopComponent");
static_assert(sizeof(UDBDNavEvadeLoopComponent) == 0x000158, "Wrong size on UDBDNavEvadeLoopComponent");
static_assert(offsetof(UDBDNavEvadeLoopComponent, EvadeDoorExtent) == 0x0000A8, "Member 'UDBDNavEvadeLoopComponent::EvadeDoorExtent' has a wrong offset!");
static_assert(offsetof(UDBDNavEvadeLoopComponent, EvadeDoorFrontPointOffset) == 0x0000C0, "Member 'UDBDNavEvadeLoopComponent::EvadeDoorFrontPointOffset' has a wrong offset!");
static_assert(offsetof(UDBDNavEvadeLoopComponent, EvadeDoorSideOffset) == 0x0000C4, "Member 'UDBDNavEvadeLoopComponent::EvadeDoorSideOffset' has a wrong offset!");
static_assert(offsetof(UDBDNavEvadeLoopComponent, SideBlockerOffset) == 0x0000C8, "Member 'UDBDNavEvadeLoopComponent::SideBlockerOffset' has a wrong offset!");
static_assert(offsetof(UDBDNavEvadeLoopComponent, AutoSnapPointsUpHeight) == 0x0000CC, "Member 'UDBDNavEvadeLoopComponent::AutoSnapPointsUpHeight' has a wrong offset!");
static_assert(offsetof(UDBDNavEvadeLoopComponent, AutoSnapPointsDownHeight) == 0x0000D0, "Member 'UDBDNavEvadeLoopComponent::AutoSnapPointsDownHeight' has a wrong offset!");
static_assert(offsetof(UDBDNavEvadeLoopComponent, AutoSnapCollisionChannel) == 0x0000D4, "Member 'UDBDNavEvadeLoopComponent::AutoSnapCollisionChannel' has a wrong offset!");
static_assert(offsetof(UDBDNavEvadeLoopComponent, EvadeLoopFilterClass) == 0x0000D8, "Member 'UDBDNavEvadeLoopComponent::EvadeLoopFilterClass' has a wrong offset!");
static_assert(offsetof(UDBDNavEvadeLoopComponent, MinSafetyLength) == 0x0000E0, "Member 'UDBDNavEvadeLoopComponent::MinSafetyLength' has a wrong offset!");
static_assert(offsetof(UDBDNavEvadeLoopComponent, MaxSafetyLength) == 0x0000E4, "Member 'UDBDNavEvadeLoopComponent::MaxSafetyLength' has a wrong offset!");
static_assert(offsetof(UDBDNavEvadeLoopComponent, LimitToSide) == 0x0000E8, "Member 'UDBDNavEvadeLoopComponent::LimitToSide' has a wrong offset!");
static_assert(offsetof(UDBDNavEvadeLoopComponent, RequiresEvadeLoopModifier) == 0x0000E9, "Member 'UDBDNavEvadeLoopComponent::RequiresEvadeLoopModifier' has a wrong offset!");
static_assert(offsetof(UDBDNavEvadeLoopComponent, DebugEditMode) == 0x0000EA, "Member 'UDBDNavEvadeLoopComponent::DebugEditMode' has a wrong offset!");
static_assert(offsetof(UDBDNavEvadeLoopComponent, DrawDebugFilter) == 0x0000EB, "Member 'UDBDNavEvadeLoopComponent::DrawDebugFilter' has a wrong offset!");

// Class DeadByDaylight.CustomizationHelper
// 0x0000 (0x0030 - 0x0030)
class UCustomizationHelper final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomizationHelper">();
	}
	static class UCustomizationHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomizationHelper>();
	}
};
static_assert(alignof(UCustomizationHelper) == 0x000008, "Wrong alignment on UCustomizationHelper");
static_assert(sizeof(UCustomizationHelper) == 0x000030, "Wrong size on UCustomizationHelper");

// Class DeadByDaylight.CharacterDataSubsystem
// 0x0000 (0x0038 - 0x0038)
class UCharacterDataSubsystem final : public UGameInstanceSubsystem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterDataSubsystem">();
	}
	static class UCharacterDataSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterDataSubsystem>();
	}
};
static_assert(alignof(UCharacterDataSubsystem) == 0x000008, "Wrong alignment on UCharacterDataSubsystem");
static_assert(sizeof(UCharacterDataSubsystem) == 0x000038, "Wrong size on UCharacterDataSubsystem");

// Class DeadByDaylight.AISenseConfig_PointOfInterest
// 0x0010 (0x0060 - 0x0050)
class UAISenseConfig_PointOfInterest final : public UAISenseConfig
{
public:
	TSubclassOf<class UAISense_PointOfInterest>   Implementation;                                    // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoClear, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinGeneratorRepairSoundRange;                      // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxGeneratorRepairSoundRange;                      // 0x005C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISenseConfig_PointOfInterest">();
	}
	static class UAISenseConfig_PointOfInterest* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISenseConfig_PointOfInterest>();
	}
};
static_assert(alignof(UAISenseConfig_PointOfInterest) == 0x000008, "Wrong alignment on UAISenseConfig_PointOfInterest");
static_assert(sizeof(UAISenseConfig_PointOfInterest) == 0x000060, "Wrong size on UAISenseConfig_PointOfInterest");
static_assert(offsetof(UAISenseConfig_PointOfInterest, Implementation) == 0x000050, "Member 'UAISenseConfig_PointOfInterest::Implementation' has a wrong offset!");
static_assert(offsetof(UAISenseConfig_PointOfInterest, MinGeneratorRepairSoundRange) == 0x000058, "Member 'UAISenseConfig_PointOfInterest::MinGeneratorRepairSoundRange' has a wrong offset!");
static_assert(offsetof(UAISenseConfig_PointOfInterest, MaxGeneratorRepairSoundRange) == 0x00005C, "Member 'UAISenseConfig_PointOfInterest::MaxGeneratorRepairSoundRange' has a wrong offset!");

// Class DeadByDaylight.DBDAttackSuccessSubstate
// 0x0000 (0x0118 - 0x0118)
class UDBDAttackSuccessSubstate : public UDBDAttackSubstate
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDAttackSuccessSubstate">();
	}
	static class UDBDAttackSuccessSubstate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDAttackSuccessSubstate>();
	}
};
static_assert(alignof(UDBDAttackSuccessSubstate) == 0x000008, "Wrong alignment on UDBDAttackSuccessSubstate");
static_assert(sizeof(UDBDAttackSuccessSubstate) == 0x000118, "Wrong size on UDBDAttackSuccessSubstate");

// Class DeadByDaylight.AICharacterBehaviourData
// 0x0000 (0x0030 - 0x0030)
class UAICharacterBehaviourData : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AICharacterBehaviourData">();
	}
	static class UAICharacterBehaviourData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAICharacterBehaviourData>();
	}
};
static_assert(alignof(UAICharacterBehaviourData) == 0x000008, "Wrong alignment on UAICharacterBehaviourData");
static_assert(sizeof(UAICharacterBehaviourData) == 0x000030, "Wrong size on UAICharacterBehaviourData");

// Class DeadByDaylight.AIMoveToPositionData
// 0x0010 (0x0040 - 0x0030)
class UAIMoveToPositionData final : public UAICharacterBehaviourData
{
public:
	class AActor*                                 _positionActor;                                    // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECharacterMovementTypes                       _movementType;                                     // 0x0038(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _usePathfinding;                                   // 0x0039(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A[0x6];                                       // 0x003A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Init(class AActor* PositionActor, ECharacterMovementTypes MovementType, bool UsePathfinding);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIMoveToPositionData">();
	}
	static class UAIMoveToPositionData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIMoveToPositionData>();
	}
};
static_assert(alignof(UAIMoveToPositionData) == 0x000008, "Wrong alignment on UAIMoveToPositionData");
static_assert(sizeof(UAIMoveToPositionData) == 0x000040, "Wrong size on UAIMoveToPositionData");
static_assert(offsetof(UAIMoveToPositionData, _positionActor) == 0x000030, "Member 'UAIMoveToPositionData::_positionActor' has a wrong offset!");
static_assert(offsetof(UAIMoveToPositionData, _movementType) == 0x000038, "Member 'UAIMoveToPositionData::_movementType' has a wrong offset!");
static_assert(offsetof(UAIMoveToPositionData, _usePathfinding) == 0x000039, "Member 'UAIMoveToPositionData::_usePathfinding' has a wrong offset!");

// Class DeadByDaylight.MapSpecificGameStateComponent
// 0x0000 (0x00A8 - 0x00A8)
class UMapSpecificGameStateComponent : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapSpecificGameStateComponent">();
	}
	static class UMapSpecificGameStateComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapSpecificGameStateComponent>();
	}
};
static_assert(alignof(UMapSpecificGameStateComponent) == 0x000008, "Wrong alignment on UMapSpecificGameStateComponent");
static_assert(sizeof(UMapSpecificGameStateComponent) == 0x0000A8, "Wrong size on UMapSpecificGameStateComponent");

// Class DeadByDaylight.BlockElement
// 0x0078 (0x00A8 - 0x0030)
class UBlockElement final : public UObject
{
public:
	TWeakObjectPtr<class UObject>                 _source;                                           // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSet<TWeakObjectPtr<class ADBDPlayer>>        _affectedPlayers;                                  // 0x0038(0x0050)(Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_88[0x20];                                      // 0x0088(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlockElement">();
	}
	static class UBlockElement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlockElement>();
	}
};
static_assert(alignof(UBlockElement) == 0x000008, "Wrong alignment on UBlockElement");
static_assert(sizeof(UBlockElement) == 0x0000A8, "Wrong size on UBlockElement");
static_assert(offsetof(UBlockElement, _source) == 0x000030, "Member 'UBlockElement::_source' has a wrong offset!");
static_assert(offsetof(UBlockElement, _affectedPlayers) == 0x000038, "Member 'UBlockElement::_affectedPlayers' has a wrong offset!");

// Class DeadByDaylight.EventSpawnableComponent
// 0x0050 (0x0310 - 0x02C0)
class UEventSpawnableComponent final : public USceneComponent
{
public:
	TArray<struct FEventSpawnablePositionDropdown> SpawnPositionPreferences;                          // 0x02C0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FVector                                Bound;                                             // 0x02D0(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BudgetOverride;                                    // 0x02E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2EC[0x4];                                      // 0x02EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBoxComponent*                          _boundBox;                                         // 0x02F0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2F8[0x18];                                     // 0x02F8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventSpawnableComponent">();
	}
	static class UEventSpawnableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventSpawnableComponent>();
	}
};
static_assert(alignof(UEventSpawnableComponent) == 0x000010, "Wrong alignment on UEventSpawnableComponent");
static_assert(sizeof(UEventSpawnableComponent) == 0x000310, "Wrong size on UEventSpawnableComponent");
static_assert(offsetof(UEventSpawnableComponent, SpawnPositionPreferences) == 0x0002C0, "Member 'UEventSpawnableComponent::SpawnPositionPreferences' has a wrong offset!");
static_assert(offsetof(UEventSpawnableComponent, Bound) == 0x0002D0, "Member 'UEventSpawnableComponent::Bound' has a wrong offset!");
static_assert(offsetof(UEventSpawnableComponent, BudgetOverride) == 0x0002E8, "Member 'UEventSpawnableComponent::BudgetOverride' has a wrong offset!");
static_assert(offsetof(UEventSpawnableComponent, _boundBox) == 0x0002F0, "Member 'UEventSpawnableComponent::_boundBox' has a wrong offset!");

// Class DeadByDaylight.DBDAttackMissSubstate
// 0x0000 (0x0118 - 0x0118)
class UDBDAttackMissSubstate : public UDBDAttackSubstate
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDAttackMissSubstate">();
	}
	static class UDBDAttackMissSubstate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDAttackMissSubstate>();
	}
};
static_assert(alignof(UDBDAttackMissSubstate) == 0x000008, "Wrong alignment on UDBDAttackMissSubstate");
static_assert(sizeof(UDBDAttackMissSubstate) == 0x000118, "Wrong size on UDBDAttackMissSubstate");

// Class DeadByDaylight.LobbyDialogueSubsystem
// 0x0058 (0x0090 - 0x0038)
class ULobbyDialogueSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x58];                                      // 0x0038(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void CountGuestLobbyMembersWithAudioSwitch(EAudioCustomizationCategory SwitchCategory, const TArray<class FString>& AudioSwitches, int32* NumMatching, int32* NumNotMatching);
	static TArray<class ADBDMenuPlayer*> GetGuestLobbyMembers();
	static bool HasCharacterPlayedDialogueForThisLobby(const class FString& CharacterName, int32 DialogueId);
	static bool IsLobbyFullForRole(EPlayerRole Role);
	static void NotifyCharacterPlayedDialogueForThisLobby(const class FString& CharacterName, int32 DialogueId);
	static void NotifyDialogueInterrupted();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LobbyDialogueSubsystem">();
	}
	static class ULobbyDialogueSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULobbyDialogueSubsystem>();
	}
};
static_assert(alignof(ULobbyDialogueSubsystem) == 0x000008, "Wrong alignment on ULobbyDialogueSubsystem");
static_assert(sizeof(ULobbyDialogueSubsystem) == 0x000090, "Wrong size on ULobbyDialogueSubsystem");

// Class DeadByDaylight.GameEventTracker
// 0x0038 (0x0068 - 0x0030)
class UGameEventTracker final : public UObject
{
public:
	FMulticastInlineDelegateProperty_             OnGameplayEvent;                                   // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnGameflowEvent;                                   // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x18];                                      // 0x0050(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FireGameEvent(EDBDScoreTypes EventType, float Amount, class AActor* Instigator, class AActor* Target);
	void FireGameflowEvent(EDBDScoreTypes EventType, float Amount, const class ADBDPlayerState* Instigator, class FName Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameEventTracker">();
	}
	static class UGameEventTracker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameEventTracker>();
	}
};
static_assert(alignof(UGameEventTracker) == 0x000008, "Wrong alignment on UGameEventTracker");
static_assert(sizeof(UGameEventTracker) == 0x000068, "Wrong size on UGameEventTracker");
static_assert(offsetof(UGameEventTracker, OnGameplayEvent) == 0x000030, "Member 'UGameEventTracker::OnGameplayEvent' has a wrong offset!");
static_assert(offsetof(UGameEventTracker, OnGameflowEvent) == 0x000040, "Member 'UGameEventTracker::OnGameflowEvent' has a wrong offset!");

// Class DeadByDaylight.ActorNavMovementComponent
// 0x0028 (0x0188 - 0x0160)
class UActorNavMovementComponent : public UNavMovementComponent
{
public:
	class AActor*                                 _owningActor;                                      // 0x0160(0x0008)(ZeroConstructor, Transient, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPathFollowingComponent*                _pathFollowingComponent;                           // 0x0168(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, DuplicateTransient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bPositionCorrected : 1;                            // 0x0170(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_171[0x3];                                      // 0x0171(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _maxSpeed;                                         // 0x0174(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _acceleration;                                     // 0x0178(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _deceleration;                                     // 0x017C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _brakingDeceleration;                              // 0x0180(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_184[0x4];                                      // 0x0184(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetAcceleration(float Acceleration);
	void SetDeceleration(float Deceleration);
	void SetMaxSpeed(float MaxSpeed);

	class AActor* GetOwningActor() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActorNavMovementComponent">();
	}
	static class UActorNavMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActorNavMovementComponent>();
	}
};
static_assert(alignof(UActorNavMovementComponent) == 0x000008, "Wrong alignment on UActorNavMovementComponent");
static_assert(sizeof(UActorNavMovementComponent) == 0x000188, "Wrong size on UActorNavMovementComponent");
static_assert(offsetof(UActorNavMovementComponent, _owningActor) == 0x000160, "Member 'UActorNavMovementComponent::_owningActor' has a wrong offset!");
static_assert(offsetof(UActorNavMovementComponent, _pathFollowingComponent) == 0x000168, "Member 'UActorNavMovementComponent::_pathFollowingComponent' has a wrong offset!");
static_assert(offsetof(UActorNavMovementComponent, _maxSpeed) == 0x000174, "Member 'UActorNavMovementComponent::_maxSpeed' has a wrong offset!");
static_assert(offsetof(UActorNavMovementComponent, _acceleration) == 0x000178, "Member 'UActorNavMovementComponent::_acceleration' has a wrong offset!");
static_assert(offsetof(UActorNavMovementComponent, _deceleration) == 0x00017C, "Member 'UActorNavMovementComponent::_deceleration' has a wrong offset!");
static_assert(offsetof(UActorNavMovementComponent, _brakingDeceleration) == 0x000180, "Member 'UActorNavMovementComponent::_brakingDeceleration' has a wrong offset!");

// Class DeadByDaylight.PresentationItemProgressComponent
// 0x0008 (0x00B0 - 0x00A8)
class UPresentationItemProgressComponent : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PresentationItemProgressComponent">();
	}
	static class UPresentationItemProgressComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPresentationItemProgressComponent>();
	}
};
static_assert(alignof(UPresentationItemProgressComponent) == 0x000008, "Wrong alignment on UPresentationItemProgressComponent");
static_assert(sizeof(UPresentationItemProgressComponent) == 0x0000B0, "Wrong size on UPresentationItemProgressComponent");

// Class DeadByDaylight.DBDRichPresenceSubsystem
// 0x0018 (0x0050 - 0x0038)
class UDBDRichPresenceSubsystem final : public UGameInstanceSubsystem
{
public:
	ERichPresenceUserType                         _userType;                                         // 0x0038(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ERichPresenceStatus                           _richPresenceStatus;                               // 0x0039(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3A[0x2];                                       // 0x003A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _timerRate;                                        // 0x003C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _timerDelay;                                       // 0x0040(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isValidSetup;                                     // 0x0044(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_45[0xB];                                       // 0x0045(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDRichPresenceSubsystem">();
	}
	static class UDBDRichPresenceSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDRichPresenceSubsystem>();
	}
};
static_assert(alignof(UDBDRichPresenceSubsystem) == 0x000008, "Wrong alignment on UDBDRichPresenceSubsystem");
static_assert(sizeof(UDBDRichPresenceSubsystem) == 0x000050, "Wrong size on UDBDRichPresenceSubsystem");
static_assert(offsetof(UDBDRichPresenceSubsystem, _userType) == 0x000038, "Member 'UDBDRichPresenceSubsystem::_userType' has a wrong offset!");
static_assert(offsetof(UDBDRichPresenceSubsystem, _richPresenceStatus) == 0x000039, "Member 'UDBDRichPresenceSubsystem::_richPresenceStatus' has a wrong offset!");
static_assert(offsetof(UDBDRichPresenceSubsystem, _timerRate) == 0x00003C, "Member 'UDBDRichPresenceSubsystem::_timerRate' has a wrong offset!");
static_assert(offsetof(UDBDRichPresenceSubsystem, _timerDelay) == 0x000040, "Member 'UDBDRichPresenceSubsystem::_timerDelay' has a wrong offset!");
static_assert(offsetof(UDBDRichPresenceSubsystem, _isValidSetup) == 0x000044, "Member 'UDBDRichPresenceSubsystem::_isValidSetup' has a wrong offset!");

// Class DeadByDaylight.BatchDrawing
// 0x0080 (0x00B0 - 0x0030)
class UBatchDrawing final : public UObject
{
public:
	class AActor*                                 _actorToSpawnInstancesInto;                        // 0x0030(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class UStaticMesh*, struct FPerMeshInstancingData> _meshesToInstancingData;                           // 0x0038(0x0050)(Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class UHISMMaterialHelperSettings*            _hismMaterialHelperSettings;                       // 0x0088(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWorld*                                 _currentWorld;                                     // 0x0090(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FStaticMeshAutoBatch>           _meshAutoBatch;                                    // 0x0098(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BatchDrawing">();
	}
	static class UBatchDrawing* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBatchDrawing>();
	}
};
static_assert(alignof(UBatchDrawing) == 0x000008, "Wrong alignment on UBatchDrawing");
static_assert(sizeof(UBatchDrawing) == 0x0000B0, "Wrong size on UBatchDrawing");
static_assert(offsetof(UBatchDrawing, _actorToSpawnInstancesInto) == 0x000030, "Member 'UBatchDrawing::_actorToSpawnInstancesInto' has a wrong offset!");
static_assert(offsetof(UBatchDrawing, _meshesToInstancingData) == 0x000038, "Member 'UBatchDrawing::_meshesToInstancingData' has a wrong offset!");
static_assert(offsetof(UBatchDrawing, _hismMaterialHelperSettings) == 0x000088, "Member 'UBatchDrawing::_hismMaterialHelperSettings' has a wrong offset!");
static_assert(offsetof(UBatchDrawing, _currentWorld) == 0x000090, "Member 'UBatchDrawing::_currentWorld' has a wrong offset!");
static_assert(offsetof(UBatchDrawing, _meshAutoBatch) == 0x000098, "Member 'UBatchDrawing::_meshAutoBatch' has a wrong offset!");

// Class DeadByDaylight.SelectiveVisibilityComponent
// 0x0000 (0x02C0 - 0x02C0)
class USelectiveVisibilityComponent final : public USceneComponent
{
public:
	void Local_SetVisibility(bool bNewVisibility, bool bPropagateToChildren);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SelectiveVisibilityComponent">();
	}
	static class USelectiveVisibilityComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USelectiveVisibilityComponent>();
	}
};
static_assert(alignof(USelectiveVisibilityComponent) == 0x000010, "Wrong alignment on USelectiveVisibilityComponent");
static_assert(sizeof(USelectiveVisibilityComponent) == 0x0002C0, "Wrong size on USelectiveVisibilityComponent");

// Class DeadByDaylight.CharacterHelper
// 0x0000 (0x0030 - 0x0030)
class UCharacterHelper final : public UObject
{
public:
	static TArray<class FString> GetAllEnabledCharms(bool SortArray);
	static void GetAllOutfitComponentsOfCharacter(TArray<struct FCustomizationItemData>* ReturnHeads, TArray<struct FCustomizationItemData>* ReturnTorsos, TArray<struct FCustomizationItemData>* ReturnLegsWeapons, const class FString& CharacterId, const bool SortArrays);
	static TArray<struct FCharacterDescription> GetCharactersByRole(const class UObject* WorldContextObject, const EPlayerRole Role, const bool SortArray);
	static void GetOutfitComposition(struct FCustomizationItemData* ReturnHead, struct FCustomizationItemData* ReturnTorso, struct FCustomizationItemData* ReturnLegsWeapon, const class FString& OutfitId);
	static TArray<struct FOutfitData> GetOutfitsByCharacterID(const class FString& CharacterId, const bool SortArray);
	static struct FCharmIdSlot SetCharmSlot(class ADBDPlayerState* PlayerState, const class FName& CharmId, int32 SlotIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterHelper">();
	}
	static class UCharacterHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterHelper>();
	}
};
static_assert(alignof(UCharacterHelper) == 0x000008, "Wrong alignment on UCharacterHelper");
static_assert(sizeof(UCharacterHelper) == 0x000030, "Wrong size on UCharacterHelper");

// Class DeadByDaylight.Halloween2018EventComponent
// 0x0080 (0x0128 - 0x00A8)
class UHalloween2018EventComponent final : public UActorComponent
{
public:
	class USectionnedChargeableComponent*         _toxinVialComponent;                               // 0x00A8(0x0008)(Edit, ExportObject, Net, ZeroConstructor, EditConst, InstancedReference, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B0[0x78];                                      // 0x00B0(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnFinishedPlaying(const struct FGameplayTag& GameEventType, const struct FGameEventData& GameEventData);
	void OnRep_Vial();
	void Server_SpawnVial(float InitialCharge);

	class USectionnedChargeableComponent* GetVial() const;
	bool IsVialFull() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Halloween2018EventComponent">();
	}
	static class UHalloween2018EventComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHalloween2018EventComponent>();
	}
};
static_assert(alignof(UHalloween2018EventComponent) == 0x000008, "Wrong alignment on UHalloween2018EventComponent");
static_assert(sizeof(UHalloween2018EventComponent) == 0x000128, "Wrong size on UHalloween2018EventComponent");
static_assert(offsetof(UHalloween2018EventComponent, _toxinVialComponent) == 0x0000A8, "Member 'UHalloween2018EventComponent::_toxinVialComponent' has a wrong offset!");

// Class DeadByDaylight.KillerProjectileLauncher
// 0x0000 (0x0198 - 0x0198)
class UKillerProjectileLauncher : public UBaseProjectileLauncher
{
public:
	class ASlasherPlayer* GetOwningKiller() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerProjectileLauncher">();
	}
	static class UKillerProjectileLauncher* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillerProjectileLauncher>();
	}
};
static_assert(alignof(UKillerProjectileLauncher) == 0x000008, "Wrong alignment on UKillerProjectileLauncher");
static_assert(sizeof(UKillerProjectileLauncher) == 0x000198, "Wrong size on UKillerProjectileLauncher");

// Class DeadByDaylight.BackendLoadoutManager
// 0x00A0 (0x00D8 - 0x0038)
class UBackendLoadoutManager final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0xA0];                                      // 0x0038(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BackendLoadoutManager">();
	}
	static class UBackendLoadoutManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBackendLoadoutManager>();
	}
};
static_assert(alignof(UBackendLoadoutManager) == 0x000008, "Wrong alignment on UBackendLoadoutManager");
static_assert(sizeof(UBackendLoadoutManager) == 0x0000D8, "Wrong size on UBackendLoadoutManager");

// Class DeadByDaylight.ActorSpawner
// 0x00E0 (0x03A0 - 0x02C0)
class UActorSpawner : public USceneComponent
{
public:
	uint8                                         Pad_2C0[0x10];                                     // 0x02C0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	EGameplayElementType                          Type;                                              // 0x02D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D1[0x7];                                      // 0x02D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   Visualization;                                     // 0x02D8(0x0038)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ActivatedByDefault;                                // 0x0310(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_311[0x7];                                      // 0x0311(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FActorSpawnerProperties>        ActivatedSceneElement;                             // 0x0318(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FActorSpawnerProperties>        DeactivatedSceneElement;                           // 0x0328(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	double                                        Weight;                                            // 0x0338(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SpawnCountMax;                                     // 0x0340(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SpawnPriorityTier;                                 // 0x0344(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           TagsToBePassedOverToActor;                         // 0x0348(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          AttachSpawnedActorToAttachedSocket;                // 0x0358(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_359[0x7];                                      // 0x0359(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnAsyncActorSpawned;                               // 0x0360(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_370[0x8];                                      // 0x0370(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          WeightInfluenceable;                               // 0x0378(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          WeightInfluencer;                                  // 0x0379(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_37A[0x2];                                      // 0x037A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Cost;                                              // 0x037C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UClass*                                 _toSpawn;                                          // 0x0380(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_388[0x8];                                      // 0x0388(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AActor>                  _spawnedActorOnAuthority;                          // 0x0390(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_398[0x8];                                      // 0x0398(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_SpawnActorAsyncEvent();
	void AuthoritySelect(bool Selected);
	void EditorForceSpawnVisualization();

	class AActor* AuthorityGetSpawnedActor() const;
	bool IsEnabled() const;
	bool UseActivatedElement() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActorSpawner">();
	}
	static class UActorSpawner* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActorSpawner>();
	}
};
static_assert(alignof(UActorSpawner) == 0x000010, "Wrong alignment on UActorSpawner");
static_assert(sizeof(UActorSpawner) == 0x0003A0, "Wrong size on UActorSpawner");
static_assert(offsetof(UActorSpawner, Type) == 0x0002D0, "Member 'UActorSpawner::Type' has a wrong offset!");
static_assert(offsetof(UActorSpawner, Visualization) == 0x0002D8, "Member 'UActorSpawner::Visualization' has a wrong offset!");
static_assert(offsetof(UActorSpawner, ActivatedByDefault) == 0x000310, "Member 'UActorSpawner::ActivatedByDefault' has a wrong offset!");
static_assert(offsetof(UActorSpawner, ActivatedSceneElement) == 0x000318, "Member 'UActorSpawner::ActivatedSceneElement' has a wrong offset!");
static_assert(offsetof(UActorSpawner, DeactivatedSceneElement) == 0x000328, "Member 'UActorSpawner::DeactivatedSceneElement' has a wrong offset!");
static_assert(offsetof(UActorSpawner, Weight) == 0x000338, "Member 'UActorSpawner::Weight' has a wrong offset!");
static_assert(offsetof(UActorSpawner, SpawnCountMax) == 0x000340, "Member 'UActorSpawner::SpawnCountMax' has a wrong offset!");
static_assert(offsetof(UActorSpawner, SpawnPriorityTier) == 0x000344, "Member 'UActorSpawner::SpawnPriorityTier' has a wrong offset!");
static_assert(offsetof(UActorSpawner, TagsToBePassedOverToActor) == 0x000348, "Member 'UActorSpawner::TagsToBePassedOverToActor' has a wrong offset!");
static_assert(offsetof(UActorSpawner, AttachSpawnedActorToAttachedSocket) == 0x000358, "Member 'UActorSpawner::AttachSpawnedActorToAttachedSocket' has a wrong offset!");
static_assert(offsetof(UActorSpawner, OnAsyncActorSpawned) == 0x000360, "Member 'UActorSpawner::OnAsyncActorSpawned' has a wrong offset!");
static_assert(offsetof(UActorSpawner, WeightInfluenceable) == 0x000378, "Member 'UActorSpawner::WeightInfluenceable' has a wrong offset!");
static_assert(offsetof(UActorSpawner, WeightInfluencer) == 0x000379, "Member 'UActorSpawner::WeightInfluencer' has a wrong offset!");
static_assert(offsetof(UActorSpawner, Cost) == 0x00037C, "Member 'UActorSpawner::Cost' has a wrong offset!");
static_assert(offsetof(UActorSpawner, _toSpawn) == 0x000380, "Member 'UActorSpawner::_toSpawn' has a wrong offset!");
static_assert(offsetof(UActorSpawner, _spawnedActorOnAuthority) == 0x000390, "Member 'UActorSpawner::_spawnedActorOnAuthority' has a wrong offset!");

// Class DeadByDaylight.EventSpawner
// 0x00E0 (0x0480 - 0x03A0)
class UEventSpawner final : public UActorSpawner
{
public:
	struct FEventSpawnablePositionDropdown        EventSpawnablePosition;                            // 0x03A0(0x0030)(Edit, NativeAccessSpecifierPublic)
	struct FDataTableDropdown                     EventSpawnableShapePreset;                         // 0x03D0(0x0030)(Edit, NativeAccessSpecifierPublic)
	struct FVector                                MinBoundOverride;                                  // 0x0400(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MaxBoundOverride;                                  // 0x0418(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBoxComponent*                          _minBoundBox;                                      // 0x0430(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBoxComponent*                          _maxBoundBox;                                      // 0x0438(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_440[0x40];                                     // 0x0440(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventSpawner">();
	}
	static class UEventSpawner* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventSpawner>();
	}
};
static_assert(alignof(UEventSpawner) == 0x000010, "Wrong alignment on UEventSpawner");
static_assert(sizeof(UEventSpawner) == 0x000480, "Wrong size on UEventSpawner");
static_assert(offsetof(UEventSpawner, EventSpawnablePosition) == 0x0003A0, "Member 'UEventSpawner::EventSpawnablePosition' has a wrong offset!");
static_assert(offsetof(UEventSpawner, EventSpawnableShapePreset) == 0x0003D0, "Member 'UEventSpawner::EventSpawnableShapePreset' has a wrong offset!");
static_assert(offsetof(UEventSpawner, MinBoundOverride) == 0x000400, "Member 'UEventSpawner::MinBoundOverride' has a wrong offset!");
static_assert(offsetof(UEventSpawner, MaxBoundOverride) == 0x000418, "Member 'UEventSpawner::MaxBoundOverride' has a wrong offset!");
static_assert(offsetof(UEventSpawner, _minBoundBox) == 0x000430, "Member 'UEventSpawner::_minBoundBox' has a wrong offset!");
static_assert(offsetof(UEventSpawner, _maxBoundBox) == 0x000438, "Member 'UEventSpawner::_maxBoundBox' has a wrong offset!");

// Class DeadByDaylight.SlasherAttackPickerComponent
// 0x0000 (0x00A8 - 0x00A8)
class USlasherAttackPickerComponent : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SlasherAttackPickerComponent">();
	}
	static class USlasherAttackPickerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USlasherAttackPickerComponent>();
	}
};
static_assert(alignof(USlasherAttackPickerComponent) == 0x000008, "Wrong alignment on USlasherAttackPickerComponent");
static_assert(sizeof(USlasherAttackPickerComponent) == 0x0000A8, "Wrong size on USlasherAttackPickerComponent");

// Class DeadByDaylight.DecalSpawner
// 0x0018 (0x0048 - 0x0030)
class UDecalSpawner final : public UObject
{
public:
	class UDecalCollection*                       _decalCollection;                                  // 0x0030(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USpawnerStrategy*                       _spawnerStrategy;                                  // 0x0038(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class USpawnerStrategy* GetSpawnerStrategy();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DecalSpawner">();
	}
	static class UDecalSpawner* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDecalSpawner>();
	}
};
static_assert(alignof(UDecalSpawner) == 0x000008, "Wrong alignment on UDecalSpawner");
static_assert(sizeof(UDecalSpawner) == 0x000048, "Wrong size on UDecalSpawner");
static_assert(offsetof(UDecalSpawner, _decalCollection) == 0x000030, "Member 'UDecalSpawner::_decalCollection' has a wrong offset!");
static_assert(offsetof(UDecalSpawner, _spawnerStrategy) == 0x000038, "Member 'UDecalSpawner::_spawnerStrategy' has a wrong offset!");

// Class DeadByDaylight.DBDCoreUMGDesignTunables
// 0x0070 (0x00A0 - 0x0030)
class UDBDCoreUMGDesignTunables : public UObject
{
public:
	TSoftClassPtr<class UClass>                   CoreHudRootWidgetClass;                            // 0x0030(0x0038)(Edit, NoClear, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   CorePlayerControllerClass;                         // 0x0068(0x0038)(Edit, NoClear, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDCoreUMGDesignTunables">();
	}
	static class UDBDCoreUMGDesignTunables* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDCoreUMGDesignTunables>();
	}
};
static_assert(alignof(UDBDCoreUMGDesignTunables) == 0x000008, "Wrong alignment on UDBDCoreUMGDesignTunables");
static_assert(sizeof(UDBDCoreUMGDesignTunables) == 0x0000A0, "Wrong size on UDBDCoreUMGDesignTunables");
static_assert(offsetof(UDBDCoreUMGDesignTunables, CoreHudRootWidgetClass) == 0x000030, "Member 'UDBDCoreUMGDesignTunables::CoreHudRootWidgetClass' has a wrong offset!");
static_assert(offsetof(UDBDCoreUMGDesignTunables, CorePlayerControllerClass) == 0x000068, "Member 'UDBDCoreUMGDesignTunables::CorePlayerControllerClass' has a wrong offset!");

// Class DeadByDaylight.BaseLockerItem
// 0x0028 (0x02C8 - 0x02A0)
class ABaseLockerItem : public AActor
{
public:
	class ALocker*                                _owningLocker;                                     // 0x02A0(0x0008)(Net, ZeroConstructor, Transient, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A8[0x8];                                      // 0x02A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                _adjustedRelativePosition;                         // 0x02B0(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void AdjustPositionOnLocker();
	void OnRep_OwningLocker();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseLockerItem">();
	}
	static class ABaseLockerItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABaseLockerItem>();
	}
};
static_assert(alignof(ABaseLockerItem) == 0x000008, "Wrong alignment on ABaseLockerItem");
static_assert(sizeof(ABaseLockerItem) == 0x0002C8, "Wrong size on ABaseLockerItem");
static_assert(offsetof(ABaseLockerItem, _owningLocker) == 0x0002A0, "Member 'ABaseLockerItem::_owningLocker' has a wrong offset!");
static_assert(offsetof(ABaseLockerItem, _adjustedRelativePosition) == 0x0002B0, "Member 'ABaseLockerItem::_adjustedRelativePosition' has a wrong offset!");

// Class DeadByDaylight.SpecialBehaviourIterativeWeightAdjustmentStrategy
// 0x0000 (0x0030 - 0x0030)
class USpecialBehaviourIterativeWeightAdjustmentStrategy : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpecialBehaviourIterativeWeightAdjustmentStrategy">();
	}
	static class USpecialBehaviourIterativeWeightAdjustmentStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpecialBehaviourIterativeWeightAdjustmentStrategy>();
	}
};
static_assert(alignof(USpecialBehaviourIterativeWeightAdjustmentStrategy) == 0x000008, "Wrong alignment on USpecialBehaviourIterativeWeightAdjustmentStrategy");
static_assert(sizeof(USpecialBehaviourIterativeWeightAdjustmentStrategy) == 0x000030, "Wrong size on USpecialBehaviourIterativeWeightAdjustmentStrategy");

// Class DeadByDaylight.AutoQualityAdjuster
// 0x0028 (0x02C8 - 0x02A0)
class AAutoQualityAdjuster : public AActor
{
public:
	float                                         TargetResolutionScale;                             // 0x02A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinimumMS;                                         // 0x02A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaximumMS;                                         // 0x02A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ScaleIncreaseRate;                                 // 0x02AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ScaleDecreaseRate;                                 // 0x02B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinimumAllowableScale;                             // 0x02B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B8[0x10];                                     // 0x02B8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AutoQualityAdjuster">();
	}
	static class AAutoQualityAdjuster* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAutoQualityAdjuster>();
	}
};
static_assert(alignof(AAutoQualityAdjuster) == 0x000008, "Wrong alignment on AAutoQualityAdjuster");
static_assert(sizeof(AAutoQualityAdjuster) == 0x0002C8, "Wrong size on AAutoQualityAdjuster");
static_assert(offsetof(AAutoQualityAdjuster, TargetResolutionScale) == 0x0002A0, "Member 'AAutoQualityAdjuster::TargetResolutionScale' has a wrong offset!");
static_assert(offsetof(AAutoQualityAdjuster, MinimumMS) == 0x0002A4, "Member 'AAutoQualityAdjuster::MinimumMS' has a wrong offset!");
static_assert(offsetof(AAutoQualityAdjuster, MaximumMS) == 0x0002A8, "Member 'AAutoQualityAdjuster::MaximumMS' has a wrong offset!");
static_assert(offsetof(AAutoQualityAdjuster, ScaleIncreaseRate) == 0x0002AC, "Member 'AAutoQualityAdjuster::ScaleIncreaseRate' has a wrong offset!");
static_assert(offsetof(AAutoQualityAdjuster, ScaleDecreaseRate) == 0x0002B0, "Member 'AAutoQualityAdjuster::ScaleDecreaseRate' has a wrong offset!");
static_assert(offsetof(AAutoQualityAdjuster, MinimumAllowableScale) == 0x0002B4, "Member 'AAutoQualityAdjuster::MinimumAllowableScale' has a wrong offset!");

// Class DeadByDaylight.KillerSpecificGameStateComponent
// 0x0000 (0x00A8 - 0x00A8)
class UKillerSpecificGameStateComponent : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerSpecificGameStateComponent">();
	}
	static class UKillerSpecificGameStateComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillerSpecificGameStateComponent>();
	}
};
static_assert(alignof(UKillerSpecificGameStateComponent) == 0x000008, "Wrong alignment on UKillerSpecificGameStateComponent");
static_assert(sizeof(UKillerSpecificGameStateComponent) == 0x0000A8, "Wrong size on UKillerSpecificGameStateComponent");

// Class DeadByDaylight.CharacterClassUtilities
// 0x0000 (0x0030 - 0x0030)
class UCharacterClassUtilities final : public UObject
{
public:
	static class FName GetEquippedCharacterClass(class ADBDPlayer* Player);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterClassUtilities">();
	}
	static class UCharacterClassUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterClassUtilities>();
	}
};
static_assert(alignof(UCharacterClassUtilities) == 0x000008, "Wrong alignment on UCharacterClassUtilities");
static_assert(sizeof(UCharacterClassUtilities) == 0x000030, "Wrong size on UCharacterClassUtilities");

// Class DeadByDaylight.TotemBoundPerk
// 0x0058 (0x0478 - 0x0420)
class UTotemBoundPerk : public UPerk
{
public:
	uint8                                         Pad_420[0x18];                                     // 0x0420(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	ETotemState                                   TotemBoundState;                                   // 0x0438(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _doNotBindToTotemOnInit;                           // 0x0439(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_43A[0x6];                                      // 0x043A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ATotem*>                         _boundTotems;                                      // 0x0440(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, RepNotify, Protected, NativeAccessSpecifierProtected)
	TArray<class ATotem*>                         _local_boundTotems;                                // 0x0450(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class ATotem*>                         _authorityPrevTotemActors;                         // 0x0460(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	int32                                         _numTotemsToBind;                                  // 0x0470(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_474[0x4];                                      // 0x0474(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool Authority_BindToDullTotems(bool AllowAdditionalBoundTotems);
	void Authority_UnbindFromTotem(class ATotem* ATotemActor);
	void OnRep_BoundTotems();

	TArray<class ATotem*> GetBoundTotems() const;
	float GetSquaredDistanceToOwner(const class AActor* Survivor) const;
	const TArray<class ATotem*> GetTotems() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TotemBoundPerk">();
	}
	static class UTotemBoundPerk* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTotemBoundPerk>();
	}
};
static_assert(alignof(UTotemBoundPerk) == 0x000008, "Wrong alignment on UTotemBoundPerk");
static_assert(sizeof(UTotemBoundPerk) == 0x000478, "Wrong size on UTotemBoundPerk");
static_assert(offsetof(UTotemBoundPerk, TotemBoundState) == 0x000438, "Member 'UTotemBoundPerk::TotemBoundState' has a wrong offset!");
static_assert(offsetof(UTotemBoundPerk, _doNotBindToTotemOnInit) == 0x000439, "Member 'UTotemBoundPerk::_doNotBindToTotemOnInit' has a wrong offset!");
static_assert(offsetof(UTotemBoundPerk, _boundTotems) == 0x000440, "Member 'UTotemBoundPerk::_boundTotems' has a wrong offset!");
static_assert(offsetof(UTotemBoundPerk, _local_boundTotems) == 0x000450, "Member 'UTotemBoundPerk::_local_boundTotems' has a wrong offset!");
static_assert(offsetof(UTotemBoundPerk, _authorityPrevTotemActors) == 0x000460, "Member 'UTotemBoundPerk::_authorityPrevTotemActors' has a wrong offset!");
static_assert(offsetof(UTotemBoundPerk, _numTotemsToBind) == 0x000470, "Member 'UTotemBoundPerk::_numTotemsToBind' has a wrong offset!");

// Class DeadByDaylight.AIMoveToInteract
// 0x0018 (0x0070 - 0x0058)
class UAIMoveToInteract final : public UAICharacterBehaviour
{
public:
	class UAIMoveToInteractData*                  _aiMoveToInteractData;                             // 0x0058(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ADBDAIPlayerController*                 _aiController;                                     // 0x0060(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_68[0x8];                                       // 0x0068(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Init(class ADBDPlayer* Character, class UAICharacterBehaviourData* behaviourData);
	void InteractionPointReached(const struct FAIRequestID& RequestID, EPathFollowingResult Result);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIMoveToInteract">();
	}
	static class UAIMoveToInteract* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIMoveToInteract>();
	}
};
static_assert(alignof(UAIMoveToInteract) == 0x000008, "Wrong alignment on UAIMoveToInteract");
static_assert(sizeof(UAIMoveToInteract) == 0x000070, "Wrong size on UAIMoveToInteract");
static_assert(offsetof(UAIMoveToInteract, _aiMoveToInteractData) == 0x000058, "Member 'UAIMoveToInteract::_aiMoveToInteractData' has a wrong offset!");
static_assert(offsetof(UAIMoveToInteract, _aiController) == 0x000060, "Member 'UAIMoveToInteract::_aiController' has a wrong offset!");

// Class DeadByDaylight.KillerBlindingFXComponent
// 0x0048 (0x0140 - 0x00F8)
class UKillerBlindingFXComponent : public UBlindingFXComponent
{
public:
	uint8                                         Pad_F8[0x18];                                      // 0x00F8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          _blindedSound;                                     // 0x0110(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_118[0x28];                                     // 0x0118(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Multicast_OnBlindedByPlayersCosmetic(const TArray<class ADBDPlayer*>& Players);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerBlindingFXComponent">();
	}
	static class UKillerBlindingFXComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillerBlindingFXComponent>();
	}
};
static_assert(alignof(UKillerBlindingFXComponent) == 0x000008, "Wrong alignment on UKillerBlindingFXComponent");
static_assert(sizeof(UKillerBlindingFXComponent) == 0x000140, "Wrong size on UKillerBlindingFXComponent");
static_assert(offsetof(UKillerBlindingFXComponent, _blindedSound) == 0x000110, "Member 'UKillerBlindingFXComponent::_blindedSound' has a wrong offset!");

// Class DeadByDaylight.PlayerProfileDAL
// 0x0058 (0x0088 - 0x0030)
class UPlayerProfileDAL : public UObject
{
public:
	uint8                                         Pad_30[0x58];                                      // 0x0030(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerProfileDAL">();
	}
	static class UPlayerProfileDAL* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerProfileDAL>();
	}
};
static_assert(alignof(UPlayerProfileDAL) == 0x000008, "Wrong alignment on UPlayerProfileDAL");
static_assert(sizeof(UPlayerProfileDAL) == 0x000088, "Wrong size on UPlayerProfileDAL");

// Class DeadByDaylight.SteamProfileDAL
// 0x0000 (0x0088 - 0x0088)
class USteamProfileDAL final : public UPlayerProfileDAL
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamProfileDAL">();
	}
	static class USteamProfileDAL* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamProfileDAL>();
	}
};
static_assert(alignof(USteamProfileDAL) == 0x000008, "Wrong alignment on USteamProfileDAL");
static_assert(sizeof(USteamProfileDAL) == 0x000088, "Wrong size on USteamProfileDAL");

// Class DeadByDaylight.KillerRedStainUpdateStrategy
// 0x0040 (0x00E8 - 0x00A8)
class UKillerRedStainUpdateStrategy : public UActorComponent
{
public:
	class UCurveFloat*                            _stealthRatioToRedStainIntensityCurve;             // 0x00A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  _hideRedStainStateTags;                            // 0x00B0(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_D0[0x18];                                      // 0x00D0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnHeadHiddenChanged(bool IsHidden);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerRedStainUpdateStrategy">();
	}
	static class UKillerRedStainUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillerRedStainUpdateStrategy>();
	}
};
static_assert(alignof(UKillerRedStainUpdateStrategy) == 0x000008, "Wrong alignment on UKillerRedStainUpdateStrategy");
static_assert(sizeof(UKillerRedStainUpdateStrategy) == 0x0000E8, "Wrong size on UKillerRedStainUpdateStrategy");
static_assert(offsetof(UKillerRedStainUpdateStrategy, _stealthRatioToRedStainIntensityCurve) == 0x0000A8, "Member 'UKillerRedStainUpdateStrategy::_stealthRatioToRedStainIntensityCurve' has a wrong offset!");
static_assert(offsetof(UKillerRedStainUpdateStrategy, _hideRedStainStateTags) == 0x0000B0, "Member 'UKillerRedStainUpdateStrategy::_hideRedStainStateTags' has a wrong offset!");

// Class DeadByDaylight.DBD_SoundEventSpawner
// 0x0038 (0x02D8 - 0x02A0)
class ADBD_SoundEventSpawner : public AActor
{
public:
	TArray<struct FDBD_SoundSpawnerData>          AtlantaSoundDescriptor;                            // 0x02A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FDBD_SoundSpawnerData>          SoundDescriptor;                                   // 0x02B0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C0[0x8];                                      // 0x02C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class AActor>>             _loadedSoundAssets;                                // 0x02C8(0x0010)(ZeroConstructor, Transient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	void AssetsLoaded();
	void OnLoudNoiseTriggered(class AActor* Originator, class AActor* InstigatingActor, const struct FVector& Location, bool ShouldTrack, float* AudibleRange, bool IsQuickAction, bool IsDeceivingNoise);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBD_SoundEventSpawner">();
	}
	static class ADBD_SoundEventSpawner* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBD_SoundEventSpawner>();
	}
};
static_assert(alignof(ADBD_SoundEventSpawner) == 0x000008, "Wrong alignment on ADBD_SoundEventSpawner");
static_assert(sizeof(ADBD_SoundEventSpawner) == 0x0002D8, "Wrong size on ADBD_SoundEventSpawner");
static_assert(offsetof(ADBD_SoundEventSpawner, AtlantaSoundDescriptor) == 0x0002A0, "Member 'ADBD_SoundEventSpawner::AtlantaSoundDescriptor' has a wrong offset!");
static_assert(offsetof(ADBD_SoundEventSpawner, SoundDescriptor) == 0x0002B0, "Member 'ADBD_SoundEventSpawner::SoundDescriptor' has a wrong offset!");
static_assert(offsetof(ADBD_SoundEventSpawner, _loadedSoundAssets) == 0x0002C8, "Member 'ADBD_SoundEventSpawner::_loadedSoundAssets' has a wrong offset!");

// Class DeadByDaylight.VaultDefinition
// 0x0060 (0x07E0 - 0x0780)
#pragma pack(push, 0x1)
class alignas(0x10) UVaultDefinition : public UInteractionDefinition
{
public:
	struct FGameplayTag                           _vaultGameEvent;                                   // 0x0778(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _feetOffGroundID;                                  // 0x0784(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _feetOnGroundID;                                   // 0x0790(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _allowedHeightDelta;                               // 0x079C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isFall;                                           // 0x07A0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7A1[0x37];                                     // 0x07A1(0x0037)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsWindowVaultable() const;
	bool IsWithinHeightDelta(const class ADBDPlayer* Player) const;
	bool ShouldLaunchCharacter(const class ADBDPlayer* Player) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VaultDefinition">();
	}
	static class UVaultDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVaultDefinition>();
	}
};
#pragma pack(pop)
static_assert(alignof(UVaultDefinition) == 0x000010, "Wrong alignment on UVaultDefinition");
static_assert(sizeof(UVaultDefinition) == 0x0007E0, "Wrong size on UVaultDefinition");
static_assert(offsetof(UVaultDefinition, _vaultGameEvent) == 0x000778, "Member 'UVaultDefinition::_vaultGameEvent' has a wrong offset!");
static_assert(offsetof(UVaultDefinition, _feetOffGroundID) == 0x000784, "Member 'UVaultDefinition::_feetOffGroundID' has a wrong offset!");
static_assert(offsetof(UVaultDefinition, _feetOnGroundID) == 0x000790, "Member 'UVaultDefinition::_feetOnGroundID' has a wrong offset!");
static_assert(offsetof(UVaultDefinition, _allowedHeightDelta) == 0x00079C, "Member 'UVaultDefinition::_allowedHeightDelta' has a wrong offset!");
static_assert(offsetof(UVaultDefinition, _isFall) == 0x0007A0, "Member 'UVaultDefinition::_isFall' has a wrong offset!");

// Class DeadByDaylight.ProceduralGenerationUtilities
// 0x0000 (0x0030 - 0x0030)
class UProceduralGenerationUtilities final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProceduralGenerationUtilities">();
	}
	static class UProceduralGenerationUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProceduralGenerationUtilities>();
	}
};
static_assert(alignof(UProceduralGenerationUtilities) == 0x000008, "Wrong alignment on UProceduralGenerationUtilities");
static_assert(sizeof(UProceduralGenerationUtilities) == 0x000030, "Wrong size on UProceduralGenerationUtilities");

// Class DeadByDaylight.MontagePlayer
// 0x01C8 (0x0270 - 0x00A8)
class UMontagePlayer final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnMontageStarted;                                  // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_B8[0x48];                                      // 0x00B8(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnMontageEnded;                                    // 0x0100(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_110[0x30];                                     // 0x0110(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             BPOnMontageBlendingOut;                            // 0x0140(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_150[0x30];                                     // 0x0150(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FContextualAnimationMapping>    _contextualAnimationMappings;                      // 0x0180(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UAnimMontage*                           _currentlyPlayingMontage;                          // 0x0190(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_198[0x18];                                     // 0x0198(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMontageInstanceInfo>           _activeMontagesInfo;                               // 0x01B0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class FName                                   _outSectionName;                                   // 0x01C0(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _timeBeforeOut;                                    // 0x01CC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USkeletalMeshComponent*                 _skeletalMeshComponent;                            // 0x01D0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1D8[0x28];                                     // 0x01D8(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class UAnimMontage*, class FName>        _montageToNameMap;                                 // 0x0200(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TArray<class UDataTable*>                     _loadedMappingTables;                              // 0x0250(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_260[0x10];                                     // 0x0260(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void JumpToSection(class FName SectionName);
	void JumpToSectionEnd(class FName SectionName);
	void OnMontageBlendingOutInternal(const struct FGuid& Guid, class UAnimMontage* Montage, bool Interrupted);
	void OnMontageEndedInternal(const struct FGuid& Guid, class UAnimMontage* Montage, bool Interrupted);
	class UAnimMontage* Play(const struct FAnimationMontageDescriptor& AnimMontageID, float PlayRate, bool IsFollower);
	class UAnimMontage* PlayLoopForDuration(const struct FAnimationMontageDescriptor& AnimMontageID, float Duration, float PlayRate, class FName Out);
	void SetPlayRate(float PlayRate);
	void SetSkeletalMesh(class USkeletalMeshComponent* SkeletalMeshComponent);
	void SignalAnimInstanceChanged();
	void Stop(float BlendOutTime);

	class UAnimInstance* GetAnimInstance() const;
	bool IsPlaying(const struct FAnimationMontageDescriptor& MontageDescriptor) const;
	bool IsPlayingAnyMontage() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MontagePlayer">();
	}
	static class UMontagePlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMontagePlayer>();
	}
};
static_assert(alignof(UMontagePlayer) == 0x000008, "Wrong alignment on UMontagePlayer");
static_assert(sizeof(UMontagePlayer) == 0x000270, "Wrong size on UMontagePlayer");
static_assert(offsetof(UMontagePlayer, OnMontageStarted) == 0x0000A8, "Member 'UMontagePlayer::OnMontageStarted' has a wrong offset!");
static_assert(offsetof(UMontagePlayer, OnMontageEnded) == 0x000100, "Member 'UMontagePlayer::OnMontageEnded' has a wrong offset!");
static_assert(offsetof(UMontagePlayer, BPOnMontageBlendingOut) == 0x000140, "Member 'UMontagePlayer::BPOnMontageBlendingOut' has a wrong offset!");
static_assert(offsetof(UMontagePlayer, _contextualAnimationMappings) == 0x000180, "Member 'UMontagePlayer::_contextualAnimationMappings' has a wrong offset!");
static_assert(offsetof(UMontagePlayer, _currentlyPlayingMontage) == 0x000190, "Member 'UMontagePlayer::_currentlyPlayingMontage' has a wrong offset!");
static_assert(offsetof(UMontagePlayer, _activeMontagesInfo) == 0x0001B0, "Member 'UMontagePlayer::_activeMontagesInfo' has a wrong offset!");
static_assert(offsetof(UMontagePlayer, _outSectionName) == 0x0001C0, "Member 'UMontagePlayer::_outSectionName' has a wrong offset!");
static_assert(offsetof(UMontagePlayer, _timeBeforeOut) == 0x0001CC, "Member 'UMontagePlayer::_timeBeforeOut' has a wrong offset!");
static_assert(offsetof(UMontagePlayer, _skeletalMeshComponent) == 0x0001D0, "Member 'UMontagePlayer::_skeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(UMontagePlayer, _montageToNameMap) == 0x000200, "Member 'UMontagePlayer::_montageToNameMap' has a wrong offset!");
static_assert(offsetof(UMontagePlayer, _loadedMappingTables) == 0x000250, "Member 'UMontagePlayer::_loadedMappingTables' has a wrong offset!");

// Class DeadByDaylight.KillerVaultDefinition
// 0x0090 (0x0870 - 0x07E0)
class UKillerVaultDefinition : public UVaultDefinition
{
public:
	bool                                          _shouldUseCustomDuration;                          // 0x07D8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7D9[0x7];                                      // 0x07D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FStatProperty                          _vaultDuration;                                    // 0x07E0(0x0088)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_868[0x8];                                      // 0x0868(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerVaultDefinition">();
	}
	static class UKillerVaultDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillerVaultDefinition>();
	}
};
static_assert(alignof(UKillerVaultDefinition) == 0x000010, "Wrong alignment on UKillerVaultDefinition");
static_assert(sizeof(UKillerVaultDefinition) == 0x000870, "Wrong size on UKillerVaultDefinition");
static_assert(offsetof(UKillerVaultDefinition, _shouldUseCustomDuration) == 0x0007D8, "Member 'UKillerVaultDefinition::_shouldUseCustomDuration' has a wrong offset!");
static_assert(offsetof(UKillerVaultDefinition, _vaultDuration) == 0x0007E0, "Member 'UKillerVaultDefinition::_vaultDuration' has a wrong offset!");

// Class DeadByDaylight.NavigationQueryFilter_EvadeLoop
// 0x0440 (0x0490 - 0x0050)
class UNavigationQueryFilter_EvadeLoop final : public UNavigationQueryFilter
{
public:
	uint8                                         Pad_50[0x440];                                     // 0x0050(0x0440)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavigationQueryFilter_EvadeLoop">();
	}
	static class UNavigationQueryFilter_EvadeLoop* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavigationQueryFilter_EvadeLoop>();
	}
};
static_assert(alignof(UNavigationQueryFilter_EvadeLoop) == 0x000008, "Wrong alignment on UNavigationQueryFilter_EvadeLoop");
static_assert(sizeof(UNavigationQueryFilter_EvadeLoop) == 0x000490, "Wrong size on UNavigationQueryFilter_EvadeLoop");

// Class DeadByDaylight.BaseCameraTargetingStrategy
// 0x0020 (0x0050 - 0x0030)
class UBaseCameraTargetingStrategy : public UObject
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _maxFreeAngle;                                     // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _maxInputRotation;                                 // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _interpolationSpeed;                               // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _interpolationSpeedOutsideFreeMoveZone;            // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 _target;                                           // 0x0048(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseCameraTargetingStrategy">();
	}
	static class UBaseCameraTargetingStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseCameraTargetingStrategy>();
	}
};
static_assert(alignof(UBaseCameraTargetingStrategy) == 0x000008, "Wrong alignment on UBaseCameraTargetingStrategy");
static_assert(sizeof(UBaseCameraTargetingStrategy) == 0x000050, "Wrong size on UBaseCameraTargetingStrategy");
static_assert(offsetof(UBaseCameraTargetingStrategy, _maxFreeAngle) == 0x000038, "Member 'UBaseCameraTargetingStrategy::_maxFreeAngle' has a wrong offset!");
static_assert(offsetof(UBaseCameraTargetingStrategy, _maxInputRotation) == 0x00003C, "Member 'UBaseCameraTargetingStrategy::_maxInputRotation' has a wrong offset!");
static_assert(offsetof(UBaseCameraTargetingStrategy, _interpolationSpeed) == 0x000040, "Member 'UBaseCameraTargetingStrategy::_interpolationSpeed' has a wrong offset!");
static_assert(offsetof(UBaseCameraTargetingStrategy, _interpolationSpeedOutsideFreeMoveZone) == 0x000044, "Member 'UBaseCameraTargetingStrategy::_interpolationSpeedOutsideFreeMoveZone' has a wrong offset!");
static_assert(offsetof(UBaseCameraTargetingStrategy, _target) == 0x000048, "Member 'UBaseCameraTargetingStrategy::_target' has a wrong offset!");

// Class DeadByDaylight.CommentatorSpawnStrategy
// 0x0000 (0x0030 - 0x0030)
class UCommentatorSpawnStrategy : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommentatorSpawnStrategy">();
	}
	static class UCommentatorSpawnStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommentatorSpawnStrategy>();
	}
};
static_assert(alignof(UCommentatorSpawnStrategy) == 0x000008, "Wrong alignment on UCommentatorSpawnStrategy");
static_assert(sizeof(UCommentatorSpawnStrategy) == 0x000030, "Wrong size on UCommentatorSpawnStrategy");

// Class DeadByDaylight.IgnoreCollisionsComponent
// 0x0050 (0x00F8 - 0x00A8)
class UIgnoreCollisionsComponent : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x50];                                      // 0x00A8(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IgnoreCollisionsComponent">();
	}
	static class UIgnoreCollisionsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIgnoreCollisionsComponent>();
	}
};
static_assert(alignof(UIgnoreCollisionsComponent) == 0x000008, "Wrong alignment on UIgnoreCollisionsComponent");
static_assert(sizeof(UIgnoreCollisionsComponent) == 0x0000F8, "Wrong size on UIgnoreCollisionsComponent");

// Class DeadByDaylight.IgnorePlayersCollisionsComponent
// 0x0010 (0x0108 - 0x00F8)
class UIgnorePlayersCollisionsComponent final : public UIgnoreCollisionsComponent
{
public:
	uint8                                         Pad_F8[0x10];                                      // 0x00F8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IgnorePlayersCollisionsComponent">();
	}
	static class UIgnorePlayersCollisionsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIgnorePlayersCollisionsComponent>();
	}
};
static_assert(alignof(UIgnorePlayersCollisionsComponent) == 0x000008, "Wrong alignment on UIgnorePlayersCollisionsComponent");
static_assert(sizeof(UIgnorePlayersCollisionsComponent) == 0x000108, "Wrong size on UIgnorePlayersCollisionsComponent");

// Class DeadByDaylight.KillInteractionDefinition
// 0x0110 (0x09D0 - 0x08C0)
class UKillInteractionDefinition : public UChargeableInteractionDefinition
{
public:
	bool                                          _disableFOVSystemDuringInteraction;                // 0x08C0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _overrideSlasherFieldOfViewDuringInteraction;      // 0x08C1(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _overrideCamperFieldOfViewDuringInteraction;       // 0x08C2(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _camperCopySlasherFOVCurve;                        // 0x08C3(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _cameraFOVCurveName;                               // 0x08C4(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 _moriKillAudioSwitchName;                          // 0x08D0(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 _moriKillAudioSwitchOnStateName;                   // 0x08E0(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 _moriKillAudioSwitchOffStateName;                  // 0x08F0(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _setKillerStatusInCrazyStateDuringMori;            // 0x0900(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_901[0x7];                                      // 0x0901(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 _killerStatusAudioSwitchName;                      // 0x0908(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 _killerStatusAudioSwitchCrazyState;                // 0x0918(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 _killerStatusAudioSwitchExitState;                 // 0x0928(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 _killerStatusAudioSwitchDefaultState;              // 0x0938(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FString>                         _nonOverrideableTargetInteractions;                // 0x0948(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	bool                                          _chargeCompleted;                                  // 0x0958(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isKillShownInThirdPerson;                         // 0x0959(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _manuallyManageMeshHiding;                         // 0x095A(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _survivorAnimationLastAfterInteractionEnds;        // 0x095B(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_95C[0x34];                                     // 0x095C(0x0034)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _maximumDelayBeforeSurvivorDeath;                  // 0x0990(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_994[0x4];                                      // 0x0994(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAnimationMontageDescriptor            _exitMontage;                                      // 0x0998(0x0020)(Edit, NativeAccessSpecifierPrivate)
	float                                         _slasherFacingTolerance;                           // 0x09B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_9BC[0x14];                                     // 0x09BC(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnMoriCancelled();

	bool GetChargeCompleted() const;
	struct FAnimationMontageDescriptor GetExitAnimationMontage() const;
	const class ACamperPlayer* GetOwningSurvivor() const;
	bool IsKillerAllowedToKillSurvivor(const class ASlasherPlayer* Killer, const class ACamperPlayer* Survivor) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillInteractionDefinition">();
	}
	static class UKillInteractionDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillInteractionDefinition>();
	}
};
static_assert(alignof(UKillInteractionDefinition) == 0x000010, "Wrong alignment on UKillInteractionDefinition");
static_assert(sizeof(UKillInteractionDefinition) == 0x0009D0, "Wrong size on UKillInteractionDefinition");
static_assert(offsetof(UKillInteractionDefinition, _disableFOVSystemDuringInteraction) == 0x0008C0, "Member 'UKillInteractionDefinition::_disableFOVSystemDuringInteraction' has a wrong offset!");
static_assert(offsetof(UKillInteractionDefinition, _overrideSlasherFieldOfViewDuringInteraction) == 0x0008C1, "Member 'UKillInteractionDefinition::_overrideSlasherFieldOfViewDuringInteraction' has a wrong offset!");
static_assert(offsetof(UKillInteractionDefinition, _overrideCamperFieldOfViewDuringInteraction) == 0x0008C2, "Member 'UKillInteractionDefinition::_overrideCamperFieldOfViewDuringInteraction' has a wrong offset!");
static_assert(offsetof(UKillInteractionDefinition, _camperCopySlasherFOVCurve) == 0x0008C3, "Member 'UKillInteractionDefinition::_camperCopySlasherFOVCurve' has a wrong offset!");
static_assert(offsetof(UKillInteractionDefinition, _cameraFOVCurveName) == 0x0008C4, "Member 'UKillInteractionDefinition::_cameraFOVCurveName' has a wrong offset!");
static_assert(offsetof(UKillInteractionDefinition, _moriKillAudioSwitchName) == 0x0008D0, "Member 'UKillInteractionDefinition::_moriKillAudioSwitchName' has a wrong offset!");
static_assert(offsetof(UKillInteractionDefinition, _moriKillAudioSwitchOnStateName) == 0x0008E0, "Member 'UKillInteractionDefinition::_moriKillAudioSwitchOnStateName' has a wrong offset!");
static_assert(offsetof(UKillInteractionDefinition, _moriKillAudioSwitchOffStateName) == 0x0008F0, "Member 'UKillInteractionDefinition::_moriKillAudioSwitchOffStateName' has a wrong offset!");
static_assert(offsetof(UKillInteractionDefinition, _setKillerStatusInCrazyStateDuringMori) == 0x000900, "Member 'UKillInteractionDefinition::_setKillerStatusInCrazyStateDuringMori' has a wrong offset!");
static_assert(offsetof(UKillInteractionDefinition, _killerStatusAudioSwitchName) == 0x000908, "Member 'UKillInteractionDefinition::_killerStatusAudioSwitchName' has a wrong offset!");
static_assert(offsetof(UKillInteractionDefinition, _killerStatusAudioSwitchCrazyState) == 0x000918, "Member 'UKillInteractionDefinition::_killerStatusAudioSwitchCrazyState' has a wrong offset!");
static_assert(offsetof(UKillInteractionDefinition, _killerStatusAudioSwitchExitState) == 0x000928, "Member 'UKillInteractionDefinition::_killerStatusAudioSwitchExitState' has a wrong offset!");
static_assert(offsetof(UKillInteractionDefinition, _killerStatusAudioSwitchDefaultState) == 0x000938, "Member 'UKillInteractionDefinition::_killerStatusAudioSwitchDefaultState' has a wrong offset!");
static_assert(offsetof(UKillInteractionDefinition, _nonOverrideableTargetInteractions) == 0x000948, "Member 'UKillInteractionDefinition::_nonOverrideableTargetInteractions' has a wrong offset!");
static_assert(offsetof(UKillInteractionDefinition, _chargeCompleted) == 0x000958, "Member 'UKillInteractionDefinition::_chargeCompleted' has a wrong offset!");
static_assert(offsetof(UKillInteractionDefinition, _isKillShownInThirdPerson) == 0x000959, "Member 'UKillInteractionDefinition::_isKillShownInThirdPerson' has a wrong offset!");
static_assert(offsetof(UKillInteractionDefinition, _manuallyManageMeshHiding) == 0x00095A, "Member 'UKillInteractionDefinition::_manuallyManageMeshHiding' has a wrong offset!");
static_assert(offsetof(UKillInteractionDefinition, _survivorAnimationLastAfterInteractionEnds) == 0x00095B, "Member 'UKillInteractionDefinition::_survivorAnimationLastAfterInteractionEnds' has a wrong offset!");
static_assert(offsetof(UKillInteractionDefinition, _maximumDelayBeforeSurvivorDeath) == 0x000990, "Member 'UKillInteractionDefinition::_maximumDelayBeforeSurvivorDeath' has a wrong offset!");
static_assert(offsetof(UKillInteractionDefinition, _exitMontage) == 0x000998, "Member 'UKillInteractionDefinition::_exitMontage' has a wrong offset!");
static_assert(offsetof(UKillInteractionDefinition, _slasherFacingTolerance) == 0x0009B8, "Member 'UKillInteractionDefinition::_slasherFacingTolerance' has a wrong offset!");

// Class DeadByDaylight.DBDOutlineComponentConfiguration
// 0x0100 (0x0138 - 0x0038)
class UDBDOutlineComponentConfiguration : public UDataAsset
{
public:
	TMap<TSoftClassPtr<class UClass>, struct FOutlineConfig> OutlineConfigs;                                    // 0x0038(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<class FName, struct FOutlineColourConfiguration> OutlineColours;                                    // 0x0088(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<TSoftObjectPtr<class UMaterialInterface>> TranslucencyDefaultMaterials;                      // 0x00D8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TMap<struct FGameplayTag, struct FOutlineOverrideConfig> OutlineOverrideConfigs;                            // 0x00E8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDOutlineComponentConfiguration">();
	}
	static class UDBDOutlineComponentConfiguration* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDOutlineComponentConfiguration>();
	}
};
static_assert(alignof(UDBDOutlineComponentConfiguration) == 0x000008, "Wrong alignment on UDBDOutlineComponentConfiguration");
static_assert(sizeof(UDBDOutlineComponentConfiguration) == 0x000138, "Wrong size on UDBDOutlineComponentConfiguration");
static_assert(offsetof(UDBDOutlineComponentConfiguration, OutlineConfigs) == 0x000038, "Member 'UDBDOutlineComponentConfiguration::OutlineConfigs' has a wrong offset!");
static_assert(offsetof(UDBDOutlineComponentConfiguration, OutlineColours) == 0x000088, "Member 'UDBDOutlineComponentConfiguration::OutlineColours' has a wrong offset!");
static_assert(offsetof(UDBDOutlineComponentConfiguration, TranslucencyDefaultMaterials) == 0x0000D8, "Member 'UDBDOutlineComponentConfiguration::TranslucencyDefaultMaterials' has a wrong offset!");
static_assert(offsetof(UDBDOutlineComponentConfiguration, OutlineOverrideConfigs) == 0x0000E8, "Member 'UDBDOutlineComponentConfiguration::OutlineOverrideConfigs' has a wrong offset!");

// Class DeadByDaylight.DBDOutlineComponentCustomDepthConfiguration
// 0x0000 (0x0138 - 0x0138)
class UDBDOutlineComponentCustomDepthConfiguration final : public UDBDOutlineComponentConfiguration
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDOutlineComponentCustomDepthConfiguration">();
	}
	static class UDBDOutlineComponentCustomDepthConfiguration* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDOutlineComponentCustomDepthConfiguration>();
	}
};
static_assert(alignof(UDBDOutlineComponentCustomDepthConfiguration) == 0x000008, "Wrong alignment on UDBDOutlineComponentCustomDepthConfiguration");
static_assert(sizeof(UDBDOutlineComponentCustomDepthConfiguration) == 0x000138, "Wrong size on UDBDOutlineComponentCustomDepthConfiguration");

// Class DeadByDaylight.DBDCheatValidatorSubsystem
// 0x0000 (0x0038 - 0x0038)
class UDBDCheatValidatorSubsystem final : public UEngineSubsystem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDCheatValidatorSubsystem">();
	}
	static class UDBDCheatValidatorSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDCheatValidatorSubsystem>();
	}
};
static_assert(alignof(UDBDCheatValidatorSubsystem) == 0x000008, "Wrong alignment on UDBDCheatValidatorSubsystem");
static_assert(sizeof(UDBDCheatValidatorSubsystem) == 0x000038, "Wrong size on UDBDCheatValidatorSubsystem");

// Class DeadByDaylight.PresentationPowerFadeComponent
// 0x0000 (0x00A8 - 0x00A8)
class UPresentationPowerFadeComponent : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PresentationPowerFadeComponent">();
	}
	static class UPresentationPowerFadeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPresentationPowerFadeComponent>();
	}
};
static_assert(alignof(UPresentationPowerFadeComponent) == 0x000008, "Wrong alignment on UPresentationPowerFadeComponent");
static_assert(sizeof(UPresentationPowerFadeComponent) == 0x0000A8, "Wrong size on UPresentationPowerFadeComponent");

// Class DeadByDaylight.ChatManager
// 0x0020 (0x02C0 - 0x02A0)
class AChatManager : public AActor
{
public:
	class UDBDGameInstance*                       _gameInstance;                                     // 0x02A0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A8[0x18];                                     // 0x02A8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Multicast_DisplayMessage(const class FString& ChatIdentifier, int32 PlayerIndex, const class FString& MirrorsId, const class FString& Msg);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChatManager">();
	}
	static class AChatManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AChatManager>();
	}
};
static_assert(alignof(AChatManager) == 0x000008, "Wrong alignment on AChatManager");
static_assert(sizeof(AChatManager) == 0x0002C0, "Wrong size on AChatManager");
static_assert(offsetof(AChatManager, _gameInstance) == 0x0002A0, "Member 'AChatManager::_gameInstance' has a wrong offset!");

// Class DeadByDaylight.IdentityValidation
// 0x0000 (0x0030 - 0x0030)
class UIdentityValidation final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IdentityValidation">();
	}
	static class UIdentityValidation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIdentityValidation>();
	}
};
static_assert(alignof(UIdentityValidation) == 0x000008, "Wrong alignment on UIdentityValidation");
static_assert(sizeof(UIdentityValidation) == 0x000030, "Wrong size on UIdentityValidation");

// Class DeadByDaylight.PowerWidgetPresentationComponent
// 0x0018 (0x00C0 - 0x00A8)
class UPowerWidgetPresentationComponent : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x10];                                      // 0x00A8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UPowerWidgetData*                       _powerWidgetData;                                  // 0x00B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PowerWidgetPresentationComponent">();
	}
	static class UPowerWidgetPresentationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPowerWidgetPresentationComponent>();
	}
};
static_assert(alignof(UPowerWidgetPresentationComponent) == 0x000008, "Wrong alignment on UPowerWidgetPresentationComponent");
static_assert(sizeof(UPowerWidgetPresentationComponent) == 0x0000C0, "Wrong size on UPowerWidgetPresentationComponent");
static_assert(offsetof(UPowerWidgetPresentationComponent, _powerWidgetData) == 0x0000B8, "Member 'UPowerWidgetPresentationComponent::_powerWidgetData' has a wrong offset!");

// Class DeadByDaylight.VaultableOutlineUpdateStrategy
// 0x0008 (0x0150 - 0x0148)
class UVaultableOutlineUpdateStrategy : public USourceBasedOutlineUpdateStrategy
{
public:
	bool                                          _canBeRevealedToLocalPlayer;                       // 0x0148(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_149[0x7];                                      // 0x0149(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetCanBeRevealedToLocalPlayer(bool CanBeRevealedToLocalPlayer);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VaultableOutlineUpdateStrategy">();
	}
	static class UVaultableOutlineUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVaultableOutlineUpdateStrategy>();
	}
};
static_assert(alignof(UVaultableOutlineUpdateStrategy) == 0x000008, "Wrong alignment on UVaultableOutlineUpdateStrategy");
static_assert(sizeof(UVaultableOutlineUpdateStrategy) == 0x000150, "Wrong size on UVaultableOutlineUpdateStrategy");
static_assert(offsetof(UVaultableOutlineUpdateStrategy, _canBeRevealedToLocalPlayer) == 0x000148, "Member 'UVaultableOutlineUpdateStrategy::_canBeRevealedToLocalPlayer' has a wrong offset!");

// Class DeadByDaylight.PalletOutlineUpdateStrategy
// 0x0010 (0x0160 - 0x0150)
class UPalletOutlineUpdateStrategy : public UVaultableOutlineUpdateStrategy
{
public:
	struct FLinearColor                           _revealedByPowerColor;                             // 0x0150(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalletOutlineUpdateStrategy">();
	}
	static class UPalletOutlineUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalletOutlineUpdateStrategy>();
	}
};
static_assert(alignof(UPalletOutlineUpdateStrategy) == 0x000008, "Wrong alignment on UPalletOutlineUpdateStrategy");
static_assert(sizeof(UPalletOutlineUpdateStrategy) == 0x000160, "Wrong size on UPalletOutlineUpdateStrategy");
static_assert(offsetof(UPalletOutlineUpdateStrategy, _revealedByPowerColor) == 0x000150, "Member 'UPalletOutlineUpdateStrategy::_revealedByPowerColor' has a wrong offset!");

// Class DeadByDaylight.DreamPalletOutlineUpdateStrategy
// 0x0028 (0x0188 - 0x0160)
class UDreamPalletOutlineUpdateStrategy final : public UPalletOutlineUpdateStrategy
{
public:
	struct FLinearColor                           _revealedByMapColor;                               // 0x0160(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_170[0x18];                                     // 0x0170(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeTunableValues(class ASlasherPlayer* Killer);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DreamPalletOutlineUpdateStrategy">();
	}
	static class UDreamPalletOutlineUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDreamPalletOutlineUpdateStrategy>();
	}
};
static_assert(alignof(UDreamPalletOutlineUpdateStrategy) == 0x000008, "Wrong alignment on UDreamPalletOutlineUpdateStrategy");
static_assert(sizeof(UDreamPalletOutlineUpdateStrategy) == 0x000188, "Wrong size on UDreamPalletOutlineUpdateStrategy");
static_assert(offsetof(UDreamPalletOutlineUpdateStrategy, _revealedByMapColor) == 0x000160, "Member 'UDreamPalletOutlineUpdateStrategy::_revealedByMapColor' has a wrong offset!");

// Class DeadByDaylight.DBDPlayer
// 0x0E10 (0x1540 - 0x0730)
class ADBDPlayer : public ADBDBasePlayer
{
public:
	uint8                                         Pad_728[0xE0];                                     // 0x0728(0x00E0)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          AllowInterrupting;                                 // 0x0808(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_809[0x3];                                      // 0x0809(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinFallHeight;                                     // 0x080C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_810[0x1];                                      // 0x0810(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          IsInInteractionUpdate;                             // 0x0811(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsInteractionChargeCompleted;                      // 0x0812(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_813[0x1];                                      // 0x0813(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PitchLimitLower;                                   // 0x0814(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchLimitUpper;                                   // 0x0818(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81C[0x4];                                      // 0x081C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                StrafingOffset;                                    // 0x0820(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PelvisHeight;                                      // 0x0838(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PelvisHeightForPounceOnStandingCamper;             // 0x083C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PelvisHeightForPounceOnCrouchingCamper;            // 0x0840(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_844[0x34];                                     // 0x0844(0x0034)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             Authority_OnAttackedDelegate;                      // 0x0878(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDamageTargetDelegate;                            // 0x0888(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSensed;                                          // 0x0898(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnAnimNotify_Pickup;                               // 0x08A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnAnimNotify_Release;                              // 0x08B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             Authority_OnSecondaryActionInput;                  // 0x08C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFirstPersonModeChanged;                          // 0x08D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDreamworldComponentSet;                          // 0x08E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnForwardInputLockedChanged;                       // 0x08F8(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	class USpringArmComponent*                    CameraBoom;                                        // 0x0908(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_910[0x18];                                     // 0x0910(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          ForceSkillChecks;                                  // 0x0928(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_929[0x7];                                      // 0x0929(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             IKLeftHandTransform;                               // 0x0930(0x0060)(BlueprintVisible, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             IKRightHandTransform;                              // 0x0990(0x0060)(BlueprintVisible, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraResetSpeed;                                  // 0x09F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9F4[0x4];                                      // 0x09F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AverageSpeedBufferTime;                            // 0x09F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AlmostCurrentSpeedBufferTime;                      // 0x09FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            GamepadYawCurve;                                   // 0x0A00(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            GamepadPitchCurve;                                 // 0x0A08(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            GamepadSettingToYawRateCurve;                      // 0x0A10(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            GamepadSettingToPitchRateCurve;                    // 0x0A18(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            JoyconSettingToYawRateCurve;                       // 0x0A20(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            JoyconSettingToPitchRateCurve;                     // 0x0A28(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnIsCrouchedChanged;                               // 0x0A30(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRunningAndMovingChanged;                         // 0x0A40(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_A50[0x18];                                     // 0x0A50(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UCameraComponent*                       Camera;                                            // 0x0A68(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialHelper*                        MaterialHelper;                                    // 0x0A70(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A78[0x30];                                     // 0x0A78(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class APlayerInteractable>        Interactable;                                      // 0x0AA8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AB0[0x18];                                     // 0x0AB0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UCharacterInventoryComponent*           _characterInventoryComponent;                      // 0x0AC8(0x0008)(Edit, ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   CarryJointName;                                    // 0x0AD0(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _pitchOffsetForInteractionPriority;                // 0x0ADC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxOcclusionQueryComponent*            _renderedPixelCounter;                             // 0x0AE0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          _standingOcclusionBox;                             // 0x0AE8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          _crouchingOcclusionBox;                            // 0x0AF0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UActivatorComponent*                    _activator;                                        // 0x0AF8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPlayerLockerStateComponent*            _lockerStateComponent;                             // 0x0B00(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsInteracting;                                     // 0x0B08(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B09[0x3];                                      // 0x0B09(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _aiCanBeSeenTestCrouchScale;                       // 0x0B0C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _aiCanBeSeenTestRightOffset;                       // 0x0B10(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _aiCanBeSeenTestHighOffset;                        // 0x0B14(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _aiCanBeSeenTestLowOffset;                         // 0x0B18(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ClearPathTestRadiusMultiplier;                     // 0x0B1C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ClearPathTestHeightMultiplier;                     // 0x0B20(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LocationClearTestRadiusMultiplier;                 // 0x0B24(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LocationClearTestHeightMultiplier;                 // 0x0B28(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ClearPathTestStepHeight;                           // 0x0B2C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MouseTurnSpeedMultiplier;                          // 0x0B30(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MouseLookUpSpeedMultiplier;                        // 0x0B34(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              DeathSound;                                        // 0x0B38(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECamperState                                  CurrentCamperState;                                // 0x0B40(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B41[0x3];                                      // 0x0B41(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CollectableAttachPoint;                            // 0x0B44(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStateMachine*                          _stateMachine;                                     // 0x0B50(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPlayerInteractionHandler*              _interactionHandler;                               // 0x0B58(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPerkManager*                           _perkManager;                                      // 0x0B60(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDBDPlayerData*                         _playerData;                                       // 0x0B68(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class APlayerInteractable*                    _interactable;                                     // 0x0B70(0x0008)(Net, ZeroConstructor, Transient, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B78[0x50];                                     // 0x0B78(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class ADBDPlayer*                             _carryingPlayer;                                   // 0x0BC8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_BD0[0x8];                                      // 0x0BD0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ADBDPlayer*                             _interactingPlayer;                                // 0x0BD8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_BE0[0x30];                                     // 0x0BE0(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	EAttackSubstate                               _nextAttackSubstate;                               // 0x0C10(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C11[0x7];                                      // 0x0C11(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ADBDPlayer*>                     _hitTargets;                                       // 0x0C18(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class UCharacterDreamworldComponent*          _dreamworldComponent;                              // 0x0C28(0x0008)(Edit, BlueprintVisible, ExportObject, Net, ZeroConstructor, EditConst, InstancedReference, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCharacterChaseVisualComponent*         _characterChaseVisualComponent;                    // 0x0C30(0x0008)(Edit, ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCameraHandlerComponent*                _cameraHandlerComponent;                           // 0x0C38(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, Transient, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UReversibleActionSystemComponent*       _reversibleActionSystemComponent;                  // 0x0C40(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        _itemDropOffPosition;                              // 0x0C48(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAIPerceptionStimuliSourceComponent*    _perceptionStimuliComponent;                       // 0x0C50(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class AActor*>                         _ignoreActors;                                     // 0x0C58(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FEffectCameraTypeSettings>      EffectCameraTypeSettings;                          // 0x0C68(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<class USceneComponent*, bool>            _detectionZoneEnabledMap;                          // 0x0C78(0x0050)(Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_CC8[0x58];                                     // 0x0CC8(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	class UChargeableComponent*                   _blindingChargeableComponent;                      // 0x0D20(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDateTime                              _stillnessStartTime;                               // 0x0D28(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D30[0xD8];                                     // 0x0D30(0x00D8)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _shouldUpdateStateMachineDriverOnPossessed;        // 0x0E08(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E09[0x7];                                      // 0x0E09(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBlindableComponent*                    _blindableComponent;                               // 0x0E10(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E18[0x4];                                      // 0x0E18(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _tutorialChargeableInteractionMultiplier;          // 0x0E1C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E20[0x8];                                      // 0x0E20(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UPollableEventListener*                 _eventListener;                                    // 0x0E28(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E30[0x8];                                      // 0x0E30(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UChaseComponent*                        _chaseComponent;                                   // 0x0E38(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UZoneDetectorComponent*                 _meatHookZoneDetector;                             // 0x0E40(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UZoneDetectorComponent*                 _basementZoneDetector;                             // 0x0E48(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E50[0x98];                                     // 0x0E50(0x0098)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  _animGameplayTags;                                 // 0x0EE8(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F08[0x88];                                     // 0x0F08(0x0088)(Fixing Size After Last Property [ Dumper-7 ])
	class UInteractionDefinition*                 _bookmarkedInteraction;                            // 0x0F90(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<EDetectionZone, class UPrimitiveComponent*> _detectionZoneMap;                                 // 0x0F98(0x0050)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_FE8[0x70];                                     // 0x0FE8(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	class UAuthoritativeMovementComponent*        _authoritativeMovementComponent;                   // 0x1058(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1060[0x338];                                   // 0x1060(0x0338)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _screenAspectRatio;                                // 0x1398(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_139C[0x1C];                                    // 0x139C(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	class UGameplayTagContainerComponent*         _objectState;                                      // 0x13B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAudioFXComponent*                      _audioFXComponent;                                 // 0x13C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPlayerPerspectiveComponent*            _playerPerspectiveComponent;                       // 0x13C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_13D0[0x8];                                     // 0x13D0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UCharacterSightComponent*               _characterSightComponent;                          // 0x13D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_13E0[0x8];                                     // 0x13E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UCharacterSightableComponent*           _characterSightableComponent;                      // 0x13E8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_13F0[0x10];                                    // 0x13F0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UNavigationStateComponent*              _navigationStateComponent;                         // 0x1400(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInteractionDetectorComponent*          _interactionDetectorComponent;                     // 0x1408(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPrimitivesRegistererComponent*         _clippablePrimitivesRegistererComponent;           // 0x1410(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UClippableProviderComponent*            _clippableProviderComponent;                       // 0x1418(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDynamicCapsuleResizerComponent*        _dynCapsuleResizer;                                // 0x1420(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPlayerGameRelevancyComponent*          _playerGameRelevancyComponent;                     // 0x1428(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UContextualQuestComponent*              _contextualQuestComponent;                         // 0x1430(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1438[0x20];                                    // 0x1438(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UActorComponent*                        _questEventHandler;                                // 0x1458(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UChargeableProgressProviderComponent*   _presentationChargeableProgressComponent;          // 0x1460(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1468[0x18];                                    // 0x1468(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            _currentGamepadYawCurve;                           // 0x1480(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _currentGamepadPitchCurve;                         // 0x1488(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ADBDPlayerState*                        _associatedPlayerStateCache;                       // 0x1490(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FOnMovementCacheStruct                 _onMovementCacheStruct;                            // 0x1498(0x0018)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_14B0[0x8];                                     // 0x14B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UOtherCharactersVerticalCollisionsHandler* _otherCharactersVerticalCollisionsHandler;         // 0x14B8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_14C0[0x80];                                    // 0x14C0(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddDetectionZone(EDetectionZone DetectionZoneID, class UPrimitiveComponent* Zone);
	void AttachInteractor(class UInteractor* Interactor);
	void Authority_HandleScoreEvent(const struct FGameplayTag& ScoreTypeTag, const struct FScoreEventData& ScoreEventData);
	void Authority_RequestStun(EStunType StunType, class ADBDPlayer* Stunner);
	void Authority_SetDreamworldComponent(class UCharacterDreamworldComponent* Component);
	void CameraUpdated();
	void CancelCarry(bool AlsoCancelForOtherPlayer);
	void Client_SendCancelInteraction(const class UInteractionDefinition* InteractionDefinition);
	void Client_TryInteraction(class UInteractionDefinition* Interaction, class ADBDPlayer* Requester, bool Force, bool UsingInputPersistence);
	void Client_TryInteractionType(EInputInteractionType InteractionType, class ADBDPlayer* Requester);
	void DBD_SetMouseLookUpSpeedMultiplier(float Value);
	void DBD_SetMouseTurnSpeedMultiplier(float Value);
	void DBD_ToggleForceAuthoritativeMovement();
	void DBDCrouch();
	void DBDUnCrouch();
	void DetachInteractor();
	void Dissolve(bool Param_Dissolve);
	const struct FInteractionPlayerProperties GetInteractionPlayerProperties();
	bool K2_SetActorLocationByBottomCapsule(const struct FVector& NewLocation, bool bSweep, struct FHitResult* SweepHitResult);
	void Local_NotifyMatchEnded();
	void Multicast_Broadcast_DebugPlayMontage(const struct FAnimationMontageDescriptor& AnimMontageID, float PlayRate);
	void Multicast_ConfirmItemDrop(bool Pressed);
	void Multicast_Debug_SetMaxWalkSpeed(float MaxWalkSpeed);
	void Multicast_LeaveGame(const struct FGuid& UniqueLeavingPlayerId);
	void Multicast_ReplicateController(class AController* NewController);
	void Multicast_ServerResetMeshRelativeOffSet();
	void Multicast_SetAuthoritativeMovement(bool Enabled);
	void Multicast_SetContinuousPrintDebug(bool Enabled);
	void Multicast_SetCustomization(const struct FEquippedPlayerCustomization& Customization);
	void Multicast_SetDebugCarry(bool Enabled);
	void Multicast_SetDebugPrintAvailableInteractions(bool Enabled);
	void Multicast_SetDebugSnapPoint(bool Enabled);
	void Multicast_SetEnableCapsuleDynamicResize(bool Enabled);
	void Multicast_SetForceAuthoritativeMovement(bool Value);
	void Multicast_SetInteractingPlayer(class ADBDPlayer* InteractingPlayer);
	void Multicast_SetReverseTraverseEnabled(bool Enabled);
	void Multicast_SetRunVaultEnabled(bool Enabled);
	void OnAllPlayerLoaded();
	void OnBlindChargeEmptied();
	void OnClientRestart();
	void OnControllerChanged(class APawn* Pawn, class AController* OldController, class AController* NewController);
	void OnEscapeDoorActivated();
	void OnHudVisibilityChanged(const bool IsVisible);
	void OnHudVisibilityChangedNative(const bool IsVisible);
	void OnInterruptedStart();
	void OnIntroCompleted();
	void OnIntroCompletedNative();
	void OnIsCrouchedChanged__DelegateSignature(bool IsCrouched);
	void OnLevelReadyToPlay();
	void OnLocallyObservedChanged();
	void OnPickupEnd(class ADBDPlayer* Target);
	void OnPickupStart(class ADBDPlayer* Target);
	void OnPostProcessInput();
	void OnRep_DreamworldComponent();
	void OnRep_Interactable();
	void RemoveStatusEffect(class UStatusEffect* StatusEffect);
	void ResetCamera();
	void ResetPitchScale(float AdjustTime);
	void Server_Broadcast_DebugPlayMontage(const struct FAnimationMontageDescriptor& AnimMontageID, float PlayRate);
	void Server_DebugSetCustomization(const struct FEquippedPlayerCustomization& Customization);
	void Server_SendAbilityInput(bool Pressed);
	void Server_SendAbilityTwoInput(bool Pressed);
	void Server_SendEventAbilityInput(bool Pressed);
	void Server_SendFastInteractionInput(bool Pressed);
	void Server_SendInteractionInput(bool Pressed);
	void Server_SendItemDropInput(bool Pressed);
	void Server_SendItemUseInput(bool Pressed, bool RequestItemUse);
	void Server_SendSecondaryActionPressed(bool FromCancelRequest);
	void Server_UpdateScreenAspectRatio(const float Value);
	void SetAllDetectionZonesEnabled(bool Enabled);
	void SetAnimationCrouchState(bool Crouched);
	void SetDetectionZoneEnabled(EDetectionZone DetectionZoneID, bool Enabled);
	void SetFirstPersonModelEnabled(bool Enabled, bool Force);
	void SetFirstPersonVfxsVisibility(bool IsFirstPerson);
	void SetForceDisableSkillChecks(bool IsEnabled);
	void SetItemUseAsToggle(bool Value);
	void SetQuestEventHandlerComponent(class UActorComponent* Component);
	void SetReverseMontage(bool Reverse);
	void SetShouldPlayCarryAnim(bool Param_ShouldPlayCarryAnim);
	void TriggerAnimNotify(EAnimNotifyType AnimNotifyType);
	bool TryInteraction(class UInteractionDefinition* Interaction, class ADBDPlayer* Requester, bool Force, bool UsingInputPersistence);
	bool TryInteractionType(EInputInteractionType InteractionInputType, class ADBDPlayer* Requester, bool UsingInputPersistence, bool Force);

	void Authority_EvaluateIfPlayerCanSee() const;
	bool CanInterrupt_BP() const;
	class ADBDPlayer* FindClosestSlashablePlayerInDetectionZone(EDetectionZone DetectionZoneID) const;
	struct FVector GetActorLocationFromFeetLocation(const struct FVector& FeetLocation) const;
	class ADBDPlayer* GetAssociatedPlayer() const;
	class APlayerState* GetAssociatedPlayerState() const;
	class USceneComponent* GetAttachPoint(class FName AttachPointName) const;
	class UAuthoritativeMovementComponent* GetAuthoritativeMovementComponent() const;
	struct FVector GetAverageVelocity() const;
	class UBlindableComponent* GetBlindableComponent() const;
	struct FVector GetBoneLocation(class FName Param_Name, EBoneSpaces Space) const;
	class ADBDPlayerCameraManager* GetCameraManager() const;
	class UCharacterInventoryComponent* GetCharacterInventoryComponent() const;
	class UChaseComponent* GetChaseComponent() const;
	class UInteractionDefinition* GetCurrentInteraction() const;
	EInteractionAnimation GetCurrentInteractionAnimation() const;
	class ADBDPlayerState* GetDBDPlayerState() const;
	class UPrimitiveComponent* GetDetectionZone(EDetectionZone DetectionZoneID) const;
	class UCharacterDreamworldComponent* GetDreamworldComponent() const;
	struct FVector GetFeetPosition() const;
	class UActorComponent* GetFirstComponentByClass(TSubclassOf<class UActorComponent> ComponentClass) const;
	float GetGrassEffectRadiusMultiplier() const;
	class AInteractable* GetInteractable() const;
	class UInteractionDetectorComponent* GetInteractionDetectorComponent() const;
	bool GetIsInFirstPerson() const;
	bool GetIsInteracting() const;
	bool GetIsInterrupting() const;
	const TArray<class UItemAddon*> GetItemAddons() const;
	const TArray<class UItemModifier*> GetItemModifiers() const;
	float GetLuck() const;
	float GetMaxSpeed() const;
	class FString GetNameDebugString() const;
	class UGameplayTagContainerComponent* GetObjectState() const;
	class UOtherCharactersVerticalCollisionsHandler* GetOtherCharactersVerticalCollisionsHandler() const;
	EPawnType GetPawnType() const;
	float GetPercentMovementSpeed() const;
	class UPerkManager* GetPerkManager() const;
	class UCameraComponent* GetPlayerCamera() const;
	class ADBDPlayerController* GetPlayerController() const;
	struct FRotator GetPlayerDirection() const;
	class UPlayerInteractionHandler* GetPlayerInteractionHandler() const;
	EPlayerRole GetPlayerRole() const;
	EPlayerTeam GetPlayerTeam() const;
	struct FRotator GetRepControlRotation() const;
	bool GetReverseTraverseEnabled() const;
	bool GetRunVaultEnabled() const;
	class ADBDPlayerController* GetSharedPlayerController() const;
	struct FDateTime GetStillnessStartTime() const;
	float GetTunableValue(class FName Key, float DefaultValue, bool WarnIfRowMissing) const;
	bool HasClearPathToTarget(const struct FVector& TargetPosition) const;
	bool HasClearPathToTargetWithFilter(const struct FVector& TargetPosition, TSubclassOf<class AActor> ClassFilter, class AActor* IgnoreActor) const;
	bool HasClearPathToTargetWithIgnore(const struct FVector& TargetPosition, const TArray<class AActor*>& IgnoreActors) const;
	bool HasDamageImmunity() const;
	bool HasMoveInput() const;
	bool IsBeingInterrupted() const;
	bool IsCloaked() const;
	bool IsCrouching() const;
	bool IsCrouchPressed() const;
	bool IsExhausted() const;
	bool IsForPreview() const;
	bool IsHeadHidden() const;
	bool IsIncapacitated() const;
	bool IsInMeathookZone() const;
	bool IsInParadise() const;
	bool IsInsideCloset() const;
	bool IsInStalkMode() const;
	bool IsInteractionInputPressed(EInputInteractionType InteractionType) const;
	bool IsInTerrorRadius() const;
	bool IsLocallyObserved() const;
	bool IsMoving() const;
	bool IsRunning() const;
	bool Local_IsInteractionInputPressed(EInputInteractionType InteractionType) const;
	class FString OnGetCharacterName() const;
	bool ShouldFall() const;
	bool ShouldPlayCarryAnim() const;
	void UpdateLoadoutFromInventory() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDPlayer">();
	}
	static class ADBDPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDPlayer>();
	}
};
static_assert(alignof(ADBDPlayer) == 0x000010, "Wrong alignment on ADBDPlayer");
static_assert(sizeof(ADBDPlayer) == 0x001540, "Wrong size on ADBDPlayer");
static_assert(offsetof(ADBDPlayer, AllowInterrupting) == 0x000808, "Member 'ADBDPlayer::AllowInterrupting' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, MinFallHeight) == 0x00080C, "Member 'ADBDPlayer::MinFallHeight' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, IsInInteractionUpdate) == 0x000811, "Member 'ADBDPlayer::IsInInteractionUpdate' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, IsInteractionChargeCompleted) == 0x000812, "Member 'ADBDPlayer::IsInteractionChargeCompleted' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, PitchLimitLower) == 0x000814, "Member 'ADBDPlayer::PitchLimitLower' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, PitchLimitUpper) == 0x000818, "Member 'ADBDPlayer::PitchLimitUpper' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, StrafingOffset) == 0x000820, "Member 'ADBDPlayer::StrafingOffset' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, PelvisHeight) == 0x000838, "Member 'ADBDPlayer::PelvisHeight' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, PelvisHeightForPounceOnStandingCamper) == 0x00083C, "Member 'ADBDPlayer::PelvisHeightForPounceOnStandingCamper' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, PelvisHeightForPounceOnCrouchingCamper) == 0x000840, "Member 'ADBDPlayer::PelvisHeightForPounceOnCrouchingCamper' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, Authority_OnAttackedDelegate) == 0x000878, "Member 'ADBDPlayer::Authority_OnAttackedDelegate' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, OnDamageTargetDelegate) == 0x000888, "Member 'ADBDPlayer::OnDamageTargetDelegate' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, OnSensed) == 0x000898, "Member 'ADBDPlayer::OnSensed' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, OnAnimNotify_Pickup) == 0x0008A8, "Member 'ADBDPlayer::OnAnimNotify_Pickup' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, OnAnimNotify_Release) == 0x0008B8, "Member 'ADBDPlayer::OnAnimNotify_Release' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, Authority_OnSecondaryActionInput) == 0x0008C8, "Member 'ADBDPlayer::Authority_OnSecondaryActionInput' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, OnFirstPersonModeChanged) == 0x0008D8, "Member 'ADBDPlayer::OnFirstPersonModeChanged' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, OnDreamworldComponentSet) == 0x0008E8, "Member 'ADBDPlayer::OnDreamworldComponentSet' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, OnForwardInputLockedChanged) == 0x0008F8, "Member 'ADBDPlayer::OnForwardInputLockedChanged' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, CameraBoom) == 0x000908, "Member 'ADBDPlayer::CameraBoom' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, ForceSkillChecks) == 0x000928, "Member 'ADBDPlayer::ForceSkillChecks' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, IKLeftHandTransform) == 0x000930, "Member 'ADBDPlayer::IKLeftHandTransform' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, IKRightHandTransform) == 0x000990, "Member 'ADBDPlayer::IKRightHandTransform' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, CameraResetSpeed) == 0x0009F0, "Member 'ADBDPlayer::CameraResetSpeed' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, AverageSpeedBufferTime) == 0x0009F8, "Member 'ADBDPlayer::AverageSpeedBufferTime' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, AlmostCurrentSpeedBufferTime) == 0x0009FC, "Member 'ADBDPlayer::AlmostCurrentSpeedBufferTime' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, GamepadYawCurve) == 0x000A00, "Member 'ADBDPlayer::GamepadYawCurve' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, GamepadPitchCurve) == 0x000A08, "Member 'ADBDPlayer::GamepadPitchCurve' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, GamepadSettingToYawRateCurve) == 0x000A10, "Member 'ADBDPlayer::GamepadSettingToYawRateCurve' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, GamepadSettingToPitchRateCurve) == 0x000A18, "Member 'ADBDPlayer::GamepadSettingToPitchRateCurve' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, JoyconSettingToYawRateCurve) == 0x000A20, "Member 'ADBDPlayer::JoyconSettingToYawRateCurve' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, JoyconSettingToPitchRateCurve) == 0x000A28, "Member 'ADBDPlayer::JoyconSettingToPitchRateCurve' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, OnIsCrouchedChanged) == 0x000A30, "Member 'ADBDPlayer::OnIsCrouchedChanged' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, OnRunningAndMovingChanged) == 0x000A40, "Member 'ADBDPlayer::OnRunningAndMovingChanged' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, Camera) == 0x000A68, "Member 'ADBDPlayer::Camera' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, MaterialHelper) == 0x000A70, "Member 'ADBDPlayer::MaterialHelper' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, Interactable) == 0x000AA8, "Member 'ADBDPlayer::Interactable' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _characterInventoryComponent) == 0x000AC8, "Member 'ADBDPlayer::_characterInventoryComponent' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, CarryJointName) == 0x000AD0, "Member 'ADBDPlayer::CarryJointName' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _pitchOffsetForInteractionPriority) == 0x000ADC, "Member 'ADBDPlayer::_pitchOffsetForInteractionPriority' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _renderedPixelCounter) == 0x000AE0, "Member 'ADBDPlayer::_renderedPixelCounter' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _standingOcclusionBox) == 0x000AE8, "Member 'ADBDPlayer::_standingOcclusionBox' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _crouchingOcclusionBox) == 0x000AF0, "Member 'ADBDPlayer::_crouchingOcclusionBox' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _activator) == 0x000AF8, "Member 'ADBDPlayer::_activator' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _lockerStateComponent) == 0x000B00, "Member 'ADBDPlayer::_lockerStateComponent' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, IsInteracting) == 0x000B08, "Member 'ADBDPlayer::IsInteracting' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _aiCanBeSeenTestCrouchScale) == 0x000B0C, "Member 'ADBDPlayer::_aiCanBeSeenTestCrouchScale' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _aiCanBeSeenTestRightOffset) == 0x000B10, "Member 'ADBDPlayer::_aiCanBeSeenTestRightOffset' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _aiCanBeSeenTestHighOffset) == 0x000B14, "Member 'ADBDPlayer::_aiCanBeSeenTestHighOffset' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _aiCanBeSeenTestLowOffset) == 0x000B18, "Member 'ADBDPlayer::_aiCanBeSeenTestLowOffset' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, ClearPathTestRadiusMultiplier) == 0x000B1C, "Member 'ADBDPlayer::ClearPathTestRadiusMultiplier' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, ClearPathTestHeightMultiplier) == 0x000B20, "Member 'ADBDPlayer::ClearPathTestHeightMultiplier' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, LocationClearTestRadiusMultiplier) == 0x000B24, "Member 'ADBDPlayer::LocationClearTestRadiusMultiplier' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, LocationClearTestHeightMultiplier) == 0x000B28, "Member 'ADBDPlayer::LocationClearTestHeightMultiplier' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, ClearPathTestStepHeight) == 0x000B2C, "Member 'ADBDPlayer::ClearPathTestStepHeight' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, MouseTurnSpeedMultiplier) == 0x000B30, "Member 'ADBDPlayer::MouseTurnSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, MouseLookUpSpeedMultiplier) == 0x000B34, "Member 'ADBDPlayer::MouseLookUpSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, DeathSound) == 0x000B38, "Member 'ADBDPlayer::DeathSound' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, CurrentCamperState) == 0x000B40, "Member 'ADBDPlayer::CurrentCamperState' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, CollectableAttachPoint) == 0x000B44, "Member 'ADBDPlayer::CollectableAttachPoint' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _stateMachine) == 0x000B50, "Member 'ADBDPlayer::_stateMachine' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _interactionHandler) == 0x000B58, "Member 'ADBDPlayer::_interactionHandler' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _perkManager) == 0x000B60, "Member 'ADBDPlayer::_perkManager' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _playerData) == 0x000B68, "Member 'ADBDPlayer::_playerData' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _interactable) == 0x000B70, "Member 'ADBDPlayer::_interactable' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _carryingPlayer) == 0x000BC8, "Member 'ADBDPlayer::_carryingPlayer' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _interactingPlayer) == 0x000BD8, "Member 'ADBDPlayer::_interactingPlayer' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _nextAttackSubstate) == 0x000C10, "Member 'ADBDPlayer::_nextAttackSubstate' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _hitTargets) == 0x000C18, "Member 'ADBDPlayer::_hitTargets' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _dreamworldComponent) == 0x000C28, "Member 'ADBDPlayer::_dreamworldComponent' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _characterChaseVisualComponent) == 0x000C30, "Member 'ADBDPlayer::_characterChaseVisualComponent' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _cameraHandlerComponent) == 0x000C38, "Member 'ADBDPlayer::_cameraHandlerComponent' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _reversibleActionSystemComponent) == 0x000C40, "Member 'ADBDPlayer::_reversibleActionSystemComponent' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _itemDropOffPosition) == 0x000C48, "Member 'ADBDPlayer::_itemDropOffPosition' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _perceptionStimuliComponent) == 0x000C50, "Member 'ADBDPlayer::_perceptionStimuliComponent' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _ignoreActors) == 0x000C58, "Member 'ADBDPlayer::_ignoreActors' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, EffectCameraTypeSettings) == 0x000C68, "Member 'ADBDPlayer::EffectCameraTypeSettings' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _detectionZoneEnabledMap) == 0x000C78, "Member 'ADBDPlayer::_detectionZoneEnabledMap' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _blindingChargeableComponent) == 0x000D20, "Member 'ADBDPlayer::_blindingChargeableComponent' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _stillnessStartTime) == 0x000D28, "Member 'ADBDPlayer::_stillnessStartTime' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _shouldUpdateStateMachineDriverOnPossessed) == 0x000E08, "Member 'ADBDPlayer::_shouldUpdateStateMachineDriverOnPossessed' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _blindableComponent) == 0x000E10, "Member 'ADBDPlayer::_blindableComponent' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _tutorialChargeableInteractionMultiplier) == 0x000E1C, "Member 'ADBDPlayer::_tutorialChargeableInteractionMultiplier' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _eventListener) == 0x000E28, "Member 'ADBDPlayer::_eventListener' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _chaseComponent) == 0x000E38, "Member 'ADBDPlayer::_chaseComponent' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _meatHookZoneDetector) == 0x000E40, "Member 'ADBDPlayer::_meatHookZoneDetector' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _basementZoneDetector) == 0x000E48, "Member 'ADBDPlayer::_basementZoneDetector' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _animGameplayTags) == 0x000EE8, "Member 'ADBDPlayer::_animGameplayTags' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _bookmarkedInteraction) == 0x000F90, "Member 'ADBDPlayer::_bookmarkedInteraction' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _detectionZoneMap) == 0x000F98, "Member 'ADBDPlayer::_detectionZoneMap' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _authoritativeMovementComponent) == 0x001058, "Member 'ADBDPlayer::_authoritativeMovementComponent' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _screenAspectRatio) == 0x001398, "Member 'ADBDPlayer::_screenAspectRatio' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _objectState) == 0x0013B8, "Member 'ADBDPlayer::_objectState' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _audioFXComponent) == 0x0013C0, "Member 'ADBDPlayer::_audioFXComponent' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _playerPerspectiveComponent) == 0x0013C8, "Member 'ADBDPlayer::_playerPerspectiveComponent' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _characterSightComponent) == 0x0013D8, "Member 'ADBDPlayer::_characterSightComponent' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _characterSightableComponent) == 0x0013E8, "Member 'ADBDPlayer::_characterSightableComponent' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _navigationStateComponent) == 0x001400, "Member 'ADBDPlayer::_navigationStateComponent' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _interactionDetectorComponent) == 0x001408, "Member 'ADBDPlayer::_interactionDetectorComponent' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _clippablePrimitivesRegistererComponent) == 0x001410, "Member 'ADBDPlayer::_clippablePrimitivesRegistererComponent' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _clippableProviderComponent) == 0x001418, "Member 'ADBDPlayer::_clippableProviderComponent' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _dynCapsuleResizer) == 0x001420, "Member 'ADBDPlayer::_dynCapsuleResizer' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _playerGameRelevancyComponent) == 0x001428, "Member 'ADBDPlayer::_playerGameRelevancyComponent' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _contextualQuestComponent) == 0x001430, "Member 'ADBDPlayer::_contextualQuestComponent' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _questEventHandler) == 0x001458, "Member 'ADBDPlayer::_questEventHandler' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _presentationChargeableProgressComponent) == 0x001460, "Member 'ADBDPlayer::_presentationChargeableProgressComponent' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _currentGamepadYawCurve) == 0x001480, "Member 'ADBDPlayer::_currentGamepadYawCurve' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _currentGamepadPitchCurve) == 0x001488, "Member 'ADBDPlayer::_currentGamepadPitchCurve' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _associatedPlayerStateCache) == 0x001490, "Member 'ADBDPlayer::_associatedPlayerStateCache' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _onMovementCacheStruct) == 0x001498, "Member 'ADBDPlayer::_onMovementCacheStruct' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _otherCharactersVerticalCollisionsHandler) == 0x0014B8, "Member 'ADBDPlayer::_otherCharactersVerticalCollisionsHandler' has a wrong offset!");

// Class DeadByDaylight.DBDDesignTunables
// 0x0068 (0x00A0 - 0x0038)
class UDBDDesignTunables final : public UEngineSubsystem
{
public:
	TSoftObjectPtr<class UDesignTunableDataAsset> SoftDesignTunableDataAsset;                        // 0x0038(0x0038)(Edit, BlueprintVisible, Config, NoClear, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDesignTunableDataAsset*                DesignTunableDataAsset;                            // 0x0070(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMenuCameraDesignTunables*              MenuCameraDesignTunables;                          // 0x0078(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDBDTextDesignTunables*                 TextTunables;                                      // 0x0080(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDBDCoreUMGDesignTunables*              CoreUMGDesignTunables;                             // 0x0088(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_90[0x10];                                      // 0x0090(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static const TArray<class FString> GetArrayGameTypeTunable(EGameType GameType, EGameTypeModifierName TunableName);
	static const bool GetBoolGameTypeTunable(EGameType GameType, EGameTypeModifierName TunableName);
	static const float GetFloatGameTypeTunable(EGameType GameType, EGameTypeModifierName TunableName);
	static const int32 GetIntGameTypeTunable(EGameType GameType, EGameTypeModifierName TunableName);
	static class FString GetStringGameTypeTunable(EGameType GameType, EGameTypeModifierName TunableName);

	void OnPluginDataPathAdded(const class FString& DataPath);

	float GetTunableValue(class FName ID, bool WarnIfRowMissing) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDDesignTunables">();
	}
	static class UDBDDesignTunables* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDDesignTunables>();
	}
};
static_assert(alignof(UDBDDesignTunables) == 0x000008, "Wrong alignment on UDBDDesignTunables");
static_assert(sizeof(UDBDDesignTunables) == 0x0000A0, "Wrong size on UDBDDesignTunables");
static_assert(offsetof(UDBDDesignTunables, SoftDesignTunableDataAsset) == 0x000038, "Member 'UDBDDesignTunables::SoftDesignTunableDataAsset' has a wrong offset!");
static_assert(offsetof(UDBDDesignTunables, DesignTunableDataAsset) == 0x000070, "Member 'UDBDDesignTunables::DesignTunableDataAsset' has a wrong offset!");
static_assert(offsetof(UDBDDesignTunables, MenuCameraDesignTunables) == 0x000078, "Member 'UDBDDesignTunables::MenuCameraDesignTunables' has a wrong offset!");
static_assert(offsetof(UDBDDesignTunables, TextTunables) == 0x000080, "Member 'UDBDDesignTunables::TextTunables' has a wrong offset!");
static_assert(offsetof(UDBDDesignTunables, CoreUMGDesignTunables) == 0x000088, "Member 'UDBDDesignTunables::CoreUMGDesignTunables' has a wrong offset!");

// Class DeadByDaylight.PlayerStateMachine
// 0x0000 (0x0120 - 0x0120)
class UPlayerStateMachine : public UStateMachine
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerStateMachine">();
	}
	static class UPlayerStateMachine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerStateMachine>();
	}
};
static_assert(alignof(UPlayerStateMachine) == 0x000010, "Wrong alignment on UPlayerStateMachine");
static_assert(sizeof(UPlayerStateMachine) == 0x000120, "Wrong size on UPlayerStateMachine");

// Class DeadByDaylight.DBDInitPlayerQuery
// 0x0000 (0x0030 - 0x0030)
class UDBDInitPlayerQuery : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDInitPlayerQuery">();
	}
	static class UDBDInitPlayerQuery* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDInitPlayerQuery>();
	}
};
static_assert(alignof(UDBDInitPlayerQuery) == 0x000008, "Wrong alignment on UDBDInitPlayerQuery");
static_assert(sizeof(UDBDInitPlayerQuery) == 0x000030, "Wrong size on UDBDInitPlayerQuery");

// Class DeadByDaylight.DBDCharacterMovementComponent
// 0x04D0 (0x1420 - 0x0F50)
class UDBDCharacterMovementComponent : public UCharacterMovementComponent
{
public:
	uint8                                         Pad_F50[0x10];                                     // 0x0F50(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ProjectedWallSlidingFactor;                        // 0x0F60(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RandomInputFrontMultiplier;                        // 0x0F64(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RandomInputSideMultiplier;                         // 0x0F68(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RandomInputBackMultiplier;                         // 0x0F6C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F70[0xE8];                                     // 0x0F70(0x00E8)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBHVRPerDetailModeFloat                _significanceThresholdForSmoothUpdateVisualOptimization; // 0x1058(0x00A0)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FBHVRPerDetailModeFloat                _significanceThresholdForSimulatedMovementPrediction; // 0x10F8(0x00A0)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FBHVRPerDetailModeInt                  _significanceMaxRefreshRateForSmoothUpdateVisualOptimization; // 0x1198(0x00A0)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	bool                                          _forceUseDropStaggerFix;                           // 0x1238(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1239[0x17];                                    // 0x1239(0x0017)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UCurveFloat*>                    _maxSpeedMultiplierCurvesToRemoveOnTheServer;      // 0x1250(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1260[0x120];                                   // 0x1260(0x0120)(Fixing Size After Last Property [ Dumper-7 ])
	class UBaseCharacterVelocityCalculationStrategy* _velocityAdditiveStrategy;                         // 0x1380(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBaseInputAccelerationConstraintStrategy* _inputAccelerationConstraintStrategy;              // 0x1388(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBaseCharacterRotationStrategy*         _rotationStrategy;                                 // 0x1390(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 _lookAtTarget;                                     // 0x1398(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_13A0[0x80];                                    // 0x13A0(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Client_Cheat_SetMaxSpeedMultiplier(const float MaxSpeedMultiplier);
	void Client_PreventMovement(const bool Value);
	void Client_Stop();
	void Client_TeleportTo(const struct FVector_NetQuantize100& Location, const struct FYawAndPitchRotator_NetQuantize32& Rotation);
	void OnMontageStarted(const struct FMontagePlaybackDefinition& MontageDefinition, const class UAnimMontage* Montage);
	void OnPreMontageStop(const struct FMontageStopDefinition& MontageDefinition, const class UAnimMontage* Montage);
	void Server_AddMaxSpeedMovementCurve(float Timestamp, const uint32 CurveNetId, float Duration, float StartOffset, const EMovementCurveType MovementCurveType);
	void Server_Launch(float Timestamp, const struct FVector& LaunchVelocity, int32 LaunchCallCount);
	void Server_MovementTimeSync(uint64 ClientTimeSync);
	void Server_PlayMontage(float Timestamp, const struct FMontagePlaybackDefinition& MontagePlaybackDefinition, int32 PlayMontageCallCount);
	void Server_RemoveMaxSpeedMovementCurve(float Timestamp, const uint32 CurveNetId, const EMovementCurveType MovementCurveType);
	void Server_ReplicateControlRotation(uint8 ClientRoll, uint32 View);
	void Server_SetMaxAcceleration(float Timestamp, float Value);
	void Server_SetStopSnapping(float Timestamp, const bool SnapToFinalDestination);
	void Server_StartSnapping(float Timestamp, const struct FSnappingData& Data, int32 SnappingCallCount, uint64 ClientTimeSync);
	void Server_StopMontage(float Timestamp, const struct FMontageStopDefinition& MontageStopDefinition);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDCharacterMovementComponent">();
	}
	static class UDBDCharacterMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDCharacterMovementComponent>();
	}
};
static_assert(alignof(UDBDCharacterMovementComponent) == 0x000010, "Wrong alignment on UDBDCharacterMovementComponent");
static_assert(sizeof(UDBDCharacterMovementComponent) == 0x001420, "Wrong size on UDBDCharacterMovementComponent");
static_assert(offsetof(UDBDCharacterMovementComponent, ProjectedWallSlidingFactor) == 0x000F60, "Member 'UDBDCharacterMovementComponent::ProjectedWallSlidingFactor' has a wrong offset!");
static_assert(offsetof(UDBDCharacterMovementComponent, RandomInputFrontMultiplier) == 0x000F64, "Member 'UDBDCharacterMovementComponent::RandomInputFrontMultiplier' has a wrong offset!");
static_assert(offsetof(UDBDCharacterMovementComponent, RandomInputSideMultiplier) == 0x000F68, "Member 'UDBDCharacterMovementComponent::RandomInputSideMultiplier' has a wrong offset!");
static_assert(offsetof(UDBDCharacterMovementComponent, RandomInputBackMultiplier) == 0x000F6C, "Member 'UDBDCharacterMovementComponent::RandomInputBackMultiplier' has a wrong offset!");
static_assert(offsetof(UDBDCharacterMovementComponent, _significanceThresholdForSmoothUpdateVisualOptimization) == 0x001058, "Member 'UDBDCharacterMovementComponent::_significanceThresholdForSmoothUpdateVisualOptimization' has a wrong offset!");
static_assert(offsetof(UDBDCharacterMovementComponent, _significanceThresholdForSimulatedMovementPrediction) == 0x0010F8, "Member 'UDBDCharacterMovementComponent::_significanceThresholdForSimulatedMovementPrediction' has a wrong offset!");
static_assert(offsetof(UDBDCharacterMovementComponent, _significanceMaxRefreshRateForSmoothUpdateVisualOptimization) == 0x001198, "Member 'UDBDCharacterMovementComponent::_significanceMaxRefreshRateForSmoothUpdateVisualOptimization' has a wrong offset!");
static_assert(offsetof(UDBDCharacterMovementComponent, _forceUseDropStaggerFix) == 0x001238, "Member 'UDBDCharacterMovementComponent::_forceUseDropStaggerFix' has a wrong offset!");
static_assert(offsetof(UDBDCharacterMovementComponent, _maxSpeedMultiplierCurvesToRemoveOnTheServer) == 0x001250, "Member 'UDBDCharacterMovementComponent::_maxSpeedMultiplierCurvesToRemoveOnTheServer' has a wrong offset!");
static_assert(offsetof(UDBDCharacterMovementComponent, _velocityAdditiveStrategy) == 0x001380, "Member 'UDBDCharacterMovementComponent::_velocityAdditiveStrategy' has a wrong offset!");
static_assert(offsetof(UDBDCharacterMovementComponent, _inputAccelerationConstraintStrategy) == 0x001388, "Member 'UDBDCharacterMovementComponent::_inputAccelerationConstraintStrategy' has a wrong offset!");
static_assert(offsetof(UDBDCharacterMovementComponent, _rotationStrategy) == 0x001390, "Member 'UDBDCharacterMovementComponent::_rotationStrategy' has a wrong offset!");
static_assert(offsetof(UDBDCharacterMovementComponent, _lookAtTarget) == 0x001398, "Member 'UDBDCharacterMovementComponent::_lookAtTarget' has a wrong offset!");

// Class DeadByDaylight.Generator
// 0x0370 (0x0718 - 0x03A8)
class AGenerator : public AInteractable
{
public:
	uint8                                         Pad_3A8[0x8];                                      // 0x03A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          Activated;                                         // 0x03B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          WasASMCachePreWarmTriggered;                       // 0x03B1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsPlaySkillcheckAesthetic;                         // 0x03B2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B3[0x5];                                      // 0x03B3(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveLinearColor*                      KillerOutlineFadeCurve;                            // 0x03B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NativePercentComplete;                             // 0x03C0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C4[0x4];                                      // 0x03C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnGeneratorRepaired;                               // 0x03C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnGeneratorRepairedBySurvivor;                     // 0x03D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnIsDamagedChanged;                                // 0x03E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_3F8[0x48];                                     // 0x03F8(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	class UGeneratorDamageComponent*              _generatorDamageComponent;                         // 0x0440(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          FireLevelScoreEventOnFix;                          // 0x0448(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_449[0x7];                                      // 0x0449(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, struct FTransform>          _activatedTopLightsTransformMap;                   // 0x0450(0x0050)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	class USceneComponent*                        _leftInteractionSceneComponent;                    // 0x04A0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        _rightInteractionSceneComponent;                   // 0x04A8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        _frontInteractionSceneComponent;                   // 0x04B0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        _backInteractionSceneComponent;                    // 0x04B8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAIPerceptionStimuliSourceComponent*    _perceptionStimuliComponent;                       // 0x04C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDischargeUntilThresholdIsReachedComponent* _regressChargeUntilThresholdIsReached;             // 0x04C8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _regressionSpeedWhileDamaged;                      // 0x04D0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4F8[0x1C];                                     // 0x04F8(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           _repairSemanticTag;                                // 0x0514(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_520[0x48];                                     // 0x0520(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _isBlocked;                                        // 0x0568(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isBlockedFromCharging;                            // 0x0569(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_56A[0x6];                                      // 0x056A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class UObject*>                          _blockingSources;                                  // 0x0570(0x0050)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5C0[0x30];                                     // 0x05C0(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class UChargeableComponent*                   _generatorCharge;                                  // 0x05F0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FPlayerFloatTuple>              _playerStartTimes;                                 // 0x05F8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_608[0x10];                                     // 0x0608(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _isAutoCompleted;                                  // 0x0618(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isOvercharged;                                    // 0x0619(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_61A[0x6];                                      // 0x061A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UCoopRepairTracker*                     _coopRepairTracker;                                // 0x0620(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_628[0x14];                                     // 0x0628(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _VFX_LightDistanceDefault;                         // 0x063C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_640[0x60];                                     // 0x0640(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UInteractionDefinition*>         _damagingInteractions;                             // 0x06A0(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6B0[0x28];                                     // 0x06B0(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ADBDPlayer*>                     _authority_cachedInteractingPlayersOnCompletion;   // 0x06D8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _defaultImmediateRegressionPercentage;             // 0x06E8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_710[0x8];                                      // 0x0710(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddDamagingInteraction(class UInteractionDefinition* Interaction);
	void AddPlayerStartTime(class ADBDPlayer* Player, float Starttime);
	void Authority_AddBlockingSource(const class UObject* Source);
	void Authority_AddTimedBlockingSource(const class UObject* Source, const float blockingTime);
	void Authority_OnChargeApplied(float IndividualChargeAmount, float TotalChargeAmount, class AActor* ChargeInstigator, bool WasCoop, float DeltaTime);
	void Authority_OnChargeChanged(class UChargeableComponent* ChargeableComponent, float PercentCompletionChange, float TotalPercentComplete);
	void Authority_RemoveBlockingSource(const class UObject* Source);
	void Authority_RepairDamage(class ADBDPlayer* RepairedBy);
	void Authority_SetRepaired(const bool ShowGeneratorCloneLoudNoise, const bool IsAutoCompleted);
	void BroadcastIsDamagedChangedEvent(class ADBDPlayer* Player);
	void DisableInaccessibleInteractors();
	bool GetIsBlockedFromCharging();
	void Multicast_OnRepaired(const bool ShowGeneratorCloneLoudNoise, const bool IsAutoCompleted, const int32 UpdatedRemainingGeneratorCount);
	void Multicast_PlayFailSparksFX(class ADBDPlayer* Player, bool Explode);
	void NotifyRepairFinish(const class ADBDPlayer* Player, class UInteractor* Interactor);
	void NotifyRepairStart(const class ADBDPlayer* Player);
	void OnBlockingStatusChanged(const bool IsBlocked);
	void OnCaptureProbeSecondState();
	void OnChargeChanged(class UChargeableComponent* ChargeableComponent, float Percent);
	void OnEscapeDoorActivated();
	void OnPreWarmASMCache();
	void OnRegressionStateChanged(const bool Regressing, class ADBDPlayer* LastDamageChangeSource);
	void OnRep_IsBlocked();
	void OnRepairedBP(const bool ShowGeneratorCloneLoudNoise, const bool IsAutoCompleted);
	void OnResetGenerator();
	void OnUpdateChargeProgress(float NewPercentComplete);
	void PlayFailSparksFX(class ADBDPlayer* InteractingPlayer, bool Explode);
	int32 PostAkEvent(class UAkAudioEvent* AkEvent, int32 CallbackMask, const TDelegate<void(EAkCallbackType CallbackType, class UAkCallbackInfo* CallbackInfo)>& PostEventCallback);
	void RemovePlayerStartTime(const class ADBDPlayer* Player);
	void ResetGenerator();
	void SetComplete(bool Complete);
	void SetFireLevelScoreEventOnFix(bool Param_FireLevelScoreEventOnFix);
	void SetIsAutoCompleted(const bool IsAutoCompleted);
	void SetIsBlockedFromCharging(bool IsBlockedFromCharging);
	void SetIsOvercharged(const bool Overcharged);
	void SpawnBloodEffectToSocket(const class FName Param_Name);
	void StopDischarge();
	void TriggerSkillCheck(class ADBDPlayer* InstigatingPlayer);
	void TriggerSkillCheckFailureLoudNoise(class ADBDPlayer* InstigatingPlayer);
	void VFXClampTopActivationSingleLight(float Distance, class FName ParameterName);

	void ActivateTeleportGeneratorIndicator(bool Activate) const;
	void Authority_CancelRepairInteractions(const TArray<class ADBDPlayer*>& Repairers) const;
	void BroadcastGeneratorRepairedBySurvivor(class ADBDPlayer* RepairingSurvivor) const;
	bool CanSurvivorReactToBlockingEntity(const class ACamperPlayer* Survivor) const;
	float GetChargePercentComplete() const;
	class UAkComponent* GetGeneratorAudioComponent() const;
	class UChargeableComponent* GetGeneratorChargeComponent() const;
	class UGeneratorDamageComponent* GetGeneratorDamageComponent() const;
	bool GetIsAutoCompleted() const;
	float GetPlayerStartTime(const class ADBDPlayer* Player) const;
	const TArray<struct FPlayerFloatTuple> GetPlayerStartTimes() const;
	TArray<class ADBDPlayer*> GetRepairers() const;
	float GetRepairPercentComplete() const;
	class USkeletalMeshComponent* GetSkeletalMesh() const;
	bool IsBeingDamagedByKiller() const;
	bool IsBeingRepaired() const;
	bool IsBlocked() const;
	bool IsRepaired() const;
	bool ShouldDoOverchargeSkillcheck() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Generator">();
	}
	static class AGenerator* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGenerator>();
	}
};
static_assert(alignof(AGenerator) == 0x000008, "Wrong alignment on AGenerator");
static_assert(sizeof(AGenerator) == 0x000718, "Wrong size on AGenerator");
static_assert(offsetof(AGenerator, Activated) == 0x0003B0, "Member 'AGenerator::Activated' has a wrong offset!");
static_assert(offsetof(AGenerator, WasASMCachePreWarmTriggered) == 0x0003B1, "Member 'AGenerator::WasASMCachePreWarmTriggered' has a wrong offset!");
static_assert(offsetof(AGenerator, IsPlaySkillcheckAesthetic) == 0x0003B2, "Member 'AGenerator::IsPlaySkillcheckAesthetic' has a wrong offset!");
static_assert(offsetof(AGenerator, KillerOutlineFadeCurve) == 0x0003B8, "Member 'AGenerator::KillerOutlineFadeCurve' has a wrong offset!");
static_assert(offsetof(AGenerator, NativePercentComplete) == 0x0003C0, "Member 'AGenerator::NativePercentComplete' has a wrong offset!");
static_assert(offsetof(AGenerator, OnGeneratorRepaired) == 0x0003C8, "Member 'AGenerator::OnGeneratorRepaired' has a wrong offset!");
static_assert(offsetof(AGenerator, OnGeneratorRepairedBySurvivor) == 0x0003D8, "Member 'AGenerator::OnGeneratorRepairedBySurvivor' has a wrong offset!");
static_assert(offsetof(AGenerator, OnIsDamagedChanged) == 0x0003E8, "Member 'AGenerator::OnIsDamagedChanged' has a wrong offset!");
static_assert(offsetof(AGenerator, _generatorDamageComponent) == 0x000440, "Member 'AGenerator::_generatorDamageComponent' has a wrong offset!");
static_assert(offsetof(AGenerator, FireLevelScoreEventOnFix) == 0x000448, "Member 'AGenerator::FireLevelScoreEventOnFix' has a wrong offset!");
static_assert(offsetof(AGenerator, _activatedTopLightsTransformMap) == 0x000450, "Member 'AGenerator::_activatedTopLightsTransformMap' has a wrong offset!");
static_assert(offsetof(AGenerator, _leftInteractionSceneComponent) == 0x0004A0, "Member 'AGenerator::_leftInteractionSceneComponent' has a wrong offset!");
static_assert(offsetof(AGenerator, _rightInteractionSceneComponent) == 0x0004A8, "Member 'AGenerator::_rightInteractionSceneComponent' has a wrong offset!");
static_assert(offsetof(AGenerator, _frontInteractionSceneComponent) == 0x0004B0, "Member 'AGenerator::_frontInteractionSceneComponent' has a wrong offset!");
static_assert(offsetof(AGenerator, _backInteractionSceneComponent) == 0x0004B8, "Member 'AGenerator::_backInteractionSceneComponent' has a wrong offset!");
static_assert(offsetof(AGenerator, _perceptionStimuliComponent) == 0x0004C0, "Member 'AGenerator::_perceptionStimuliComponent' has a wrong offset!");
static_assert(offsetof(AGenerator, _regressChargeUntilThresholdIsReached) == 0x0004C8, "Member 'AGenerator::_regressChargeUntilThresholdIsReached' has a wrong offset!");
static_assert(offsetof(AGenerator, _regressionSpeedWhileDamaged) == 0x0004D0, "Member 'AGenerator::_regressionSpeedWhileDamaged' has a wrong offset!");
static_assert(offsetof(AGenerator, _repairSemanticTag) == 0x000514, "Member 'AGenerator::_repairSemanticTag' has a wrong offset!");
static_assert(offsetof(AGenerator, _isBlocked) == 0x000568, "Member 'AGenerator::_isBlocked' has a wrong offset!");
static_assert(offsetof(AGenerator, _isBlockedFromCharging) == 0x000569, "Member 'AGenerator::_isBlockedFromCharging' has a wrong offset!");
static_assert(offsetof(AGenerator, _blockingSources) == 0x000570, "Member 'AGenerator::_blockingSources' has a wrong offset!");
static_assert(offsetof(AGenerator, _generatorCharge) == 0x0005F0, "Member 'AGenerator::_generatorCharge' has a wrong offset!");
static_assert(offsetof(AGenerator, _playerStartTimes) == 0x0005F8, "Member 'AGenerator::_playerStartTimes' has a wrong offset!");
static_assert(offsetof(AGenerator, _isAutoCompleted) == 0x000618, "Member 'AGenerator::_isAutoCompleted' has a wrong offset!");
static_assert(offsetof(AGenerator, _isOvercharged) == 0x000619, "Member 'AGenerator::_isOvercharged' has a wrong offset!");
static_assert(offsetof(AGenerator, _coopRepairTracker) == 0x000620, "Member 'AGenerator::_coopRepairTracker' has a wrong offset!");
static_assert(offsetof(AGenerator, _VFX_LightDistanceDefault) == 0x00063C, "Member 'AGenerator::_VFX_LightDistanceDefault' has a wrong offset!");
static_assert(offsetof(AGenerator, _damagingInteractions) == 0x0006A0, "Member 'AGenerator::_damagingInteractions' has a wrong offset!");
static_assert(offsetof(AGenerator, _authority_cachedInteractingPlayersOnCompletion) == 0x0006D8, "Member 'AGenerator::_authority_cachedInteractingPlayersOnCompletion' has a wrong offset!");
static_assert(offsetof(AGenerator, _defaultImmediateRegressionPercentage) == 0x0006E8, "Member 'AGenerator::_defaultImmediateRegressionPercentage' has a wrong offset!");

// Class DeadByDaylight.FirstPersonViewComponent
// 0x0048 (0x00F0 - 0x00A8)
class UFirstPersonViewComponent : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x28];                                      // 0x00A8(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  _activatingTagsForThirdPerson;                     // 0x00D0(0x0020)(Edit, NativeAccessSpecifierPrivate)

public:
	void OnIntroCompleted();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FirstPersonViewComponent">();
	}
	static class UFirstPersonViewComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFirstPersonViewComponent>();
	}
};
static_assert(alignof(UFirstPersonViewComponent) == 0x000008, "Wrong alignment on UFirstPersonViewComponent");
static_assert(sizeof(UFirstPersonViewComponent) == 0x0000F0, "Wrong size on UFirstPersonViewComponent");
static_assert(offsetof(UFirstPersonViewComponent, _activatingTagsForThirdPerson) == 0x0000D0, "Member 'UFirstPersonViewComponent::_activatingTagsForThirdPerson' has a wrong offset!");

// Class DeadByDaylight.DBDEasyAntiCheat
// 0x0020 (0x0050 - 0x0030)
class UDBDEasyAntiCheat : public UObject
{
public:
	uint8                                         Pad_30[0x20];                                      // 0x0030(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDEasyAntiCheat">();
	}
	static class UDBDEasyAntiCheat* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDEasyAntiCheat>();
	}
};
static_assert(alignof(UDBDEasyAntiCheat) == 0x000008, "Wrong alignment on UDBDEasyAntiCheat");
static_assert(sizeof(UDBDEasyAntiCheat) == 0x000050, "Wrong size on UDBDEasyAntiCheat");

// Class DeadByDaylight.DBDEasyAntiCheatEnable
// 0x0000 (0x0050 - 0x0050)
class UDBDEasyAntiCheatEnable : public UDBDEasyAntiCheat
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDEasyAntiCheatEnable">();
	}
	static class UDBDEasyAntiCheatEnable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDEasyAntiCheatEnable>();
	}
};
static_assert(alignof(UDBDEasyAntiCheatEnable) == 0x000008, "Wrong alignment on UDBDEasyAntiCheatEnable");
static_assert(sizeof(UDBDEasyAntiCheatEnable) == 0x000050, "Wrong size on UDBDEasyAntiCheatEnable");

// Class DeadByDaylight.DBDEasyAntiCheatClient
// 0x0070 (0x00C0 - 0x0050)
class UDBDEasyAntiCheatClient : public UDBDEasyAntiCheatEnable
{
public:
	uint8                                         Pad_50[0x70];                                      // 0x0050(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDEasyAntiCheatClient">();
	}
	static class UDBDEasyAntiCheatClient* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDEasyAntiCheatClient>();
	}
};
static_assert(alignof(UDBDEasyAntiCheatClient) == 0x000008, "Wrong alignment on UDBDEasyAntiCheatClient");
static_assert(sizeof(UDBDEasyAntiCheatClient) == 0x0000C0, "Wrong size on UDBDEasyAntiCheatClient");

// Class DeadByDaylight.GameEventDispatcher
// 0x00B0 (0x00E8 - 0x0038)
class UGameEventDispatcher final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UOngoingGameEvent*>              _ongoingEvents;                                    // 0x0088(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_98[0x50];                                      // 0x0098(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_AccumulateOngoingGameEvent(const struct FGameplayTag& GameEventType, const struct FGameEventData& GameEventData, float OngoingWaitTime);
	void Authority_RemotelyDispatch(const struct FGameplayTag& GameEventType, const struct FGameEventData& GameEventData);
	void LocallyDispatch(const struct FGameplayTag& GameEventType, const struct FGameEventData& GameEventData);
	void RegisterListener(const struct FGameEventDispatcherHandleBP& GameEventDispatcherHandle);
	void RemotelyDispatch(const struct FGameplayTag& GameEventType, const struct FGameEventData& GameEventData);
	void UnregisterListener(const struct FGameEventDispatcherHandleBP& GameEventDispatcherHandle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameEventDispatcher">();
	}
	static class UGameEventDispatcher* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameEventDispatcher>();
	}
};
static_assert(alignof(UGameEventDispatcher) == 0x000008, "Wrong alignment on UGameEventDispatcher");
static_assert(sizeof(UGameEventDispatcher) == 0x0000E8, "Wrong size on UGameEventDispatcher");
static_assert(offsetof(UGameEventDispatcher, _ongoingEvents) == 0x000088, "Member 'UGameEventDispatcher::_ongoingEvents' has a wrong offset!");

// Class DeadByDaylight.IterativeWeightAdjustmentStrategy
// 0x0000 (0x0030 - 0x0030)
class UIterativeWeightAdjustmentStrategy : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IterativeWeightAdjustmentStrategy">();
	}
	static class UIterativeWeightAdjustmentStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIterativeWeightAdjustmentStrategy>();
	}
};
static_assert(alignof(UIterativeWeightAdjustmentStrategy) == 0x000008, "Wrong alignment on UIterativeWeightAdjustmentStrategy");
static_assert(sizeof(UIterativeWeightAdjustmentStrategy) == 0x000030, "Wrong size on UIterativeWeightAdjustmentStrategy");

// Class DeadByDaylight.ActivationTimerElapsedCooldownElapsedIconStrategy
// 0x0000 (0x0038 - 0x0038)
class UActivationTimerElapsedCooldownElapsedIconStrategy final : public UBasePerkIconStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActivationTimerElapsedCooldownElapsedIconStrategy">();
	}
	static class UActivationTimerElapsedCooldownElapsedIconStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActivationTimerElapsedCooldownElapsedIconStrategy>();
	}
};
static_assert(alignof(UActivationTimerElapsedCooldownElapsedIconStrategy) == 0x000008, "Wrong alignment on UActivationTimerElapsedCooldownElapsedIconStrategy");
static_assert(sizeof(UActivationTimerElapsedCooldownElapsedIconStrategy) == 0x000038, "Wrong size on UActivationTimerElapsedCooldownElapsedIconStrategy");

// Class DeadByDaylight.ObjectPlacerComponent
// 0x0070 (0x0330 - 0x02C0)
class UObjectPlacerComponent : public USceneComponent
{
public:
	class UObjectPlacementUpdateStrategy*         _objectPlacementUpdateStrategy;                    // 0x02C0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoClear, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UObjectPlacementValidationStrategy*     _objectPlacementValidationStrategy;                // 0x02C8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoClear, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   _objectMesh;                                       // 0x02D0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _meshOffsetZ;                                      // 0x02D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _socketName;                                       // 0x02DC(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _indicatorOffsetY;                                 // 0x02E8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _indicatorOffsetX;                                 // 0x02EC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   _itemObjectId;                                     // 0x02F0(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _showIndicator;                                    // 0x02FC(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _stayActiveWhileItemInUse;                         // 0x02FD(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _hideIndicatorDuringAttack;                        // 0x02FE(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2FF[0x1];                                      // 0x02FF(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameplayTag>                   _tagsPreventingObjectPlacement;                    // 0x0300(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_310[0x20];                                     // 0x0310(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActivateObjectPlacement(bool Active);
	void SetHideIndicatorDuringAttack(bool Enable);
	void SetIndicatorOffsetX(float X);
	void SetIndicatorOffsetY(float Y);
	void SetMeshOffsetZ(float Z);
	void SetObjectMesh(class UStaticMeshComponent* ObjectMesh);
	void SetShowIndicator(bool NewValue);

	struct FVector GetObjectPlacementLocation() const;
	struct FRotator GetObjectPlacementRotation() const;
	bool IsPlacementValid() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ObjectPlacerComponent">();
	}
	static class UObjectPlacerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UObjectPlacerComponent>();
	}
};
static_assert(alignof(UObjectPlacerComponent) == 0x000010, "Wrong alignment on UObjectPlacerComponent");
static_assert(sizeof(UObjectPlacerComponent) == 0x000330, "Wrong size on UObjectPlacerComponent");
static_assert(offsetof(UObjectPlacerComponent, _objectPlacementUpdateStrategy) == 0x0002C0, "Member 'UObjectPlacerComponent::_objectPlacementUpdateStrategy' has a wrong offset!");
static_assert(offsetof(UObjectPlacerComponent, _objectPlacementValidationStrategy) == 0x0002C8, "Member 'UObjectPlacerComponent::_objectPlacementValidationStrategy' has a wrong offset!");
static_assert(offsetof(UObjectPlacerComponent, _objectMesh) == 0x0002D0, "Member 'UObjectPlacerComponent::_objectMesh' has a wrong offset!");
static_assert(offsetof(UObjectPlacerComponent, _meshOffsetZ) == 0x0002D8, "Member 'UObjectPlacerComponent::_meshOffsetZ' has a wrong offset!");
static_assert(offsetof(UObjectPlacerComponent, _socketName) == 0x0002DC, "Member 'UObjectPlacerComponent::_socketName' has a wrong offset!");
static_assert(offsetof(UObjectPlacerComponent, _indicatorOffsetY) == 0x0002E8, "Member 'UObjectPlacerComponent::_indicatorOffsetY' has a wrong offset!");
static_assert(offsetof(UObjectPlacerComponent, _indicatorOffsetX) == 0x0002EC, "Member 'UObjectPlacerComponent::_indicatorOffsetX' has a wrong offset!");
static_assert(offsetof(UObjectPlacerComponent, _itemObjectId) == 0x0002F0, "Member 'UObjectPlacerComponent::_itemObjectId' has a wrong offset!");
static_assert(offsetof(UObjectPlacerComponent, _showIndicator) == 0x0002FC, "Member 'UObjectPlacerComponent::_showIndicator' has a wrong offset!");
static_assert(offsetof(UObjectPlacerComponent, _stayActiveWhileItemInUse) == 0x0002FD, "Member 'UObjectPlacerComponent::_stayActiveWhileItemInUse' has a wrong offset!");
static_assert(offsetof(UObjectPlacerComponent, _hideIndicatorDuringAttack) == 0x0002FE, "Member 'UObjectPlacerComponent::_hideIndicatorDuringAttack' has a wrong offset!");
static_assert(offsetof(UObjectPlacerComponent, _tagsPreventingObjectPlacement) == 0x000300, "Member 'UObjectPlacerComponent::_tagsPreventingObjectPlacement' has a wrong offset!");

// Class DeadByDaylight.DefaultOutlineUpdateStrategy
// 0x0020 (0x00F0 - 0x00D0)
class UDefaultOutlineUpdateStrategy : public UOutlineUpdateStrategy
{
public:
	struct FLinearColor                           _revealedColorToSurvivor;                          // 0x00D0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           _revealedColorToKiller;                            // 0x00E0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DefaultOutlineUpdateStrategy">();
	}
	static class UDefaultOutlineUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDefaultOutlineUpdateStrategy>();
	}
};
static_assert(alignof(UDefaultOutlineUpdateStrategy) == 0x000008, "Wrong alignment on UDefaultOutlineUpdateStrategy");
static_assert(sizeof(UDefaultOutlineUpdateStrategy) == 0x0000F0, "Wrong size on UDefaultOutlineUpdateStrategy");
static_assert(offsetof(UDefaultOutlineUpdateStrategy, _revealedColorToSurvivor) == 0x0000D0, "Member 'UDefaultOutlineUpdateStrategy::_revealedColorToSurvivor' has a wrong offset!");
static_assert(offsetof(UDefaultOutlineUpdateStrategy, _revealedColorToKiller) == 0x0000E0, "Member 'UDefaultOutlineUpdateStrategy::_revealedColorToKiller' has a wrong offset!");

// Class DeadByDaylight.HatchOutlineUpdateStrategy
// 0x0000 (0x00F0 - 0x00F0)
class UHatchOutlineUpdateStrategy final : public UDefaultOutlineUpdateStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HatchOutlineUpdateStrategy">();
	}
	static class UHatchOutlineUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHatchOutlineUpdateStrategy>();
	}
};
static_assert(alignof(UHatchOutlineUpdateStrategy) == 0x000008, "Wrong alignment on UHatchOutlineUpdateStrategy");
static_assert(sizeof(UHatchOutlineUpdateStrategy) == 0x0000F0, "Wrong size on UHatchOutlineUpdateStrategy");

// Class DeadByDaylight.StationaryPointLightComponent
// 0x0000 (0x04E0 - 0x04E0)
class UStationaryPointLightComponent final : public UPointLightComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StationaryPointLightComponent">();
	}
	static class UStationaryPointLightComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStationaryPointLightComponent>();
	}
};
static_assert(alignof(UStationaryPointLightComponent) == 0x000010, "Wrong alignment on UStationaryPointLightComponent");
static_assert(sizeof(UStationaryPointLightComponent) == 0x0004E0, "Wrong size on UStationaryPointLightComponent");

// Class DeadByDaylight.CrossPromoCampaignsSubsystem
// 0x0058 (0x0090 - 0x0038)
class UCrossPromoCampaignsSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x58];                                      // 0x0038(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrossPromoCampaignsSubsystem">();
	}
	static class UCrossPromoCampaignsSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrossPromoCampaignsSubsystem>();
	}
};
static_assert(alignof(UCrossPromoCampaignsSubsystem) == 0x000008, "Wrong alignment on UCrossPromoCampaignsSubsystem");
static_assert(sizeof(UCrossPromoCampaignsSubsystem) == 0x000090, "Wrong size on UCrossPromoCampaignsSubsystem");

// Class DeadByDaylight.PowerWidgetBundlePresentationComponent
// 0x0060 (0x0108 - 0x00A8)
class UPowerWidgetBundlePresentationComponent : public UActorComponent
{
public:
	TArray<struct FGameplayTag>                   _powerWidgetPriorities;                            // 0x00A8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B8[0x50];                                      // 0x00B8(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PowerWidgetBundlePresentationComponent">();
	}
	static class UPowerWidgetBundlePresentationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPowerWidgetBundlePresentationComponent>();
	}
};
static_assert(alignof(UPowerWidgetBundlePresentationComponent) == 0x000008, "Wrong alignment on UPowerWidgetBundlePresentationComponent");
static_assert(sizeof(UPowerWidgetBundlePresentationComponent) == 0x000108, "Wrong size on UPowerWidgetBundlePresentationComponent");
static_assert(offsetof(UPowerWidgetBundlePresentationComponent, _powerWidgetPriorities) == 0x0000A8, "Member 'UPowerWidgetBundlePresentationComponent::_powerWidgetPriorities' has a wrong offset!");

// Class DeadByDaylight.AudioMultipleEmitterComponent
// 0x0010 (0x0550 - 0x0540)
class UAudioMultipleEmitterComponent final : public UAkComponent
{
public:
	TArray<class UActorComponent*>                EmitterActorsComponents;                           // 0x0538(0x0010)(Edit, ExportObject, ZeroConstructor, EditConst, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_548[0x8];                                      // 0x0548(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AudioMultipleEmitterComponent">();
	}
	static class UAudioMultipleEmitterComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAudioMultipleEmitterComponent>();
	}
};
static_assert(alignof(UAudioMultipleEmitterComponent) == 0x000010, "Wrong alignment on UAudioMultipleEmitterComponent");
static_assert(sizeof(UAudioMultipleEmitterComponent) == 0x000550, "Wrong size on UAudioMultipleEmitterComponent");
static_assert(offsetof(UAudioMultipleEmitterComponent, EmitterActorsComponents) == 0x000538, "Member 'UAudioMultipleEmitterComponent::EmitterActorsComponents' has a wrong offset!");

// Class DeadByDaylight.BlindableBaseComponent
// 0x01B8 (0x0260 - 0x00A8)
class UBlindableBaseComponent : public UActorComponent
{
public:
	uint8                                         Pad_A8[0xA8];                                      // 0x00A8(0x00A8)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _isBlinded;                                        // 0x0150(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_151[0x7];                                      // 0x0151(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTagStateBool                          _isBeingBlinded;                                   // 0x0158(0x0048)(Net, Transient, Protected, NativeAccessSpecifierProtected)
	class UChargeableComponent*                   _chargeableComponent;                              // 0x01A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class AActor*, TScriptInterface<class IBlindingEffectorInterface>> _authority_blindingEffectors;                      // 0x01A8(0x0050)(Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1F8[0x68];                                     // 0x01F8(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_AddBlindingEffector(TScriptInterface<class IBlindingEffectorInterface> Effector);
	void Authority_Blinded(EBlindType blindType, float BlindnessDuration, class AActor* EffectorActor);
	void Authority_RemoveBlindingEffector(TScriptInterface<class IBlindingEffectorInterface> Effector);
	void OnChargeableCompletionPercentChanged(class UChargeableComponent* ChargeableComponent, float TotalPercentComplete);
	void OnRep_IsBlinded();
	void SetChargeable(class UChargeableComponent* Value);

	bool IsBlinded() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlindableBaseComponent">();
	}
	static class UBlindableBaseComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlindableBaseComponent>();
	}
};
static_assert(alignof(UBlindableBaseComponent) == 0x000008, "Wrong alignment on UBlindableBaseComponent");
static_assert(sizeof(UBlindableBaseComponent) == 0x000260, "Wrong size on UBlindableBaseComponent");
static_assert(offsetof(UBlindableBaseComponent, _isBlinded) == 0x000150, "Member 'UBlindableBaseComponent::_isBlinded' has a wrong offset!");
static_assert(offsetof(UBlindableBaseComponent, _isBeingBlinded) == 0x000158, "Member 'UBlindableBaseComponent::_isBeingBlinded' has a wrong offset!");
static_assert(offsetof(UBlindableBaseComponent, _chargeableComponent) == 0x0001A0, "Member 'UBlindableBaseComponent::_chargeableComponent' has a wrong offset!");
static_assert(offsetof(UBlindableBaseComponent, _authority_blindingEffectors) == 0x0001A8, "Member 'UBlindableBaseComponent::_authority_blindingEffectors' has a wrong offset!");

// Class DeadByDaylight.DBDSRComponent
// 0x0080 (0x0128 - 0x00A8)
class UDBDSRComponent : public UActorComponent
{
public:
	struct FGameplayTagContainer                  _gameEventTags;                                    // 0x00A8(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	EDBDSRState                                   _state;                                            // 0x00C8(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C9[0x5F];                                      // 0x00C9(0x005F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_State();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDSRComponent">();
	}
	static class UDBDSRComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDSRComponent>();
	}
};
static_assert(alignof(UDBDSRComponent) == 0x000008, "Wrong alignment on UDBDSRComponent");
static_assert(sizeof(UDBDSRComponent) == 0x000128, "Wrong size on UDBDSRComponent");
static_assert(offsetof(UDBDSRComponent, _gameEventTags) == 0x0000A8, "Member 'UDBDSRComponent::_gameEventTags' has a wrong offset!");
static_assert(offsetof(UDBDSRComponent, _state) == 0x0000C8, "Member 'UDBDSRComponent::_state' has a wrong offset!");

// Class DeadByDaylight.ESSRComponent
// 0x0020 (0x0148 - 0x0128)
class UESSRComponent : public UDBDSRComponent
{
public:
	TArray<struct FCharacterOverrideDropdown>     _eligibleCharacters;                               // 0x0128(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TArray<struct FCharmDropdown>                 _requiredCharms;                                   // 0x0138(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ESSRComponent">();
	}
	static class UESSRComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UESSRComponent>();
	}
};
static_assert(alignof(UESSRComponent) == 0x000008, "Wrong alignment on UESSRComponent");
static_assert(sizeof(UESSRComponent) == 0x000148, "Wrong size on UESSRComponent");
static_assert(offsetof(UESSRComponent, _eligibleCharacters) == 0x000128, "Member 'UESSRComponent::_eligibleCharacters' has a wrong offset!");
static_assert(offsetof(UESSRComponent, _requiredCharms) == 0x000138, "Member 'UESSRComponent::_requiredCharms' has a wrong offset!");

// Class DeadByDaylight.DSQuestEventsHelper
// 0x0000 (0x0030 - 0x0030)
class UDSQuestEventsHelper final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DSQuestEventsHelper">();
	}
	static class UDSQuestEventsHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDSQuestEventsHelper>();
	}
};
static_assert(alignof(UDSQuestEventsHelper) == 0x000008, "Wrong alignment on UDSQuestEventsHelper");
static_assert(sizeof(UDSQuestEventsHelper) == 0x000030, "Wrong size on UDSQuestEventsHelper");

// Class DeadByDaylight.AttackableComponent
// 0x0000 (0x00A8 - 0x00A8)
class UAttackableComponent : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AttackableComponent">();
	}
	static class UAttackableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAttackableComponent>();
	}
};
static_assert(alignof(UAttackableComponent) == 0x000008, "Wrong alignment on UAttackableComponent");
static_assert(sizeof(UAttackableComponent) == 0x0000A8, "Wrong size on UAttackableComponent");

// Class DeadByDaylight.DBDGameInstance
// 0x0898 (0x0AB0 - 0x0218)
class UDBDGameInstance : public UGameInstance
{
public:
	uint8                                         Pad_218[0x48];                                     // 0x0218(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class URegionFinder>              RegionClass;                                       // 0x0260(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoClear, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UShopmanager>               ShopManagerClass;                                  // 0x0268(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AOfferingSequenceManager>   OfferingSequenceManagerClass;                      // 0x0270(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UFriendManager>             FriendManagerClass;                                // 0x0278(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataAsset*                             AchievementsDataAsset;                             // 0x0280(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameEventTracker*                      GameEventTracker;                                  // 0x0288(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDBDKeyDisplayInfo*                     KeyDisplayInfo;                                    // 0x0290(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          LeaveGameRequested;                                // 0x0298(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_299[0x7];                                      // 0x0299(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UPlayerProfileDAL*                      PlayerProfileDAL;                                  // 0x02A0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGenerationParams                      TrialGenerationParameters;                         // 0x02A8(0x0038)(Transient, NativeAccessSpecifierPublic)
	class FString                                 PremadeMap;                                        // 0x02E0(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FForceSpawnTileData>            ForceSpawnTileData;                                // 0x02F0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_300[0x20];                                     // 0x0300(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class AOfferingSequenceManager*               OfferingSequence;                                  // 0x0320(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FString, struct FParadiseData>     ParadiseData;                                      // 0x0328(0x0050)(NativeAccessSpecifierPublic)
	bool                                          PlayerProfileLoadFailed;                           // 0x0378(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_379[0x7];                                      // 0x0379(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UNewsContentManager*                    NewsContentManager;                                // 0x0380(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UContentScheduleManager*                ContentScheduleManager;                            // 0x0388(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCharacterProgressionManager*           CharacterProgressionManager;                       // 0x0390(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AuthOrEACErrorAdditionalInfo;                      // 0x0398(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasServerLeftMatch;                                // 0x03A8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasWrittenGameEndStats;                            // 0x03A9(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3AA[0x6];                                      // 0x03AA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UFearMarketManager*                     FearMarketManager;                                 // 0x03B0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UShopmanager*                           Shopmanager;                                       // 0x03B8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFriendManager*                         FriendManager;                                     // 0x03C0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWalletHandler*                         WalletHandler;                                     // 0x03C8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TutorialRequesterName;                             // 0x03D0(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3DC[0x4];                                      // 0x03DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UControllerPairingManager*              ControllerPairingManager;                          // 0x03E0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E8[0xE8];                                     // 0x03E8(0x00E8)(Fixing Size After Last Property [ Dumper-7 ])
	class UChunkingManager*                       ChunkingManager;                                   // 0x04D0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPlayerDisconnect;                                // 0x04D8(0x0010)(Edit, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_4E8[0x150];                                    // 0x04E8(0x0150)(Fixing Size After Last Property [ Dumper-7 ])
	class UAssetLibraryManager*                   _assetLibraryManager;                              // 0x0638(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftClassPtr<class UClass>                   _bloodwebManagerClass;                             // 0x0640(0x0038)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOnlineTransactionServiceComponent*     _onlineTransactionService;                         // 0x0678(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_680[0x138];                                    // 0x0680(0x0138)(Fixing Size After Last Property [ Dumper-7 ])
	class UDBDPersistentData*                     _persistentData;                                   // 0x07B8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPlayerDataStorageFacade*               _playerDataFacade;                                 // 0x07C0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URankManager*                           _rankManager;                                      // 0x07C8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDBDPlayerLevelManager*                 _playerLevelManager;                               // 0x07D0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPlayerNameRegistration*                _playerNameRegistration;                           // 0x07D8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USpecialeventmanager*                   _specialEventManager;                              // 0x07E0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBonusPointEventsManager*               _bonusPointEventsManager;                          // 0x07E8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDBDTimeTravelManager*                  _timeTravelManager;                                // 0x07F0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UToastManager*                          _toastManager;                                     // 0x07F8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDBDSocialNotificationFactory*          _socialNotificationFactory;                        // 0x0800(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDBDPartyFacade*                        _partyFacade;                                      // 0x0808(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPenaltyTracker*                        _penaltyTracker;                                   // 0x0810(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_818[0x28];                                     // 0x0818(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class ULightingHelper*                        _ligthingHelper;                                   // 0x0840(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOfferingHandler*                       _offeringHandler;                                  // 0x0848(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_850[0x8];                                      // 0x0850(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UActorKnowledgeCollection*>      _actorKnowledgeCollections;                        // 0x0858(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class UMapActorDB*                            _mapActorDB;                                       // 0x0868(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UInteractionProficiency*>        _interactionProficiencies;                         // 0x0870(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class UDBDHud*                                _theHud;                                           // 0x0880(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_888[0x28];                                     // 0x0888(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class UBloodwebManager*                       _bloodwebManager;                                  // 0x08B0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPopupSequencer*                        _popupSequencer;                                   // 0x08B8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPopupFactory*                          _popupFactory;                                     // 0x08C0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDBDAuthentication*                     _auth;                                             // 0x08C8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDBDEasyAntiCheat*                      _eac;                                              // 0x08D0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8D8[0x98];                                     // 0x08D8(0x0098)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class UObject>>         _execObjects;                                      // 0x0970(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	bool                                          _networkFailureDetected;                           // 0x0980(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _networkConnectionMonitoringOnly;                  // 0x0981(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _achievementStatsUploadEnabled;                    // 0x0982(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isDisconnected;                                   // 0x0983(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isGamepadReconnected;                             // 0x0984(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isProfileOffline;                                 // 0x0985(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isAppSuspended;                                   // 0x0986(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isAppResumed;                                     // 0x0987(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isInvitationRejected;                             // 0x0988(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isAdditionalContentInstalled;                     // 0x0989(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isCloudInventoryInitialized;                      // 0x098A(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_98B[0x7D];                                     // 0x098B(0x007D)(Fixing Size After Last Property [ Dumper-7 ])
	class UOfferingEffectCollection*              _resultOfferingAndPerkEffects;                     // 0x0A08(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCinematicManager*                      _cinematicManager;                                 // 0x0A10(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USoftBanManager*                        _softBanManager;                                   // 0x0A18(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UConsentManager*                        _consentManager;                                   // 0x0A20(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOnlineSystemHandler*                   _onlineSystemHandler;                              // 0x0A28(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URegionFinder*                          _regionFinder;                                     // 0x0A30(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDecalSpawnerCollection*                _decalSpawnerCollection;                           // 0x0A38(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPrimitiveCollection*                   _characterClippingPrimitiveCollection;             // 0x0A40(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint32                                        LastProviderErrorCode;                             // 0x0A48(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EDisconnectErrors                             _disconnectError;                                  // 0x0A4C(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A4D[0xB];                                      // 0x0A4D(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	class UDateTimerUpdater*                      _dateTimerUpdater;                                 // 0x0A58(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A60[0x50];                                     // 0x0A60(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void ForceCloseGame();

	void AddActorKnowledgeCollection(class UActorKnowledgeCollection* Collection);
	void Authority_SimulatePerks(const TArray<class FName>& Perks, int32 Level);
	void BeginLoadingScreen(const class FString& MapName);
	void DBD_ApplyMist(const float FogModifier);
	void DBD_ApplyNoMist();
	void DBD_ChangeSteamOverlayPosition(int32 Position, int32 VerticalOffset, int32 HorizontalOffset);
	void DBD_CheckForNewContent(const class FString& DebugGameVersion, bool ForceDisplay);
	void DBD_DeleteLocalSaveFile();
	void DBD_DestroySteamInventory();
	void DBD_DisplayCurrentAchievementStat(class FName StatName);
	void DBD_DumpSessions();
	void DBD_ForceLoad();
	void DBD_ForceSave();
	void DBD_GetRegion();
	void DBD_PIXBeginCapture();
	void DBD_PIXEndCapture();
	void DBD_ResetCurrentAchievementStat(class FName StatName, bool AndUpload);
	void DBD_ResetCurrentAchievementStats(bool AndUpload, bool AndUpdateData);
	void DBD_ResetSaveData();
	void DBD_SetFearMarketDate(const class FString& DateString);
	void DBD_SetStatsUploadEnabled(bool Enabled);
	void DBD_TestDiceRoll(float BaseProbability, float MultiplicativeModifier, float AdditiveModifier);
	void DBD_TestRegion();
	void DBD_TestSaveFile(const class FString& Param_Name);
	void DBD_TestTickedDiceRoll(float BaseProbability, float Ticks, float MultiplicativeModifier, float AdditiveModifier);
	void DBD_ToggleLightingLoaded();
	void DBD_UpdateSteamInventory();
	void EndLoadingScreen(class UWorld* LoadedWorld);
	class ABaseSky* GetLevelLighting();
	class ULightingHelper* GetLightingHelper();
	class ULightingInterpolator* GetLightInterpolator();
	void GotoSplashScreen(bool ShowDefaultDialogueOnSplashScreen);
	void RemoveActorKnowledgeCollection(class UActorKnowledgeCollection* Collection);
	void SimulateOfferingSequence(const TArray<class FName>& Offerings, bool PlaySequence);
	void StartOfferingSequence();

	void DBD_PrintAudioConfig() const;
	class UBonusPointEventsManager* GetBonusPointEventsManager() const;
	class UPrimitiveCollection* GetCharacterClippingPrimitiveCollection() const;
	class FName GetCharacterDefaultItem(int32 InCharacterIndex) const;
	class UCinematicManager* GetCinematicManager() const;
	class UConsentManager* GetConsentManager() const;
	int32 GetDeadOrDisconnectedCampersCount(class ADBDPlayerState* Exception) const;
	class UDecalSpawnerCollection* GetDecalSpawnerCollection() const;
	class UDedicatedServerManager* GetDedicatedServerManager() const;
	class UInventoryHandler* GetInventoryHandler() const;
	class ULocalEventManager* GetLocalEventManager() const;
	class ADBDPlayer* GetLocallyControlledCharacter() const;
	class ULocalPlayer* GetLocalPlayer() const;
	class APlayerController* GetLocalPlayerController() const;
	class UMapActorDB* GetMapActorDB() const;
	int32 GetMaxSurvivorCount() const;
	class UDBDPlayerLevelManager* GetPlayerLevelManager() const;
	class UPlayerNameRegistration* GetPlayerNameRegistration() const;
	class URankManager* GetRankManager() const;
	class USoftBanManager* GetSoftBanManager() const;
	class USpecialeventmanager* GetSpecialEventManager() const;
	class UDBDTimeUtilities* GetTimeUtils() const;
	bool HasOfferingByType(EOfferingEffectType Type) const;
	bool HasOfferingOfType(EOfferingEffectType Type, int32 PlayerId, class FName Tag) const;
	bool IsActorKnown(const class ADBDPlayer* KnowledgePossessor, class AActor* PossiblyKnownActor) const;
	void OnTimeTravelComplete(bool Success, const class FString& Date) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDGameInstance">();
	}
	static class UDBDGameInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDGameInstance>();
	}
};
static_assert(alignof(UDBDGameInstance) == 0x000008, "Wrong alignment on UDBDGameInstance");
static_assert(sizeof(UDBDGameInstance) == 0x000AB0, "Wrong size on UDBDGameInstance");
static_assert(offsetof(UDBDGameInstance, RegionClass) == 0x000260, "Member 'UDBDGameInstance::RegionClass' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, ShopManagerClass) == 0x000268, "Member 'UDBDGameInstance::ShopManagerClass' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, OfferingSequenceManagerClass) == 0x000270, "Member 'UDBDGameInstance::OfferingSequenceManagerClass' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, FriendManagerClass) == 0x000278, "Member 'UDBDGameInstance::FriendManagerClass' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, AchievementsDataAsset) == 0x000280, "Member 'UDBDGameInstance::AchievementsDataAsset' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, GameEventTracker) == 0x000288, "Member 'UDBDGameInstance::GameEventTracker' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, KeyDisplayInfo) == 0x000290, "Member 'UDBDGameInstance::KeyDisplayInfo' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, LeaveGameRequested) == 0x000298, "Member 'UDBDGameInstance::LeaveGameRequested' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, PlayerProfileDAL) == 0x0002A0, "Member 'UDBDGameInstance::PlayerProfileDAL' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, TrialGenerationParameters) == 0x0002A8, "Member 'UDBDGameInstance::TrialGenerationParameters' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, PremadeMap) == 0x0002E0, "Member 'UDBDGameInstance::PremadeMap' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, ForceSpawnTileData) == 0x0002F0, "Member 'UDBDGameInstance::ForceSpawnTileData' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, OfferingSequence) == 0x000320, "Member 'UDBDGameInstance::OfferingSequence' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, ParadiseData) == 0x000328, "Member 'UDBDGameInstance::ParadiseData' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, PlayerProfileLoadFailed) == 0x000378, "Member 'UDBDGameInstance::PlayerProfileLoadFailed' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, NewsContentManager) == 0x000380, "Member 'UDBDGameInstance::NewsContentManager' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, ContentScheduleManager) == 0x000388, "Member 'UDBDGameInstance::ContentScheduleManager' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, CharacterProgressionManager) == 0x000390, "Member 'UDBDGameInstance::CharacterProgressionManager' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, AuthOrEACErrorAdditionalInfo) == 0x000398, "Member 'UDBDGameInstance::AuthOrEACErrorAdditionalInfo' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, HasServerLeftMatch) == 0x0003A8, "Member 'UDBDGameInstance::HasServerLeftMatch' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, HasWrittenGameEndStats) == 0x0003A9, "Member 'UDBDGameInstance::HasWrittenGameEndStats' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, FearMarketManager) == 0x0003B0, "Member 'UDBDGameInstance::FearMarketManager' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, Shopmanager) == 0x0003B8, "Member 'UDBDGameInstance::Shopmanager' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, FriendManager) == 0x0003C0, "Member 'UDBDGameInstance::FriendManager' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, WalletHandler) == 0x0003C8, "Member 'UDBDGameInstance::WalletHandler' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, TutorialRequesterName) == 0x0003D0, "Member 'UDBDGameInstance::TutorialRequesterName' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, ControllerPairingManager) == 0x0003E0, "Member 'UDBDGameInstance::ControllerPairingManager' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, ChunkingManager) == 0x0004D0, "Member 'UDBDGameInstance::ChunkingManager' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, OnPlayerDisconnect) == 0x0004D8, "Member 'UDBDGameInstance::OnPlayerDisconnect' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _assetLibraryManager) == 0x000638, "Member 'UDBDGameInstance::_assetLibraryManager' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _bloodwebManagerClass) == 0x000640, "Member 'UDBDGameInstance::_bloodwebManagerClass' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _onlineTransactionService) == 0x000678, "Member 'UDBDGameInstance::_onlineTransactionService' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _persistentData) == 0x0007B8, "Member 'UDBDGameInstance::_persistentData' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _playerDataFacade) == 0x0007C0, "Member 'UDBDGameInstance::_playerDataFacade' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _rankManager) == 0x0007C8, "Member 'UDBDGameInstance::_rankManager' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _playerLevelManager) == 0x0007D0, "Member 'UDBDGameInstance::_playerLevelManager' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _playerNameRegistration) == 0x0007D8, "Member 'UDBDGameInstance::_playerNameRegistration' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _specialEventManager) == 0x0007E0, "Member 'UDBDGameInstance::_specialEventManager' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _bonusPointEventsManager) == 0x0007E8, "Member 'UDBDGameInstance::_bonusPointEventsManager' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _timeTravelManager) == 0x0007F0, "Member 'UDBDGameInstance::_timeTravelManager' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _toastManager) == 0x0007F8, "Member 'UDBDGameInstance::_toastManager' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _socialNotificationFactory) == 0x000800, "Member 'UDBDGameInstance::_socialNotificationFactory' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _partyFacade) == 0x000808, "Member 'UDBDGameInstance::_partyFacade' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _penaltyTracker) == 0x000810, "Member 'UDBDGameInstance::_penaltyTracker' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _ligthingHelper) == 0x000840, "Member 'UDBDGameInstance::_ligthingHelper' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _offeringHandler) == 0x000848, "Member 'UDBDGameInstance::_offeringHandler' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _actorKnowledgeCollections) == 0x000858, "Member 'UDBDGameInstance::_actorKnowledgeCollections' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _mapActorDB) == 0x000868, "Member 'UDBDGameInstance::_mapActorDB' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _interactionProficiencies) == 0x000870, "Member 'UDBDGameInstance::_interactionProficiencies' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _theHud) == 0x000880, "Member 'UDBDGameInstance::_theHud' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _bloodwebManager) == 0x0008B0, "Member 'UDBDGameInstance::_bloodwebManager' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _popupSequencer) == 0x0008B8, "Member 'UDBDGameInstance::_popupSequencer' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _popupFactory) == 0x0008C0, "Member 'UDBDGameInstance::_popupFactory' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _auth) == 0x0008C8, "Member 'UDBDGameInstance::_auth' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _eac) == 0x0008D0, "Member 'UDBDGameInstance::_eac' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _execObjects) == 0x000970, "Member 'UDBDGameInstance::_execObjects' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _networkFailureDetected) == 0x000980, "Member 'UDBDGameInstance::_networkFailureDetected' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _networkConnectionMonitoringOnly) == 0x000981, "Member 'UDBDGameInstance::_networkConnectionMonitoringOnly' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _achievementStatsUploadEnabled) == 0x000982, "Member 'UDBDGameInstance::_achievementStatsUploadEnabled' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _isDisconnected) == 0x000983, "Member 'UDBDGameInstance::_isDisconnected' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _isGamepadReconnected) == 0x000984, "Member 'UDBDGameInstance::_isGamepadReconnected' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _isProfileOffline) == 0x000985, "Member 'UDBDGameInstance::_isProfileOffline' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _isAppSuspended) == 0x000986, "Member 'UDBDGameInstance::_isAppSuspended' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _isAppResumed) == 0x000987, "Member 'UDBDGameInstance::_isAppResumed' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _isInvitationRejected) == 0x000988, "Member 'UDBDGameInstance::_isInvitationRejected' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _isAdditionalContentInstalled) == 0x000989, "Member 'UDBDGameInstance::_isAdditionalContentInstalled' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _isCloudInventoryInitialized) == 0x00098A, "Member 'UDBDGameInstance::_isCloudInventoryInitialized' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _resultOfferingAndPerkEffects) == 0x000A08, "Member 'UDBDGameInstance::_resultOfferingAndPerkEffects' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _cinematicManager) == 0x000A10, "Member 'UDBDGameInstance::_cinematicManager' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _softBanManager) == 0x000A18, "Member 'UDBDGameInstance::_softBanManager' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _consentManager) == 0x000A20, "Member 'UDBDGameInstance::_consentManager' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _onlineSystemHandler) == 0x000A28, "Member 'UDBDGameInstance::_onlineSystemHandler' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _regionFinder) == 0x000A30, "Member 'UDBDGameInstance::_regionFinder' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _decalSpawnerCollection) == 0x000A38, "Member 'UDBDGameInstance::_decalSpawnerCollection' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _characterClippingPrimitiveCollection) == 0x000A40, "Member 'UDBDGameInstance::_characterClippingPrimitiveCollection' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, LastProviderErrorCode) == 0x000A48, "Member 'UDBDGameInstance::LastProviderErrorCode' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _disconnectError) == 0x000A4C, "Member 'UDBDGameInstance::_disconnectError' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _dateTimerUpdater) == 0x000A58, "Member 'UDBDGameInstance::_dateTimerUpdater' has a wrong offset!");

// Class DeadByDaylight.AimingCrosshairComponent
// 0x0040 (0x00E8 - 0x00A8)
class UAimingCrosshairComponent : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x40];                                      // 0x00A8(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_OnCrosshairStateChanged(EAimingCrosshairState NewState, EAimingCrosshairState LastState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AimingCrosshairComponent">();
	}
	static class UAimingCrosshairComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAimingCrosshairComponent>();
	}
};
static_assert(alignof(UAimingCrosshairComponent) == 0x000008, "Wrong alignment on UAimingCrosshairComponent");
static_assert(sizeof(UAimingCrosshairComponent) == 0x0000E8, "Wrong size on UAimingCrosshairComponent");

// Class DeadByDaylight.CustomizedAnimationComponent
// 0x0020 (0x00C8 - 0x00A8)
class UCustomizedAnimationComponent final : public UActorComponent
{
public:
	class ADBDBasePlayer*                         _owner;                                            // 0x00A8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCustomizedSkeletalMesh*                _customizedSkeletalMesh;                           // 0x00B0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UAnimInstance>              _defaultAnimClass;                                 // 0x00B8(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C0[0x8];                                       // 0x00C0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCustomizationChanged();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomizedAnimationComponent">();
	}
	static class UCustomizedAnimationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomizedAnimationComponent>();
	}
};
static_assert(alignof(UCustomizedAnimationComponent) == 0x000008, "Wrong alignment on UCustomizedAnimationComponent");
static_assert(sizeof(UCustomizedAnimationComponent) == 0x0000C8, "Wrong size on UCustomizedAnimationComponent");
static_assert(offsetof(UCustomizedAnimationComponent, _owner) == 0x0000A8, "Member 'UCustomizedAnimationComponent::_owner' has a wrong offset!");
static_assert(offsetof(UCustomizedAnimationComponent, _customizedSkeletalMesh) == 0x0000B0, "Member 'UCustomizedAnimationComponent::_customizedSkeletalMesh' has a wrong offset!");
static_assert(offsetof(UCustomizedAnimationComponent, _defaultAnimClass) == 0x0000B8, "Member 'UCustomizedAnimationComponent::_defaultAnimClass' has a wrong offset!");

// Class DeadByDaylight.CharacterInventoryComponent
// 0x00C8 (0x0170 - 0x00A8)
class UCharacterInventoryComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x48];                                      // 0x00A8(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameplayTag>                   _tagsPreventingItemVisibility;                     // 0x00F0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_100[0x10];                                     // 0x0100(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ACollectable*>                   _inventory;                                        // 0x0110(0x0010)(Net, ZeroConstructor, Transient, RepNotify, NativeAccessSpecifierPrivate)
	TArray<class UItemAddon*>                     _generalAddons;                                    // 0x0120(0x0010)(ExportObject, Net, ZeroConstructor, Transient, RepNotify, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class ACollectable*>                   _backpackInventory;                                // 0x0130(0x0010)(Net, ZeroConstructor, Transient, RepNotify, NativeAccessSpecifierPrivate)
	TArray<class ACollectable*>                   _localInventory;                                   // 0x0140(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class ACollectable*>                   _localBackpackInventory;                           // 0x0150(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class UItemAddon*>                     _allAddons;                                        // 0x0160(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	void Authority_AddToInventory(class ACollectable* Item, EInventoryType InventoryType);
	void Authority_ClearAndDestroyInventory();
	void Authority_Collect(class ACollectable* Item, EInventoryType InventoryType, bool SwapItemsAndHideOldAway);
	void Authority_RemoveFromInventory(class ACollectable* Item, EInventoryType InventoryType);
	void Authority_UseInventoryItem();
	void EquipItem();
	class UItemAddon* GetAddon(class FName AddonID);
	const TArray<class UItemAddon*> GetAddons();
	class ACollectable* GetFirstItemFromInventory(TSubclassOf<class ACollectable> Item, EInventoryType InventoryType);
	bool HasInInventory(TSubclassOf<class ACollectable> Item, EInventoryType InventoryType);
	void Multicast_AddToInventory(class ACollectable* Item, EInventoryType InventoryType);
	void Multicast_ClearAndDestroyInventory();
	void Multicast_MoveItemToOtherSlot(class ACollectable* ItemBeingMoved, EInventoryType TargetInventoryType);
	void Multicast_RemoveFromInventory(class ACollectable* Item, EInventoryType InventoryType);
	void OnRep_BackpackInventory();
	void OnRep_GeneralAddons();
	void OnRep_Inventory();
	class ACollectable* SpawnAndCollectItem(class FName ItemId);
	void StoreItem();

	class ACollectable* GetItem(EInventoryType InventoryType) const;
	int32 GetItemCount() const;
	int32 GetItemCountByID(class FName ItemId) const;
	class FName GetItemID(EInventoryType InventoryType) const;
	bool HasEquippedItem() const;
	bool HasItem(EInventoryType InventoryType) const;
	bool HasMaximumItemCount(const class ACollectable* Item) const;
	bool HasStoredItem() const;
	bool IsUsingAimItem() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterInventoryComponent">();
	}
	static class UCharacterInventoryComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterInventoryComponent>();
	}
};
static_assert(alignof(UCharacterInventoryComponent) == 0x000008, "Wrong alignment on UCharacterInventoryComponent");
static_assert(sizeof(UCharacterInventoryComponent) == 0x000170, "Wrong size on UCharacterInventoryComponent");
static_assert(offsetof(UCharacterInventoryComponent, _tagsPreventingItemVisibility) == 0x0000F0, "Member 'UCharacterInventoryComponent::_tagsPreventingItemVisibility' has a wrong offset!");
static_assert(offsetof(UCharacterInventoryComponent, _inventory) == 0x000110, "Member 'UCharacterInventoryComponent::_inventory' has a wrong offset!");
static_assert(offsetof(UCharacterInventoryComponent, _generalAddons) == 0x000120, "Member 'UCharacterInventoryComponent::_generalAddons' has a wrong offset!");
static_assert(offsetof(UCharacterInventoryComponent, _backpackInventory) == 0x000130, "Member 'UCharacterInventoryComponent::_backpackInventory' has a wrong offset!");
static_assert(offsetof(UCharacterInventoryComponent, _localInventory) == 0x000140, "Member 'UCharacterInventoryComponent::_localInventory' has a wrong offset!");
static_assert(offsetof(UCharacterInventoryComponent, _localBackpackInventory) == 0x000150, "Member 'UCharacterInventoryComponent::_localBackpackInventory' has a wrong offset!");
static_assert(offsetof(UCharacterInventoryComponent, _allAddons) == 0x000160, "Member 'UCharacterInventoryComponent::_allAddons' has a wrong offset!");

// Class DeadByDaylight.DBDAIController
// 0x0480 (0x0850 - 0x03D0)
class ADBDAIController : public AAIController
{
public:
	float                                         DefaultSightRange;                                 // 0x03D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CloakedTargetSightRange;                           // 0x03D4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SightSweepTestRadius;                              // 0x03D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraMaxPitchAngle;                               // 0x03DC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraMinPitchAngle;                               // 0x03E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E4[0x4];                                      // 0x03E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAITunableParameter                    CameraHighDeltaLerpSpeed;                          // 0x03E8(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    CameraLowDeltaLerpSpeed;                           // 0x0448(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    CameraTowardTargetDeltaAngle;                      // 0x04A8(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<EAIDifficultyLevel, int32>               AIDifficultyMaxPlayerRanks;                        // 0x0508(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         Pad_558[0x20];                                     // 0x0558(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class APawn*                                  _aiPawn;                                           // 0x0578(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class APawn*                                  _lastAiPawn;                                       // 0x0580(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class UObject*, float>                   _contextualPathSpeedFactors;                       // 0x0588(0x0050)(Transient, NativeAccessSpecifierPrivate)
	class UObject*                                _objOverridingDefaultNavigationFilter;             // 0x05D8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UNavigationQueryFilter>     _originalDefaultNavigationFilter;                  // 0x05E0(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5E8[0x28];                                     // 0x05E8(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EPawnInputPressTypes, class UObject*>    _inputLocks;                                       // 0x0610(0x0050)(Transient, NativeAccessSpecifierPrivate)
	class UObject*                                _movementLock;                                     // 0x0660(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UObject*>                        _focusPriorityLocks;                               // 0x0668(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_678[0x1D8];                                    // 0x0678(0x01D8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AbilityTwoRequest(const class UObject* Requester, ECharacterMovementTypes MovementMode);
	void ActionRequest(const class UObject* Requester);
	void AttackRequest(const class UObject* Requester);
	void CancelMinigameRequest(const class UObject* Requester);
	void DropItemRequest(const class UObject* Requester);
	void EndAbilityTwoRequest(const class UObject* Requester);
	void EndActionRequest(const class UObject* Requester);
	void EndDropItemRequest(const class UObject* Requester);
	void EndEventAbilityRequest(const class UObject* Requester);
	void EndFastInteractRequest(const class UObject* Requester);
	void EndInteractRequest(const class UObject* Requester);
	void EndRunRequest(const class UObject* Requester);
	void EndSecondAttackRequest(const class UObject* Requester);
	void EndUseItemRequest(const class UObject* Requester);
	void EventAbilityRequest(const class UObject* Requester);
	void FastInteractRequest(const class UObject* Requester);
	void Gesture01Request(const class UObject* Requester);
	void Gesture02Request(const class UObject* Requester);
	void Gesture03Request(const class UObject* Requester);
	void Gesture04Request(const class UObject* Requester);
	void InteractRequest(const class UObject* Requester);
	void InteractRequestRelease(const class UObject* Requester);
	void RunRequest(const class UObject* Requester);
	void SecondaryActionRequest(const class UObject* Requester);
	void SecondAttackRequest(const class UObject* Requester);
	void Server_SetAIPlayerRank(int32 PlayerRank);
	bool SetCharacterMovement(ECharacterMovementTypes MovementTypes, const class UObject* Requester, EAIMovementPriority ApplyOrder);
	void StruggleRequest(const class UObject* Requester, float Input);
	void UseItemRequest(const class UObject* Requester);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDAIController">();
	}
	static class ADBDAIController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDAIController>();
	}
};
static_assert(alignof(ADBDAIController) == 0x000008, "Wrong alignment on ADBDAIController");
static_assert(sizeof(ADBDAIController) == 0x000850, "Wrong size on ADBDAIController");
static_assert(offsetof(ADBDAIController, DefaultSightRange) == 0x0003D0, "Member 'ADBDAIController::DefaultSightRange' has a wrong offset!");
static_assert(offsetof(ADBDAIController, CloakedTargetSightRange) == 0x0003D4, "Member 'ADBDAIController::CloakedTargetSightRange' has a wrong offset!");
static_assert(offsetof(ADBDAIController, SightSweepTestRadius) == 0x0003D8, "Member 'ADBDAIController::SightSweepTestRadius' has a wrong offset!");
static_assert(offsetof(ADBDAIController, CameraMaxPitchAngle) == 0x0003DC, "Member 'ADBDAIController::CameraMaxPitchAngle' has a wrong offset!");
static_assert(offsetof(ADBDAIController, CameraMinPitchAngle) == 0x0003E0, "Member 'ADBDAIController::CameraMinPitchAngle' has a wrong offset!");
static_assert(offsetof(ADBDAIController, CameraHighDeltaLerpSpeed) == 0x0003E8, "Member 'ADBDAIController::CameraHighDeltaLerpSpeed' has a wrong offset!");
static_assert(offsetof(ADBDAIController, CameraLowDeltaLerpSpeed) == 0x000448, "Member 'ADBDAIController::CameraLowDeltaLerpSpeed' has a wrong offset!");
static_assert(offsetof(ADBDAIController, CameraTowardTargetDeltaAngle) == 0x0004A8, "Member 'ADBDAIController::CameraTowardTargetDeltaAngle' has a wrong offset!");
static_assert(offsetof(ADBDAIController, AIDifficultyMaxPlayerRanks) == 0x000508, "Member 'ADBDAIController::AIDifficultyMaxPlayerRanks' has a wrong offset!");
static_assert(offsetof(ADBDAIController, _aiPawn) == 0x000578, "Member 'ADBDAIController::_aiPawn' has a wrong offset!");
static_assert(offsetof(ADBDAIController, _lastAiPawn) == 0x000580, "Member 'ADBDAIController::_lastAiPawn' has a wrong offset!");
static_assert(offsetof(ADBDAIController, _contextualPathSpeedFactors) == 0x000588, "Member 'ADBDAIController::_contextualPathSpeedFactors' has a wrong offset!");
static_assert(offsetof(ADBDAIController, _objOverridingDefaultNavigationFilter) == 0x0005D8, "Member 'ADBDAIController::_objOverridingDefaultNavigationFilter' has a wrong offset!");
static_assert(offsetof(ADBDAIController, _originalDefaultNavigationFilter) == 0x0005E0, "Member 'ADBDAIController::_originalDefaultNavigationFilter' has a wrong offset!");
static_assert(offsetof(ADBDAIController, _inputLocks) == 0x000610, "Member 'ADBDAIController::_inputLocks' has a wrong offset!");
static_assert(offsetof(ADBDAIController, _movementLock) == 0x000660, "Member 'ADBDAIController::_movementLock' has a wrong offset!");
static_assert(offsetof(ADBDAIController, _focusPriorityLocks) == 0x000668, "Member 'ADBDAIController::_focusPriorityLocks' has a wrong offset!");

// Class DeadByDaylight.AISlasherMoveToGrabSurvivorBehaviourData
// 0x0008 (0x0038 - 0x0030)
class UAISlasherMoveToGrabSurvivorBehaviourData final : public UAICharacterBehaviourData
{
public:
	class ACamperPlayer*                          _targetSurvivor;                                   // 0x0030(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Init(class ACamperPlayer* TargetSurvivor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISlasherMoveToGrabSurvivorBehaviourData">();
	}
	static class UAISlasherMoveToGrabSurvivorBehaviourData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISlasherMoveToGrabSurvivorBehaviourData>();
	}
};
static_assert(alignof(UAISlasherMoveToGrabSurvivorBehaviourData) == 0x000008, "Wrong alignment on UAISlasherMoveToGrabSurvivorBehaviourData");
static_assert(sizeof(UAISlasherMoveToGrabSurvivorBehaviourData) == 0x000038, "Wrong size on UAISlasherMoveToGrabSurvivorBehaviourData");
static_assert(offsetof(UAISlasherMoveToGrabSurvivorBehaviourData, _targetSurvivor) == 0x000030, "Member 'UAISlasherMoveToGrabSurvivorBehaviourData::_targetSurvivor' has a wrong offset!");

// Class DeadByDaylight.DBDTunableUtilities
// 0x0000 (0x0030 - 0x0030)
class UDBDTunableUtilities final : public UBlueprintFunctionLibrary
{
public:
	static float GetEndGameTunableValue(const class UObject* WorldContextObject, class FName ValueName);
	static float GetSlasherTunableValue(const class UObject* WorldContextObject, class FName ValueName);
	static float GetTunableRowHandleValue(const struct FDBDTunableRowHandle& RowHandle);
	static float GetTunableValue(const class UObject* WorldContextObject, class FName ValueName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDTunableUtilities">();
	}
	static class UDBDTunableUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDTunableUtilities>();
	}
};
static_assert(alignof(UDBDTunableUtilities) == 0x000008, "Wrong alignment on UDBDTunableUtilities");
static_assert(sizeof(UDBDTunableUtilities) == 0x000030, "Wrong size on UDBDTunableUtilities");

// Class DeadByDaylight.DBDDangerPredictionComponent
// 0x0068 (0x0110 - 0x00A8)
class UDBDDangerPredictionComponent : public UActorComponent
{
public:
	bool                                          ApplyAdditionalCostInDangerArea;                   // 0x00A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESurvivorFleePathStrategy                     SurvivorFleePathStrategy;                          // 0x00A9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AA[0x2];                                       // 0x00AA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RelevantHorizontalDistance;                        // 0x00AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RelevantVerticalDistance;                          // 0x00B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EDangerTraversePriority                       DangerTraversePriority;                            // 0x00B4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EPlayerRole                                   RelevantRole;                                      // 0x00B5(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B6[0x2];                                       // 0x00B6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FEQSParametrizedQueryExecutionRequest  FleeEQSRequest;                                    // 0x00B8(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_108[0x8];                                      // 0x0108(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDDangerPredictionComponent">();
	}
	static class UDBDDangerPredictionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDDangerPredictionComponent>();
	}
};
static_assert(alignof(UDBDDangerPredictionComponent) == 0x000008, "Wrong alignment on UDBDDangerPredictionComponent");
static_assert(sizeof(UDBDDangerPredictionComponent) == 0x000110, "Wrong size on UDBDDangerPredictionComponent");
static_assert(offsetof(UDBDDangerPredictionComponent, ApplyAdditionalCostInDangerArea) == 0x0000A8, "Member 'UDBDDangerPredictionComponent::ApplyAdditionalCostInDangerArea' has a wrong offset!");
static_assert(offsetof(UDBDDangerPredictionComponent, SurvivorFleePathStrategy) == 0x0000A9, "Member 'UDBDDangerPredictionComponent::SurvivorFleePathStrategy' has a wrong offset!");
static_assert(offsetof(UDBDDangerPredictionComponent, RelevantHorizontalDistance) == 0x0000AC, "Member 'UDBDDangerPredictionComponent::RelevantHorizontalDistance' has a wrong offset!");
static_assert(offsetof(UDBDDangerPredictionComponent, RelevantVerticalDistance) == 0x0000B0, "Member 'UDBDDangerPredictionComponent::RelevantVerticalDistance' has a wrong offset!");
static_assert(offsetof(UDBDDangerPredictionComponent, DangerTraversePriority) == 0x0000B4, "Member 'UDBDDangerPredictionComponent::DangerTraversePriority' has a wrong offset!");
static_assert(offsetof(UDBDDangerPredictionComponent, RelevantRole) == 0x0000B5, "Member 'UDBDDangerPredictionComponent::RelevantRole' has a wrong offset!");
static_assert(offsetof(UDBDDangerPredictionComponent, FleeEQSRequest) == 0x0000B8, "Member 'UDBDDangerPredictionComponent::FleeEQSRequest' has a wrong offset!");

// Class DeadByDaylight.DBDCharacterMovementUtilities
// 0x0000 (0x0030 - 0x0030)
class UDBDCharacterMovementUtilities final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDCharacterMovementUtilities">();
	}
	static class UDBDCharacterMovementUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDCharacterMovementUtilities>();
	}
};
static_assert(alignof(UDBDCharacterMovementUtilities) == 0x000008, "Wrong alignment on UDBDCharacterMovementUtilities");
static_assert(sizeof(UDBDCharacterMovementUtilities) == 0x000030, "Wrong size on UDBDCharacterMovementUtilities");

// Class DeadByDaylight.AICharacterEvasionBehaviour
// 0x0028 (0x0080 - 0x0058)
class UAICharacterEvasionBehaviour final : public UAICharacterBehaviour
{
public:
	class ADBDPlayer*                             _prey;                                             // 0x0058(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ADBDAIPlayerController*                 _preyAIController;                                 // 0x0060(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 _currentEscapePoint;                               // 0x0068(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCharacterEvasionBehaviourData*         _characterEvasionData;                             // 0x0070(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_78[0x8];                                       // 0x0078(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EscapeDestinationReached(const struct FAIRequestID& RequestID, EPathFollowingResult Result);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AICharacterEvasionBehaviour">();
	}
	static class UAICharacterEvasionBehaviour* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAICharacterEvasionBehaviour>();
	}
};
static_assert(alignof(UAICharacterEvasionBehaviour) == 0x000008, "Wrong alignment on UAICharacterEvasionBehaviour");
static_assert(sizeof(UAICharacterEvasionBehaviour) == 0x000080, "Wrong size on UAICharacterEvasionBehaviour");
static_assert(offsetof(UAICharacterEvasionBehaviour, _prey) == 0x000058, "Member 'UAICharacterEvasionBehaviour::_prey' has a wrong offset!");
static_assert(offsetof(UAICharacterEvasionBehaviour, _preyAIController) == 0x000060, "Member 'UAICharacterEvasionBehaviour::_preyAIController' has a wrong offset!");
static_assert(offsetof(UAICharacterEvasionBehaviour, _currentEscapePoint) == 0x000068, "Member 'UAICharacterEvasionBehaviour::_currentEscapePoint' has a wrong offset!");
static_assert(offsetof(UAICharacterEvasionBehaviour, _characterEvasionData) == 0x000070, "Member 'UAICharacterEvasionBehaviour::_characterEvasionData' has a wrong offset!");

// Class DeadByDaylight.MenuForcedLODHandler
// 0x0070 (0x0118 - 0x00A8)
class UMenuForcedLODHandler final : public UActorComponent
{
public:
	TArray<EGameFlowStep>                         _forcedLOD0GameFlowSteps;                          // 0x00A8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B8[0x60];                                      // 0x00B8(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCustomizationChanged(ECustomizationCategory Category, const class FName& ItemId, class ADBDMenuPlayer* MenuPlayer);
	void OnMenuPlayerEndPlay(class AActor* MenuPlayerActor, EEndPlayReason EndPlayReason);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MenuForcedLODHandler">();
	}
	static class UMenuForcedLODHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMenuForcedLODHandler>();
	}
};
static_assert(alignof(UMenuForcedLODHandler) == 0x000008, "Wrong alignment on UMenuForcedLODHandler");
static_assert(sizeof(UMenuForcedLODHandler) == 0x000118, "Wrong size on UMenuForcedLODHandler");
static_assert(offsetof(UMenuForcedLODHandler, _forcedLOD0GameFlowSteps) == 0x0000A8, "Member 'UMenuForcedLODHandler::_forcedLOD0GameFlowSteps' has a wrong offset!");

// Class DeadByDaylight.SurvivorCollectableOutlineUpdateStrategy
// 0x0030 (0x0100 - 0x00D0)
class USurvivorCollectableOutlineUpdateStrategy : public UOutlineUpdateStrategy
{
public:
	struct FLinearColor                           _outlineColor;                                     // 0x00D0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           _nearlyConsumedColor;                              // 0x00E0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           _yellowOutlineColor;                               // 0x00F0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SurvivorCollectableOutlineUpdateStrategy">();
	}
	static class USurvivorCollectableOutlineUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<USurvivorCollectableOutlineUpdateStrategy>();
	}
};
static_assert(alignof(USurvivorCollectableOutlineUpdateStrategy) == 0x000008, "Wrong alignment on USurvivorCollectableOutlineUpdateStrategy");
static_assert(sizeof(USurvivorCollectableOutlineUpdateStrategy) == 0x000100, "Wrong size on USurvivorCollectableOutlineUpdateStrategy");
static_assert(offsetof(USurvivorCollectableOutlineUpdateStrategy, _outlineColor) == 0x0000D0, "Member 'USurvivorCollectableOutlineUpdateStrategy::_outlineColor' has a wrong offset!");
static_assert(offsetof(USurvivorCollectableOutlineUpdateStrategy, _nearlyConsumedColor) == 0x0000E0, "Member 'USurvivorCollectableOutlineUpdateStrategy::_nearlyConsumedColor' has a wrong offset!");
static_assert(offsetof(USurvivorCollectableOutlineUpdateStrategy, _yellowOutlineColor) == 0x0000F0, "Member 'USurvivorCollectableOutlineUpdateStrategy::_yellowOutlineColor' has a wrong offset!");

// Class DeadByDaylight.CamperMaterialHelperController
// 0x0088 (0x0130 - 0x00A8)
class UCamperMaterialHelperController final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x78];                                      // 0x00A8(0x0078)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FManagedMaterialGroup>          _managedGroups;                                    // 0x0120(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	void AddManagedGroup(class UObject* Source, const class FString& Group);
	void AddManagedWithCondition(class UObject* Source, const class FString& Group, const TDelegate<void()>& Condition);
	void RemoveGroupsBySource(class UObject* Source);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CamperMaterialHelperController">();
	}
	static class UCamperMaterialHelperController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCamperMaterialHelperController>();
	}
};
static_assert(alignof(UCamperMaterialHelperController) == 0x000008, "Wrong alignment on UCamperMaterialHelperController");
static_assert(sizeof(UCamperMaterialHelperController) == 0x000130, "Wrong size on UCamperMaterialHelperController");
static_assert(offsetof(UCamperMaterialHelperController, _managedGroups) == 0x000120, "Member 'UCamperMaterialHelperController::_managedGroups' has a wrong offset!");

// Class DeadByDaylight.GeneratorDamageComponent
// 0x0078 (0x0120 - 0x00A8)
class UGeneratorDamageComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x10];                                      // 0x00A8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             Cosmetic_OnGeneratorDamaged;                       // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	struct FDamageData                            _damageData;                                       // 0x00C8(0x0020)(Net, Transient, RepNotify, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _gradualRegressionPercentPerDamage;                // 0x00E8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_110[0x10];                                     // 0x0110(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CosmeticGeneratorDamagedDelegate__DelegateSignature(bool Intense);
	void Multicast_DamageEffects(const float ImmediateRegressionPercent, const TArray<class ADBDPlayer*>& Repairers, const bool PlayLoudNoise);
	void OnRep_DamageData();

	bool IsIntenseDamage() const;
	bool IsRegressing() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GeneratorDamageComponent">();
	}
	static class UGeneratorDamageComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGeneratorDamageComponent>();
	}
};
static_assert(alignof(UGeneratorDamageComponent) == 0x000008, "Wrong alignment on UGeneratorDamageComponent");
static_assert(sizeof(UGeneratorDamageComponent) == 0x000120, "Wrong size on UGeneratorDamageComponent");
static_assert(offsetof(UGeneratorDamageComponent, Cosmetic_OnGeneratorDamaged) == 0x0000B8, "Member 'UGeneratorDamageComponent::Cosmetic_OnGeneratorDamaged' has a wrong offset!");
static_assert(offsetof(UGeneratorDamageComponent, _damageData) == 0x0000C8, "Member 'UGeneratorDamageComponent::_damageData' has a wrong offset!");
static_assert(offsetof(UGeneratorDamageComponent, _gradualRegressionPercentPerDamage) == 0x0000E8, "Member 'UGeneratorDamageComponent::_gradualRegressionPercentPerDamage' has a wrong offset!");

// Class DeadByDaylight.PlayerPerspectiveChangeComponent
// 0x0078 (0x0120 - 0x00A8)
class UPlayerPerspectiveChangeComponent : public UActorComponent
{
public:
	struct FPlayerPerspectiveChangeCameraMovementData _currentCameraTransitionData;                      // 0x00A8(0x0050)(Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FPlayerPerspectiveChangeTargetData     _targetPerspective;                                // 0x00F8(0x0020)(Transient, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	bool                                          _shouldUpdateFirstPersonMeshAndModelAfterFinalize; // 0x0118(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_119[0x7];                                      // 0x0119(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FinalizeTargetPerspective();
	void TransitionToTargetPerspective(const struct FPlayerPerspectiveChangeTargetData& TargetData, float TransitionDuration);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerPerspectiveChangeComponent">();
	}
	static class UPlayerPerspectiveChangeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerPerspectiveChangeComponent>();
	}
};
static_assert(alignof(UPlayerPerspectiveChangeComponent) == 0x000008, "Wrong alignment on UPlayerPerspectiveChangeComponent");
static_assert(sizeof(UPlayerPerspectiveChangeComponent) == 0x000120, "Wrong size on UPlayerPerspectiveChangeComponent");
static_assert(offsetof(UPlayerPerspectiveChangeComponent, _currentCameraTransitionData) == 0x0000A8, "Member 'UPlayerPerspectiveChangeComponent::_currentCameraTransitionData' has a wrong offset!");
static_assert(offsetof(UPlayerPerspectiveChangeComponent, _targetPerspective) == 0x0000F8, "Member 'UPlayerPerspectiveChangeComponent::_targetPerspective' has a wrong offset!");
static_assert(offsetof(UPlayerPerspectiveChangeComponent, _shouldUpdateFirstPersonMeshAndModelAfterFinalize) == 0x000118, "Member 'UPlayerPerspectiveChangeComponent::_shouldUpdateFirstPersonMeshAndModelAfterFinalize' has a wrong offset!");

// Class DeadByDaylight.AnimationFollowerActor
// 0x00B8 (0x0358 - 0x02A0)
class AAnimationFollowerActor : public AActor
{
public:
	uint8                                         Pad_2A0[0x8];                                      // 0x02A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UDBDSkeletalMeshComponentBudgeted*      _skeletalMeshComponent;                            // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimationMontageSlave*                 _montageFollower;                                  // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMontagePlayer*                         _montagePlayer;                                    // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C0[0x78];                                     // 0x02C0(0x0078)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           _montageIDsLeavingActorVisible;                    // 0x0338(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_348[0x9];                                      // 0x0348(0x0009)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _attachToMontageLeaderOnAnimationStart;            // 0x0351(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_352[0x6];                                      // 0x0352(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_OnMontageStarted(const struct FAnimationMontageDescriptor& MontagePlayed);
	void Cosmetic_OnMontageStopped();
	void Cosmetic_OnVisibilityChanged(bool IsVisible);
	void NativeOnMontageEnded(const struct FAnimationMontageDescriptor& Montage, bool Interrupted);
	void NativeOnMontageStarted(const struct FAnimationMontageDescriptor& ID, const float Rate);
	void NativeOnMontageStopped(const struct FAnimationMontageDescriptor& ID);
	void OnMontageEnd(const struct FAnimationMontageDescriptor& MontageID, bool Interrupted);
	void OnMontageStarted(const struct FAnimationMontageDescriptor& MontageID, const float Rate);
	void OnMontageStopped(const struct FAnimationMontageDescriptor& MontageID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimationFollowerActor">();
	}
	static class AAnimationFollowerActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAnimationFollowerActor>();
	}
};
static_assert(alignof(AAnimationFollowerActor) == 0x000008, "Wrong alignment on AAnimationFollowerActor");
static_assert(sizeof(AAnimationFollowerActor) == 0x000358, "Wrong size on AAnimationFollowerActor");
static_assert(offsetof(AAnimationFollowerActor, _skeletalMeshComponent) == 0x0002A8, "Member 'AAnimationFollowerActor::_skeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(AAnimationFollowerActor, _montageFollower) == 0x0002B0, "Member 'AAnimationFollowerActor::_montageFollower' has a wrong offset!");
static_assert(offsetof(AAnimationFollowerActor, _montagePlayer) == 0x0002B8, "Member 'AAnimationFollowerActor::_montagePlayer' has a wrong offset!");
static_assert(offsetof(AAnimationFollowerActor, _montageIDsLeavingActorVisible) == 0x000338, "Member 'AAnimationFollowerActor::_montageIDsLeavingActorVisible' has a wrong offset!");
static_assert(offsetof(AAnimationFollowerActor, _attachToMontageLeaderOnAnimationStart) == 0x000351, "Member 'AAnimationFollowerActor::_attachToMontageLeaderOnAnimationStart' has a wrong offset!");

// Class DeadByDaylight.DirectionalMinigameComponent
// 0x0068 (0x0110 - 0x00A8)
class UDirectionalMinigameComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x20];                                      // 0x00A8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class ACamperPlayer*                          _currentlyEngagedSurvivor;                         // 0x00C8(0x0008)(Net, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<EDirectionalInputKey>                  _currentSequence;                                  // 0x00D0(0x0010)(Net, ZeroConstructor, NativeAccessSpecifierPrivate)
	bool                                          _isInProgress;                                     // 0x00E0(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E1[0x3];                                       // 0x00E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _currentKeyIndex;                                  // 0x00E4(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDirectionalMiniGameDefinition         _miniGameDefinition;                               // 0x00E8(0x0020)(Net, NativeAccessSpecifierPrivate)
	uint8                                         Pad_108[0x8];                                      // 0x0108(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_StartMinigameForSurvivor(class ACamperPlayer* Survivor, const struct FDirectionalMiniGameDefinition& MiniGameDefinition);
	void OnRep_IsInProgress();
	void Server_CancelMinigame();
	void Server_EnterKey(EDirectionalInputKey EnteredKey);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DirectionalMinigameComponent">();
	}
	static class UDirectionalMinigameComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDirectionalMinigameComponent>();
	}
};
static_assert(alignof(UDirectionalMinigameComponent) == 0x000008, "Wrong alignment on UDirectionalMinigameComponent");
static_assert(sizeof(UDirectionalMinigameComponent) == 0x000110, "Wrong size on UDirectionalMinigameComponent");
static_assert(offsetof(UDirectionalMinigameComponent, _currentlyEngagedSurvivor) == 0x0000C8, "Member 'UDirectionalMinigameComponent::_currentlyEngagedSurvivor' has a wrong offset!");
static_assert(offsetof(UDirectionalMinigameComponent, _currentSequence) == 0x0000D0, "Member 'UDirectionalMinigameComponent::_currentSequence' has a wrong offset!");
static_assert(offsetof(UDirectionalMinigameComponent, _isInProgress) == 0x0000E0, "Member 'UDirectionalMinigameComponent::_isInProgress' has a wrong offset!");
static_assert(offsetof(UDirectionalMinigameComponent, _currentKeyIndex) == 0x0000E4, "Member 'UDirectionalMinigameComponent::_currentKeyIndex' has a wrong offset!");
static_assert(offsetof(UDirectionalMinigameComponent, _miniGameDefinition) == 0x0000E8, "Member 'UDirectionalMinigameComponent::_miniGameDefinition' has a wrong offset!");

// Class DeadByDaylight.ColorBlindSettingsListenerInterface
// 0x0000 (0x0030 - 0x0030)
class IColorBlindSettingsListenerInterface final : public IInterface
{
public:
	void OnColorBlindSettingsChange(EColorVisionDeficiency ColorBlindMode, int32 ColorblindIntensity);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ColorBlindSettingsListenerInterface">();
	}
	static class IColorBlindSettingsListenerInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IColorBlindSettingsListenerInterface>();
	}
};
static_assert(alignof(IColorBlindSettingsListenerInterface) == 0x000008, "Wrong alignment on IColorBlindSettingsListenerInterface");
static_assert(sizeof(IColorBlindSettingsListenerInterface) == 0x000030, "Wrong size on IColorBlindSettingsListenerInterface");

// Class DeadByDaylight.PalletTracker
// 0x0078 (0x0318 - 0x02A0)
class APalletTracker final : public AActor
{
public:
	uint8                                         Pad_2A0[0x28];                                     // 0x02A0(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        _indicatorLocation;                                // 0x02C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDBDNavEvadeLoopComponent*              _navEvadeLoopComponent;                            // 0x02D0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APallet*                                _trackedPallet;                                    // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APallet*                                _procedurallySpawnedPallet;                        // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EPalletState                                  _trackedPalletState;                               // 0x02E8(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2E9[0x2F];                                     // 0x02E9(0x002F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CanSpawnPalletAtLocation(const class AActor* SpawningActor) const;
	void OnRep_TrackedPallet() const;
	void OnRep_TrackedPalletState() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalletTracker">();
	}
	static class APalletTracker* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalletTracker>();
	}
};
static_assert(alignof(APalletTracker) == 0x000008, "Wrong alignment on APalletTracker");
static_assert(sizeof(APalletTracker) == 0x000318, "Wrong size on APalletTracker");
static_assert(offsetof(APalletTracker, _indicatorLocation) == 0x0002C8, "Member 'APalletTracker::_indicatorLocation' has a wrong offset!");
static_assert(offsetof(APalletTracker, _navEvadeLoopComponent) == 0x0002D0, "Member 'APalletTracker::_navEvadeLoopComponent' has a wrong offset!");
static_assert(offsetof(APalletTracker, _trackedPallet) == 0x0002D8, "Member 'APalletTracker::_trackedPallet' has a wrong offset!");
static_assert(offsetof(APalletTracker, _procedurallySpawnedPallet) == 0x0002E0, "Member 'APalletTracker::_procedurallySpawnedPallet' has a wrong offset!");
static_assert(offsetof(APalletTracker, _trackedPalletState) == 0x0002E8, "Member 'APalletTracker::_trackedPalletState' has a wrong offset!");

// Class DeadByDaylight.SurvivorTrapPerk
// 0x0088 (0x04A8 - 0x0420)
class USurvivorTrapPerk : public UPerk
{
public:
	uint8                                         Pad_420[0x8];                                      // 0x0420(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	ETrapType                                     _trapType;                                         // 0x0428(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_429[0x7];                                      // 0x0429(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AInteractable>              _trappableInteractableType;                        // 0x0430(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _progressPercentRequirementLevels[0x3];            // 0x0438(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _trapDurationLevels[0x3];                          // 0x0444(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AInteractable*                          _trappedInteractable;                              // 0x0450(0x0008)(Net, ZeroConstructor, Transient, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UTrapInstallerComponent>    _trapInstallerComponentClass;                      // 0x0458(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_460[0x38];                                     // 0x0460(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _progressPercent;                                  // 0x0498(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isTrapReady;                                      // 0x049C(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_49D[0xB];                                      // 0x049D(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnKillerInteracted(const struct FGameplayTag& GameEventTag, const struct FGameEventData& GameEventData);
	void Authority_OnRepairProgress(float IndividualChargeAmount, float TotalChargeAmount, class AActor* ChargeInstigator, bool WasCoop, float DeltaTime);
	void Authority_OnSurvivorRemoved(class ACamperPlayer* Survivor);
	void Authority_OnTrapInteractionEvent(const struct FGameplayTag& GameEvent, const struct FGameEventData& GameEventData);
	void Authority_OnTrapTimerDone();
	void OnRep_TrappedInteractable(class AInteractable* OldInteractable);

	class UPerkTrappableComponent* GetPerkTrappableComponent(class AInteractable* Interactable) const;
	float GetRepairProgressPercent() const;
	float GetRequiredRepairProgressForActivation() const;
	float GetTrapDuration() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SurvivorTrapPerk">();
	}
	static class USurvivorTrapPerk* GetDefaultObj()
	{
		return GetDefaultObjImpl<USurvivorTrapPerk>();
	}
};
static_assert(alignof(USurvivorTrapPerk) == 0x000008, "Wrong alignment on USurvivorTrapPerk");
static_assert(sizeof(USurvivorTrapPerk) == 0x0004A8, "Wrong size on USurvivorTrapPerk");
static_assert(offsetof(USurvivorTrapPerk, _trapType) == 0x000428, "Member 'USurvivorTrapPerk::_trapType' has a wrong offset!");
static_assert(offsetof(USurvivorTrapPerk, _trappableInteractableType) == 0x000430, "Member 'USurvivorTrapPerk::_trappableInteractableType' has a wrong offset!");
static_assert(offsetof(USurvivorTrapPerk, _progressPercentRequirementLevels) == 0x000438, "Member 'USurvivorTrapPerk::_progressPercentRequirementLevels' has a wrong offset!");
static_assert(offsetof(USurvivorTrapPerk, _trapDurationLevels) == 0x000444, "Member 'USurvivorTrapPerk::_trapDurationLevels' has a wrong offset!");
static_assert(offsetof(USurvivorTrapPerk, _trappedInteractable) == 0x000450, "Member 'USurvivorTrapPerk::_trappedInteractable' has a wrong offset!");
static_assert(offsetof(USurvivorTrapPerk, _trapInstallerComponentClass) == 0x000458, "Member 'USurvivorTrapPerk::_trapInstallerComponentClass' has a wrong offset!");
static_assert(offsetof(USurvivorTrapPerk, _progressPercent) == 0x000498, "Member 'USurvivorTrapPerk::_progressPercent' has a wrong offset!");
static_assert(offsetof(USurvivorTrapPerk, _isTrapReady) == 0x00049C, "Member 'USurvivorTrapPerk::_isTrapReady' has a wrong offset!");

// Class DeadByDaylight.AchievementHelper
// 0x0000 (0x0030 - 0x0030)
class UAchievementHelper final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AchievementHelper">();
	}
	static class UAchievementHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAchievementHelper>();
	}
};
static_assert(alignof(UAchievementHelper) == 0x000008, "Wrong alignment on UAchievementHelper");
static_assert(sizeof(UAchievementHelper) == 0x000030, "Wrong size on UAchievementHelper");

// Class DeadByDaylight.Locker
// 0x01C0 (0x0568 - 0x03A8)
class ALocker : public AInteractable
{
public:
	uint8                                         Pad_3A8[0x28];                                     // 0x03A8(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnPlayerInLockerChanged;                           // 0x03D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E0[0x18];                                     // 0x03E0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FastDoorActivationAudibleRange;                    // 0x03F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NormalDoorActivationAudibleRange;                  // 0x03FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBoxComponent*                          _boxComponent;                                     // 0x0400(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimationMontageSlave*                 _montageFollower;                                  // 0x0408(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMontagePlayer*                         _montagePlayer;                                    // 0x0410(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ADBDPlayer*                             _playerOpeningLocker;                              // 0x0418(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ADBDPlayer*                             _playerInLocker;                                   // 0x0420(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractor*                            _mainInteractor;                                   // 0x0428(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPrimitiveComponent*                    _frontInteractionZone;                             // 0x0430(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractionDefinition*                 _searchEmpty;                                      // 0x0438(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractionDefinition*                 _searchPlayer;                                     // 0x0440(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UChildActorComponent*                   _killerInteractionActor;                           // 0x0448(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractionDefinition*                 _enterSneak;                                       // 0x0450(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        _rootComponent;                                    // 0x0458(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        _survivorCameraAttachmentComponent;                // 0x0460(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _camperSocket;                                     // 0x0468(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_474[0x4];                                      // 0x0474(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ULockerAnimInstance*                    _lockerAnimInstance;                               // 0x0478(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_480[0x48];                                     // 0x0480(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _preventAllInteractions;                           // 0x04C8(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _local_preventAllInteractions;                     // 0x04C9(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4CA[0x6];                                      // 0x04CA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class ABaseLockerItem*                        _spawnedLockerItem;                                // 0x04D0(0x0008)(Net, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   _fastEnterInteractionTag;                          // 0x04D8(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   _fastExitInteractionTag;                           // 0x04E4(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4F0[0x70];                                     // 0x04F0(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	class UAIPerceptionStimuliSourceComponent*    _perceptionStimuliComponent;                       // 0x0560(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Authority_EnableOtherInteractors(const class UInteractor* UsableInteractor, bool Usable);
	void Authority_ReportOpenLockerNoiseEventToAI(const bool FastActivation);
	void EjectSurvivor();
	class UExposerInteriorZoneComponent* GetExposerInteriorZone();
	struct FVector GetPlayerInClosetLocation();
	void OnPlayerInLockerChanged__DelegateSignature(class ADBDPlayer* PlayerWhoWasInLocker, class ADBDPlayer* PlayerNowInLocker);
	void OnRep_PlayerInLocker(class ADBDPlayer* PreviousPlayerInLocker);
	void OnRep_PlayerOpeningLocker(class ADBDPlayer* PlayerWhoWasOpeningLocker);
	void OnRep_PreventAllInteractions();
	void StartMinNearOutlineDistLerp(class ADBDPlayer* Player);
	void StopMinNearOutlineDistLerp(class ADBDPlayer* Player);

	class AActor* GetChildInteractionActor() const;
	class UInteractor* GetInteractor() const;
	class UInteractionDefinition* GetLockerHideEnterSneakInteraction() const;
	class USkeletalMeshComponent* GetMesh() const;
	class ADBDPlayer* GetPlayerInLocker() const;
	class UPrimitiveComponent* GetStunZone() const;
	class ACamperPlayer* GetSurvivorInLocker() const;
	bool IsFacingLocker(const class ADBDPlayer* Player, float ToleranceDegreeAngle) const;
	bool IsOccupied() const;
	void SetPlayerInLockerVisibility(const bool IsVisible) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Locker">();
	}
	static class ALocker* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALocker>();
	}
};
static_assert(alignof(ALocker) == 0x000008, "Wrong alignment on ALocker");
static_assert(sizeof(ALocker) == 0x000568, "Wrong size on ALocker");
static_assert(offsetof(ALocker, OnPlayerInLockerChanged) == 0x0003D0, "Member 'ALocker::OnPlayerInLockerChanged' has a wrong offset!");
static_assert(offsetof(ALocker, FastDoorActivationAudibleRange) == 0x0003F8, "Member 'ALocker::FastDoorActivationAudibleRange' has a wrong offset!");
static_assert(offsetof(ALocker, NormalDoorActivationAudibleRange) == 0x0003FC, "Member 'ALocker::NormalDoorActivationAudibleRange' has a wrong offset!");
static_assert(offsetof(ALocker, _boxComponent) == 0x000400, "Member 'ALocker::_boxComponent' has a wrong offset!");
static_assert(offsetof(ALocker, _montageFollower) == 0x000408, "Member 'ALocker::_montageFollower' has a wrong offset!");
static_assert(offsetof(ALocker, _montagePlayer) == 0x000410, "Member 'ALocker::_montagePlayer' has a wrong offset!");
static_assert(offsetof(ALocker, _playerOpeningLocker) == 0x000418, "Member 'ALocker::_playerOpeningLocker' has a wrong offset!");
static_assert(offsetof(ALocker, _playerInLocker) == 0x000420, "Member 'ALocker::_playerInLocker' has a wrong offset!");
static_assert(offsetof(ALocker, _mainInteractor) == 0x000428, "Member 'ALocker::_mainInteractor' has a wrong offset!");
static_assert(offsetof(ALocker, _frontInteractionZone) == 0x000430, "Member 'ALocker::_frontInteractionZone' has a wrong offset!");
static_assert(offsetof(ALocker, _searchEmpty) == 0x000438, "Member 'ALocker::_searchEmpty' has a wrong offset!");
static_assert(offsetof(ALocker, _searchPlayer) == 0x000440, "Member 'ALocker::_searchPlayer' has a wrong offset!");
static_assert(offsetof(ALocker, _killerInteractionActor) == 0x000448, "Member 'ALocker::_killerInteractionActor' has a wrong offset!");
static_assert(offsetof(ALocker, _enterSneak) == 0x000450, "Member 'ALocker::_enterSneak' has a wrong offset!");
static_assert(offsetof(ALocker, _rootComponent) == 0x000458, "Member 'ALocker::_rootComponent' has a wrong offset!");
static_assert(offsetof(ALocker, _survivorCameraAttachmentComponent) == 0x000460, "Member 'ALocker::_survivorCameraAttachmentComponent' has a wrong offset!");
static_assert(offsetof(ALocker, _camperSocket) == 0x000468, "Member 'ALocker::_camperSocket' has a wrong offset!");
static_assert(offsetof(ALocker, _lockerAnimInstance) == 0x000478, "Member 'ALocker::_lockerAnimInstance' has a wrong offset!");
static_assert(offsetof(ALocker, _preventAllInteractions) == 0x0004C8, "Member 'ALocker::_preventAllInteractions' has a wrong offset!");
static_assert(offsetof(ALocker, _local_preventAllInteractions) == 0x0004C9, "Member 'ALocker::_local_preventAllInteractions' has a wrong offset!");
static_assert(offsetof(ALocker, _spawnedLockerItem) == 0x0004D0, "Member 'ALocker::_spawnedLockerItem' has a wrong offset!");
static_assert(offsetof(ALocker, _fastEnterInteractionTag) == 0x0004D8, "Member 'ALocker::_fastEnterInteractionTag' has a wrong offset!");
static_assert(offsetof(ALocker, _fastExitInteractionTag) == 0x0004E4, "Member 'ALocker::_fastExitInteractionTag' has a wrong offset!");
static_assert(offsetof(ALocker, _perceptionStimuliComponent) == 0x000560, "Member 'ALocker::_perceptionStimuliComponent' has a wrong offset!");

// Class DeadByDaylight.GeneratorTrapPerk
// 0x0000 (0x04A8 - 0x04A8)
class UGeneratorTrapPerk : public USurvivorTrapPerk
{
public:
	void Authority_OnExitGatesPowered(const struct FGameplayTag& GameEventTag, const struct FGameEventData& GameEventData);
	void Authority_OnGeneratorCompleted(bool IsAutoCompleted);
	void Client_OnTrapActivated(const class AGenerator* Generator);
	void Client_OnTrapDestroyed(const class AGenerator* Generator, const ETrapRemovedReason Reason);
	void Cosmetic_TrapActivated(const class AGenerator* Generator);
	void Cosmetic_TrapDestroyed(const class AGenerator* Generator, const ETrapRemovedReason Reason);

	float GetGeneratorTrapDuration() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GeneratorTrapPerk">();
	}
	static class UGeneratorTrapPerk* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGeneratorTrapPerk>();
	}
};
static_assert(alignof(UGeneratorTrapPerk) == 0x000008, "Wrong alignment on UGeneratorTrapPerk");
static_assert(sizeof(UGeneratorTrapPerk) == 0x0004A8, "Wrong size on UGeneratorTrapPerk");

// Class DeadByDaylight.DBDEmblem
// 0x0048 (0x00F0 - 0x00A8)
class UDBDEmblem : public UActorComponent
{
public:
	float                                         _points;                                           // 0x00A8(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FProgressionPoints>             _progressionPoints;                                // 0x00B0(0x0010)(Net, ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	struct FDataTableRowHandle                    _definition;                                       // 0x00C0(0x0018)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_D8[0x18];                                      // 0x00D8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Client_FinalizeReplication(const float Points, const TArray<struct FProgressionPoints>& ProgressionPoints);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDEmblem">();
	}
	static class UDBDEmblem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDEmblem>();
	}
};
static_assert(alignof(UDBDEmblem) == 0x000008, "Wrong alignment on UDBDEmblem");
static_assert(sizeof(UDBDEmblem) == 0x0000F0, "Wrong size on UDBDEmblem");
static_assert(offsetof(UDBDEmblem, _points) == 0x0000A8, "Member 'UDBDEmblem::_points' has a wrong offset!");
static_assert(offsetof(UDBDEmblem, _progressionPoints) == 0x0000B0, "Member 'UDBDEmblem::_progressionPoints' has a wrong offset!");
static_assert(offsetof(UDBDEmblem, _definition) == 0x0000C0, "Member 'UDBDEmblem::_definition' has a wrong offset!");

// Class DeadByDaylight.UsableWithPerkFlagPerkIconStrategy
// 0x0018 (0x0050 - 0x0038)
class UUsableWithPerkFlagPerkIconStrategy final : public UBasePerkIconStrategy
{
public:
	TArray<struct FGameplayTag>                   _perkTagsOnPlayer;                                 // 0x0038(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          _playerShouldHaveTags;                             // 0x0048(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UsableWithPerkFlagPerkIconStrategy">();
	}
	static class UUsableWithPerkFlagPerkIconStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUsableWithPerkFlagPerkIconStrategy>();
	}
};
static_assert(alignof(UUsableWithPerkFlagPerkIconStrategy) == 0x000008, "Wrong alignment on UUsableWithPerkFlagPerkIconStrategy");
static_assert(sizeof(UUsableWithPerkFlagPerkIconStrategy) == 0x000050, "Wrong size on UUsableWithPerkFlagPerkIconStrategy");
static_assert(offsetof(UUsableWithPerkFlagPerkIconStrategy, _perkTagsOnPlayer) == 0x000038, "Member 'UUsableWithPerkFlagPerkIconStrategy::_perkTagsOnPlayer' has a wrong offset!");
static_assert(offsetof(UUsableWithPerkFlagPerkIconStrategy, _playerShouldHaveTags) == 0x000048, "Member 'UUsableWithPerkFlagPerkIconStrategy::_playerShouldHaveTags' has a wrong offset!");

// Class DeadByDaylight.LanternLightCollectable
// 0x0008 (0x0558 - 0x0550)
class ALanternLightCollectable final : public ACollectable
{
public:
	class ALanternInteractable*                   _parentLantern;                                    // 0x0550(0x0008)(Net, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void SetParentLantern(class ALanternInteractable* ParentLantern);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LanternLightCollectable">();
	}
	static class ALanternLightCollectable* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALanternLightCollectable>();
	}
};
static_assert(alignof(ALanternLightCollectable) == 0x000008, "Wrong alignment on ALanternLightCollectable");
static_assert(sizeof(ALanternLightCollectable) == 0x000558, "Wrong size on ALanternLightCollectable");
static_assert(offsetof(ALanternLightCollectable, _parentLantern) == 0x000550, "Member 'ALanternLightCollectable::_parentLantern' has a wrong offset!");

// Class DeadByDaylight.SeancePerk
// 0x0018 (0x0438 - 0x0420)
class USeancePerk : public UPerk
{
public:
	TSubclassOf<class USeancePerformerComponent>  _seancePerformerComponentClass;                    // 0x0420(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UStatusEffect>              _brokenEffect;                                     // 0x0428(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EManifestationTarget                          _effectTarget;                                     // 0x0430(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isSeancePerformed;                                // 0x0431(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _destructivePerk;                                  // 0x0432(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_433[0x5];                                      // 0x0433(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SeancePerk">();
	}
	static class USeancePerk* GetDefaultObj()
	{
		return GetDefaultObjImpl<USeancePerk>();
	}
};
static_assert(alignof(USeancePerk) == 0x000008, "Wrong alignment on USeancePerk");
static_assert(sizeof(USeancePerk) == 0x000438, "Wrong size on USeancePerk");
static_assert(offsetof(USeancePerk, _seancePerformerComponentClass) == 0x000420, "Member 'USeancePerk::_seancePerformerComponentClass' has a wrong offset!");
static_assert(offsetof(USeancePerk, _brokenEffect) == 0x000428, "Member 'USeancePerk::_brokenEffect' has a wrong offset!");
static_assert(offsetof(USeancePerk, _effectTarget) == 0x000430, "Member 'USeancePerk::_effectTarget' has a wrong offset!");
static_assert(offsetof(USeancePerk, _isSeancePerformed) == 0x000431, "Member 'USeancePerk::_isSeancePerformed' has a wrong offset!");
static_assert(offsetof(USeancePerk, _destructivePerk) == 0x000432, "Member 'USeancePerk::_destructivePerk' has a wrong offset!");

// Class DeadByDaylight.AtlantaUtilities
// 0x0000 (0x0030 - 0x0030)
class UAtlantaUtilities final : public UBlueprintFunctionLibrary
{
public:
	static class FText GetAlantaInteractionDescriptionText(class UInteractionDefinition* Interaction);
	static class UInteractionDefinition* GetAvailableInteractionOfType(class ADBDPlayer* Player, EInputInteractionType InteractionInputType);
	static struct FSlateColor GetCurrencyColor(ECurrencyType CurrencyType);
	static class FString GetCurrencyUITexturePath(ECurrencyType CurrencyType);
	static class UInteractionDefinition* GetCurrentInteraction(class ADBDPlayer* Player);
	static class UInteractionDefinition* GetCurrentInteractionOfType(class ADBDPlayer* Player, EInputInteractionType InteractionInputType);
	static class UInteractionDefinition* GetCurrentOrAvailableInteractionOfType(class ADBDPlayer* Player, EInputInteractionType InteractionInputType);
	static class FText GetDifficultyLevelText(const EAIDifficultyLevel DifficultyLevel);
	static class FText GetEmblemQualityText(const EEmblemQuality EmblemQuality);
	static class UTexture2D* GetIconImageByPath(const class FString& IconPath);
	static class FText GetItemAvailabilityText(const EItemAvailability Availability);
	static class FText GetItemRarityText(const EItemRarity Rarity);
	static class UPaperSprite* GetMapSpriteFromPath(const class FString& MapSpritePath);
	static class FText GetOfferingCategoryText(const EOfferingCategory OfferingCategory);
	static class FText GetPlayerRoleText(const EPlayerRole PlayerRole);
	static class FText GetPlayerRoleTextUppercase(const EPlayerRole PlayerRole);
	static class UPaperSprite* GetSpriteFromFullPath(const class FString& FullSpritePath);
	static class UPaperSprite* GetSpriteFromPath(const class FString& FullDbPathToImage, const class FString& ConstantDbPathToImageFolder, const class FString& ConstantPathToSpriteFolder);
	static class FString GetStoreVersion();
	static bool IsPlayerInteractingWithActor(class ADBDPlayer* Player, const class AActor* Actor);
	static class UTexture2D* LoadTextureByAsset(const class FString& Path);
	static struct FSlateBrush MakeBrushFromSprite(class UPaperSprite* Sprite);
	static struct FSlateBrush MakeBrushFromTexture(class UTexture2D* Texture);
	static class FString SecondsToStringWithoutDecimals(const int32 Seconds);
	static void SetButtonStyle(class UButton* Button, const struct FSlateBrush& Brush);
	static void SetImageBrush(class UImage* Image, class UTexture2D* Asset, bool bMatchSize);
	static void SetImageBrushFromPath(class UImage* Image, const class FString& Path, bool bMatchSize);
	static void SetImageBrushFromSpritePath(class UImage* Image, const class FString& Path);
	static bool SetImageSlateBrush(class UImage* Image, const struct FSlateBrush& Brush, bool bMatchSize);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AtlantaUtilities">();
	}
	static class UAtlantaUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAtlantaUtilities>();
	}
};
static_assert(alignof(UAtlantaUtilities) == 0x000008, "Wrong alignment on UAtlantaUtilities");
static_assert(sizeof(UAtlantaUtilities) == 0x000030, "Wrong size on UAtlantaUtilities");

// Class DeadByDaylight.ImposeStatusEffectSeancePerk
// 0x0010 (0x0448 - 0x0438)
class UImposeStatusEffectSeancePerk : public USeancePerk
{
public:
	float                                         _effectAmount;                                     // 0x0438(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _effectLifetime;                                   // 0x043C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UStatusEffect>              _statusEffectClass;                                // 0x0440(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ImposeStatusEffectSeancePerk">();
	}
	static class UImposeStatusEffectSeancePerk* GetDefaultObj()
	{
		return GetDefaultObjImpl<UImposeStatusEffectSeancePerk>();
	}
};
static_assert(alignof(UImposeStatusEffectSeancePerk) == 0x000008, "Wrong alignment on UImposeStatusEffectSeancePerk");
static_assert(sizeof(UImposeStatusEffectSeancePerk) == 0x000448, "Wrong size on UImposeStatusEffectSeancePerk");
static_assert(offsetof(UImposeStatusEffectSeancePerk, _effectAmount) == 0x000438, "Member 'UImposeStatusEffectSeancePerk::_effectAmount' has a wrong offset!");
static_assert(offsetof(UImposeStatusEffectSeancePerk, _effectLifetime) == 0x00043C, "Member 'UImposeStatusEffectSeancePerk::_effectLifetime' has a wrong offset!");
static_assert(offsetof(UImposeStatusEffectSeancePerk, _statusEffectClass) == 0x000440, "Member 'UImposeStatusEffectSeancePerk::_statusEffectClass' has a wrong offset!");

// Class DeadByDaylight.Searchable
// 0x0150 (0x04F8 - 0x03A8)
class ASearchable : public AInteractable
{
public:
	uint8                                         Pad_3A8[0x28];                                     // 0x03A8(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Weight;                                            // 0x03D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D4[0x4];                                      // 0x03D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnSearchedChanged;                                 // 0x03D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class USearchableItemStrategy*                SearchableItemStrategy;                            // 0x03E8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USearchableSpawnPoint*                  _searchableSpawnPoint;                             // 0x03F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3F8[0x48];                                     // 0x03F8(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	class ACollectable*                           _spawnedItem;                                      // 0x0440(0x0008)(Net, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ACollectable*                           _itemInsideSearchable;                             // 0x0448(0x0008)(Net, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isOpened;                                         // 0x0450(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _hasBeenOpened;                                    // 0x0451(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_452[0x6];                                      // 0x0452(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class ADBDPlayer*, uint8>                _numberOfSearchesWhileOpenPerPlayer;               // 0x0458(0x0050)(Transient, NativeAccessSpecifierPrivate)
	class UBlockableComponent*                    _searchableBlockableComponent;                     // 0x04A8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ULocalPlayerTrackerComponent*           _localPlayerTracker;                               // 0x04B0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4B8[0x40];                                     // 0x04B8(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class ACollectable* Authority_SpawnObject(class ADBDPlayer* Player);
	void Cosmetic_OnBlockSearchable(class ADBDPlayer* Player);
	void Cosmetic_OnUnblockSearchable(class ADBDPlayer* Player);
	void Multicast_SetHasBeenSearched(bool HasBeenSearched);
	void OnLocallyObservedChanged();
	void OnRep_IsOpened();
	void OnSearchableBlockChanged();
	void OnSearchedChanged__DelegateSignature(bool Searched);
	void SetHasBeenSearched(bool NewHasBeenSearched);

	bool ContainsSpawnedItem() const;
	class UPrimitiveComponent* GetInteractorPrimitiveComponent() const;
	bool HasBeenSearched() const;
	bool IsSearchableBlockedForPlayer(const class ADBDPlayer* Player) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Searchable">();
	}
	static class ASearchable* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASearchable>();
	}
};
static_assert(alignof(ASearchable) == 0x000008, "Wrong alignment on ASearchable");
static_assert(sizeof(ASearchable) == 0x0004F8, "Wrong size on ASearchable");
static_assert(offsetof(ASearchable, Weight) == 0x0003D0, "Member 'ASearchable::Weight' has a wrong offset!");
static_assert(offsetof(ASearchable, OnSearchedChanged) == 0x0003D8, "Member 'ASearchable::OnSearchedChanged' has a wrong offset!");
static_assert(offsetof(ASearchable, SearchableItemStrategy) == 0x0003E8, "Member 'ASearchable::SearchableItemStrategy' has a wrong offset!");
static_assert(offsetof(ASearchable, _searchableSpawnPoint) == 0x0003F0, "Member 'ASearchable::_searchableSpawnPoint' has a wrong offset!");
static_assert(offsetof(ASearchable, _spawnedItem) == 0x000440, "Member 'ASearchable::_spawnedItem' has a wrong offset!");
static_assert(offsetof(ASearchable, _itemInsideSearchable) == 0x000448, "Member 'ASearchable::_itemInsideSearchable' has a wrong offset!");
static_assert(offsetof(ASearchable, _isOpened) == 0x000450, "Member 'ASearchable::_isOpened' has a wrong offset!");
static_assert(offsetof(ASearchable, _hasBeenOpened) == 0x000451, "Member 'ASearchable::_hasBeenOpened' has a wrong offset!");
static_assert(offsetof(ASearchable, _numberOfSearchesWhileOpenPerPlayer) == 0x000458, "Member 'ASearchable::_numberOfSearchesWhileOpenPerPlayer' has a wrong offset!");
static_assert(offsetof(ASearchable, _searchableBlockableComponent) == 0x0004A8, "Member 'ASearchable::_searchableBlockableComponent' has a wrong offset!");
static_assert(offsetof(ASearchable, _localPlayerTracker) == 0x0004B0, "Member 'ASearchable::_localPlayerTracker' has a wrong offset!");

// Class DeadByDaylight.VaultFastDefintion
// 0x0000 (0x07E0 - 0x07E0)
class UVaultFastDefintion : public UVaultDefinition
{
public:
	bool                                          _isMediumVault;                                    // 0x07D8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7D9[0x7];                                      // 0x07D9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VaultFastDefintion">();
	}
	static class UVaultFastDefintion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVaultFastDefintion>();
	}
};
static_assert(alignof(UVaultFastDefintion) == 0x000010, "Wrong alignment on UVaultFastDefintion");
static_assert(sizeof(UVaultFastDefintion) == 0x0007E0, "Wrong size on UVaultFastDefintion");
static_assert(offsetof(UVaultFastDefintion, _isMediumVault) == 0x0007D8, "Member 'UVaultFastDefintion::_isMediumVault' has a wrong offset!");

// Class DeadByDaylight.Totem
// 0x0140 (0x04E8 - 0x03A8)
class ATotem : public AInteractable
{
public:
	uint8                                         Pad_3A8[0x8];                                      // 0x03A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnTotemBound;                                      // 0x03B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C0[0x18];                                     // 0x03C0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           _boonAuraRevealColor;                              // 0x03D8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UTotemBoundPerk*>                _boundPerks;                                       // 0x03E8(0x0010)(ExportObject, Net, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	ETotemState                                   _totemState;                                       // 0x03F8(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3F9[0x7];                                      // 0x03F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _baseBoonTotemBlessingRange;                       // 0x0400(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _baseBoonTotemAuraRevealRange;                     // 0x0428(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_450[0x18];                                     // 0x0450(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UAIPerceptionStimuliSourceComponent*    _perceptionStimuliComponent;                       // 0x0468(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBlockableComponent*                    _totemBlockableComponent;                          // 0x0470(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_478[0x10];                                     // 0x0478(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class ULocalPlayerTrackerComponent*           _localPlayerTracker;                               // 0x0488(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UActivatorComponent*                    _activatorComponent;                               // 0x0490(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGameplayTagContainerComponent*         _objectState;                                      // 0x0498(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USceneComponent*                        _interactionsAttachPoint;                          // 0x04A0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTotemOutlineUpdateStrategy*            _totemOutlineUpdateStrategy;                       // 0x04A8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4B0[0x30];                                     // 0x04B0(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _canBeBoundToBoonPerk;                             // 0x04E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4E1[0x7];                                      // 0x04E1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_BindToPerk(class UTotemBoundPerk* Perk);
	void Authority_Cleanse();
	void Authority_UnbindFromAllPerks();
	void Authority_UnbindFromPerk(class UTotemBoundPerk* Perk);
	void BindingDelegate__DelegateSignature();
	void OnBlockTotemCosmetic(class ADBDPlayer* Player);
	void OnCleanseTotem(class ATotem* Totem, const ETotemState OldTotemState);
	void OnLocallyObservedChanged();
	void OnRep_TotemState(const ETotemState OldTotemState);
	void OnTotemBlockChanged();
	void OnTotemStateChanged(const ETotemState OldTotemState, const ETotemState NewTotemState);
	void OnUnblockTotemCosmetic(class ADBDPlayer* Player);

	class UAkComponent* GetAkAudioComponent() const;
	class UChargeableInteractionDefinition* GetBlessTotemInteraction() const;
	struct FLinearColor GetBoonAuraRevealColor() const;
	float GetBoonTotemAuraRevealRange() const;
	float GetBoonTotemBlessingRange() const;
	class UChargeableInteractionDefinition* GetCleanseTotemInteraction() const;
	class UInteractor* GetMainInteractor() const;
	ETotemState GetTotemState() const;
	bool IsBoundToPerk() const;
	bool IsTotemBlockedForPlayer(const class ADBDPlayer* Player) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Totem">();
	}
	static class ATotem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATotem>();
	}
};
static_assert(alignof(ATotem) == 0x000008, "Wrong alignment on ATotem");
static_assert(sizeof(ATotem) == 0x0004E8, "Wrong size on ATotem");
static_assert(offsetof(ATotem, OnTotemBound) == 0x0003B0, "Member 'ATotem::OnTotemBound' has a wrong offset!");
static_assert(offsetof(ATotem, _boonAuraRevealColor) == 0x0003D8, "Member 'ATotem::_boonAuraRevealColor' has a wrong offset!");
static_assert(offsetof(ATotem, _boundPerks) == 0x0003E8, "Member 'ATotem::_boundPerks' has a wrong offset!");
static_assert(offsetof(ATotem, _totemState) == 0x0003F8, "Member 'ATotem::_totemState' has a wrong offset!");
static_assert(offsetof(ATotem, _baseBoonTotemBlessingRange) == 0x000400, "Member 'ATotem::_baseBoonTotemBlessingRange' has a wrong offset!");
static_assert(offsetof(ATotem, _baseBoonTotemAuraRevealRange) == 0x000428, "Member 'ATotem::_baseBoonTotemAuraRevealRange' has a wrong offset!");
static_assert(offsetof(ATotem, _perceptionStimuliComponent) == 0x000468, "Member 'ATotem::_perceptionStimuliComponent' has a wrong offset!");
static_assert(offsetof(ATotem, _totemBlockableComponent) == 0x000470, "Member 'ATotem::_totemBlockableComponent' has a wrong offset!");
static_assert(offsetof(ATotem, _localPlayerTracker) == 0x000488, "Member 'ATotem::_localPlayerTracker' has a wrong offset!");
static_assert(offsetof(ATotem, _activatorComponent) == 0x000490, "Member 'ATotem::_activatorComponent' has a wrong offset!");
static_assert(offsetof(ATotem, _objectState) == 0x000498, "Member 'ATotem::_objectState' has a wrong offset!");
static_assert(offsetof(ATotem, _interactionsAttachPoint) == 0x0004A0, "Member 'ATotem::_interactionsAttachPoint' has a wrong offset!");
static_assert(offsetof(ATotem, _totemOutlineUpdateStrategy) == 0x0004A8, "Member 'ATotem::_totemOutlineUpdateStrategy' has a wrong offset!");
static_assert(offsetof(ATotem, _canBeBoundToBoonPerk) == 0x0004E0, "Member 'ATotem::_canBeBoundToBoonPerk' has a wrong offset!");

// Class DeadByDaylight.DBDGameFlowUtilities
// 0x0000 (0x0030 - 0x0030)
class UDBDGameFlowUtilities final : public UBlueprintFunctionLibrary
{
public:
	static bool IsCurrentlyInGame(const class UDBDGameInstance* GameInstance);
	static void TriggerUIFlowEvent(class UObject* WorldContextObject, EUIFlowEvent UiFlowEvent, bool ForceChange);
	static void TriggerWorldFlowEvent(class UObject* WorldContextObject, EWorldFlowEvent WorldFlowEvent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDGameFlowUtilities">();
	}
	static class UDBDGameFlowUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDGameFlowUtilities>();
	}
};
static_assert(alignof(UDBDGameFlowUtilities) == 0x000008, "Wrong alignment on UDBDGameFlowUtilities");
static_assert(sizeof(UDBDGameFlowUtilities) == 0x000030, "Wrong size on UDBDGameFlowUtilities");

// Class DeadByDaylight.QuestEventEvaluatorBase
// 0x0078 (0x00A8 - 0x0030)
class UQuestEventEvaluatorBase : public UObject
{
public:
	uint8                                         Pad_30[0x18];                                      // 0x0030(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class ADBDPlayer*                             _dbdPlayer;                                        // 0x0048(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_50[0xA];                                       // 0x0050(0x000A)(Fixing Size After Last Property [ Dumper-7 ])
	EConditionNeedsType                           _conditionNeedsType;                               // 0x005A(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5B[0x5];                                       // 0x005B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UEvaluatorCondition>> _evaluatorConditionsClass;                         // 0x0060(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<class UEvaluatorCondition*>            _evaluatorConditions;                              // 0x0070(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_80[0x28];                                      // 0x0080(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnGameEvent(const struct FGameplayTag& GameEventType, const struct FGameEventData& GameEventData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"QuestEventEvaluatorBase">();
	}
	static class UQuestEventEvaluatorBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UQuestEventEvaluatorBase>();
	}
};
static_assert(alignof(UQuestEventEvaluatorBase) == 0x000008, "Wrong alignment on UQuestEventEvaluatorBase");
static_assert(sizeof(UQuestEventEvaluatorBase) == 0x0000A8, "Wrong size on UQuestEventEvaluatorBase");
static_assert(offsetof(UQuestEventEvaluatorBase, _dbdPlayer) == 0x000048, "Member 'UQuestEventEvaluatorBase::_dbdPlayer' has a wrong offset!");
static_assert(offsetof(UQuestEventEvaluatorBase, _conditionNeedsType) == 0x00005A, "Member 'UQuestEventEvaluatorBase::_conditionNeedsType' has a wrong offset!");
static_assert(offsetof(UQuestEventEvaluatorBase, _evaluatorConditionsClass) == 0x000060, "Member 'UQuestEventEvaluatorBase::_evaluatorConditionsClass' has a wrong offset!");
static_assert(offsetof(UQuestEventEvaluatorBase, _evaluatorConditions) == 0x000070, "Member 'UQuestEventEvaluatorBase::_evaluatorConditions' has a wrong offset!");

// Class DeadByDaylight.SlasherOutlineUpdateStrategy
// 0x0080 (0x01C8 - 0x0148)
class USlasherOutlineUpdateStrategy final : public USourceBasedOutlineUpdateStrategy
{
public:
	FMulticastInlineDelegateProperty_             OnRevealed;                                        // 0x0148(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FLinearColor                           _revealedColor;                                    // 0x0158(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           _revealedColorForKiller;                           // 0x0168(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_178[0x50];                                     // 0x0178(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnLevelReadyToPlay();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SlasherOutlineUpdateStrategy">();
	}
	static class USlasherOutlineUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<USlasherOutlineUpdateStrategy>();
	}
};
static_assert(alignof(USlasherOutlineUpdateStrategy) == 0x000008, "Wrong alignment on USlasherOutlineUpdateStrategy");
static_assert(sizeof(USlasherOutlineUpdateStrategy) == 0x0001C8, "Wrong size on USlasherOutlineUpdateStrategy");
static_assert(offsetof(USlasherOutlineUpdateStrategy, OnRevealed) == 0x000148, "Member 'USlasherOutlineUpdateStrategy::OnRevealed' has a wrong offset!");
static_assert(offsetof(USlasherOutlineUpdateStrategy, _revealedColor) == 0x000158, "Member 'USlasherOutlineUpdateStrategy::_revealedColor' has a wrong offset!");
static_assert(offsetof(USlasherOutlineUpdateStrategy, _revealedColorForKiller) == 0x000168, "Member 'USlasherOutlineUpdateStrategy::_revealedColorForKiller' has a wrong offset!");

// Class DeadByDaylight.EvaluatorCondition
// 0x0018 (0x0048 - 0x0030)
class UEvaluatorCondition : public UObject
{
public:
	EConditionSubject                             _conditionSubject;                                 // 0x0030(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_31[0x17];                                      // 0x0031(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EvaluatorCondition">();
	}
	static class UEvaluatorCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEvaluatorCondition>();
	}
};
static_assert(alignof(UEvaluatorCondition) == 0x000008, "Wrong alignment on UEvaluatorCondition");
static_assert(sizeof(UEvaluatorCondition) == 0x000048, "Wrong size on UEvaluatorCondition");
static_assert(offsetof(UEvaluatorCondition, _conditionSubject) == 0x000030, "Member 'UEvaluatorCondition::_conditionSubject' has a wrong offset!");

// Class DeadByDaylight.ArchiveVignettesContainer
// 0x00D8 (0x0108 - 0x0030)
class UArchiveVignettesContainer final : public UObject
{
public:
	uint8                                         Pad_30[0xD8];                                      // 0x0030(0x00D8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArchiveVignettesContainer">();
	}
	static class UArchiveVignettesContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UArchiveVignettesContainer>();
	}
};
static_assert(alignof(UArchiveVignettesContainer) == 0x000008, "Wrong alignment on UArchiveVignettesContainer");
static_assert(sizeof(UArchiveVignettesContainer) == 0x000108, "Wrong size on UArchiveVignettesContainer");

// Class DeadByDaylight.SpecialBehaviourInteractable
// 0x0040 (0x03E8 - 0x03A8)
class ASpecialBehaviourInteractable : public AInteractable
{
public:
	uint8                                         Pad_3A8[0x30];                                     // 0x03A8(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class ADBDPlayerState>         _specialBehaviourOwner;                            // 0x03D8(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3E0[0x8];                                      // 0x03E0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_SpecialBehaviourOwner();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpecialBehaviourInteractable">();
	}
	static class ASpecialBehaviourInteractable* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASpecialBehaviourInteractable>();
	}
};
static_assert(alignof(ASpecialBehaviourInteractable) == 0x000008, "Wrong alignment on ASpecialBehaviourInteractable");
static_assert(sizeof(ASpecialBehaviourInteractable) == 0x0003E8, "Wrong size on ASpecialBehaviourInteractable");
static_assert(offsetof(ASpecialBehaviourInteractable, _specialBehaviourOwner) == 0x0003D8, "Member 'ASpecialBehaviourInteractable::_specialBehaviourOwner' has a wrong offset!");

// Class DeadByDaylight.NavArea_Drone
// 0x0000 (0x0050 - 0x0050)
class UNavArea_Drone final : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavArea_Drone">();
	}
	static class UNavArea_Drone* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavArea_Drone>();
	}
};
static_assert(alignof(UNavArea_Drone) == 0x000008, "Wrong alignment on UNavArea_Drone");
static_assert(sizeof(UNavArea_Drone) == 0x000050, "Wrong size on UNavArea_Drone");

// Class DeadByDaylight.DBDBaseHud
// 0x0010 (0x03A0 - 0x0390)
class ADBDBaseHud : public AHUD
{
public:
	class UFont*                                  _debugFont;                                        // 0x0390(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_398[0x8];                                      // 0x0398(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DBD_ShowAnimHud(bool Show);
	void ShowAnimHudBP();

	bool ShouldDrawAnimHud() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDBaseHud">();
	}
	static class ADBDBaseHud* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDBaseHud>();
	}
};
static_assert(alignof(ADBDBaseHud) == 0x000008, "Wrong alignment on ADBDBaseHud");
static_assert(sizeof(ADBDBaseHud) == 0x0003A0, "Wrong size on ADBDBaseHud");
static_assert(offsetof(ADBDBaseHud, _debugFont) == 0x000390, "Member 'ADBDBaseHud::_debugFont' has a wrong offset!");

// Class DeadByDaylight.ArmIKSensorComponent
// 0x0080 (0x0128 - 0x00A8)
class UArmIKSensorComponent : public UActorComponent
{
public:
	class USkeletalMeshComponent*                 _mesh;                                             // 0x00A8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<EArm, struct FArmIKSensorDatum>          _arms;                                             // 0x00B0(0x0050)(Edit, EditFixedSize, Protected, NativeAccessSpecifierProtected)
	float                                         _capsuleRadius;                                    // 0x0100(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _capsuleHalfHeight;                                // 0x0104(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _traceLength;                                      // 0x0108(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_10C[0x4];                                      // 0x010C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCameraComponent*                       _owningCamera;                                     // 0x0110(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_118[0x10];                                     // 0x0118(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArmIKSensorComponent">();
	}
	static class UArmIKSensorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UArmIKSensorComponent>();
	}
};
static_assert(alignof(UArmIKSensorComponent) == 0x000008, "Wrong alignment on UArmIKSensorComponent");
static_assert(sizeof(UArmIKSensorComponent) == 0x000128, "Wrong size on UArmIKSensorComponent");
static_assert(offsetof(UArmIKSensorComponent, _mesh) == 0x0000A8, "Member 'UArmIKSensorComponent::_mesh' has a wrong offset!");
static_assert(offsetof(UArmIKSensorComponent, _arms) == 0x0000B0, "Member 'UArmIKSensorComponent::_arms' has a wrong offset!");
static_assert(offsetof(UArmIKSensorComponent, _capsuleRadius) == 0x000100, "Member 'UArmIKSensorComponent::_capsuleRadius' has a wrong offset!");
static_assert(offsetof(UArmIKSensorComponent, _capsuleHalfHeight) == 0x000104, "Member 'UArmIKSensorComponent::_capsuleHalfHeight' has a wrong offset!");
static_assert(offsetof(UArmIKSensorComponent, _traceLength) == 0x000108, "Member 'UArmIKSensorComponent::_traceLength' has a wrong offset!");
static_assert(offsetof(UArmIKSensorComponent, _owningCamera) == 0x000110, "Member 'UArmIKSensorComponent::_owningCamera' has a wrong offset!");

// Class DeadByDaylight.LobbyPositionsSubsystem
// 0x00B8 (0x00F0 - 0x0038)
class ULobbyPositionsSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0xB8];                                      // 0x0038(0x00B8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LobbyPositionsSubsystem">();
	}
	static class ULobbyPositionsSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULobbyPositionsSubsystem>();
	}
};
static_assert(alignof(ULobbyPositionsSubsystem) == 0x000008, "Wrong alignment on ULobbyPositionsSubsystem");
static_assert(sizeof(ULobbyPositionsSubsystem) == 0x0000F0, "Wrong size on ULobbyPositionsSubsystem");

// Class DeadByDaylight.DBDAIUtilities
// 0x0000 (0x0030 - 0x0030)
class UDBDAIUtilities : public UBlueprintFunctionLibrary
{
public:
	static bool DrawDebugAINavigation();
	static bool DrawDebugAINavigationFilter();
	static bool DrawDebugAIPerception();
	static class UNavigationPath* FindPathWithAgentRadiusToActorSynchronously(class UObject* WorldContextObject, const struct FVector& PathStart, class AActor* GoalActor, float AgentRadius, float TetherDistance, class AActor* PathfindingContext, TSubclassOf<class UNavigationQueryFilter> FilterClass);
	static void SetCanEverAffectNavigation(class UActorComponent* Component, bool AffectNavigation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDAIUtilities">();
	}
	static class UDBDAIUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDAIUtilities>();
	}
};
static_assert(alignof(UDBDAIUtilities) == 0x000008, "Wrong alignment on UDBDAIUtilities");
static_assert(sizeof(UDBDAIUtilities) == 0x000030, "Wrong size on UDBDAIUtilities");

// Class DeadByDaylight.DBDPlayerState
// 0x0440 (0x0800 - 0x03C0)
class ADBDPlayerState : public APlayerState
{
public:
	uint8                                         Pad_3C0[0x8];                                      // 0x03C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnAIFinishedPlayingEvent;                          // 0x03C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class FString                                 MirrorsId;                                         // 0x03D8(0x0010)(Net, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ContentVersion;                                    // 0x03E8(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAIDifficultyLevel                            _difficultyLevel;                                  // 0x03F8(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsPlayerReady;                                     // 0x03F9(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerRole                                   GameRole;                                          // 0x03FA(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3FB[0x5];                                      // 0x03FB(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UDedicatedServerHandlerComponent*       DedicatedServerHandler;                            // 0x0400(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDSQuestEventsHandlerComponent*         DSQuestEventsHandler;                              // 0x0408(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCharacterStateData                    CamperData;                                        // 0x0410(0x0020)(Net, Transient, RepNotify, NativeAccessSpecifierPublic)
	struct FCharacterStateData                    SlasherData;                                       // 0x0430(0x0020)(Net, RepNotify, NativeAccessSpecifierPublic)
	struct FPlayerStateData                       PlayerData;                                        // 0x0450(0x0068)(Net, RepNotify, NativeAccessSpecifierPublic)
	uint8                                         Pad_4B8[0x8];                                      // 0x04B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnPlayerGameplayEvent;                             // 0x04C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPlayerGameStateChanged;                          // 0x04D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMap<class FName, struct FAwardedScores>      _awardedScoresByType;                              // 0x04E0(0x0050)(Protected, NativeAccessSpecifierProtected)
	struct FUserGameStats                         _cachedUserGameStats;                              // 0x0530(0x00B0)(Protected, NativeAccessSpecifierProtected)
	TArray<struct FOngoingScoreData>              _ongoingScoreEvents;                               // 0x05E0(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_5F0[0x8];                                      // 0x05F0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _inParadise;                                       // 0x05F8(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _endOfMatchRpcReceived;                            // 0x05F9(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5FA[0x6];                                      // 0x05FA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FEquippedPlayerCustomization           _playerCustomization;                              // 0x0600(0x0038)(Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	int32                                         _selectedCamperIndex;                              // 0x0638(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         _selectedSlasherIndex;                             // 0x063C(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGameplayNotificationManager*           _gameplayNotificationManager;                      // 0x0640(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCharacterStatsHandlerComponent*        _characterStatsHandler;                            // 0x0648(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPlayerScoreComponent*                  _playerScoreComponent;                             // 0x0650(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_658[0x20];                                     // 0x0658(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 _platformAccountId;                                // 0x0678(0x0010)(Net, ZeroConstructor, Transient, RepNotify, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 _EOSProductId;                                     // 0x0688(0x0010)(Net, ZeroConstructor, Transient, RepNotify, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_698[0x104];                                    // 0x0698(0x0104)(Fixing Size After Last Property [ Dumper-7 ])
	EPlatformFlag                                 _platform;                                         // 0x079C(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EProviderFlag                                 _provider;                                         // 0x07A0(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _crossplayAllowed;                                 // 0x07A4(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _offNetworkFlag;                                   // 0x07A5(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7A6[0x2];                                      // 0x07A6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FStreamerModePlayerData                _streamerModePlayerData;                           // 0x07A8(0x0008)(Net, Transient, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)
	bool                                          _gameLevelLoaded;                                  // 0x07B0(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7B1[0x17];                                     // 0x07B1(0x0017)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _showPortraitBorder;                               // 0x07C8(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7C9[0x2];                                      // 0x07C9(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _hasActiveSubscription;                            // 0x07CB(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint32                                        _matchmakingIncentive;                             // 0x07CC(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _pktLossPercentage;                                // 0x07D0(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7D4[0x4];                                      // 0x07D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDBotStateInfo                       _botInfo;                                          // 0x07D8(0x0020)(Net, Transient, RepNotify, NativeAccessSpecifierPrivate)
	int32                                         _disconnectedPlayerScore;                          // 0x07F8(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _hasActiveArchiveDSQuestUpdate;                    // 0x07FC(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7FD[0x3];                                      // 0x07FD(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_CancelOngoingScoreEvent(const struct FGameplayTag& ScoreTypeTag);
	void Authority_EndOngoingScoreEvent(const struct FGameplayTag& ScoreTypeTag);
	void Authority_HandleScoreEvent(const struct FGameplayTag& ScoreTypeTag, const struct FScoreEventData& ScoreEventData);
	void Authority_SetBotStateInfo(const struct FDBDBotStateInfo& Info);
	void Authority_SetPlayerGameState(EGameState NewGameState, bool IsEscapeHatch);
	void ChangeStartingGameRole(EPlayerRole Param_GameRole);
	void Client_FetchCoreRituals(bool HasClaimableRitual);
	void Client_FireQuestRepetitionValueChangeEvent(int32 Repetition, const class FString& QuestEventId);
	void Client_HandleEndOfMatch(bool Success, const struct FEndOfMatchRPCData& Response);
	void Client_HandleEscapeScoreEvent();
	void Client_InvalidateIncentives();
	void Client_RemotelyDispatchGameEvent(const struct FGameplayTag& GameEventType, const struct FGameEventData& GameEventData);
	void Client_RemotelyDispatchGameEventWithScore(const struct FGameplayTag& GameEventType, const struct FGameEventData& GameEventData, const struct FAwardedScore& AwardedScore);
	void Client_RemoveElementFromInventory(class FName ToRemove, bool UpdateLoadout);
	void Client_SetDSKickedOutReason(const uint32 Reason);
	void Client_SetGameRole(EPlayerRole NewRole);
	void Client_SetHasActiveArchiveDSQuestUpdate(bool IsEnabled);
	void Client_SetInParadise();
	void Client_UpdateWallet(const class FString& CurrencyId, int32 Amount);
	void FireActiveStatusEffectEvent(class FName StatusEffectId, float Percentage, int32 IconFilePathIndex, int32 LevelToDisplay);
	void FireActiveStatusViewEvent(class FName StatusViewID, class FName UniqueSourceID, const struct FStatusViewSource& StatusViewSource);
	void FireScoreEvent(EDBDScoreTypes ScoreType, float PercentToAward);
	void Multicast_FireGameplayEvent(EDBDScoreTypes PlayerGameplayEventType, float Amount, class AActor* Effector, class AActor* Target);
	void Multicast_FireGameplayEventWithScore(EDBDScoreTypes PlayerGameplayEventType, float Amount, class AActor* Effector, class AActor* Target, const struct FAwardedScore& AwardedScore);
	void Multicast_SetAsDisconnected(EBotReplacementState botReplacementState);
	void Multicast_SetAsLeftMatch(EBotReplacementState botReplacementState);
	void Multicast_SetInParadise();
	void Multicast_SetPlayerGameState(EGameState NewGameState, bool IsEscapeHatch);
	void OnRep_BotDifficultyLevel();
	void OnRep_BotInfo();
	void OnRep_CustomizationData();
	void OnRep_DisplayData();
	void Server_CheatSelectKiller(int32 SlasherIndex);
	void Server_CheatSelectSurvivor(int32 CamperIndex);
	void Server_SetQuestRepetitionByClientValue(int32 Repetition, const class FString& QuestEventId);
	void UpdateOngoingScores();

	const struct FDBDBotStateInfo GetBotStateInfo() const;
	class UGameplayNotificationManager* GetGameplayNotificationManager() const;
	EPlayerRole GetGameRole() const;
	EGameState GetPlayerGameState() const;
	bool HasEscaped() const;
	bool IsInFinishedPlayingState() const;
	bool IsReplacementBot() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDPlayerState">();
	}
	static class ADBDPlayerState* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDPlayerState>();
	}
};
static_assert(alignof(ADBDPlayerState) == 0x000008, "Wrong alignment on ADBDPlayerState");
static_assert(sizeof(ADBDPlayerState) == 0x000800, "Wrong size on ADBDPlayerState");
static_assert(offsetof(ADBDPlayerState, OnAIFinishedPlayingEvent) == 0x0003C8, "Member 'ADBDPlayerState::OnAIFinishedPlayingEvent' has a wrong offset!");
static_assert(offsetof(ADBDPlayerState, MirrorsId) == 0x0003D8, "Member 'ADBDPlayerState::MirrorsId' has a wrong offset!");
static_assert(offsetof(ADBDPlayerState, ContentVersion) == 0x0003E8, "Member 'ADBDPlayerState::ContentVersion' has a wrong offset!");
static_assert(offsetof(ADBDPlayerState, _difficultyLevel) == 0x0003F8, "Member 'ADBDPlayerState::_difficultyLevel' has a wrong offset!");
static_assert(offsetof(ADBDPlayerState, IsPlayerReady) == 0x0003F9, "Member 'ADBDPlayerState::IsPlayerReady' has a wrong offset!");
static_assert(offsetof(ADBDPlayerState, GameRole) == 0x0003FA, "Member 'ADBDPlayerState::GameRole' has a wrong offset!");
static_assert(offsetof(ADBDPlayerState, DedicatedServerHandler) == 0x000400, "Member 'ADBDPlayerState::DedicatedServerHandler' has a wrong offset!");
static_assert(offsetof(ADBDPlayerState, DSQuestEventsHandler) == 0x000408, "Member 'ADBDPlayerState::DSQuestEventsHandler' has a wrong offset!");
static_assert(offsetof(ADBDPlayerState, CamperData) == 0x000410, "Member 'ADBDPlayerState::CamperData' has a wrong offset!");
static_assert(offsetof(ADBDPlayerState, SlasherData) == 0x000430, "Member 'ADBDPlayerState::SlasherData' has a wrong offset!");
static_assert(offsetof(ADBDPlayerState, PlayerData) == 0x000450, "Member 'ADBDPlayerState::PlayerData' has a wrong offset!");
static_assert(offsetof(ADBDPlayerState, OnPlayerGameplayEvent) == 0x0004C0, "Member 'ADBDPlayerState::OnPlayerGameplayEvent' has a wrong offset!");
static_assert(offsetof(ADBDPlayerState, OnPlayerGameStateChanged) == 0x0004D0, "Member 'ADBDPlayerState::OnPlayerGameStateChanged' has a wrong offset!");
static_assert(offsetof(ADBDPlayerState, _awardedScoresByType) == 0x0004E0, "Member 'ADBDPlayerState::_awardedScoresByType' has a wrong offset!");
static_assert(offsetof(ADBDPlayerState, _cachedUserGameStats) == 0x000530, "Member 'ADBDPlayerState::_cachedUserGameStats' has a wrong offset!");
static_assert(offsetof(ADBDPlayerState, _ongoingScoreEvents) == 0x0005E0, "Member 'ADBDPlayerState::_ongoingScoreEvents' has a wrong offset!");
static_assert(offsetof(ADBDPlayerState, _inParadise) == 0x0005F8, "Member 'ADBDPlayerState::_inParadise' has a wrong offset!");
static_assert(offsetof(ADBDPlayerState, _endOfMatchRpcReceived) == 0x0005F9, "Member 'ADBDPlayerState::_endOfMatchRpcReceived' has a wrong offset!");
static_assert(offsetof(ADBDPlayerState, _playerCustomization) == 0x000600, "Member 'ADBDPlayerState::_playerCustomization' has a wrong offset!");
static_assert(offsetof(ADBDPlayerState, _selectedCamperIndex) == 0x000638, "Member 'ADBDPlayerState::_selectedCamperIndex' has a wrong offset!");
static_assert(offsetof(ADBDPlayerState, _selectedSlasherIndex) == 0x00063C, "Member 'ADBDPlayerState::_selectedSlasherIndex' has a wrong offset!");
static_assert(offsetof(ADBDPlayerState, _gameplayNotificationManager) == 0x000640, "Member 'ADBDPlayerState::_gameplayNotificationManager' has a wrong offset!");
static_assert(offsetof(ADBDPlayerState, _characterStatsHandler) == 0x000648, "Member 'ADBDPlayerState::_characterStatsHandler' has a wrong offset!");
static_assert(offsetof(ADBDPlayerState, _playerScoreComponent) == 0x000650, "Member 'ADBDPlayerState::_playerScoreComponent' has a wrong offset!");
static_assert(offsetof(ADBDPlayerState, _platformAccountId) == 0x000678, "Member 'ADBDPlayerState::_platformAccountId' has a wrong offset!");
static_assert(offsetof(ADBDPlayerState, _EOSProductId) == 0x000688, "Member 'ADBDPlayerState::_EOSProductId' has a wrong offset!");
static_assert(offsetof(ADBDPlayerState, _platform) == 0x00079C, "Member 'ADBDPlayerState::_platform' has a wrong offset!");
static_assert(offsetof(ADBDPlayerState, _provider) == 0x0007A0, "Member 'ADBDPlayerState::_provider' has a wrong offset!");
static_assert(offsetof(ADBDPlayerState, _crossplayAllowed) == 0x0007A4, "Member 'ADBDPlayerState::_crossplayAllowed' has a wrong offset!");
static_assert(offsetof(ADBDPlayerState, _offNetworkFlag) == 0x0007A5, "Member 'ADBDPlayerState::_offNetworkFlag' has a wrong offset!");
static_assert(offsetof(ADBDPlayerState, _streamerModePlayerData) == 0x0007A8, "Member 'ADBDPlayerState::_streamerModePlayerData' has a wrong offset!");
static_assert(offsetof(ADBDPlayerState, _gameLevelLoaded) == 0x0007B0, "Member 'ADBDPlayerState::_gameLevelLoaded' has a wrong offset!");
static_assert(offsetof(ADBDPlayerState, _showPortraitBorder) == 0x0007C8, "Member 'ADBDPlayerState::_showPortraitBorder' has a wrong offset!");
static_assert(offsetof(ADBDPlayerState, _hasActiveSubscription) == 0x0007CB, "Member 'ADBDPlayerState::_hasActiveSubscription' has a wrong offset!");
static_assert(offsetof(ADBDPlayerState, _matchmakingIncentive) == 0x0007CC, "Member 'ADBDPlayerState::_matchmakingIncentive' has a wrong offset!");
static_assert(offsetof(ADBDPlayerState, _pktLossPercentage) == 0x0007D0, "Member 'ADBDPlayerState::_pktLossPercentage' has a wrong offset!");
static_assert(offsetof(ADBDPlayerState, _botInfo) == 0x0007D8, "Member 'ADBDPlayerState::_botInfo' has a wrong offset!");
static_assert(offsetof(ADBDPlayerState, _disconnectedPlayerScore) == 0x0007F8, "Member 'ADBDPlayerState::_disconnectedPlayerScore' has a wrong offset!");
static_assert(offsetof(ADBDPlayerState, _hasActiveArchiveDSQuestUpdate) == 0x0007FC, "Member 'ADBDPlayerState::_hasActiveArchiveDSQuestUpdate' has a wrong offset!");

// Class DeadByDaylight.DBDPlayerState_Menu
// 0x0008 (0x0808 - 0x0800)
class ADBDPlayerState_Menu : public ADBDPlayerState
{
public:
	uint8                                         Pad_800[0x8];                                      // 0x0800(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Client_ChangeCharacterClass(const class FName& CharacterClass, const class FName& PreviousClass, const int32 CharacterId, int32 ClassChangeAttempt);
	void Multicast_SetSelectedCharacterCustomization(EPlayerRole ForRole, int32 ID, const struct FEquippedPlayerCustomization& Customization);
	void Multicast_SetSelectedCharacterId(EPlayerRole ForRole, int32 ID, bool UpdateDisplayData);
	void Server_NotifyOnRep();
	void Server_SetCharacterClass(const class FName& CharacterClass, const class FName& PreviousClass, const int32 CharacterId, int32 ClassChangeAttempt, bool CallOnRep);
	void Server_SetEquipment(ELoadoutSlot Slot, class FName ItemId, bool CallOnRep);
	void Server_SetEquipmentAddons(const TArray<class FName>& AddonItemIds, bool CallOnRep);
	void Server_SetSelectedCharacterId(int32 ID, bool UpdateDisplayData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDPlayerState_Menu">();
	}
	static class ADBDPlayerState_Menu* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDPlayerState_Menu>();
	}
};
static_assert(alignof(ADBDPlayerState_Menu) == 0x000008, "Wrong alignment on ADBDPlayerState_Menu");
static_assert(sizeof(ADBDPlayerState_Menu) == 0x000808, "Wrong size on ADBDPlayerState_Menu");

// Class DeadByDaylight.DBDPlayerState_Lobby
// 0x0008 (0x0810 - 0x0808)
class ADBDPlayerState_Lobby final : public ADBDPlayerState_Menu
{
public:
	bool                                          IsOwnershipValidated;                              // 0x0808(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_809[0x7];                                      // 0x0809(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDPlayerState_Lobby">();
	}
	static class ADBDPlayerState_Lobby* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDPlayerState_Lobby>();
	}
};
static_assert(alignof(ADBDPlayerState_Lobby) == 0x000008, "Wrong alignment on ADBDPlayerState_Lobby");
static_assert(sizeof(ADBDPlayerState_Lobby) == 0x000810, "Wrong size on ADBDPlayerState_Lobby");
static_assert(offsetof(ADBDPlayerState_Lobby, IsOwnershipValidated) == 0x000808, "Member 'ADBDPlayerState_Lobby::IsOwnershipValidated' has a wrong offset!");

// Class DeadByDaylight.GameplayModifierCondition
// 0x0000 (0x00C0 - 0x00C0)
class UGameplayModifierCondition : public UBaseModifierCondition
{
public:
	void OnOwningGameplayModifierSet();
	void SetOwningGameplayModifier(class UGameplayModifierContainer* OwningGameplayModifier);

	class UGameplayModifierContainer* GetOwningGameplayModifier() const;
	class ADBDPlayer* GetOwningPlayer() const;
	bool IsApplicable() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayModifierCondition">();
	}
	static class UGameplayModifierCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayModifierCondition>();
	}
};
static_assert(alignof(UGameplayModifierCondition) == 0x000008, "Wrong alignment on UGameplayModifierCondition");
static_assert(sizeof(UGameplayModifierCondition) == 0x0000C0, "Wrong size on UGameplayModifierCondition");

// Class DeadByDaylight.AISense_UnclearHearing
// 0x0060 (0x00F0 - 0x0090)
class UAISense_UnclearHearing final : public UAISense
{
public:
	TArray<struct FAIUnclearNoiseEvent>           NoiseEvents;                                       // 0x0090(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_A0[0x50];                                      // 0x00A0(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void ReportUnclearNoiseEvent(class UObject* WorldContextObject, const struct FVector& NoiseLocation, float Loudness, class AActor* Instigator, float MaxRange, class FName Tag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISense_UnclearHearing">();
	}
	static class UAISense_UnclearHearing* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISense_UnclearHearing>();
	}
};
static_assert(alignof(UAISense_UnclearHearing) == 0x000008, "Wrong alignment on UAISense_UnclearHearing");
static_assert(sizeof(UAISense_UnclearHearing) == 0x0000F0, "Wrong size on UAISense_UnclearHearing");
static_assert(offsetof(UAISense_UnclearHearing, NoiseEvents) == 0x000090, "Member 'UAISense_UnclearHearing::NoiseEvents' has a wrong offset!");

// Class DeadByDaylight.AnimationPreview
// 0x00E0 (0x0110 - 0x0030)
class UAnimationPreview : public UObject
{
public:
	TArray<struct FAnimationPreviewCharacter>     Characters;                                        // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FAnimationPreviewProp>          Props;                                             // 0x0040(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x38];                                      // 0x0050(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAnimationPreviewRequest               _request;                                          // 0x0088(0x0058)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_E0[0x30];                                      // 0x00E0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAnimationStartFadeOutComplete();
	void OnFadeInComplete();
	void OnFadeOutForCompletionComplete(bool Succeeded);
	void OnRequiredClassesLoaded();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimationPreview">();
	}
	static class UAnimationPreview* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimationPreview>();
	}
};
static_assert(alignof(UAnimationPreview) == 0x000008, "Wrong alignment on UAnimationPreview");
static_assert(sizeof(UAnimationPreview) == 0x000110, "Wrong size on UAnimationPreview");
static_assert(offsetof(UAnimationPreview, Characters) == 0x000030, "Member 'UAnimationPreview::Characters' has a wrong offset!");
static_assert(offsetof(UAnimationPreview, Props) == 0x000040, "Member 'UAnimationPreview::Props' has a wrong offset!");
static_assert(offsetof(UAnimationPreview, _request) == 0x000088, "Member 'UAnimationPreview::_request' has a wrong offset!");

// Class DeadByDaylight.InteractionAnimationPreview
// 0x0008 (0x0118 - 0x0110)
class UInteractionAnimationPreview : public UAnimationPreview
{
public:
	class UInteractionDefinition*                 _interactionDefinition;                            // 0x0110(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnInteractionFinished(class ADBDPlayer* Player, bool DidInteractionStart);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionAnimationPreview">();
	}
	static class UInteractionAnimationPreview* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionAnimationPreview>();
	}
};
static_assert(alignof(UInteractionAnimationPreview) == 0x000008, "Wrong alignment on UInteractionAnimationPreview");
static_assert(sizeof(UInteractionAnimationPreview) == 0x000118, "Wrong size on UInteractionAnimationPreview");
static_assert(offsetof(UInteractionAnimationPreview, _interactionDefinition) == 0x000110, "Member 'UInteractionAnimationPreview::_interactionDefinition' has a wrong offset!");

// Class DeadByDaylight.MoriAnimationPreview
// 0x0028 (0x0140 - 0x0118)
class UMoriAnimationPreview : public UInteractionAnimationPreview
{
public:
	uint8                                         Pad_118[0x28];                                     // 0x0118(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAudioEventFinished(EAkCallbackType CallbackType, class UAkCallbackInfo* CallbackInfo);
	void OnMontageStarted(const struct FAnimationMontageDescriptor& AnimMontageID, float PlayRate);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoriAnimationPreview">();
	}
	static class UMoriAnimationPreview* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoriAnimationPreview>();
	}
};
static_assert(alignof(UMoriAnimationPreview) == 0x000008, "Wrong alignment on UMoriAnimationPreview");
static_assert(sizeof(UMoriAnimationPreview) == 0x000140, "Wrong size on UMoriAnimationPreview");

// Class DeadByDaylight.TwinsMoriAnimationPreview
// 0x0000 (0x0140 - 0x0140)
class UTwinsMoriAnimationPreview final : public UMoriAnimationPreview
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TwinsMoriAnimationPreview">();
	}
	static class UTwinsMoriAnimationPreview* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTwinsMoriAnimationPreview>();
	}
};
static_assert(alignof(UTwinsMoriAnimationPreview) == 0x000008, "Wrong alignment on UTwinsMoriAnimationPreview");
static_assert(sizeof(UTwinsMoriAnimationPreview) == 0x000140, "Wrong size on UTwinsMoriAnimationPreview");

// Class DeadByDaylight.Tile
// 0x01C0 (0x0460 - 0x02A0)
class ATile : public AActor
{
public:
	uint8                                         Pad_2A0[0x8];                                      // 0x02A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          RerunConstructionScript;                           // 0x02A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A9[0x3];                                      // 0x02A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MinimumSpacing;                                    // 0x02AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaximumSpacing;                                    // 0x02B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DiagonalSpacing;                                   // 0x02B4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TypeSpacing;                                       // 0x02B5(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B6[0x2];                                      // 0x02B6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaximumCount;                                      // 0x02B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BC[0x4];                                      // 0x02BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              Dimension;                                         // 0x02C0(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EscapeStrategyType>                    AvailableEscapeTypes;                              // 0x02D0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	ETileType                                     Type;                                              // 0x02E0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDensity                                      Density;                                           // 0x02E1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPathType                                     Path;                                              // 0x02E2(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E3[0x1];                                      // 0x02E3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Number;                                            // 0x02E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          PlaceHolder;                                       // 0x02E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Replacement;                                       // 0x02E9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2EA[0x2];                                      // 0x02EA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SpawnPriorityTier;                                 // 0x02EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        Weight;                                            // 0x02F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Coord;                                             // 0x02F8(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EQuadrantSpawnType                            QuadrantSpawnType;                                 // 0x0308(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBasementType                                 BasementType;                                      // 0x0309(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30A[0x6];                                      // 0x030A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UTileSpawnPoint*>                SpawnPointsCache;                                  // 0x0310(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UObjectRandomizer*>              ObjectRandomizersCache;                            // 0x0320(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UActorSpawner*>                  ActorSpawnersCache;                                // 0x0330(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UActorVariationSpawner*>         ActorVariationSpawnersCache;                       // 0x0340(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_350[0x7C];                                     // 0x0350(0x007C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRandomStream                          SharedTileRandomizer;                              // 0x03CC(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          IsOutOfWorldTile;                                  // 0x03D4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseTileEventSpawnerSettingOverride;                // 0x03D5(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D6[0x2];                                      // 0x03D6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTileEventSpawnerSettingData           TileEventSpawnerSettingOverride;                   // 0x03D8(0x0028)(Edit, NativeAccessSpecifierPublic)
	bool                                          _initialized;                                      // 0x0400(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_401[0x5F];                                     // 0x0401(0x005F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitOnSpawned();
	void OnAllTileSpawned();
	void OnRep_Initialized(bool OldValue);
	void OnSetSpawnObject(class UTileSpawnPoint* TileSpawnPoint, class AActor* SpawnedObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Tile">();
	}
	static class ATile* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATile>();
	}
};
static_assert(alignof(ATile) == 0x000008, "Wrong alignment on ATile");
static_assert(sizeof(ATile) == 0x000460, "Wrong size on ATile");
static_assert(offsetof(ATile, RerunConstructionScript) == 0x0002A8, "Member 'ATile::RerunConstructionScript' has a wrong offset!");
static_assert(offsetof(ATile, MinimumSpacing) == 0x0002AC, "Member 'ATile::MinimumSpacing' has a wrong offset!");
static_assert(offsetof(ATile, MaximumSpacing) == 0x0002B0, "Member 'ATile::MaximumSpacing' has a wrong offset!");
static_assert(offsetof(ATile, DiagonalSpacing) == 0x0002B4, "Member 'ATile::DiagonalSpacing' has a wrong offset!");
static_assert(offsetof(ATile, TypeSpacing) == 0x0002B5, "Member 'ATile::TypeSpacing' has a wrong offset!");
static_assert(offsetof(ATile, MaximumCount) == 0x0002B8, "Member 'ATile::MaximumCount' has a wrong offset!");
static_assert(offsetof(ATile, Dimension) == 0x0002C0, "Member 'ATile::Dimension' has a wrong offset!");
static_assert(offsetof(ATile, AvailableEscapeTypes) == 0x0002D0, "Member 'ATile::AvailableEscapeTypes' has a wrong offset!");
static_assert(offsetof(ATile, Type) == 0x0002E0, "Member 'ATile::Type' has a wrong offset!");
static_assert(offsetof(ATile, Density) == 0x0002E1, "Member 'ATile::Density' has a wrong offset!");
static_assert(offsetof(ATile, Path) == 0x0002E2, "Member 'ATile::Path' has a wrong offset!");
static_assert(offsetof(ATile, Number) == 0x0002E4, "Member 'ATile::Number' has a wrong offset!");
static_assert(offsetof(ATile, PlaceHolder) == 0x0002E8, "Member 'ATile::PlaceHolder' has a wrong offset!");
static_assert(offsetof(ATile, Replacement) == 0x0002E9, "Member 'ATile::Replacement' has a wrong offset!");
static_assert(offsetof(ATile, SpawnPriorityTier) == 0x0002EC, "Member 'ATile::SpawnPriorityTier' has a wrong offset!");
static_assert(offsetof(ATile, Weight) == 0x0002F0, "Member 'ATile::Weight' has a wrong offset!");
static_assert(offsetof(ATile, Coord) == 0x0002F8, "Member 'ATile::Coord' has a wrong offset!");
static_assert(offsetof(ATile, QuadrantSpawnType) == 0x000308, "Member 'ATile::QuadrantSpawnType' has a wrong offset!");
static_assert(offsetof(ATile, BasementType) == 0x000309, "Member 'ATile::BasementType' has a wrong offset!");
static_assert(offsetof(ATile, SpawnPointsCache) == 0x000310, "Member 'ATile::SpawnPointsCache' has a wrong offset!");
static_assert(offsetof(ATile, ObjectRandomizersCache) == 0x000320, "Member 'ATile::ObjectRandomizersCache' has a wrong offset!");
static_assert(offsetof(ATile, ActorSpawnersCache) == 0x000330, "Member 'ATile::ActorSpawnersCache' has a wrong offset!");
static_assert(offsetof(ATile, ActorVariationSpawnersCache) == 0x000340, "Member 'ATile::ActorVariationSpawnersCache' has a wrong offset!");
static_assert(offsetof(ATile, SharedTileRandomizer) == 0x0003CC, "Member 'ATile::SharedTileRandomizer' has a wrong offset!");
static_assert(offsetof(ATile, IsOutOfWorldTile) == 0x0003D4, "Member 'ATile::IsOutOfWorldTile' has a wrong offset!");
static_assert(offsetof(ATile, UseTileEventSpawnerSettingOverride) == 0x0003D5, "Member 'ATile::UseTileEventSpawnerSettingOverride' has a wrong offset!");
static_assert(offsetof(ATile, TileEventSpawnerSettingOverride) == 0x0003D8, "Member 'ATile::TileEventSpawnerSettingOverride' has a wrong offset!");
static_assert(offsetof(ATile, _initialized) == 0x000400, "Member 'ATile::_initialized' has a wrong offset!");

// Class DeadByDaylight.BorderTile
// 0x0020 (0x0480 - 0x0460)
class ABorderTile : public ATile
{
public:
	TArray<struct FBorderElements>                Borders;                                           // 0x0460(0x0010)(Edit, BlueprintVisible, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UMapData*                               _map;                                              // 0x0470(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_478[0x8];                                      // 0x0478(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BorderTile">();
	}
	static class ABorderTile* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABorderTile>();
	}
};
static_assert(alignof(ABorderTile) == 0x000008, "Wrong alignment on ABorderTile");
static_assert(sizeof(ABorderTile) == 0x000480, "Wrong size on ABorderTile");
static_assert(offsetof(ABorderTile, Borders) == 0x000460, "Member 'ABorderTile::Borders' has a wrong offset!");
static_assert(offsetof(ABorderTile, _map) == 0x000470, "Member 'ABorderTile::_map' has a wrong offset!");

// Class DeadByDaylight.DBDGameState
// 0x0760 (0x0A80 - 0x0320)
class ADBDGameState : public AGameState
{
public:
	uint8                                         Pad_320[0x88];                                     // 0x0320(0x0088)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnEscapeDoorActivated;                             // 0x03A8(0x0010)(ZeroConstructor, Transient, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B8[0xA8];                                     // 0x03B8(0x00A8)(Fixing Size After Last Property [ Dumper-7 ])
	EIntroState                                   IntroState;                                        // 0x0460(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_461[0x7];                                      // 0x0461(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnKillerIntroCompletePercentChanged;               // 0x0468(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnLightingGenerated;                               // 0x0478(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_488[0x30];                                     // 0x0488(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class USpecialEventGameplaySpawnerComponent*  _specialEventGameplaySpawnerComponent;             // 0x04B8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USpecialBehaviourGameplaySpawnerComponent* _specialBehaviourGameplaySpawnerComponent;         // 0x04C0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             AuthorityOnAllPlayerLoaded;                        // 0x04C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D8[0x18];                                     // 0x04D8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnSlasherSet;                                      // 0x04F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_500[0x18];                                     // 0x0500(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnObsessionChanged;                                // 0x0518(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	int32                                         SecondsLeftInLobby;                                // 0x0528(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_52C[0x4C];                                     // 0x052C(0x004C)(Fixing Size After Last Property [ Dumper-7 ])
	class ASlasherPlayer*                         Slasher;                                           // 0x0578(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URenderingFeaturesSequencer*            _renderingSequencer;                               // 0x0580(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_588[0x48];                                     // 0x0588(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _camperHookedInBasementCount;                      // 0x05D0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5D4[0x8];                                      // 0x05D4(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	EServerUseNetAsyncLoading                     _useNetAsyncLoading;                               // 0x05DC(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _gameLevelLoadingStarted;                          // 0x05DD(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5DE[0x2];                                      // 0x05DE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBuiltLevelData                        _builtLevelData;                                   // 0x05E0(0x00B8)(Net, Transient, RepNotify, NativeAccessSpecifierPrivate)
	struct FOfferingData                          _levelOfferings;                                   // 0x0698(0x0018)(Net, Transient, NativeAccessSpecifierPrivate)
	class AClipManager*                           _clipManager;                                      // 0x06B0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AFadeManager*                           _fadeManager;                                      // 0x06B8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGuid                                  _sessionId;                                        // 0x06C0(0x0010)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGuid                                  _lobbyId;                                          // 0x06D0(0x0010)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class AGameObjectiveBase*>             _gameObjectives;                                   // 0x06E0(0x0010)(Net, ZeroConstructor, Transient, RepNotify, NativeAccessSpecifierPrivate)
	bool                                          _escapeDoorActivated;                              // 0x06F0(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _escapeDoorOpened;                                 // 0x06F1(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isHatchOpen;                                      // 0x06F2(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _levelReadyToPlay;                                 // 0x06F3(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _playerDistributionReady;                          // 0x06F4(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _usingWeakenedMechanic;                            // 0x06F5(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6F6[0x2];                                      // 0x06F6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _survivorLeft;                                     // 0x06F8(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6FC[0x4];                                      // 0x06FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AMeatHook*>                      _meatHooks;                                        // 0x0700(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class ASearchable*>                    _searchables;                                      // 0x0710(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class AGenerator*>                     _generators;                                       // 0x0720(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class AEscapeDoor*>                    _escapeDoors;                                      // 0x0730(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class AHatch*>                         _hatches;                                          // 0x0740(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class AReverseBearTrapRemover*>        _reverseBearTrapRemovers;                          // 0x0750(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class ABaseTrap*>                      _baseTraps;                                        // 0x0760(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class APallet*>                        _pallets;                                          // 0x0770(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class AWindow*>                        _windows;                                          // 0x0780(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class ALocker*>                        _lockers;                                          // 0x0790(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class ABreakableBase*>                 _breakableWalls;                                   // 0x07A0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class ATotem*>                         _totems;                                           // 0x07B0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	struct FBoxSphereBounds                       _mapBoxSphereBounds;                               // 0x07C0(0x0038)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	struct FBoxSphereBounds                       _basementBoxSphereBounds;                          // 0x07F8(0x0038)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_830[0x1C];                                     // 0x0830(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _camperEscapedThroughHatch;                        // 0x084C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ACamperPlayer*                          _obsessionTarget;                                  // 0x0850(0x0008)(Net, ZeroConstructor, Transient, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _cachedObsessionEscaped;                           // 0x0858(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_859[0x7];                                      // 0x0859(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	int8                                          _numberOfSurvivorsKilledOrSacrificed;              // 0x0860(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_861[0x7];                                      // 0x0861(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AInteractable*>                  _traps;                                            // 0x0868(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class UDBDDangerPredictionComponent*>  _dangerPredictionObjects;                          // 0x0878(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_888[0x8];                                      // 0x0888(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGamePresetData                        _gamePresetData;                                   // 0x0890(0x0090)(Net, Transient, RepNotify, NativeAccessSpecifierPrivate)
	bool                                          _gameLevelLoaded;                                  // 0x0920(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _gameLevelCreated;                                 // 0x0921(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _gameLevelEnded;                                   // 0x0922(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _gameTimedOut;                                     // 0x0923(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EEndGameReason                                _gameEndedReason;                                  // 0x0924(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isLoadoutFrozen;                                  // 0x0925(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_926[0x2];                                      // 0x0926(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class UEndGameStateComponent*                 _endGameState;                                     // 0x0928(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UScourgeHookManagerComponent*           _scourgeHookManager;                               // 0x0930(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UActorPairQueryEvaluatorComponent*      _actorPairQueryEvaluatorComponent;                 // 0x0938(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHudStateComponent*                     _hudStateComponent;                                // 0x0940(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_948[0x8];                                      // 0x0948(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UCharacterCollection*                   _characterCollection;                              // 0x0950(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCollectableCollection*                 _collectableCollection;                            // 0x0958(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UServerTimeProviderComponent*           _serverTimeProvider;                               // 0x0960(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInGameAssetPreloaderComponent*         _inGameAssetPreloaderComponent;                    // 0x0968(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOnScreenDebugComponent*                _onScreenDebugComponent;                           // 0x0970(0x0008)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_978[0x28];                                     // 0x0978(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              _matchStartTime;                                   // 0x09A0(0x0008)(Net, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isServerDedicated;                                // 0x09A8(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_9A9[0x3];                                      // 0x09A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _maxSurvivorCount;                                 // 0x09AC(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 _serverBuildVersion;                               // 0x09B0(0x0010)(Net, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 _serverContentVersion;                             // 0x09C0(0x0010)(Net, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 _serverSessionId;                                  // 0x09D0(0x0010)(Net, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 _serverRegion;                                     // 0x09E0(0x0010)(Net, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 _serverMatchId;                                    // 0x09F0(0x0010)(Net, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _introDuration;                                    // 0x0A00(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _leaveSpectateRequested;                           // 0x0A04(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A05[0x3];                                      // 0x0A05(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _eventTrackerObjectiveLevel;                       // 0x0A08(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         _hatchVisibleSurvivorThreshold;                    // 0x0A0C(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A10[0x70];                                     // 0x0A10(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddDangerPredictionObject(class UDBDDangerPredictionComponent* ToAdd);
	void AddTrap(class AInteractable* ToAdd);
	void Authority_DeactivateAI();
	void Authority_EnableObsession();
	void Authority_EscapeThroughHatch();
	void Authority_EvaluateObsessionTarget(class ADBDPlayer* PotentialTarget);
	void Authority_OnPlayerGameStateChangedAddIfKilled(class ADBDPlayerState* PlayerState, EGameState GameState);
	void Authority_SetAllPlayerLoaded();
	void Authority_SetBuiltLevelData(const struct FBuiltLevelData& BuiltLevelData);
	void Authority_SetEscapeDoorOpened(bool OPENED);
	void Authority_SetGameLevelCreated();
	void Authority_SetGameLevelEnded(EEndGameReason EndGameReason);
	void Authority_SetGameLevelLoaded();
	void Authority_SetGameSelectedOffering(const TArray<struct FSelectedOffering>& Offerings);
	void Authority_SetGameStarted();
	void Authority_SetLevelReadyToPlay();
	void Authority_SetObsessionTarget(class ACamperPlayer* ObsessionTarget);
	void Authority_SetSurvivorLeft(int32 SurvivorRemaining);
	void Authority_SignalEscapeDoorActivated(bool NewEscapeDoorActivated);
	void Authority_UnsetLevelReadyToPlay();
	void Authority_UpdateHatchState();
	void BroadcastOnSetBuildLevelData();
	void CallOnIntroComplete(TDelegate<void()> Callback);
	void OnIntroCompleteDelegate__DelegateSignature();
	void CallOnLevelReadyToPlay(TDelegate<void()> Callback);
	void OnLevelReadyToPlayDelegate__DelegateSignature();
	void CallOnSlasherSet(TDelegate<void(class ASlasherPlayer* Slasher)> Callback);
	const TArray<class UDBDDangerPredictionComponent*> GetDangerPredictionObjects(const bool IsObjectDynamic);
	void IntroCompleted();
	bool IsObsessionTargetAlive();
	bool IsObsessionTargetAliveInLevel();
	void Multicast_BroadcastOnLevelLoadingTimeOutClientEvent();
	void Multicast_OnGameStarted();
	void Multicast_SendEnsureToClients(const class FString& Ensure);
	void Multicast_SendHVSPlusState(bool Enabled);
	void Multicast_SetBuiltLevelData(const struct FBuiltLevelData& BuiltLevelData);
	void Multicast_SetGameEnded(bool HasServerLeftGame);
	void Multicast_SetGameLevelEnded(EEndGameReason EndGameReason);
	void Multicast_SetGameLevelLoaded(bool GameLevelLoaded);
	void Multicast_SetLostServerConnection(bool HasLostServerConnection);
	void Multicast_SetServerLeftGame(bool HasServerLeftGame);
	void Multicast_UpdateCharacterFromGamePreset(class ADBDPlayerState_Menu* PlayerState_Menu, const struct FGamePresetData& GamePresetData);
	void OnRep_BuildLevelData();
	void OnRep_EscapeDoorActivated(bool OldValue);
	void OnRep_GameLevelLoadingStarted(bool OldValue);
	void OnRep_GameObjectives(const TArray<class AGameObjectiveBase*>& OldArray);
	void OnRep_GamePresetData();
	void OnRep_LobbyId();
	void OnRep_NumberOfSurvivorsKilledOrSacrificed();
	void OnRep_ObsessionTarget(class ACamperPlayer* PreviousObsessionTarget);
	void OnRep_OnGameLevelCreated();
	void OnRep_OnLevelReadyToPlay();
	void OnRep_SecondsLeftInLobby(const int32 OldValue);
	void OnRep_SessionId();
	void OnRep_SurvivorLeft(int32 OldValue);
	void OnRep_UseNetAsyncLoading();
	void OnSlasherSetMultiDelegate__DelegateSignature(class ASlasherPlayer* SlasherPlayer);
	void RemoveDangerPredictionObject(class UDBDDangerPredictionComponent* ToRemove);
	void RemoveTrap(class AInteractable* ToRemove);
	void ResetGameLevelStatus();
	void Server_UpdateGameRole();
	void SetDisplayMapName(bool Display);
	void SetGameLevelEnded(EEndGameReason EndGameReason);
	void SetKillerIntroCompletedNormalized(float CompletedAmount);
	void SetPlayersReadyToStart(bool PlayersReadyToStart);
	void SortOfferings();
	void UnregisterFromIntroCompleteAndLevelReadyToPlay(const class UObject* InObject);

	const TArray<class UDBDDangerPredictionComponent*> GetAllDangerPredictionObjects() const;
	class UCharacterCollection* GetCharacterCollection() const;
	class UCollectableCollection* GetCollectableCollection() const;
	class UEndGameStateComponent* GetEndGameStateComponent() const;
	bool GetGameLevelLoaded() const;
	bool GetGameLevelLoadingStarted() const;
	const TArray<class ABaseTrap*> GetInGameBaseTraps() const;
	const TArray<class AEscapeDoor*> GetInGameEscapeDoors() const;
	const TArray<class AGenerator*> GetInGameGenerators() const;
	const TArray<class AHatch*> GetInGameHatches() const;
	const TArray<class AMeatHook*> GetInGameMeatHooks() const;
	const TArray<class APallet*> GetInGamePallets() const;
	const TArray<class AReverseBearTrapRemover*> GetInGameReverseBearTrapRemovers() const;
	const TArray<class ASearchable*> GetInGameSearchables() const;
	const TArray<class AWindow*> GetInGameWindows() const;
	bool GetIsGameEnded() const;
	class ASlasherPlayer* GetKiller() const;
	float GetKillerIntroCompletedNormalized() const;
	const struct FBuiltLevelData GetLevelData() const;
	TSoftObjectPtr<class UAkAudioBank> GetLevelThemeAudioSoundBankAssetPtr() const;
	class APawn* GetLocalPlayerBasePawn() const;
	class ADBDPlayer* GetLocalPlayerPawn() const;
	class FName GetMapThemeName() const;
	int32 GetNumberOfActiveSurvivors() const;
	int32 GetNumberOfOtherActiveSurvivors(class ADBDPlayer* Exception) const;
	class ACamperPlayer* GetObsessionTarget() const;
	void GetPlayerRoleCounts(int32* SurvivorCount, int32* KillerCount, int32* SpectatorCount) const;
	bool GetPlayersReadyToStart() const;
	class ADBDPlayerState* GetPlayerStateByIDString(const class FString& ID, bool IsReplacementBot) const;
	class ADBDPlayerState* GetPlayerStateByMirrorsID(const class FString& ID) const;
	int32 GetRemainingGeneratorsNeeded() const;
	int32 GetRequiredActivatedGeneratorCount() const;
	bool GetSelectedOffering(int32 Param_Index, struct FSelectedOffering* SelectedOffering) const;
	const TArray<struct FSelectedOffering> GetSelectedOfferings() const;
	class USpecialEventGameplaySpawnerComponent* GetSpecialEventGameplaySpawnerComponent() const;
	int32 GetSurvivorLeft() const;
	const TArray<class ATotem*> GetTotems() const;
	const TArray<class AInteractable*> GetTraps() const;
	bool IsEscapeDoorActivated() const;
	bool IsEscapeDoorOpen() const;
	bool IsEscapeRequirementCompleted() const;
	bool IsHatchVisible() const;
	bool IsIntroCompleted() const;
	bool IsLevelReadyToPlay() const;
	bool IsLevelSetupDone() const;
	bool IsLightingGenerated() const;
	bool IsOfferingReceived() const;
	bool IsOnePlayerLeft() const;
	bool IsPlayerDistributionReady() const;
	void OnRep_HatchOpened() const;
	void UpdateInGamePallets() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDGameState">();
	}
	static class ADBDGameState* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDGameState>();
	}
};
static_assert(alignof(ADBDGameState) == 0x000008, "Wrong alignment on ADBDGameState");
static_assert(sizeof(ADBDGameState) == 0x000A80, "Wrong size on ADBDGameState");
static_assert(offsetof(ADBDGameState, OnEscapeDoorActivated) == 0x0003A8, "Member 'ADBDGameState::OnEscapeDoorActivated' has a wrong offset!");
static_assert(offsetof(ADBDGameState, IntroState) == 0x000460, "Member 'ADBDGameState::IntroState' has a wrong offset!");
static_assert(offsetof(ADBDGameState, OnKillerIntroCompletePercentChanged) == 0x000468, "Member 'ADBDGameState::OnKillerIntroCompletePercentChanged' has a wrong offset!");
static_assert(offsetof(ADBDGameState, OnLightingGenerated) == 0x000478, "Member 'ADBDGameState::OnLightingGenerated' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _specialEventGameplaySpawnerComponent) == 0x0004B8, "Member 'ADBDGameState::_specialEventGameplaySpawnerComponent' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _specialBehaviourGameplaySpawnerComponent) == 0x0004C0, "Member 'ADBDGameState::_specialBehaviourGameplaySpawnerComponent' has a wrong offset!");
static_assert(offsetof(ADBDGameState, AuthorityOnAllPlayerLoaded) == 0x0004C8, "Member 'ADBDGameState::AuthorityOnAllPlayerLoaded' has a wrong offset!");
static_assert(offsetof(ADBDGameState, OnSlasherSet) == 0x0004F0, "Member 'ADBDGameState::OnSlasherSet' has a wrong offset!");
static_assert(offsetof(ADBDGameState, OnObsessionChanged) == 0x000518, "Member 'ADBDGameState::OnObsessionChanged' has a wrong offset!");
static_assert(offsetof(ADBDGameState, SecondsLeftInLobby) == 0x000528, "Member 'ADBDGameState::SecondsLeftInLobby' has a wrong offset!");
static_assert(offsetof(ADBDGameState, Slasher) == 0x000578, "Member 'ADBDGameState::Slasher' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _renderingSequencer) == 0x000580, "Member 'ADBDGameState::_renderingSequencer' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _camperHookedInBasementCount) == 0x0005D0, "Member 'ADBDGameState::_camperHookedInBasementCount' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _useNetAsyncLoading) == 0x0005DC, "Member 'ADBDGameState::_useNetAsyncLoading' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _gameLevelLoadingStarted) == 0x0005DD, "Member 'ADBDGameState::_gameLevelLoadingStarted' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _builtLevelData) == 0x0005E0, "Member 'ADBDGameState::_builtLevelData' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _levelOfferings) == 0x000698, "Member 'ADBDGameState::_levelOfferings' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _clipManager) == 0x0006B0, "Member 'ADBDGameState::_clipManager' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _fadeManager) == 0x0006B8, "Member 'ADBDGameState::_fadeManager' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _sessionId) == 0x0006C0, "Member 'ADBDGameState::_sessionId' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _lobbyId) == 0x0006D0, "Member 'ADBDGameState::_lobbyId' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _gameObjectives) == 0x0006E0, "Member 'ADBDGameState::_gameObjectives' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _escapeDoorActivated) == 0x0006F0, "Member 'ADBDGameState::_escapeDoorActivated' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _escapeDoorOpened) == 0x0006F1, "Member 'ADBDGameState::_escapeDoorOpened' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _isHatchOpen) == 0x0006F2, "Member 'ADBDGameState::_isHatchOpen' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _levelReadyToPlay) == 0x0006F3, "Member 'ADBDGameState::_levelReadyToPlay' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _playerDistributionReady) == 0x0006F4, "Member 'ADBDGameState::_playerDistributionReady' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _usingWeakenedMechanic) == 0x0006F5, "Member 'ADBDGameState::_usingWeakenedMechanic' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _survivorLeft) == 0x0006F8, "Member 'ADBDGameState::_survivorLeft' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _meatHooks) == 0x000700, "Member 'ADBDGameState::_meatHooks' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _searchables) == 0x000710, "Member 'ADBDGameState::_searchables' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _generators) == 0x000720, "Member 'ADBDGameState::_generators' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _escapeDoors) == 0x000730, "Member 'ADBDGameState::_escapeDoors' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _hatches) == 0x000740, "Member 'ADBDGameState::_hatches' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _reverseBearTrapRemovers) == 0x000750, "Member 'ADBDGameState::_reverseBearTrapRemovers' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _baseTraps) == 0x000760, "Member 'ADBDGameState::_baseTraps' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _pallets) == 0x000770, "Member 'ADBDGameState::_pallets' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _windows) == 0x000780, "Member 'ADBDGameState::_windows' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _lockers) == 0x000790, "Member 'ADBDGameState::_lockers' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _breakableWalls) == 0x0007A0, "Member 'ADBDGameState::_breakableWalls' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _totems) == 0x0007B0, "Member 'ADBDGameState::_totems' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _mapBoxSphereBounds) == 0x0007C0, "Member 'ADBDGameState::_mapBoxSphereBounds' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _basementBoxSphereBounds) == 0x0007F8, "Member 'ADBDGameState::_basementBoxSphereBounds' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _camperEscapedThroughHatch) == 0x00084C, "Member 'ADBDGameState::_camperEscapedThroughHatch' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _obsessionTarget) == 0x000850, "Member 'ADBDGameState::_obsessionTarget' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _cachedObsessionEscaped) == 0x000858, "Member 'ADBDGameState::_cachedObsessionEscaped' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _numberOfSurvivorsKilledOrSacrificed) == 0x000860, "Member 'ADBDGameState::_numberOfSurvivorsKilledOrSacrificed' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _traps) == 0x000868, "Member 'ADBDGameState::_traps' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _dangerPredictionObjects) == 0x000878, "Member 'ADBDGameState::_dangerPredictionObjects' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _gamePresetData) == 0x000890, "Member 'ADBDGameState::_gamePresetData' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _gameLevelLoaded) == 0x000920, "Member 'ADBDGameState::_gameLevelLoaded' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _gameLevelCreated) == 0x000921, "Member 'ADBDGameState::_gameLevelCreated' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _gameLevelEnded) == 0x000922, "Member 'ADBDGameState::_gameLevelEnded' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _gameTimedOut) == 0x000923, "Member 'ADBDGameState::_gameTimedOut' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _gameEndedReason) == 0x000924, "Member 'ADBDGameState::_gameEndedReason' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _isLoadoutFrozen) == 0x000925, "Member 'ADBDGameState::_isLoadoutFrozen' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _endGameState) == 0x000928, "Member 'ADBDGameState::_endGameState' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _scourgeHookManager) == 0x000930, "Member 'ADBDGameState::_scourgeHookManager' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _actorPairQueryEvaluatorComponent) == 0x000938, "Member 'ADBDGameState::_actorPairQueryEvaluatorComponent' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _hudStateComponent) == 0x000940, "Member 'ADBDGameState::_hudStateComponent' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _characterCollection) == 0x000950, "Member 'ADBDGameState::_characterCollection' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _collectableCollection) == 0x000958, "Member 'ADBDGameState::_collectableCollection' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _serverTimeProvider) == 0x000960, "Member 'ADBDGameState::_serverTimeProvider' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _inGameAssetPreloaderComponent) == 0x000968, "Member 'ADBDGameState::_inGameAssetPreloaderComponent' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _onScreenDebugComponent) == 0x000970, "Member 'ADBDGameState::_onScreenDebugComponent' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _matchStartTime) == 0x0009A0, "Member 'ADBDGameState::_matchStartTime' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _isServerDedicated) == 0x0009A8, "Member 'ADBDGameState::_isServerDedicated' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _maxSurvivorCount) == 0x0009AC, "Member 'ADBDGameState::_maxSurvivorCount' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _serverBuildVersion) == 0x0009B0, "Member 'ADBDGameState::_serverBuildVersion' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _serverContentVersion) == 0x0009C0, "Member 'ADBDGameState::_serverContentVersion' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _serverSessionId) == 0x0009D0, "Member 'ADBDGameState::_serverSessionId' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _serverRegion) == 0x0009E0, "Member 'ADBDGameState::_serverRegion' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _serverMatchId) == 0x0009F0, "Member 'ADBDGameState::_serverMatchId' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _introDuration) == 0x000A00, "Member 'ADBDGameState::_introDuration' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _leaveSpectateRequested) == 0x000A04, "Member 'ADBDGameState::_leaveSpectateRequested' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _eventTrackerObjectiveLevel) == 0x000A08, "Member 'ADBDGameState::_eventTrackerObjectiveLevel' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _hatchVisibleSurvivorThreshold) == 0x000A0C, "Member 'ADBDGameState::_hatchVisibleSurvivorThreshold' has a wrong offset!");

// Class DeadByDaylight.ActorComponentExt
// 0x0000 (0x0030 - 0x0030)
class UActorComponentExt final : public UBlueprintFunctionLibrary
{
public:
	static class ACharacter* GetOwningCharacter(const class UActorComponent* ActorComponent, bool RecursiveSearch);
	static class ACharacter* GetOwningCharacterChecked(const class UActorComponent* ActorComponent, bool RecursiveSearch);
	static class ASlasherPlayer* GetOwningKiller(const class UActorComponent* ActorComponent, bool RecursiveSearch);
	static class APawn* GetOwningPawn(const class UActorComponent* ActorComponent, bool RecursiveSearch);
	static class APawn* GetOwningPawnChecked(const class UActorComponent* ActorComponent, bool RecursiveSearch);
	static class ADBDPlayer* GetOwningPlayer(const class UActorComponent* ActorComponent, bool RecursiveSearch);
	static class ADBDPlayer* GetOwningPlayerChecked(const class UActorComponent* ActorComponent, bool RecursiveSearch);
	static class ADBDPlayer* GetOwningPlayerInHierarchy(const class UActorComponent* ActorComponent);
	static class ACamperPlayer* GetOwningSurvivor(const class UActorComponent* ActorComponent, bool RecursiveSearch);
	static class ACamperPlayer* GetOwningSurvivorChecked(const class UActorComponent* ActorComponent, bool RecursiveSearch);
	static class AActor* GetValidatedOwner(const class UActorComponent* ActorComponent);
	static bool HasAuthority(const class UActorComponent* ActorComponent);
	static bool IsLocallyControlled(const class UActorComponent* ActorComponent, bool RecursiveSearch);
	static bool IsLocallyObserved(const class UActorComponent* ActorComponent, bool RecursiveSearch);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActorComponentExt">();
	}
	static class UActorComponentExt* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActorComponentExt>();
	}
};
static_assert(alignof(UActorComponentExt) == 0x000008, "Wrong alignment on UActorComponentExt");
static_assert(sizeof(UActorComponentExt) == 0x000030, "Wrong size on UActorComponentExt");

// Class DeadByDaylight.OtherCharactersVerticalCollisionsHandler
// 0x0028 (0x00D0 - 0x00A8)
class UOtherCharactersVerticalCollisionsHandler final : public UActorComponent
{
public:
	TArray<class AActor*>                         _ignoreBelowActors;                                // 0x00A8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class AActor*>                         _overlappingActors;                                // 0x00B8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class UCapsuleComponent*                      _pawnDetector;                                     // 0x00C8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void InitializeOverlapDetection();
	void OnPawnDetectorOverlapEnter(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnPawnDetectorOverlapExit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void SetPawnDetector(class UCapsuleComponent* PawnDetector);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OtherCharactersVerticalCollisionsHandler">();
	}
	static class UOtherCharactersVerticalCollisionsHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOtherCharactersVerticalCollisionsHandler>();
	}
};
static_assert(alignof(UOtherCharactersVerticalCollisionsHandler) == 0x000008, "Wrong alignment on UOtherCharactersVerticalCollisionsHandler");
static_assert(sizeof(UOtherCharactersVerticalCollisionsHandler) == 0x0000D0, "Wrong size on UOtherCharactersVerticalCollisionsHandler");
static_assert(offsetof(UOtherCharactersVerticalCollisionsHandler, _ignoreBelowActors) == 0x0000A8, "Member 'UOtherCharactersVerticalCollisionsHandler::_ignoreBelowActors' has a wrong offset!");
static_assert(offsetof(UOtherCharactersVerticalCollisionsHandler, _overlappingActors) == 0x0000B8, "Member 'UOtherCharactersVerticalCollisionsHandler::_overlappingActors' has a wrong offset!");
static_assert(offsetof(UOtherCharactersVerticalCollisionsHandler, _pawnDetector) == 0x0000C8, "Member 'UOtherCharactersVerticalCollisionsHandler::_pawnDetector' has a wrong offset!");

// Class DeadByDaylight.DBDEngineUtils
// 0x0000 (0x0030 - 0x0030)
class UDBDEngineUtils final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDEngineUtils">();
	}
	static class UDBDEngineUtils* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDEngineUtils>();
	}
};
static_assert(alignof(UDBDEngineUtils) == 0x000008, "Wrong alignment on UDBDEngineUtils");
static_assert(sizeof(UDBDEngineUtils) == 0x000030, "Wrong size on UDBDEngineUtils");

// Class DeadByDaylight.ScreenIndicatorWorldMarkerComponent
// 0x0020 (0x02E0 - 0x02C0)
#pragma pack(push, 0x1)
class alignas(0x10) UScreenIndicatorWorldMarkerComponent : public USceneComponent
{
public:
	EHudScreenIndicatorType                       HudScreenIndicatorType;                            // 0x02C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C1[0x3];                                      // 0x02C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFloatRange                            VisibleDistanceRange;                              // 0x02C4(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D4[0x4];                                      // 0x02D4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScreenIndicatorWorldMarkerComponent">();
	}
	static class UScreenIndicatorWorldMarkerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScreenIndicatorWorldMarkerComponent>();
	}
};
#pragma pack(pop)
static_assert(alignof(UScreenIndicatorWorldMarkerComponent) == 0x000010, "Wrong alignment on UScreenIndicatorWorldMarkerComponent");
static_assert(sizeof(UScreenIndicatorWorldMarkerComponent) == 0x0002E0, "Wrong size on UScreenIndicatorWorldMarkerComponent");
static_assert(offsetof(UScreenIndicatorWorldMarkerComponent, HudScreenIndicatorType) == 0x0002C0, "Member 'UScreenIndicatorWorldMarkerComponent::HudScreenIndicatorType' has a wrong offset!");
static_assert(offsetof(UScreenIndicatorWorldMarkerComponent, VisibleDistanceRange) == 0x0002C4, "Member 'UScreenIndicatorWorldMarkerComponent::VisibleDistanceRange' has a wrong offset!");

// Class DeadByDaylight.DisplayStandController
// 0x01B0 (0x01E0 - 0x0030)
class UDisplayStandController : public UObject
{
public:
	uint8                                         Pad_30[0x1B0];                                     // 0x0030(0x01B0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DisplayStandController">();
	}
	static class UDisplayStandController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDisplayStandController>();
	}
};
static_assert(alignof(UDisplayStandController) == 0x000008, "Wrong alignment on UDisplayStandController");
static_assert(sizeof(UDisplayStandController) == 0x0001E0, "Wrong size on UDisplayStandController");

// Class DeadByDaylight.LobbyDisplayStandController
// 0x0178 (0x0358 - 0x01E0)
class ULobbyDisplayStandController final : public UDisplayStandController
{
public:
	uint8                                         Pad_1E0[0x178];                                    // 0x01E0(0x0178)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LobbyDisplayStandController">();
	}
	static class ULobbyDisplayStandController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULobbyDisplayStandController>();
	}
};
static_assert(alignof(ULobbyDisplayStandController) == 0x000008, "Wrong alignment on ULobbyDisplayStandController");
static_assert(sizeof(ULobbyDisplayStandController) == 0x000358, "Wrong size on ULobbyDisplayStandController");

// Class DeadByDaylight.TutorialObjectiveController
// 0x00B0 (0x00E0 - 0x0030)
class UTutorialObjectiveController final : public UObject
{
public:
	uint8                                         Pad_30[0xB0];                                      // 0x0030(0x00B0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddObjective(class FName TutorialObjectiveId);
	void CompleteObjective(class FName TutorialObjectiveId, bool RemoveAfterCompletion);
	void RemoveAllObjectives();
	void RemoveObjective(class FName TutorialObjectiveId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TutorialObjectiveController">();
	}
	static class UTutorialObjectiveController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTutorialObjectiveController>();
	}
};
static_assert(alignof(UTutorialObjectiveController) == 0x000008, "Wrong alignment on UTutorialObjectiveController");
static_assert(sizeof(UTutorialObjectiveController) == 0x0000E0, "Wrong size on UTutorialObjectiveController");

// Class DeadByDaylight.BloodwebHandler
// 0x0068 (0x0098 - 0x0030)
class UBloodwebHandler final : public UObject
{
public:
	uint8                                         Pad_30[0x68];                                      // 0x0030(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BloodwebHandler">();
	}
	static class UBloodwebHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBloodwebHandler>();
	}
};
static_assert(alignof(UBloodwebHandler) == 0x000008, "Wrong alignment on UBloodwebHandler");
static_assert(sizeof(UBloodwebHandler) == 0x000098, "Wrong size on UBloodwebHandler");

// Class DeadByDaylight.AbstractGameFlowHandler
// 0x0000 (0x0038 - 0x0038)
class UAbstractGameFlowHandler : public UGameInstanceSubsystem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbstractGameFlowHandler">();
	}
	static class UAbstractGameFlowHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbstractGameFlowHandler>();
	}
};
static_assert(alignof(UAbstractGameFlowHandler) == 0x000008, "Wrong alignment on UAbstractGameFlowHandler");
static_assert(sizeof(UAbstractGameFlowHandler) == 0x000038, "Wrong size on UAbstractGameFlowHandler");

// Class DeadByDaylight.ActionButton
// 0x0388 (0x06D0 - 0x0348)
class UActionButton final : public UMobileBaseUserWidget
{
public:
	uint8                                         Pad_348[0x8];                                      // 0x0348(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            DefaultImage;                                      // 0x0350(0x00D0)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	class UImage*                                 IconImage;                                         // 0x0420(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 ToggleSmokeImage;                                  // 0x0428(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UButton*                                Button;                                            // 0x0430(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultOpacity;                                    // 0x0438(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ToggledOpacity;                                    // 0x043C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DisabledOpacity;                                   // 0x0440(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_444[0xC];                                      // 0x0444(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            Normal;                                            // 0x0450(0x00D0)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FSlateBrush                            Toggled;                                           // 0x0520(0x00D0)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FSlateBrush                            Disabled;                                          // 0x05F0(0x00D0)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	EActionButtonState                            _currentState;                                     // 0x06C0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EActionButtonState                            _previousState;                                    // 0x06C1(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6C2[0xE];                                      // 0x06C2(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void PlayBecameAvailableAnimation();
	void SetIcon(const struct FSlateBrush& SlateBrush);
	void SetPreviousState();
	void SetSlateBrush(const struct FSlateBrush& InBrush);
	void SetState(EActionButtonState State);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActionButton">();
	}
	static class UActionButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActionButton>();
	}
};
static_assert(alignof(UActionButton) == 0x000010, "Wrong alignment on UActionButton");
static_assert(sizeof(UActionButton) == 0x0006D0, "Wrong size on UActionButton");
static_assert(offsetof(UActionButton, DefaultImage) == 0x000350, "Member 'UActionButton::DefaultImage' has a wrong offset!");
static_assert(offsetof(UActionButton, IconImage) == 0x000420, "Member 'UActionButton::IconImage' has a wrong offset!");
static_assert(offsetof(UActionButton, ToggleSmokeImage) == 0x000428, "Member 'UActionButton::ToggleSmokeImage' has a wrong offset!");
static_assert(offsetof(UActionButton, Button) == 0x000430, "Member 'UActionButton::Button' has a wrong offset!");
static_assert(offsetof(UActionButton, DefaultOpacity) == 0x000438, "Member 'UActionButton::DefaultOpacity' has a wrong offset!");
static_assert(offsetof(UActionButton, ToggledOpacity) == 0x00043C, "Member 'UActionButton::ToggledOpacity' has a wrong offset!");
static_assert(offsetof(UActionButton, DisabledOpacity) == 0x000440, "Member 'UActionButton::DisabledOpacity' has a wrong offset!");
static_assert(offsetof(UActionButton, Normal) == 0x000450, "Member 'UActionButton::Normal' has a wrong offset!");
static_assert(offsetof(UActionButton, Toggled) == 0x000520, "Member 'UActionButton::Toggled' has a wrong offset!");
static_assert(offsetof(UActionButton, Disabled) == 0x0005F0, "Member 'UActionButton::Disabled' has a wrong offset!");
static_assert(offsetof(UActionButton, _currentState) == 0x0006C0, "Member 'UActionButton::_currentState' has a wrong offset!");
static_assert(offsetof(UActionButton, _previousState) == 0x0006C1, "Member 'UActionButton::_previousState' has a wrong offset!");

// Class DeadByDaylight.ActivationAndTimerIconStrategy
// 0x0000 (0x0038 - 0x0038)
class UActivationAndTimerIconStrategy final : public UBasePerkIconStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActivationAndTimerIconStrategy">();
	}
	static class UActivationAndTimerIconStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActivationAndTimerIconStrategy>();
	}
};
static_assert(alignof(UActivationAndTimerIconStrategy) == 0x000008, "Wrong alignment on UActivationAndTimerIconStrategy");
static_assert(sizeof(UActivationAndTimerIconStrategy) == 0x000038, "Wrong size on UActivationAndTimerIconStrategy");

// Class DeadByDaylight.ActivationTimerElapsedCooldownRemainingIconStrategy
// 0x0000 (0x0038 - 0x0038)
class UActivationTimerElapsedCooldownRemainingIconStrategy final : public UBasePerkIconStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActivationTimerElapsedCooldownRemainingIconStrategy">();
	}
	static class UActivationTimerElapsedCooldownRemainingIconStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActivationTimerElapsedCooldownRemainingIconStrategy>();
	}
};
static_assert(alignof(UActivationTimerElapsedCooldownRemainingIconStrategy) == 0x000008, "Wrong alignment on UActivationTimerElapsedCooldownRemainingIconStrategy");
static_assert(sizeof(UActivationTimerElapsedCooldownRemainingIconStrategy) == 0x000038, "Wrong size on UActivationTimerElapsedCooldownRemainingIconStrategy");

// Class DeadByDaylight.LoudNoise
// 0x0070 (0x0310 - 0x02A0)
class ALoudNoise : public AActor
{
public:
	class UDecalComponent*                        _toInfinityDecal;                                  // 0x02A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystemComponent*               _distortionParticleSystem;                         // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkComponent*                           _ak_audio_loudNoise;                               // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        _rootScene;                                        // 0x02B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _loudNoiseMinDistance;                             // 0x02C0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C4[0x34];                                     // 0x02C4(0x0034)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _loudNoiseLifetime;                                // 0x02F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _heightToAddToLoudNoiseLocation;                   // 0x02FC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _loudNoiseDecalDistance;                           // 0x0300(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _cameraDecalDistance;                              // 0x0304(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_308[0x8];                                      // 0x0308(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoudNoise">();
	}
	static class ALoudNoise* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALoudNoise>();
	}
};
static_assert(alignof(ALoudNoise) == 0x000008, "Wrong alignment on ALoudNoise");
static_assert(sizeof(ALoudNoise) == 0x000310, "Wrong size on ALoudNoise");
static_assert(offsetof(ALoudNoise, _toInfinityDecal) == 0x0002A0, "Member 'ALoudNoise::_toInfinityDecal' has a wrong offset!");
static_assert(offsetof(ALoudNoise, _distortionParticleSystem) == 0x0002A8, "Member 'ALoudNoise::_distortionParticleSystem' has a wrong offset!");
static_assert(offsetof(ALoudNoise, _ak_audio_loudNoise) == 0x0002B0, "Member 'ALoudNoise::_ak_audio_loudNoise' has a wrong offset!");
static_assert(offsetof(ALoudNoise, _rootScene) == 0x0002B8, "Member 'ALoudNoise::_rootScene' has a wrong offset!");
static_assert(offsetof(ALoudNoise, _loudNoiseMinDistance) == 0x0002C0, "Member 'ALoudNoise::_loudNoiseMinDistance' has a wrong offset!");
static_assert(offsetof(ALoudNoise, _loudNoiseLifetime) == 0x0002F8, "Member 'ALoudNoise::_loudNoiseLifetime' has a wrong offset!");
static_assert(offsetof(ALoudNoise, _heightToAddToLoudNoiseLocation) == 0x0002FC, "Member 'ALoudNoise::_heightToAddToLoudNoiseLocation' has a wrong offset!");
static_assert(offsetof(ALoudNoise, _loudNoiseDecalDistance) == 0x000300, "Member 'ALoudNoise::_loudNoiseDecalDistance' has a wrong offset!");
static_assert(offsetof(ALoudNoise, _cameraDecalDistance) == 0x000304, "Member 'ALoudNoise::_cameraDecalDistance' has a wrong offset!");

// Class DeadByDaylight.BloodwebEntity
// 0x0048 (0x0078 - 0x0030)
class UBloodwebEntity final : public UObject
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UDBDGameInstance*                       _gameInstance;                                     // 0x0038(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBloodwebTunables*                      _bloodwebTunables;                                 // 0x0040(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TScriptInterface<class IDBDBloodwebDefinitionBase> _bloodwebDefinition;                               // 0x0048(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_58[0x20];                                      // 0x0058(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BloodwebEntity">();
	}
	static class UBloodwebEntity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBloodwebEntity>();
	}
};
static_assert(alignof(UBloodwebEntity) == 0x000008, "Wrong alignment on UBloodwebEntity");
static_assert(sizeof(UBloodwebEntity) == 0x000078, "Wrong size on UBloodwebEntity");
static_assert(offsetof(UBloodwebEntity, _gameInstance) == 0x000038, "Member 'UBloodwebEntity::_gameInstance' has a wrong offset!");
static_assert(offsetof(UBloodwebEntity, _bloodwebTunables) == 0x000040, "Member 'UBloodwebEntity::_bloodwebTunables' has a wrong offset!");
static_assert(offsetof(UBloodwebEntity, _bloodwebDefinition) == 0x000048, "Member 'UBloodwebEntity::_bloodwebDefinition' has a wrong offset!");

// Class DeadByDaylight.TormentAttackDamageCooldownInterface
// 0x0000 (0x0030 - 0x0030)
class ITormentAttackDamageCooldownInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TormentAttackDamageCooldownInterface">();
	}
	static class ITormentAttackDamageCooldownInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ITormentAttackDamageCooldownInterface>();
	}
};
static_assert(alignof(ITormentAttackDamageCooldownInterface) == 0x000008, "Wrong alignment on ITormentAttackDamageCooldownInterface");
static_assert(sizeof(ITormentAttackDamageCooldownInterface) == 0x000030, "Wrong size on ITormentAttackDamageCooldownInterface");

// Class DeadByDaylight.ActivationTimerElapsedIconStrategy
// 0x0000 (0x0038 - 0x0038)
class UActivationTimerElapsedIconStrategy final : public UBasePerkIconStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActivationTimerElapsedIconStrategy">();
	}
	static class UActivationTimerElapsedIconStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActivationTimerElapsedIconStrategy>();
	}
};
static_assert(alignof(UActivationTimerElapsedIconStrategy) == 0x000008, "Wrong alignment on UActivationTimerElapsedIconStrategy");
static_assert(sizeof(UActivationTimerElapsedIconStrategy) == 0x000038, "Wrong size on UActivationTimerElapsedIconStrategy");

// Class DeadByDaylight.RedStainComponent
// 0x0010 (0x0530 - 0x0520)
class URedStainComponent : public USpotLightComponent
{
public:
	struct FLinearColor                           _initialSpotLightColor;                            // 0x0518(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_528[0x8];                                      // 0x0528(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DBD_HideRedStain(const bool HideStain);
	void UpdateRedStain(bool ShouldBeHidden, const float Alpha);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RedStainComponent">();
	}
	static class URedStainComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URedStainComponent>();
	}
};
static_assert(alignof(URedStainComponent) == 0x000010, "Wrong alignment on URedStainComponent");
static_assert(sizeof(URedStainComponent) == 0x000530, "Wrong size on URedStainComponent");
static_assert(offsetof(URedStainComponent, _initialSpotLightColor) == 0x000518, "Member 'URedStainComponent::_initialSpotLightColor' has a wrong offset!");

// Class DeadByDaylight.ActivationTimerIconStrategy
// 0x0000 (0x0038 - 0x0038)
class UActivationTimerIconStrategy final : public UBasePerkIconStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActivationTimerIconStrategy">();
	}
	static class UActivationTimerIconStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActivationTimerIconStrategy>();
	}
};
static_assert(alignof(UActivationTimerIconStrategy) == 0x000008, "Wrong alignment on UActivationTimerIconStrategy");
static_assert(sizeof(UActivationTimerIconStrategy) == 0x000038, "Wrong size on UActivationTimerIconStrategy");

// Class DeadByDaylight.BonusPointEventsManager
// 0x00B8 (0x00E8 - 0x0030)
class UBonusPointEventsManager final : public UObject
{
public:
	uint8                                         Pad_30[0xB8];                                      // 0x0030(0x00B8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BonusPointEventsManager">();
	}
	static class UBonusPointEventsManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBonusPointEventsManager>();
	}
};
static_assert(alignof(UBonusPointEventsManager) == 0x000008, "Wrong alignment on UBonusPointEventsManager");
static_assert(sizeof(UBonusPointEventsManager) == 0x0000E8, "Wrong size on UBonusPointEventsManager");

// Class DeadByDaylight.ActivationTimerRemainingCooldownElapsedIconStrategy
// 0x0000 (0x0038 - 0x0038)
class UActivationTimerRemainingCooldownElapsedIconStrategy final : public UBasePerkIconStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActivationTimerRemainingCooldownElapsedIconStrategy">();
	}
	static class UActivationTimerRemainingCooldownElapsedIconStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActivationTimerRemainingCooldownElapsedIconStrategy>();
	}
};
static_assert(alignof(UActivationTimerRemainingCooldownElapsedIconStrategy) == 0x000008, "Wrong alignment on UActivationTimerRemainingCooldownElapsedIconStrategy");
static_assert(sizeof(UActivationTimerRemainingCooldownElapsedIconStrategy) == 0x000038, "Wrong size on UActivationTimerRemainingCooldownElapsedIconStrategy");

// Class DeadByDaylight.ActivationTimerRemainingPercentIconStrategy
// 0x0000 (0x0038 - 0x0038)
class UActivationTimerRemainingPercentIconStrategy final : public UBasePerkIconStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActivationTimerRemainingPercentIconStrategy">();
	}
	static class UActivationTimerRemainingPercentIconStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActivationTimerRemainingPercentIconStrategy>();
	}
};
static_assert(alignof(UActivationTimerRemainingPercentIconStrategy) == 0x000008, "Wrong alignment on UActivationTimerRemainingPercentIconStrategy");
static_assert(sizeof(UActivationTimerRemainingPercentIconStrategy) == 0x000038, "Wrong size on UActivationTimerRemainingPercentIconStrategy");

// Class DeadByDaylight.LoudNoiseUtilities
// 0x0000 (0x0030 - 0x0030)
class ULoudNoiseUtilities final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoudNoiseUtilities">();
	}
	static class ULoudNoiseUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoudNoiseUtilities>();
	}
};
static_assert(alignof(ULoudNoiseUtilities) == 0x000008, "Wrong alignment on ULoudNoiseUtilities");
static_assert(sizeof(ULoudNoiseUtilities) == 0x000030, "Wrong size on ULoudNoiseUtilities");

// Class DeadByDaylight.BloodwebPathfinder
// 0x0018 (0x0048 - 0x0030)
class UBloodwebPathfinder final : public UObject
{
public:
	uint8                                         Pad_30[0x18];                                      // 0x0030(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BloodwebPathfinder">();
	}
	static class UBloodwebPathfinder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBloodwebPathfinder>();
	}
};
static_assert(alignof(UBloodwebPathfinder) == 0x000008, "Wrong alignment on UBloodwebPathfinder");
static_assert(sizeof(UBloodwebPathfinder) == 0x000048, "Wrong size on UBloodwebPathfinder");

// Class DeadByDaylight.ActiveOnTimerOrApplicablePerkIconStrategy
// 0x0000 (0x0038 - 0x0038)
class UActiveOnTimerOrApplicablePerkIconStrategy final : public UBasePerkIconStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActiveOnTimerOrApplicablePerkIconStrategy">();
	}
	static class UActiveOnTimerOrApplicablePerkIconStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActiveOnTimerOrApplicablePerkIconStrategy>();
	}
};
static_assert(alignof(UActiveOnTimerOrApplicablePerkIconStrategy) == 0x000008, "Wrong alignment on UActiveOnTimerOrApplicablePerkIconStrategy");
static_assert(sizeof(UActiveOnTimerOrApplicablePerkIconStrategy) == 0x000038, "Wrong size on UActiveOnTimerOrApplicablePerkIconStrategy");

// Class DeadByDaylight.ScreenBase
// 0x00F8 (0x0128 - 0x0030)
class UScreenBase : public UObject
{
public:
	bool                                          IsAnimationDone;                                   // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UGFxObject*                             ScreenObject;                                      // 0x0038(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UScreenController*                      _screenController;                                 // 0x0040(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         LocKeyResultMaxChars;                              // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4C[0xDC];                                      // 0x004C(0x00DC)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BroadcastOnHighlightedElementClickedEvent(const class FName OnBoardingID);
	void OnAnimationUpdate(int32 Param_IsAnimationDone);
	void OnAnyKey(float Code);
	void OnBack();
	void OnEscape();
	void OnHideVirtualKeyboardRequested();
	void OnNavKey(const class FString& NavKey);
	void OnStart();
	void OnTextInputMouseClicked(bool IsPassword);

	void SetFadesOut(bool FadesOut) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScreenBase">();
	}
	static class UScreenBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScreenBase>();
	}
};
static_assert(alignof(UScreenBase) == 0x000008, "Wrong alignment on UScreenBase");
static_assert(sizeof(UScreenBase) == 0x000128, "Wrong size on UScreenBase");
static_assert(offsetof(UScreenBase, IsAnimationDone) == 0x000030, "Member 'UScreenBase::IsAnimationDone' has a wrong offset!");
static_assert(offsetof(UScreenBase, ScreenObject) == 0x000038, "Member 'UScreenBase::ScreenObject' has a wrong offset!");
static_assert(offsetof(UScreenBase, _screenController) == 0x000040, "Member 'UScreenBase::_screenController' has a wrong offset!");
static_assert(offsetof(UScreenBase, LocKeyResultMaxChars) == 0x000048, "Member 'UScreenBase::LocKeyResultMaxChars' has a wrong offset!");

// Class DeadByDaylight.BasePopupScreen
// 0x0000 (0x0128 - 0x0128)
class UBasePopupScreen : public UScreenBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BasePopupScreen">();
	}
	static class UBasePopupScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBasePopupScreen>();
	}
};
static_assert(alignof(UBasePopupScreen) == 0x000008, "Wrong alignment on UBasePopupScreen");
static_assert(sizeof(UBasePopupScreen) == 0x000128, "Wrong size on UBasePopupScreen");

// Class DeadByDaylight.GenericPopupScreen
// 0x0020 (0x0148 - 0x0128)
class UGenericPopupScreen : public UBasePopupScreen
{
public:
	class UUMGGenericPopup*                       _popup;                                            // 0x0128(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_130[0x18];                                     // 0x0130(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnChoiceSelected(int32 SelectedButtonType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GenericPopupScreen">();
	}
	static class UGenericPopupScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGenericPopupScreen>();
	}
};
static_assert(alignof(UGenericPopupScreen) == 0x000008, "Wrong alignment on UGenericPopupScreen");
static_assert(sizeof(UGenericPopupScreen) == 0x000148, "Wrong size on UGenericPopupScreen");
static_assert(offsetof(UGenericPopupScreen, _popup) == 0x000128, "Member 'UGenericPopupScreen::_popup' has a wrong offset!");

// Class DeadByDaylight.ReportPlayerPopupScreen
// 0x0030 (0x0178 - 0x0148)
class UReportPlayerPopupScreen final : public UGenericPopupScreen
{
public:
	uint8                                         Pad_148[0x30];                                     // 0x0148(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnConfirmReportPlayer(const class FString& Category, const class FString& Comment);
	void OnTextInputMouseOver(bool IsMouseOver);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReportPlayerPopupScreen">();
	}
	static class UReportPlayerPopupScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReportPlayerPopupScreen>();
	}
};
static_assert(alignof(UReportPlayerPopupScreen) == 0x000008, "Wrong alignment on UReportPlayerPopupScreen");
static_assert(sizeof(UReportPlayerPopupScreen) == 0x000178, "Wrong size on UReportPlayerPopupScreen");

// Class DeadByDaylight.ActiveOnTimerPerkIconStrategy
// 0x0000 (0x0038 - 0x0038)
class UActiveOnTimerPerkIconStrategy final : public UBasePerkIconStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActiveOnTimerPerkIconStrategy">();
	}
	static class UActiveOnTimerPerkIconStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActiveOnTimerPerkIconStrategy>();
	}
};
static_assert(alignof(UActiveOnTimerPerkIconStrategy) == 0x000008, "Wrong alignment on UActiveOnTimerPerkIconStrategy");
static_assert(sizeof(UActiveOnTimerPerkIconStrategy) == 0x000038, "Wrong size on UActiveOnTimerPerkIconStrategy");

// Class DeadByDaylight.BloodwebTunables
// 0x0008 (0x0038 - 0x0030)
class UBloodwebTunables : public UObject
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BloodwebTunables">();
	}
	static class UBloodwebTunables* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBloodwebTunables>();
	}
};
static_assert(alignof(UBloodwebTunables) == 0x000008, "Wrong alignment on UBloodwebTunables");
static_assert(sizeof(UBloodwebTunables) == 0x000038, "Wrong size on UBloodwebTunables");

// Class DeadByDaylight.BloodwebClientTunables
// 0x0000 (0x0038 - 0x0038)
class UBloodwebClientTunables final : public UBloodwebTunables
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BloodwebClientTunables">();
	}
	static class UBloodwebClientTunables* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBloodwebClientTunables>();
	}
};
static_assert(alignof(UBloodwebClientTunables) == 0x000008, "Wrong alignment on UBloodwebClientTunables");
static_assert(sizeof(UBloodwebClientTunables) == 0x000038, "Wrong size on UBloodwebClientTunables");

// Class DeadByDaylight.ActiveWhenApplicableAndActivationAndCooldownPerkIconStrategy
// 0x0000 (0x0038 - 0x0038)
class UActiveWhenApplicableAndActivationAndCooldownPerkIconStrategy final : public UBasePerkIconStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActiveWhenApplicableAndActivationAndCooldownPerkIconStrategy">();
	}
	static class UActiveWhenApplicableAndActivationAndCooldownPerkIconStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActiveWhenApplicableAndActivationAndCooldownPerkIconStrategy>();
	}
};
static_assert(alignof(UActiveWhenApplicableAndActivationAndCooldownPerkIconStrategy) == 0x000008, "Wrong alignment on UActiveWhenApplicableAndActivationAndCooldownPerkIconStrategy");
static_assert(sizeof(UActiveWhenApplicableAndActivationAndCooldownPerkIconStrategy) == 0x000038, "Wrong size on UActiveWhenApplicableAndActivationAndCooldownPerkIconStrategy");

// Class DeadByDaylight.ActiveWhenApplicableAndEnabledPerkIconStrategy
// 0x0008 (0x0040 - 0x0038)
class UActiveWhenApplicableAndEnabledPerkIconStrategy final : public UBasePerkIconStrategy
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActiveWhenApplicableAndEnabledPerkIconStrategy">();
	}
	static class UActiveWhenApplicableAndEnabledPerkIconStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActiveWhenApplicableAndEnabledPerkIconStrategy>();
	}
};
static_assert(alignof(UActiveWhenApplicableAndEnabledPerkIconStrategy) == 0x000008, "Wrong alignment on UActiveWhenApplicableAndEnabledPerkIconStrategy");
static_assert(sizeof(UActiveWhenApplicableAndEnabledPerkIconStrategy) == 0x000040, "Wrong size on UActiveWhenApplicableAndEnabledPerkIconStrategy");

// Class DeadByDaylight.DBDPrimaryDataAsset
// 0x0010 (0x0048 - 0x0038)
class UDBDPrimaryDataAsset : public UPrimaryDataAsset
{
public:
	struct FPrimaryAssetType                      AssetType;                                         // 0x0038(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDPrimaryDataAsset">();
	}
	static class UDBDPrimaryDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDPrimaryDataAsset>();
	}
};
static_assert(alignof(UDBDPrimaryDataAsset) == 0x000008, "Wrong alignment on UDBDPrimaryDataAsset");
static_assert(sizeof(UDBDPrimaryDataAsset) == 0x000048, "Wrong size on UDBDPrimaryDataAsset");
static_assert(offsetof(UDBDPrimaryDataAsset, AssetType) == 0x000038, "Member 'UDBDPrimaryDataAsset::AssetType' has a wrong offset!");

// Class DeadByDaylight.ItemDataAsset
// 0x0048 (0x0090 - 0x0048)
class UItemDataAsset final : public UDBDPrimaryDataAsset
{
public:
	TSoftClassPtr<class UClass>                   ActorClass;                                        // 0x0048(0x0038)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UGameplayModifierContainerDataAsset>> RequiredModifierContainers;                        // 0x0080(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemDataAsset">();
	}
	static class UItemDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemDataAsset>();
	}
};
static_assert(alignof(UItemDataAsset) == 0x000008, "Wrong alignment on UItemDataAsset");
static_assert(sizeof(UItemDataAsset) == 0x000090, "Wrong size on UItemDataAsset");
static_assert(offsetof(UItemDataAsset, ActorClass) == 0x000048, "Member 'UItemDataAsset::ActorClass' has a wrong offset!");
static_assert(offsetof(UItemDataAsset, RequiredModifierContainers) == 0x000080, "Member 'UItemDataAsset::RequiredModifierContainers' has a wrong offset!");

// Class DeadByDaylight.BlueprintDebugUtilities
// 0x0000 (0x0030 - 0x0030)
class UBlueprintDebugUtilities final : public UBlueprintFunctionLibrary
{
public:
	static void EnsureFalseWithMessage(const class FString& EnsureMessage);
	static void EnsureOnConditionWithMessage(const bool Condition, const class FString& EnsureMessage);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlueprintDebugUtilities">();
	}
	static class UBlueprintDebugUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlueprintDebugUtilities>();
	}
};
static_assert(alignof(UBlueprintDebugUtilities) == 0x000008, "Wrong alignment on UBlueprintDebugUtilities");
static_assert(sizeof(UBlueprintDebugUtilities) == 0x000030, "Wrong size on UBlueprintDebugUtilities");

// Class DeadByDaylight.ActiveWhenApplicableAndNotCampingPerkIconStrategy
// 0x0008 (0x0040 - 0x0038)
class UActiveWhenApplicableAndNotCampingPerkIconStrategy final : public UBasePerkIconStrategy
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActiveWhenApplicableAndNotCampingPerkIconStrategy">();
	}
	static class UActiveWhenApplicableAndNotCampingPerkIconStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActiveWhenApplicableAndNotCampingPerkIconStrategy>();
	}
};
static_assert(alignof(UActiveWhenApplicableAndNotCampingPerkIconStrategy) == 0x000008, "Wrong alignment on UActiveWhenApplicableAndNotCampingPerkIconStrategy");
static_assert(sizeof(UActiveWhenApplicableAndNotCampingPerkIconStrategy) == 0x000040, "Wrong size on UActiveWhenApplicableAndNotCampingPerkIconStrategy");

// Class DeadByDaylight.ActiveWhenApplicablePerkIconStrategy
// 0x0000 (0x0038 - 0x0038)
class UActiveWhenApplicablePerkIconStrategy final : public UBasePerkIconStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActiveWhenApplicablePerkIconStrategy">();
	}
	static class UActiveWhenApplicablePerkIconStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActiveWhenApplicablePerkIconStrategy>();
	}
};
static_assert(alignof(UActiveWhenApplicablePerkIconStrategy) == 0x000008, "Wrong alignment on UActiveWhenApplicablePerkIconStrategy");
static_assert(sizeof(UActiveWhenApplicablePerkIconStrategy) == 0x000038, "Wrong size on UActiveWhenApplicablePerkIconStrategy");

// Class DeadByDaylight.UMGHudEditorScreen
// 0x0070 (0x0318 - 0x02A8)
class UUMGHudEditorScreen final : public UUserWidget
{
public:
	class UUMGHudEditorLayoutWidget*              _hudEditorLayoutWidget;                            // 0x02A8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUMGHudEditorVersionWidget*             _versionSwapWidget;                                // 0x02B0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<EPlayerRole, class UUMGHudEditorLayoutScreen*> _storedLayoutScreens;                              // 0x02B8(0x0050)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class UUMGHudEditorLayoutScreen*              _currentLayoutScreen;                              // 0x0308(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkAudioEvent*                          _onDropOverlapSound;                               // 0x0310(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Quit();
	void RegisterEditorLayoutScreen(EPlayerRole Role, class UUMGHudEditorLayoutScreen* Screen);
	void SetEditorDropErrorOverlapSound(class UAkAudioEvent* OnDropOverlapSound);
	void SetWidgets(class UUMGHudEditorLayoutWidget* HudEditorLayoutWidget, class UUMGHudEditorVersionWidget* VersionSwapWidget);
	void ShowHudLayout(EPlayerRole Role);

	class UUMGHudEditorVersionWidget* GetVersionSwapWidget() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGHudEditorScreen">();
	}
	static class UUMGHudEditorScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGHudEditorScreen>();
	}
};
static_assert(alignof(UUMGHudEditorScreen) == 0x000008, "Wrong alignment on UUMGHudEditorScreen");
static_assert(sizeof(UUMGHudEditorScreen) == 0x000318, "Wrong size on UUMGHudEditorScreen");
static_assert(offsetof(UUMGHudEditorScreen, _hudEditorLayoutWidget) == 0x0002A8, "Member 'UUMGHudEditorScreen::_hudEditorLayoutWidget' has a wrong offset!");
static_assert(offsetof(UUMGHudEditorScreen, _versionSwapWidget) == 0x0002B0, "Member 'UUMGHudEditorScreen::_versionSwapWidget' has a wrong offset!");
static_assert(offsetof(UUMGHudEditorScreen, _storedLayoutScreens) == 0x0002B8, "Member 'UUMGHudEditorScreen::_storedLayoutScreens' has a wrong offset!");
static_assert(offsetof(UUMGHudEditorScreen, _currentLayoutScreen) == 0x000308, "Member 'UUMGHudEditorScreen::_currentLayoutScreen' has a wrong offset!");
static_assert(offsetof(UUMGHudEditorScreen, _onDropOverlapSound) == 0x000310, "Member 'UUMGHudEditorScreen::_onDropOverlapSound' has a wrong offset!");

// Class DeadByDaylight.CameraAttachmentComponent
// 0x00C8 (0x0170 - 0x00A8)
class UCameraAttachmentComponent final : public UActorComponent
{
public:
	class USceneComponent*                        _anchor;                                           // 0x00A8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B0[0x18];                                      // 0x00B0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCameraAttachment                      _defaultCameraAttachment;                          // 0x00C8(0x0018)(Transient, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FCameraAttachment                      _currentCameraAttachment;                          // 0x00E0(0x0018)(Transient, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F8[0x78];                                      // 0x00F8(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Detach();
	void Reset();

	bool IsAttached() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraAttachmentComponent">();
	}
	static class UCameraAttachmentComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCameraAttachmentComponent>();
	}
};
static_assert(alignof(UCameraAttachmentComponent) == 0x000008, "Wrong alignment on UCameraAttachmentComponent");
static_assert(sizeof(UCameraAttachmentComponent) == 0x000170, "Wrong size on UCameraAttachmentComponent");
static_assert(offsetof(UCameraAttachmentComponent, _anchor) == 0x0000A8, "Member 'UCameraAttachmentComponent::_anchor' has a wrong offset!");
static_assert(offsetof(UCameraAttachmentComponent, _defaultCameraAttachment) == 0x0000C8, "Member 'UCameraAttachmentComponent::_defaultCameraAttachment' has a wrong offset!");
static_assert(offsetof(UCameraAttachmentComponent, _currentCameraAttachment) == 0x0000E0, "Member 'UCameraAttachmentComponent::_currentCameraAttachment' has a wrong offset!");

// Class DeadByDaylight.ActiveWhenKOdAndCooldownTimerPerkIconStrategy
// 0x0000 (0x0038 - 0x0038)
class UActiveWhenKOdAndCooldownTimerPerkIconStrategy final : public UBasePerkIconStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActiveWhenKOdAndCooldownTimerPerkIconStrategy">();
	}
	static class UActiveWhenKOdAndCooldownTimerPerkIconStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActiveWhenKOdAndCooldownTimerPerkIconStrategy>();
	}
};
static_assert(alignof(UActiveWhenKOdAndCooldownTimerPerkIconStrategy) == 0x000008, "Wrong alignment on UActiveWhenKOdAndCooldownTimerPerkIconStrategy");
static_assert(sizeof(UActiveWhenKOdAndCooldownTimerPerkIconStrategy) == 0x000038, "Wrong size on UActiveWhenKOdAndCooldownTimerPerkIconStrategy");

// Class DeadByDaylight.ActorClipperComponent
// 0x0080 (0x0128 - 0x00A8)
class UActorClipperComponent final : public UActorComponent
{
public:
	class USphereComponent*                       Shape;                                             // 0x00A8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class AActor*, struct FClippedActor>     _clippedActors;                                    // 0x00B0(0x0050)(Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class UPrimitiveCollection>    _clippables;                                       // 0x0100(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_108[0x20];                                     // 0x0108(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCameraChanged(EDBDCameraSocketID SocketId);
	void OnOwnerLocallyObservedChanged(bool LocallyObserved);
	void SetPrimitiveCollection(const class UPrimitiveCollection* Clippables);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActorClipperComponent">();
	}
	static class UActorClipperComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActorClipperComponent>();
	}
};
static_assert(alignof(UActorClipperComponent) == 0x000008, "Wrong alignment on UActorClipperComponent");
static_assert(sizeof(UActorClipperComponent) == 0x000128, "Wrong size on UActorClipperComponent");
static_assert(offsetof(UActorClipperComponent, Shape) == 0x0000A8, "Member 'UActorClipperComponent::Shape' has a wrong offset!");
static_assert(offsetof(UActorClipperComponent, _clippedActors) == 0x0000B0, "Member 'UActorClipperComponent::_clippedActors' has a wrong offset!");
static_assert(offsetof(UActorClipperComponent, _clippables) == 0x000100, "Member 'UActorClipperComponent::_clippables' has a wrong offset!");

// Class DeadByDaylight.ItemWillBeConsumedEffect
// 0x0000 (0x0380 - 0x0380)
class UItemWillBeConsumedEffect final : public UStatusEffect
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemWillBeConsumedEffect">();
	}
	static class UItemWillBeConsumedEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemWillBeConsumedEffect>();
	}
};
static_assert(alignof(UItemWillBeConsumedEffect) == 0x000008, "Wrong alignment on UItemWillBeConsumedEffect");
static_assert(sizeof(UItemWillBeConsumedEffect) == 0x000380, "Wrong size on UItemWillBeConsumedEffect");

// Class DeadByDaylight.ActorDependency
// 0x0010 (0x00B8 - 0x00A8)
class UActorDependency final : public UActorComponent
{
public:
	TArray<struct FDependency>                    Dependencies;                                      // 0x00A8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActorDependency">();
	}
	static class UActorDependency* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActorDependency>();
	}
};
static_assert(alignof(UActorDependency) == 0x000008, "Wrong alignment on UActorDependency");
static_assert(sizeof(UActorDependency) == 0x0000B8, "Wrong size on UActorDependency");
static_assert(offsetof(UActorDependency, Dependencies) == 0x0000A8, "Member 'UActorDependency::Dependencies' has a wrong offset!");

// Class DeadByDaylight.BloodDecalEffectIntensity
// 0x0018 (0x0050 - 0x0038)
class UBloodDecalEffectIntensity final : public UDataAsset
{
public:
	struct FColor                                 IntensifyBloodColor;                               // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 IntensifyBloodColor2;                              // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 IntensifyBloodColorEmissive;                       // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IntensifyBloodColorEmissiveMinimumIntensity;       // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IntensifyBloodColorEmissiveMaximumIntensity;       // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BloodDecalEffectIntensity">();
	}
	static class UBloodDecalEffectIntensity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBloodDecalEffectIntensity>();
	}
};
static_assert(alignof(UBloodDecalEffectIntensity) == 0x000008, "Wrong alignment on UBloodDecalEffectIntensity");
static_assert(sizeof(UBloodDecalEffectIntensity) == 0x000050, "Wrong size on UBloodDecalEffectIntensity");
static_assert(offsetof(UBloodDecalEffectIntensity, IntensifyBloodColor) == 0x000038, "Member 'UBloodDecalEffectIntensity::IntensifyBloodColor' has a wrong offset!");
static_assert(offsetof(UBloodDecalEffectIntensity, IntensifyBloodColor2) == 0x00003C, "Member 'UBloodDecalEffectIntensity::IntensifyBloodColor2' has a wrong offset!");
static_assert(offsetof(UBloodDecalEffectIntensity, IntensifyBloodColorEmissive) == 0x000040, "Member 'UBloodDecalEffectIntensity::IntensifyBloodColorEmissive' has a wrong offset!");
static_assert(offsetof(UBloodDecalEffectIntensity, IntensifyBloodColorEmissiveMinimumIntensity) == 0x000044, "Member 'UBloodDecalEffectIntensity::IntensifyBloodColorEmissiveMinimumIntensity' has a wrong offset!");
static_assert(offsetof(UBloodDecalEffectIntensity, IntensifyBloodColorEmissiveMaximumIntensity) == 0x000048, "Member 'UBloodDecalEffectIntensity::IntensifyBloodColorEmissiveMaximumIntensity' has a wrong offset!");

// Class DeadByDaylight.TokenProvider
// 0x0000 (0x0030 - 0x0030)
class ITokenProvider final : public IInterface
{
public:
	class UTokenCounter* GetTokenProvider() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TokenProvider">();
	}
	static class ITokenProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<ITokenProvider>();
	}
};
static_assert(alignof(ITokenProvider) == 0x000008, "Wrong alignment on ITokenProvider");
static_assert(sizeof(ITokenProvider) == 0x000030, "Wrong size on ITokenProvider");

// Class DeadByDaylight.ActorDetectorComponent
// 0x0028 (0x00D0 - 0x00A8)
class UActorDetectorComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnActorDetected;                                   // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<class UClass*>                         CollectedTypes;                                    // 0x00B8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UPrimitiveComponent*                    _primitive;                                        // 0x00C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnOverlapEnter(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void SetDetectionPrimitive(class UPrimitiveComponent* Primitive);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActorDetectorComponent">();
	}
	static class UActorDetectorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActorDetectorComponent>();
	}
};
static_assert(alignof(UActorDetectorComponent) == 0x000008, "Wrong alignment on UActorDetectorComponent");
static_assert(sizeof(UActorDetectorComponent) == 0x0000D0, "Wrong size on UActorDetectorComponent");
static_assert(offsetof(UActorDetectorComponent, OnActorDetected) == 0x0000A8, "Member 'UActorDetectorComponent::OnActorDetected' has a wrong offset!");
static_assert(offsetof(UActorDetectorComponent, CollectedTypes) == 0x0000B8, "Member 'UActorDetectorComponent::CollectedTypes' has a wrong offset!");
static_assert(offsetof(UActorDetectorComponent, _primitive) == 0x0000C8, "Member 'UActorDetectorComponent::_primitive' has a wrong offset!");

// Class DeadByDaylight.ActorKnowledgeCollection
// 0x0050 (0x00F8 - 0x00A8)
class UActorKnowledgeCollection final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x18];                                      // 0x00A8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         _actors;                                           // 0x00C0(0x0010)(Net, ZeroConstructor, Transient, RepNotify, NativeAccessSpecifierPrivate)
	TArray<class AActor*>                         _previousActors;                                   // 0x00D0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	bool                                          _available;                                        // 0x00E0(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E1[0x7];                                       // 0x00E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ACharacter*                             _possessor;                                        // 0x00E8(0x0008)(Net, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EKnowledgeSharingType                         _sharing;                                          // 0x00F0(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F1[0x7];                                       // 0x00F1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool Authority_Add(class AActor* Actor);
	void Authority_Append(const TArray<class AActor*>& Actors);
	void Authority_Empty();
	void Authority_Remove(class AActor* Actor);
	void Authority_SetAvailable(bool Value);
	void Authority_SetPossessor(class ACharacter* Possessor);
	void Authority_SetSharingType(EKnowledgeSharingType Value);
	void Local_SetAvailable(bool Value);
	void OnRep_Actors();

	bool Contains(class AActor* Actor) const;
	bool IsAvailable(const class ACharacter* Character) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActorKnowledgeCollection">();
	}
	static class UActorKnowledgeCollection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActorKnowledgeCollection>();
	}
};
static_assert(alignof(UActorKnowledgeCollection) == 0x000008, "Wrong alignment on UActorKnowledgeCollection");
static_assert(sizeof(UActorKnowledgeCollection) == 0x0000F8, "Wrong size on UActorKnowledgeCollection");
static_assert(offsetof(UActorKnowledgeCollection, _actors) == 0x0000C0, "Member 'UActorKnowledgeCollection::_actors' has a wrong offset!");
static_assert(offsetof(UActorKnowledgeCollection, _previousActors) == 0x0000D0, "Member 'UActorKnowledgeCollection::_previousActors' has a wrong offset!");
static_assert(offsetof(UActorKnowledgeCollection, _available) == 0x0000E0, "Member 'UActorKnowledgeCollection::_available' has a wrong offset!");
static_assert(offsetof(UActorKnowledgeCollection, _possessor) == 0x0000E8, "Member 'UActorKnowledgeCollection::_possessor' has a wrong offset!");
static_assert(offsetof(UActorKnowledgeCollection, _sharing) == 0x0000F0, "Member 'UActorKnowledgeCollection::_sharing' has a wrong offset!");

// Class DeadByDaylight.KillerAudioMenuReactionComponent
// 0x0010 (0x00B8 - 0x00A8)
class UKillerAudioMenuReactionComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x10];                                      // 0x00A8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void LobbyKillerReactionSpecificSurvivorSFX(const TArray<class ADBDMenuPlayer*>& MenuPlayers);
	void OnLobbyTimeChanged();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerAudioMenuReactionComponent">();
	}
	static class UKillerAudioMenuReactionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillerAudioMenuReactionComponent>();
	}
};
static_assert(alignof(UKillerAudioMenuReactionComponent) == 0x000008, "Wrong alignment on UKillerAudioMenuReactionComponent");
static_assert(sizeof(UKillerAudioMenuReactionComponent) == 0x0000B8, "Wrong size on UKillerAudioMenuReactionComponent");

// Class DeadByDaylight.BreakableWallOutlineUpdateStrategy
// 0x0000 (0x0148 - 0x0148)
class UBreakableWallOutlineUpdateStrategy final : public USourceBasedOutlineUpdateStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BreakableWallOutlineUpdateStrategy">();
	}
	static class UBreakableWallOutlineUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBreakableWallOutlineUpdateStrategy>();
	}
};
static_assert(alignof(UBreakableWallOutlineUpdateStrategy) == 0x000008, "Wrong alignment on UBreakableWallOutlineUpdateStrategy");
static_assert(sizeof(UBreakableWallOutlineUpdateStrategy) == 0x000148, "Wrong size on UBreakableWallOutlineUpdateStrategy");

// Class DeadByDaylight.ActorPairQueryEvaluatorUtilities
// 0x0000 (0x0030 - 0x0030)
class UActorPairQueryEvaluatorUtilities final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActorPairQueryEvaluatorUtilities">();
	}
	static class UActorPairQueryEvaluatorUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActorPairQueryEvaluatorUtilities>();
	}
};
static_assert(alignof(UActorPairQueryEvaluatorUtilities) == 0x000008, "Wrong alignment on UActorPairQueryEvaluatorUtilities");
static_assert(sizeof(UActorPairQueryEvaluatorUtilities) == 0x000030, "Wrong size on UActorPairQueryEvaluatorUtilities");

// Class DeadByDaylight.CamperExposerInstance
// 0x0030 (0x02D0 - 0x02A0)
class ACamperExposerInstance : public AActor
{
public:
	bool                                          IsInterior;                                        // 0x02A0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A1[0x7];                                      // 0x02A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 _audioAgravationLevelRtpc;                         // 0x02A8(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B8[0x18];                                     // 0x02B8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ExitSequenceComplete();
	void SetIsInteriorBP(bool Interior);
	void StartExitSequence(bool WithRandomDelay);
	void StartSpawnSequence(bool WithRandomDelay);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CamperExposerInstance">();
	}
	static class ACamperExposerInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACamperExposerInstance>();
	}
};
static_assert(alignof(ACamperExposerInstance) == 0x000008, "Wrong alignment on ACamperExposerInstance");
static_assert(sizeof(ACamperExposerInstance) == 0x0002D0, "Wrong size on ACamperExposerInstance");
static_assert(offsetof(ACamperExposerInstance, IsInterior) == 0x0002A0, "Member 'ACamperExposerInstance::IsInterior' has a wrong offset!");
static_assert(offsetof(ACamperExposerInstance, _audioAgravationLevelRtpc) == 0x0002A8, "Member 'ACamperExposerInstance::_audioAgravationLevelRtpc' has a wrong offset!");

// Class DeadByDaylight.ObjectRandomizer
// 0x0020 (0x02E0 - 0x02C0)
#pragma pack(push, 0x1)
class alignas(0x10) UObjectRandomizer : public USceneComponent
{
public:
	TArray<class UActorSpawner*>                  Spawners;                                          // 0x02C0(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	int32                                         MinPopulation;                                     // 0x02D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxPopulation;                                     // 0x02D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ObjectRandomizer">();
	}
	static class UObjectRandomizer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UObjectRandomizer>();
	}
};
#pragma pack(pop)
static_assert(alignof(UObjectRandomizer) == 0x000010, "Wrong alignment on UObjectRandomizer");
static_assert(sizeof(UObjectRandomizer) == 0x0002E0, "Wrong size on UObjectRandomizer");
static_assert(offsetof(UObjectRandomizer, Spawners) == 0x0002C0, "Member 'UObjectRandomizer::Spawners' has a wrong offset!");
static_assert(offsetof(UObjectRandomizer, MinPopulation) == 0x0002D0, "Member 'UObjectRandomizer::MinPopulation' has a wrong offset!");
static_assert(offsetof(UObjectRandomizer, MaxPopulation) == 0x0002D4, "Member 'UObjectRandomizer::MaxPopulation' has a wrong offset!");

// Class DeadByDaylight.ActorSpawnerRandomizer
// 0x0020 (0x0300 - 0x02E0)
class UActorSpawnerRandomizer final : public UObjectRandomizer
{
public:
	TArray<struct FSpawnerElement>                ActivatedSpawnerContentLists;                      // 0x02D8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FSpawnerElement>                DeactivatedSpawnerContentLists;                    // 0x02E8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F8[0x8];                                      // 0x02F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActorSpawnerRandomizer">();
	}
	static class UActorSpawnerRandomizer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActorSpawnerRandomizer>();
	}
};
static_assert(alignof(UActorSpawnerRandomizer) == 0x000010, "Wrong alignment on UActorSpawnerRandomizer");
static_assert(sizeof(UActorSpawnerRandomizer) == 0x000300, "Wrong size on UActorSpawnerRandomizer");
static_assert(offsetof(UActorSpawnerRandomizer, ActivatedSpawnerContentLists) == 0x0002D8, "Member 'UActorSpawnerRandomizer::ActivatedSpawnerContentLists' has a wrong offset!");
static_assert(offsetof(UActorSpawnerRandomizer, DeactivatedSpawnerContentLists) == 0x0002E8, "Member 'UActorSpawnerRandomizer::DeactivatedSpawnerContentLists' has a wrong offset!");

// Class DeadByDaylight.CameraHandlerComponent
// 0x0100 (0x01A8 - 0x00A8)
class UCameraHandlerComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x38];                                      // 0x00A8(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EDBDCameraSocketID, class AActor*>       _cameraMap;                                        // 0x00E0(0x0050)(Transient, NativeAccessSpecifierPrivate)
	EDBDCameraSocketID                            _delayedSocketID;                                  // 0x0130(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EDBDCameraSocketID                            _currentSocketID;                                  // 0x0131(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_132[0x47];                                     // 0x0132(0x0047)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _manualZoomAllowPerkModifiers;                     // 0x0179(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_17A[0x6];                                      // 0x017A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            _manualZoomCurveFloat;                             // 0x0180(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   _cameraAttachmentSocket;                           // 0x0188(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_194[0x4];                                      // 0x0194(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        _cameraAttachmentComponent;                        // 0x0198(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isFOVSystemActive;                                // 0x01A0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1A1[0x7];                                      // 0x01A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddCameraToSocket(EDBDCameraSocketID Mode, class AActor* Camera);
	class AActor* GetCurrentCamera();
	EDBDCameraSocketID GetSocketID();
	void OnFirstPersonViewChanged(bool IsFirstPerson);
	void OnLevelReadyToPlay();
	void PlayVFXOnCurrentCamera(class UParticleSystemComponent* Component);
	void SetAttachmentComponent(class USceneComponent* AttachmentComponent);
	void SetSocketID(EDBDCameraSocketID Mode);

	class UCameraComponent* GetCameraComponentBySocket(EDBDCameraSocketID Socket) const;
	float GetDesiredFOV() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraHandlerComponent">();
	}
	static class UCameraHandlerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCameraHandlerComponent>();
	}
};
static_assert(alignof(UCameraHandlerComponent) == 0x000008, "Wrong alignment on UCameraHandlerComponent");
static_assert(sizeof(UCameraHandlerComponent) == 0x0001A8, "Wrong size on UCameraHandlerComponent");
static_assert(offsetof(UCameraHandlerComponent, _cameraMap) == 0x0000E0, "Member 'UCameraHandlerComponent::_cameraMap' has a wrong offset!");
static_assert(offsetof(UCameraHandlerComponent, _delayedSocketID) == 0x000130, "Member 'UCameraHandlerComponent::_delayedSocketID' has a wrong offset!");
static_assert(offsetof(UCameraHandlerComponent, _currentSocketID) == 0x000131, "Member 'UCameraHandlerComponent::_currentSocketID' has a wrong offset!");
static_assert(offsetof(UCameraHandlerComponent, _manualZoomAllowPerkModifiers) == 0x000179, "Member 'UCameraHandlerComponent::_manualZoomAllowPerkModifiers' has a wrong offset!");
static_assert(offsetof(UCameraHandlerComponent, _manualZoomCurveFloat) == 0x000180, "Member 'UCameraHandlerComponent::_manualZoomCurveFloat' has a wrong offset!");
static_assert(offsetof(UCameraHandlerComponent, _cameraAttachmentSocket) == 0x000188, "Member 'UCameraHandlerComponent::_cameraAttachmentSocket' has a wrong offset!");
static_assert(offsetof(UCameraHandlerComponent, _cameraAttachmentComponent) == 0x000198, "Member 'UCameraHandlerComponent::_cameraAttachmentComponent' has a wrong offset!");
static_assert(offsetof(UCameraHandlerComponent, _isFOVSystemActive) == 0x0001A0, "Member 'UCameraHandlerComponent::_isFOVSystemActive' has a wrong offset!");

// Class DeadByDaylight.ActorVariationSpawner
// 0x0060 (0x0320 - 0x02C0)
class UActorVariationSpawner final : public USceneComponent
{
public:
	TSoftClassPtr<class UClass>                   Visualization;                                     // 0x02C0(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FActorVariationElements>        Variations;                                        // 0x02F8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_308[0x8];                                      // 0x0308(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UClass*                                 _toSpawn;                                          // 0x0310(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_318[0x8];                                      // 0x0318(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActorVariationSpawner">();
	}
	static class UActorVariationSpawner* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActorVariationSpawner>();
	}
};
static_assert(alignof(UActorVariationSpawner) == 0x000010, "Wrong alignment on UActorVariationSpawner");
static_assert(sizeof(UActorVariationSpawner) == 0x000320, "Wrong size on UActorVariationSpawner");
static_assert(offsetof(UActorVariationSpawner, Visualization) == 0x0002C0, "Member 'UActorVariationSpawner::Visualization' has a wrong offset!");
static_assert(offsetof(UActorVariationSpawner, Variations) == 0x0002F8, "Member 'UActorVariationSpawner::Variations' has a wrong offset!");
static_assert(offsetof(UActorVariationSpawner, _toSpawn) == 0x000310, "Member 'UActorVariationSpawner::_toSpawn' has a wrong offset!");

// Class DeadByDaylight.AIBotsManager
// 0x0038 (0x0070 - 0x0038)
class UAIBotsManager final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x38];                                      // 0x0038(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIBotsManager">();
	}
	static class UAIBotsManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIBotsManager>();
	}
};
static_assert(alignof(UAIBotsManager) == 0x000008, "Wrong alignment on UAIBotsManager");
static_assert(sizeof(UAIBotsManager) == 0x000070, "Wrong size on UAIBotsManager");

// Class DeadByDaylight.Tile2
// 0x0060 (0x0300 - 0x02A0)
class ATile2 : public AActor
{
public:
	struct FRandomStream                          SharedTileRandomizer;                              // 0x02A0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnLevelLoaded;                                     // 0x02A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSetSpawnObject;                                  // 0x02B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnAllTileSpawned;                                  // 0x02C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             InitOnSpawned;                                     // 0x02D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          EnableRandomizer;                                  // 0x02E8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E9[0x3];                                      // 0x02E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RandomizerSeed;                                    // 0x02EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTileRandomizerData>            Randomizers;                                       // 0x02F0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Tile2">();
	}
	static class ATile2* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATile2>();
	}
};
static_assert(alignof(ATile2) == 0x000008, "Wrong alignment on ATile2");
static_assert(sizeof(ATile2) == 0x000300, "Wrong size on ATile2");
static_assert(offsetof(ATile2, SharedTileRandomizer) == 0x0002A0, "Member 'ATile2::SharedTileRandomizer' has a wrong offset!");
static_assert(offsetof(ATile2, OnLevelLoaded) == 0x0002A8, "Member 'ATile2::OnLevelLoaded' has a wrong offset!");
static_assert(offsetof(ATile2, OnSetSpawnObject) == 0x0002B8, "Member 'ATile2::OnSetSpawnObject' has a wrong offset!");
static_assert(offsetof(ATile2, OnAllTileSpawned) == 0x0002C8, "Member 'ATile2::OnAllTileSpawned' has a wrong offset!");
static_assert(offsetof(ATile2, InitOnSpawned) == 0x0002D8, "Member 'ATile2::InitOnSpawned' has a wrong offset!");
static_assert(offsetof(ATile2, EnableRandomizer) == 0x0002E8, "Member 'ATile2::EnableRandomizer' has a wrong offset!");
static_assert(offsetof(ATile2, RandomizerSeed) == 0x0002EC, "Member 'ATile2::RandomizerSeed' has a wrong offset!");
static_assert(offsetof(ATile2, Randomizers) == 0x0002F0, "Member 'ATile2::Randomizers' has a wrong offset!");

// Class DeadByDaylight.BorderTile2
// 0x0018 (0x0318 - 0x0300)
class ABorderTile2 final : public ATile2
{
public:
	TArray<struct FBorderElements2>               Borders;                                           // 0x0300(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          EnableBorderDirection;                             // 0x0310(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDirection                                    BorderDirection;                                   // 0x0311(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_312[0x6];                                      // 0x0312(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BorderTile2">();
	}
	static class ABorderTile2* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABorderTile2>();
	}
};
static_assert(alignof(ABorderTile2) == 0x000008, "Wrong alignment on ABorderTile2");
static_assert(sizeof(ABorderTile2) == 0x000318, "Wrong size on ABorderTile2");
static_assert(offsetof(ABorderTile2, Borders) == 0x000300, "Member 'ABorderTile2::Borders' has a wrong offset!");
static_assert(offsetof(ABorderTile2, EnableBorderDirection) == 0x000310, "Member 'ABorderTile2::EnableBorderDirection' has a wrong offset!");
static_assert(offsetof(ABorderTile2, BorderDirection) == 0x000311, "Member 'ABorderTile2::BorderDirection' has a wrong offset!");

// Class DeadByDaylight.MeatHookOutlineUpdateStrategy
// 0x0040 (0x0188 - 0x0148)
class UMeatHookOutlineUpdateStrategy final : public USourceBasedOutlineUpdateStrategy
{
public:
	struct FLinearColor                           HookedOutlineColorSlasher;                         // 0x0148(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           CarryingOutlineColorSlasher;                       // 0x0158(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           DefaultOutlineColorSlasher;                        // 0x0168(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           VisibleOutlineColorCamper;                         // 0x0178(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Authority_AddBasementHookToPlayerMapItem();
	void Local_AddBasementOfferingReveal();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MeatHookOutlineUpdateStrategy">();
	}
	static class UMeatHookOutlineUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMeatHookOutlineUpdateStrategy>();
	}
};
static_assert(alignof(UMeatHookOutlineUpdateStrategy) == 0x000008, "Wrong alignment on UMeatHookOutlineUpdateStrategy");
static_assert(sizeof(UMeatHookOutlineUpdateStrategy) == 0x000188, "Wrong size on UMeatHookOutlineUpdateStrategy");
static_assert(offsetof(UMeatHookOutlineUpdateStrategy, HookedOutlineColorSlasher) == 0x000148, "Member 'UMeatHookOutlineUpdateStrategy::HookedOutlineColorSlasher' has a wrong offset!");
static_assert(offsetof(UMeatHookOutlineUpdateStrategy, CarryingOutlineColorSlasher) == 0x000158, "Member 'UMeatHookOutlineUpdateStrategy::CarryingOutlineColorSlasher' has a wrong offset!");
static_assert(offsetof(UMeatHookOutlineUpdateStrategy, DefaultOutlineColorSlasher) == 0x000168, "Member 'UMeatHookOutlineUpdateStrategy::DefaultOutlineColorSlasher' has a wrong offset!");
static_assert(offsetof(UMeatHookOutlineUpdateStrategy, VisibleOutlineColorCamper) == 0x000178, "Member 'UMeatHookOutlineUpdateStrategy::VisibleOutlineColorCamper' has a wrong offset!");

// Class DeadByDaylight.ConfigurableCollisionComponent
// 0x0070 (0x0330 - 0x02C0)
#pragma pack(push, 0x1)
class alignas(0x10) UConfigurableCollisionComponent : public USceneComponent
{
public:
	struct FCollisionZoneParams                   _collisionParams;                                  // 0x02C0(0x0048)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FGameplayTag>                   _requiredPresenceTag;                              // 0x0308(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          _spawnOnAuthorityOnly;                             // 0x0318(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_319[0x7];                                      // 0x0319(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UShapeComponent*                        _collisionZone;                                    // 0x0320(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool FromSweep, const struct FHitResult& SweepResult);
	void OnEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void OnLevelReadyToPlay();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConfigurableCollisionComponent">();
	}
	static class UConfigurableCollisionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfigurableCollisionComponent>();
	}
};
#pragma pack(pop)
static_assert(alignof(UConfigurableCollisionComponent) == 0x000010, "Wrong alignment on UConfigurableCollisionComponent");
static_assert(sizeof(UConfigurableCollisionComponent) == 0x000330, "Wrong size on UConfigurableCollisionComponent");
static_assert(offsetof(UConfigurableCollisionComponent, _collisionParams) == 0x0002C0, "Member 'UConfigurableCollisionComponent::_collisionParams' has a wrong offset!");
static_assert(offsetof(UConfigurableCollisionComponent, _requiredPresenceTag) == 0x000308, "Member 'UConfigurableCollisionComponent::_requiredPresenceTag' has a wrong offset!");
static_assert(offsetof(UConfigurableCollisionComponent, _spawnOnAuthorityOnly) == 0x000318, "Member 'UConfigurableCollisionComponent::_spawnOnAuthorityOnly' has a wrong offset!");
static_assert(offsetof(UConfigurableCollisionComponent, _collisionZone) == 0x000320, "Member 'UConfigurableCollisionComponent::_collisionZone' has a wrong offset!");

// Class DeadByDaylight.AICharacterBehaviourInteractWithActor
// 0x0030 (0x0088 - 0x0058)
class UAICharacterBehaviourInteractWithActor : public UAICharacterBehaviour
{
public:
	class ADBDPlayer*                             _aiPlayer;                                         // 0x0058(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ADBDAIPlayerController*                 _aiPlayerController;                               // 0x0060(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAICharacterBehaviourInteractWithActorData* _behaviourData;                                    // 0x0068(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_70[0x18];                                      // 0x0070(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnMovementFinished(const struct FAIRequestID& RequestID, EPathFollowingResult Result);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AICharacterBehaviourInteractWithActor">();
	}
	static class UAICharacterBehaviourInteractWithActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAICharacterBehaviourInteractWithActor>();
	}
};
static_assert(alignof(UAICharacterBehaviourInteractWithActor) == 0x000008, "Wrong alignment on UAICharacterBehaviourInteractWithActor");
static_assert(sizeof(UAICharacterBehaviourInteractWithActor) == 0x000088, "Wrong size on UAICharacterBehaviourInteractWithActor");
static_assert(offsetof(UAICharacterBehaviourInteractWithActor, _aiPlayer) == 0x000058, "Member 'UAICharacterBehaviourInteractWithActor::_aiPlayer' has a wrong offset!");
static_assert(offsetof(UAICharacterBehaviourInteractWithActor, _aiPlayerController) == 0x000060, "Member 'UAICharacterBehaviourInteractWithActor::_aiPlayerController' has a wrong offset!");
static_assert(offsetof(UAICharacterBehaviourInteractWithActor, _behaviourData) == 0x000068, "Member 'UAICharacterBehaviourInteractWithActor::_behaviourData' has a wrong offset!");

// Class DeadByDaylight.AICharacterBehaviourDropPallet
// 0x0008 (0x0090 - 0x0088)
class UAICharacterBehaviourDropPallet final : public UAICharacterBehaviourInteractWithActor
{
public:
	class APallet*                                _targetPallet;                                     // 0x0088(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AICharacterBehaviourDropPallet">();
	}
	static class UAICharacterBehaviourDropPallet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAICharacterBehaviourDropPallet>();
	}
};
static_assert(alignof(UAICharacterBehaviourDropPallet) == 0x000008, "Wrong alignment on UAICharacterBehaviourDropPallet");
static_assert(sizeof(UAICharacterBehaviourDropPallet) == 0x000090, "Wrong size on UAICharacterBehaviourDropPallet");
static_assert(offsetof(UAICharacterBehaviourDropPallet, _targetPallet) == 0x000088, "Member 'UAICharacterBehaviourDropPallet::_targetPallet' has a wrong offset!");

// Class DeadByDaylight.AICharacterBehaviourInteractWithActorData
// 0x0020 (0x0050 - 0x0030)
class UAICharacterBehaviourInteractWithActorData final : public UAICharacterBehaviourData
{
public:
	class AActor*                                 TargetActor;                                       // 0x0030(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x10];                                      // 0x0038(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	ECharacterMovementTypes                       CharacterMovementType;                             // 0x0048(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UsePathfinding;                                    // 0x0049(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A[0x6];                                       // 0x004A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Init(class AActor* Actor, ECharacterMovementTypes Param_CharacterMovementType, bool Param_UsePathfinding);
	void WatchGameEventType(const struct FGameplayTag& GameEventType);
	void WatchGameEventTypes(const TArray<struct FGameplayTag>& GameEventTypes);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AICharacterBehaviourInteractWithActorData">();
	}
	static class UAICharacterBehaviourInteractWithActorData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAICharacterBehaviourInteractWithActorData>();
	}
};
static_assert(alignof(UAICharacterBehaviourInteractWithActorData) == 0x000008, "Wrong alignment on UAICharacterBehaviourInteractWithActorData");
static_assert(sizeof(UAICharacterBehaviourInteractWithActorData) == 0x000050, "Wrong size on UAICharacterBehaviourInteractWithActorData");
static_assert(offsetof(UAICharacterBehaviourInteractWithActorData, TargetActor) == 0x000030, "Member 'UAICharacterBehaviourInteractWithActorData::TargetActor' has a wrong offset!");
static_assert(offsetof(UAICharacterBehaviourInteractWithActorData, CharacterMovementType) == 0x000048, "Member 'UAICharacterBehaviourInteractWithActorData::CharacterMovementType' has a wrong offset!");
static_assert(offsetof(UAICharacterBehaviourInteractWithActorData, UsePathfinding) == 0x000049, "Member 'UAICharacterBehaviourInteractWithActorData::UsePathfinding' has a wrong offset!");

// Class DeadByDaylight.AICharacterBehaviourInteractWithHook
// 0x0008 (0x0090 - 0x0088)
class UAICharacterBehaviourInteractWithHook final : public UAICharacterBehaviourInteractWithActor
{
public:
	class AMeatHook*                              _targetHook;                                       // 0x0088(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AICharacterBehaviourInteractWithHook">();
	}
	static class UAICharacterBehaviourInteractWithHook* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAICharacterBehaviourInteractWithHook>();
	}
};
static_assert(alignof(UAICharacterBehaviourInteractWithHook) == 0x000008, "Wrong alignment on UAICharacterBehaviourInteractWithHook");
static_assert(sizeof(UAICharacterBehaviourInteractWithHook) == 0x000090, "Wrong size on UAICharacterBehaviourInteractWithHook");
static_assert(offsetof(UAICharacterBehaviourInteractWithHook, _targetHook) == 0x000088, "Member 'UAICharacterBehaviourInteractWithHook::_targetHook' has a wrong offset!");

// Class DeadByDaylight.UMGPopupButton
// 0x0030 (0x04F0 - 0x04C0)
class UUMGPopupButton final : public UUMGBaseButtonWidget
{
public:
	uint8                                         Pad_4B8[0x14];                                     // 0x04B8(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DisabledOpacity;                                   // 0x04CC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EnabledOpacity;                                    // 0x04D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4D4[0x4];                                      // 0x04D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UImage*                                 VFXs;                                              // 0x04D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Line;                                              // 0x04E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 FXSmoke;                                           // 0x04E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnButtonClicked();
	void OnButtonPressed();
	void OnButtonReleased();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGPopupButton">();
	}
	static class UUMGPopupButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGPopupButton>();
	}
};
static_assert(alignof(UUMGPopupButton) == 0x000010, "Wrong alignment on UUMGPopupButton");
static_assert(sizeof(UUMGPopupButton) == 0x0004F0, "Wrong size on UUMGPopupButton");
static_assert(offsetof(UUMGPopupButton, DisabledOpacity) == 0x0004CC, "Member 'UUMGPopupButton::DisabledOpacity' has a wrong offset!");
static_assert(offsetof(UUMGPopupButton, EnabledOpacity) == 0x0004D0, "Member 'UUMGPopupButton::EnabledOpacity' has a wrong offset!");
static_assert(offsetof(UUMGPopupButton, VFXs) == 0x0004D8, "Member 'UUMGPopupButton::VFXs' has a wrong offset!");
static_assert(offsetof(UUMGPopupButton, Line) == 0x0004E0, "Member 'UUMGPopupButton::Line' has a wrong offset!");
static_assert(offsetof(UUMGPopupButton, FXSmoke) == 0x0004E8, "Member 'UUMGPopupButton::FXSmoke' has a wrong offset!");

// Class DeadByDaylight.ContainsItemInterface
// 0x0000 (0x0030 - 0x0030)
class IContainsItemInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ContainsItemInterface">();
	}
	static class IContainsItemInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IContainsItemInterface>();
	}
};
static_assert(alignof(IContainsItemInterface) == 0x000008, "Wrong alignment on IContainsItemInterface");
static_assert(sizeof(IContainsItemInterface) == 0x000030, "Wrong size on IContainsItemInterface");

// Class DeadByDaylight.AICharacterEscapeCarriedData
// 0x0008 (0x0038 - 0x0030)
class UAICharacterEscapeCarriedData final : public UAICharacterBehaviourData
{
public:
	bool                                          _preventWiggleSuccess;                             // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Init(bool PreventWiggleSuccess);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AICharacterEscapeCarriedData">();
	}
	static class UAICharacterEscapeCarriedData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAICharacterEscapeCarriedData>();
	}
};
static_assert(alignof(UAICharacterEscapeCarriedData) == 0x000008, "Wrong alignment on UAICharacterEscapeCarriedData");
static_assert(sizeof(UAICharacterEscapeCarriedData) == 0x000038, "Wrong size on UAICharacterEscapeCarriedData");
static_assert(offsetof(UAICharacterEscapeCarriedData, _preventWiggleSuccess) == 0x000030, "Member 'UAICharacterEscapeCarriedData::_preventWiggleSuccess' has a wrong offset!");

// Class DeadByDaylight.AICharacterEscapeCarried
// 0x0010 (0x0068 - 0x0058)
class UAICharacterEscapeCarried final : public UAICharacterBehaviour
{
public:
	class ACamperPlayer*                          _camperPlayer;                                     // 0x0058(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAICharacterEscapeCarriedData*          _behaviourData;                                    // 0x0060(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AICharacterEscapeCarried">();
	}
	static class UAICharacterEscapeCarried* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAICharacterEscapeCarried>();
	}
};
static_assert(alignof(UAICharacterEscapeCarried) == 0x000008, "Wrong alignment on UAICharacterEscapeCarried");
static_assert(sizeof(UAICharacterEscapeCarried) == 0x000068, "Wrong size on UAICharacterEscapeCarried");
static_assert(offsetof(UAICharacterEscapeCarried, _camperPlayer) == 0x000058, "Member 'UAICharacterEscapeCarried::_camperPlayer' has a wrong offset!");
static_assert(offsetof(UAICharacterEscapeCarried, _behaviourData) == 0x000060, "Member 'UAICharacterEscapeCarried::_behaviourData' has a wrong offset!");

// Class DeadByDaylight.CondemnedUIDataInterface
// 0x0000 (0x0030 - 0x0030)
class ICondemnedUIDataInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CondemnedUIDataInterface">();
	}
	static class ICondemnedUIDataInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ICondemnedUIDataInterface>();
	}
};
static_assert(alignof(ICondemnedUIDataInterface) == 0x000008, "Wrong alignment on ICondemnedUIDataInterface");
static_assert(sizeof(ICondemnedUIDataInterface) == 0x000030, "Wrong size on ICondemnedUIDataInterface");

// Class DeadByDaylight.CharacterEvasionBehaviourData
// 0x0020 (0x0050 - 0x0030)
class UCharacterEvasionBehaviourData final : public UAICharacterBehaviourData
{
public:
	class AActor*                                 _hunter;                                           // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class AActor*>                         _escapePoints;                                     // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPrivate)
	float                                         _minEscapeDist;                                    // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Init(class AActor* Hunter, const TArray<class AActor*>& EscapePoints, float MinEscapeDist);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterEvasionBehaviourData">();
	}
	static class UCharacterEvasionBehaviourData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterEvasionBehaviourData>();
	}
};
static_assert(alignof(UCharacterEvasionBehaviourData) == 0x000008, "Wrong alignment on UCharacterEvasionBehaviourData");
static_assert(sizeof(UCharacterEvasionBehaviourData) == 0x000050, "Wrong size on UCharacterEvasionBehaviourData");
static_assert(offsetof(UCharacterEvasionBehaviourData, _hunter) == 0x000030, "Member 'UCharacterEvasionBehaviourData::_hunter' has a wrong offset!");
static_assert(offsetof(UCharacterEvasionBehaviourData, _escapePoints) == 0x000038, "Member 'UCharacterEvasionBehaviourData::_escapePoints' has a wrong offset!");
static_assert(offsetof(UCharacterEvasionBehaviourData, _minEscapeDist) == 0x000048, "Member 'UCharacterEvasionBehaviourData::_minEscapeDist' has a wrong offset!");

// Class DeadByDaylight.CamperSlashableComponent
// 0x00F0 (0x0198 - 0x00A8)
class UCamperSlashableComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UCapsuleComponent*                      _slashableZone;                                    // 0x00B0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCapsuleComponent*                      _hookSlashableZone;                                // 0x00B8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _standingCapsuleHalfHeight;                        // 0x00C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _crouchCapsuleHalfHeight;                          // 0x00C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  _slashableDisablingStateTags;                      // 0x00C8(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         _sourceActivationLingerDuration;                   // 0x00E8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_EC[0x34];                                      // 0x00EC(0x0034)(Fixing Size After Last Property [ Dumper-7 ])
	class USlashableActivationSourceCollection*   _slashableActivationSources;                       // 0x0120(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_128[0x70];                                     // 0x0128(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetCrouchCapsuleHalfHeight(float Height);
	void SetHookSlashableZone(class UCapsuleComponent* Zone);
	void SetSlashableZone(class UCapsuleComponent* Zone);
	void SetStandingCapsuleHalfHeight(float Height);
	void SetUseCrouchSlashableCapsule(bool UseCrouchCapsule);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CamperSlashableComponent">();
	}
	static class UCamperSlashableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCamperSlashableComponent>();
	}
};
static_assert(alignof(UCamperSlashableComponent) == 0x000008, "Wrong alignment on UCamperSlashableComponent");
static_assert(sizeof(UCamperSlashableComponent) == 0x000198, "Wrong size on UCamperSlashableComponent");
static_assert(offsetof(UCamperSlashableComponent, _slashableZone) == 0x0000B0, "Member 'UCamperSlashableComponent::_slashableZone' has a wrong offset!");
static_assert(offsetof(UCamperSlashableComponent, _hookSlashableZone) == 0x0000B8, "Member 'UCamperSlashableComponent::_hookSlashableZone' has a wrong offset!");
static_assert(offsetof(UCamperSlashableComponent, _standingCapsuleHalfHeight) == 0x0000C0, "Member 'UCamperSlashableComponent::_standingCapsuleHalfHeight' has a wrong offset!");
static_assert(offsetof(UCamperSlashableComponent, _crouchCapsuleHalfHeight) == 0x0000C4, "Member 'UCamperSlashableComponent::_crouchCapsuleHalfHeight' has a wrong offset!");
static_assert(offsetof(UCamperSlashableComponent, _slashableDisablingStateTags) == 0x0000C8, "Member 'UCamperSlashableComponent::_slashableDisablingStateTags' has a wrong offset!");
static_assert(offsetof(UCamperSlashableComponent, _sourceActivationLingerDuration) == 0x0000E8, "Member 'UCamperSlashableComponent::_sourceActivationLingerDuration' has a wrong offset!");
static_assert(offsetof(UCamperSlashableComponent, _slashableActivationSources) == 0x000120, "Member 'UCamperSlashableComponent::_slashableActivationSources' has a wrong offset!");

// Class DeadByDaylight.AICharacterHideInLockerBehaviourData
// 0x0010 (0x0040 - 0x0030)
class UAICharacterHideInLockerBehaviourData final : public UAICharacterBehaviourData
{
public:
	class ALocker*                                TargetLocker;                                      // 0x0030(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECharacterMovementTypes                       CharacterMovementType;                             // 0x0038(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Init(class ALocker* Locker, ECharacterMovementTypes Param_CharacterMovementType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AICharacterHideInLockerBehaviourData">();
	}
	static class UAICharacterHideInLockerBehaviourData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAICharacterHideInLockerBehaviourData>();
	}
};
static_assert(alignof(UAICharacterHideInLockerBehaviourData) == 0x000008, "Wrong alignment on UAICharacterHideInLockerBehaviourData");
static_assert(sizeof(UAICharacterHideInLockerBehaviourData) == 0x000040, "Wrong size on UAICharacterHideInLockerBehaviourData");
static_assert(offsetof(UAICharacterHideInLockerBehaviourData, TargetLocker) == 0x000030, "Member 'UAICharacterHideInLockerBehaviourData::TargetLocker' has a wrong offset!");
static_assert(offsetof(UAICharacterHideInLockerBehaviourData, CharacterMovementType) == 0x000038, "Member 'UAICharacterHideInLockerBehaviourData::CharacterMovementType' has a wrong offset!");

// Class DeadByDaylight.AICharacterHideInLockerBehaviour
// 0x0030 (0x0088 - 0x0058)
class UAICharacterHideInLockerBehaviour final : public UAICharacterBehaviour
{
public:
	class ADBDPlayer*                             _aiPlayer;                                         // 0x0058(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ADBDAIPlayerController*                 _aiPlayerController;                               // 0x0060(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_68[0x10];                                      // 0x0068(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UAICharacterHideInLockerBehaviourData*  _characterHideInLockerData;                        // 0x0078(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_80[0x8];                                       // 0x0080(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnMovementFinished(const struct FAIRequestID& RequestID, EPathFollowingResult Result);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AICharacterHideInLockerBehaviour">();
	}
	static class UAICharacterHideInLockerBehaviour* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAICharacterHideInLockerBehaviour>();
	}
};
static_assert(alignof(UAICharacterHideInLockerBehaviour) == 0x000008, "Wrong alignment on UAICharacterHideInLockerBehaviour");
static_assert(sizeof(UAICharacterHideInLockerBehaviour) == 0x000088, "Wrong size on UAICharacterHideInLockerBehaviour");
static_assert(offsetof(UAICharacterHideInLockerBehaviour, _aiPlayer) == 0x000058, "Member 'UAICharacterHideInLockerBehaviour::_aiPlayer' has a wrong offset!");
static_assert(offsetof(UAICharacterHideInLockerBehaviour, _aiPlayerController) == 0x000060, "Member 'UAICharacterHideInLockerBehaviour::_aiPlayerController' has a wrong offset!");
static_assert(offsetof(UAICharacterHideInLockerBehaviour, _characterHideInLockerData) == 0x000078, "Member 'UAICharacterHideInLockerBehaviour::_characterHideInLockerData' has a wrong offset!");

// Class DeadByDaylight.CharacterCollectionUtilities
// 0x0000 (0x0030 - 0x0030)
class UCharacterCollectionUtilities final : public UBlueprintFunctionLibrary
{
public:
	static const TSet<class ACharacter*> GetAllCharacters(const class UObject* WorldContextObject);
	static TArray<class ADBDPlayer*> GetAllDBDPlayers(const class UObject* WorldContextObject);
	static TArray<class ADBDPlayer*> GetCharactersByPlayerTeam(EPlayerTeam PlayerTeam, const class UObject* WorldContextObject);
	static TArray<class ASlasherPlayer*> GetInGameKillers(const class UObject* WorldContextObject);
	static const TSet<class ASlasherPlayer*> GetInGameKillersByRef(const class UObject* WorldContextObject);
	static TArray<class ADBDPlayer*> GetInGameOtherCharacters(const class UObject* WorldContextObject);
	static TArray<class ADBDPlayer*> GetInGamePlayers(const class UObject* WorldContextObject);
	static TArray<class ACamperPlayer*> GetInGameSurvivors(const class UObject* WorldContextObject);
	static TArray<class ADBDPlayer*> GetInGameSurvivorsAsPlayers(const class UObject* WorldContextObject);
	static const TSet<class ACamperPlayer*> GetInGameSurvivorsByRef(const class UObject* WorldContextObject);
	static class ASlasherPlayer* GetKiller(const class UObject* WorldContextObject);
	static const int32 GetNumberOfInjuredHookedOrDyingSurvivors(const class UObject* WorldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterCollectionUtilities">();
	}
	static class UCharacterCollectionUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterCollectionUtilities>();
	}
};
static_assert(alignof(UCharacterCollectionUtilities) == 0x000008, "Wrong alignment on UCharacterCollectionUtilities");
static_assert(sizeof(UCharacterCollectionUtilities) == 0x000030, "Wrong size on UCharacterCollectionUtilities");

// Class DeadByDaylight.AICharacterRepairGeneratorBehaviourData
// 0x0010 (0x0040 - 0x0030)
class UAICharacterRepairGeneratorBehaviourData final : public UAICharacterBehaviourData
{
public:
	class AGenerator*                             _generator;                                        // 0x0030(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ECharacterMovementTypes                       _characterMovementType;                            // 0x0038(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Init(class AGenerator* Generator, ECharacterMovementTypes CharacterMovementType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AICharacterRepairGeneratorBehaviourData">();
	}
	static class UAICharacterRepairGeneratorBehaviourData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAICharacterRepairGeneratorBehaviourData>();
	}
};
static_assert(alignof(UAICharacterRepairGeneratorBehaviourData) == 0x000008, "Wrong alignment on UAICharacterRepairGeneratorBehaviourData");
static_assert(sizeof(UAICharacterRepairGeneratorBehaviourData) == 0x000040, "Wrong size on UAICharacterRepairGeneratorBehaviourData");
static_assert(offsetof(UAICharacterRepairGeneratorBehaviourData, _generator) == 0x000030, "Member 'UAICharacterRepairGeneratorBehaviourData::_generator' has a wrong offset!");
static_assert(offsetof(UAICharacterRepairGeneratorBehaviourData, _characterMovementType) == 0x000038, "Member 'UAICharacterRepairGeneratorBehaviourData::_characterMovementType' has a wrong offset!");

// Class DeadByDaylight.AICharacterRepairGeneratorBehaviour
// 0x0048 (0x00A0 - 0x0058)
class UAICharacterRepairGeneratorBehaviour final : public UAICharacterBehaviour
{
public:
	uint8                                         Pad_58[0x18];                                      // 0x0058(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class ADBDPlayer*                             _aiPlayer;                                         // 0x0070(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ADBDAIPlayerController*                 _aiPlayerController;                               // 0x0078(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInteractor*                            _targetInteractor;                                 // 0x0080(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAICharacterRepairGeneratorBehaviourData* _characterRepairGeneratorData;                     // 0x0088(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_90[0x10];                                      // 0x0090(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnGeneratorRepairedEventHandler(bool IsAutoCompleted);
	void OnMovementFinished(const struct FAIRequestID& RequestID, EPathFollowingResult Result);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AICharacterRepairGeneratorBehaviour">();
	}
	static class UAICharacterRepairGeneratorBehaviour* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAICharacterRepairGeneratorBehaviour>();
	}
};
static_assert(alignof(UAICharacterRepairGeneratorBehaviour) == 0x000008, "Wrong alignment on UAICharacterRepairGeneratorBehaviour");
static_assert(sizeof(UAICharacterRepairGeneratorBehaviour) == 0x0000A0, "Wrong size on UAICharacterRepairGeneratorBehaviour");
static_assert(offsetof(UAICharacterRepairGeneratorBehaviour, _aiPlayer) == 0x000070, "Member 'UAICharacterRepairGeneratorBehaviour::_aiPlayer' has a wrong offset!");
static_assert(offsetof(UAICharacterRepairGeneratorBehaviour, _aiPlayerController) == 0x000078, "Member 'UAICharacterRepairGeneratorBehaviour::_aiPlayerController' has a wrong offset!");
static_assert(offsetof(UAICharacterRepairGeneratorBehaviour, _targetInteractor) == 0x000080, "Member 'UAICharacterRepairGeneratorBehaviour::_targetInteractor' has a wrong offset!");
static_assert(offsetof(UAICharacterRepairGeneratorBehaviour, _characterRepairGeneratorData) == 0x000088, "Member 'UAICharacterRepairGeneratorBehaviour::_characterRepairGeneratorData' has a wrong offset!");

// Class DeadByDaylight.MobileProfileDAL
// 0x0000 (0x0088 - 0x0088)
class UMobileProfileDAL final : public UPlayerProfileDAL
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MobileProfileDAL">();
	}
	static class UMobileProfileDAL* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMobileProfileDAL>();
	}
};
static_assert(alignof(UMobileProfileDAL) == 0x000008, "Wrong alignment on UMobileProfileDAL");
static_assert(sizeof(UMobileProfileDAL) == 0x000088, "Wrong size on UMobileProfileDAL");

// Class DeadByDaylight.CarriedMovementComponent
// 0x00D8 (0x0180 - 0x00A8)
class UCarriedMovementComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0xD8];                                      // 0x00A8(0x00D8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CarriedMovementComponent">();
	}
	static class UCarriedMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCarriedMovementComponent>();
	}
};
static_assert(alignof(UCarriedMovementComponent) == 0x000008, "Wrong alignment on UCarriedMovementComponent");
static_assert(sizeof(UCarriedMovementComponent) == 0x000180, "Wrong size on UCarriedMovementComponent");

// Class DeadByDaylight.AIHealAllyBehaviourData
// 0x0008 (0x0038 - 0x0030)
class UAIHealAllyBehaviourData final : public UAICharacterBehaviourData
{
public:
	class ACamperPlayer*                          _targetAlly;                                       // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void Init(class ACamperPlayer* AllyToHealTarget);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIHealAllyBehaviourData">();
	}
	static class UAIHealAllyBehaviourData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIHealAllyBehaviourData>();
	}
};
static_assert(alignof(UAIHealAllyBehaviourData) == 0x000008, "Wrong alignment on UAIHealAllyBehaviourData");
static_assert(sizeof(UAIHealAllyBehaviourData) == 0x000038, "Wrong size on UAIHealAllyBehaviourData");
static_assert(offsetof(UAIHealAllyBehaviourData, _targetAlly) == 0x000030, "Member 'UAIHealAllyBehaviourData::_targetAlly' has a wrong offset!");

// Class DeadByDaylight.AIHealAllyBehaviour
// 0x0038 (0x0090 - 0x0058)
class UAIHealAllyBehaviour final : public UAICharacterBehaviour
{
public:
	class UAIHealAllyBehaviourData*               _behaviourData;                                    // 0x0058(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ADBDAIPlayerController*                 _aiController;                                     // 0x0060(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ADBDPlayer*                             _aiPlayer;                                         // 0x0068(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_70[0x20];                                      // 0x0070(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Init(class ADBDPlayer* Character, class UAICharacterBehaviourData* behaviourData);
	void TargetPositionReached(const struct FAIRequestID& RequestID, EPathFollowingResult Result);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIHealAllyBehaviour">();
	}
	static class UAIHealAllyBehaviour* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIHealAllyBehaviour>();
	}
};
static_assert(alignof(UAIHealAllyBehaviour) == 0x000008, "Wrong alignment on UAIHealAllyBehaviour");
static_assert(sizeof(UAIHealAllyBehaviour) == 0x000090, "Wrong size on UAIHealAllyBehaviour");
static_assert(offsetof(UAIHealAllyBehaviour, _behaviourData) == 0x000058, "Member 'UAIHealAllyBehaviour::_behaviourData' has a wrong offset!");
static_assert(offsetof(UAIHealAllyBehaviour, _aiController) == 0x000060, "Member 'UAIHealAllyBehaviour::_aiController' has a wrong offset!");
static_assert(offsetof(UAIHealAllyBehaviour, _aiPlayer) == 0x000068, "Member 'UAIHealAllyBehaviour::_aiPlayer' has a wrong offset!");

// Class DeadByDaylight.CamperMovementComponent
// 0x00B0 (0x14D0 - 0x1420)
class UCamperMovementComponent final : public UDBDCharacterMovementComponent
{
public:
	uint8                                         Pad_1420[0x18];                                    // 0x1420(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxCrawlSpeed;                                     // 0x1438(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRunSpeed;                                       // 0x143C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               _defaultRotationRate;                              // 0x1440(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FRotator                               _rotationRateWhileCrawling;                        // 0x1458(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class UCurveFloat*                            _dropStaggerDuration;                              // 0x1470(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            _dropStaggerMaxSpeed;                              // 0x1478(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1480[0x50];                                    // 0x1480(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCamperHealthStateChanged(ECamperDamageState OldDamageState, ECamperDamageState CurrentDamageState);

	struct FRotator GetDefaultRotationRate() const;
	float GetDropStaggerTimeLeft() const;
	struct FRotator GetRotationRateWhileCrawling() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CamperMovementComponent">();
	}
	static class UCamperMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCamperMovementComponent>();
	}
};
static_assert(alignof(UCamperMovementComponent) == 0x000010, "Wrong alignment on UCamperMovementComponent");
static_assert(sizeof(UCamperMovementComponent) == 0x0014D0, "Wrong size on UCamperMovementComponent");
static_assert(offsetof(UCamperMovementComponent, MaxCrawlSpeed) == 0x001438, "Member 'UCamperMovementComponent::MaxCrawlSpeed' has a wrong offset!");
static_assert(offsetof(UCamperMovementComponent, MaxRunSpeed) == 0x00143C, "Member 'UCamperMovementComponent::MaxRunSpeed' has a wrong offset!");
static_assert(offsetof(UCamperMovementComponent, _defaultRotationRate) == 0x001440, "Member 'UCamperMovementComponent::_defaultRotationRate' has a wrong offset!");
static_assert(offsetof(UCamperMovementComponent, _rotationRateWhileCrawling) == 0x001458, "Member 'UCamperMovementComponent::_rotationRateWhileCrawling' has a wrong offset!");
static_assert(offsetof(UCamperMovementComponent, _dropStaggerDuration) == 0x001470, "Member 'UCamperMovementComponent::_dropStaggerDuration' has a wrong offset!");
static_assert(offsetof(UCamperMovementComponent, _dropStaggerMaxSpeed) == 0x001478, "Member 'UCamperMovementComponent::_dropStaggerMaxSpeed' has a wrong offset!");

// Class DeadByDaylight.AimableInterface
// 0x0000 (0x0030 - 0x0030)
class IAimableInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AimableInterface">();
	}
	static class IAimableInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IAimableInterface>();
	}
};
static_assert(alignof(IAimableInterface) == 0x000008, "Wrong alignment on IAimableInterface");
static_assert(sizeof(IAimableInterface) == 0x000030, "Wrong size on IAimableInterface");

// Class DeadByDaylight.AIMoveToInteractData
// 0x0018 (0x0048 - 0x0030)
class UAIMoveToInteractData final : public UAICharacterBehaviourData
{
public:
	class AActor*                                 _interactActor;                                    // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 _targetPositionActor;                              // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECharacterMovementTypes                       _characterMovementTypes;                           // 0x0040(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Init(class AActor* InteractActor, ECharacterMovementTypes CharacterMovementTypes, class AActor* TargetPositionActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIMoveToInteractData">();
	}
	static class UAIMoveToInteractData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIMoveToInteractData>();
	}
};
static_assert(alignof(UAIMoveToInteractData) == 0x000008, "Wrong alignment on UAIMoveToInteractData");
static_assert(sizeof(UAIMoveToInteractData) == 0x000048, "Wrong size on UAIMoveToInteractData");
static_assert(offsetof(UAIMoveToInteractData, _interactActor) == 0x000030, "Member 'UAIMoveToInteractData::_interactActor' has a wrong offset!");
static_assert(offsetof(UAIMoveToInteractData, _targetPositionActor) == 0x000038, "Member 'UAIMoveToInteractData::_targetPositionActor' has a wrong offset!");
static_assert(offsetof(UAIMoveToInteractData, _characterMovementTypes) == 0x000040, "Member 'UAIMoveToInteractData::_characterMovementTypes' has a wrong offset!");

// Class DeadByDaylight.PhaseWalkingInterface
// 0x0000 (0x0030 - 0x0030)
class IPhaseWalkingInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PhaseWalkingInterface">();
	}
	static class IPhaseWalkingInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPhaseWalkingInterface>();
	}
};
static_assert(alignof(IPhaseWalkingInterface) == 0x000008, "Wrong alignment on IPhaseWalkingInterface");
static_assert(sizeof(IPhaseWalkingInterface) == 0x000030, "Wrong size on IPhaseWalkingInterface");

// Class DeadByDaylight.CharacterProgressionManager
// 0x0008 (0x0038 - 0x0030)
class UCharacterProgressionManager final : public UObject
{
public:
	TWeakObjectPtr<class UDBDGameInstance>        _gameInstance;                                     // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterProgressionManager">();
	}
	static class UCharacterProgressionManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterProgressionManager>();
	}
};
static_assert(alignof(UCharacterProgressionManager) == 0x000008, "Wrong alignment on UCharacterProgressionManager");
static_assert(sizeof(UCharacterProgressionManager) == 0x000038, "Wrong size on UCharacterProgressionManager");
static_assert(offsetof(UCharacterProgressionManager, _gameInstance) == 0x000030, "Member 'UCharacterProgressionManager::_gameInstance' has a wrong offset!");

// Class DeadByDaylight.AIMoveToPosition
// 0x0018 (0x0070 - 0x0058)
class UAIMoveToPosition final : public UAICharacterBehaviour
{
public:
	class UAIMoveToPositionData*                  _aiBehaviourData;                                  // 0x0058(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ADBDAIPlayerController*                 _aiController;                                     // 0x0060(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_68[0x8];                                       // 0x0068(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Init(class ADBDPlayer* Character, class UAICharacterBehaviourData* behaviourData);
	void TargetPositionReached(const struct FAIRequestID& RequestID, EPathFollowingResult Result);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIMoveToPosition">();
	}
	static class UAIMoveToPosition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIMoveToPosition>();
	}
};
static_assert(alignof(UAIMoveToPosition) == 0x000008, "Wrong alignment on UAIMoveToPosition");
static_assert(sizeof(UAIMoveToPosition) == 0x000070, "Wrong size on UAIMoveToPosition");
static_assert(offsetof(UAIMoveToPosition, _aiBehaviourData) == 0x000058, "Member 'UAIMoveToPosition::_aiBehaviourData' has a wrong offset!");
static_assert(offsetof(UAIMoveToPosition, _aiController) == 0x000060, "Member 'UAIMoveToPosition::_aiController' has a wrong offset!");

// Class DeadByDaylight.AIPointOfInterestTargetInterface
// 0x0000 (0x0030 - 0x0030)
class IAIPointOfInterestTargetInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIPointOfInterestTargetInterface">();
	}
	static class IAIPointOfInterestTargetInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IAIPointOfInterestTargetInterface>();
	}
};
static_assert(alignof(IAIPointOfInterestTargetInterface) == 0x000008, "Wrong alignment on IAIPointOfInterestTargetInterface");
static_assert(sizeof(IAIPointOfInterestTargetInterface) == 0x000030, "Wrong size on IAIPointOfInterestTargetInterface");

// Class DeadByDaylight.PlayerDataStorageFacade
// 0x0078 (0x00A8 - 0x0030)
class UPlayerDataStorageFacade final : public UObject
{
public:
	uint8                                         Pad_30[0x78];                                      // 0x0030(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerDataStorageFacade">();
	}
	static class UPlayerDataStorageFacade* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerDataStorageFacade>();
	}
};
static_assert(alignof(UPlayerDataStorageFacade) == 0x000008, "Wrong alignment on UPlayerDataStorageFacade");
static_assert(sizeof(UPlayerDataStorageFacade) == 0x0000A8, "Wrong size on UPlayerDataStorageFacade");

// Class DeadByDaylight.AISense_PointOfInterest
// 0x0010 (0x00A0 - 0x0090)
class UAISense_PointOfInterest final : public UAISense
{
public:
	TArray<class AActor*>                         _sources;                                          // 0x0090(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISense_PointOfInterest">();
	}
	static class UAISense_PointOfInterest* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISense_PointOfInterest>();
	}
};
static_assert(alignof(UAISense_PointOfInterest) == 0x000008, "Wrong alignment on UAISense_PointOfInterest");
static_assert(sizeof(UAISense_PointOfInterest) == 0x0000A0, "Wrong size on UAISense_PointOfInterest");
static_assert(offsetof(UAISense_PointOfInterest, _sources) == 0x000090, "Member 'UAISense_PointOfInterest::_sources' has a wrong offset!");

// Class DeadByDaylight.ChallengesManager
// 0x01D8 (0x0210 - 0x0038)
class UChallengesManager final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x1D8];                                     // 0x0038(0x01D8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChallengesManager">();
	}
	static class UChallengesManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChallengesManager>();
	}
};
static_assert(alignof(UChallengesManager) == 0x000008, "Wrong alignment on UChallengesManager");
static_assert(sizeof(UChallengesManager) == 0x000210, "Wrong size on UChallengesManager");

// Class DeadByDaylight.AISenseConfig_Trail
// 0x0018 (0x0068 - 0x0050)
class UAISenseConfig_Trail final : public UAISenseConfig
{
public:
	TSubclassOf<class UAISense_Trail>             Implementation;                                    // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoClear, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRange;                                          // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PeripheralVisionAngleDegrees;                      // 0x005C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAISenseAffiliationFilter              DetectionByAffiliation;                            // 0x0060(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISenseConfig_Trail">();
	}
	static class UAISenseConfig_Trail* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISenseConfig_Trail>();
	}
};
static_assert(alignof(UAISenseConfig_Trail) == 0x000008, "Wrong alignment on UAISenseConfig_Trail");
static_assert(sizeof(UAISenseConfig_Trail) == 0x000068, "Wrong size on UAISenseConfig_Trail");
static_assert(offsetof(UAISenseConfig_Trail, Implementation) == 0x000050, "Member 'UAISenseConfig_Trail::Implementation' has a wrong offset!");
static_assert(offsetof(UAISenseConfig_Trail, MaxRange) == 0x000058, "Member 'UAISenseConfig_Trail::MaxRange' has a wrong offset!");
static_assert(offsetof(UAISenseConfig_Trail, PeripheralVisionAngleDegrees) == 0x00005C, "Member 'UAISenseConfig_Trail::PeripheralVisionAngleDegrees' has a wrong offset!");
static_assert(offsetof(UAISenseConfig_Trail, DetectionByAffiliation) == 0x000060, "Member 'UAISenseConfig_Trail::DetectionByAffiliation' has a wrong offset!");

// Class DeadByDaylight.DBDPlayerStart
// 0x0008 (0x02E0 - 0x02D8)
class ADBDPlayerStart final : public APlayerStart
{
public:
	uint8                                         Pad_2D8[0x8];                                      // 0x02D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDPlayerStart">();
	}
	static class ADBDPlayerStart* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDPlayerStart>();
	}
};
static_assert(alignof(ADBDPlayerStart) == 0x000008, "Wrong alignment on ADBDPlayerStart");
static_assert(sizeof(ADBDPlayerStart) == 0x0002E0, "Wrong size on ADBDPlayerStart");

// Class DeadByDaylight.AISenseEvent_Trail
// 0x0038 (0x0068 - 0x0030)
class UAISenseEvent_Trail final : public UAISenseEvent
{
public:
	struct FAITrailEvent                          Event;                                             // 0x0030(0x0038)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISenseEvent_Trail">();
	}
	static class UAISenseEvent_Trail* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISenseEvent_Trail>();
	}
};
static_assert(alignof(UAISenseEvent_Trail) == 0x000008, "Wrong alignment on UAISenseEvent_Trail");
static_assert(sizeof(UAISenseEvent_Trail) == 0x000068, "Wrong size on UAISenseEvent_Trail");
static_assert(offsetof(UAISenseEvent_Trail, Event) == 0x000030, "Member 'UAISenseEvent_Trail::Event' has a wrong offset!");

// Class DeadByDaylight.PlayerInteractionHandler
// 0x0628 (0x06D0 - 0x00A8)
class alignas(0x10) UPlayerInteractionHandler final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x68];                                      // 0x00A8(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PriorityConeAngle;                                 // 0x0110(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BotPriorityConeAngle;                              // 0x0114(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_118[0x10];                                     // 0x0118(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             Authority_SecondaryActionDoneDelegate;             // 0x0128(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             NewInteractionRequestedDelegate;                   // 0x0138(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             ServerValidatedInteractionStartedDelegate;         // 0x0148(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             ServerValidatedInteractionEndedDelegate;           // 0x0158(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	EInteractionLayer                             InteractionLayer;                                  // 0x0168(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_169[0xF];                                      // 0x0169(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnDeactivateSkillCheckDelegate;                    // 0x0178(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_188[0x60];                                     // 0x0188(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _hasInteractionRequest;                            // 0x01E8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _hasInteractionRequestInBuffer;                    // 0x01E9(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1EA[0x1E];                                     // 0x01EA(0x001E)(Fixing Size After Last Property [ Dumper-7 ])
	class UInteractionDefinition*                 _interactionToSwapTo;                              // 0x0208(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_210[0x18];                                     // 0x0210(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UInteractionDefinition*                 _currentInteraction;                               // 0x0228(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_230[0xC8];                                     // 0x0230(0x00C8)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ADBDPlayer*>                     _currentPlayerDependencies;                        // 0x02F8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	EInputInteractionType                         _currentInteractionType;                           // 0x0308(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_309[0x7];                                      // 0x0309(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USkillCheck*                            _skillCheck;                                       // 0x0310(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_318[0x8];                                      // 0x0318(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 _progressBasedSkillChecks;                         // 0x0320(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_330[0x60];                                     // 0x0330(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	class ADBDPlayer*                             _requestedInterruptionOtherParty;                  // 0x0390(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInterruptionDefinition*                _requestedInterruptionDefinition;                  // 0x0398(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _requestedInterruptionIsInterruptor;               // 0x03A0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3A1[0x7];                                      // 0x03A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ADBDPlayer*                             _currentInterruptionOtherParty;                    // 0x03A8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInterruptionDefinition*                _currentInterruptionDefinition;                    // 0x03B0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _currentInterruptionIsInterruptor;                 // 0x03B8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _interactionInProgress;                            // 0x03B9(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3BA[0x5E];                                     // 0x03BA(0x005E)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UInteractionDefinition*>         _interactionsInZone;                               // 0x0418(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_428[0x38];                                     // 0x0428(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAvailableInteractionCalculator        _availableInteractionCalculator;                   // 0x0460(0x01E8)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_648[0x20];                                     // 0x0648(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class UObject*, struct FGameplayTagContainer> _disableInteractionSourcesToExceptions;            // 0x0668(0x0050)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6B8[0x18];                                     // 0x06B8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddInteraction(class UInteractionDefinition* Interaction);
	void Authority_ClearPlayerDependency(class ADBDPlayer* PlayerDependency);
	void Broadcast_Multicast_ConfirmChargedCompleted(bool ChargeComplete);
	void CleanInteractionArray(class AActor* DestroyedActor);
	void Client_Cheat_SetInteractionScanInterval(float Interval);
	void Client_NotifyChargeCompleted(const class UInteractionDefinition* Interaction);
	bool HasAvailableInteraction(EInputInteractionType InteractionType);
	void Multicast_CancelCurrentInteractionByInput();
	void Multicast_InteractionPredictionValidationResult(class UInteractionDefinition* Interaction, EInteractionValidationState State);
	void Multicast_InterruptionRequestResult_Interruptor(ERequestState State, bool GrantInterruptScore);
	void Multicast_RequestInterruption_Interruptee(class ADBDPlayer* InterruptionOtherParty, class UInterruptionDefinition* InterruptionDefinition);
	void Multicast_SetInteractionToSwapTo(class UInteractionDefinition* Interaction);
	void Multicast_StoreInteraction(const struct FStoredInteraction& InteractionToStore);
	void Multicast_StoreInterruption_Interruptor(class ADBDPlayer* InterruptionOtherParty, class UInterruptionDefinition* InterruptionDefinition);
	void OnAttachedInteractorOwnerEndPlay(class AActor* Actor, EEndPlayReason EndPlayReason);
	void RemoveInteraction(class UInteractionDefinition* Interaction);
	void Server_AnswerInterruption_Interruptee(ERequestState State);
	void Server_Broadcast_ConfirmChargedCompleted(bool ChargeComplete);
	void Server_Broadcast_StoreInteraction(const struct FStoredInteraction& InteractionToStore);
	void Server_CancelCurrentInteractionByInput();
	void Server_Cheat_SetInteractionScanInterval(float Interval);
	void Server_RequestInterruption_Interruptor();
	void Server_SetInteractionToSwapTo(class UInteractionDefinition* Interaction);
	void Server_StoreInterruption_Interruptor(class ADBDPlayer* InterruptionOtherParty, class UInterruptionDefinition* InterruptionDefinition);

	float GetAdditiveSkillCheckProbabilityModifier() const;
	class UInteractionDefinition* GetAvailableInteraction(EInputInteractionType InteractionType) const;
	class UInteractionDefinition* GetCurrentInteraction() const;
	float GetMultiplicativeSkillCheckProbabilityModifier() const;
	bool HasActiveSkillCheck() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerInteractionHandler">();
	}
	static class UPlayerInteractionHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerInteractionHandler>();
	}
};
static_assert(alignof(UPlayerInteractionHandler) == 0x000010, "Wrong alignment on UPlayerInteractionHandler");
static_assert(sizeof(UPlayerInteractionHandler) == 0x0006D0, "Wrong size on UPlayerInteractionHandler");
static_assert(offsetof(UPlayerInteractionHandler, PriorityConeAngle) == 0x000110, "Member 'UPlayerInteractionHandler::PriorityConeAngle' has a wrong offset!");
static_assert(offsetof(UPlayerInteractionHandler, BotPriorityConeAngle) == 0x000114, "Member 'UPlayerInteractionHandler::BotPriorityConeAngle' has a wrong offset!");
static_assert(offsetof(UPlayerInteractionHandler, Authority_SecondaryActionDoneDelegate) == 0x000128, "Member 'UPlayerInteractionHandler::Authority_SecondaryActionDoneDelegate' has a wrong offset!");
static_assert(offsetof(UPlayerInteractionHandler, NewInteractionRequestedDelegate) == 0x000138, "Member 'UPlayerInteractionHandler::NewInteractionRequestedDelegate' has a wrong offset!");
static_assert(offsetof(UPlayerInteractionHandler, ServerValidatedInteractionStartedDelegate) == 0x000148, "Member 'UPlayerInteractionHandler::ServerValidatedInteractionStartedDelegate' has a wrong offset!");
static_assert(offsetof(UPlayerInteractionHandler, ServerValidatedInteractionEndedDelegate) == 0x000158, "Member 'UPlayerInteractionHandler::ServerValidatedInteractionEndedDelegate' has a wrong offset!");
static_assert(offsetof(UPlayerInteractionHandler, InteractionLayer) == 0x000168, "Member 'UPlayerInteractionHandler::InteractionLayer' has a wrong offset!");
static_assert(offsetof(UPlayerInteractionHandler, OnDeactivateSkillCheckDelegate) == 0x000178, "Member 'UPlayerInteractionHandler::OnDeactivateSkillCheckDelegate' has a wrong offset!");
static_assert(offsetof(UPlayerInteractionHandler, _hasInteractionRequest) == 0x0001E8, "Member 'UPlayerInteractionHandler::_hasInteractionRequest' has a wrong offset!");
static_assert(offsetof(UPlayerInteractionHandler, _hasInteractionRequestInBuffer) == 0x0001E9, "Member 'UPlayerInteractionHandler::_hasInteractionRequestInBuffer' has a wrong offset!");
static_assert(offsetof(UPlayerInteractionHandler, _interactionToSwapTo) == 0x000208, "Member 'UPlayerInteractionHandler::_interactionToSwapTo' has a wrong offset!");
static_assert(offsetof(UPlayerInteractionHandler, _currentInteraction) == 0x000228, "Member 'UPlayerInteractionHandler::_currentInteraction' has a wrong offset!");
static_assert(offsetof(UPlayerInteractionHandler, _currentPlayerDependencies) == 0x0002F8, "Member 'UPlayerInteractionHandler::_currentPlayerDependencies' has a wrong offset!");
static_assert(offsetof(UPlayerInteractionHandler, _currentInteractionType) == 0x000308, "Member 'UPlayerInteractionHandler::_currentInteractionType' has a wrong offset!");
static_assert(offsetof(UPlayerInteractionHandler, _skillCheck) == 0x000310, "Member 'UPlayerInteractionHandler::_skillCheck' has a wrong offset!");
static_assert(offsetof(UPlayerInteractionHandler, _progressBasedSkillChecks) == 0x000320, "Member 'UPlayerInteractionHandler::_progressBasedSkillChecks' has a wrong offset!");
static_assert(offsetof(UPlayerInteractionHandler, _requestedInterruptionOtherParty) == 0x000390, "Member 'UPlayerInteractionHandler::_requestedInterruptionOtherParty' has a wrong offset!");
static_assert(offsetof(UPlayerInteractionHandler, _requestedInterruptionDefinition) == 0x000398, "Member 'UPlayerInteractionHandler::_requestedInterruptionDefinition' has a wrong offset!");
static_assert(offsetof(UPlayerInteractionHandler, _requestedInterruptionIsInterruptor) == 0x0003A0, "Member 'UPlayerInteractionHandler::_requestedInterruptionIsInterruptor' has a wrong offset!");
static_assert(offsetof(UPlayerInteractionHandler, _currentInterruptionOtherParty) == 0x0003A8, "Member 'UPlayerInteractionHandler::_currentInterruptionOtherParty' has a wrong offset!");
static_assert(offsetof(UPlayerInteractionHandler, _currentInterruptionDefinition) == 0x0003B0, "Member 'UPlayerInteractionHandler::_currentInterruptionDefinition' has a wrong offset!");
static_assert(offsetof(UPlayerInteractionHandler, _currentInterruptionIsInterruptor) == 0x0003B8, "Member 'UPlayerInteractionHandler::_currentInterruptionIsInterruptor' has a wrong offset!");
static_assert(offsetof(UPlayerInteractionHandler, _interactionInProgress) == 0x0003B9, "Member 'UPlayerInteractionHandler::_interactionInProgress' has a wrong offset!");
static_assert(offsetof(UPlayerInteractionHandler, _interactionsInZone) == 0x000418, "Member 'UPlayerInteractionHandler::_interactionsInZone' has a wrong offset!");
static_assert(offsetof(UPlayerInteractionHandler, _availableInteractionCalculator) == 0x000460, "Member 'UPlayerInteractionHandler::_availableInteractionCalculator' has a wrong offset!");
static_assert(offsetof(UPlayerInteractionHandler, _disableInteractionSourcesToExceptions) == 0x000668, "Member 'UPlayerInteractionHandler::_disableInteractionSourcesToExceptions' has a wrong offset!");

// Class DeadByDaylight.ItemsAssetLibrary
// 0x0070 (0x0120 - 0x00B0)
class UItemsAssetLibrary : public UAssetLibrary
{
public:
	uint8                                         Pad_B0[0x70];                                      // 0x00B0(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemsAssetLibrary">();
	}
	static class UItemsAssetLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemsAssetLibrary>();
	}
};
static_assert(alignof(UItemsAssetLibrary) == 0x000008, "Wrong alignment on UItemsAssetLibrary");
static_assert(sizeof(UItemsAssetLibrary) == 0x000120, "Wrong size on UItemsAssetLibrary");

// Class DeadByDaylight.CharacterItemsAssetLibrary
// 0x0018 (0x0138 - 0x0120)
class UCharacterItemsAssetLibrary final : public UItemsAssetLibrary
{
public:
	uint8                                         Pad_120[0x18];                                     // 0x0120(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterItemsAssetLibrary">();
	}
	static class UCharacterItemsAssetLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterItemsAssetLibrary>();
	}
};
static_assert(alignof(UCharacterItemsAssetLibrary) == 0x000008, "Wrong alignment on UCharacterItemsAssetLibrary");
static_assert(sizeof(UCharacterItemsAssetLibrary) == 0x000138, "Wrong size on UCharacterItemsAssetLibrary");

// Class DeadByDaylight.AISense_Trail
// 0x0060 (0x00F0 - 0x0090)
class UAISense_Trail final : public UAISense
{
public:
	TArray<struct FAITrailEvent>                  Events;                                            // 0x0090(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_A0[0x50];                                      // 0x00A0(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void ReportTrailEvent(class UObject* WorldContextObj, const struct FVector& Location, class AActor* Instigator, const struct FGameplayTag& IgnoreOnPerkTag, float Lifetime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISense_Trail">();
	}
	static class UAISense_Trail* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISense_Trail>();
	}
};
static_assert(alignof(UAISense_Trail) == 0x000008, "Wrong alignment on UAISense_Trail");
static_assert(sizeof(UAISense_Trail) == 0x0000F0, "Wrong size on UAISense_Trail");
static_assert(offsetof(UAISense_Trail, Events) == 0x000090, "Member 'UAISense_Trail::Events' has a wrong offset!");

// Class DeadByDaylight.AISenseConfig_UnclearHearing
// 0x00D8 (0x0128 - 0x0050)
class UAISenseConfig_UnclearHearing final : public UAISenseConfig
{
public:
	TSubclassOf<class UAISense_UnclearHearing>    Implementation;                                    // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoClear, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HearingRange;                                      // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAITunableParameter                    NoiseRangeMultiplier;                              // 0x0060(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    ReactionTime;                                      // 0x00C0(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAISenseAffiliationFilter              DetectionByAffiliation;                            // 0x0120(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_124[0x4];                                      // 0x0124(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISenseConfig_UnclearHearing">();
	}
	static class UAISenseConfig_UnclearHearing* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISenseConfig_UnclearHearing>();
	}
};
static_assert(alignof(UAISenseConfig_UnclearHearing) == 0x000008, "Wrong alignment on UAISenseConfig_UnclearHearing");
static_assert(sizeof(UAISenseConfig_UnclearHearing) == 0x000128, "Wrong size on UAISenseConfig_UnclearHearing");
static_assert(offsetof(UAISenseConfig_UnclearHearing, Implementation) == 0x000050, "Member 'UAISenseConfig_UnclearHearing::Implementation' has a wrong offset!");
static_assert(offsetof(UAISenseConfig_UnclearHearing, HearingRange) == 0x000058, "Member 'UAISenseConfig_UnclearHearing::HearingRange' has a wrong offset!");
static_assert(offsetof(UAISenseConfig_UnclearHearing, NoiseRangeMultiplier) == 0x000060, "Member 'UAISenseConfig_UnclearHearing::NoiseRangeMultiplier' has a wrong offset!");
static_assert(offsetof(UAISenseConfig_UnclearHearing, ReactionTime) == 0x0000C0, "Member 'UAISenseConfig_UnclearHearing::ReactionTime' has a wrong offset!");
static_assert(offsetof(UAISenseConfig_UnclearHearing, DetectionByAffiliation) == 0x000120, "Member 'UAISenseConfig_UnclearHearing::DetectionByAffiliation' has a wrong offset!");

// Class DeadByDaylight.DBDHostSettingsParamsBase
// 0x0010 (0x0040 - 0x0030)
class UDBDHostSettingsParamsBase : public UObject
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDHostSettingsParamsBase">();
	}
	static class UDBDHostSettingsParamsBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDHostSettingsParamsBase>();
	}
};
static_assert(alignof(UDBDHostSettingsParamsBase) == 0x000008, "Wrong alignment on UDBDHostSettingsParamsBase");
static_assert(sizeof(UDBDHostSettingsParamsBase) == 0x000040, "Wrong size on UDBDHostSettingsParamsBase");

// Class DeadByDaylight.DBDHostSettingsParamsSessionInvalid
// 0x0000 (0x0040 - 0x0040)
class UDBDHostSettingsParamsSessionInvalid final : public UDBDHostSettingsParamsBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDHostSettingsParamsSessionInvalid">();
	}
	static class UDBDHostSettingsParamsSessionInvalid* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDHostSettingsParamsSessionInvalid>();
	}
};
static_assert(alignof(UDBDHostSettingsParamsSessionInvalid) == 0x000008, "Wrong alignment on UDBDHostSettingsParamsSessionInvalid");
static_assert(sizeof(UDBDHostSettingsParamsSessionInvalid) == 0x000040, "Wrong size on UDBDHostSettingsParamsSessionInvalid");

// Class DeadByDaylight.ChargeableProgressProviderComponent
// 0x0010 (0x00B8 - 0x00A8)
class UChargeableProgressProviderComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x10];                                      // 0x00A8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChargeableProgressProviderComponent">();
	}
	static class UChargeableProgressProviderComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChargeableProgressProviderComponent>();
	}
};
static_assert(alignof(UChargeableProgressProviderComponent) == 0x000008, "Wrong alignment on UChargeableProgressProviderComponent");
static_assert(sizeof(UChargeableProgressProviderComponent) == 0x0000B8, "Wrong size on UChargeableProgressProviderComponent");

// Class DeadByDaylight.AISenseEvent_UnclearHearing
// 0x0040 (0x0070 - 0x0030)
class UAISenseEvent_UnclearHearing final : public UAISenseEvent
{
public:
	struct FAIUnclearNoiseEvent                   Event;                                             // 0x0030(0x0040)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISenseEvent_UnclearHearing">();
	}
	static class UAISenseEvent_UnclearHearing* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISenseEvent_UnclearHearing>();
	}
};
static_assert(alignof(UAISenseEvent_UnclearHearing) == 0x000008, "Wrong alignment on UAISenseEvent_UnclearHearing");
static_assert(sizeof(UAISenseEvent_UnclearHearing) == 0x000070, "Wrong size on UAISenseEvent_UnclearHearing");
static_assert(offsetof(UAISenseEvent_UnclearHearing, Event) == 0x000030, "Member 'UAISenseEvent_UnclearHearing::Event' has a wrong offset!");

// Class DeadByDaylight.CharacterStatsUtilities
// 0x0000 (0x0030 - 0x0030)
class UCharacterStatsUtilities final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterStatsUtilities">();
	}
	static class UCharacterStatsUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterStatsUtilities>();
	}
};
static_assert(alignof(UCharacterStatsUtilities) == 0x000008, "Wrong alignment on UCharacterStatsUtilities");
static_assert(sizeof(UCharacterStatsUtilities) == 0x000030, "Wrong size on UCharacterStatsUtilities");

// Class DeadByDaylight.AISlasherChaseAndAttackBehaviourData
// 0x0010 (0x0040 - 0x0030)
class UAISlasherChaseAndAttackBehaviourData final : public UAICharacterBehaviourData
{
public:
	class ACamperPlayer*                          _targetSurvivor;                                   // 0x0030(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _sqrtAttackRangeDistance;                          // 0x0038(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _sqrtMaxTargetPositionDiff;                        // 0x003C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Init(class ACamperPlayer* TargetSurvivor, float AttackRangeDistance, float LocationDistance);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISlasherChaseAndAttackBehaviourData">();
	}
	static class UAISlasherChaseAndAttackBehaviourData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISlasherChaseAndAttackBehaviourData>();
	}
};
static_assert(alignof(UAISlasherChaseAndAttackBehaviourData) == 0x000008, "Wrong alignment on UAISlasherChaseAndAttackBehaviourData");
static_assert(sizeof(UAISlasherChaseAndAttackBehaviourData) == 0x000040, "Wrong size on UAISlasherChaseAndAttackBehaviourData");
static_assert(offsetof(UAISlasherChaseAndAttackBehaviourData, _targetSurvivor) == 0x000030, "Member 'UAISlasherChaseAndAttackBehaviourData::_targetSurvivor' has a wrong offset!");
static_assert(offsetof(UAISlasherChaseAndAttackBehaviourData, _sqrtAttackRangeDistance) == 0x000038, "Member 'UAISlasherChaseAndAttackBehaviourData::_sqrtAttackRangeDistance' has a wrong offset!");
static_assert(offsetof(UAISlasherChaseAndAttackBehaviourData, _sqrtMaxTargetPositionDiff) == 0x00003C, "Member 'UAISlasherChaseAndAttackBehaviourData::_sqrtMaxTargetPositionDiff' has a wrong offset!");

// Class DeadByDaylight.AISlasherChaseAndAttackBehaviour
// 0x0038 (0x0090 - 0x0058)
class UAISlasherChaseAndAttackBehaviour final : public UAICharacterBehaviour
{
public:
	class UAISlasherChaseAndAttackBehaviourData*  _behaviourData;                                    // 0x0058(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ASlasherPlayer*                         _slasherPlayer;                                    // 0x0060(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ADBDAIPlayerController*                 _slasherAIPlayerController;                        // 0x0068(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_70[0x20];                                      // 0x0070(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISlasherChaseAndAttackBehaviour">();
	}
	static class UAISlasherChaseAndAttackBehaviour* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISlasherChaseAndAttackBehaviour>();
	}
};
static_assert(alignof(UAISlasherChaseAndAttackBehaviour) == 0x000008, "Wrong alignment on UAISlasherChaseAndAttackBehaviour");
static_assert(sizeof(UAISlasherChaseAndAttackBehaviour) == 0x000090, "Wrong size on UAISlasherChaseAndAttackBehaviour");
static_assert(offsetof(UAISlasherChaseAndAttackBehaviour, _behaviourData) == 0x000058, "Member 'UAISlasherChaseAndAttackBehaviour::_behaviourData' has a wrong offset!");
static_assert(offsetof(UAISlasherChaseAndAttackBehaviour, _slasherPlayer) == 0x000060, "Member 'UAISlasherChaseAndAttackBehaviour::_slasherPlayer' has a wrong offset!");
static_assert(offsetof(UAISlasherChaseAndAttackBehaviour, _slasherAIPlayerController) == 0x000068, "Member 'UAISlasherChaseAndAttackBehaviour::_slasherAIPlayerController' has a wrong offset!");

// Class DeadByDaylight.BlockableComponent
// 0x0048 (0x00F0 - 0x00A8)
class UBlockableComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x18];                                      // 0x00A8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlockableReplicatedDatum              _replicatedDatum;                                  // 0x00C0(0x0020)(Net, Transient, RepNotify, NativeAccessSpecifierPrivate)
	TArray<class UBlockElement*>                  _blockElements;                                    // 0x00E0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	void Authority_AddBlock(const class UObject* Source, const TSet<class ADBDPlayer*>& AffectedPlayers);
	void Authority_AddTimedBlock(const class UObject* Source, const float Duration, const TSet<class ADBDPlayer*>& AffectedPlayers);
	void Authority_RemoveBlock(const class UObject* Source);

	void OnRep_ReplicatedDatum() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlockableComponent">();
	}
	static class UBlockableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlockableComponent>();
	}
};
static_assert(alignof(UBlockableComponent) == 0x000008, "Wrong alignment on UBlockableComponent");
static_assert(sizeof(UBlockableComponent) == 0x0000F0, "Wrong size on UBlockableComponent");
static_assert(offsetof(UBlockableComponent, _replicatedDatum) == 0x0000C0, "Member 'UBlockableComponent::_replicatedDatum' has a wrong offset!");
static_assert(offsetof(UBlockableComponent, _blockElements) == 0x0000E0, "Member 'UBlockableComponent::_blockElements' has a wrong offset!");

// Class DeadByDaylight.AlwaysVisiblePerkIconStrategy
// 0x0000 (0x0038 - 0x0038)
class UAlwaysVisiblePerkIconStrategy final : public UBasePerkIconStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AlwaysVisiblePerkIconStrategy">();
	}
	static class UAlwaysVisiblePerkIconStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAlwaysVisiblePerkIconStrategy>();
	}
};
static_assert(alignof(UAlwaysVisiblePerkIconStrategy) == 0x000008, "Wrong alignment on UAlwaysVisiblePerkIconStrategy");
static_assert(sizeof(UAlwaysVisiblePerkIconStrategy) == 0x000038, "Wrong size on UAlwaysVisiblePerkIconStrategy");

// Class DeadByDaylight.Gate
// 0x0018 (0x02B8 - 0x02A0)
class AGate : public AActor
{
public:
	TArray<float>                                 InteractionInputs;                                 // 0x02A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         InteractionOutput;                                 // 0x02B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B4[0x4];                                      // 0x02B4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Gate">();
	}
	static class AGate* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGate>();
	}
};
static_assert(alignof(AGate) == 0x000008, "Wrong alignment on AGate");
static_assert(sizeof(AGate) == 0x0002B8, "Wrong size on AGate");
static_assert(offsetof(AGate, InteractionInputs) == 0x0002A0, "Member 'AGate::InteractionInputs' has a wrong offset!");
static_assert(offsetof(AGate, InteractionOutput) == 0x0002B0, "Member 'AGate::InteractionOutput' has a wrong offset!");

// Class DeadByDaylight.ChaseComponent
// 0x0088 (0x0130 - 0x00A8)
class UChaseComponent : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnChaseStarted;                                    // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnChaseEnded;                                      // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnAllChaseEnded;                                   // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnIsInChaseChanged;                                // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FTagStateBool                          _isInChase;                                        // 0x00E8(0x0048)(Net, RepNotify, NativeAccessSpecifierPrivate)

public:
	void OnRep_IsInChase();

	bool IsInChase() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChaseComponent">();
	}
	static class UChaseComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChaseComponent>();
	}
};
static_assert(alignof(UChaseComponent) == 0x000008, "Wrong alignment on UChaseComponent");
static_assert(sizeof(UChaseComponent) == 0x000130, "Wrong size on UChaseComponent");
static_assert(offsetof(UChaseComponent, OnChaseStarted) == 0x0000A8, "Member 'UChaseComponent::OnChaseStarted' has a wrong offset!");
static_assert(offsetof(UChaseComponent, OnChaseEnded) == 0x0000B8, "Member 'UChaseComponent::OnChaseEnded' has a wrong offset!");
static_assert(offsetof(UChaseComponent, OnAllChaseEnded) == 0x0000C8, "Member 'UChaseComponent::OnAllChaseEnded' has a wrong offset!");
static_assert(offsetof(UChaseComponent, OnIsInChaseChanged) == 0x0000D8, "Member 'UChaseComponent::OnIsInChaseChanged' has a wrong offset!");
static_assert(offsetof(UChaseComponent, _isInChase) == 0x0000E8, "Member 'UChaseComponent::_isInChase' has a wrong offset!");

// Class DeadByDaylight.AndGate
// 0x0000 (0x02B8 - 0x02B8)
class AAndGate final : public AGate
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AndGate">();
	}
	static class AAndGate* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAndGate>();
	}
};
static_assert(alignof(AAndGate) == 0x000008, "Wrong alignment on AAndGate");
static_assert(sizeof(AAndGate) == 0x0002B8, "Wrong size on AAndGate");

// Class DeadByDaylight.AnimationMontageSlave
// 0x0010 (0x00B8 - 0x00A8)
class UAnimationMontageSlave final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x10];                                      // 0x00A8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnMontageStarted(const struct FAnimationMontageDescriptor& ID, const float Rate);
	void OnMontageStopped(const struct FAnimationMontageDescriptor& ID);
	void SetLeader(class UMontagePlayer* Leader);
	void SetMontagePlayer(class UMontagePlayer* MontagePlayer);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimationMontageSlave">();
	}
	static class UAnimationMontageSlave* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimationMontageSlave>();
	}
};
static_assert(alignof(UAnimationMontageSlave) == 0x000008, "Wrong alignment on UAnimationMontageSlave");
static_assert(sizeof(UAnimationMontageSlave) == 0x0000B8, "Wrong size on UAnimationMontageSlave");

// Class DeadByDaylight.NotExhaustedActivationTimerElapsedIconStrategy
// 0x0000 (0x0038 - 0x0038)
class UNotExhaustedActivationTimerElapsedIconStrategy final : public UBasePerkIconStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NotExhaustedActivationTimerElapsedIconStrategy">();
	}
	static class UNotExhaustedActivationTimerElapsedIconStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNotExhaustedActivationTimerElapsedIconStrategy>();
	}
};
static_assert(alignof(UNotExhaustedActivationTimerElapsedIconStrategy) == 0x000008, "Wrong alignment on UNotExhaustedActivationTimerElapsedIconStrategy");
static_assert(sizeof(UNotExhaustedActivationTimerElapsedIconStrategy) == 0x000038, "Wrong size on UNotExhaustedActivationTimerElapsedIconStrategy");

// Class DeadByDaylight.AnimationPreviewPreloadRequest
// 0x0020 (0x0050 - 0x0030)
class UAnimationPreviewPreloadRequest final : public UObject
{
public:
	TArray<struct FSoftObjectPath>                RequestedClasses;                                  // 0x0030(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x10];                                      // 0x0040(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnClassesLoaded();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimationPreviewPreloadRequest">();
	}
	static class UAnimationPreviewPreloadRequest* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimationPreviewPreloadRequest>();
	}
};
static_assert(alignof(UAnimationPreviewPreloadRequest) == 0x000008, "Wrong alignment on UAnimationPreviewPreloadRequest");
static_assert(sizeof(UAnimationPreviewPreloadRequest) == 0x000050, "Wrong size on UAnimationPreviewPreloadRequest");
static_assert(offsetof(UAnimationPreviewPreloadRequest, RequestedClasses) == 0x000030, "Member 'UAnimationPreviewPreloadRequest::RequestedClasses' has a wrong offset!");

// Class DeadByDaylight.VomitStateComponent
// 0x00E0 (0x0188 - 0x00A8)
class UVomitStateComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTagStateBool                          _isIdle;                                           // 0x00B0(0x0048)(NativeAccessSpecifierPrivate)
	struct FTagStateBool                          _isCharging;                                       // 0x00F8(0x0048)(NativeAccessSpecifierPrivate)
	struct FTagStateBool                          _isVomiting;                                       // 0x0140(0x0048)(NativeAccessSpecifierPrivate)

public:
	void SetObjectState(class UGameplayTagContainerComponent* ObjectState);
	void SetVomitState(ELinkedVomitState NewVomitState);

	ELinkedVomitState GetVomitState() const;
	bool IsVomiting() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VomitStateComponent">();
	}
	static class UVomitStateComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVomitStateComponent>();
	}
};
static_assert(alignof(UVomitStateComponent) == 0x000008, "Wrong alignment on UVomitStateComponent");
static_assert(sizeof(UVomitStateComponent) == 0x000188, "Wrong size on UVomitStateComponent");
static_assert(offsetof(UVomitStateComponent, _isIdle) == 0x0000B0, "Member 'UVomitStateComponent::_isIdle' has a wrong offset!");
static_assert(offsetof(UVomitStateComponent, _isCharging) == 0x0000F8, "Member 'UVomitStateComponent::_isCharging' has a wrong offset!");
static_assert(offsetof(UVomitStateComponent, _isVomiting) == 0x000140, "Member 'UVomitStateComponent::_isVomiting' has a wrong offset!");

// Class DeadByDaylight.BlindingEffectorInterface
// 0x0000 (0x0030 - 0x0030)
class IBlindingEffectorInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlindingEffectorInterface">();
	}
	static class IBlindingEffectorInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IBlindingEffectorInterface>();
	}
};
static_assert(alignof(IBlindingEffectorInterface) == 0x000008, "Wrong alignment on IBlindingEffectorInterface");
static_assert(sizeof(IBlindingEffectorInterface) == 0x000030, "Wrong size on IBlindingEffectorInterface");

// Class DeadByDaylight.AnimationPreviewSubsystem
// 0x0058 (0x0090 - 0x0038)
class UAnimationPreviewSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x48];                                      // 0x0038(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimationPreview*                      _activePreview;                                    // 0x0080(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_88[0x8];                                       // 0x0088(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAnimationPreviewEnd(class UAnimationPreview* Preview, bool CompletedSuccessfully);
	void OnAnimationPreviewStart(class UAnimationPreview* Preview);

	bool CharacterHasSecondaryMori(int32 KillerId) const;
	bool IsPreviewingAnimation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimationPreviewSubsystem">();
	}
	static class UAnimationPreviewSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimationPreviewSubsystem>();
	}
};
static_assert(alignof(UAnimationPreviewSubsystem) == 0x000008, "Wrong alignment on UAnimationPreviewSubsystem");
static_assert(sizeof(UAnimationPreviewSubsystem) == 0x000090, "Wrong size on UAnimationPreviewSubsystem");
static_assert(offsetof(UAnimationPreviewSubsystem, _activePreview) == 0x000080, "Member 'UAnimationPreviewSubsystem::_activePreview' has a wrong offset!");

// Class DeadByDaylight.AnimNotifyState_HideCustomizationAttachments
// 0x0008 (0x0040 - 0x0038)
class UAnimNotifyState_HideCustomizationAttachments final : public UAnimNotifyState
{
public:
	ECustomizationCategory                        Category;                                          // 0x0038(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_HideCustomizationAttachments">();
	}
	static class UAnimNotifyState_HideCustomizationAttachments* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_HideCustomizationAttachments>();
	}
};
static_assert(alignof(UAnimNotifyState_HideCustomizationAttachments) == 0x000008, "Wrong alignment on UAnimNotifyState_HideCustomizationAttachments");
static_assert(sizeof(UAnimNotifyState_HideCustomizationAttachments) == 0x000040, "Wrong size on UAnimNotifyState_HideCustomizationAttachments");
static_assert(offsetof(UAnimNotifyState_HideCustomizationAttachments, Category) == 0x000038, "Member 'UAnimNotifyState_HideCustomizationAttachments::Category' has a wrong offset!");

// Class DeadByDaylight.ObjectPlacementUpdateStrategy
// 0x0038 (0x0068 - 0x0030)
class UObjectPlacementUpdateStrategy : public UObject
{
public:
	uint8                                         Pad_30[0x38];                                      // 0x0030(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ObjectPlacementUpdateStrategy">();
	}
	static class UObjectPlacementUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UObjectPlacementUpdateStrategy>();
	}
};
static_assert(alignof(UObjectPlacementUpdateStrategy) == 0x000008, "Wrong alignment on UObjectPlacementUpdateStrategy");
static_assert(sizeof(UObjectPlacementUpdateStrategy) == 0x000068, "Wrong size on UObjectPlacementUpdateStrategy");

// Class DeadByDaylight.BufferLastValidLocationObjectPlacementStrategy
// 0x0008 (0x0070 - 0x0068)
class UBufferLastValidLocationObjectPlacementStrategy final : public UObjectPlacementUpdateStrategy
{
public:
	float                                         _maxDistanceToOwner;                               // 0x0068(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BufferLastValidLocationObjectPlacementStrategy">();
	}
	static class UBufferLastValidLocationObjectPlacementStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBufferLastValidLocationObjectPlacementStrategy>();
	}
};
static_assert(alignof(UBufferLastValidLocationObjectPlacementStrategy) == 0x000008, "Wrong alignment on UBufferLastValidLocationObjectPlacementStrategy");
static_assert(sizeof(UBufferLastValidLocationObjectPlacementStrategy) == 0x000070, "Wrong size on UBufferLastValidLocationObjectPlacementStrategy");
static_assert(offsetof(UBufferLastValidLocationObjectPlacementStrategy, _maxDistanceToOwner) == 0x000068, "Member 'UBufferLastValidLocationObjectPlacementStrategy::_maxDistanceToOwner' has a wrong offset!");

// Class DeadByDaylight.CharmAttacher
// 0x0040 (0x02E0 - 0x02A0)
class ACharmAttacher final : public AActor
{
public:
	FMulticastInlineDelegateProperty_             OnAttachedOnActor;                                 // 0x02A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCharmAnimationTagsChanged;                       // 0x02B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UDBDSkeletalMeshComponentBudgeted*      _chain;                                            // 0x02C0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ACharm*                                 _attachedCharm;                                    // 0x02C8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   _charmAttachSocketName;                            // 0x02D0(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2DC[0x4];                                      // 0x02DC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BindOnCharmAnimationTagsChanged();
	void DispatchOnCharmAnimationTagsChanged();
	class AActor* GetActorAttachedOn();
	struct FCharmAttacherAnimationTweak GetAnimationTweak();
	class ACharm* GetAttachedCharm();
	class USkeletalMeshComponent* GetSkeletalMeshComponentAttachedOn();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharmAttacher">();
	}
	static class ACharmAttacher* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACharmAttacher>();
	}
};
static_assert(alignof(ACharmAttacher) == 0x000008, "Wrong alignment on ACharmAttacher");
static_assert(sizeof(ACharmAttacher) == 0x0002E0, "Wrong size on ACharmAttacher");
static_assert(offsetof(ACharmAttacher, OnAttachedOnActor) == 0x0002A0, "Member 'ACharmAttacher::OnAttachedOnActor' has a wrong offset!");
static_assert(offsetof(ACharmAttacher, OnCharmAnimationTagsChanged) == 0x0002B0, "Member 'ACharmAttacher::OnCharmAnimationTagsChanged' has a wrong offset!");
static_assert(offsetof(ACharmAttacher, _chain) == 0x0002C0, "Member 'ACharmAttacher::_chain' has a wrong offset!");
static_assert(offsetof(ACharmAttacher, _attachedCharm) == 0x0002C8, "Member 'ACharmAttacher::_attachedCharm' has a wrong offset!");
static_assert(offsetof(ACharmAttacher, _charmAttachSocketName) == 0x0002D0, "Member 'ACharmAttacher::_charmAttachSocketName' has a wrong offset!");

// Class DeadByDaylight.AnimTagProvider
// 0x0000 (0x0030 - 0x0030)
class IAnimTagProvider final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimTagProvider">();
	}
	static class IAnimTagProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<IAnimTagProvider>();
	}
};
static_assert(alignof(IAnimTagProvider) == 0x000008, "Wrong alignment on IAnimTagProvider");
static_assert(sizeof(IAnimTagProvider) == 0x000030, "Wrong size on IAnimTagProvider");

// Class DeadByDaylight.AntiCampSelfUnhookComponent
// 0x00E0 (0x0188 - 0x00A8)
class UAntiCampSelfUnhookComponent : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x30];                                      // 0x00A8(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	EAntiCampSelfUnhookMeterState                 _state;                                            // 0x00D8(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D9[0x7];                                       // 0x00D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _maxSecondsToChargeAntiCampUnhook;                 // 0x00E0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _antiCampUnhookXYDistanceToChargeCurve;            // 0x0108(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _antiCampUnhookUpperZDistanceToChargeCurve;        // 0x0110(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _antiCampUnhookLowerZDistanceToChargeCurve;        // 0x0118(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _antiCampUnhookBasementZDistanceToChargeCurve;     // 0x0120(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _antiCampUnhookBasementLowerZDistanceToChargeCurve; // 0x0128(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _antiCampGracePeriod;                              // 0x0130(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_134[0x4C];                                     // 0x0134(0x004C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _progress;                                         // 0x0180(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_184[0x4];                                      // 0x0184(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnEscapeDoorActivated();
	void OnHookedSurvivorDrainStageChanged(const int32 DrainStage, class ADBDPlayer* Target);
	void OnRep_Progress();
	void OnRep_State(EAntiCampSelfUnhookMeterState PreviousState);
	void SetAntiCampUnhookChargeable(class UChargeableComponent* Component);

	float GetAntiCampGracePeriod() const;
	float GetAntiCampMaxLowerZCurveDistanceTime() const;
	float GetAntiCampMaxUpperZCurveDistanceTime() const;
	float GetAntiCampMaxXYCurveDistanceTime() const;
	float GetProgress() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AntiCampSelfUnhookComponent">();
	}
	static class UAntiCampSelfUnhookComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAntiCampSelfUnhookComponent>();
	}
};
static_assert(alignof(UAntiCampSelfUnhookComponent) == 0x000008, "Wrong alignment on UAntiCampSelfUnhookComponent");
static_assert(sizeof(UAntiCampSelfUnhookComponent) == 0x000188, "Wrong size on UAntiCampSelfUnhookComponent");
static_assert(offsetof(UAntiCampSelfUnhookComponent, _state) == 0x0000D8, "Member 'UAntiCampSelfUnhookComponent::_state' has a wrong offset!");
static_assert(offsetof(UAntiCampSelfUnhookComponent, _maxSecondsToChargeAntiCampUnhook) == 0x0000E0, "Member 'UAntiCampSelfUnhookComponent::_maxSecondsToChargeAntiCampUnhook' has a wrong offset!");
static_assert(offsetof(UAntiCampSelfUnhookComponent, _antiCampUnhookXYDistanceToChargeCurve) == 0x000108, "Member 'UAntiCampSelfUnhookComponent::_antiCampUnhookXYDistanceToChargeCurve' has a wrong offset!");
static_assert(offsetof(UAntiCampSelfUnhookComponent, _antiCampUnhookUpperZDistanceToChargeCurve) == 0x000110, "Member 'UAntiCampSelfUnhookComponent::_antiCampUnhookUpperZDistanceToChargeCurve' has a wrong offset!");
static_assert(offsetof(UAntiCampSelfUnhookComponent, _antiCampUnhookLowerZDistanceToChargeCurve) == 0x000118, "Member 'UAntiCampSelfUnhookComponent::_antiCampUnhookLowerZDistanceToChargeCurve' has a wrong offset!");
static_assert(offsetof(UAntiCampSelfUnhookComponent, _antiCampUnhookBasementZDistanceToChargeCurve) == 0x000120, "Member 'UAntiCampSelfUnhookComponent::_antiCampUnhookBasementZDistanceToChargeCurve' has a wrong offset!");
static_assert(offsetof(UAntiCampSelfUnhookComponent, _antiCampUnhookBasementLowerZDistanceToChargeCurve) == 0x000128, "Member 'UAntiCampSelfUnhookComponent::_antiCampUnhookBasementLowerZDistanceToChargeCurve' has a wrong offset!");
static_assert(offsetof(UAntiCampSelfUnhookComponent, _antiCampGracePeriod) == 0x000130, "Member 'UAntiCampSelfUnhookComponent::_antiCampGracePeriod' has a wrong offset!");
static_assert(offsetof(UAntiCampSelfUnhookComponent, _progress) == 0x000180, "Member 'UAntiCampSelfUnhookComponent::_progress' has a wrong offset!");

// Class DeadByDaylight.AnyPlayerHasPerkConditionStrategy
// 0x0018 (0x0048 - 0x0030)
class UAnyPlayerHasPerkConditionStrategy final : public UBaseSpawnConditionStrategy
{
public:
	EPlayerRole                                   _playerRole;                                       // 0x0030(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPerkIdDropdown                        _perk;                                             // 0x0034(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnyPlayerHasPerkConditionStrategy">();
	}
	static class UAnyPlayerHasPerkConditionStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnyPlayerHasPerkConditionStrategy>();
	}
};
static_assert(alignof(UAnyPlayerHasPerkConditionStrategy) == 0x000008, "Wrong alignment on UAnyPlayerHasPerkConditionStrategy");
static_assert(sizeof(UAnyPlayerHasPerkConditionStrategy) == 0x000048, "Wrong size on UAnyPlayerHasPerkConditionStrategy");
static_assert(offsetof(UAnyPlayerHasPerkConditionStrategy, _playerRole) == 0x000030, "Member 'UAnyPlayerHasPerkConditionStrategy::_playerRole' has a wrong offset!");
static_assert(offsetof(UAnyPlayerHasPerkConditionStrategy, _perk) == 0x000034, "Member 'UAnyPlayerHasPerkConditionStrategy::_perk' has a wrong offset!");

// Class DeadByDaylight.OfferingEffectCollection
// 0x0050 (0x0088 - 0x0038)
class UOfferingEffectCollection final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool HasOfferingOfType(EOfferingEffectType Type, int32 PlayerId, class FName Tag) const;
	bool HasOfferingWithTag(int32 PlayerId, class FName Tag) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OfferingEffectCollection">();
	}
	static class UOfferingEffectCollection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOfferingEffectCollection>();
	}
};
static_assert(alignof(UOfferingEffectCollection) == 0x000008, "Wrong alignment on UOfferingEffectCollection");
static_assert(sizeof(UOfferingEffectCollection) == 0x000088, "Wrong size on UOfferingEffectCollection");

// Class DeadByDaylight.ChaserCharacterComponent
// 0x00F0 (0x0220 - 0x0130)
class UChaserCharacterComponent final : public UChaseComponent
{
public:
	uint8                                         Pad_130[0x28];                                     // 0x0130(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class UDBDPawnSensingComponent*               _camperSensor;                                     // 0x0158(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class ADBDPlayer*, struct FChaseUpdateInfo> _chaseUpdateInfo;                                  // 0x0160(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TArray<class ADBDPlayer*>                     _chasedPlayers;                                    // 0x01B0(0x0010)(Net, ZeroConstructor, Transient, RepNotify, NativeAccessSpecifierPrivate)
	TArray<class ADBDPlayer*>                     _authority_survivorsWhoStunnedKillerByPalletDuringChase; // 0x01C0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1D0[0x28];                                     // 0x01D0(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  _preventChaseTags;                                 // 0x01F8(0x0020)(Edit, NativeAccessSpecifierPrivate)
	bool                                          _camperSensorUsesActorRotation;                    // 0x0218(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _camperSensorLocationUsesEyesViewPoint;            // 0x0219(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_21A[0x6];                                      // 0x021A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnChaseTargetFound(class APawn* Pawn);
	void Multicast_OnAllChaseEnd();
	void Multicast_OnChaseEnd(class ACamperPlayer* Survivor, const struct FChaseUpdateInfo& ChaseUpdateInfo);
	void Multicast_OnChaseStart(class ACamperPlayer* Survivor);
	void OnKillerLocallyObservedChanged(bool LocallyObserved);

	void OnRep_ChasedPlayers() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChaserCharacterComponent">();
	}
	static class UChaserCharacterComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChaserCharacterComponent>();
	}
};
static_assert(alignof(UChaserCharacterComponent) == 0x000008, "Wrong alignment on UChaserCharacterComponent");
static_assert(sizeof(UChaserCharacterComponent) == 0x000220, "Wrong size on UChaserCharacterComponent");
static_assert(offsetof(UChaserCharacterComponent, _camperSensor) == 0x000158, "Member 'UChaserCharacterComponent::_camperSensor' has a wrong offset!");
static_assert(offsetof(UChaserCharacterComponent, _chaseUpdateInfo) == 0x000160, "Member 'UChaserCharacterComponent::_chaseUpdateInfo' has a wrong offset!");
static_assert(offsetof(UChaserCharacterComponent, _chasedPlayers) == 0x0001B0, "Member 'UChaserCharacterComponent::_chasedPlayers' has a wrong offset!");
static_assert(offsetof(UChaserCharacterComponent, _authority_survivorsWhoStunnedKillerByPalletDuringChase) == 0x0001C0, "Member 'UChaserCharacterComponent::_authority_survivorsWhoStunnedKillerByPalletDuringChase' has a wrong offset!");
static_assert(offsetof(UChaserCharacterComponent, _preventChaseTags) == 0x0001F8, "Member 'UChaserCharacterComponent::_preventChaseTags' has a wrong offset!");
static_assert(offsetof(UChaserCharacterComponent, _camperSensorUsesActorRotation) == 0x000218, "Member 'UChaserCharacterComponent::_camperSensorUsesActorRotation' has a wrong offset!");
static_assert(offsetof(UChaserCharacterComponent, _camperSensorLocationUsesEyesViewPoint) == 0x000219, "Member 'UChaserCharacterComponent::_camperSensorLocationUsesEyesViewPoint' has a wrong offset!");

// Class DeadByDaylight.ApplicableActivationTimerElapsedIconStrategy
// 0x0000 (0x0038 - 0x0038)
class UApplicableActivationTimerElapsedIconStrategy final : public UBasePerkIconStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ApplicableActivationTimerElapsedIconStrategy">();
	}
	static class UApplicableActivationTimerElapsedIconStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UApplicableActivationTimerElapsedIconStrategy>();
	}
};
static_assert(alignof(UApplicableActivationTimerElapsedIconStrategy) == 0x000008, "Wrong alignment on UApplicableActivationTimerElapsedIconStrategy");
static_assert(sizeof(UApplicableActivationTimerElapsedIconStrategy) == 0x000038, "Wrong size on UApplicableActivationTimerElapsedIconStrategy");

// Class DeadByDaylight.ApplicableActivationTimerRemainingCooldownElapsedIconStrategy
// 0x0000 (0x0038 - 0x0038)
class UApplicableActivationTimerRemainingCooldownElapsedIconStrategy final : public UBasePerkIconStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ApplicableActivationTimerRemainingCooldownElapsedIconStrategy">();
	}
	static class UApplicableActivationTimerRemainingCooldownElapsedIconStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UApplicableActivationTimerRemainingCooldownElapsedIconStrategy>();
	}
};
static_assert(alignof(UApplicableActivationTimerRemainingCooldownElapsedIconStrategy) == 0x000008, "Wrong alignment on UApplicableActivationTimerRemainingCooldownElapsedIconStrategy");
static_assert(sizeof(UApplicableActivationTimerRemainingCooldownElapsedIconStrategy) == 0x000038, "Wrong size on UApplicableActivationTimerRemainingCooldownElapsedIconStrategy");

// Class DeadByDaylight.Charm
// 0x0048 (0x02E8 - 0x02A0)
class ACharm final : public AActor
{
public:
	uint8                                         Pad_2A0[0x8];                                      // 0x02A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UDBDSkeletalMeshComponentBudgeted*      _skeletalMeshComponent;                            // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B0[0x18];                                     // 0x02B0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class AItemVfx*                               _actorVfx;                                         // 0x02C8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D0[0x18];                                     // 0x02D0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BeginDestroySequence_Internal();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Charm">();
	}
	static class ACharm* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACharm>();
	}
};
static_assert(alignof(ACharm) == 0x000008, "Wrong alignment on ACharm");
static_assert(sizeof(ACharm) == 0x0002E8, "Wrong size on ACharm");
static_assert(offsetof(ACharm, _skeletalMeshComponent) == 0x0002A8, "Member 'ACharm::_skeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(ACharm, _actorVfx) == 0x0002C8, "Member 'ACharm::_actorVfx' has a wrong offset!");

// Class DeadByDaylight.ApplicableActivationTimerRemainingIconStrategy
// 0x0000 (0x0038 - 0x0038)
class UApplicableActivationTimerRemainingIconStrategy final : public UBasePerkIconStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ApplicableActivationTimerRemainingIconStrategy">();
	}
	static class UApplicableActivationTimerRemainingIconStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UApplicableActivationTimerRemainingIconStrategy>();
	}
};
static_assert(alignof(UApplicableActivationTimerRemainingIconStrategy) == 0x000008, "Wrong alignment on UApplicableActivationTimerRemainingIconStrategy");
static_assert(sizeof(UApplicableActivationTimerRemainingIconStrategy) == 0x000038, "Wrong size on UApplicableActivationTimerRemainingIconStrategy");

// Class DeadByDaylight.ApplicableAndStealthRatioIconStrategy
// 0x0000 (0x0038 - 0x0038)
class UApplicableAndStealthRatioIconStrategy final : public UBasePerkIconStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ApplicableAndStealthRatioIconStrategy">();
	}
	static class UApplicableAndStealthRatioIconStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UApplicableAndStealthRatioIconStrategy>();
	}
};
static_assert(alignof(UApplicableAndStealthRatioIconStrategy) == 0x000008, "Wrong alignment on UApplicableAndStealthRatioIconStrategy");
static_assert(sizeof(UApplicableAndStealthRatioIconStrategy) == 0x000038, "Wrong size on UApplicableAndStealthRatioIconStrategy");

// Class DeadByDaylight.MagicFountainOutlineUpdateStrategy
// 0x0018 (0x00E8 - 0x00D0)
class UMagicFountainOutlineUpdateStrategy final : public UOutlineUpdateStrategy
{
public:
	struct FLinearColor                           _outlineColor;                                     // 0x00D0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E0[0x8];                                       // 0x00E0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetFountainCorrupted(const bool Corrupted);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MagicFountainOutlineUpdateStrategy">();
	}
	static class UMagicFountainOutlineUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMagicFountainOutlineUpdateStrategy>();
	}
};
static_assert(alignof(UMagicFountainOutlineUpdateStrategy) == 0x000008, "Wrong alignment on UMagicFountainOutlineUpdateStrategy");
static_assert(sizeof(UMagicFountainOutlineUpdateStrategy) == 0x0000E8, "Wrong size on UMagicFountainOutlineUpdateStrategy");
static_assert(offsetof(UMagicFountainOutlineUpdateStrategy, _outlineColor) == 0x0000D0, "Member 'UMagicFountainOutlineUpdateStrategy::_outlineColor' has a wrong offset!");

// Class DeadByDaylight.CinematicManager
// 0x0060 (0x0090 - 0x0030)
class UCinematicManager final : public UObject
{
public:
	uint8                                         Pad_30[0x48];                                      // 0x0030(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCinematic>                     _cinematicQueue;                                   // 0x0078(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class UBackendCinematicContainer*             _backendContainer;                                 // 0x0088(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void CancelAllCinematicToPlay();
	struct FCinematic GetNextCinematicToPlay();
	void PlayMultiple(const TArray<struct FCinematic>& Cinematics);
	void PlaySingle(const struct FCinematic& Cinematic);
	void SetVideoThumbnailProperties(struct FCinematic* Cinematic);

	bool HasCinematicToPlay() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CinematicManager">();
	}
	static class UCinematicManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCinematicManager>();
	}
};
static_assert(alignof(UCinematicManager) == 0x000008, "Wrong alignment on UCinematicManager");
static_assert(sizeof(UCinematicManager) == 0x000090, "Wrong size on UCinematicManager");
static_assert(offsetof(UCinematicManager, _cinematicQueue) == 0x000078, "Member 'UCinematicManager::_cinematicQueue' has a wrong offset!");
static_assert(offsetof(UCinematicManager, _backendContainer) == 0x000088, "Member 'UCinematicManager::_backendContainer' has a wrong offset!");

// Class DeadByDaylight.ApplicableCooldownPerkIconStrategy
// 0x0000 (0x0038 - 0x0038)
class UApplicableCooldownPerkIconStrategy final : public UBasePerkIconStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ApplicableCooldownPerkIconStrategy">();
	}
	static class UApplicableCooldownPerkIconStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UApplicableCooldownPerkIconStrategy>();
	}
};
static_assert(alignof(UApplicableCooldownPerkIconStrategy) == 0x000008, "Wrong alignment on UApplicableCooldownPerkIconStrategy");
static_assert(sizeof(UApplicableCooldownPerkIconStrategy) == 0x000038, "Wrong size on UApplicableCooldownPerkIconStrategy");

// Class DeadByDaylight.ArchivesHelper
// 0x0000 (0x0030 - 0x0030)
class UArchivesHelper final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArchivesHelper">();
	}
	static class UArchivesHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UArchivesHelper>();
	}
};
static_assert(alignof(UArchivesHelper) == 0x000008, "Wrong alignment on UArchivesHelper");
static_assert(sizeof(UArchivesHelper) == 0x000030, "Wrong size on UArchivesHelper");

// Class DeadByDaylight.CommentatorAudioData
// 0x0070 (0x00A8 - 0x0038)
class UCommentatorAudioData final : public UDataAsset
{
public:
	TMap<struct FGameplayTag, struct FCommentatorAudioContext> _commentatorAudioContexts;                         // 0x0038(0x0050)(Edit, NativeAccessSpecifierPrivate)
	struct FFloatRange                            _secondsBetweenEvents;                             // 0x0088(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class ACommentatorActorBase>      _commentatorActorClass;                            // 0x0098(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCommentatorSpawnStrategy*              _commentatorSpawnStrategy;                         // 0x00A0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommentatorAudioData">();
	}
	static class UCommentatorAudioData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommentatorAudioData>();
	}
};
static_assert(alignof(UCommentatorAudioData) == 0x000008, "Wrong alignment on UCommentatorAudioData");
static_assert(sizeof(UCommentatorAudioData) == 0x0000A8, "Wrong size on UCommentatorAudioData");
static_assert(offsetof(UCommentatorAudioData, _commentatorAudioContexts) == 0x000038, "Member 'UCommentatorAudioData::_commentatorAudioContexts' has a wrong offset!");
static_assert(offsetof(UCommentatorAudioData, _secondsBetweenEvents) == 0x000088, "Member 'UCommentatorAudioData::_secondsBetweenEvents' has a wrong offset!");
static_assert(offsetof(UCommentatorAudioData, _commentatorActorClass) == 0x000098, "Member 'UCommentatorAudioData::_commentatorActorClass' has a wrong offset!");
static_assert(offsetof(UCommentatorAudioData, _commentatorSpawnStrategy) == 0x0000A0, "Member 'UCommentatorAudioData::_commentatorSpawnStrategy' has a wrong offset!");

// Class DeadByDaylight.ArchivesManager
// 0x0038 (0x0070 - 0x0038)
class UArchivesManager final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x20];                                      // 0x0038(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UArchiveStoriesContainer*               _storiesContainer;                                 // 0x0058(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UArchiveVignettesContainer*             _vignettesContainer;                               // 0x0060(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URewardTrackContainer*                  _rewardTrackContainer;                             // 0x0068(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArchivesManager">();
	}
	static class UArchivesManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UArchivesManager>();
	}
};
static_assert(alignof(UArchivesManager) == 0x000008, "Wrong alignment on UArchivesManager");
static_assert(sizeof(UArchivesManager) == 0x000070, "Wrong size on UArchivesManager");
static_assert(offsetof(UArchivesManager, _storiesContainer) == 0x000058, "Member 'UArchivesManager::_storiesContainer' has a wrong offset!");
static_assert(offsetof(UArchivesManager, _vignettesContainer) == 0x000060, "Member 'UArchivesManager::_vignettesContainer' has a wrong offset!");
static_assert(offsetof(UArchivesManager, _rewardTrackContainer) == 0x000068, "Member 'UArchivesManager::_rewardTrackContainer' has a wrong offset!");

// Class DeadByDaylight.ArchivesSpecialBehavioursHelper
// 0x0000 (0x0030 - 0x0030)
class UArchivesSpecialBehavioursHelper final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArchivesSpecialBehavioursHelper">();
	}
	static class UArchivesSpecialBehavioursHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UArchivesSpecialBehavioursHelper>();
	}
};
static_assert(alignof(UArchivesSpecialBehavioursHelper) == 0x000008, "Wrong alignment on UArchivesSpecialBehavioursHelper");
static_assert(sizeof(UArchivesSpecialBehavioursHelper) == 0x000030, "Wrong size on UArchivesSpecialBehavioursHelper");

// Class DeadByDaylight.MapActorDetectorComponent
// 0x0028 (0x00D0 - 0x00A8)
class UMapActorDetectorComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnActorDetected;                                   // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<EMapActorCategory>                     CollectedCategories;                               // 0x00B8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UPrimitiveComponent*                    _primitive;                                        // 0x00C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnOverlapEnter(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void SetDetectionPrimitive(class UPrimitiveComponent* Primitive);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapActorDetectorComponent">();
	}
	static class UMapActorDetectorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapActorDetectorComponent>();
	}
};
static_assert(alignof(UMapActorDetectorComponent) == 0x000008, "Wrong alignment on UMapActorDetectorComponent");
static_assert(sizeof(UMapActorDetectorComponent) == 0x0000D0, "Wrong size on UMapActorDetectorComponent");
static_assert(offsetof(UMapActorDetectorComponent, OnActorDetected) == 0x0000A8, "Member 'UMapActorDetectorComponent::OnActorDetected' has a wrong offset!");
static_assert(offsetof(UMapActorDetectorComponent, CollectedCategories) == 0x0000B8, "Member 'UMapActorDetectorComponent::CollectedCategories' has a wrong offset!");
static_assert(offsetof(UMapActorDetectorComponent, _primitive) == 0x0000C8, "Member 'UMapActorDetectorComponent::_primitive' has a wrong offset!");

// Class DeadByDaylight.CollectableAudioComponent
// 0x0010 (0x00B8 - 0x00A8)
class UCollectableAudioComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x10];                                      // 0x00A8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddonConsumed(class UItemAddon* Addon);
	void EnableComponent();
	void OnChargeEmpty();
	void OnItemDropped(EItemDropType DropType);
	void PlayerPickedUpCollectable(class ADBDPlayer* Player);

	void PostAudioEvent(const class FString& AudioCall) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CollectableAudioComponent">();
	}
	static class UCollectableAudioComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCollectableAudioComponent>();
	}
};
static_assert(alignof(UCollectableAudioComponent) == 0x000008, "Wrong alignment on UCollectableAudioComponent");
static_assert(sizeof(UCollectableAudioComponent) == 0x0000B8, "Wrong size on UCollectableAudioComponent");

// Class DeadByDaylight.ArchiveStoriesContainer
// 0x04B8 (0x04E8 - 0x0030)
class UArchiveStoriesContainer final : public UObject
{
public:
	uint8                                         Pad_30[0x2A8];                                     // 0x0030(0x02A8)(Fixing Size After Last Property [ Dumper-7 ])
	class URewardTrackContainer*                  _rewardTrackContainer;                             // 0x02D8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2E0[0xA0];                                     // 0x02E0(0x00A0)(Fixing Size After Last Property [ Dumper-7 ])
	class UWalletHandler*                         _wallet;                                           // 0x0380(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UArchiveVignettesContainer*             _vignettesContainer;                               // 0x0388(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_390[0x158];                                    // 0x0390(0x0158)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArchiveStoriesContainer">();
	}
	static class UArchiveStoriesContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UArchiveStoriesContainer>();
	}
};
static_assert(alignof(UArchiveStoriesContainer) == 0x000008, "Wrong alignment on UArchiveStoriesContainer");
static_assert(sizeof(UArchiveStoriesContainer) == 0x0004E8, "Wrong size on UArchiveStoriesContainer");
static_assert(offsetof(UArchiveStoriesContainer, _rewardTrackContainer) == 0x0002D8, "Member 'UArchiveStoriesContainer::_rewardTrackContainer' has a wrong offset!");
static_assert(offsetof(UArchiveStoriesContainer, _wallet) == 0x000380, "Member 'UArchiveStoriesContainer::_wallet' has a wrong offset!");
static_assert(offsetof(UArchiveStoriesContainer, _vignettesContainer) == 0x000388, "Member 'UArchiveStoriesContainer::_vignettesContainer' has a wrong offset!");

// Class DeadByDaylight.ChatSimulator
// 0x0020 (0x0050 - 0x0030)
class UChatSimulator final : public UObject
{
public:
	uint8                                         Pad_30[0x20];                                      // 0x0030(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChatSimulator">();
	}
	static class UChatSimulator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChatSimulator>();
	}
};
static_assert(alignof(UChatSimulator) == 0x000008, "Wrong alignment on UChatSimulator");
static_assert(sizeof(UChatSimulator) == 0x000050, "Wrong size on UChatSimulator");

// Class DeadByDaylight.ArchiveWidgetScreen
// 0x0038 (0x0160 - 0x0128)
class UArchiveWidgetScreen final : public UScreenBase
{
public:
	uint8                                         Pad_128[0x38];                                     // 0x0128(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnQuestsButtonClick();
	void OnRewardsButtonClick();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArchiveWidgetScreen">();
	}
	static class UArchiveWidgetScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UArchiveWidgetScreen>();
	}
};
static_assert(alignof(UArchiveWidgetScreen) == 0x000008, "Wrong alignment on UArchiveWidgetScreen");
static_assert(sizeof(UArchiveWidgetScreen) == 0x000160, "Wrong size on UArchiveWidgetScreen");

// Class DeadByDaylight.MatchHandler
// 0x0000 (0x0030 - 0x0030)
class UMatchHandler final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchHandler">();
	}
	static class UMatchHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchHandler>();
	}
};
static_assert(alignof(UMatchHandler) == 0x000008, "Wrong alignment on UMatchHandler");
static_assert(sizeof(UMatchHandler) == 0x000030, "Wrong size on UMatchHandler");

// Class DeadByDaylight.CommentatorActorBase
// 0x0010 (0x02B0 - 0x02A0)
class ACommentatorActorBase : public AActor
{
public:
	uint8                                         Pad_2A0[0x8];                                      // 0x02A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkComponent*                           _audioComponent;                                   // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommentatorActorBase">();
	}
	static class ACommentatorActorBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACommentatorActorBase>();
	}
};
static_assert(alignof(ACommentatorActorBase) == 0x000008, "Wrong alignment on ACommentatorActorBase");
static_assert(sizeof(ACommentatorActorBase) == 0x0002B0, "Wrong size on ACommentatorActorBase");
static_assert(offsetof(ACommentatorActorBase, _audioComponent) == 0x0002A8, "Member 'ACommentatorActorBase::_audioComponent' has a wrong offset!");

// Class DeadByDaylight.AspectRatioComponentUtilities
// 0x0000 (0x0030 - 0x0030)
class UAspectRatioComponentUtilities final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AspectRatioComponentUtilities">();
	}
	static class UAspectRatioComponentUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAspectRatioComponentUtilities>();
	}
};
static_assert(alignof(UAspectRatioComponentUtilities) == 0x000008, "Wrong alignment on UAspectRatioComponentUtilities");
static_assert(sizeof(UAspectRatioComponentUtilities) == 0x000030, "Wrong size on UAspectRatioComponentUtilities");

// Class DeadByDaylight.ConsentManager
// 0x0090 (0x00C0 - 0x0030)
class UConsentManager final : public UObject
{
public:
	uint8                                         Pad_30[0x90];                                      // 0x0030(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConsentManager">();
	}
	static class UConsentManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConsentManager>();
	}
};
static_assert(alignof(UConsentManager) == 0x000008, "Wrong alignment on UConsentManager");
static_assert(sizeof(UConsentManager) == 0x0000C0, "Wrong size on UConsentManager");

// Class DeadByDaylight.AssetLibraryManager
// 0x00D0 (0x0100 - 0x0030)
class UAssetLibraryManager final : public UObject
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                _worldContextObject;                               // 0x0040(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<int32, class UCharacterItemsAssetLibrary*> _characterItemsAssetLibrary;                       // 0x0048(0x0050)(Transient, NativeAccessSpecifierPrivate)
	class UIniAssetLibrary*                       _globalAssetLibrary;                               // 0x0098(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMenuAssetLibrary*                      _menuAssetLibrary;                                 // 0x00A0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGameAssetLibrary*                      _gameAssetLibrary;                                 // 0x00A8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTutorialAssetLibrary*                  _tutorialAssetLibrary;                             // 0x00B0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UShopmanager*                           _shopManager;                                      // 0x00C0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C8[0x10];                                      // 0x00C8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAssetLibraryLoader>            _loadingList;                                      // 0x00D8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	int32                                         CharacterItemsAssetLoadCountPerChunk;              // 0x00E8(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         BlindPackAssetLoadCountPerChunk;                   // 0x00EC(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         MenuAssetLoadCountPerChunk;                        // 0x00F0(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         GlobalAssetLoadCountPerChunk;                      // 0x00F4(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         GameAssetLoadCountPerChunk;                        // 0x00F8(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_FC[0x4];                                       // 0x00FC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AssetLibraryManager">();
	}
	static class UAssetLibraryManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAssetLibraryManager>();
	}
};
static_assert(alignof(UAssetLibraryManager) == 0x000008, "Wrong alignment on UAssetLibraryManager");
static_assert(sizeof(UAssetLibraryManager) == 0x000100, "Wrong size on UAssetLibraryManager");
static_assert(offsetof(UAssetLibraryManager, _worldContextObject) == 0x000040, "Member 'UAssetLibraryManager::_worldContextObject' has a wrong offset!");
static_assert(offsetof(UAssetLibraryManager, _characterItemsAssetLibrary) == 0x000048, "Member 'UAssetLibraryManager::_characterItemsAssetLibrary' has a wrong offset!");
static_assert(offsetof(UAssetLibraryManager, _globalAssetLibrary) == 0x000098, "Member 'UAssetLibraryManager::_globalAssetLibrary' has a wrong offset!");
static_assert(offsetof(UAssetLibraryManager, _menuAssetLibrary) == 0x0000A0, "Member 'UAssetLibraryManager::_menuAssetLibrary' has a wrong offset!");
static_assert(offsetof(UAssetLibraryManager, _gameAssetLibrary) == 0x0000A8, "Member 'UAssetLibraryManager::_gameAssetLibrary' has a wrong offset!");
static_assert(offsetof(UAssetLibraryManager, _tutorialAssetLibrary) == 0x0000B0, "Member 'UAssetLibraryManager::_tutorialAssetLibrary' has a wrong offset!");
static_assert(offsetof(UAssetLibraryManager, _shopManager) == 0x0000C0, "Member 'UAssetLibraryManager::_shopManager' has a wrong offset!");
static_assert(offsetof(UAssetLibraryManager, _loadingList) == 0x0000D8, "Member 'UAssetLibraryManager::_loadingList' has a wrong offset!");
static_assert(offsetof(UAssetLibraryManager, CharacterItemsAssetLoadCountPerChunk) == 0x0000E8, "Member 'UAssetLibraryManager::CharacterItemsAssetLoadCountPerChunk' has a wrong offset!");
static_assert(offsetof(UAssetLibraryManager, BlindPackAssetLoadCountPerChunk) == 0x0000EC, "Member 'UAssetLibraryManager::BlindPackAssetLoadCountPerChunk' has a wrong offset!");
static_assert(offsetof(UAssetLibraryManager, MenuAssetLoadCountPerChunk) == 0x0000F0, "Member 'UAssetLibraryManager::MenuAssetLoadCountPerChunk' has a wrong offset!");
static_assert(offsetof(UAssetLibraryManager, GlobalAssetLoadCountPerChunk) == 0x0000F4, "Member 'UAssetLibraryManager::GlobalAssetLoadCountPerChunk' has a wrong offset!");
static_assert(offsetof(UAssetLibraryManager, GameAssetLoadCountPerChunk) == 0x0000F8, "Member 'UAssetLibraryManager::GameAssetLoadCountPerChunk' has a wrong offset!");

// Class DeadByDaylight.AssetUtilities
// 0x0000 (0x0030 - 0x0030)
class UAssetUtilities final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AssetUtilities">();
	}
	static class UAssetUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAssetUtilities>();
	}
};
static_assert(alignof(UAssetUtilities) == 0x000008, "Wrong alignment on UAssetUtilities");
static_assert(sizeof(UAssetUtilities) == 0x000030, "Wrong size on UAssetUtilities");

// Class DeadByDaylight.MatchManagementScreen
// 0x00C0 (0x01E8 - 0x0128)
class UMatchManagementScreen final : public UScreenBase
{
public:
	uint8                                         Pad_128[0xC0];                                     // 0x0128(0x00C0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAddMap(const class FString& MapId);
	void OnAllowDlcSettingsClick();
	void OnApplyChangesClicked();
	void OnBackButtonClick();
	void OnItemsAndAddonsSettingsChange(int32 Value);
	void OnOfferingsSettingsChange(int32 Value);
	void OnPerksSettingsChange(int32 Value);
	void OnRemoveMap(const class FString& MapId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchManagementScreen">();
	}
	static class UMatchManagementScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchManagementScreen>();
	}
};
static_assert(alignof(UMatchManagementScreen) == 0x000008, "Wrong alignment on UMatchManagementScreen");
static_assert(sizeof(UMatchManagementScreen) == 0x0001E8, "Wrong size on UMatchManagementScreen");

// Class DeadByDaylight.CommentatorSubsystem
// 0x0090 (0x00C8 - 0x0038)
class UCommentatorSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x90];                                      // 0x0038(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCommentatorAudioFinished(EAkCallbackType CallbackType, class UAkCallbackInfo* CallbackInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommentatorSubsystem">();
	}
	static class UCommentatorSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommentatorSubsystem>();
	}
};
static_assert(alignof(UCommentatorSubsystem) == 0x000008, "Wrong alignment on UCommentatorSubsystem");
static_assert(sizeof(UCommentatorSubsystem) == 0x0000C8, "Wrong size on UCommentatorSubsystem");

// Class DeadByDaylight.DisplayStand
// 0x01B0 (0x0450 - 0x02A0)
#pragma pack(push, 0x1)
class alignas(0x10) ADisplayStand : public AActor
{
public:
	uint8                                         Pad_2A0[0x18];                                     // 0x02A0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 _currentActorDisplayed;                            // 0x02B8(0x0008)(Edit, ZeroConstructor, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C0[0x8];                                      // 0x02C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UClass*                                 _currentActorDisplayedClass;                       // 0x02C8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UClass*                                 _nextActorToDisplayClass;                          // 0x02D0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D8[0x28];                                     // 0x02D8(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class UClass*, struct FTransform>        _offsetByClass;                                    // 0x0300(0x0050)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPrivate)
	TMap<TSoftClassPtr<class UClass>, bool>       _enableRotationByClass;                            // 0x0350(0x0050)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPrivate)
	TSoftClassPtr<class UClass>                   _defaultCharmClassDisplayable;                     // 0x03A0(0x0038)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3D8[0x61];                                     // 0x03D8(0x0061)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _useOffsetMenuAnimations;                          // 0x0439(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _displayDummyCharacter;                            // 0x043A(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_43B[0x1];                                      // 0x043B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCharacterDropdown                     _characterDropdown;                                // 0x043C(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_444[0x4];                                      // 0x0444(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BlockRotation(bool ShouldBlockRotation);
	void OnCurrentActorDestroyed(class AActor* DestroyedActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DisplayStand">();
	}
	static class ADisplayStand* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADisplayStand>();
	}
};
#pragma pack(pop)
static_assert(alignof(ADisplayStand) == 0x000010, "Wrong alignment on ADisplayStand");
static_assert(sizeof(ADisplayStand) == 0x000450, "Wrong size on ADisplayStand");
static_assert(offsetof(ADisplayStand, _currentActorDisplayed) == 0x0002B8, "Member 'ADisplayStand::_currentActorDisplayed' has a wrong offset!");
static_assert(offsetof(ADisplayStand, _currentActorDisplayedClass) == 0x0002C8, "Member 'ADisplayStand::_currentActorDisplayedClass' has a wrong offset!");
static_assert(offsetof(ADisplayStand, _nextActorToDisplayClass) == 0x0002D0, "Member 'ADisplayStand::_nextActorToDisplayClass' has a wrong offset!");
static_assert(offsetof(ADisplayStand, _offsetByClass) == 0x000300, "Member 'ADisplayStand::_offsetByClass' has a wrong offset!");
static_assert(offsetof(ADisplayStand, _enableRotationByClass) == 0x000350, "Member 'ADisplayStand::_enableRotationByClass' has a wrong offset!");
static_assert(offsetof(ADisplayStand, _defaultCharmClassDisplayable) == 0x0003A0, "Member 'ADisplayStand::_defaultCharmClassDisplayable' has a wrong offset!");
static_assert(offsetof(ADisplayStand, _useOffsetMenuAnimations) == 0x000439, "Member 'ADisplayStand::_useOffsetMenuAnimations' has a wrong offset!");
static_assert(offsetof(ADisplayStand, _displayDummyCharacter) == 0x00043A, "Member 'ADisplayStand::_displayDummyCharacter' has a wrong offset!");
static_assert(offsetof(ADisplayStand, _characterDropdown) == 0x00043C, "Member 'ADisplayStand::_characterDropdown' has a wrong offset!");

// Class DeadByDaylight.AtlantaDisplayStand
// 0x0010 (0x0460 - 0x0450)
class AAtlantaDisplayStand final : public ADisplayStand
{
public:
	EAtlantaDisplayStandPosition                  StandPosition;                                     // 0x0448(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_449[0x7];                                      // 0x0449(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        SurvivorPositionMarker;                            // 0x0450(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        KillerPositionMarker;                              // 0x0458(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AtlantaDisplayStand">();
	}
	static class AAtlantaDisplayStand* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAtlantaDisplayStand>();
	}
};
static_assert(alignof(AAtlantaDisplayStand) == 0x000010, "Wrong alignment on AAtlantaDisplayStand");
static_assert(sizeof(AAtlantaDisplayStand) == 0x000460, "Wrong size on AAtlantaDisplayStand");
static_assert(offsetof(AAtlantaDisplayStand, StandPosition) == 0x000448, "Member 'AAtlantaDisplayStand::StandPosition' has a wrong offset!");
static_assert(offsetof(AAtlantaDisplayStand, SurvivorPositionMarker) == 0x000450, "Member 'AAtlantaDisplayStand::SurvivorPositionMarker' has a wrong offset!");
static_assert(offsetof(AAtlantaDisplayStand, KillerPositionMarker) == 0x000458, "Member 'AAtlantaDisplayStand::KillerPositionMarker' has a wrong offset!");

// Class DeadByDaylight.AtlantaSaveGame
// 0x0030 (0x0060 - 0x0030)
class UAtlantaSaveGame final : public USaveGame
{
public:
	class FString                                 SaveSlotName;                                      // 0x0030(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        UserIndex;                                         // 0x0040(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LastGenericLoadingImageId;                         // 0x0044(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LastSpecificLoadingImageId;                        // 0x0050(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsLastSpecificImage;                               // 0x005C(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D[0x3];                                       // 0x005D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AtlantaSaveGame">();
	}
	static class UAtlantaSaveGame* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAtlantaSaveGame>();
	}
};
static_assert(alignof(UAtlantaSaveGame) == 0x000008, "Wrong alignment on UAtlantaSaveGame");
static_assert(sizeof(UAtlantaSaveGame) == 0x000060, "Wrong size on UAtlantaSaveGame");
static_assert(offsetof(UAtlantaSaveGame, SaveSlotName) == 0x000030, "Member 'UAtlantaSaveGame::SaveSlotName' has a wrong offset!");
static_assert(offsetof(UAtlantaSaveGame, UserIndex) == 0x000040, "Member 'UAtlantaSaveGame::UserIndex' has a wrong offset!");
static_assert(offsetof(UAtlantaSaveGame, LastGenericLoadingImageId) == 0x000044, "Member 'UAtlantaSaveGame::LastGenericLoadingImageId' has a wrong offset!");
static_assert(offsetof(UAtlantaSaveGame, LastSpecificLoadingImageId) == 0x000050, "Member 'UAtlantaSaveGame::LastSpecificLoadingImageId' has a wrong offset!");
static_assert(offsetof(UAtlantaSaveGame, IsLastSpecificImage) == 0x00005C, "Member 'UAtlantaSaveGame::IsLastSpecificImage' has a wrong offset!");

// Class DeadByDaylight.AtlantaTutorialPlayerHudController
// 0x0048 (0x0078 - 0x0030)
class UAtlantaTutorialPlayerHudController final : public UObject
{
public:
	uint8                                         Pad_30[0x48];                                      // 0x0030(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HideHudComponent(EHudComponent HudComponentToHide);
	void SetVirtualJoystickInputEnabled(bool Enable);
	void ShowHudComponent(EHudComponent HudComponentToShow);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AtlantaTutorialPlayerHudController">();
	}
	static class UAtlantaTutorialPlayerHudController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAtlantaTutorialPlayerHudController>();
	}
};
static_assert(alignof(UAtlantaTutorialPlayerHudController) == 0x000008, "Wrong alignment on UAtlantaTutorialPlayerHudController");
static_assert(sizeof(UAtlantaTutorialPlayerHudController) == 0x000078, "Wrong size on UAtlantaTutorialPlayerHudController");

// Class DeadByDaylight.GameplayModifierContainerDataAsset
// 0x0048 (0x0090 - 0x0048)
class UGameplayModifierContainerDataAsset : public UDBDPrimaryDataAsset
{
public:
	TSoftClassPtr<class UClass>                   ModifierContainerComponent;                        // 0x0048(0x0038)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UGameplayModifierContainerDataAsset>> RequiredModifierContainers;                        // 0x0080(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayModifierContainerDataAsset">();
	}
	static class UGameplayModifierContainerDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayModifierContainerDataAsset>();
	}
};
static_assert(alignof(UGameplayModifierContainerDataAsset) == 0x000008, "Wrong alignment on UGameplayModifierContainerDataAsset");
static_assert(sizeof(UGameplayModifierContainerDataAsset) == 0x000090, "Wrong size on UGameplayModifierContainerDataAsset");
static_assert(offsetof(UGameplayModifierContainerDataAsset, ModifierContainerComponent) == 0x000048, "Member 'UGameplayModifierContainerDataAsset::ModifierContainerComponent' has a wrong offset!");
static_assert(offsetof(UGameplayModifierContainerDataAsset, RequiredModifierContainers) == 0x000080, "Member 'UGameplayModifierContainerDataAsset::RequiredModifierContainers' has a wrong offset!");

// Class DeadByDaylight.AttachInteractionComponent
// 0x0010 (0x00B8 - 0x00A8)
class UAttachInteractionComponent final : public UActorComponent
{
public:
	TArray<class USceneComponent*>                _interactionsAttachPoints;                         // 0x00A8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	void Authority_SetInteractionAttachPoints(const TArray<class USceneComponent*>& InteractionsAttachPoints);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AttachInteractionComponent">();
	}
	static class UAttachInteractionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAttachInteractionComponent>();
	}
};
static_assert(alignof(UAttachInteractionComponent) == 0x000008, "Wrong alignment on UAttachInteractionComponent");
static_assert(sizeof(UAttachInteractionComponent) == 0x0000B8, "Wrong size on UAttachInteractionComponent");
static_assert(offsetof(UAttachInteractionComponent, _interactionsAttachPoints) == 0x0000A8, "Member 'UAttachInteractionComponent::_interactionsAttachPoints' has a wrong offset!");

// Class DeadByDaylight.TeamworkIconStrategy
// 0x0008 (0x0040 - 0x0038)
class UTeamworkIconStrategy final : public UBasePerkIconStrategy
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TeamworkIconStrategy">();
	}
	static class UTeamworkIconStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTeamworkIconStrategy>();
	}
};
static_assert(alignof(UTeamworkIconStrategy) == 0x000008, "Wrong alignment on UTeamworkIconStrategy");
static_assert(sizeof(UTeamworkIconStrategy) == 0x000040, "Wrong size on UTeamworkIconStrategy");

// Class DeadByDaylight.AttackTypeEventComponent
// 0x0010 (0x00B8 - 0x00A8)
class UAttackTypeEventComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x10];                                      // 0x00A8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AttackTypeEventComponent">();
	}
	static class UAttackTypeEventComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAttackTypeEventComponent>();
	}
};
static_assert(alignof(UAttackTypeEventComponent) == 0x000008, "Wrong alignment on UAttackTypeEventComponent");
static_assert(sizeof(UAttackTypeEventComponent) == 0x0000B8, "Wrong size on UAttackTypeEventComponent");

// Class DeadByDaylight.AudioFXComponent
// 0x0070 (0x0118 - 0x00A8)
class UAudioFXComponent final : public UActorComponent
{
public:
	class UPrimitiveComponent*                    _audioAmbientDetector;                             // 0x00A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B0[0x68];                                      // 0x00B0(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_Deafen(float Duration);
	void Multicast_Deafen(float Duration);
	void OnDeafenCompleted();
	void OnLocallyObservedChanged(bool LocallyObserved);
	void SetAudioAmbientDetector(class UPrimitiveComponent* AudioAmbientDetector);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AudioFXComponent">();
	}
	static class UAudioFXComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAudioFXComponent>();
	}
};
static_assert(alignof(UAudioFXComponent) == 0x000008, "Wrong alignment on UAudioFXComponent");
static_assert(sizeof(UAudioFXComponent) == 0x000118, "Wrong size on UAudioFXComponent");
static_assert(offsetof(UAudioFXComponent, _audioAmbientDetector) == 0x0000A8, "Member 'UAudioFXComponent::_audioAmbientDetector' has a wrong offset!");

// Class DeadByDaylight.GameplayNotificationUtilities
// 0x0000 (0x0030 - 0x0030)
class UGameplayNotificationUtilities final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayNotificationUtilities">();
	}
	static class UGameplayNotificationUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayNotificationUtilities>();
	}
};
static_assert(alignof(UGameplayNotificationUtilities) == 0x000008, "Wrong alignment on UGameplayNotificationUtilities");
static_assert(sizeof(UGameplayNotificationUtilities) == 0x000030, "Wrong size on UGameplayNotificationUtilities");

// Class DeadByDaylight.AudioMultipleEmitterActor
// 0x0018 (0x02B8 - 0x02A0)
class AAudioMultipleEmitterActor final : public AActor
{
public:
	class UAudioMultipleEmitterComponent*         AudioMultiEmitter;                                 // 0x02A0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         EmitterActors;                                     // 0x02A8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AudioMultipleEmitterActor">();
	}
	static class AAudioMultipleEmitterActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAudioMultipleEmitterActor>();
	}
};
static_assert(alignof(AAudioMultipleEmitterActor) == 0x000008, "Wrong alignment on AAudioMultipleEmitterActor");
static_assert(sizeof(AAudioMultipleEmitterActor) == 0x0002B8, "Wrong size on AAudioMultipleEmitterActor");
static_assert(offsetof(AAudioMultipleEmitterActor, AudioMultiEmitter) == 0x0002A0, "Member 'AAudioMultipleEmitterActor::AudioMultiEmitter' has a wrong offset!");
static_assert(offsetof(AAudioMultipleEmitterActor, EmitterActors) == 0x0002A8, "Member 'AAudioMultipleEmitterActor::EmitterActors' has a wrong offset!");

// Class DeadByDaylight.AuthoritativeMovementComponent
// 0x0060 (0x0108 - 0x00A8)
class UAuthoritativeMovementComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x10];                                      // 0x00A8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ACharacter*>                     _charactersToPush;                                 // 0x00B8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class ACharacter*>                     _stopIgnoreCharacterOnEndOverlap;                  // 0x00C8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D8[0x8];                                       // 0x00D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UCapsuleComponent*                      _pawnDetector;                                     // 0x00E0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class ACharacter*>                     _authoritativeIgnoreOverlapCharacters;             // 0x00E8(0x0010)(Net, ZeroConstructor, Transient, RepNotify, NativeAccessSpecifierPrivate)
	TArray<class ACharacter*>                     _previousAuthoritativeIgnoreOverlapCharacters;     // 0x00F8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	void OnPawnDetectorOverlapEnter(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnPawnDetectorOverlapExit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void OnRep_AuthoritativeIgnoreOverlapCharacters();
	void SetPawnDetector(class UCapsuleComponent* PawnDetector);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AuthoritativeMovementComponent">();
	}
	static class UAuthoritativeMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAuthoritativeMovementComponent>();
	}
};
static_assert(alignof(UAuthoritativeMovementComponent) == 0x000008, "Wrong alignment on UAuthoritativeMovementComponent");
static_assert(sizeof(UAuthoritativeMovementComponent) == 0x000108, "Wrong size on UAuthoritativeMovementComponent");
static_assert(offsetof(UAuthoritativeMovementComponent, _charactersToPush) == 0x0000B8, "Member 'UAuthoritativeMovementComponent::_charactersToPush' has a wrong offset!");
static_assert(offsetof(UAuthoritativeMovementComponent, _stopIgnoreCharacterOnEndOverlap) == 0x0000C8, "Member 'UAuthoritativeMovementComponent::_stopIgnoreCharacterOnEndOverlap' has a wrong offset!");
static_assert(offsetof(UAuthoritativeMovementComponent, _pawnDetector) == 0x0000E0, "Member 'UAuthoritativeMovementComponent::_pawnDetector' has a wrong offset!");
static_assert(offsetof(UAuthoritativeMovementComponent, _authoritativeIgnoreOverlapCharacters) == 0x0000E8, "Member 'UAuthoritativeMovementComponent::_authoritativeIgnoreOverlapCharacters' has a wrong offset!");
static_assert(offsetof(UAuthoritativeMovementComponent, _previousAuthoritativeIgnoreOverlapCharacters) == 0x0000F8, "Member 'UAuthoritativeMovementComponent::_previousAuthoritativeIgnoreOverlapCharacters' has a wrong offset!");

// Class DeadByDaylight.AutomaticLeanComponent
// 0x0398 (0x0440 - 0x00A8)
class UAutomaticLeanComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnLeanStateChanged;                                // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPotentialLeanStateChanged;                       // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCanInitiateLeanChanged;                          // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FSocketOrBoneCache                     _cameraIdleLocation;                               // 0x00D8(0x0080)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPrivate)
	struct FSocketOrBoneCache                     _cameraLeftLeanLocation;                           // 0x0158(0x0080)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPrivate)
	struct FSocketOrBoneCache                     _cameraRightLeanLocation;                          // 0x01D8(0x0080)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPrivate)
	struct FSocketOrBoneCache                     _cameraCrouchLocation;                             // 0x0258(0x0080)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPrivate)
	struct FSocketOrBoneCache                     _cameraCrouchLeftLeanLocation;                     // 0x02D8(0x0080)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPrivate)
	struct FSocketOrBoneCache                     _cameraCrouchRightLeanLocation;                    // 0x0358(0x0080)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPrivate)
	float                                         _middleSphereTraceLength;                          // 0x03D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _sideSphereTraceLength;                            // 0x03DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _sphereTraceRadius;                                // 0x03E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _standingTraceHeightOffset;                        // 0x03E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _crouchingTraceHeightOffset;                       // 0x03E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _sideTraceOffset;                                  // 0x03EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _maxCameraDistance;                                // 0x03F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _maxCameraAngle;                                   // 0x03F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _debugMode;                                        // 0x03F8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ELeanState                                    _leanState;                                        // 0x03F9(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3FA[0x46];                                     // 0x03FA(0x0046)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Local_Lean();
	void Local_Unlean();
	void OnCanInitiateLeanChanged__DelegateSignature(bool CanInitiate);
	void OnLeanStateChanged__DelegateSignature(ELeanState LeanState);
	void OnPotentialLeanStateChanged__DelegateSignature(ELeanState LeanState);
	void OnRep_LeanState();
	void Server_SetLeanState(ELeanState LeanState);

	bool CanInitiateLean() const;
	float GetAvailableDistanceInFrontOfCamera() const;
	ELeanState GetLeanState() const;
	ELeanState GetPotentialLeanState() const;
	bool IsLeaning() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AutomaticLeanComponent">();
	}
	static class UAutomaticLeanComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAutomaticLeanComponent>();
	}
};
static_assert(alignof(UAutomaticLeanComponent) == 0x000008, "Wrong alignment on UAutomaticLeanComponent");
static_assert(sizeof(UAutomaticLeanComponent) == 0x000440, "Wrong size on UAutomaticLeanComponent");
static_assert(offsetof(UAutomaticLeanComponent, OnLeanStateChanged) == 0x0000A8, "Member 'UAutomaticLeanComponent::OnLeanStateChanged' has a wrong offset!");
static_assert(offsetof(UAutomaticLeanComponent, OnPotentialLeanStateChanged) == 0x0000B8, "Member 'UAutomaticLeanComponent::OnPotentialLeanStateChanged' has a wrong offset!");
static_assert(offsetof(UAutomaticLeanComponent, OnCanInitiateLeanChanged) == 0x0000C8, "Member 'UAutomaticLeanComponent::OnCanInitiateLeanChanged' has a wrong offset!");
static_assert(offsetof(UAutomaticLeanComponent, _cameraIdleLocation) == 0x0000D8, "Member 'UAutomaticLeanComponent::_cameraIdleLocation' has a wrong offset!");
static_assert(offsetof(UAutomaticLeanComponent, _cameraLeftLeanLocation) == 0x000158, "Member 'UAutomaticLeanComponent::_cameraLeftLeanLocation' has a wrong offset!");
static_assert(offsetof(UAutomaticLeanComponent, _cameraRightLeanLocation) == 0x0001D8, "Member 'UAutomaticLeanComponent::_cameraRightLeanLocation' has a wrong offset!");
static_assert(offsetof(UAutomaticLeanComponent, _cameraCrouchLocation) == 0x000258, "Member 'UAutomaticLeanComponent::_cameraCrouchLocation' has a wrong offset!");
static_assert(offsetof(UAutomaticLeanComponent, _cameraCrouchLeftLeanLocation) == 0x0002D8, "Member 'UAutomaticLeanComponent::_cameraCrouchLeftLeanLocation' has a wrong offset!");
static_assert(offsetof(UAutomaticLeanComponent, _cameraCrouchRightLeanLocation) == 0x000358, "Member 'UAutomaticLeanComponent::_cameraCrouchRightLeanLocation' has a wrong offset!");
static_assert(offsetof(UAutomaticLeanComponent, _middleSphereTraceLength) == 0x0003D8, "Member 'UAutomaticLeanComponent::_middleSphereTraceLength' has a wrong offset!");
static_assert(offsetof(UAutomaticLeanComponent, _sideSphereTraceLength) == 0x0003DC, "Member 'UAutomaticLeanComponent::_sideSphereTraceLength' has a wrong offset!");
static_assert(offsetof(UAutomaticLeanComponent, _sphereTraceRadius) == 0x0003E0, "Member 'UAutomaticLeanComponent::_sphereTraceRadius' has a wrong offset!");
static_assert(offsetof(UAutomaticLeanComponent, _standingTraceHeightOffset) == 0x0003E4, "Member 'UAutomaticLeanComponent::_standingTraceHeightOffset' has a wrong offset!");
static_assert(offsetof(UAutomaticLeanComponent, _crouchingTraceHeightOffset) == 0x0003E8, "Member 'UAutomaticLeanComponent::_crouchingTraceHeightOffset' has a wrong offset!");
static_assert(offsetof(UAutomaticLeanComponent, _sideTraceOffset) == 0x0003EC, "Member 'UAutomaticLeanComponent::_sideTraceOffset' has a wrong offset!");
static_assert(offsetof(UAutomaticLeanComponent, _maxCameraDistance) == 0x0003F0, "Member 'UAutomaticLeanComponent::_maxCameraDistance' has a wrong offset!");
static_assert(offsetof(UAutomaticLeanComponent, _maxCameraAngle) == 0x0003F4, "Member 'UAutomaticLeanComponent::_maxCameraAngle' has a wrong offset!");
static_assert(offsetof(UAutomaticLeanComponent, _debugMode) == 0x0003F8, "Member 'UAutomaticLeanComponent::_debugMode' has a wrong offset!");
static_assert(offsetof(UAutomaticLeanComponent, _leanState) == 0x0003F9, "Member 'UAutomaticLeanComponent::_leanState' has a wrong offset!");

// Class DeadByDaylight.CoopRepairTracker
// 0x0010 (0x0040 - 0x0030)
class UCoopRepairTracker final : public UObject
{
public:
	TArray<class ADBDPlayer*>                     _coopRepairerHistory;                              // 0x0030(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	void SetHasEverCoopRepaired(const class ADBDPlayer* Player);

	bool HasEverCoopRepaired(const class ADBDPlayer* Player) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CoopRepairTracker">();
	}
	static class UCoopRepairTracker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCoopRepairTracker>();
	}
};
static_assert(alignof(UCoopRepairTracker) == 0x000008, "Wrong alignment on UCoopRepairTracker");
static_assert(sizeof(UCoopRepairTracker) == 0x000040, "Wrong size on UCoopRepairTracker");
static_assert(offsetof(UCoopRepairTracker, _coopRepairerHistory) == 0x000030, "Member 'UCoopRepairTracker::_coopRepairerHistory' has a wrong offset!");

// Class DeadByDaylight.BaseBloodwebContentAdapter
// 0x0028 (0x0058 - 0x0030)
class UBaseBloodwebContentAdapter : public UObject
{
public:
	class UBloodwebTunables*                      _bloodwebTunables;                                 // 0x0030(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBloodwebEntity*                        _entity;                                           // 0x0038(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TScriptInterface<class IDBDBloodwebDefinitionBase> _bloodwebDefinition;                               // 0x0040(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseBloodwebContentAdapter">();
	}
	static class UBaseBloodwebContentAdapter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseBloodwebContentAdapter>();
	}
};
static_assert(alignof(UBaseBloodwebContentAdapter) == 0x000008, "Wrong alignment on UBaseBloodwebContentAdapter");
static_assert(sizeof(UBaseBloodwebContentAdapter) == 0x000058, "Wrong size on UBaseBloodwebContentAdapter");
static_assert(offsetof(UBaseBloodwebContentAdapter, _bloodwebTunables) == 0x000030, "Member 'UBaseBloodwebContentAdapter::_bloodwebTunables' has a wrong offset!");
static_assert(offsetof(UBaseBloodwebContentAdapter, _entity) == 0x000038, "Member 'UBaseBloodwebContentAdapter::_entity' has a wrong offset!");
static_assert(offsetof(UBaseBloodwebContentAdapter, _bloodwebDefinition) == 0x000040, "Member 'UBaseBloodwebContentAdapter::_bloodwebDefinition' has a wrong offset!");

// Class DeadByDaylight.BackendBloodwebContentAdapter
// 0x00B8 (0x0110 - 0x0058)
class UBackendBloodwebContentAdapter final : public UBaseBloodwebContentAdapter
{
public:
	uint8                                         Pad_58[0xB0];                                      // 0x0058(0x00B0)(Fixing Size After Last Property [ Dumper-7 ])
	class UBloodwebGenerator*                     _bloodwebBuilder;                                  // 0x0108(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BackendBloodwebContentAdapter">();
	}
	static class UBackendBloodwebContentAdapter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBackendBloodwebContentAdapter>();
	}
};
static_assert(alignof(UBackendBloodwebContentAdapter) == 0x000008, "Wrong alignment on UBackendBloodwebContentAdapter");
static_assert(sizeof(UBackendBloodwebContentAdapter) == 0x000110, "Wrong size on UBackendBloodwebContentAdapter");
static_assert(offsetof(UBackendBloodwebContentAdapter, _bloodwebBuilder) == 0x000108, "Member 'UBackendBloodwebContentAdapter::_bloodwebBuilder' has a wrong offset!");

// Class DeadByDaylight.BackendCinematicContainer
// 0x00C0 (0x00F0 - 0x0030)
class UBackendCinematicContainer final : public UObject
{
public:
	uint8                                         Pad_30[0xC0];                                      // 0x0030(0x00C0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BackendCinematicContainer">();
	}
	static class UBackendCinematicContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBackendCinematicContainer>();
	}
};
static_assert(alignof(UBackendCinematicContainer) == 0x000008, "Wrong alignment on UBackendCinematicContainer");
static_assert(sizeof(UBackendCinematicContainer) == 0x0000F0, "Wrong size on UBackendCinematicContainer");

// Class DeadByDaylight.GeneratorDrivenActor
// 0x0028 (0x02C8 - 0x02A0)
class AGeneratorDrivenActor : public AActor
{
public:
	float                                         LightPriority;                                     // 0x02A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EComponentMobility                            TargetMobileLightMobility;                         // 0x02A4(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A5[0x3];                                      // 0x02A5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<bool>                                  _activated;                                        // 0x02A8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class AGenerator*>                     _generators;                                       // 0x02B8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	void Authority_CheckActivation(bool IsAutoCompleted, int32 GeneratorId);
	void Authority_CheckGeneratorRepairedBySurvivor(class ADBDPlayer* RepairingSurvivor, int32 GeneratorId);
	struct FRandomStream GetSharedTileRandomizer();
	void Multicast_ActivationChecked(bool Activated, bool IsAutoCompleted, int32 GeneratorId);
	void Multicast_GeneratorRepairedBySurvivor(class ADBDPlayer* RepairingSurvivor, int32 GeneratorId);
	void OnActivateGeneratorDrivenActor(bool IsAutoCompleted, int32 GeneratorId);
	void OnGeneratorRepairedBySurvivor(class ADBDPlayer* RepairingSurvivor, int32 GeneratorId);
	void OnGeneratorRepairedBySurvivorEvent0(class ADBDPlayer* RepairingSurvivor);
	void OnGeneratorRepairedBySurvivorEvent1(class ADBDPlayer* RepairingSurvivor);
	void OnGeneratorRepairedBySurvivorEvent2(class ADBDPlayer* RepairingSurvivor);
	void OnGeneratorRepairedBySurvivorEvent3(class ADBDPlayer* RepairingSurvivor);
	void OnGeneratorRepairedBySurvivorEvent4(class ADBDPlayer* RepairingSurvivor);
	void OnGeneratorRepairedBySurvivorEvent5(class ADBDPlayer* RepairingSurvivor);
	void OnGeneratorRepairedBySurvivorEvent6(class ADBDPlayer* RepairingSurvivor);
	void OnGeneratorRepairedEvent0(bool IsAutoCompleted);
	void OnGeneratorRepairedEvent1(bool IsAutoCompleted);
	void OnGeneratorRepairedEvent2(bool IsAutoCompleted);
	void OnGeneratorRepairedEvent3(bool IsAutoCompleted);
	void OnGeneratorRepairedEvent4(bool IsAutoCompleted);
	void OnGeneratorRepairedEvent5(bool IsAutoCompleted);
	void OnGeneratorRepairedEvent6(bool IsAutoCompleted);
	void OnInitGeneratorDrivenActor(class AGenerator* Generator, int32 GeneratorId);
	void SetSpawnedObject(class AGenerator* Generator, int32 GeneratorId);

	bool IsActivated(int32 GeneratorId) const;
	bool IsValidGeneratorId(int32 GeneratorId) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GeneratorDrivenActor">();
	}
	static class AGeneratorDrivenActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGeneratorDrivenActor>();
	}
};
static_assert(alignof(AGeneratorDrivenActor) == 0x000008, "Wrong alignment on AGeneratorDrivenActor");
static_assert(sizeof(AGeneratorDrivenActor) == 0x0002C8, "Wrong size on AGeneratorDrivenActor");
static_assert(offsetof(AGeneratorDrivenActor, LightPriority) == 0x0002A0, "Member 'AGeneratorDrivenActor::LightPriority' has a wrong offset!");
static_assert(offsetof(AGeneratorDrivenActor, TargetMobileLightMobility) == 0x0002A4, "Member 'AGeneratorDrivenActor::TargetMobileLightMobility' has a wrong offset!");
static_assert(offsetof(AGeneratorDrivenActor, _activated) == 0x0002A8, "Member 'AGeneratorDrivenActor::_activated' has a wrong offset!");
static_assert(offsetof(AGeneratorDrivenActor, _generators) == 0x0002B8, "Member 'AGeneratorDrivenActor::_generators' has a wrong offset!");

// Class DeadByDaylight.DBDGeneratorDrivenReflectionCaptureActor
// 0x0018 (0x02E0 - 0x02C8)
class ADBDGeneratorDrivenReflectionCaptureActor final : public AGeneratorDrivenActor
{
public:
	class UGenyReflectionCaptureComponent*        GenyReflectionCapture;                             // 0x02C8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D0[0x10];                                     // 0x02D0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SwapToSecondState();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDGeneratorDrivenReflectionCaptureActor">();
	}
	static class ADBDGeneratorDrivenReflectionCaptureActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDGeneratorDrivenReflectionCaptureActor>();
	}
};
static_assert(alignof(ADBDGeneratorDrivenReflectionCaptureActor) == 0x000008, "Wrong alignment on ADBDGeneratorDrivenReflectionCaptureActor");
static_assert(sizeof(ADBDGeneratorDrivenReflectionCaptureActor) == 0x0002E0, "Wrong size on ADBDGeneratorDrivenReflectionCaptureActor");
static_assert(offsetof(ADBDGeneratorDrivenReflectionCaptureActor, GenyReflectionCapture) == 0x0002C8, "Member 'ADBDGeneratorDrivenReflectionCaptureActor::GenyReflectionCapture' has a wrong offset!");

// Class DeadByDaylight.Tile2DataRetrievalSubsystem
// 0x0068 (0x00A0 - 0x0038)
class UTile2DataRetrievalSubsystem final : public UEngineSubsystem
{
public:
	uint8                                         Pad_38[0x68];                                      // 0x0038(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Tile2DataRetrievalSubsystem">();
	}
	static class UTile2DataRetrievalSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTile2DataRetrievalSubsystem>();
	}
};
static_assert(alignof(UTile2DataRetrievalSubsystem) == 0x000008, "Wrong alignment on UTile2DataRetrievalSubsystem");
static_assert(sizeof(UTile2DataRetrievalSubsystem) == 0x0000A0, "Wrong size on UTile2DataRetrievalSubsystem");

// Class DeadByDaylight.BackendInventory
// 0x00F0 (0x0128 - 0x0038)
class UBackendInventory final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0xF0];                                      // 0x0038(0x00F0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BackendInventory">();
	}
	static class UBackendInventory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBackendInventory>();
	}
};
static_assert(alignof(UBackendInventory) == 0x000008, "Wrong alignment on UBackendInventory");
static_assert(sizeof(UBackendInventory) == 0x000128, "Wrong size on UBackendInventory");

// Class DeadByDaylight.BackendMessageManager
// 0x0018 (0x0050 - 0x0038)
class UBackendMessageManager final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x18];                                      // 0x0038(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BackendMessageManager">();
	}
	static class UBackendMessageManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBackendMessageManager>();
	}
};
static_assert(alignof(UBackendMessageManager) == 0x000008, "Wrong alignment on UBackendMessageManager");
static_assert(sizeof(UBackendMessageManager) == 0x000050, "Wrong size on UBackendMessageManager");

// Class DeadByDaylight.BaseEscapeThroughHatch
// 0x0000 (0x0780 - 0x0780)
class UBaseEscapeThroughHatch : public UInteractionDefinition
{
public:
	class AHatch* GetHatch() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseEscapeThroughHatch">();
	}
	static class UBaseEscapeThroughHatch* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseEscapeThroughHatch>();
	}
};
static_assert(alignof(UBaseEscapeThroughHatch) == 0x000010, "Wrong alignment on UBaseEscapeThroughHatch");
static_assert(sizeof(UBaseEscapeThroughHatch) == 0x000780, "Wrong size on UBaseEscapeThroughHatch");

// Class DeadByDaylight.EscapeTile
// 0x0008 (0x0468 - 0x0460)
class AEscapeTile : public ATile
{
public:
	uint8                                         Pad_460[0x8];                                      // 0x0460(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EscapeTile">();
	}
	static class AEscapeTile* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEscapeTile>();
	}
};
static_assert(alignof(AEscapeTile) == 0x000008, "Wrong alignment on AEscapeTile");
static_assert(sizeof(AEscapeTile) == 0x000468, "Wrong size on AEscapeTile");

// Class DeadByDaylight.BaseLinkedVomitProjectile
// 0x0080 (0x0428 - 0x03A8)
class ABaseLinkedVomitProjectile final : public AKillerProjectile
{
public:
	bool                                          _useSplashDamage;                                  // 0x03A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _passThroughSurvivors;                             // 0x03A9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3AA[0x6];                                      // 0x03AA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UPoolableProjectileComponent*           _poolableProjectile;                               // 0x03B0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnDeactivateOrLaunch;                              // 0x03B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	class UParticleSystemComponent*               _vomitTrail;                                       // 0x03C8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USplineMeshComponent*                   _splineMesh;                                       // 0x03D0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USphereComponent*                       _splashDamageSphere;                               // 0x03D8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkComponent*                           _akAudioVomitProjectile;                           // 0x03E0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UParticleSystem*                        _vomitSplashCamper;                                // 0x03E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UParticleSystem*                        _vomitSplash;                                      // 0x03F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkAudioEvent*                          _akAudioEventAudioEventVomitSplash;                // 0x03F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector2D                              _minDecalSize;                                     // 0x0400(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector2D                              _maxDecalSize;                                     // 0x0410(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isSuperVomit;                                     // 0x0420(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_421[0x7];                                      // 0x0421(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void NativeExplode(const struct FImpactInfo& ImpactInfo);
	void OnAffectInteractable(class AInteractable* Interactable, class USceneComponent* HitComponent);
	void OnAffectSurvivor(class ACamperPlayer* CamperPlayer);
	void OnLinkedVomitProjectileDeactivate__DelegateSignature();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseLinkedVomitProjectile">();
	}
	static class ABaseLinkedVomitProjectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABaseLinkedVomitProjectile>();
	}
};
static_assert(alignof(ABaseLinkedVomitProjectile) == 0x000008, "Wrong alignment on ABaseLinkedVomitProjectile");
static_assert(sizeof(ABaseLinkedVomitProjectile) == 0x000428, "Wrong size on ABaseLinkedVomitProjectile");
static_assert(offsetof(ABaseLinkedVomitProjectile, _useSplashDamage) == 0x0003A8, "Member 'ABaseLinkedVomitProjectile::_useSplashDamage' has a wrong offset!");
static_assert(offsetof(ABaseLinkedVomitProjectile, _passThroughSurvivors) == 0x0003A9, "Member 'ABaseLinkedVomitProjectile::_passThroughSurvivors' has a wrong offset!");
static_assert(offsetof(ABaseLinkedVomitProjectile, _poolableProjectile) == 0x0003B0, "Member 'ABaseLinkedVomitProjectile::_poolableProjectile' has a wrong offset!");
static_assert(offsetof(ABaseLinkedVomitProjectile, OnDeactivateOrLaunch) == 0x0003B8, "Member 'ABaseLinkedVomitProjectile::OnDeactivateOrLaunch' has a wrong offset!");
static_assert(offsetof(ABaseLinkedVomitProjectile, _vomitTrail) == 0x0003C8, "Member 'ABaseLinkedVomitProjectile::_vomitTrail' has a wrong offset!");
static_assert(offsetof(ABaseLinkedVomitProjectile, _splineMesh) == 0x0003D0, "Member 'ABaseLinkedVomitProjectile::_splineMesh' has a wrong offset!");
static_assert(offsetof(ABaseLinkedVomitProjectile, _splashDamageSphere) == 0x0003D8, "Member 'ABaseLinkedVomitProjectile::_splashDamageSphere' has a wrong offset!");
static_assert(offsetof(ABaseLinkedVomitProjectile, _akAudioVomitProjectile) == 0x0003E0, "Member 'ABaseLinkedVomitProjectile::_akAudioVomitProjectile' has a wrong offset!");
static_assert(offsetof(ABaseLinkedVomitProjectile, _vomitSplashCamper) == 0x0003E8, "Member 'ABaseLinkedVomitProjectile::_vomitSplashCamper' has a wrong offset!");
static_assert(offsetof(ABaseLinkedVomitProjectile, _vomitSplash) == 0x0003F0, "Member 'ABaseLinkedVomitProjectile::_vomitSplash' has a wrong offset!");
static_assert(offsetof(ABaseLinkedVomitProjectile, _akAudioEventAudioEventVomitSplash) == 0x0003F8, "Member 'ABaseLinkedVomitProjectile::_akAudioEventAudioEventVomitSplash' has a wrong offset!");
static_assert(offsetof(ABaseLinkedVomitProjectile, _minDecalSize) == 0x000400, "Member 'ABaseLinkedVomitProjectile::_minDecalSize' has a wrong offset!");
static_assert(offsetof(ABaseLinkedVomitProjectile, _maxDecalSize) == 0x000410, "Member 'ABaseLinkedVomitProjectile::_maxDecalSize' has a wrong offset!");
static_assert(offsetof(ABaseLinkedVomitProjectile, _isSuperVomit) == 0x000420, "Member 'ABaseLinkedVomitProjectile::_isSuperVomit' has a wrong offset!");

// Class DeadByDaylight.TotemActiveIconStrategy
// 0x0000 (0x0038 - 0x0038)
class UTotemActiveIconStrategy final : public UBasePerkIconStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TotemActiveIconStrategy">();
	}
	static class UTotemActiveIconStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTotemActiveIconStrategy>();
	}
};
static_assert(alignof(UTotemActiveIconStrategy) == 0x000008, "Wrong alignment on UTotemActiveIconStrategy");
static_assert(sizeof(UTotemActiveIconStrategy) == 0x000038, "Wrong size on UTotemActiveIconStrategy");

// Class DeadByDaylight.BaseSky
// 0x0168 (0x0408 - 0x02A0)
class ABaseSky : public AActor
{
public:
	uint8                                         Pad_2A0[0x8];                                      // 0x02A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          AdjustCullDistance;                                // 0x02A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A9[0x3];                                      // 0x02A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         IBLContributionMultiplier;                         // 0x02AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           ProbesTintColor;                                   // 0x02B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ProbesSaturationValue;                             // 0x02C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C4[0x4];                                      // 0x02C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBHVRPerDetailModeFloat                ASMDepthBias;                                      // 0x02C8(0x00A0)(Edit, AdvancedDisplay, Protected, NativeAccessSpecifierProtected)
	struct FBHVRPerDetailModeFloat                ASMDepthAttenuation;                               // 0x0368(0x00A0)(Edit, AdvancedDisplay, Protected, NativeAccessSpecifierProtected)

public:
	void CopyComponentsSettingsFromSource(class UStaticMeshComponent* MoonMesh, class UDirectionalLightComponent* ShadowLight, class UDirectionalLightComponent* GodRayLight, class USkyLightComponent* SkyLight, class UExponentialHeightFogComponent* HeightFog, class UPostProcessComponent* PostProcess, class UClass* SourceBaseSkyClass);
	class UPostProcessComponent* GetPostprocessComponent();
	class USceneComponent* GetVistasAndEnvironmentElements();
	void OnAlphaChanged(float NewAlpha, class AActor* Other);
	void OnFadeBegin(class AActor* Other);
	void OnFadeEnd(class AActor* Other);
	void SetCullDistance(float NewCullDistance);
	void SetProbesTint(const struct FLinearColor& InColor, float InSaturation);
	void ToggleLightingChange(bool ToggleOn, class FName ThemeName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseSky">();
	}
	static class ABaseSky* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABaseSky>();
	}
};
static_assert(alignof(ABaseSky) == 0x000008, "Wrong alignment on ABaseSky");
static_assert(sizeof(ABaseSky) == 0x000408, "Wrong size on ABaseSky");
static_assert(offsetof(ABaseSky, AdjustCullDistance) == 0x0002A8, "Member 'ABaseSky::AdjustCullDistance' has a wrong offset!");
static_assert(offsetof(ABaseSky, IBLContributionMultiplier) == 0x0002AC, "Member 'ABaseSky::IBLContributionMultiplier' has a wrong offset!");
static_assert(offsetof(ABaseSky, ProbesTintColor) == 0x0002B0, "Member 'ABaseSky::ProbesTintColor' has a wrong offset!");
static_assert(offsetof(ABaseSky, ProbesSaturationValue) == 0x0002C0, "Member 'ABaseSky::ProbesSaturationValue' has a wrong offset!");
static_assert(offsetof(ABaseSky, ASMDepthBias) == 0x0002C8, "Member 'ABaseSky::ASMDepthBias' has a wrong offset!");
static_assert(offsetof(ABaseSky, ASMDepthAttenuation) == 0x000368, "Member 'ABaseSky::ASMDepthAttenuation' has a wrong offset!");

// Class DeadByDaylight.EventObjectComponent
// 0x0008 (0x00B0 - 0x00A8)
class UEventObjectComponent : public UActorComponent
{
public:
	struct FColor                                 _eventOutlineColour;                               // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventObjectComponent">();
	}
	static class UEventObjectComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventObjectComponent>();
	}
};
static_assert(alignof(UEventObjectComponent) == 0x000008, "Wrong alignment on UEventObjectComponent");
static_assert(sizeof(UEventObjectComponent) == 0x0000B0, "Wrong size on UEventObjectComponent");
static_assert(offsetof(UEventObjectComponent, _eventOutlineColour) == 0x0000A8, "Member 'UEventObjectComponent::_eventOutlineColour' has a wrong offset!");

// Class DeadByDaylight.BlessedVignetteController
// 0x0010 (0x00B8 - 0x00A8)
class UBlessedVignetteController final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x10];                                      // 0x00A8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnActivateBlessedVignette();
	void OnDeactivateBlessedVignette();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlessedVignetteController">();
	}
	static class UBlessedVignetteController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlessedVignetteController>();
	}
};
static_assert(alignof(UBlessedVignetteController) == 0x000008, "Wrong alignment on UBlessedVignetteController");
static_assert(sizeof(UBlessedVignetteController) == 0x0000B8, "Wrong size on UBlessedVignetteController");

// Class DeadByDaylight.BlindableComponent
// 0x0008 (0x0268 - 0x0260)
class UBlindableComponent final : public UBlindableBaseComponent
{
public:
	uint8                                         Pad_260[0x8];                                      // 0x0260(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlindableComponent">();
	}
	static class UBlindableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlindableComponent>();
	}
};
static_assert(alignof(UBlindableComponent) == 0x000008, "Wrong alignment on UBlindableComponent");
static_assert(sizeof(UBlindableComponent) == 0x000268, "Wrong size on UBlindableComponent");

// Class DeadByDaylight.Bloodlust
// 0x0158 (0x04D8 - 0x0380)
class UBloodlust : public UStatusEffect
{
public:
	class UCurveFloat*                            BloodlustCurve;                                    // 0x0380(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_388[0x20];                                     // 0x0388(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _bloodlustTime;                                    // 0x03A8(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3AC[0x2C];                                     // 0x03AC(0x002C)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameplayTag>                   _bloodlustResettingGameEvents;                     // 0x03D8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3E8[0xF0];                                     // 0x03E8(0x00F0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DBD_SetBloodlust(const int32 Amount, const bool EnableDecay);
	void OnAllChaseEndedEvent();
	void OnChaseStartedEvent(class ADBDPlayer* ChasedPlayer);
	void OnRep_BloodlustTime(float OldBloodlustTime);

	float GetBloodlustTime() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Bloodlust">();
	}
	static class UBloodlust* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBloodlust>();
	}
};
static_assert(alignof(UBloodlust) == 0x000008, "Wrong alignment on UBloodlust");
static_assert(sizeof(UBloodlust) == 0x0004D8, "Wrong size on UBloodlust");
static_assert(offsetof(UBloodlust, BloodlustCurve) == 0x000380, "Member 'UBloodlust::BloodlustCurve' has a wrong offset!");
static_assert(offsetof(UBloodlust, _bloodlustTime) == 0x0003A8, "Member 'UBloodlust::_bloodlustTime' has a wrong offset!");
static_assert(offsetof(UBloodlust, _bloodlustResettingGameEvents) == 0x0003D8, "Member 'UBloodlust::_bloodlustResettingGameEvents' has a wrong offset!");

// Class DeadByDaylight.BloodTrailSettings
// 0x0168 (0x01A0 - 0x0038)
class UBloodTrailSettings final : public UDataAsset
{
public:
	float                                         _initialDelay;                                     // 0x0038(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _numBloodDropsPerBloodPool;                        // 0x003C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _bloodDropsInterval;                               // 0x0040(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _randomlyRotateBloodDrops;                         // 0x0044(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _bloodDropsRandomScatter;                          // 0x0048(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETraceTypeQuery                               _bloodTraceChannel;                                // 0x004C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UBloodDecalEffect*                      _bloodDecalEffect;                                 // 0x0050(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBHVRPerDetailModeInt                  _decalPoolSize;                                    // 0x0058(0x00A0)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         _recycleThresholdPercentage;                       // 0x00F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _recycleDistancePercentage;                        // 0x00FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBHVRPerDetailModeInt                  _maxOverlapping;                                   // 0x0100(0x00A0)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BloodTrailSettings">();
	}
	static class UBloodTrailSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBloodTrailSettings>();
	}
};
static_assert(alignof(UBloodTrailSettings) == 0x000008, "Wrong alignment on UBloodTrailSettings");
static_assert(sizeof(UBloodTrailSettings) == 0x0001A0, "Wrong size on UBloodTrailSettings");
static_assert(offsetof(UBloodTrailSettings, _initialDelay) == 0x000038, "Member 'UBloodTrailSettings::_initialDelay' has a wrong offset!");
static_assert(offsetof(UBloodTrailSettings, _numBloodDropsPerBloodPool) == 0x00003C, "Member 'UBloodTrailSettings::_numBloodDropsPerBloodPool' has a wrong offset!");
static_assert(offsetof(UBloodTrailSettings, _bloodDropsInterval) == 0x000040, "Member 'UBloodTrailSettings::_bloodDropsInterval' has a wrong offset!");
static_assert(offsetof(UBloodTrailSettings, _randomlyRotateBloodDrops) == 0x000044, "Member 'UBloodTrailSettings::_randomlyRotateBloodDrops' has a wrong offset!");
static_assert(offsetof(UBloodTrailSettings, _bloodDropsRandomScatter) == 0x000048, "Member 'UBloodTrailSettings::_bloodDropsRandomScatter' has a wrong offset!");
static_assert(offsetof(UBloodTrailSettings, _bloodTraceChannel) == 0x00004C, "Member 'UBloodTrailSettings::_bloodTraceChannel' has a wrong offset!");
static_assert(offsetof(UBloodTrailSettings, _bloodDecalEffect) == 0x000050, "Member 'UBloodTrailSettings::_bloodDecalEffect' has a wrong offset!");
static_assert(offsetof(UBloodTrailSettings, _decalPoolSize) == 0x000058, "Member 'UBloodTrailSettings::_decalPoolSize' has a wrong offset!");
static_assert(offsetof(UBloodTrailSettings, _recycleThresholdPercentage) == 0x0000F8, "Member 'UBloodTrailSettings::_recycleThresholdPercentage' has a wrong offset!");
static_assert(offsetof(UBloodTrailSettings, _recycleDistancePercentage) == 0x0000FC, "Member 'UBloodTrailSettings::_recycleDistancePercentage' has a wrong offset!");
static_assert(offsetof(UBloodTrailSettings, _maxOverlapping) == 0x000100, "Member 'UBloodTrailSettings::_maxOverlapping' has a wrong offset!");

// Class DeadByDaylight.BloodTrailComponent
// 0x01B8 (0x0260 - 0x00A8)
class alignas(0x10) UBloodTrailComponent : public UActorComponent
{
public:
	class UBloodTrailSettings*                    _bloodTrailSettings;                               // 0x00A8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B0[0x80];                                      // 0x00B0(0x0080)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class UDBDDecalComponent*, struct FBloodDecal> _bloodDecals;                                      // 0x0130(0x0050)(Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UBloodDecalEffect*                      _bloodDecalEffect;                                 // 0x0180(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_188[0xC0];                                     // 0x0188(0x00C0)(Fixing Size After Last Property [ Dumper-7 ])
	class UDecalSpawner*                          _decalSpawner;                                     // 0x0248(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_250[0x10];                                     // 0x0250(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ConditionalStartBleeding();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BloodTrailComponent">();
	}
	static class UBloodTrailComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBloodTrailComponent>();
	}
};
static_assert(alignof(UBloodTrailComponent) == 0x000010, "Wrong alignment on UBloodTrailComponent");
static_assert(sizeof(UBloodTrailComponent) == 0x000260, "Wrong size on UBloodTrailComponent");
static_assert(offsetof(UBloodTrailComponent, _bloodTrailSettings) == 0x0000A8, "Member 'UBloodTrailComponent::_bloodTrailSettings' has a wrong offset!");
static_assert(offsetof(UBloodTrailComponent, _bloodDecals) == 0x000130, "Member 'UBloodTrailComponent::_bloodDecals' has a wrong offset!");
static_assert(offsetof(UBloodTrailComponent, _bloodDecalEffect) == 0x000180, "Member 'UBloodTrailComponent::_bloodDecalEffect' has a wrong offset!");
static_assert(offsetof(UBloodTrailComponent, _decalSpawner) == 0x000248, "Member 'UBloodTrailComponent::_decalSpawner' has a wrong offset!");

// Class DeadByDaylight.ExitGateSwitchesRestrictedPlacementAreaStrategy
// 0x0000 (0x00A8 - 0x00A8)
class UExitGateSwitchesRestrictedPlacementAreaStrategy final : public URestrictedPlacementAreaStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExitGateSwitchesRestrictedPlacementAreaStrategy">();
	}
	static class UExitGateSwitchesRestrictedPlacementAreaStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UExitGateSwitchesRestrictedPlacementAreaStrategy>();
	}
};
static_assert(alignof(UExitGateSwitchesRestrictedPlacementAreaStrategy) == 0x000008, "Wrong alignment on UExitGateSwitchesRestrictedPlacementAreaStrategy");
static_assert(sizeof(UExitGateSwitchesRestrictedPlacementAreaStrategy) == 0x0000A8, "Wrong size on UExitGateSwitchesRestrictedPlacementAreaStrategy");

// Class DeadByDaylight.BloodwebBackendTunables
// 0x0070 (0x00A8 - 0x0038)
class UBloodwebBackendTunables final : public UBloodwebTunables
{
public:
	uint8                                         Pad_38[0x70];                                      // 0x0038(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BloodwebBackendTunables">();
	}
	static class UBloodwebBackendTunables* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBloodwebBackendTunables>();
	}
};
static_assert(alignof(UBloodwebBackendTunables) == 0x000008, "Wrong alignment on UBloodwebBackendTunables");
static_assert(sizeof(UBloodwebBackendTunables) == 0x0000A8, "Wrong size on UBloodwebBackendTunables");

// Class DeadByDaylight.DetectionZoneUtilities
// 0x0000 (0x0030 - 0x0030)
class UDetectionZoneUtilities final : public UBlueprintFunctionLibrary
{
public:
	static bool DetectObstruction(const class ADBDPlayer* Player, EDetectionZone DetectionZoneID, class UPhysicalMaterial** PhysicalMaterialOut, struct FVector* PositionOut, struct FVector* NormalOut);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DetectionZoneUtilities">();
	}
	static class UDetectionZoneUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDetectionZoneUtilities>();
	}
};
static_assert(alignof(UDetectionZoneUtilities) == 0x000008, "Wrong alignment on UDetectionZoneUtilities");
static_assert(sizeof(UDetectionZoneUtilities) == 0x000030, "Wrong size on UDetectionZoneUtilities");

// Class DeadByDaylight.BloodwebDistribution
// 0x02F0 (0x0320 - 0x0030)
class UBloodwebDistribution final : public UObject
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UBloodwebTunables*                      _bloodwebTunables;                                 // 0x0040(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_48[0x2D8];                                     // 0x0048(0x02D8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BloodwebDistribution">();
	}
	static class UBloodwebDistribution* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBloodwebDistribution>();
	}
};
static_assert(alignof(UBloodwebDistribution) == 0x000008, "Wrong alignment on UBloodwebDistribution");
static_assert(sizeof(UBloodwebDistribution) == 0x000320, "Wrong size on UBloodwebDistribution");
static_assert(offsetof(UBloodwebDistribution, _bloodwebTunables) == 0x000040, "Member 'UBloodwebDistribution::_bloodwebTunables' has a wrong offset!");

// Class DeadByDaylight.BloodwebGenerator
// 0x00C0 (0x00F0 - 0x0030)
class alignas(0x10) UBloodwebGenerator : public UObject
{
public:
	uint8                                         Pad_30[0xC];                                       // 0x0030(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRandomStream                          _randomizationStream;                              // 0x003C(0x0008)(ZeroConstructor, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         _selectedNodes;                                    // 0x0048(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class FName>                           _selectedContent;                                  // 0x0058(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_68[0x48];                                      // 0x0068(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	TScriptInterface<class IDBDBloodwebDefinitionBase> _bloodwebDefinition;                               // 0x00B0(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBloodwebTunables*                      _bloodwebTunables;                                 // 0x00C0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _alternativePathOccurenceFactor;                   // 0x00C8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_CC[0x4];                                       // 0x00CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBloodwebDistribution*                  _dataDistribution;                                 // 0x00D0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBloodwebSettings*                      _bloodwebSettings;                                 // 0x00D8(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E0[0x10];                                      // 0x00E0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BloodwebGenerator">();
	}
	static class UBloodwebGenerator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBloodwebGenerator>();
	}
};
static_assert(alignof(UBloodwebGenerator) == 0x000010, "Wrong alignment on UBloodwebGenerator");
static_assert(sizeof(UBloodwebGenerator) == 0x0000F0, "Wrong size on UBloodwebGenerator");
static_assert(offsetof(UBloodwebGenerator, _randomizationStream) == 0x00003C, "Member 'UBloodwebGenerator::_randomizationStream' has a wrong offset!");
static_assert(offsetof(UBloodwebGenerator, _selectedNodes) == 0x000048, "Member 'UBloodwebGenerator::_selectedNodes' has a wrong offset!");
static_assert(offsetof(UBloodwebGenerator, _selectedContent) == 0x000058, "Member 'UBloodwebGenerator::_selectedContent' has a wrong offset!");
static_assert(offsetof(UBloodwebGenerator, _bloodwebDefinition) == 0x0000B0, "Member 'UBloodwebGenerator::_bloodwebDefinition' has a wrong offset!");
static_assert(offsetof(UBloodwebGenerator, _bloodwebTunables) == 0x0000C0, "Member 'UBloodwebGenerator::_bloodwebTunables' has a wrong offset!");
static_assert(offsetof(UBloodwebGenerator, _alternativePathOccurenceFactor) == 0x0000C8, "Member 'UBloodwebGenerator::_alternativePathOccurenceFactor' has a wrong offset!");
static_assert(offsetof(UBloodwebGenerator, _dataDistribution) == 0x0000D0, "Member 'UBloodwebGenerator::_dataDistribution' has a wrong offset!");
static_assert(offsetof(UBloodwebGenerator, _bloodwebSettings) == 0x0000D8, "Member 'UBloodwebGenerator::_bloodwebSettings' has a wrong offset!");

// Class DeadByDaylight.DischargeUntilThresholdIsReachedComponent
// 0x0058 (0x0100 - 0x00A8)
class UDischargeUntilThresholdIsReachedComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x18];                                      // 0x00A8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _threshold;                                        // 0x00C0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class UChargeableComponent*                   _chargeableComponent;                              // 0x00E8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F0[0x10];                                      // 0x00F0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnChargePercentChanged(class UChargeableComponent* ChargeableComponent, float PercentCompletionChange, float TotalPercentComplete);
	void OnChargePercentChanged(class UChargeableComponent* ChargeableComponent, float TotalPercentComplete);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DischargeUntilThresholdIsReachedComponent">();
	}
	static class UDischargeUntilThresholdIsReachedComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDischargeUntilThresholdIsReachedComponent>();
	}
};
static_assert(alignof(UDischargeUntilThresholdIsReachedComponent) == 0x000008, "Wrong alignment on UDischargeUntilThresholdIsReachedComponent");
static_assert(sizeof(UDischargeUntilThresholdIsReachedComponent) == 0x000100, "Wrong size on UDischargeUntilThresholdIsReachedComponent");
static_assert(offsetof(UDischargeUntilThresholdIsReachedComponent, _threshold) == 0x0000C0, "Member 'UDischargeUntilThresholdIsReachedComponent::_threshold' has a wrong offset!");
static_assert(offsetof(UDischargeUntilThresholdIsReachedComponent, _chargeableComponent) == 0x0000E8, "Member 'UDischargeUntilThresholdIsReachedComponent::_chargeableComponent' has a wrong offset!");

// Class DeadByDaylight.BloodwebManager
// 0x01C8 (0x01F8 - 0x0030)
class UBloodwebManager : public UObject
{
public:
	uint8                                         Pad_30[0x60];                                      // 0x0030(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UBloodwebGenerator>         _bloodwebBuilderClass;                             // 0x0090(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDBDGameInstance*                       _gameInstance;                                     // 0x0098(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBaseBloodwebContentAdapter*            _bloodWebContentAdapter;                           // 0x00A0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBloodwebHandler*                       _bloodwebHandler;                                  // 0x00A8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBloodwebPathfinder*                    _bloodwebPathfinder;                               // 0x00B0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B8[0x140];                                     // 0x00B8(0x0140)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Init(class UDBDGameInstance* GameInstance);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BloodwebManager">();
	}
	static class UBloodwebManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBloodwebManager>();
	}
};
static_assert(alignof(UBloodwebManager) == 0x000008, "Wrong alignment on UBloodwebManager");
static_assert(sizeof(UBloodwebManager) == 0x0001F8, "Wrong size on UBloodwebManager");
static_assert(offsetof(UBloodwebManager, _bloodwebBuilderClass) == 0x000090, "Member 'UBloodwebManager::_bloodwebBuilderClass' has a wrong offset!");
static_assert(offsetof(UBloodwebManager, _gameInstance) == 0x000098, "Member 'UBloodwebManager::_gameInstance' has a wrong offset!");
static_assert(offsetof(UBloodwebManager, _bloodWebContentAdapter) == 0x0000A0, "Member 'UBloodwebManager::_bloodWebContentAdapter' has a wrong offset!");
static_assert(offsetof(UBloodwebManager, _bloodwebHandler) == 0x0000A8, "Member 'UBloodwebManager::_bloodwebHandler' has a wrong offset!");
static_assert(offsetof(UBloodwebManager, _bloodwebPathfinder) == 0x0000B0, "Member 'UBloodwebManager::_bloodwebPathfinder' has a wrong offset!");

// Class DeadByDaylight.BloodwebSettings
// 0x0010 (0x0048 - 0x0038)
class UBloodwebSettings final : public UDataAsset
{
public:
	TArray<class FName>                           _duplicableItems;                                  // 0x0038(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BloodwebSettings">();
	}
	static class UBloodwebSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBloodwebSettings>();
	}
};
static_assert(alignof(UBloodwebSettings) == 0x000008, "Wrong alignment on UBloodwebSettings");
static_assert(sizeof(UBloodwebSettings) == 0x000048, "Wrong size on UBloodwebSettings");
static_assert(offsetof(UBloodwebSettings, _duplicableItems) == 0x000038, "Member 'UBloodwebSettings::_duplicableItems' has a wrong offset!");

// Class DeadByDaylight.DisplayStandItemRequesterComponent
// 0x0058 (0x0100 - 0x00A8)
class UDisplayStandItemRequesterComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x58];                                      // 0x00A8(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void LoadItemsOnCharacter(class AActor* Actor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DisplayStandItemRequesterComponent">();
	}
	static class UDisplayStandItemRequesterComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDisplayStandItemRequesterComponent>();
	}
};
static_assert(alignof(UDisplayStandItemRequesterComponent) == 0x000008, "Wrong alignment on UDisplayStandItemRequesterComponent");
static_assert(sizeof(UDisplayStandItemRequesterComponent) == 0x000100, "Wrong size on UDisplayStandItemRequesterComponent");

// Class DeadByDaylight.BloodDecalEffect
// 0x00E0 (0x0118 - 0x0038)
class UBloodDecalEffect final : public UDataAsset
{
public:
	class UCurveFloat*                            AnimationTimelineCurve;                            // 0x0038(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            DestroyTimelineCurve;                              // 0x0040(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UTexture2D*>                     Textures;                                          // 0x0048(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UTexture2D*>                     Normals;                                           // 0x0058(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          EnableVisualEffects;                               // 0x0068(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBloodDecalEffectIntensity*             BloodDecalEffectIntensity;                         // 0x0070(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ColorInterpolationSpeed;                           // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     DefalultDecalMaterial;                             // 0x0080(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_88[0x90];                                      // 0x0088(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BloodDecalEffect">();
	}
	static class UBloodDecalEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBloodDecalEffect>();
	}
};
static_assert(alignof(UBloodDecalEffect) == 0x000008, "Wrong alignment on UBloodDecalEffect");
static_assert(sizeof(UBloodDecalEffect) == 0x000118, "Wrong size on UBloodDecalEffect");
static_assert(offsetof(UBloodDecalEffect, AnimationTimelineCurve) == 0x000038, "Member 'UBloodDecalEffect::AnimationTimelineCurve' has a wrong offset!");
static_assert(offsetof(UBloodDecalEffect, DestroyTimelineCurve) == 0x000040, "Member 'UBloodDecalEffect::DestroyTimelineCurve' has a wrong offset!");
static_assert(offsetof(UBloodDecalEffect, Textures) == 0x000048, "Member 'UBloodDecalEffect::Textures' has a wrong offset!");
static_assert(offsetof(UBloodDecalEffect, Normals) == 0x000058, "Member 'UBloodDecalEffect::Normals' has a wrong offset!");
static_assert(offsetof(UBloodDecalEffect, EnableVisualEffects) == 0x000068, "Member 'UBloodDecalEffect::EnableVisualEffects' has a wrong offset!");
static_assert(offsetof(UBloodDecalEffect, BloodDecalEffectIntensity) == 0x000070, "Member 'UBloodDecalEffect::BloodDecalEffectIntensity' has a wrong offset!");
static_assert(offsetof(UBloodDecalEffect, ColorInterpolationSpeed) == 0x000078, "Member 'UBloodDecalEffect::ColorInterpolationSpeed' has a wrong offset!");
static_assert(offsetof(UBloodDecalEffect, DefalultDecalMaterial) == 0x000080, "Member 'UBloodDecalEffect::DefalultDecalMaterial' has a wrong offset!");

// Class DeadByDaylight.BlueprintPlatformUtilities
// 0x0000 (0x0030 - 0x0030)
class UBlueprintPlatformUtilities final : public UBlueprintFunctionLibrary
{
public:
	static float ToFloat(const struct FDBDPerPlatformFloat& PerPlatformFloat, const class UObject* ObjectInWorld);
	static int32 ToInteger(const struct FDBDPerPlatformInt& PerPlatformInt, const class UObject* ObjectInWorld);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlueprintPlatformUtilities">();
	}
	static class UBlueprintPlatformUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlueprintPlatformUtilities>();
	}
};
static_assert(alignof(UBlueprintPlatformUtilities) == 0x000008, "Wrong alignment on UBlueprintPlatformUtilities");
static_assert(sizeof(UBlueprintPlatformUtilities) == 0x000030, "Wrong size on UBlueprintPlatformUtilities");

// Class DeadByDaylight.DLCManager
// 0x0060 (0x0098 - 0x0038)
class UDLCManager final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x60];                                      // 0x0038(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DLCManager">();
	}
	static class UDLCManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDLCManager>();
	}
};
static_assert(alignof(UDLCManager) == 0x000008, "Wrong alignment on UDLCManager");
static_assert(sizeof(UDLCManager) == 0x000098, "Wrong size on UDLCManager");

// Class DeadByDaylight.BreakableBase
// 0x0028 (0x03D0 - 0x03A8)
class ABreakableBase : public AInteractable
{
public:
	class UBoxComponent*                          _breakableCollision;                               // 0x03A8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBreakableState                               _state;                                            // 0x03B0(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B1[0x7];                                      // 0x03B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkComponent*                           _akAudioBreakable;                                 // 0x03B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          _akAudioBreakEvent;                                // 0x03C0(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        _rootComponent;                                    // 0x03C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Explode(class ADBDPlayer* Player);
	void ExplodeVfxSfx(const struct FVector& ImpulseDir);
	void PlayAudioBreakable();

	bool IsUnbroken() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BreakableBase">();
	}
	static class ABreakableBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABreakableBase>();
	}
};
static_assert(alignof(ABreakableBase) == 0x000008, "Wrong alignment on ABreakableBase");
static_assert(sizeof(ABreakableBase) == 0x0003D0, "Wrong size on ABreakableBase");
static_assert(offsetof(ABreakableBase, _breakableCollision) == 0x0003A8, "Member 'ABreakableBase::_breakableCollision' has a wrong offset!");
static_assert(offsetof(ABreakableBase, _state) == 0x0003B0, "Member 'ABreakableBase::_state' has a wrong offset!");
static_assert(offsetof(ABreakableBase, _akAudioBreakable) == 0x0003B8, "Member 'ABreakableBase::_akAudioBreakable' has a wrong offset!");
static_assert(offsetof(ABreakableBase, _akAudioBreakEvent) == 0x0003C0, "Member 'ABreakableBase::_akAudioBreakEvent' has a wrong offset!");
static_assert(offsetof(ABreakableBase, _rootComponent) == 0x0003C8, "Member 'ABreakableBase::_rootComponent' has a wrong offset!");

// Class DeadByDaylight.FoliageDensityHISM
// 0x0000 (0x0960 - 0x0960)
class UFoliageDensityHISM final : public UHierarchicalInstancedStaticMeshComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FoliageDensityHISM">();
	}
	static class UFoliageDensityHISM* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFoliageDensityHISM>();
	}
};
static_assert(alignof(UFoliageDensityHISM) == 0x000010, "Wrong alignment on UFoliageDensityHISM");
static_assert(sizeof(UFoliageDensityHISM) == 0x000960, "Wrong size on UFoliageDensityHISM");

// Class DeadByDaylight.CakeModePlayerComponent
// 0x0008 (0x00B0 - 0x00A8)
class UCakeModePlayerComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CakeModePlayerComponent">();
	}
	static class UCakeModePlayerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCakeModePlayerComponent>();
	}
};
static_assert(alignof(UCakeModePlayerComponent) == 0x000008, "Wrong alignment on UCakeModePlayerComponent");
static_assert(sizeof(UCakeModePlayerComponent) == 0x0000B0, "Wrong size on UCakeModePlayerComponent");

// Class DeadByDaylight.CameraFadeComponent
// 0x0038 (0x00E0 - 0x00A8)
class UCameraFadeComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x38];                                      // 0x00A8(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnFadedIn();
	void OnFadedOut();

	ECameraFadeState GetCameraFadeState() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraFadeComponent">();
	}
	static class UCameraFadeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCameraFadeComponent>();
	}
};
static_assert(alignof(UCameraFadeComponent) == 0x000008, "Wrong alignment on UCameraFadeComponent");
static_assert(sizeof(UCameraFadeComponent) == 0x0000E0, "Wrong size on UCameraFadeComponent");

// Class DeadByDaylight.FriendManager
// 0x0238 (0x0268 - 0x0030)
class UFriendManager final : public UObject
{
public:
	uint8                                         Pad_30[0x238];                                     // 0x0030(0x0238)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FriendManager">();
	}
	static class UFriendManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFriendManager>();
	}
};
static_assert(alignof(UFriendManager) == 0x000008, "Wrong alignment on UFriendManager");
static_assert(sizeof(UFriendManager) == 0x000268, "Wrong size on UFriendManager");

// Class DeadByDaylight.CameraOffsetController
// 0x0050 (0x00F8 - 0x00A8)
class UCameraOffsetController final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x50];                                      // 0x00A8(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraOffsetController">();
	}
	static class UCameraOffsetController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCameraOffsetController>();
	}
};
static_assert(alignof(UCameraOffsetController) == 0x000008, "Wrong alignment on UCameraOffsetController");
static_assert(sizeof(UCameraOffsetController) == 0x0000F8, "Wrong size on UCameraOffsetController");

// Class DeadByDaylight.CamperBloodTrailComponent
// 0x0030 (0x0290 - 0x0260)
class UCamperBloodTrailComponent final : public UBloodTrailComponent
{
public:
	class UPerkManager*                           _camperPerkManager;                                // 0x0260(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_268[0x28];                                     // 0x0268(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnDamageStateChanged(ECamperDamageState OldDamageState, ECamperDamageState CurrentDamageState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CamperBloodTrailComponent">();
	}
	static class UCamperBloodTrailComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCamperBloodTrailComponent>();
	}
};
static_assert(alignof(UCamperBloodTrailComponent) == 0x000010, "Wrong alignment on UCamperBloodTrailComponent");
static_assert(sizeof(UCamperBloodTrailComponent) == 0x000290, "Wrong size on UCamperBloodTrailComponent");
static_assert(offsetof(UCamperBloodTrailComponent, _camperPerkManager) == 0x000260, "Member 'UCamperBloodTrailComponent::_camperPerkManager' has a wrong offset!");

// Class DeadByDaylight.CharacterDreamworldComponent
// 0x00C8 (0x0170 - 0x00A8)
class UCharacterDreamworldComponent : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             DreamStateChanged;                                 // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     _mobileDreamworldPostProcessClass;                 // 0x00B8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAmbianceManagerDataAsset*              _dreamWorldAmbiance;                               // 0x00C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTagStateBool                          _isInDreamworld;                                   // 0x00C8(0x0048)(Net, Transient, RepNotify, NativeAccessSpecifierPrivate)
	class APostProcessUpdate*                     _mobileDreamworldPostProcess;                      // 0x0110(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_118[0x58];                                     // 0x0118(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class ADBDPlayer* GetLocallyObservedOrLocalCharacter(class UObject* WorldContextObject);

	void Authority_SetIsInDreamworld(bool NewValue, bool IsScripted);
	void FireWakeUpScoreEvent(class ADBDPlayer* Instigator);
	void OnRep_IsInDreamworld();

	bool IsInDreamworld() const;
	bool ShouldShowVignette() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterDreamworldComponent">();
	}
	static class UCharacterDreamworldComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterDreamworldComponent>();
	}
};
static_assert(alignof(UCharacterDreamworldComponent) == 0x000008, "Wrong alignment on UCharacterDreamworldComponent");
static_assert(sizeof(UCharacterDreamworldComponent) == 0x000170, "Wrong size on UCharacterDreamworldComponent");
static_assert(offsetof(UCharacterDreamworldComponent, DreamStateChanged) == 0x0000A8, "Member 'UCharacterDreamworldComponent::DreamStateChanged' has a wrong offset!");
static_assert(offsetof(UCharacterDreamworldComponent, _mobileDreamworldPostProcessClass) == 0x0000B8, "Member 'UCharacterDreamworldComponent::_mobileDreamworldPostProcessClass' has a wrong offset!");
static_assert(offsetof(UCharacterDreamworldComponent, _dreamWorldAmbiance) == 0x0000C0, "Member 'UCharacterDreamworldComponent::_dreamWorldAmbiance' has a wrong offset!");
static_assert(offsetof(UCharacterDreamworldComponent, _isInDreamworld) == 0x0000C8, "Member 'UCharacterDreamworldComponent::_isInDreamworld' has a wrong offset!");
static_assert(offsetof(UCharacterDreamworldComponent, _mobileDreamworldPostProcess) == 0x000110, "Member 'UCharacterDreamworldComponent::_mobileDreamworldPostProcess' has a wrong offset!");

// Class DeadByDaylight.OngoingGameEvent
// 0x0078 (0x00A8 - 0x0030)
class UOngoingGameEvent final : public UObject
{
public:
	struct FGameEventData                         _eventData;                                        // 0x0030(0x0030)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_60[0x48];                                      // 0x0060(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OngoingGameEvent">();
	}
	static class UOngoingGameEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOngoingGameEvent>();
	}
};
static_assert(alignof(UOngoingGameEvent) == 0x000008, "Wrong alignment on UOngoingGameEvent");
static_assert(sizeof(UOngoingGameEvent) == 0x0000A8, "Wrong size on UOngoingGameEvent");
static_assert(offsetof(UOngoingGameEvent, _eventData) == 0x000030, "Member 'UOngoingGameEvent::_eventData' has a wrong offset!");

// Class DeadByDaylight.CamperDreamworldComponent
// 0x0128 (0x0298 - 0x0170)
class UCamperDreamworldComponent final : public UCharacterDreamworldComponent
{
public:
	FMulticastInlineDelegateProperty_             OnCamperTriggeredDreamTrap;                        // 0x0170(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_180[0x10];                                     // 0x0180(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UStatusEffect>              _survivorDreamWorldStatusEffect;                   // 0x0190(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FSurvivorSleepiness                    _survivorSleepiness;                               // 0x0198(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, Transient, NoDestructor, NativeAccessSpecifierPrivate)
	float                                         _sleepinessProtectionRemainingDuration;            // 0x01A0(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _sleepGainPerSecond;                               // 0x01A4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1A8[0x4];                                      // 0x01A8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _wakeUpByOtherCount;                               // 0x01AC(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _showKiller;                                       // 0x01B0(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1B1[0x7];                                      // 0x01B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFastTimer                             _killerGlimpseDurationTimer;                       // 0x01B8(0x0030)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1E8[0x10];                                     // 0x01E8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFastTimer                             _killerGlimpseCooldownTimer;                       // 0x01F8(0x0030)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_228[0x10];                                     // 0x0228(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _glimpseMinDistance;                               // 0x0238(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _glimpseMaxDistance;                               // 0x023C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _killerGlimpseCooldown;                            // 0x0240(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _killerGlimpseDuration;                            // 0x0244(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         _wakeUpBySkillCheckCount;                          // 0x0248(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         _fellAsleepCount;                                  // 0x024C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _forcedAsleep;                                     // 0x0250(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_251[0x7];                                      // 0x0251(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AWakerObject*                           _linkedWaker;                                      // 0x0258(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _useScriptedKillerVisibility;                      // 0x0260(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_261[0x7];                                      // 0x0261(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _showKillerInstantly;                              // 0x0268(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_269[0x2F];                                     // 0x0269(0x002F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_HandleSkillCheckFailure(bool WakeUpEveryoneInteracting, class ADBDPlayer* Instigator);
	void Authority_OnAttacked();
	void Authority_PutAsleep();
	void Authority_WakeUpByHook();
	void Authority_WakeUpByOther(class ADBDPlayer* Instigator);
	void Authority_WakeUpByWakerObject();
	void BroadcastCamperTriggeredDreamTrap(class AActor* DreamObject);
	void HandleShowKillerChanged(bool ShowKiller, bool Instantly);
	void InitializeTunableValues(class ASlasherPlayer* Killer);
	void Local_SetShowKiller(bool ShowKiller, bool Instantly);
	void OnRep_ShowKiller();
	void SetScriptedKillerVisibility(bool UseScriptedKillerVisibility);

	int32 Authority_GetFellAsleepCount() const;
	int32 Authority_GetWakeUpBySkillCheckCount() const;
	void Authority_SpawnDreamworldStatusEffect() const;
	bool CanWakeUp() const;
	bool CanWakeUpBySkillCheck() const;
	int32 GetWakeUpByOtherCount() const;
	bool ShouldLookSleepyToLocalPlayer() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CamperDreamworldComponent">();
	}
	static class UCamperDreamworldComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCamperDreamworldComponent>();
	}
};
static_assert(alignof(UCamperDreamworldComponent) == 0x000008, "Wrong alignment on UCamperDreamworldComponent");
static_assert(sizeof(UCamperDreamworldComponent) == 0x000298, "Wrong size on UCamperDreamworldComponent");
static_assert(offsetof(UCamperDreamworldComponent, OnCamperTriggeredDreamTrap) == 0x000170, "Member 'UCamperDreamworldComponent::OnCamperTriggeredDreamTrap' has a wrong offset!");
static_assert(offsetof(UCamperDreamworldComponent, _survivorDreamWorldStatusEffect) == 0x000190, "Member 'UCamperDreamworldComponent::_survivorDreamWorldStatusEffect' has a wrong offset!");
static_assert(offsetof(UCamperDreamworldComponent, _survivorSleepiness) == 0x000198, "Member 'UCamperDreamworldComponent::_survivorSleepiness' has a wrong offset!");
static_assert(offsetof(UCamperDreamworldComponent, _sleepinessProtectionRemainingDuration) == 0x0001A0, "Member 'UCamperDreamworldComponent::_sleepinessProtectionRemainingDuration' has a wrong offset!");
static_assert(offsetof(UCamperDreamworldComponent, _sleepGainPerSecond) == 0x0001A4, "Member 'UCamperDreamworldComponent::_sleepGainPerSecond' has a wrong offset!");
static_assert(offsetof(UCamperDreamworldComponent, _wakeUpByOtherCount) == 0x0001AC, "Member 'UCamperDreamworldComponent::_wakeUpByOtherCount' has a wrong offset!");
static_assert(offsetof(UCamperDreamworldComponent, _showKiller) == 0x0001B0, "Member 'UCamperDreamworldComponent::_showKiller' has a wrong offset!");
static_assert(offsetof(UCamperDreamworldComponent, _killerGlimpseDurationTimer) == 0x0001B8, "Member 'UCamperDreamworldComponent::_killerGlimpseDurationTimer' has a wrong offset!");
static_assert(offsetof(UCamperDreamworldComponent, _killerGlimpseCooldownTimer) == 0x0001F8, "Member 'UCamperDreamworldComponent::_killerGlimpseCooldownTimer' has a wrong offset!");
static_assert(offsetof(UCamperDreamworldComponent, _glimpseMinDistance) == 0x000238, "Member 'UCamperDreamworldComponent::_glimpseMinDistance' has a wrong offset!");
static_assert(offsetof(UCamperDreamworldComponent, _glimpseMaxDistance) == 0x00023C, "Member 'UCamperDreamworldComponent::_glimpseMaxDistance' has a wrong offset!");
static_assert(offsetof(UCamperDreamworldComponent, _killerGlimpseCooldown) == 0x000240, "Member 'UCamperDreamworldComponent::_killerGlimpseCooldown' has a wrong offset!");
static_assert(offsetof(UCamperDreamworldComponent, _killerGlimpseDuration) == 0x000244, "Member 'UCamperDreamworldComponent::_killerGlimpseDuration' has a wrong offset!");
static_assert(offsetof(UCamperDreamworldComponent, _wakeUpBySkillCheckCount) == 0x000248, "Member 'UCamperDreamworldComponent::_wakeUpBySkillCheckCount' has a wrong offset!");
static_assert(offsetof(UCamperDreamworldComponent, _fellAsleepCount) == 0x00024C, "Member 'UCamperDreamworldComponent::_fellAsleepCount' has a wrong offset!");
static_assert(offsetof(UCamperDreamworldComponent, _forcedAsleep) == 0x000250, "Member 'UCamperDreamworldComponent::_forcedAsleep' has a wrong offset!");
static_assert(offsetof(UCamperDreamworldComponent, _linkedWaker) == 0x000258, "Member 'UCamperDreamworldComponent::_linkedWaker' has a wrong offset!");
static_assert(offsetof(UCamperDreamworldComponent, _useScriptedKillerVisibility) == 0x000260, "Member 'UCamperDreamworldComponent::_useScriptedKillerVisibility' has a wrong offset!");
static_assert(offsetof(UCamperDreamworldComponent, _showKillerInstantly) == 0x000268, "Member 'UCamperDreamworldComponent::_showKillerInstantly' has a wrong offset!");

// Class DeadByDaylight.CamperEndGameComponent
// 0x0070 (0x0118 - 0x00A8)
class UCamperEndGameComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x58];                                      // 0x00A8(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AEndGameEntity>             _endGameEntityClass;                               // 0x0100(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_108[0x4];                                      // 0x0108(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _delayBeforeSacrifice;                             // 0x010C(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _readyToBeSacrificed;                              // 0x0110(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_111[0x7];                                      // 0x0111(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnDelayBeforeSacrificeEnd();
	void OnEndGameSacrificeEnd();

	bool GetSacrificedByEndGame() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CamperEndGameComponent">();
	}
	static class UCamperEndGameComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCamperEndGameComponent>();
	}
};
static_assert(alignof(UCamperEndGameComponent) == 0x000008, "Wrong alignment on UCamperEndGameComponent");
static_assert(sizeof(UCamperEndGameComponent) == 0x000118, "Wrong size on UCamperEndGameComponent");
static_assert(offsetof(UCamperEndGameComponent, _endGameEntityClass) == 0x000100, "Member 'UCamperEndGameComponent::_endGameEntityClass' has a wrong offset!");
static_assert(offsetof(UCamperEndGameComponent, _delayBeforeSacrifice) == 0x00010C, "Member 'UCamperEndGameComponent::_delayBeforeSacrifice' has a wrong offset!");
static_assert(offsetof(UCamperEndGameComponent, _readyToBeSacrificed) == 0x000110, "Member 'UCamperEndGameComponent::_readyToBeSacrificed' has a wrong offset!");

// Class DeadByDaylight.CamperHealthComponent
// 0x0250 (0x02F8 - 0x00A8)
class UCamperHealthComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnHealedDelegate;                                  // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnInjuredBleedoutStarted;                          // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnInjuredBleedoutEnded;                            // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnInjuredBleedoutKO;                               // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_E8[0x30];                                      // 0x00E8(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnDamageStateChanged;                              // 0x0118(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDamageStateChangedCosmetic;                      // 0x0128(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_138[0x18];                                     // 0x0138(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _bleedoutBaseDuration;                             // 0x0150(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FTagStateBool                          _inInjuredBleedOut;                                // 0x0178(0x0048)(Net, Transient, RepNotify, NativeAccessSpecifierPrivate)
	struct FDBDTimer                              _bleedOutTimer;                                    // 0x01C0(0x0028)(Net, Transient, NativeAccessSpecifierPrivate)
	bool                                          _canBleedout;                                      // 0x01E8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1E9[0x7];                                      // 0x01E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UInteractionDefinition>> _pauseInjuredBleedoutTimerInteractions;            // 0x01F0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	int32                                         _currentHealthStateCount;                          // 0x0200(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_204[0x4];                                      // 0x0204(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _numHealthyHeals;                                  // 0x0208(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_20C[0x4];                                      // 0x020C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTimer                              _dyingTimer;                                       // 0x0210(0x0028)(Net, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_238[0x8];                                      // 0x0238(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UChargeableComponent*                   _healFromDyingChargeable;                          // 0x0240(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UChargeableComponent*                   _healFromInjuredChargeable;                        // 0x0248(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UChargeableComponent*                   _mendChargeable;                                   // 0x0250(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ADBDPlayer*                             _injuredBleedoutInstigator;                        // 0x0258(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_260[0x98];                                     // 0x0260(0x0098)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_ApplyDamage(class AActor* DamageSource, class ACharacter* DamagePlayerOwner);
	void Authority_ApplyDeepWound(class AActor* DamageSource, class ACharacter* DamagePlayerOwner);
	void Authority_ApplyDoubleDamage(class AActor* DamageSource, class ACharacter* DamagePlayerOwner);
	void Authority_EndInjuredBleedout();
	void Authority_HealTryGrantScoresOnChargeApplied(float IndividualChargeAmount, float TotalChargeAmount, class AActor* ChargeInstigator, bool WasCoop, float DeltaTime);
	void Authority_MendTryGrantScoresOnChargeApplied(float IndividualChargeAmount, float TotalChargeAmount, class AActor* ChargeInstigator, bool WasCoop, float DeltaTime);
	void Authority_OnHealthBarCharged(bool Complete, const TArray<class AActor*>& Instigators);
	void Authority_OnMendChargeCompletionStateChanged(bool Complete, const TArray<class AActor*>& Instigators);
	void Authority_OnSurvivorRemoved(class ACamperPlayer* Survivor);
	void Authority_SetDamageState(ECamperDamageState DamageState, bool FireScoreEvent, bool Sacrificed);
	class UChargeableComponent* GetCurrentHPSlot();
	void IncreaseHPSlotSize(float Percent);
	void Multicast_OnHealed(const struct FCamperHealResult& HealResult);
	void Multicast_OnInjuredBleedoutKO(class ADBDPlayer* InjuredBleedoutInstigator);
	void Multicast_OnSurvivorGainedHealthStateByOthersEvents(const bool HealedFromKO, class ADBDPlayer* HealedSurvivor, const TArray<class ADBDPlayer*>& Healers, const TArray<bool>& HealedSurvivorFarEnoughAway);
	void Multicast_SetCurrentHealthStateCount(int32 NewHealth, bool FireScoreEvent);
	void Multicast_SetDamageState(ECamperDamageState DamageState, bool FireScoreEvent, bool Sacrificed);
	void Multicast_SetHealthStateFromDamageState(ECamperDamageState DamageState, bool FireScoreEvent);
	void Multicast_SetHealthType(EHealthType HealthType);
	void Multicast_StartInjuredBleedout(class ADBDPlayer* Killer, class UGameplayModifierContainer* Container);
	void OnDamageStateChangedCosmetic__DelegateSignature();
	void OnImmobilizedStateChanged(const EImmobilizedState OldImmobilizeState, const EImmobilizedState NewImmobilizeState);
	void OnRep_InInjuredBleedOut();
	void SetCanBleedout(bool CanBleedout);

	bool CanBecomeHealthy() const;
	bool CanBeHealed() const;
	bool CanBeHealedFromInjured() const;
	bool CanHealSelf() const;
	float GetCurrentTotalHealthBarPercent() const;
	ECamperDamageState GetDamageState() const;
	float GetPercentDyingTimer() const;
	float GetPercentInjuredBleedoutTimer() const;
	bool IsDead() const;
	bool IsDyingTimerExpired() const;
	bool IsHealthy() const;
	bool IsInInjuredBleedout() const;
	bool IsInjured() const;
	bool IsInjuredBleedoutTimerExpired() const;
	bool IsKO() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CamperHealthComponent">();
	}
	static class UCamperHealthComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCamperHealthComponent>();
	}
};
static_assert(alignof(UCamperHealthComponent) == 0x000008, "Wrong alignment on UCamperHealthComponent");
static_assert(sizeof(UCamperHealthComponent) == 0x0002F8, "Wrong size on UCamperHealthComponent");
static_assert(offsetof(UCamperHealthComponent, OnHealedDelegate) == 0x0000A8, "Member 'UCamperHealthComponent::OnHealedDelegate' has a wrong offset!");
static_assert(offsetof(UCamperHealthComponent, OnInjuredBleedoutStarted) == 0x0000B8, "Member 'UCamperHealthComponent::OnInjuredBleedoutStarted' has a wrong offset!");
static_assert(offsetof(UCamperHealthComponent, OnInjuredBleedoutEnded) == 0x0000C8, "Member 'UCamperHealthComponent::OnInjuredBleedoutEnded' has a wrong offset!");
static_assert(offsetof(UCamperHealthComponent, OnInjuredBleedoutKO) == 0x0000D8, "Member 'UCamperHealthComponent::OnInjuredBleedoutKO' has a wrong offset!");
static_assert(offsetof(UCamperHealthComponent, OnDamageStateChanged) == 0x000118, "Member 'UCamperHealthComponent::OnDamageStateChanged' has a wrong offset!");
static_assert(offsetof(UCamperHealthComponent, OnDamageStateChangedCosmetic) == 0x000128, "Member 'UCamperHealthComponent::OnDamageStateChangedCosmetic' has a wrong offset!");
static_assert(offsetof(UCamperHealthComponent, _bleedoutBaseDuration) == 0x000150, "Member 'UCamperHealthComponent::_bleedoutBaseDuration' has a wrong offset!");
static_assert(offsetof(UCamperHealthComponent, _inInjuredBleedOut) == 0x000178, "Member 'UCamperHealthComponent::_inInjuredBleedOut' has a wrong offset!");
static_assert(offsetof(UCamperHealthComponent, _bleedOutTimer) == 0x0001C0, "Member 'UCamperHealthComponent::_bleedOutTimer' has a wrong offset!");
static_assert(offsetof(UCamperHealthComponent, _canBleedout) == 0x0001E8, "Member 'UCamperHealthComponent::_canBleedout' has a wrong offset!");
static_assert(offsetof(UCamperHealthComponent, _pauseInjuredBleedoutTimerInteractions) == 0x0001F0, "Member 'UCamperHealthComponent::_pauseInjuredBleedoutTimerInteractions' has a wrong offset!");
static_assert(offsetof(UCamperHealthComponent, _currentHealthStateCount) == 0x000200, "Member 'UCamperHealthComponent::_currentHealthStateCount' has a wrong offset!");
static_assert(offsetof(UCamperHealthComponent, _numHealthyHeals) == 0x000208, "Member 'UCamperHealthComponent::_numHealthyHeals' has a wrong offset!");
static_assert(offsetof(UCamperHealthComponent, _dyingTimer) == 0x000210, "Member 'UCamperHealthComponent::_dyingTimer' has a wrong offset!");
static_assert(offsetof(UCamperHealthComponent, _healFromDyingChargeable) == 0x000240, "Member 'UCamperHealthComponent::_healFromDyingChargeable' has a wrong offset!");
static_assert(offsetof(UCamperHealthComponent, _healFromInjuredChargeable) == 0x000248, "Member 'UCamperHealthComponent::_healFromInjuredChargeable' has a wrong offset!");
static_assert(offsetof(UCamperHealthComponent, _mendChargeable) == 0x000250, "Member 'UCamperHealthComponent::_mendChargeable' has a wrong offset!");
static_assert(offsetof(UCamperHealthComponent, _injuredBleedoutInstigator) == 0x000258, "Member 'UCamperHealthComponent::_injuredBleedoutInstigator' has a wrong offset!");

// Class DeadByDaylight.GameFlowContextSystem
// 0x00C0 (0x00F8 - 0x0038)
class UGameFlowContextSystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0xA8];                                      // 0x0038(0x00A8)(Fixing Size After Last Property [ Dumper-7 ])
	class URootMovie*                             M_RootMovie;                                       // 0x00E0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E8[0x10];                                      // 0x00E8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameFlowContextSystem">();
	}
	static class UGameFlowContextSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameFlowContextSystem>();
	}
};
static_assert(alignof(UGameFlowContextSystem) == 0x000008, "Wrong alignment on UGameFlowContextSystem");
static_assert(sizeof(UGameFlowContextSystem) == 0x0000F8, "Wrong size on UGameFlowContextSystem");
static_assert(offsetof(UGameFlowContextSystem, M_RootMovie) == 0x0000E0, "Member 'UGameFlowContextSystem::M_RootMovie' has a wrong offset!");

// Class DeadByDaylight.SurvivorAttackableComponent
// 0x0028 (0x00D0 - 0x00A8)
class USurvivorAttackableComponent final : public UAttackableComponent
{
public:
	uint8                                         Pad_A8[0x28];                                      // 0x00A8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_HitCosmetic(const class AActor* Attacker, EAttackType AttackType, bool CauseKO, bool IsWeaponHit);
	void Multicast_HitCosmetic(const struct FPlayerHitCosmeticParams& Params_0);
	void Multicast_HitCosmetic_NonLocal(const struct FPlayerHitCosmeticParams& Params_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SurvivorAttackableComponent">();
	}
	static class USurvivorAttackableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USurvivorAttackableComponent>();
	}
};
static_assert(alignof(USurvivorAttackableComponent) == 0x000008, "Wrong alignment on USurvivorAttackableComponent");
static_assert(sizeof(USurvivorAttackableComponent) == 0x0000D0, "Wrong size on USurvivorAttackableComponent");

// Class DeadByDaylight.CamperInteractable
// 0x00E0 (0x04C0 - 0x03E0)
class ACamperInteractable : public APlayerInteractable
{
public:
	uint8                                         Pad_3E0[0x8];                                      // 0x03E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UInteractor*>                    HealingInteractors;                                // 0x03E8(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class UChargeableInteractionDefinition*> _healInteractions;                                 // 0x03F8(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UChargeableComponent*                   _killCharge;                                       // 0x0408(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UActivatorComponent*                    _activator;                                        // 0x0410(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_418[0x68];                                     // 0x0418(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	class UInteractor*                            _killInteractor;                                   // 0x0480(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBoxComponent*                          _killInteractionZone;                              // 0x0488(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USphereComponent*                       _killHealthyInteractionZone;                       // 0x0490(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInteractor*                            _healingInteractor1;                               // 0x0498(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInteractor*                            _killerInteractor;                                 // 0x04A0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USphereComponent*                       _killerInteractionZone;                            // 0x04A8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4B0[0x10];                                     // 0x04B0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ServerMoveOut();
	void SetKillInteraction(class UInteractionDefinition* KillInteraction);
	void UpdateTargetHPSlot();

	class ACamperPlayer* GetOwningSurvivor() const;
	class UInteractor* GetSlasherInteractor() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CamperInteractable">();
	}
	static class ACamperInteractable* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACamperInteractable>();
	}
};
static_assert(alignof(ACamperInteractable) == 0x000008, "Wrong alignment on ACamperInteractable");
static_assert(sizeof(ACamperInteractable) == 0x0004C0, "Wrong size on ACamperInteractable");
static_assert(offsetof(ACamperInteractable, HealingInteractors) == 0x0003E8, "Member 'ACamperInteractable::HealingInteractors' has a wrong offset!");
static_assert(offsetof(ACamperInteractable, _healInteractions) == 0x0003F8, "Member 'ACamperInteractable::_healInteractions' has a wrong offset!");
static_assert(offsetof(ACamperInteractable, _killCharge) == 0x000408, "Member 'ACamperInteractable::_killCharge' has a wrong offset!");
static_assert(offsetof(ACamperInteractable, _activator) == 0x000410, "Member 'ACamperInteractable::_activator' has a wrong offset!");
static_assert(offsetof(ACamperInteractable, _killInteractor) == 0x000480, "Member 'ACamperInteractable::_killInteractor' has a wrong offset!");
static_assert(offsetof(ACamperInteractable, _killInteractionZone) == 0x000488, "Member 'ACamperInteractable::_killInteractionZone' has a wrong offset!");
static_assert(offsetof(ACamperInteractable, _killHealthyInteractionZone) == 0x000490, "Member 'ACamperInteractable::_killHealthyInteractionZone' has a wrong offset!");
static_assert(offsetof(ACamperInteractable, _healingInteractor1) == 0x000498, "Member 'ACamperInteractable::_healingInteractor1' has a wrong offset!");
static_assert(offsetof(ACamperInteractable, _killerInteractor) == 0x0004A0, "Member 'ACamperInteractable::_killerInteractor' has a wrong offset!");
static_assert(offsetof(ACamperInteractable, _killerInteractionZone) == 0x0004A8, "Member 'ACamperInteractable::_killerInteractionZone' has a wrong offset!");

// Class DeadByDaylight.SurviveTimerScoreEventComponent
// 0x0028 (0x00D0 - 0x00A8)
class USurviveTimerScoreEventComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x28];                                      // 0x00A8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnGameStarted();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SurviveTimerScoreEventComponent">();
	}
	static class USurviveTimerScoreEventComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USurviveTimerScoreEventComponent>();
	}
};
static_assert(alignof(USurviveTimerScoreEventComponent) == 0x000008, "Wrong alignment on USurviveTimerScoreEventComponent");
static_assert(sizeof(USurviveTimerScoreEventComponent) == 0x0000D0, "Wrong size on USurviveTimerScoreEventComponent");

// Class DeadByDaylight.CamperPlayer
// 0x04D0 (0x1A10 - 0x1540)
class ACamperPlayer : public ADBDPlayer
{
public:
	uint8                                         Pad_1540[0x10];                                    // 0x1540(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnHookedStateChanged;                              // 0x1550(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnGuidedStateChanged;                              // 0x1560(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPickedUpDelegate;                                // 0x1570(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPickedUpEndDelegate;                             // 0x1580(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnHPSlotChanged;                                   // 0x1590(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_15A0[0x40];                                    // 0x15A0(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnImmobilizeStateChanged;                          // 0x15E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_15F0[0x30];                                    // 0x15F0(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnHookEscapeFailedCosmetic;                        // 0x1620(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class FName                                   ReverseBearTrapAttachSocket;                       // 0x1630(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsBeingDissolved;                                  // 0x163C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_163D[0x3];                                     // 0x163D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FootprintAudibleRange;                             // 0x1640(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1644[0x4];                                     // 0x1644(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UStalkedComponent*                      StalkedComponent;                                  // 0x1648(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraResetToleranceYaw;                           // 0x1650(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraResetTolerancePitch;                         // 0x1654(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraRecenterOffsetYaw;                           // 0x1658(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraRecenterOffsetPitch;                         // 0x165C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGender                                       Gender;                                            // 0x1660(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1661[0x7];                                     // 0x1661(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            DropStaggerDuration;                               // 0x1668(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            DropStaggerMaxSpeed;                               // 0x1670(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeforDeathWhileCrawling;                         // 0x1678(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeforDeathWhileHooked;                           // 0x167C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SecondsUntilFootprintTrigger;                      // 0x1680(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TriggerAfflictionHUDIntro;                         // 0x1684(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1685[0xAB];                                    // 0x1685(0x00AB)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerController*                      _storedPlayerController;                           // 0x1730(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCamperStillnessTrackerComponent*       _stillnessTracker;                                 // 0x1738(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PartiallyHiddenStillnessThreshold;                 // 0x1740(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1744[0x4];                                     // 0x1744(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 _escape;                                           // 0x1748(0x0008)(Net, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 _overlappingEscape;                                // 0x1750(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USpherePlayerOverlapComponent*          ProximityZone;                                     // 0x1758(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1760[0x18];                                    // 0x1760(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UCapsuleComponent*                      SlashableZone;                                     // 0x1778(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCapsuleComponent*                      HookSlashableZone;                                 // 0x1780(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCamperSlashableComponent*              _camperSlashable;                                  // 0x1788(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMoriableComponent*                     _moriableComponent;                                // 0x1790(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CrouchCapsuleHalfHeight;                           // 0x1798(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         IKOffsetRightFoot;                                 // 0x179C(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         IKOffsetLeftFoot;                                  // 0x17A0(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_17A4[0xC];                                     // 0x17A4(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	class UDBDPawnSensingComponent*               _camperSensor;                                     // 0x17B0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USurviveTimerScoreEventComponent*       _surviveTimerScoreComponent;                       // 0x17B8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_17C0[0x10];                                    // 0x17C0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ADBDPlayer*>                     _foundCampers;                                     // 0x17D0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class ADBDPlayer*>                     _potentialSaviors;                                 // 0x17E0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class UCamperHealthComponent*                 _healthComponent;                                  // 0x17F0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UChargeableComponent*                   _hpSlot01;                                         // 0x17F8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UChargeableComponent*                   _hpSlot02;                                         // 0x1800(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UChargeableComponent*                   _mendChargeable;                                   // 0x1808(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UChargeableComponent*                   _antiCampUnhookChargeable;                         // 0x1810(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBloodTrailSettings*                    _bloodTrailSettings;                               // 0x1818(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCamperBloodTrailComponent*             _bloodTrailComponent;                              // 0x1820(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCameraAttachmentComponent*             _cameraAttachment;                                 // 0x1828(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCharmSpawnerComponent*                 _charmSpawnerComponent;                            // 0x1830(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHookableComponent*                     _hookableComponent;                                // 0x1838(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UProtectionHitComponent*                _protectionHitComponent;                           // 0x1840(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UScreamComponent*                       _screamComponent;                                  // 0x1848(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCharacterPositionRecorderComponent*    _positionRecorder;                                 // 0x1850(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1858[0x65];                                    // 0x1858(0x0065)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _lastEscaped;                                      // 0x18BD(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _runInputPressed;                                  // 0x18BE(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_18BF[0x31];                                    // 0x18BF(0x0031)(Fixing Size After Last Property [ Dumper-7 ])
	class UCamperEndGameComponent*                _camperEndGameComponent;                           // 0x18F0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkComponent*                           _noOcclusionAkComponent;                           // 0x18F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkComponent*                           _attenuationAkComponent;                           // 0x1900(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1908[0x24];                                    // 0x1908(0x0024)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _isBeingSacrificed;                                // 0x192C(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isWiggleProgressionAllowed;                       // 0x192D(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_192E[0x9A];                                    // 0x192E(0x009A)(Fixing Size After Last Property [ Dumper-7 ])
	class UMoveComponentToComponent*              _meshMover;                                        // 0x19C8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCarriedMovementComponent*              _carriedMovementComponent;                         // 0x19D0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class UAntiCampSelfUnhookComponent> _antiCampSelfUnhookComponent;                      // 0x19D8(0x0008)(Edit, BlueprintVisible, ExportObject, Net, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USurvivorHitSprintEffect*               _sprintEffect;                                     // 0x19E0(0x0008)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _sprintOnHitEffectClass;                           // 0x19E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_19F0[0x20];                                    // 0x19F0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActionInputPressed();
	void ActionInputReleased();
	void ActivateLocalPlayerExposedVFX();
	void ActivatePlayerExposedVFX();
	void AddBloodDecalToGK_Mori();
	void AddBloodDrippingToGK_Mori();
	void AddBloodDropsToLeftHand();
	void AddBloodDropsToRightHand();
	void AttachToGuidingPlayer();
	void Authority_ApplySprintEffect();
	void Authority_OnSlashed(class ADBDPlayer* Attacker);
	void Authority_SetImmobilized(EImmobilizedState State);
	void Client_OnSlashedOutOfTrap(class ADBDPlayer* Requester);
	bool ComputeBeartrapEscapeResult();
	bool ComputeHookEscapeResult();
	float ComputeInteractionSuccessPercentage(const class UInteractionDefinition* Interaction);
	void DBD_CheatEscaped();
	void DBD_ForceRun(bool Forced);
	void DBD_LeaveParadise();
	void DBD_SetImmobilized(EImmobilizedState State);
	void DBD_SetSurvivorCameraArmLength(float CameraArmLength);
	void DBD_SetSurvivorCameraArmLengthCommand(float CameraArmLength);
	void DecalBlood_Puddles();
	void DetachFromGuidingPlayer();
	void DoSacrificialDissolve();
	void EscapeTutorial();
	void EventOnDeath();
	void HatchEscapeZoneEntered(class AActor* Escape);
	void Input_ToggleRun();
	bool IsRunLocked();
	void Kill(EHealthType HealthType);
	void Local_SetImmobilized(EImmobilizedState State);
	void MakeCamperDisappear();
	void MakeCamperDisappearBleedOut();
	void Multicast_EscapeItemEvents(bool IsItemFromSpawn);
	void Multicast_RemoveReverseBearTrap();
	void Multicast_SetAuthoritativeMovementFlag(EAuthoritativeMovementFlag Flag, bool Value);
	void Multicast_SetHookEscapeAutoFail(bool Enabled);
	void Multicast_SetImmobilized(EImmobilizedState State);
	void Multicast_SetOverlappingEscape(class AActor* Escape);
	void OnDroppedEnd(bool ClearLeader);
	void OnDroppedStart(class ADBDPlayer* Dropper);
	void OnFinishedPlaying();
	void OnHooked();
	void OnHookedStateChangedCosmetic(bool Hooked);
	void OnHpSlotSkillCheckResponseAesthetic(bool Success, bool Bonus, class ADBDPlayer* Player, bool TriggerLoudNoise, bool HadInput, ESkillCheckCustomType Type, float ChargeChange);
	void OnObsessionChanged(class ACamperPlayer* NewObsession, class ACamperPlayer* PreviousObsession);
	void OnPawnSensed(class APawn* Pawn);
	void OnPickUpEnter(class ADBDPlayer* Picker, float TransitionTime);
	void OnProximityEntered(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnRep_RunInputPressed();
	void OnRep_SprintEffect();
	void OnUnhooked();
	void RemoveReverseBearTrap();
	void ResetCameraAttach();
	void ResetPotentialSaviors();
	void RunLocked(bool Lock);
	void Server_SetOverlappingEscape(class AActor* Escape);
	void Server_SetRunInput(bool Pressed);
	void SetBeingCarried(bool IsBeingCarried, class ADBDPlayer* Carrier);
	void SetPlayerExposedVFX();
	void SetVignetteVisible(bool Visible);
	void StartHealingTimer(float Time);
	void StopHealingTimer();
	void SurvivorDissolve(bool ShouldDissolve, float TimeToDissolve);
	void TriggerAfflictionHUDFeedback();
	void TriggerPickUpAnimation();
	void TriggerPutDownAnimation();
	void UpdateHealingTimer(float DeltaTime);

	bool AcceptsHealing() const;
	bool CanBeKilled() const;
	bool CanBePickedUp() const;
	bool CanBeShocked() const;
	bool CanRushQuietly() const;
	struct FVector GetAimPoint() const;
	TArray<class UDBDClipRegionComponent*> GetAllEntityRenderRegions() const;
	class UAntiCampSelfUnhookComponent* GetAntiCampSelfUnhookComponent() const;
	class UAkComponent* GetAttenuationAudioComponent() const;
	class UCamperBloodTrailComponent* GetBloodTrailComponent() const;
	class UCameraAttachmentComponent* GetCameraAttachmentComponent() const;
	class UChaseeCharacterComponent* GetChaseeCharacterComponent() const;
	class UDBDClipRegionComponent* GetEntityRenderRegionAtIndex(int32 InIndex) const;
	EGuidedState GetGuidedAction() const;
	class UCamperHealthComponent* GetHealthComponent() const;
	class UHookableComponent* GetHookableComponent() const;
	EImmobilizedState GetImmobilizedState() const;
	bool GetIsBeingDissolved() const;
	bool GetIsWiggleProgressionAllowed() const;
	float GetMaxGruntDistance(bool IsLocalPlayerKiller) const;
	class UMoveComponentToComponent* GetMeshMover() const;
	class UAnimationMontageSlave* GetMontageFollower() const;
	class UAkComponent* GetNoOcclusionAudioComponent() const;
	int32 GetNumberOfEntityRenderRegions() const;
	float GetObsessionTargetWeight() const;
	class AActor* GetOverlappingEscape() const;
	float GetPercentHealingTimer() const;
	class AReverseBearTrap* GetReverseBearTrap() const;
	float GetStillness() const;
	struct FRotator GetToAimPointRotation() const;
	class UChargeableComponent* GetWiggleChargeable() const;
	bool HasGuidedAction() const;
	bool HasHitEvents() const;
	bool HasReverseBearTrap() const;
	bool IsBeingCarried() const;
	bool IsBeingEndGameSacrificed() const;
	bool IsBeingHealed() const;
	bool IsBeingInteractedWith() const;
	bool IsBeingKilled() const;
	bool IsBeingMended() const;
	bool IsBeingPickedUp() const;
	bool IsBeingPulledFromCloset() const;
	bool IsBeingPutDown() const;
	bool IsBeingPutOnHook() const;
	bool IsBeingUnhooked() const;
	bool IsCrawling() const;
	bool IsDeadOrInParadise() const;
	bool IsEscaped() const;
	bool IsGuidedBySlasher() const;
	bool IsHealingTimerExpired() const;
	bool IsHooked() const;
	bool IsInDeathBed() const;
	bool IsInNeed() const;
	bool IsMovementGuided() const;
	bool IsObsessionTarget() const;
	bool IsSacrificed() const;
	bool IsTrapped() const;
	bool IsUnhookingSelf() const;
	bool IsUnintentionallyImmobilized() const;
	bool IsVaulting() const;
	void NotifySurvivorDissolveFinished(bool IsDissolved) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CamperPlayer">();
	}
	static class ACamperPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACamperPlayer>();
	}
};
static_assert(alignof(ACamperPlayer) == 0x000010, "Wrong alignment on ACamperPlayer");
static_assert(sizeof(ACamperPlayer) == 0x001A10, "Wrong size on ACamperPlayer");
static_assert(offsetof(ACamperPlayer, OnHookedStateChanged) == 0x001550, "Member 'ACamperPlayer::OnHookedStateChanged' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, OnGuidedStateChanged) == 0x001560, "Member 'ACamperPlayer::OnGuidedStateChanged' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, OnPickedUpDelegate) == 0x001570, "Member 'ACamperPlayer::OnPickedUpDelegate' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, OnPickedUpEndDelegate) == 0x001580, "Member 'ACamperPlayer::OnPickedUpEndDelegate' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, OnHPSlotChanged) == 0x001590, "Member 'ACamperPlayer::OnHPSlotChanged' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, OnImmobilizeStateChanged) == 0x0015E0, "Member 'ACamperPlayer::OnImmobilizeStateChanged' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, OnHookEscapeFailedCosmetic) == 0x001620, "Member 'ACamperPlayer::OnHookEscapeFailedCosmetic' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, ReverseBearTrapAttachSocket) == 0x001630, "Member 'ACamperPlayer::ReverseBearTrapAttachSocket' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, IsBeingDissolved) == 0x00163C, "Member 'ACamperPlayer::IsBeingDissolved' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, FootprintAudibleRange) == 0x001640, "Member 'ACamperPlayer::FootprintAudibleRange' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, StalkedComponent) == 0x001648, "Member 'ACamperPlayer::StalkedComponent' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, CameraResetToleranceYaw) == 0x001650, "Member 'ACamperPlayer::CameraResetToleranceYaw' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, CameraResetTolerancePitch) == 0x001654, "Member 'ACamperPlayer::CameraResetTolerancePitch' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, CameraRecenterOffsetYaw) == 0x001658, "Member 'ACamperPlayer::CameraRecenterOffsetYaw' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, CameraRecenterOffsetPitch) == 0x00165C, "Member 'ACamperPlayer::CameraRecenterOffsetPitch' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, Gender) == 0x001660, "Member 'ACamperPlayer::Gender' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, DropStaggerDuration) == 0x001668, "Member 'ACamperPlayer::DropStaggerDuration' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, DropStaggerMaxSpeed) == 0x001670, "Member 'ACamperPlayer::DropStaggerMaxSpeed' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, TimeforDeathWhileCrawling) == 0x001678, "Member 'ACamperPlayer::TimeforDeathWhileCrawling' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, TimeforDeathWhileHooked) == 0x00167C, "Member 'ACamperPlayer::TimeforDeathWhileHooked' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, SecondsUntilFootprintTrigger) == 0x001680, "Member 'ACamperPlayer::SecondsUntilFootprintTrigger' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, TriggerAfflictionHUDIntro) == 0x001684, "Member 'ACamperPlayer::TriggerAfflictionHUDIntro' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, _storedPlayerController) == 0x001730, "Member 'ACamperPlayer::_storedPlayerController' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, _stillnessTracker) == 0x001738, "Member 'ACamperPlayer::_stillnessTracker' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, PartiallyHiddenStillnessThreshold) == 0x001740, "Member 'ACamperPlayer::PartiallyHiddenStillnessThreshold' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, _escape) == 0x001748, "Member 'ACamperPlayer::_escape' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, _overlappingEscape) == 0x001750, "Member 'ACamperPlayer::_overlappingEscape' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, ProximityZone) == 0x001758, "Member 'ACamperPlayer::ProximityZone' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, SlashableZone) == 0x001778, "Member 'ACamperPlayer::SlashableZone' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, HookSlashableZone) == 0x001780, "Member 'ACamperPlayer::HookSlashableZone' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, _camperSlashable) == 0x001788, "Member 'ACamperPlayer::_camperSlashable' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, _moriableComponent) == 0x001790, "Member 'ACamperPlayer::_moriableComponent' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, CrouchCapsuleHalfHeight) == 0x001798, "Member 'ACamperPlayer::CrouchCapsuleHalfHeight' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, IKOffsetRightFoot) == 0x00179C, "Member 'ACamperPlayer::IKOffsetRightFoot' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, IKOffsetLeftFoot) == 0x0017A0, "Member 'ACamperPlayer::IKOffsetLeftFoot' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, _camperSensor) == 0x0017B0, "Member 'ACamperPlayer::_camperSensor' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, _surviveTimerScoreComponent) == 0x0017B8, "Member 'ACamperPlayer::_surviveTimerScoreComponent' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, _foundCampers) == 0x0017D0, "Member 'ACamperPlayer::_foundCampers' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, _potentialSaviors) == 0x0017E0, "Member 'ACamperPlayer::_potentialSaviors' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, _healthComponent) == 0x0017F0, "Member 'ACamperPlayer::_healthComponent' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, _hpSlot01) == 0x0017F8, "Member 'ACamperPlayer::_hpSlot01' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, _hpSlot02) == 0x001800, "Member 'ACamperPlayer::_hpSlot02' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, _mendChargeable) == 0x001808, "Member 'ACamperPlayer::_mendChargeable' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, _antiCampUnhookChargeable) == 0x001810, "Member 'ACamperPlayer::_antiCampUnhookChargeable' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, _bloodTrailSettings) == 0x001818, "Member 'ACamperPlayer::_bloodTrailSettings' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, _bloodTrailComponent) == 0x001820, "Member 'ACamperPlayer::_bloodTrailComponent' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, _cameraAttachment) == 0x001828, "Member 'ACamperPlayer::_cameraAttachment' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, _charmSpawnerComponent) == 0x001830, "Member 'ACamperPlayer::_charmSpawnerComponent' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, _hookableComponent) == 0x001838, "Member 'ACamperPlayer::_hookableComponent' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, _protectionHitComponent) == 0x001840, "Member 'ACamperPlayer::_protectionHitComponent' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, _screamComponent) == 0x001848, "Member 'ACamperPlayer::_screamComponent' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, _positionRecorder) == 0x001850, "Member 'ACamperPlayer::_positionRecorder' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, _lastEscaped) == 0x0018BD, "Member 'ACamperPlayer::_lastEscaped' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, _runInputPressed) == 0x0018BE, "Member 'ACamperPlayer::_runInputPressed' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, _camperEndGameComponent) == 0x0018F0, "Member 'ACamperPlayer::_camperEndGameComponent' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, _noOcclusionAkComponent) == 0x0018F8, "Member 'ACamperPlayer::_noOcclusionAkComponent' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, _attenuationAkComponent) == 0x001900, "Member 'ACamperPlayer::_attenuationAkComponent' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, _isBeingSacrificed) == 0x00192C, "Member 'ACamperPlayer::_isBeingSacrificed' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, _isWiggleProgressionAllowed) == 0x00192D, "Member 'ACamperPlayer::_isWiggleProgressionAllowed' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, _meshMover) == 0x0019C8, "Member 'ACamperPlayer::_meshMover' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, _carriedMovementComponent) == 0x0019D0, "Member 'ACamperPlayer::_carriedMovementComponent' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, _antiCampSelfUnhookComponent) == 0x0019D8, "Member 'ACamperPlayer::_antiCampSelfUnhookComponent' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, _sprintEffect) == 0x0019E0, "Member 'ACamperPlayer::_sprintEffect' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, _sprintOnHitEffectClass) == 0x0019E8, "Member 'ACamperPlayer::_sprintOnHitEffectClass' has a wrong offset!");

// Class DeadByDaylight.InteractableTransformOptimizer
// 0x0008 (0x00B0 - 0x00A8)
class UInteractableTransformOptimizer final : public UActorComponent
{
public:
	bool                                          _optimizeTransformUpdate;                          // 0x00A8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractableTransformOptimizer">();
	}
	static class UInteractableTransformOptimizer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractableTransformOptimizer>();
	}
};
static_assert(alignof(UInteractableTransformOptimizer) == 0x000008, "Wrong alignment on UInteractableTransformOptimizer");
static_assert(sizeof(UInteractableTransformOptimizer) == 0x0000B0, "Wrong size on UInteractableTransformOptimizer");
static_assert(offsetof(UInteractableTransformOptimizer, _optimizeTransformUpdate) == 0x0000A8, "Member 'UInteractableTransformOptimizer::_optimizeTransformUpdate' has a wrong offset!");

// Class DeadByDaylight.CamperStateMachine
// 0x0000 (0x0120 - 0x0120)
class UCamperStateMachine final : public UPlayerStateMachine
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CamperStateMachine">();
	}
	static class UCamperStateMachine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCamperStateMachine>();
	}
};
static_assert(alignof(UCamperStateMachine) == 0x000010, "Wrong alignment on UCamperStateMachine");
static_assert(sizeof(UCamperStateMachine) == 0x000120, "Wrong size on UCamperStateMachine");

// Class DeadByDaylight.CartersSparkComponent
// 0x0130 (0x01D8 - 0x00A8)
class UCartersSparkComponent final : public UActorComponent
{
public:
	bool                                          _staticBlastEnabled;                               // 0x00A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A9[0x8F];                                      // 0x00A9(0x008F)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ADBDPlayer*>                     _totallyInsanePlayers;                             // 0x0138(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class ADBDPlayer*                             _owningPlayer;                                     // 0x0148(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _baseStaticBlastCooldown;                          // 0x0150(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _hitSurvivorStaticBlastCooldown;                   // 0x0178(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1A0[0x10];                                     // 0x01A0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _maxMadnessTier;                                   // 0x01B0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	void Authority_AddTotallyInsaneSurvivor(class ADBDPlayer* InsaneSurvivor);
	void Authority_RegisterToGameEvents();
	void Multicast_OnShockTherapyCooldownCheatEntered();
	void OnRequestAndBeginInteraction(class UInteractionDefinition* Interaction);
	void TriggerShockTherapyCooldown();
	void TriggerStaticBlastCooldown(bool HasHitSurvivor);

	float GetShockTherapyCooldownDuration() const;
	float GetStaticBlastCooldownDuration(bool HasHitSurvivor) const;
	float GetStaticBlastCooldownPercentElapsed() const;
	bool IsShockTherapyOnCooldown() const;
	bool IsStaticBlastOnCooldown() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CartersSparkComponent">();
	}
	static class UCartersSparkComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCartersSparkComponent>();
	}
};
static_assert(alignof(UCartersSparkComponent) == 0x000008, "Wrong alignment on UCartersSparkComponent");
static_assert(sizeof(UCartersSparkComponent) == 0x0001D8, "Wrong size on UCartersSparkComponent");
static_assert(offsetof(UCartersSparkComponent, _staticBlastEnabled) == 0x0000A8, "Member 'UCartersSparkComponent::_staticBlastEnabled' has a wrong offset!");
static_assert(offsetof(UCartersSparkComponent, _totallyInsanePlayers) == 0x000138, "Member 'UCartersSparkComponent::_totallyInsanePlayers' has a wrong offset!");
static_assert(offsetof(UCartersSparkComponent, _owningPlayer) == 0x000148, "Member 'UCartersSparkComponent::_owningPlayer' has a wrong offset!");
static_assert(offsetof(UCartersSparkComponent, _baseStaticBlastCooldown) == 0x000150, "Member 'UCartersSparkComponent::_baseStaticBlastCooldown' has a wrong offset!");
static_assert(offsetof(UCartersSparkComponent, _hitSurvivorStaticBlastCooldown) == 0x000178, "Member 'UCartersSparkComponent::_hitSurvivorStaticBlastCooldown' has a wrong offset!");
static_assert(offsetof(UCartersSparkComponent, _maxMadnessTier) == 0x0001B0, "Member 'UCartersSparkComponent::_maxMadnessTier' has a wrong offset!");

// Class DeadByDaylight.CharacterCollisionsUtilities
// 0x0000 (0x0030 - 0x0030)
class UCharacterCollisionsUtilities final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterCollisionsUtilities">();
	}
	static class UCharacterCollisionsUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterCollisionsUtilities>();
	}
};
static_assert(alignof(UCharacterCollisionsUtilities) == 0x000008, "Wrong alignment on UCharacterCollisionsUtilities");
static_assert(sizeof(UCharacterCollisionsUtilities) == 0x000030, "Wrong size on UCharacterCollisionsUtilities");

// Class DeadByDaylight.IsNotSightedByAnyCharacter
// 0x0008 (0x00E8 - 0x00E0)
class UIsNotSightedByAnyCharacter : public UEventDrivenModifierCondition
{
public:
	uint8                                         Pad_E0[0x8];                                       // 0x00E0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IsNotSightedByAnyCharacter">();
	}
	static class UIsNotSightedByAnyCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIsNotSightedByAnyCharacter>();
	}
};
static_assert(alignof(UIsNotSightedByAnyCharacter) == 0x000008, "Wrong alignment on UIsNotSightedByAnyCharacter");
static_assert(sizeof(UIsNotSightedByAnyCharacter) == 0x0000E8, "Wrong size on UIsNotSightedByAnyCharacter");

// Class DeadByDaylight.IsNotSightedByAnySurvivor
// 0x0000 (0x00E8 - 0x00E8)
class UIsNotSightedByAnySurvivor final : public UIsNotSightedByAnyCharacter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IsNotSightedByAnySurvivor">();
	}
	static class UIsNotSightedByAnySurvivor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIsNotSightedByAnySurvivor>();
	}
};
static_assert(alignof(UIsNotSightedByAnySurvivor) == 0x000008, "Wrong alignment on UIsNotSightedByAnySurvivor");
static_assert(sizeof(UIsNotSightedByAnySurvivor) == 0x0000E8, "Wrong size on UIsNotSightedByAnySurvivor");

// Class DeadByDaylight.SlasherHitsWhileCarryingTrackerComponent
// 0x0060 (0x0108 - 0x00A8)
class USlasherHitsWhileCarryingTrackerComponent final : public UActorComponent
{
public:
	TSet<class ACamperPlayer*>                    _campersHitDuringLastCarry;                        // 0x00A8(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_F8[0x10];                                      // 0x00F8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAttack(const struct FGameplayTag& GameEventType, const struct FGameEventData& GameEventData);
	void OnPickup(const struct FGameplayTag& GameEventType, const struct FGameEventData& GameEventData);
	void OnPostAttack(const struct FGameplayTag& GameEventType, const struct FGameEventData& GameEventData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SlasherHitsWhileCarryingTrackerComponent">();
	}
	static class USlasherHitsWhileCarryingTrackerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USlasherHitsWhileCarryingTrackerComponent>();
	}
};
static_assert(alignof(USlasherHitsWhileCarryingTrackerComponent) == 0x000008, "Wrong alignment on USlasherHitsWhileCarryingTrackerComponent");
static_assert(sizeof(USlasherHitsWhileCarryingTrackerComponent) == 0x000108, "Wrong size on USlasherHitsWhileCarryingTrackerComponent");
static_assert(offsetof(USlasherHitsWhileCarryingTrackerComponent, _campersHitDuringLastCarry) == 0x0000A8, "Member 'USlasherHitsWhileCarryingTrackerComponent::_campersHitDuringLastCarry' has a wrong offset!");

// Class DeadByDaylight.GeneratorRepairWithGenericPerksEscapeAchievement
// 0x0020 (0x00C8 - 0x00A8)
class UGeneratorRepairWithGenericPerksEscapeAchievement final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x20];                                      // 0x00A8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GeneratorRepairWithGenericPerksEscapeAchievement">();
	}
	static class UGeneratorRepairWithGenericPerksEscapeAchievement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGeneratorRepairWithGenericPerksEscapeAchievement>();
	}
};
static_assert(alignof(UGeneratorRepairWithGenericPerksEscapeAchievement) == 0x000008, "Wrong alignment on UGeneratorRepairWithGenericPerksEscapeAchievement");
static_assert(sizeof(UGeneratorRepairWithGenericPerksEscapeAchievement) == 0x0000C8, "Wrong size on UGeneratorRepairWithGenericPerksEscapeAchievement");

// Class DeadByDaylight.CharacterPositionRecorderConfigurator
// 0x0018 (0x00C8 - 0x00B0)
class UCharacterPositionRecorderConfigurator final : public UBaseHitValidationConfigurator
{
public:
	uint8                                         Pad_B0[0x18];                                      // 0x00B0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterPositionRecorderConfigurator">();
	}
	static class UCharacterPositionRecorderConfigurator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterPositionRecorderConfigurator>();
	}
};
static_assert(alignof(UCharacterPositionRecorderConfigurator) == 0x000008, "Wrong alignment on UCharacterPositionRecorderConfigurator");
static_assert(sizeof(UCharacterPositionRecorderConfigurator) == 0x0000C8, "Wrong size on UCharacterPositionRecorderConfigurator");

// Class DeadByDaylight.CharacterStatsHandlerComponent
// 0x0010 (0x00B8 - 0x00A8)
class UCharacterStatsHandlerComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x10];                                      // 0x00A8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializePreMatchStats();
	void OnGameEvent(const struct FGameplayTag& GameEventType, const struct FGameEventData& GameEventData);
	void ReceiveGameEvent(EDBDScoreTypes ScoreType, float Amount, class AActor* Instigator, class AActor* Target);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterStatsHandlerComponent">();
	}
	static class UCharacterStatsHandlerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterStatsHandlerComponent>();
	}
};
static_assert(alignof(UCharacterStatsHandlerComponent) == 0x000008, "Wrong alignment on UCharacterStatsHandlerComponent");
static_assert(sizeof(UCharacterStatsHandlerComponent) == 0x0000B8, "Wrong size on UCharacterStatsHandlerComponent");

// Class DeadByDaylight.GhostStealthUIData
// 0x0000 (0x0030 - 0x0030)
class IGhostStealthUIData final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GhostStealthUIData">();
	}
	static class IGhostStealthUIData* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGhostStealthUIData>();
	}
};
static_assert(alignof(IGhostStealthUIData) == 0x000008, "Wrong alignment on IGhostStealthUIData");
static_assert(sizeof(IGhostStealthUIData) == 0x000030, "Wrong size on IGhostStealthUIData");

// Class DeadByDaylight.DBDEditorActor
// 0x0000 (0x02A0 - 0x02A0)
class ADBDEditorActor : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDEditorActor">();
	}
	static class ADBDEditorActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDEditorActor>();
	}
};
static_assert(alignof(ADBDEditorActor) == 0x000008, "Wrong alignment on ADBDEditorActor");
static_assert(sizeof(ADBDEditorActor) == 0x0002A0, "Wrong size on ADBDEditorActor");

// Class DeadByDaylight.DBDRankDesignTunables
// 0x0030 (0x0060 - 0x0030)
class UDBDRankDesignTunables : public UObject
{
public:
	class UCurveFloat*                            UnbrokenTimeAlivePointsCurve;                      // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            EvaderStealthPointsByDistanceWhileKillerNotChasingCurve; // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            EvaderStealthPointsByDistanceWhileKillerIsChasingCurve; // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            EvaderChasePointsByDurationCurve;                  // 0x0048(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            EvaderZAxisDistanceScalingCurve;                   // 0x0050(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            ChaserChasePointsByDurationCurve;                  // 0x0058(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDRankDesignTunables">();
	}
	static class UDBDRankDesignTunables* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDRankDesignTunables>();
	}
};
static_assert(alignof(UDBDRankDesignTunables) == 0x000008, "Wrong alignment on UDBDRankDesignTunables");
static_assert(sizeof(UDBDRankDesignTunables) == 0x000060, "Wrong size on UDBDRankDesignTunables");
static_assert(offsetof(UDBDRankDesignTunables, UnbrokenTimeAlivePointsCurve) == 0x000030, "Member 'UDBDRankDesignTunables::UnbrokenTimeAlivePointsCurve' has a wrong offset!");
static_assert(offsetof(UDBDRankDesignTunables, EvaderStealthPointsByDistanceWhileKillerNotChasingCurve) == 0x000038, "Member 'UDBDRankDesignTunables::EvaderStealthPointsByDistanceWhileKillerNotChasingCurve' has a wrong offset!");
static_assert(offsetof(UDBDRankDesignTunables, EvaderStealthPointsByDistanceWhileKillerIsChasingCurve) == 0x000040, "Member 'UDBDRankDesignTunables::EvaderStealthPointsByDistanceWhileKillerIsChasingCurve' has a wrong offset!");
static_assert(offsetof(UDBDRankDesignTunables, EvaderChasePointsByDurationCurve) == 0x000048, "Member 'UDBDRankDesignTunables::EvaderChasePointsByDurationCurve' has a wrong offset!");
static_assert(offsetof(UDBDRankDesignTunables, EvaderZAxisDistanceScalingCurve) == 0x000050, "Member 'UDBDRankDesignTunables::EvaderZAxisDistanceScalingCurve' has a wrong offset!");
static_assert(offsetof(UDBDRankDesignTunables, ChaserChasePointsByDurationCurve) == 0x000058, "Member 'UDBDRankDesignTunables::ChaserChasePointsByDurationCurve' has a wrong offset!");

// Class DeadByDaylight.CharacterTool
// 0x0158 (0x03F8 - 0x02A0)
class ACharacterTool : public ADBDEditorActor
{
public:
	TArray<class ATargetPoint*>                   SpawnLocations;                                    // 0x02A0(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FCharacterToolData                     _customizationData;                                // 0x02B0(0x0080)(Edit, NativeAccessSpecifierPrivate)
	struct FCharacterToolSpawnParameters          _defaultSpawnParams;                               // 0x0330(0x0003)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_333[0x1];                                      // 0x0333(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   _powerSocket;                                      // 0x0334(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EAttachmentRule                               _powerAttachmentRule;                              // 0x0340(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _muteAudioInPIE;                                   // 0x0341(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isUsingGameSkeleton;                              // 0x0342(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_343[0x5];                                      // 0x0343(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   _overallLightingClass;                             // 0x0348(0x0038)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FNamedButton                           _showHelp;                                         // 0x0380(0x0018)(Edit, Transient, NativeAccessSpecifierPrivate)
	TMap<class ADBDMenuPlayer*, struct FCharacterToolSpawnParameters> _characters;                                       // 0x0398(0x0050)(Transient, NativeAccessSpecifierPrivate)
	class AActor*                                 _lighting;                                         // 0x03E8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3F0[0x8];                                      // 0x03F0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterTool">();
	}
	static class ACharacterTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACharacterTool>();
	}
};
static_assert(alignof(ACharacterTool) == 0x000008, "Wrong alignment on ACharacterTool");
static_assert(sizeof(ACharacterTool) == 0x0003F8, "Wrong size on ACharacterTool");
static_assert(offsetof(ACharacterTool, SpawnLocations) == 0x0002A0, "Member 'ACharacterTool::SpawnLocations' has a wrong offset!");
static_assert(offsetof(ACharacterTool, _customizationData) == 0x0002B0, "Member 'ACharacterTool::_customizationData' has a wrong offset!");
static_assert(offsetof(ACharacterTool, _defaultSpawnParams) == 0x000330, "Member 'ACharacterTool::_defaultSpawnParams' has a wrong offset!");
static_assert(offsetof(ACharacterTool, _powerSocket) == 0x000334, "Member 'ACharacterTool::_powerSocket' has a wrong offset!");
static_assert(offsetof(ACharacterTool, _powerAttachmentRule) == 0x000340, "Member 'ACharacterTool::_powerAttachmentRule' has a wrong offset!");
static_assert(offsetof(ACharacterTool, _muteAudioInPIE) == 0x000341, "Member 'ACharacterTool::_muteAudioInPIE' has a wrong offset!");
static_assert(offsetof(ACharacterTool, _isUsingGameSkeleton) == 0x000342, "Member 'ACharacterTool::_isUsingGameSkeleton' has a wrong offset!");
static_assert(offsetof(ACharacterTool, _overallLightingClass) == 0x000348, "Member 'ACharacterTool::_overallLightingClass' has a wrong offset!");
static_assert(offsetof(ACharacterTool, _showHelp) == 0x000380, "Member 'ACharacterTool::_showHelp' has a wrong offset!");
static_assert(offsetof(ACharacterTool, _characters) == 0x000398, "Member 'ACharacterTool::_characters' has a wrong offset!");
static_assert(offsetof(ACharacterTool, _lighting) == 0x0003E8, "Member 'ACharacterTool::_lighting' has a wrong offset!");

// Class DeadByDaylight.CharacterToolAnimation
// 0x0010 (0x0360 - 0x0350)
class UCharacterToolAnimation final : public UAnimInstance
{
public:
	TArray<struct FCharacterToolItemData>         SelectedItems;                                     // 0x0350(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterToolAnimation">();
	}
	static class UCharacterToolAnimation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterToolAnimation>();
	}
};
static_assert(alignof(UCharacterToolAnimation) == 0x000010, "Wrong alignment on UCharacterToolAnimation");
static_assert(sizeof(UCharacterToolAnimation) == 0x000360, "Wrong size on UCharacterToolAnimation");
static_assert(offsetof(UCharacterToolAnimation, SelectedItems) == 0x000350, "Member 'UCharacterToolAnimation::SelectedItems' has a wrong offset!");

// Class DeadByDaylight.PS4GRDKBaseProfileDAL
// 0x0000 (0x0088 - 0x0088)
class UPS4GRDKBaseProfileDAL : public UPlayerProfileDAL
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PS4GRDKBaseProfileDAL">();
	}
	static class UPS4GRDKBaseProfileDAL* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPS4GRDKBaseProfileDAL>();
	}
};
static_assert(alignof(UPS4GRDKBaseProfileDAL) == 0x000008, "Wrong alignment on UPS4GRDKBaseProfileDAL");
static_assert(sizeof(UPS4GRDKBaseProfileDAL) == 0x000088, "Wrong size on UPS4GRDKBaseProfileDAL");

// Class DeadByDaylight.CharacterUtilities
// 0x0000 (0x0030 - 0x0030)
class UCharacterUtilities final : public UBlueprintFunctionLibrary
{
public:
	static struct FVector GetActorLocationFromFeetLocation(const class ACharacter* Character, const struct FVector& FeetLocation);
	static struct FVector GetFeetPosition(const class ACharacter* Character);
	static struct FVector GetFeetPositionAtTargetLocation(const class ACharacter* Character, const struct FVector& Location);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterUtilities">();
	}
	static class UCharacterUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterUtilities>();
	}
};
static_assert(alignof(UCharacterUtilities) == 0x000008, "Wrong alignment on UCharacterUtilities");
static_assert(sizeof(UCharacterUtilities) == 0x000030, "Wrong size on UCharacterUtilities");

// Class DeadByDaylight.ChargeableComponent
// 0x0270 (0x0318 - 0x00A8)
class UChargeableComponent : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnInteractionEmptiedEvent;                         // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_B8[0x18];                                      // 0x00B8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnInteractionCompletionStateChanged;               // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_E0[0x18];                                      // 0x00E0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             SkillCheckResponseAestheticDelegate;               // 0x00F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             SkillCheckResponseAuthorityDelegate;               // 0x0108(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             ChargeAppliedAuthorityDelegate;                    // 0x0118(0x0010)(ZeroConstructor, Transient, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             ChargeableCompletionPercentChangeAuthorityDelegate; // 0x0128(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             ChargeableCompletionPercentChangeCosmeticDelegate; // 0x0138(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DechargeBeginDelegate;                             // 0x0148(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DechargeEndDelegate;                               // 0x0158(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          AllowSkillChecksAtFullCharge;                      // 0x0168(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_169[0x7];                                      // 0x0169(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ChargeableComponentID;                             // 0x0170(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DechargeDelay;                                     // 0x0180(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartingChargePercent;                             // 0x0184(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSpeedBasedNetSyncedValue              _currentCharge;                                    // 0x0188(0x0038)(Net, RepNotify, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1C0[0x10];                                     // 0x01C0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTimer                              _skillCheckFailurePenaltyTimer;                    // 0x01D0(0x0028)(Transient, NativeAccessSpecifierPrivate)
	struct FDBDTimer                              _dechargeTimer;                                    // 0x01F8(0x0028)(Transient, NativeAccessSpecifierPrivate)
	TArray<struct FChargeData>                    _chargesThisFrame;                                 // 0x0220(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<struct FChargeData>                    _redirectedChargesThisFrame;                       // 0x0230(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TMap<uint32, class UChargeStrategy*>          _activeChargeStrategies;                           // 0x0240(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TArray<class AActor*>                         _instigatorsSinceEmpty;                            // 0x0290(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TMap<class FName, float>                      _tunableValueMap;                                  // 0x02A0(0x0050)(Transient, NativeAccessSpecifierPrivate)
	bool                                          _isCharging;                                       // 0x02F0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2F1[0x7];                                      // 0x02F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 _playersWhoDidSkillCheck;                          // 0x02F8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	bool                                          _isChargeBlocked;                                  // 0x0308(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_309[0x3];                                      // 0x0309(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _dechargeRate;                                     // 0x030C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _enableAddCharge;                                  // 0x0310(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _enableSkillCheckFailurePenalty;                   // 0x0311(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isDecharging;                                     // 0x0312(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _stopDechargingWhenComplete;                       // 0x0313(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_314[0x4];                                      // 0x0314(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_AddCharge(float ChargeAmount, class AActor* Instigator, bool BypassSkillCheckFail, bool IsOneTimeIncrease, bool IsChargeWithItem);
	void Authority_AddChargePercent(float ChargePercent, class AActor* Instigator, bool BypassSkillCheckFail, bool IsOneTimeIncrease, bool IsChargeWithItem);
	void Authority_ApplyStartingCharge();
	void Authority_Reset();
	void Authority_SetEnableAddCharge(const bool Enable);
	void Authority_SetEnableSkillCheckFailurePenalty(const bool Enable);
	void IncreaseMaxCharge(float Percent);
	void Multicast_SetPermanentCharge(float ChargePercent);
	void OnCurrentChargeChanged(float Value);
	void OnRep_CurrentCharge();
	void SetDechargeRate(float DechargeRate);
	void SetSecondsToCharge(float SecondsToCharge);

	float GetChargeRemaining() const;
	float GetChargingSpeed() const;
	float GetCurrentCharge() const;
	float GetMaxCharge() const;
	float GetPercentComplete() const;
	float GetPermanentChargePercent() const;
	float GetPlayerCountPenaltyModifier(int32 PlayerCount) const;
	float GetTunableValue(class FName TunableValueID) const;
	bool HasPlayerDoneSkillCheck(int32 PlayerId) const;
	bool IsChargeComplete() const;
	bool IsSkillCheckTimePenaltyActive() const;
	void Multicast_OnCompleteChanged(bool COMPLETED) const;
	void Multicast_OnEmptied() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChargeableComponent">();
	}
	static class UChargeableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChargeableComponent>();
	}
};
static_assert(alignof(UChargeableComponent) == 0x000008, "Wrong alignment on UChargeableComponent");
static_assert(sizeof(UChargeableComponent) == 0x000318, "Wrong size on UChargeableComponent");
static_assert(offsetof(UChargeableComponent, OnInteractionEmptiedEvent) == 0x0000A8, "Member 'UChargeableComponent::OnInteractionEmptiedEvent' has a wrong offset!");
static_assert(offsetof(UChargeableComponent, OnInteractionCompletionStateChanged) == 0x0000D0, "Member 'UChargeableComponent::OnInteractionCompletionStateChanged' has a wrong offset!");
static_assert(offsetof(UChargeableComponent, SkillCheckResponseAestheticDelegate) == 0x0000F8, "Member 'UChargeableComponent::SkillCheckResponseAestheticDelegate' has a wrong offset!");
static_assert(offsetof(UChargeableComponent, SkillCheckResponseAuthorityDelegate) == 0x000108, "Member 'UChargeableComponent::SkillCheckResponseAuthorityDelegate' has a wrong offset!");
static_assert(offsetof(UChargeableComponent, ChargeAppliedAuthorityDelegate) == 0x000118, "Member 'UChargeableComponent::ChargeAppliedAuthorityDelegate' has a wrong offset!");
static_assert(offsetof(UChargeableComponent, ChargeableCompletionPercentChangeAuthorityDelegate) == 0x000128, "Member 'UChargeableComponent::ChargeableCompletionPercentChangeAuthorityDelegate' has a wrong offset!");
static_assert(offsetof(UChargeableComponent, ChargeableCompletionPercentChangeCosmeticDelegate) == 0x000138, "Member 'UChargeableComponent::ChargeableCompletionPercentChangeCosmeticDelegate' has a wrong offset!");
static_assert(offsetof(UChargeableComponent, DechargeBeginDelegate) == 0x000148, "Member 'UChargeableComponent::DechargeBeginDelegate' has a wrong offset!");
static_assert(offsetof(UChargeableComponent, DechargeEndDelegate) == 0x000158, "Member 'UChargeableComponent::DechargeEndDelegate' has a wrong offset!");
static_assert(offsetof(UChargeableComponent, AllowSkillChecksAtFullCharge) == 0x000168, "Member 'UChargeableComponent::AllowSkillChecksAtFullCharge' has a wrong offset!");
static_assert(offsetof(UChargeableComponent, ChargeableComponentID) == 0x000170, "Member 'UChargeableComponent::ChargeableComponentID' has a wrong offset!");
static_assert(offsetof(UChargeableComponent, DechargeDelay) == 0x000180, "Member 'UChargeableComponent::DechargeDelay' has a wrong offset!");
static_assert(offsetof(UChargeableComponent, StartingChargePercent) == 0x000184, "Member 'UChargeableComponent::StartingChargePercent' has a wrong offset!");
static_assert(offsetof(UChargeableComponent, _currentCharge) == 0x000188, "Member 'UChargeableComponent::_currentCharge' has a wrong offset!");
static_assert(offsetof(UChargeableComponent, _skillCheckFailurePenaltyTimer) == 0x0001D0, "Member 'UChargeableComponent::_skillCheckFailurePenaltyTimer' has a wrong offset!");
static_assert(offsetof(UChargeableComponent, _dechargeTimer) == 0x0001F8, "Member 'UChargeableComponent::_dechargeTimer' has a wrong offset!");
static_assert(offsetof(UChargeableComponent, _chargesThisFrame) == 0x000220, "Member 'UChargeableComponent::_chargesThisFrame' has a wrong offset!");
static_assert(offsetof(UChargeableComponent, _redirectedChargesThisFrame) == 0x000230, "Member 'UChargeableComponent::_redirectedChargesThisFrame' has a wrong offset!");
static_assert(offsetof(UChargeableComponent, _activeChargeStrategies) == 0x000240, "Member 'UChargeableComponent::_activeChargeStrategies' has a wrong offset!");
static_assert(offsetof(UChargeableComponent, _instigatorsSinceEmpty) == 0x000290, "Member 'UChargeableComponent::_instigatorsSinceEmpty' has a wrong offset!");
static_assert(offsetof(UChargeableComponent, _tunableValueMap) == 0x0002A0, "Member 'UChargeableComponent::_tunableValueMap' has a wrong offset!");
static_assert(offsetof(UChargeableComponent, _isCharging) == 0x0002F0, "Member 'UChargeableComponent::_isCharging' has a wrong offset!");
static_assert(offsetof(UChargeableComponent, _playersWhoDidSkillCheck) == 0x0002F8, "Member 'UChargeableComponent::_playersWhoDidSkillCheck' has a wrong offset!");
static_assert(offsetof(UChargeableComponent, _isChargeBlocked) == 0x000308, "Member 'UChargeableComponent::_isChargeBlocked' has a wrong offset!");
static_assert(offsetof(UChargeableComponent, _dechargeRate) == 0x00030C, "Member 'UChargeableComponent::_dechargeRate' has a wrong offset!");
static_assert(offsetof(UChargeableComponent, _enableAddCharge) == 0x000310, "Member 'UChargeableComponent::_enableAddCharge' has a wrong offset!");
static_assert(offsetof(UChargeableComponent, _enableSkillCheckFailurePenalty) == 0x000311, "Member 'UChargeableComponent::_enableSkillCheckFailurePenalty' has a wrong offset!");
static_assert(offsetof(UChargeableComponent, _isDecharging) == 0x000312, "Member 'UChargeableComponent::_isDecharging' has a wrong offset!");
static_assert(offsetof(UChargeableComponent, _stopDechargingWhenComplete) == 0x000313, "Member 'UChargeableComponent::_stopDechargingWhenComplete' has a wrong offset!");

// Class DeadByDaylight.StartupInitializerInterface
// 0x0000 (0x0030 - 0x0030)
class IStartupInitializerInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StartupInitializerInterface">();
	}
	static class IStartupInitializerInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IStartupInitializerInterface>();
	}
};
static_assert(alignof(IStartupInitializerInterface) == 0x000008, "Wrong alignment on IStartupInitializerInterface");
static_assert(sizeof(IStartupInitializerInterface) == 0x000030, "Wrong size on IStartupInitializerInterface");

// Class DeadByDaylight.ChargedAttackStateComponent
// 0x0008 (0x00B0 - 0x00A8)
class UChargedAttackStateComponent : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetChargingPercent(float ChargePercent);
	void SetIsCharging(bool IsCharging);

	float GetChargingPercent() const;
	bool GetIsCharging() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChargedAttackStateComponent">();
	}
	static class UChargedAttackStateComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChargedAttackStateComponent>();
	}
};
static_assert(alignof(UChargedAttackStateComponent) == 0x000008, "Wrong alignment on UChargedAttackStateComponent");
static_assert(sizeof(UChargedAttackStateComponent) == 0x0000B0, "Wrong size on UChargedAttackStateComponent");

// Class DeadByDaylight.HasTokenAndIsApplicableOrActivationTimerElapsedIconStrategy
// 0x0000 (0x0038 - 0x0038)
class UHasTokenAndIsApplicableOrActivationTimerElapsedIconStrategy final : public UBasePerkIconStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HasTokenAndIsApplicableOrActivationTimerElapsedIconStrategy">();
	}
	static class UHasTokenAndIsApplicableOrActivationTimerElapsedIconStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHasTokenAndIsApplicableOrActivationTimerElapsedIconStrategy>();
	}
};
static_assert(alignof(UHasTokenAndIsApplicableOrActivationTimerElapsedIconStrategy) == 0x000008, "Wrong alignment on UHasTokenAndIsApplicableOrActivationTimerElapsedIconStrategy");
static_assert(sizeof(UHasTokenAndIsApplicableOrActivationTimerElapsedIconStrategy) == 0x000038, "Wrong size on UHasTokenAndIsApplicableOrActivationTimerElapsedIconStrategy");

// Class DeadByDaylight.StalkedComponent
// 0x0078 (0x0120 - 0x00A8)
class UStalkedComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnBeingStalkedChanged;                             // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         _maxStalkPoints;                                   // 0x00B8(0x0004)(Edit, Net, ZeroConstructor, EditConst, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _stalkableWhileSightingStalker;                    // 0x00BC(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isBeingStalked;                                   // 0x00BD(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_BE[0x2];                                       // 0x00BE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class UChargeableComponent*                   _stalkPointsChargeable;                            // 0x00C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C8[0x58];                                      // 0x00C8(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnBeingStalkedChanged__DelegateSignature(bool IsBeingStalked);
	void OnRep_IsBeingStalked();
	void OnRep_MaxStalkPoints();

	bool HasStalkPoints() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StalkedComponent">();
	}
	static class UStalkedComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStalkedComponent>();
	}
};
static_assert(alignof(UStalkedComponent) == 0x000008, "Wrong alignment on UStalkedComponent");
static_assert(sizeof(UStalkedComponent) == 0x000120, "Wrong size on UStalkedComponent");
static_assert(offsetof(UStalkedComponent, OnBeingStalkedChanged) == 0x0000A8, "Member 'UStalkedComponent::OnBeingStalkedChanged' has a wrong offset!");
static_assert(offsetof(UStalkedComponent, _maxStalkPoints) == 0x0000B8, "Member 'UStalkedComponent::_maxStalkPoints' has a wrong offset!");
static_assert(offsetof(UStalkedComponent, _stalkableWhileSightingStalker) == 0x0000BC, "Member 'UStalkedComponent::_stalkableWhileSightingStalker' has a wrong offset!");
static_assert(offsetof(UStalkedComponent, _isBeingStalked) == 0x0000BD, "Member 'UStalkedComponent::_isBeingStalked' has a wrong offset!");
static_assert(offsetof(UStalkedComponent, _stalkPointsChargeable) == 0x0000C0, "Member 'UStalkedComponent::_stalkPointsChargeable' has a wrong offset!");

// Class DeadByDaylight.ChargerComponent
// 0x0098 (0x0140 - 0x00A8)
class UChargerComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ChargerComponentID;                                // 0x00B0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnChargeStateChange;                               // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnChargePercentChange;                             // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_E0[0x30];                                      // 0x00E0(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	EEnergyTypeEnum                               EnergyType;                                        // 0x0110(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_111[0x3];                                      // 0x0111(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _currentEnergyLevel;                               // 0x0114(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _maxEnergyLevel;                                   // 0x0118(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_11C[0x24];                                     // 0x011C(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_EnergyLevel(float PreviousEnergyLevel);
	void Reset();
	void SetEnergyLevel(float EnergyLevel);
	void SetMaxEnergyLevel(float EnergyLevel);
	void SetNormalizedEnergyLevel(float EnergyLevel);
	void UseEnergy(float Seconds, float EnergyUseModifier);

	float GetEnergyLevel() const;
	float GetMaxEnergyLevel() const;
	float GetNormalizedEnergyLevel() const;
	bool HasCharge() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChargerComponent">();
	}
	static class UChargerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChargerComponent>();
	}
};
static_assert(alignof(UChargerComponent) == 0x000008, "Wrong alignment on UChargerComponent");
static_assert(sizeof(UChargerComponent) == 0x000140, "Wrong size on UChargerComponent");
static_assert(offsetof(UChargerComponent, ChargerComponentID) == 0x0000B0, "Member 'UChargerComponent::ChargerComponentID' has a wrong offset!");
static_assert(offsetof(UChargerComponent, OnChargeStateChange) == 0x0000C0, "Member 'UChargerComponent::OnChargeStateChange' has a wrong offset!");
static_assert(offsetof(UChargerComponent, OnChargePercentChange) == 0x0000D0, "Member 'UChargerComponent::OnChargePercentChange' has a wrong offset!");
static_assert(offsetof(UChargerComponent, EnergyType) == 0x000110, "Member 'UChargerComponent::EnergyType' has a wrong offset!");
static_assert(offsetof(UChargerComponent, _currentEnergyLevel) == 0x000114, "Member 'UChargerComponent::_currentEnergyLevel' has a wrong offset!");
static_assert(offsetof(UChargerComponent, _maxEnergyLevel) == 0x000118, "Member 'UChargerComponent::_maxEnergyLevel' has a wrong offset!");

// Class DeadByDaylight.SlasherStunnableComponent
// 0x0040 (0x00E8 - 0x00A8)
class USlasherStunnableComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x40];                                      // 0x00A8(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Server_NotifyStunHasBeenProcessed();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SlasherStunnableComponent">();
	}
	static class USlasherStunnableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USlasherStunnableComponent>();
	}
};
static_assert(alignof(USlasherStunnableComponent) == 0x000008, "Wrong alignment on USlasherStunnableComponent");
static_assert(sizeof(USlasherStunnableComponent) == 0x0000E8, "Wrong size on USlasherStunnableComponent");

// Class DeadByDaylight.ChargeStrategy
// 0x0018 (0x0048 - 0x0030)
class UChargeStrategy final : public UObject
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _shouldApplyRedirectedChargeNormally;              // 0x0040(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _shouldBroadcastChargeApplied;                     // 0x0041(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _shouldApplyModifiersToRedirectedCharge;           // 0x0042(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _shouldAllowChargeFromItem;                        // 0x0043(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _shouldRedirectSkillcheckChargePenalty;            // 0x0044(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChargeStrategy">();
	}
	static class UChargeStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChargeStrategy>();
	}
};
static_assert(alignof(UChargeStrategy) == 0x000008, "Wrong alignment on UChargeStrategy");
static_assert(sizeof(UChargeStrategy) == 0x000048, "Wrong size on UChargeStrategy");
static_assert(offsetof(UChargeStrategy, _shouldApplyRedirectedChargeNormally) == 0x000040, "Member 'UChargeStrategy::_shouldApplyRedirectedChargeNormally' has a wrong offset!");
static_assert(offsetof(UChargeStrategy, _shouldBroadcastChargeApplied) == 0x000041, "Member 'UChargeStrategy::_shouldBroadcastChargeApplied' has a wrong offset!");
static_assert(offsetof(UChargeStrategy, _shouldApplyModifiersToRedirectedCharge) == 0x000042, "Member 'UChargeStrategy::_shouldApplyModifiersToRedirectedCharge' has a wrong offset!");
static_assert(offsetof(UChargeStrategy, _shouldAllowChargeFromItem) == 0x000043, "Member 'UChargeStrategy::_shouldAllowChargeFromItem' has a wrong offset!");
static_assert(offsetof(UChargeStrategy, _shouldRedirectSkillcheckChargePenalty) == 0x000044, "Member 'UChargeStrategy::_shouldRedirectSkillcheckChargePenalty' has a wrong offset!");

// Class DeadByDaylight.CharmAttachable
// 0x0000 (0x0030 - 0x0030)
class ICharmAttachable final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharmAttachable">();
	}
	static class ICharmAttachable* GetDefaultObj()
	{
		return GetDefaultObjImpl<ICharmAttachable>();
	}
};
static_assert(alignof(ICharmAttachable) == 0x000008, "Wrong alignment on ICharmAttachable");
static_assert(sizeof(ICharmAttachable) == 0x000030, "Wrong size on ICharmAttachable");

// Class DeadByDaylight.ExposerInteriorZoneComponent
// 0x0010 (0x05E0 - 0x05D0)
class UExposerInteriorZoneComponent final : public UBoxComponent
{
public:
	TArray<class USceneComponent*>                ExposerSpawnPoints;                                // 0x05D0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	void AddExposerSpawnPoint(class USceneComponent* Point);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExposerInteriorZoneComponent">();
	}
	static class UExposerInteriorZoneComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UExposerInteriorZoneComponent>();
	}
};
static_assert(alignof(UExposerInteriorZoneComponent) == 0x000010, "Wrong alignment on UExposerInteriorZoneComponent");
static_assert(sizeof(UExposerInteriorZoneComponent) == 0x0005E0, "Wrong size on UExposerInteriorZoneComponent");
static_assert(offsetof(UExposerInteriorZoneComponent, ExposerSpawnPoints) == 0x0005D0, "Member 'UExposerInteriorZoneComponent::ExposerSpawnPoints' has a wrong offset!");

// Class DeadByDaylight.CharmSpawnerComponent
// 0x0040 (0x00E8 - 0x00A8)
class UCharmSpawnerComponent final : public UActorComponent
{
public:
	class FName                                   SocketRootName;                                    // 0x00A8(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B4[0x4];                                       // 0x00B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCharmSlot>                     CharmSlots;                                        // 0x00B8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FVector                                ScaleCharm;                                        // 0x00C8(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _forcedLOD;                                        // 0x00E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E4[0x4];                                       // 0x00E4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ReplaceCharmTextures(const TArray<struct FCharmIdSlot>& Customization);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharmSpawnerComponent">();
	}
	static class UCharmSpawnerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharmSpawnerComponent>();
	}
};
static_assert(alignof(UCharmSpawnerComponent) == 0x000008, "Wrong alignment on UCharmSpawnerComponent");
static_assert(sizeof(UCharmSpawnerComponent) == 0x0000E8, "Wrong size on UCharmSpawnerComponent");
static_assert(offsetof(UCharmSpawnerComponent, SocketRootName) == 0x0000A8, "Member 'UCharmSpawnerComponent::SocketRootName' has a wrong offset!");
static_assert(offsetof(UCharmSpawnerComponent, CharmSlots) == 0x0000B8, "Member 'UCharmSpawnerComponent::CharmSlots' has a wrong offset!");
static_assert(offsetof(UCharmSpawnerComponent, ScaleCharm) == 0x0000C8, "Member 'UCharmSpawnerComponent::ScaleCharm' has a wrong offset!");
static_assert(offsetof(UCharmSpawnerComponent, _forcedLOD) == 0x0000E0, "Member 'UCharmSpawnerComponent::_forcedLOD' has a wrong offset!");

// Class DeadByDaylight.ChaseeCharacterComponent
// 0x0068 (0x0198 - 0x0130)
class UChaseeCharacterComponent final : public UChaseComponent
{
public:
	uint8                                         Pad_130[0x8];                                      // 0x0130(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _totalChaseTimeThisMatchDebugReplicated;           // 0x0138(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_13C[0x5C];                                     // 0x013C(0x005C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnGeneratorPercentChanged(class UChargeableComponent* ChargeableComponent, float PercentCompletionChange, float TotalPercentComplete);
	void Authority_OnLevelReadyToPlay();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChaseeCharacterComponent">();
	}
	static class UChaseeCharacterComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChaseeCharacterComponent>();
	}
};
static_assert(alignof(UChaseeCharacterComponent) == 0x000008, "Wrong alignment on UChaseeCharacterComponent");
static_assert(sizeof(UChaseeCharacterComponent) == 0x000198, "Wrong size on UChaseeCharacterComponent");
static_assert(offsetof(UChaseeCharacterComponent, _totalChaseTimeThisMatchDebugReplicated) == 0x000138, "Member 'UChaseeCharacterComponent::_totalChaseTimeThisMatchDebugReplicated' has a wrong offset!");

// Class DeadByDaylight.FearMarketManager
// 0x00E0 (0x0110 - 0x0030)
class UFearMarketManager final : public UObject
{
public:
	struct FFearMarketItemInstance                PendingPurchaseFearMarketItem;                     // 0x0030(0x0030)(NativeAccessSpecifierPublic)
	uint8                                         Pad_60[0x48];                                      // 0x0060(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFearMarketOfferingInstance            _existingFearMarket;                               // 0x00A8(0x0020)(NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class UDBDGameInstance>        _gameInstance;                                     // 0x00C8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D0[0x40];                                      // 0x00D0(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ReceivedFearMarketData(bool Success);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FearMarketManager">();
	}
	static class UFearMarketManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFearMarketManager>();
	}
};
static_assert(alignof(UFearMarketManager) == 0x000008, "Wrong alignment on UFearMarketManager");
static_assert(sizeof(UFearMarketManager) == 0x000110, "Wrong size on UFearMarketManager");
static_assert(offsetof(UFearMarketManager, PendingPurchaseFearMarketItem) == 0x000030, "Member 'UFearMarketManager::PendingPurchaseFearMarketItem' has a wrong offset!");
static_assert(offsetof(UFearMarketManager, _existingFearMarket) == 0x0000A8, "Member 'UFearMarketManager::_existingFearMarket' has a wrong offset!");
static_assert(offsetof(UFearMarketManager, _gameInstance) == 0x0000C8, "Member 'UFearMarketManager::_gameInstance' has a wrong offset!");

// Class DeadByDaylight.ChunkingManager
// 0x0058 (0x0088 - 0x0030)
class UChunkingManager final : public UObject
{
public:
	uint8                                         Pad_30[0x18];                                      // 0x0030(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UDBDGameInstance*                       _gameInstance;                                     // 0x0048(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_50[0x38];                                      // 0x0050(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChunkingManager">();
	}
	static class UChunkingManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChunkingManager>();
	}
};
static_assert(alignof(UChunkingManager) == 0x000008, "Wrong alignment on UChunkingManager");
static_assert(sizeof(UChunkingManager) == 0x000088, "Wrong size on UChunkingManager");
static_assert(offsetof(UChunkingManager, _gameInstance) == 0x000048, "Member 'UChunkingManager::_gameInstance' has a wrong offset!");

// Class DeadByDaylight.FeatureGateHelper
// 0x0000 (0x0030 - 0x0030)
class UFeatureGateHelper final : public UObject
{
public:
	static bool GetAll(const class UObject* ContextObject, TArray<struct FDBDFeatureLockProgress>* OutData);
	static bool GetAllByLockState(const class UObject* ContextObject, TArray<struct FDBDFeatureLockProgress>* OutData, bool Locked);
	static bool GetAllByRole(const class UObject* ContextObject, TArray<struct FDBDFeatureLockProgress>* OutData, EPlayerRole Role);
	static bool GetAllBySeenState(const class UObject* ContextObject, TArray<struct FDBDFeatureLockProgress>* OutData, bool Param_WasSeen);
	static bool GetSingle(const class UObject* ContextObject, struct FDBDFeatureLockProgress* OutData, EDBDFeatureType FeatureType, EPlayerRole Role);
	static bool IsEnabled(const class UObject* ContextObject);
	static bool IsLocked(const class UObject* ContextObject, EDBDFeatureType FeatureType, EPlayerRole Role);
	static bool WasSeen(const class UObject* ContextObject, EDBDFeatureType FeatureType, EPlayerRole Role);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FeatureGateHelper">();
	}
	static class UFeatureGateHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFeatureGateHelper>();
	}
};
static_assert(alignof(UFeatureGateHelper) == 0x000008, "Wrong alignment on UFeatureGateHelper");
static_assert(sizeof(UFeatureGateHelper) == 0x000030, "Wrong size on UFeatureGateHelper");

// Class DeadByDaylight.ClientBloodwebContentAdapter
// 0x0010 (0x0068 - 0x0058)
class UClientBloodwebContentAdapter final : public UBaseBloodwebContentAdapter
{
public:
	class UBloodwebGenerator*                     _bloodwebBuilder;                                  // 0x0058(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_60[0x8];                                       // 0x0060(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClientBloodwebContentAdapter">();
	}
	static class UClientBloodwebContentAdapter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UClientBloodwebContentAdapter>();
	}
};
static_assert(alignof(UClientBloodwebContentAdapter) == 0x000008, "Wrong alignment on UClientBloodwebContentAdapter");
static_assert(sizeof(UClientBloodwebContentAdapter) == 0x000068, "Wrong size on UClientBloodwebContentAdapter");
static_assert(offsetof(UClientBloodwebContentAdapter, _bloodwebBuilder) == 0x000058, "Member 'UClientBloodwebContentAdapter::_bloodwebBuilder' has a wrong offset!");

// Class DeadByDaylight.ClipManager
// 0x0168 (0x0408 - 0x02A0)
class AClipManager final : public AActor
{
public:
	TArray<class UDBDClipRegionComponent*>        _clippingZones;                                    // 0x02A0(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TSet<class UMeshComponent*>                   _meshComponents;                                   // 0x02B0(0x0050)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FMaterialOriginalState>         _dissolvedMeshes;                                  // 0x0300(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TMap<class UMaterialInterface*, class UMaterialInterface*> _normal2dissolve;                                  // 0x0310(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMap<class UMaterialInterface*, struct FStaticMeshesArrayForClip> _normal2dissolveStaticMeshes;                      // 0x0360(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMap<class UMaterialInterface*, class UMaterialInterface*> _dissolve2normal;                                  // 0x03B0(0x0050)(Transient, NativeAccessSpecifierPrivate)
	class UDataTable*                             _sphericalDissolveMaterials;                       // 0x0400(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void RemoveDissolveMaterials();
	void SphericalDissolveAt(const struct FVector& Location, float Radius);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClipManager">();
	}
	static class AClipManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AClipManager>();
	}
};
static_assert(alignof(AClipManager) == 0x000008, "Wrong alignment on AClipManager");
static_assert(sizeof(AClipManager) == 0x000408, "Wrong size on AClipManager");
static_assert(offsetof(AClipManager, _clippingZones) == 0x0002A0, "Member 'AClipManager::_clippingZones' has a wrong offset!");
static_assert(offsetof(AClipManager, _meshComponents) == 0x0002B0, "Member 'AClipManager::_meshComponents' has a wrong offset!");
static_assert(offsetof(AClipManager, _dissolvedMeshes) == 0x000300, "Member 'AClipManager::_dissolvedMeshes' has a wrong offset!");
static_assert(offsetof(AClipManager, _normal2dissolve) == 0x000310, "Member 'AClipManager::_normal2dissolve' has a wrong offset!");
static_assert(offsetof(AClipManager, _normal2dissolveStaticMeshes) == 0x000360, "Member 'AClipManager::_normal2dissolveStaticMeshes' has a wrong offset!");
static_assert(offsetof(AClipManager, _dissolve2normal) == 0x0003B0, "Member 'AClipManager::_dissolve2normal' has a wrong offset!");
static_assert(offsetof(AClipManager, _sphericalDissolveMaterials) == 0x000400, "Member 'AClipManager::_sphericalDissolveMaterials' has a wrong offset!");

// Class DeadByDaylight.FoliageActor
// 0x0008 (0x02A8 - 0x02A0)
class AFoliageActor final : public AActor
{
public:
	class UFoliageDensityHISM*                    _foliageHISM;                                      // 0x02A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FoliageActor">();
	}
	static class AFoliageActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFoliageActor>();
	}
};
static_assert(alignof(AFoliageActor) == 0x000008, "Wrong alignment on AFoliageActor");
static_assert(sizeof(AFoliageActor) == 0x0002A8, "Wrong size on AFoliageActor");
static_assert(offsetof(AFoliageActor, _foliageHISM) == 0x0002A0, "Member 'AFoliageActor::_foliageHISM' has a wrong offset!");

// Class DeadByDaylight.StandDisplayable
// 0x0000 (0x0030 - 0x0030)
class IStandDisplayable final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StandDisplayable">();
	}
	static class IStandDisplayable* GetDefaultObj()
	{
		return GetDefaultObjImpl<IStandDisplayable>();
	}
};
static_assert(alignof(IStandDisplayable) == 0x000008, "Wrong alignment on IStandDisplayable");
static_assert(sizeof(IStandDisplayable) == 0x000030, "Wrong size on IStandDisplayable");

// Class DeadByDaylight.CollectableCollection
// 0x0048 (0x00F0 - 0x00A8)
class UCollectableCollection final : public UActorComponent
{
public:
	TArray<class ACollectable*>                   _collectables;                                     // 0x00A8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B8[0x38];                                      // 0x00B8(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CollectableCollection">();
	}
	static class UCollectableCollection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCollectableCollection>();
	}
};
static_assert(alignof(UCollectableCollection) == 0x000008, "Wrong alignment on UCollectableCollection");
static_assert(sizeof(UCollectableCollection) == 0x0000F0, "Wrong size on UCollectableCollection");
static_assert(offsetof(UCollectableCollection, _collectables) == 0x0000A8, "Member 'UCollectableCollection::_collectables' has a wrong offset!");

// Class DeadByDaylight.CombinedPartyFriendFacade
// 0x0138 (0x0168 - 0x0030)
class UCombinedPartyFriendFacade final : public UObject
{
public:
	uint8                                         Pad_30[0x138];                                     // 0x0030(0x0138)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CombinedPartyFriendFacade">();
	}
	static class UCombinedPartyFriendFacade* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCombinedPartyFriendFacade>();
	}
};
static_assert(alignof(UCombinedPartyFriendFacade) == 0x000008, "Wrong alignment on UCombinedPartyFriendFacade");
static_assert(sizeof(UCombinedPartyFriendFacade) == 0x000168, "Wrong size on UCombinedPartyFriendFacade");

// Class DeadByDaylight.StatusEffectCollectionComponent
// 0x0038 (0x00E0 - 0x00A8)
class UStatusEffectCollectionComponent final : public UActorComponent
{
public:
	TArray<class UStatusEffect*>                  _array;                                            // 0x00A8(0x0010)(ExportObject, Net, ZeroConstructor, Transient, RepNotify, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UStatusEffect*>                  _local_oldArray;                                   // 0x00B8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C8[0x18];                                      // 0x00C8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_Array();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StatusEffectCollectionComponent">();
	}
	static class UStatusEffectCollectionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStatusEffectCollectionComponent>();
	}
};
static_assert(alignof(UStatusEffectCollectionComponent) == 0x000008, "Wrong alignment on UStatusEffectCollectionComponent");
static_assert(sizeof(UStatusEffectCollectionComponent) == 0x0000E0, "Wrong size on UStatusEffectCollectionComponent");
static_assert(offsetof(UStatusEffectCollectionComponent, _array) == 0x0000A8, "Member 'UStatusEffectCollectionComponent::_array' has a wrong offset!");
static_assert(offsetof(UStatusEffectCollectionComponent, _local_oldArray) == 0x0000B8, "Member 'UStatusEffectCollectionComponent::_local_oldArray' has a wrong offset!");

// Class DeadByDaylight.CombinedSpecialEventDataUtilities
// 0x0000 (0x0030 - 0x0030)
class UCombinedSpecialEventDataUtilities final : public UBlueprintFunctionLibrary
{
public:
	static class FName GetSpecialMusicState(const struct FCombinedSpecialEventData& Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CombinedSpecialEventDataUtilities">();
	}
	static class UCombinedSpecialEventDataUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCombinedSpecialEventDataUtilities>();
	}
};
static_assert(alignof(UCombinedSpecialEventDataUtilities) == 0x000008, "Wrong alignment on UCombinedSpecialEventDataUtilities");
static_assert(sizeof(UCombinedSpecialEventDataUtilities) == 0x000030, "Wrong size on UCombinedSpecialEventDataUtilities");

// Class DeadByDaylight.ChainLinkable
// 0x0000 (0x0030 - 0x0030)
class IChainLinkable final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChainLinkable">();
	}
	static class IChainLinkable* GetDefaultObj()
	{
		return GetDefaultObjImpl<IChainLinkable>();
	}
};
static_assert(alignof(IChainLinkable) == 0x000008, "Wrong alignment on IChainLinkable");
static_assert(sizeof(IChainLinkable) == 0x000030, "Wrong size on IChainLinkable");

// Class DeadByDaylight.CommentatorActorInterface
// 0x0000 (0x0030 - 0x0030)
class ICommentatorActorInterface final : public IInterface
{
public:
	void OnAudioEnded();
	void OnAudioStarted();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommentatorActorInterface">();
	}
	static class ICommentatorActorInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ICommentatorActorInterface>();
	}
};
static_assert(alignof(ICommentatorActorInterface) == 0x000008, "Wrong alignment on ICommentatorActorInterface");
static_assert(sizeof(ICommentatorActorInterface) == 0x000030, "Wrong size on ICommentatorActorInterface");

// Class DeadByDaylight.CompetenceOperation
// 0x0028 (0x0058 - 0x0030)
class UCompetenceOperation final : public UObject
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UEventDrivenModifierCondition> _conditionClass;                                   // 0x0038(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEventDrivenModifierCondition*          _condition;                                        // 0x0040(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UCompetenceAction*>              _actions;                                          // 0x0048(0x0010)(Edit, ExportObject, Net, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CompetenceOperation">();
	}
	static class UCompetenceOperation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCompetenceOperation>();
	}
};
static_assert(alignof(UCompetenceOperation) == 0x000008, "Wrong alignment on UCompetenceOperation");
static_assert(sizeof(UCompetenceOperation) == 0x000058, "Wrong size on UCompetenceOperation");
static_assert(offsetof(UCompetenceOperation, _conditionClass) == 0x000038, "Member 'UCompetenceOperation::_conditionClass' has a wrong offset!");
static_assert(offsetof(UCompetenceOperation, _condition) == 0x000040, "Member 'UCompetenceOperation::_condition' has a wrong offset!");
static_assert(offsetof(UCompetenceOperation, _actions) == 0x000048, "Member 'UCompetenceOperation::_actions' has a wrong offset!");

// Class DeadByDaylight.ConeAroundDirectionCameraStrategy
// 0x0038 (0x0068 - 0x0030)
class UConeAroundDirectionCameraStrategy final : public UObject
{
public:
	uint8                                         Pad_30[0x28];                                      // 0x0030(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _maxPitchDifference;                               // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _maxYawDifference;                                 // 0x005C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _maxRollDifference;                                // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConeAroundDirectionCameraStrategy">();
	}
	static class UConeAroundDirectionCameraStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConeAroundDirectionCameraStrategy>();
	}
};
static_assert(alignof(UConeAroundDirectionCameraStrategy) == 0x000008, "Wrong alignment on UConeAroundDirectionCameraStrategy");
static_assert(sizeof(UConeAroundDirectionCameraStrategy) == 0x000068, "Wrong size on UConeAroundDirectionCameraStrategy");
static_assert(offsetof(UConeAroundDirectionCameraStrategy, _maxPitchDifference) == 0x000058, "Member 'UConeAroundDirectionCameraStrategy::_maxPitchDifference' has a wrong offset!");
static_assert(offsetof(UConeAroundDirectionCameraStrategy, _maxYawDifference) == 0x00005C, "Member 'UConeAroundDirectionCameraStrategy::_maxYawDifference' has a wrong offset!");
static_assert(offsetof(UConeAroundDirectionCameraStrategy, _maxRollDifference) == 0x000060, "Member 'UConeAroundDirectionCameraStrategy::_maxRollDifference' has a wrong offset!");

// Class DeadByDaylight.MovementSettings
// 0x0000 (0x0030 - 0x0030)
class IMovementSettings final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovementSettings">();
	}
	static class IMovementSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<IMovementSettings>();
	}
};
static_assert(alignof(IMovementSettings) == 0x000008, "Wrong alignment on IMovementSettings");
static_assert(sizeof(IMovementSettings) == 0x000030, "Wrong size on IMovementSettings");

// Class DeadByDaylight.ConnectionStatusSubsystem
// 0x00E0 (0x0118 - 0x0038)
class UConnectionStatusSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0xE0];                                      // 0x0038(0x00E0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConnectionStatusSubsystem">();
	}
	static class UConnectionStatusSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConnectionStatusSubsystem>();
	}
};
static_assert(alignof(UConnectionStatusSubsystem) == 0x000008, "Wrong alignment on UConnectionStatusSubsystem");
static_assert(sizeof(UConnectionStatusSubsystem) == 0x000118, "Wrong size on UConnectionStatusSubsystem");

// Class DeadByDaylight.ConstrainAspectRatioComponent
// 0x00B8 (0x0160 - 0x00A8)
class UConstrainAspectRatioComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0xB8];                                      // 0x00A8(0x00B8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DBD_ToggleBlackBars(int32 Option);
	void OnIntroCompleted();
	void SetCinematicMode(bool CinematicMode);

	struct FIntPoint GetCameraConstrainedViewSize() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConstrainAspectRatioComponent">();
	}
	static class UConstrainAspectRatioComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConstrainAspectRatioComponent>();
	}
};
static_assert(alignof(UConstrainAspectRatioComponent) == 0x000008, "Wrong alignment on UConstrainAspectRatioComponent");
static_assert(sizeof(UConstrainAspectRatioComponent) == 0x000160, "Wrong size on UConstrainAspectRatioComponent");

// Class DeadByDaylight.InGameAssetPreloaderComponent
// 0x01A8 (0x0250 - 0x00A8)
class UInGameAssetPreloaderComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x18];                                      // 0x00A8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<struct FPrimaryAssetId>                  _generalPrimaryAssetIds;                           // 0x00C0(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TSet<TSoftClassPtr<class UClass>>             _generalRegularAssets;                             // 0x0110(0x0050)(Edit, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<TSubclassOf<class UInGameAssetPreloaderGatherer>> _assetGathererClasses;                             // 0x0160(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<class UInGameAssetPreloaderGatherer*>  _assetGatherers;                                   // 0x0170(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_180[0xD0];                                     // 0x0180(0x00D0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InGameAssetPreloaderComponent">();
	}
	static class UInGameAssetPreloaderComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInGameAssetPreloaderComponent>();
	}
};
static_assert(alignof(UInGameAssetPreloaderComponent) == 0x000008, "Wrong alignment on UInGameAssetPreloaderComponent");
static_assert(sizeof(UInGameAssetPreloaderComponent) == 0x000250, "Wrong size on UInGameAssetPreloaderComponent");
static_assert(offsetof(UInGameAssetPreloaderComponent, _generalPrimaryAssetIds) == 0x0000C0, "Member 'UInGameAssetPreloaderComponent::_generalPrimaryAssetIds' has a wrong offset!");
static_assert(offsetof(UInGameAssetPreloaderComponent, _generalRegularAssets) == 0x000110, "Member 'UInGameAssetPreloaderComponent::_generalRegularAssets' has a wrong offset!");
static_assert(offsetof(UInGameAssetPreloaderComponent, _assetGathererClasses) == 0x000160, "Member 'UInGameAssetPreloaderComponent::_assetGathererClasses' has a wrong offset!");
static_assert(offsetof(UInGameAssetPreloaderComponent, _assetGatherers) == 0x000170, "Member 'UInGameAssetPreloaderComponent::_assetGatherers' has a wrong offset!");

// Class DeadByDaylight.StoreDisplayStandController
// 0x0020 (0x0200 - 0x01E0)
class UStoreDisplayStandController final : public UDisplayStandController
{
public:
	uint8                                         Pad_1E0[0x20];                                     // 0x01E0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StoreDisplayStandController">();
	}
	static class UStoreDisplayStandController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStoreDisplayStandController>();
	}
};
static_assert(alignof(UStoreDisplayStandController) == 0x000008, "Wrong alignment on UStoreDisplayStandController");
static_assert(sizeof(UStoreDisplayStandController) == 0x000200, "Wrong size on UStoreDisplayStandController");

// Class DeadByDaylight.ContentScheduleManager
// 0x0110 (0x0140 - 0x0030)
class UContentScheduleManager final : public UObject
{
public:
	uint8                                         Pad_30[0x108];                                     // 0x0030(0x0108)(Fixing Size After Last Property [ Dumper-7 ])
	class UObjectLibrary*                         _availableMapLibrary;                              // 0x0138(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ContentScheduleManager">();
	}
	static class UContentScheduleManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UContentScheduleManager>();
	}
};
static_assert(alignof(UContentScheduleManager) == 0x000008, "Wrong alignment on UContentScheduleManager");
static_assert(sizeof(UContentScheduleManager) == 0x000140, "Wrong size on UContentScheduleManager");
static_assert(offsetof(UContentScheduleManager, _availableMapLibrary) == 0x000138, "Member 'UContentScheduleManager::_availableMapLibrary' has a wrong offset!");

// Class DeadByDaylight.ContentVersionManager
// 0x00B8 (0x00F0 - 0x0038)
class UContentVersionManager final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0xB8];                                      // 0x0038(0x00B8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ContentVersionManager">();
	}
	static class UContentVersionManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UContentVersionManager>();
	}
};
static_assert(alignof(UContentVersionManager) == 0x000008, "Wrong alignment on UContentVersionManager");
static_assert(sizeof(UContentVersionManager) == 0x0000F0, "Wrong size on UContentVersionManager");

// Class DeadByDaylight.UMGDragWidget
// 0x0028 (0x02D0 - 0x02A8)
class UUMGDragWidget : public UUserWidget
{
public:
	uint8                                         Pad_2A8[0x18];                                     // 0x02A8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UCustomWidgetWrapper_HudEditor*> _allEditableWidgets;                               // 0x02C0(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	void SetClampToViewportDirty();

	const TArray<class UCustomWidgetWrapper_HudEditor*> GetAllEditableWidgets() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGDragWidget">();
	}
	static class UUMGDragWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGDragWidget>();
	}
};
static_assert(alignof(UUMGDragWidget) == 0x000008, "Wrong alignment on UUMGDragWidget");
static_assert(sizeof(UUMGDragWidget) == 0x0002D0, "Wrong size on UUMGDragWidget");
static_assert(offsetof(UUMGDragWidget, _allEditableWidgets) == 0x0002C0, "Member 'UUMGDragWidget::_allEditableWidgets' has a wrong offset!");

// Class DeadByDaylight.UMGHudEditorLayoutWidget
// 0x0078 (0x0348 - 0x02D0)
class UUMGHudEditorLayoutWidget final : public UUMGDragWidget
{
public:
	uint8                                         Pad_2D0[0x10];                                     // 0x02D0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UUMGHudEditorScreen*                    HudEditorScreen;                                   // 0x02E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          _onSaveOverlapSound;                               // 0x02E8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUMGDragWidget_HudEditor*               _currentWidgetToEdit;                              // 0x02F0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class UUMGHudEditorLayoutScreen*, bool>  _isSaveDirtyMap;                                   // 0x02F8(0x0050)(Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	void FlagSaveAsDirty();
	void FlipLayout();
	void OnSaveDirty(bool IsDirty);
	void ResetLayout();
	void SaveLayout();
	void SetHudEditorScreen(class UUMGHudEditorScreen* Param_HudEditorScreen);
	void SetSaveOverlapSound(class UAkAudioEvent* OnSaveOverlapSound);
	void SetWidgetToEdit(class UUMGDragWidget_HudEditor* Widget);
	void ShowKillerLayout();
	void ShowSurvivorLayout();

	class UUMGDragWidget_HudEditor* GetCurrentDragWidget() const;
	class UCustomWidgetWrapper_HudEditor* GetHudEditorWrapperToEdit() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGHudEditorLayoutWidget">();
	}
	static class UUMGHudEditorLayoutWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGHudEditorLayoutWidget>();
	}
};
static_assert(alignof(UUMGHudEditorLayoutWidget) == 0x000008, "Wrong alignment on UUMGHudEditorLayoutWidget");
static_assert(sizeof(UUMGHudEditorLayoutWidget) == 0x000348, "Wrong size on UUMGHudEditorLayoutWidget");
static_assert(offsetof(UUMGHudEditorLayoutWidget, HudEditorScreen) == 0x0002E0, "Member 'UUMGHudEditorLayoutWidget::HudEditorScreen' has a wrong offset!");
static_assert(offsetof(UUMGHudEditorLayoutWidget, _onSaveOverlapSound) == 0x0002E8, "Member 'UUMGHudEditorLayoutWidget::_onSaveOverlapSound' has a wrong offset!");
static_assert(offsetof(UUMGHudEditorLayoutWidget, _currentWidgetToEdit) == 0x0002F0, "Member 'UUMGHudEditorLayoutWidget::_currentWidgetToEdit' has a wrong offset!");
static_assert(offsetof(UUMGHudEditorLayoutWidget, _isSaveDirtyMap) == 0x0002F8, "Member 'UUMGHudEditorLayoutWidget::_isSaveDirtyMap' has a wrong offset!");

// Class DeadByDaylight.ContextualQuestComponent
// 0x0040 (0x00E8 - 0x00A8)
class UContextualQuestComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x28];                                      // 0x00A8(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSpecialBehaviourObjectsInfo>   _specialBehaviourObjectsInfo;                      // 0x00D0(0x0010)(Net, ZeroConstructor, Transient, RepNotify, NativeAccessSpecifierPrivate)
	bool                                          _isInitialized;                                    // 0x00E0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E1[0x7];                                       // 0x00E1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_DebugAddSpecialBehaviour(class FName ID, int32 AmountRequired);
	void Authority_DebugRemoveSpecialBehaviour(class FName ID);
	void OnRep_SpecialBehaviourObjectsInfo();
	void OnSpecialBehaviourSet__DelegateSignature(class ADBDPlayer* DBDPlayer);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ContextualQuestComponent">();
	}
	static class UContextualQuestComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UContextualQuestComponent>();
	}
};
static_assert(alignof(UContextualQuestComponent) == 0x000008, "Wrong alignment on UContextualQuestComponent");
static_assert(sizeof(UContextualQuestComponent) == 0x0000E8, "Wrong size on UContextualQuestComponent");
static_assert(offsetof(UContextualQuestComponent, _specialBehaviourObjectsInfo) == 0x0000D0, "Member 'UContextualQuestComponent::_specialBehaviourObjectsInfo' has a wrong offset!");
static_assert(offsetof(UContextualQuestComponent, _isInitialized) == 0x0000E0, "Member 'UContextualQuestComponent::_isInitialized' has a wrong offset!");

// Class DeadByDaylight.DBDObserverPlayer
// 0x0040 (0x0690 - 0x0650)
class ADBDObserverPlayer final : public ACharacter
{
public:
	class UDBDPlayerData*                         _playerData;                                       // 0x0650(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_658[0x38];                                     // 0x0658(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Server_PlayerReady();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDObserverPlayer">();
	}
	static class ADBDObserverPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDObserverPlayer>();
	}
};
static_assert(alignof(ADBDObserverPlayer) == 0x000010, "Wrong alignment on ADBDObserverPlayer");
static_assert(sizeof(ADBDObserverPlayer) == 0x000690, "Wrong size on ADBDObserverPlayer");
static_assert(offsetof(ADBDObserverPlayer, _playerData) == 0x000650, "Member 'ADBDObserverPlayer::_playerData' has a wrong offset!");

// Class DeadByDaylight.ControllerPairingManager
// 0x0060 (0x0090 - 0x0030)
class UControllerPairingManager final : public UObject
{
public:
	uint8                                         Pad_30[0x54];                                      // 0x0030(0x0054)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UDBDGameInstance>        _gameInstance;                                     // 0x0084(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ControllerPairingManager">();
	}
	static class UControllerPairingManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UControllerPairingManager>();
	}
};
static_assert(alignof(UControllerPairingManager) == 0x000008, "Wrong alignment on UControllerPairingManager");
static_assert(sizeof(UControllerPairingManager) == 0x000090, "Wrong size on UControllerPairingManager");
static_assert(offsetof(UControllerPairingManager, _gameInstance) == 0x000084, "Member 'UControllerPairingManager::_gameInstance' has a wrong offset!");

// Class DeadByDaylight.CooldownTimerPerkIconStrategy
// 0x0000 (0x0038 - 0x0038)
class UCooldownTimerPerkIconStrategy final : public UBasePerkIconStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CooldownTimerPerkIconStrategy">();
	}
	static class UCooldownTimerPerkIconStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCooldownTimerPerkIconStrategy>();
	}
};
static_assert(alignof(UCooldownTimerPerkIconStrategy) == 0x000008, "Wrong alignment on UCooldownTimerPerkIconStrategy");
static_assert(sizeof(UCooldownTimerPerkIconStrategy) == 0x000038, "Wrong size on UCooldownTimerPerkIconStrategy");

// Class DeadByDaylight.DBDPawnSensingComponent
// 0x0010 (0x0100 - 0x00F0)
class UDBDPawnSensingComponent final : public UPawnSensingComponent
{
public:
	bool                                          bSenseEverywhere;                                  // 0x00F0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F1[0x3];                                       // 0x00F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PartiallyHiddenSensingDistance;                    // 0x00F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F8[0x8];                                       // 0x00F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDPawnSensingComponent">();
	}
	static class UDBDPawnSensingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDPawnSensingComponent>();
	}
};
static_assert(alignof(UDBDPawnSensingComponent) == 0x000008, "Wrong alignment on UDBDPawnSensingComponent");
static_assert(sizeof(UDBDPawnSensingComponent) == 0x000100, "Wrong size on UDBDPawnSensingComponent");
static_assert(offsetof(UDBDPawnSensingComponent, bSenseEverywhere) == 0x0000F0, "Member 'UDBDPawnSensingComponent::bSenseEverywhere' has a wrong offset!");
static_assert(offsetof(UDBDPawnSensingComponent, PartiallyHiddenSensingDistance) == 0x0000F4, "Member 'UDBDPawnSensingComponent::PartiallyHiddenSensingDistance' has a wrong offset!");

// Class DeadByDaylight.CoreCursor
// 0x0008 (0x02B0 - 0x02A8)
class UCoreCursor : public UUserWidget
{
public:
	class UScaleBox*                              CursorScaleBox;                                    // 0x02A8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CoreCursor">();
	}
	static class UCoreCursor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCoreCursor>();
	}
};
static_assert(alignof(UCoreCursor) == 0x000008, "Wrong alignment on UCoreCursor");
static_assert(sizeof(UCoreCursor) == 0x0002B0, "Wrong size on UCoreCursor");
static_assert(offsetof(UCoreCursor, CursorScaleBox) == 0x0002A8, "Member 'UCoreCursor::CursorScaleBox' has a wrong offset!");

// Class DeadByDaylight.CoreHudRootWidget
// 0x00A8 (0x0350 - 0x02A8)
class UCoreHudRootWidget : public UUserWidget
{
public:
	class UOverlay*                               WidgetContainer;                                   // 0x02A8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOverlay*                               OuterContainer;                                    // 0x02B0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOverlay*                               SpectateContainer;                                 // 0x02B8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UScaleBox*                              ScaleHud;                                          // 0x02C0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UnfocusedOpacity;                                  // 0x02C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CC[0x4];                                      // 0x02CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UUserWidget>                ExternalEffectsWidgetClass;                        // 0x02D0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UUserWidget>                HudAlertWidgetClass;                               // 0x02D8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UUserWidget>                InteractionProgressWidgetClass;                    // 0x02E0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UUserWidget>                InteractionPromptsContainerWidgetClass;            // 0x02E8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UUserWidget>                ItemInteractionWidgetClass;                        // 0x02F0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UUserWidget>                OfferingInteractionWidgetClass;                    // 0x02F8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UUserWidget>                CompetenceContainerWidgetClass;                    // 0x0300(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UUserWidget>                PingStatusWidgetClass;                             // 0x0308(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UUserWidget>                PlayerStatusesWidgetClass;                         // 0x0310(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UUserWidget>                ScreenIndicatorWidgetClass;                        // 0x0318(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UUserWidget>                StartSequenceWidgetClass;                          // 0x0320(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UUserWidget>                StatusEffectWidgetClass;                           // 0x0328(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<TScriptInterface<class ICoreBaseViewInterface>> _coreBaseViewInterfaces;                           // 0x0330(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_             HUDWidgetsFadeOutCompletedDelegate;                // 0x0340(0x0010)(ZeroConstructor, InstancedReference, BlueprintCallable, NativeAccessSpecifierPrivate)

public:
	void ApplyConstrainedAspectRatio(bool IsConstrained, float AspectRatio);
	void FadeInWidgets();
	void FadeOutWidgets();
	void SetWidgetsVisibility(bool Visible);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CoreHudRootWidget">();
	}
	static class UCoreHudRootWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCoreHudRootWidget>();
	}
};
static_assert(alignof(UCoreHudRootWidget) == 0x000008, "Wrong alignment on UCoreHudRootWidget");
static_assert(sizeof(UCoreHudRootWidget) == 0x000350, "Wrong size on UCoreHudRootWidget");
static_assert(offsetof(UCoreHudRootWidget, WidgetContainer) == 0x0002A8, "Member 'UCoreHudRootWidget::WidgetContainer' has a wrong offset!");
static_assert(offsetof(UCoreHudRootWidget, OuterContainer) == 0x0002B0, "Member 'UCoreHudRootWidget::OuterContainer' has a wrong offset!");
static_assert(offsetof(UCoreHudRootWidget, SpectateContainer) == 0x0002B8, "Member 'UCoreHudRootWidget::SpectateContainer' has a wrong offset!");
static_assert(offsetof(UCoreHudRootWidget, ScaleHud) == 0x0002C0, "Member 'UCoreHudRootWidget::ScaleHud' has a wrong offset!");
static_assert(offsetof(UCoreHudRootWidget, UnfocusedOpacity) == 0x0002C8, "Member 'UCoreHudRootWidget::UnfocusedOpacity' has a wrong offset!");
static_assert(offsetof(UCoreHudRootWidget, ExternalEffectsWidgetClass) == 0x0002D0, "Member 'UCoreHudRootWidget::ExternalEffectsWidgetClass' has a wrong offset!");
static_assert(offsetof(UCoreHudRootWidget, HudAlertWidgetClass) == 0x0002D8, "Member 'UCoreHudRootWidget::HudAlertWidgetClass' has a wrong offset!");
static_assert(offsetof(UCoreHudRootWidget, InteractionProgressWidgetClass) == 0x0002E0, "Member 'UCoreHudRootWidget::InteractionProgressWidgetClass' has a wrong offset!");
static_assert(offsetof(UCoreHudRootWidget, InteractionPromptsContainerWidgetClass) == 0x0002E8, "Member 'UCoreHudRootWidget::InteractionPromptsContainerWidgetClass' has a wrong offset!");
static_assert(offsetof(UCoreHudRootWidget, ItemInteractionWidgetClass) == 0x0002F0, "Member 'UCoreHudRootWidget::ItemInteractionWidgetClass' has a wrong offset!");
static_assert(offsetof(UCoreHudRootWidget, OfferingInteractionWidgetClass) == 0x0002F8, "Member 'UCoreHudRootWidget::OfferingInteractionWidgetClass' has a wrong offset!");
static_assert(offsetof(UCoreHudRootWidget, CompetenceContainerWidgetClass) == 0x000300, "Member 'UCoreHudRootWidget::CompetenceContainerWidgetClass' has a wrong offset!");
static_assert(offsetof(UCoreHudRootWidget, PingStatusWidgetClass) == 0x000308, "Member 'UCoreHudRootWidget::PingStatusWidgetClass' has a wrong offset!");
static_assert(offsetof(UCoreHudRootWidget, PlayerStatusesWidgetClass) == 0x000310, "Member 'UCoreHudRootWidget::PlayerStatusesWidgetClass' has a wrong offset!");
static_assert(offsetof(UCoreHudRootWidget, ScreenIndicatorWidgetClass) == 0x000318, "Member 'UCoreHudRootWidget::ScreenIndicatorWidgetClass' has a wrong offset!");
static_assert(offsetof(UCoreHudRootWidget, StartSequenceWidgetClass) == 0x000320, "Member 'UCoreHudRootWidget::StartSequenceWidgetClass' has a wrong offset!");
static_assert(offsetof(UCoreHudRootWidget, StatusEffectWidgetClass) == 0x000328, "Member 'UCoreHudRootWidget::StatusEffectWidgetClass' has a wrong offset!");
static_assert(offsetof(UCoreHudRootWidget, _coreBaseViewInterfaces) == 0x000330, "Member 'UCoreHudRootWidget::_coreBaseViewInterfaces' has a wrong offset!");
static_assert(offsetof(UCoreHudRootWidget, HUDWidgetsFadeOutCompletedDelegate) == 0x000340, "Member 'UCoreHudRootWidget::HUDWidgetsFadeOutCompletedDelegate' has a wrong offset!");

// Class DeadByDaylight.DBDSurfaceTypeName
// 0x0000 (0x0030 - 0x0030)
class UDBDSurfaceTypeName final : public UBlueprintFunctionLibrary
{
public:
	static class FName Convert(const EPhysicalSurface SurfaceType);
	static class FName ConvertFromPhysicalMaterial(const class UPhysicalMaterial* Material);
	static class FString GetSurfaceName(const class UPhysicalMaterial* PhysicalMaterial);
	static EPhysicalSurface GetSurfaceType(const class UPhysicalMaterial* PhysicalMaterial);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDSurfaceTypeName">();
	}
	static class UDBDSurfaceTypeName* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDSurfaceTypeName>();
	}
};
static_assert(alignof(UDBDSurfaceTypeName) == 0x000008, "Wrong alignment on UDBDSurfaceTypeName");
static_assert(sizeof(UDBDSurfaceTypeName) == 0x000030, "Wrong size on UDBDSurfaceTypeName");

// Class DeadByDaylight.CrossPlatformManager
// 0x0008 (0x0038 - 0x0030)
class UCrossPlatformManager final : public UObject
{
public:
	bool                                          _crossPlayAllowedByPlatform;                       // 0x0030(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _crossPlayAllowedByKraken;                         // 0x0031(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_32[0x6];                                       // 0x0032(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrossPlatformManager">();
	}
	static class UCrossPlatformManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrossPlatformManager>();
	}
};
static_assert(alignof(UCrossPlatformManager) == 0x000008, "Wrong alignment on UCrossPlatformManager");
static_assert(sizeof(UCrossPlatformManager) == 0x000038, "Wrong size on UCrossPlatformManager");
static_assert(offsetof(UCrossPlatformManager, _crossPlayAllowedByPlatform) == 0x000030, "Member 'UCrossPlatformManager::_crossPlayAllowedByPlatform' has a wrong offset!");
static_assert(offsetof(UCrossPlatformManager, _crossPlayAllowedByKraken) == 0x000031, "Member 'UCrossPlatformManager::_crossPlayAllowedByKraken' has a wrong offset!");

// Class DeadByDaylight.DBDPlayerCameraManager
// 0x0020 (0x3380 - 0x3360)
class ADBDPlayerCameraManager : public APlayerCameraManager
{
public:
	float                                         NormalFOV;                                         // 0x3360(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetingFOV;                                      // 0x3364(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TScriptInterface<class IViewRotationStrategy> _viewRotationStrategy;                             // 0x3368(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3378[0x8];                                     // 0x3378(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CancelCurrentFadeTimeline();
	void StartFadeInTimeline(float Duration);
	void StartFadeOutTimeline(float Duration);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDPlayerCameraManager">();
	}
	static class ADBDPlayerCameraManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDPlayerCameraManager>();
	}
};
static_assert(alignof(ADBDPlayerCameraManager) == 0x000010, "Wrong alignment on ADBDPlayerCameraManager");
static_assert(sizeof(ADBDPlayerCameraManager) == 0x003380, "Wrong size on ADBDPlayerCameraManager");
static_assert(offsetof(ADBDPlayerCameraManager, NormalFOV) == 0x003360, "Member 'ADBDPlayerCameraManager::NormalFOV' has a wrong offset!");
static_assert(offsetof(ADBDPlayerCameraManager, TargetingFOV) == 0x003364, "Member 'ADBDPlayerCameraManager::TargetingFOV' has a wrong offset!");
static_assert(offsetof(ADBDPlayerCameraManager, _viewRotationStrategy) == 0x003368, "Member 'ADBDPlayerCameraManager::_viewRotationStrategy' has a wrong offset!");

// Class DeadByDaylight.CrossPromotionManager
// 0x0028 (0x0060 - 0x0038)
class UCrossPromotionManager final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x28];                                      // 0x0038(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrossPromotionManager">();
	}
	static class UCrossPromotionManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrossPromotionManager>();
	}
};
static_assert(alignof(UCrossPromotionManager) == 0x000008, "Wrong alignment on UCrossPromotionManager");
static_assert(sizeof(UCrossPromotionManager) == 0x000060, "Wrong size on UCrossPromotionManager");

// Class DeadByDaylight.StoreMenuFlowEventsGenerator
// 0x0010 (0x0040 - 0x0030)
class UStoreMenuFlowEventsGenerator final : public UObject
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ULocalEventManager*                     _localEventManager;                                // 0x0038(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StoreMenuFlowEventsGenerator">();
	}
	static class UStoreMenuFlowEventsGenerator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStoreMenuFlowEventsGenerator>();
	}
};
static_assert(alignof(UStoreMenuFlowEventsGenerator) == 0x000008, "Wrong alignment on UStoreMenuFlowEventsGenerator");
static_assert(sizeof(UStoreMenuFlowEventsGenerator) == 0x000040, "Wrong size on UStoreMenuFlowEventsGenerator");
static_assert(offsetof(UStoreMenuFlowEventsGenerator, _localEventManager) == 0x000038, "Member 'UStoreMenuFlowEventsGenerator::_localEventManager' has a wrong offset!");

// Class DeadByDaylight.DBDOutlineComponentTranslucentConfiguration
// 0x0000 (0x0138 - 0x0138)
class UDBDOutlineComponentTranslucentConfiguration final : public UDBDOutlineComponentConfiguration
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDOutlineComponentTranslucentConfiguration">();
	}
	static class UDBDOutlineComponentTranslucentConfiguration* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDOutlineComponentTranslucentConfiguration>();
	}
};
static_assert(alignof(UDBDOutlineComponentTranslucentConfiguration) == 0x000008, "Wrong alignment on UDBDOutlineComponentTranslucentConfiguration");
static_assert(sizeof(UDBDOutlineComponentTranslucentConfiguration) == 0x000138, "Wrong size on UDBDOutlineComponentTranslucentConfiguration");

// Class DeadByDaylight.CrowBomb
// 0x00A0 (0x0368 - 0x02C8)
class ACrowBomb final : public AGeneratorDrivenActor
{
public:
	float                                         _innerRadius;                                      // 0x02C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _outerRadius;                                      // 0x02CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _maxTakeoffDelay;                                  // 0x02D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         _numCrows;                                         // 0x02D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         _crowCenterDistance;                               // 0x02D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         _eliminationSamples;                               // 0x02DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _eliminationStddev;                                // 0x02E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2E4[0x4];                                      // 0x02E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   _meshComponentClass;                               // 0x02E8(0x0038)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UWorldRunawayMeshComponent*>     _crows;                                            // 0x0320(0x0010)(ExportObject, Net, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_330[0x18];                                     // 0x0330(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        _root;                                             // 0x0348(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USceneComponent*                        _traceStart;                                       // 0x0350(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USceneComponent*                        _traceEnd;                                         // 0x0358(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _landed;                                           // 0x0360(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_361[0x7];                                      // 0x0361(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void TriggerLand();
	void TriggerTakeOff(const struct FVector& TriggerLocation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrowBomb">();
	}
	static class ACrowBomb* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACrowBomb>();
	}
};
static_assert(alignof(ACrowBomb) == 0x000008, "Wrong alignment on ACrowBomb");
static_assert(sizeof(ACrowBomb) == 0x000368, "Wrong size on ACrowBomb");
static_assert(offsetof(ACrowBomb, _innerRadius) == 0x0002C8, "Member 'ACrowBomb::_innerRadius' has a wrong offset!");
static_assert(offsetof(ACrowBomb, _outerRadius) == 0x0002CC, "Member 'ACrowBomb::_outerRadius' has a wrong offset!");
static_assert(offsetof(ACrowBomb, _maxTakeoffDelay) == 0x0002D0, "Member 'ACrowBomb::_maxTakeoffDelay' has a wrong offset!");
static_assert(offsetof(ACrowBomb, _numCrows) == 0x0002D4, "Member 'ACrowBomb::_numCrows' has a wrong offset!");
static_assert(offsetof(ACrowBomb, _crowCenterDistance) == 0x0002D8, "Member 'ACrowBomb::_crowCenterDistance' has a wrong offset!");
static_assert(offsetof(ACrowBomb, _eliminationSamples) == 0x0002DC, "Member 'ACrowBomb::_eliminationSamples' has a wrong offset!");
static_assert(offsetof(ACrowBomb, _eliminationStddev) == 0x0002E0, "Member 'ACrowBomb::_eliminationStddev' has a wrong offset!");
static_assert(offsetof(ACrowBomb, _meshComponentClass) == 0x0002E8, "Member 'ACrowBomb::_meshComponentClass' has a wrong offset!");
static_assert(offsetof(ACrowBomb, _crows) == 0x000320, "Member 'ACrowBomb::_crows' has a wrong offset!");
static_assert(offsetof(ACrowBomb, _root) == 0x000348, "Member 'ACrowBomb::_root' has a wrong offset!");
static_assert(offsetof(ACrowBomb, _traceStart) == 0x000350, "Member 'ACrowBomb::_traceStart' has a wrong offset!");
static_assert(offsetof(ACrowBomb, _traceEnd) == 0x000358, "Member 'ACrowBomb::_traceEnd' has a wrong offset!");
static_assert(offsetof(ACrowBomb, _landed) == 0x000360, "Member 'ACrowBomb::_landed' has a wrong offset!");

// Class DeadByDaylight.CustomizationDescription
// 0x0010 (0x0048 - 0x0038)
class UCustomizationDescription final : public UDataAsset
{
public:
	TArray<struct FCustomizedMeshPart>            Parts;                                             // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomizationDescription">();
	}
	static class UCustomizationDescription* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomizationDescription>();
	}
};
static_assert(alignof(UCustomizationDescription) == 0x000008, "Wrong alignment on UCustomizationDescription");
static_assert(sizeof(UCustomizationDescription) == 0x000048, "Wrong size on UCustomizationDescription");
static_assert(offsetof(UCustomizationDescription, Parts) == 0x000038, "Member 'UCustomizationDescription::Parts' has a wrong offset!");

// Class DeadByDaylight.SlasherPlayer
// 0x0560 (0x1AA0 - 0x1540)
class ASlasherPlayer : public ADBDPlayer
{
public:
	uint8                                         Pad_1540[0x48];                                    // 0x1540(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _setFirstPersonModeEnabledOnKillerIntroCompleted;  // 0x1588(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1589[0x27];                                    // 0x1589(0x0027)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                PutDownTraceLocation;                              // 0x15B0(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DefaultSlasherPower;                               // 0x15C8(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LoudNoiseDisplayTime;                              // 0x15D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetPriorityFactor;                              // 0x15D8(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShouldDisplayAttackZones;                          // 0x15F0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15F1[0x7];                                     // 0x15F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ACamperExposerInstance>     CamperExposer;                                     // 0x15F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EKillerAbilities>                      KillerAbilities;                                   // 0x1600(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class UKillerSoundCuesComponent*              KillerSoundCuesComponent;                          // 0x1610(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShowKillerPowerDebugInfo;                          // 0x1618(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1619[0x7];                                     // 0x1619(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnStalkModeChangedEvent;                           // 0x1620(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_1630[0x18];                                    // 0x1630(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UAkComponent>            _audioComponent;                                   // 0x1648(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDBDNavModifierComponent*               _terrorNavModifierComponent;                       // 0x1650(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UKillerBloodFXComponent*                _bloodFXComponent;                                 // 0x1658(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _slasherLightIntensity;                            // 0x1660(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _defaultAmountToSquish;                            // 0x1664(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1668[0x8];                                     // 0x1668(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class ADBDPlayer*, struct FTargetFocusTimer> _stalkTimers;                                      // 0x1670(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	class UStillnessTrackerComponent*             _stillnessTracker;                                 // 0x16C0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDBDTimer                              _recentlyCloakedTimer;                             // 0x16C8(0x0028)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FDBDTimer                              _flashlightBlindEvasionScoreTimer;                 // 0x16F0(0x0028)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FDBDTimer                              _flashlightBurnoutEvasionScoreTimer;               // 0x1718(0x0028)(Transient, Protected, NativeAccessSpecifierProtected)
	TMap<class ADBDPlayer*, struct FAnimationMontageDescriptor> _predictedCamperHitMontages;                       // 0x1740(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1790[0x10];                                    // 0x1790(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class ULoudNoiseHUDIndicator*                 _loudNoiseIndicator;                               // 0x17A0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USlasherHitsWhileCarryingTrackerComponent* _hitsWhileCarryingTracker;                         // 0x17A8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _stealthIncreaseRate;                              // 0x17B0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _stealthDecreaseRate;                              // 0x17B4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_17B8[0x50];                                    // 0x17B8(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTagStateBool                          _isInStalkMode;                                    // 0x1808(0x0048)(Net, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1850[0x120];                                   // 0x1850(0x0120)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _isKilling;                                        // 0x1970(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int8                                          _allowedKillCount;                                 // 0x1971(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int8                                          _allowedKillAfterStrugglePhase;                    // 0x1972(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1973[0x9];                                     // 0x1973(0x0009)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _cachedBloodlustTier;                              // 0x197C(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1980[0x4];                                     // 0x1980(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        _killerPowerDebugFlags;                            // 0x1984(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTag                           _presenceTag;                                      // 0x1988(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1994[0x4];                                     // 0x1994(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  _persistantStateTags;                              // 0x1998(0x0020)(Edit, NativeAccessSpecifierPrivate)
	bool                                          _enableKillerCrouchInput;                          // 0x19B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _canStartAttackWhileCrouched;                      // 0x19B9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_19BA[0x6];                                     // 0x19BA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class ACamperPlayer*                          _carriedCamper;                                    // 0x19C0(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMoriComponent*                         _moriComponent;                                    // 0x19C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFinisherMoriHandlerComponent*          _finisherMoriHandlerComponent;                     // 0x19D0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHitValidatorComponent*                 _hitValidator;                                     // 0x19D8(0x0008)(Edit, ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHitValidatorConfigurator*              _hitValidationConfigurator;                        // 0x19E0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDBDAttackerComponent*                  _attackerComponent;                                // 0x19E8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_19F0[0x14];                                    // 0x19F0(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	EAttackType                                   _basicAttackType;                                  // 0x1A04(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1A05[0x3];                                     // 0x1A05(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UArmIKSensorComponent*                  _armIKSensorComponent;                             // 0x1A08(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ACamperPlayer*                          _survivorBeingKilled;                              // 0x1A10(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1A18[0x8];                                     // 0x1A18(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UFirstPersonViewComponent>  _firstPersonViewComponentClass;                    // 0x1A20(0x0008)(Edit, ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFirstPersonViewComponent*              _firstPersonViewComponent;                         // 0x1A28(0x0008)(Edit, ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UKillerIntroComponent*                  _killerIntroComponent;                             // 0x1A30(0x0008)(Edit, ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UKillerBlindingFXComponent*             _blindingFXComponent;                              // 0x1A38(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1A40[0x8];                                     // 0x1A40(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UKillerRedStainUpdateStrategy*          _redStainUpdateStrategy;                           // 0x1A48(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   _squishFactorParameter;                            // 0x1A50(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1A5C[0x4];                                     // 0x1A5C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        _attackZonePivot;                                  // 0x1A60(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USlasherStunnableComponent*             _slasherStunnableComponent;                        // 0x1A68(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1A70[0x30];                                    // 0x1A70(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_AllowKilling(int32 NumKills);
	void Authority_SetInStalkMode(bool StalkMode, bool Forced);
	void BroadcastOnInstantTeleport();
	bool CancelAttackByInput();
	void Client_RequestStun(EStunType StunType, class ADBDPlayer* Stunner);
	void Cosmetic_OnCancelCarry();
	void Cosmetic_OnDropCamperEnd();
	void Cosmetic_OnPickUpEnd();
	void DBD_AllowKilling();
	void DBD_DisplayAttackZones(bool Display);
	void DBD_MergeLockOnDamageZones(bool Enable);
	void DBD_SetAttackZones(EAttackZoneSet AttackZoneSet);
	void DecrementInterruptBlock();
	void DisplayAttackZones(bool Display);
	class USceneComponent* GetAttackZonePivot();
	float GetCurrentRotationYaw();
	void IncrementInterruptBlock();
	bool IsCrouchAvailable_BP();
	bool IsIdling();
	bool Local_CancelAttack();
	void MergeLockOnDamageZones(bool Enable);
	void Multicast_Cheat_SetAttackDetectionZoneSet(EAttackZoneSet AttackZoneSet);
	void Multicast_DisplayAttackZones(bool Display);
	void Multicast_MergeLockOnDamageZones(bool Enable);
	void OnAttackFinish(const EAttackType AttackType);
	void OnAttackStart(const EAttackType AttackType);
	void OnCamperHit(class ACamperPlayer* Camper);
	void OnDropCamperEnd(class ADBDPlayer* Camper);
	void OnIsKillingSurvivorWithMoriUpdated(bool IsKillingSurvivorWithMori);
	void OnKillerAbilityBeginActivate(EKillerAbilities KillerAbility);
	void OnKillerAbilityBeginDeactivate(EKillerAbilities KillerAbility, bool Forced);
	void OnKillerAbilityEndActivate(EKillerAbilities KillerAbility);
	void OnKillerAbilityEndDeactivate(EKillerAbilities KillerAbility, bool Forced);
	void OnKillerAbilityUpdateActivate(EKillerAbilities KillerAbility, float Percent);
	void OnLoudNoiseIndicatorDestroyed();
	void OnLoudNoiseTriggered(class AActor* Originator, class AActor* InstigatingActor, const struct FVector& Location, bool ShouldTrack, float* AudibleRange, bool IsQuickAction, bool IsDeceivingNoise);
	void OnPerformingChargableInteraction(float Progress);
	void OnStalkModeChanged(bool StalkMode);
	void OnStalkModeChangedCosmetic(bool StalkMode);
	void OnStalkModeChangedEvent__DelegateSignature(bool Param_IsInStalkMode);
	void OnStealthChanged(bool Stealth);
	void PlayBloodHitsEffects();
	void Server_SendActionKillerInput(bool Pressed);
	void Server_SendAttackInput(bool Pressed);
	void SetAttackDetectionZoneSet(EAttackZoneSet AttackZoneSet);
	void SetAttackZonePivot(class USceneComponent* AttackZonePivot);
	void SetCarriedCamper(class ACamperPlayer* Camper);
	void SetIsCloaked(bool Param_IsCloaked, bool Forced);
	void SetIsHookingSurvivor(const bool Value);
	void SetIsKilling(bool IsKilling);
	void SetLightIntensity(float Intensity);
	void SetStalkTierWalkSpeedMultiplier(float StalkTierWalkSpeedMultiplier);
	void SetSurvivorBeingKilled(class ACamperPlayer* Survivor);
	void SpawnSlasherPower();
	void UpdateRageTierEffect(int32 PreviousTier, int32 CurrentTier);

	void BroadcastOffensiveAction() const;
	bool CanAffectLocalPlayer() const;
	bool CanAttack(const EAttackType AttackType) const;
	bool CanAttack_BP(const EAttackType AttackType) const;
	bool CanGainRage() const;
	bool CanPerformKillerAbility(EKillerAbilities KillerAbility) const;
	bool CanSlashAttack_BP() const;
	float GetAnimDirection() const;
	float GetBlindedPercent() const;
	class ACamperPlayer* GetCarriedCamper() const;
	TArray<class FName> GetCharacterCustomAnimTags() const;
	class UChaserCharacterComponent* GetChaserCharacterComponent() const;
	bool GetIsAttacking() const;
	EKillerCarryAnimWeight GetKillerCarryAnimWeight() const;
	float GetLightIntensity() const;
	struct FRotator GetLookRotation() const;
	class ACamperPlayer* GetObsessionTarget() const;
	struct FVector GetPlayerDropOffPoint() const;
	struct FGameplayTag GetPresenceTag() const;
	int32 GetRageTier() const;
	class USlasherMovementComponent* GetSlasherMovement() const;
	float GetStalkTierWalkSpeedMultiplier() const;
	float GetStealthRatio() const;
	class ACamperPlayer* GetSurvivorBeingKilled() const;
	bool HasKillerAbility(EKillerAbilities KillerAbility) const;
	bool HasPreLevelGenerationModifier(class FName ModifierID) const;
	bool IsAllowedToKill(const class ACamperPlayer* Survivor) const;
	bool IsCarrying() const;
	bool IsCloaking() const;
	bool IsHooking() const;
	bool IsImmuneToObservingPlayerDetection(const class ADBDPlayer* ObservingPlayer) const;
	bool IsInterruptBlocked() const;
	bool IsKilling() const;
	bool IsStunned() const;
	bool IsUncloaking() const;
	bool ShouldApplyBloodlustSpeedModifier() const;
	bool WasRecentlyCloaked() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SlasherPlayer">();
	}
	static class ASlasherPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASlasherPlayer>();
	}
};
static_assert(alignof(ASlasherPlayer) == 0x000010, "Wrong alignment on ASlasherPlayer");
static_assert(sizeof(ASlasherPlayer) == 0x001AA0, "Wrong size on ASlasherPlayer");
static_assert(offsetof(ASlasherPlayer, _setFirstPersonModeEnabledOnKillerIntroCompleted) == 0x001588, "Member 'ASlasherPlayer::_setFirstPersonModeEnabledOnKillerIntroCompleted' has a wrong offset!");
static_assert(offsetof(ASlasherPlayer, PutDownTraceLocation) == 0x0015B0, "Member 'ASlasherPlayer::PutDownTraceLocation' has a wrong offset!");
static_assert(offsetof(ASlasherPlayer, DefaultSlasherPower) == 0x0015C8, "Member 'ASlasherPlayer::DefaultSlasherPower' has a wrong offset!");
static_assert(offsetof(ASlasherPlayer, LoudNoiseDisplayTime) == 0x0015D4, "Member 'ASlasherPlayer::LoudNoiseDisplayTime' has a wrong offset!");
static_assert(offsetof(ASlasherPlayer, TargetPriorityFactor) == 0x0015D8, "Member 'ASlasherPlayer::TargetPriorityFactor' has a wrong offset!");
static_assert(offsetof(ASlasherPlayer, ShouldDisplayAttackZones) == 0x0015F0, "Member 'ASlasherPlayer::ShouldDisplayAttackZones' has a wrong offset!");
static_assert(offsetof(ASlasherPlayer, CamperExposer) == 0x0015F8, "Member 'ASlasherPlayer::CamperExposer' has a wrong offset!");
static_assert(offsetof(ASlasherPlayer, KillerAbilities) == 0x001600, "Member 'ASlasherPlayer::KillerAbilities' has a wrong offset!");
static_assert(offsetof(ASlasherPlayer, KillerSoundCuesComponent) == 0x001610, "Member 'ASlasherPlayer::KillerSoundCuesComponent' has a wrong offset!");
static_assert(offsetof(ASlasherPlayer, ShowKillerPowerDebugInfo) == 0x001618, "Member 'ASlasherPlayer::ShowKillerPowerDebugInfo' has a wrong offset!");
static_assert(offsetof(ASlasherPlayer, OnStalkModeChangedEvent) == 0x001620, "Member 'ASlasherPlayer::OnStalkModeChangedEvent' has a wrong offset!");
static_assert(offsetof(ASlasherPlayer, _audioComponent) == 0x001648, "Member 'ASlasherPlayer::_audioComponent' has a wrong offset!");
static_assert(offsetof(ASlasherPlayer, _terrorNavModifierComponent) == 0x001650, "Member 'ASlasherPlayer::_terrorNavModifierComponent' has a wrong offset!");
static_assert(offsetof(ASlasherPlayer, _bloodFXComponent) == 0x001658, "Member 'ASlasherPlayer::_bloodFXComponent' has a wrong offset!");
static_assert(offsetof(ASlasherPlayer, _slasherLightIntensity) == 0x001660, "Member 'ASlasherPlayer::_slasherLightIntensity' has a wrong offset!");
static_assert(offsetof(ASlasherPlayer, _defaultAmountToSquish) == 0x001664, "Member 'ASlasherPlayer::_defaultAmountToSquish' has a wrong offset!");
static_assert(offsetof(ASlasherPlayer, _stalkTimers) == 0x001670, "Member 'ASlasherPlayer::_stalkTimers' has a wrong offset!");
static_assert(offsetof(ASlasherPlayer, _stillnessTracker) == 0x0016C0, "Member 'ASlasherPlayer::_stillnessTracker' has a wrong offset!");
static_assert(offsetof(ASlasherPlayer, _recentlyCloakedTimer) == 0x0016C8, "Member 'ASlasherPlayer::_recentlyCloakedTimer' has a wrong offset!");
static_assert(offsetof(ASlasherPlayer, _flashlightBlindEvasionScoreTimer) == 0x0016F0, "Member 'ASlasherPlayer::_flashlightBlindEvasionScoreTimer' has a wrong offset!");
static_assert(offsetof(ASlasherPlayer, _flashlightBurnoutEvasionScoreTimer) == 0x001718, "Member 'ASlasherPlayer::_flashlightBurnoutEvasionScoreTimer' has a wrong offset!");
static_assert(offsetof(ASlasherPlayer, _predictedCamperHitMontages) == 0x001740, "Member 'ASlasherPlayer::_predictedCamperHitMontages' has a wrong offset!");
static_assert(offsetof(ASlasherPlayer, _loudNoiseIndicator) == 0x0017A0, "Member 'ASlasherPlayer::_loudNoiseIndicator' has a wrong offset!");
static_assert(offsetof(ASlasherPlayer, _hitsWhileCarryingTracker) == 0x0017A8, "Member 'ASlasherPlayer::_hitsWhileCarryingTracker' has a wrong offset!");
static_assert(offsetof(ASlasherPlayer, _stealthIncreaseRate) == 0x0017B0, "Member 'ASlasherPlayer::_stealthIncreaseRate' has a wrong offset!");
static_assert(offsetof(ASlasherPlayer, _stealthDecreaseRate) == 0x0017B4, "Member 'ASlasherPlayer::_stealthDecreaseRate' has a wrong offset!");
static_assert(offsetof(ASlasherPlayer, _isInStalkMode) == 0x001808, "Member 'ASlasherPlayer::_isInStalkMode' has a wrong offset!");
static_assert(offsetof(ASlasherPlayer, _isKilling) == 0x001970, "Member 'ASlasherPlayer::_isKilling' has a wrong offset!");
static_assert(offsetof(ASlasherPlayer, _allowedKillCount) == 0x001971, "Member 'ASlasherPlayer::_allowedKillCount' has a wrong offset!");
static_assert(offsetof(ASlasherPlayer, _allowedKillAfterStrugglePhase) == 0x001972, "Member 'ASlasherPlayer::_allowedKillAfterStrugglePhase' has a wrong offset!");
static_assert(offsetof(ASlasherPlayer, _cachedBloodlustTier) == 0x00197C, "Member 'ASlasherPlayer::_cachedBloodlustTier' has a wrong offset!");
static_assert(offsetof(ASlasherPlayer, _killerPowerDebugFlags) == 0x001984, "Member 'ASlasherPlayer::_killerPowerDebugFlags' has a wrong offset!");
static_assert(offsetof(ASlasherPlayer, _presenceTag) == 0x001988, "Member 'ASlasherPlayer::_presenceTag' has a wrong offset!");
static_assert(offsetof(ASlasherPlayer, _persistantStateTags) == 0x001998, "Member 'ASlasherPlayer::_persistantStateTags' has a wrong offset!");
static_assert(offsetof(ASlasherPlayer, _enableKillerCrouchInput) == 0x0019B8, "Member 'ASlasherPlayer::_enableKillerCrouchInput' has a wrong offset!");
static_assert(offsetof(ASlasherPlayer, _canStartAttackWhileCrouched) == 0x0019B9, "Member 'ASlasherPlayer::_canStartAttackWhileCrouched' has a wrong offset!");
static_assert(offsetof(ASlasherPlayer, _carriedCamper) == 0x0019C0, "Member 'ASlasherPlayer::_carriedCamper' has a wrong offset!");
static_assert(offsetof(ASlasherPlayer, _moriComponent) == 0x0019C8, "Member 'ASlasherPlayer::_moriComponent' has a wrong offset!");
static_assert(offsetof(ASlasherPlayer, _finisherMoriHandlerComponent) == 0x0019D0, "Member 'ASlasherPlayer::_finisherMoriHandlerComponent' has a wrong offset!");
static_assert(offsetof(ASlasherPlayer, _hitValidator) == 0x0019D8, "Member 'ASlasherPlayer::_hitValidator' has a wrong offset!");
static_assert(offsetof(ASlasherPlayer, _hitValidationConfigurator) == 0x0019E0, "Member 'ASlasherPlayer::_hitValidationConfigurator' has a wrong offset!");
static_assert(offsetof(ASlasherPlayer, _attackerComponent) == 0x0019E8, "Member 'ASlasherPlayer::_attackerComponent' has a wrong offset!");
static_assert(offsetof(ASlasherPlayer, _basicAttackType) == 0x001A04, "Member 'ASlasherPlayer::_basicAttackType' has a wrong offset!");
static_assert(offsetof(ASlasherPlayer, _armIKSensorComponent) == 0x001A08, "Member 'ASlasherPlayer::_armIKSensorComponent' has a wrong offset!");
static_assert(offsetof(ASlasherPlayer, _survivorBeingKilled) == 0x001A10, "Member 'ASlasherPlayer::_survivorBeingKilled' has a wrong offset!");
static_assert(offsetof(ASlasherPlayer, _firstPersonViewComponentClass) == 0x001A20, "Member 'ASlasherPlayer::_firstPersonViewComponentClass' has a wrong offset!");
static_assert(offsetof(ASlasherPlayer, _firstPersonViewComponent) == 0x001A28, "Member 'ASlasherPlayer::_firstPersonViewComponent' has a wrong offset!");
static_assert(offsetof(ASlasherPlayer, _killerIntroComponent) == 0x001A30, "Member 'ASlasherPlayer::_killerIntroComponent' has a wrong offset!");
static_assert(offsetof(ASlasherPlayer, _blindingFXComponent) == 0x001A38, "Member 'ASlasherPlayer::_blindingFXComponent' has a wrong offset!");
static_assert(offsetof(ASlasherPlayer, _redStainUpdateStrategy) == 0x001A48, "Member 'ASlasherPlayer::_redStainUpdateStrategy' has a wrong offset!");
static_assert(offsetof(ASlasherPlayer, _squishFactorParameter) == 0x001A50, "Member 'ASlasherPlayer::_squishFactorParameter' has a wrong offset!");
static_assert(offsetof(ASlasherPlayer, _attackZonePivot) == 0x001A60, "Member 'ASlasherPlayer::_attackZonePivot' has a wrong offset!");
static_assert(offsetof(ASlasherPlayer, _slasherStunnableComponent) == 0x001A68, "Member 'ASlasherPlayer::_slasherStunnableComponent' has a wrong offset!");

// Class DeadByDaylight.SurvivorCameraLagStrategy
// 0x0070 (0x0118 - 0x00A8)
class USurvivorCameraLagStrategy final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x70];                                      // 0x00A8(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SurvivorCameraLagStrategy">();
	}
	static class USurvivorCameraLagStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<USurvivorCameraLagStrategy>();
	}
};
static_assert(alignof(USurvivorCameraLagStrategy) == 0x000008, "Wrong alignment on USurvivorCameraLagStrategy");
static_assert(sizeof(USurvivorCameraLagStrategy) == 0x000118, "Wrong size on USurvivorCameraLagStrategy");

// Class DeadByDaylight.CustomizationPresetController
// 0x0000 (0x0030 - 0x0030)
class UCustomizationPresetController final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomizationPresetController">();
	}
	static class UCustomizationPresetController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomizationPresetController>();
	}
};
static_assert(alignof(UCustomizationPresetController) == 0x000008, "Wrong alignment on UCustomizationPresetController");
static_assert(sizeof(UCustomizationPresetController) == 0x000030, "Wrong size on UCustomizationPresetController");

// Class DeadByDaylight.TallyUIUtilities
// 0x0000 (0x0030 - 0x0030)
class UTallyUIUtilities final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TallyUIUtilities">();
	}
	static class UTallyUIUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTallyUIUtilities>();
	}
};
static_assert(alignof(UTallyUIUtilities) == 0x000008, "Wrong alignment on UTallyUIUtilities");
static_assert(sizeof(UTallyUIUtilities) == 0x000030, "Wrong size on UTallyUIUtilities");

// Class DeadByDaylight.CustomizedAudioComponent
// 0x0160 (0x0208 - 0x00A8)
class UCustomizedAudioComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnCustomizedAudioSwitchStateChanged;               // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnOutfitCustomizedAudioStateCollectionChanged;     // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_C8[0xB0];                                      // 0x00C8(0x00B0)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 AudioCharacterNameDefaultSwitchState;              // 0x0178(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 AudioCharacterSubNameDefaultSwitchState;           // 0x0188(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 AudioCharacterHeadDefaultSwitchState;              // 0x0198(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 AudioCharacterClothesDefaultSwitchState;           // 0x01A8(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 AudioCharacterShoesDefaultSwitchState;             // 0x01B8(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 AudioCharacterWeaponDefaultSwitchState;            // 0x01C8(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 AudioCharacterAmbianceDefaultSwitchState;          // 0x01D8(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 AudioCharacterStateDefaultSwitchState;             // 0x01E8(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   AudioCharacterDefaultOutfitCollectionState;        // 0x01F8(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_204[0x4];                                      // 0x0204(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OutfitCustomizedAudioChangedDelegate__DelegateSignature(const class FName& OutfitAudioStateCollection);

	class FString GetAudioSwitchState(EAudioCustomizationCategory AudioCustomizationCategory) const;
	class FName GetOutfitCustomizedAudioCollectionState() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomizedAudioComponent">();
	}
	static class UCustomizedAudioComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomizedAudioComponent>();
	}
};
static_assert(alignof(UCustomizedAudioComponent) == 0x000008, "Wrong alignment on UCustomizedAudioComponent");
static_assert(sizeof(UCustomizedAudioComponent) == 0x000208, "Wrong size on UCustomizedAudioComponent");
static_assert(offsetof(UCustomizedAudioComponent, OnCustomizedAudioSwitchStateChanged) == 0x0000A8, "Member 'UCustomizedAudioComponent::OnCustomizedAudioSwitchStateChanged' has a wrong offset!");
static_assert(offsetof(UCustomizedAudioComponent, OnOutfitCustomizedAudioStateCollectionChanged) == 0x0000B8, "Member 'UCustomizedAudioComponent::OnOutfitCustomizedAudioStateCollectionChanged' has a wrong offset!");
static_assert(offsetof(UCustomizedAudioComponent, AudioCharacterNameDefaultSwitchState) == 0x000178, "Member 'UCustomizedAudioComponent::AudioCharacterNameDefaultSwitchState' has a wrong offset!");
static_assert(offsetof(UCustomizedAudioComponent, AudioCharacterSubNameDefaultSwitchState) == 0x000188, "Member 'UCustomizedAudioComponent::AudioCharacterSubNameDefaultSwitchState' has a wrong offset!");
static_assert(offsetof(UCustomizedAudioComponent, AudioCharacterHeadDefaultSwitchState) == 0x000198, "Member 'UCustomizedAudioComponent::AudioCharacterHeadDefaultSwitchState' has a wrong offset!");
static_assert(offsetof(UCustomizedAudioComponent, AudioCharacterClothesDefaultSwitchState) == 0x0001A8, "Member 'UCustomizedAudioComponent::AudioCharacterClothesDefaultSwitchState' has a wrong offset!");
static_assert(offsetof(UCustomizedAudioComponent, AudioCharacterShoesDefaultSwitchState) == 0x0001B8, "Member 'UCustomizedAudioComponent::AudioCharacterShoesDefaultSwitchState' has a wrong offset!");
static_assert(offsetof(UCustomizedAudioComponent, AudioCharacterWeaponDefaultSwitchState) == 0x0001C8, "Member 'UCustomizedAudioComponent::AudioCharacterWeaponDefaultSwitchState' has a wrong offset!");
static_assert(offsetof(UCustomizedAudioComponent, AudioCharacterAmbianceDefaultSwitchState) == 0x0001D8, "Member 'UCustomizedAudioComponent::AudioCharacterAmbianceDefaultSwitchState' has a wrong offset!");
static_assert(offsetof(UCustomizedAudioComponent, AudioCharacterStateDefaultSwitchState) == 0x0001E8, "Member 'UCustomizedAudioComponent::AudioCharacterStateDefaultSwitchState' has a wrong offset!");
static_assert(offsetof(UCustomizedAudioComponent, AudioCharacterDefaultOutfitCollectionState) == 0x0001F8, "Member 'UCustomizedAudioComponent::AudioCharacterDefaultOutfitCollectionState' has a wrong offset!");

// Class DeadByDaylight.DBDPlayerAudioHandlerComponent
// 0x00A0 (0x0148 - 0x00A8)
class UDBDPlayerAudioHandlerComponent : public UActorComponent
{
public:
	class FString                                 _stopMovingRTPC;                                   // 0x00A8(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FDBDCharacterMovementSpeedRTPC> _movementRTPCs;                                    // 0x00B8(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_C8[0x80];                                      // 0x00C8(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDPlayerAudioHandlerComponent">();
	}
	static class UDBDPlayerAudioHandlerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDPlayerAudioHandlerComponent>();
	}
};
static_assert(alignof(UDBDPlayerAudioHandlerComponent) == 0x000008, "Wrong alignment on UDBDPlayerAudioHandlerComponent");
static_assert(sizeof(UDBDPlayerAudioHandlerComponent) == 0x000148, "Wrong size on UDBDPlayerAudioHandlerComponent");
static_assert(offsetof(UDBDPlayerAudioHandlerComponent, _stopMovingRTPC) == 0x0000A8, "Member 'UDBDPlayerAudioHandlerComponent::_stopMovingRTPC' has a wrong offset!");
static_assert(offsetof(UDBDPlayerAudioHandlerComponent, _movementRTPCs) == 0x0000B8, "Member 'UDBDPlayerAudioHandlerComponent::_movementRTPCs' has a wrong offset!");

// Class DeadByDaylight.CustomizedSkeletalMesh
// 0x0378 (0x0420 - 0x00A8)
class UCustomizedSkeletalMesh final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnMeshSwitchBP;                                    // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_B8[0x18];                                      // 0x00B8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnCustomizationReady;                              // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_E0[0x30];                                      // 0x00E0(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class USkinnedMeshComponent*                  _meshOwner;                                        // 0x0110(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_118[0x8];                                      // 0x0118(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<ECustomizationCategory>                  _ignoredItemCategories;                            // 0x0120(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TArray<class USkeletalMeshComponent*>         _cosmeticPiecesMesh;                               // 0x0170(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TMap<ECustomizationCategory, class USkeletalMeshComponent*> _cosmeticPiecesMeshPerCategory;                    // 0x0180(0x0050)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class USkeletalMeshComponent*>         _slaves;                                           // 0x01D0(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TMap<ECustomizationCategory, class AItemVfx*> _itemVfxs;                                         // 0x01E0(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPrivate)
	uint8                                         Pad_230[0xA0];                                     // 0x0230(0x00A0)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _characterIdOverride;                              // 0x02D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D4[0x5C];                                     // 0x02D4(0x005C)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ECustomizationCategory, struct FCosmeticPieceMeshLoadingData> _cosmeticPieceMeshesBeingLoaded;                   // 0x0330(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_380[0xA0];                                     // 0x0380(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearAllVfxs();
	void CopyCustomization(const class UCustomizedSkeletalMesh* CopyFrom);
	class USkinnedMeshComponent* GetMeshOwner();
	void OnCustomizationReadyBP__DelegateSignature();
	void OnMeshSwitchEventBP__DelegateSignature(ECustomizationCategory Category, class USkeletalMeshComponent* Mesh);
	void SetAllAccessoriesVisibility(bool Visible);
	void SetAllVfxsVisibility(bool Visible);
	void SetCastShadow(bool CastShadow);
	void SetMeshOwner(class USkinnedMeshComponent* Mesh);
	void SetMeshVisibility(bool Visible);
	void SetVfxsVisibility(ECustomizationCategory Category, bool Visible);

	bool Contains(const TArray<class FName>& ItemIds) const;
	const TArray<class USkeletalMeshComponent*> GetComponents() const;
	TArray<class FName> GetCurrentCustomizationItems() const;
	class USkeletalMeshComponent* GetSkeletalMesh(ECustomizationCategory Category) const;
	bool HasValidCustomization() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomizedSkeletalMesh">();
	}
	static class UCustomizedSkeletalMesh* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomizedSkeletalMesh>();
	}
};
static_assert(alignof(UCustomizedSkeletalMesh) == 0x000008, "Wrong alignment on UCustomizedSkeletalMesh");
static_assert(sizeof(UCustomizedSkeletalMesh) == 0x000420, "Wrong size on UCustomizedSkeletalMesh");
static_assert(offsetof(UCustomizedSkeletalMesh, OnMeshSwitchBP) == 0x0000A8, "Member 'UCustomizedSkeletalMesh::OnMeshSwitchBP' has a wrong offset!");
static_assert(offsetof(UCustomizedSkeletalMesh, OnCustomizationReady) == 0x0000D0, "Member 'UCustomizedSkeletalMesh::OnCustomizationReady' has a wrong offset!");
static_assert(offsetof(UCustomizedSkeletalMesh, _meshOwner) == 0x000110, "Member 'UCustomizedSkeletalMesh::_meshOwner' has a wrong offset!");
static_assert(offsetof(UCustomizedSkeletalMesh, _ignoredItemCategories) == 0x000120, "Member 'UCustomizedSkeletalMesh::_ignoredItemCategories' has a wrong offset!");
static_assert(offsetof(UCustomizedSkeletalMesh, _cosmeticPiecesMesh) == 0x000170, "Member 'UCustomizedSkeletalMesh::_cosmeticPiecesMesh' has a wrong offset!");
static_assert(offsetof(UCustomizedSkeletalMesh, _cosmeticPiecesMeshPerCategory) == 0x000180, "Member 'UCustomizedSkeletalMesh::_cosmeticPiecesMeshPerCategory' has a wrong offset!");
static_assert(offsetof(UCustomizedSkeletalMesh, _slaves) == 0x0001D0, "Member 'UCustomizedSkeletalMesh::_slaves' has a wrong offset!");
static_assert(offsetof(UCustomizedSkeletalMesh, _itemVfxs) == 0x0001E0, "Member 'UCustomizedSkeletalMesh::_itemVfxs' has a wrong offset!");
static_assert(offsetof(UCustomizedSkeletalMesh, _characterIdOverride) == 0x0002D0, "Member 'UCustomizedSkeletalMesh::_characterIdOverride' has a wrong offset!");
static_assert(offsetof(UCustomizedSkeletalMesh, _cosmeticPieceMeshesBeingLoaded) == 0x000330, "Member 'UCustomizedSkeletalMesh::_cosmeticPieceMeshesBeingLoaded' has a wrong offset!");

// Class DeadByDaylight.CustomWidgetWrapperInitializer
// 0x0010 (0x02B8 - 0x02A8)
class UCustomWidgetWrapperInitializer final : public UUserWidget
{
public:
	class UCustomWidgetWrapper*                   ListeningWrapper;                                  // 0x02A8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B0[0x8];                                      // 0x02B0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomWidgetWrapperInitializer">();
	}
	static class UCustomWidgetWrapperInitializer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomWidgetWrapperInitializer>();
	}
};
static_assert(alignof(UCustomWidgetWrapperInitializer) == 0x000008, "Wrong alignment on UCustomWidgetWrapperInitializer");
static_assert(sizeof(UCustomWidgetWrapperInitializer) == 0x0002B8, "Wrong size on UCustomWidgetWrapperInitializer");
static_assert(offsetof(UCustomWidgetWrapperInitializer, ListeningWrapper) == 0x0002A8, "Member 'UCustomWidgetWrapperInitializer::ListeningWrapper' has a wrong offset!");

// Class DeadByDaylight.SupplyCrateAnimInstance
// 0x0010 (0x0370 - 0x0360)
class USupplyCrateAnimInstance final : public USleepingAnimInstance
{
public:
	class ASupplyCrateInteractable*               _owningSupplyCrate;                                // 0x0360(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isOpen;                                           // 0x0368(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isBeingPriedOpen;                                 // 0x0369(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isAutoClosing;                                    // 0x036A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_36B[0x5];                                      // 0x036B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnBeingPriedOpenStarted(class ADBDPlayer* Player);
	void OnBeingPriedOpenStopped();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SupplyCrateAnimInstance">();
	}
	static class USupplyCrateAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USupplyCrateAnimInstance>();
	}
};
static_assert(alignof(USupplyCrateAnimInstance) == 0x000010, "Wrong alignment on USupplyCrateAnimInstance");
static_assert(sizeof(USupplyCrateAnimInstance) == 0x000370, "Wrong size on USupplyCrateAnimInstance");
static_assert(offsetof(USupplyCrateAnimInstance, _owningSupplyCrate) == 0x000360, "Member 'USupplyCrateAnimInstance::_owningSupplyCrate' has a wrong offset!");
static_assert(offsetof(USupplyCrateAnimInstance, _isOpen) == 0x000368, "Member 'USupplyCrateAnimInstance::_isOpen' has a wrong offset!");
static_assert(offsetof(USupplyCrateAnimInstance, _isBeingPriedOpen) == 0x000369, "Member 'USupplyCrateAnimInstance::_isBeingPriedOpen' has a wrong offset!");
static_assert(offsetof(USupplyCrateAnimInstance, _isAutoClosing) == 0x00036A, "Member 'USupplyCrateAnimInstance::_isAutoClosing' has a wrong offset!");

// Class DeadByDaylight.CustomWidgetWrapper_InGame
// 0x0038 (0x0220 - 0x01E8)
class UCustomWidgetWrapper_InGame final : public UCustomWidgetWrapper
{
public:
	int32                                         VirtualJoystickIndex;                              // 0x01E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1EC[0x34];                                     // 0x01EC(0x0034)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void UpdateSettings();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomWidgetWrapper_InGame">();
	}
	static class UCustomWidgetWrapper_InGame* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomWidgetWrapper_InGame>();
	}
};
static_assert(alignof(UCustomWidgetWrapper_InGame) == 0x000008, "Wrong alignment on UCustomWidgetWrapper_InGame");
static_assert(sizeof(UCustomWidgetWrapper_InGame) == 0x000220, "Wrong size on UCustomWidgetWrapper_InGame");
static_assert(offsetof(UCustomWidgetWrapper_InGame, VirtualJoystickIndex) == 0x0001E8, "Member 'UCustomWidgetWrapper_InGame::VirtualJoystickIndex' has a wrong offset!");

// Class DeadByDaylight.DynamicGrassEffectorInterface
// 0x0000 (0x0030 - 0x0030)
class IDynamicGrassEffectorInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicGrassEffectorInterface">();
	}
	static class IDynamicGrassEffectorInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IDynamicGrassEffectorInterface>();
	}
};
static_assert(alignof(IDynamicGrassEffectorInterface) == 0x000008, "Wrong alignment on IDynamicGrassEffectorInterface");
static_assert(sizeof(IDynamicGrassEffectorInterface) == 0x000030, "Wrong size on IDynamicGrassEffectorInterface");

// Class DeadByDaylight.DailyRitualsScreen
// 0x0060 (0x0188 - 0x0128)
class UDailyRitualsScreen final : public UScreenBase
{
public:
	uint8                                         Pad_128[0x60];                                     // 0x0128(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnClaimAllRituals();
	void OnClaimRitual(const class FString& ID);
	void OnClosed();
	void OnRemoveRitual(const class FString& ID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DailyRitualsScreen">();
	}
	static class UDailyRitualsScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDailyRitualsScreen>();
	}
};
static_assert(alignof(UDailyRitualsScreen) == 0x000008, "Wrong alignment on UDailyRitualsScreen");
static_assert(sizeof(UDailyRitualsScreen) == 0x000188, "Wrong size on UDailyRitualsScreen");

// Class DeadByDaylight.shopmanager
// 0x0710 (0x0740 - 0x0030)
class UShopmanager : public UObject
{
public:
	uint8                                         Pad_30[0x40];                                      // 0x0030(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UDBDGameInstance>        _gameInstance;                                     // 0x0070(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_78[0x6C8];                                     // 0x0078(0x06C8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"shopmanager">();
	}
	static class UShopmanager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShopmanager>();
	}
};
static_assert(alignof(UShopmanager) == 0x000008, "Wrong alignment on UShopmanager");
static_assert(sizeof(UShopmanager) == 0x000740, "Wrong size on UShopmanager");
static_assert(offsetof(UShopmanager, _gameInstance) == 0x000070, "Member 'UShopmanager::_gameInstance' has a wrong offset!");

// Class DeadByDaylight.DBDBaseActorSpawnerActor2
// 0x0010 (0x02B0 - 0x02A0)
class ADBDBaseActorSpawnerActor2 : public AActor
{
public:
	uint8                                         Pad_2A0[0x10];                                     // 0x02A0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDBaseActorSpawnerActor2">();
	}
	static class ADBDBaseActorSpawnerActor2* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDBaseActorSpawnerActor2>();
	}
};
static_assert(alignof(ADBDBaseActorSpawnerActor2) == 0x000008, "Wrong alignment on ADBDBaseActorSpawnerActor2");
static_assert(sizeof(ADBDBaseActorSpawnerActor2) == 0x0002B0, "Wrong size on ADBDBaseActorSpawnerActor2");

// Class DeadByDaylight.DBDPlayerPositionOffsetComponent
// 0x0008 (0x00B0 - 0x00A8)
class UDBDPlayerPositionOffsetComponent final : public UActorComponent
{
public:
	struct FPerPlatformFloat                      _menuZHeadOffset;                                  // 0x00A8(0x0004)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDPlayerPositionOffsetComponent">();
	}
	static class UDBDPlayerPositionOffsetComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDPlayerPositionOffsetComponent>();
	}
};
static_assert(alignof(UDBDPlayerPositionOffsetComponent) == 0x000008, "Wrong alignment on UDBDPlayerPositionOffsetComponent");
static_assert(sizeof(UDBDPlayerPositionOffsetComponent) == 0x0000B0, "Wrong size on UDBDPlayerPositionOffsetComponent");
static_assert(offsetof(UDBDPlayerPositionOffsetComponent, _menuZHeadOffset) == 0x0000A8, "Member 'UDBDPlayerPositionOffsetComponent::_menuZHeadOffset' has a wrong offset!");

// Class DeadByDaylight.DBDActorSpawnerActor2
// 0x0008 (0x02B8 - 0x02B0)
class ADBDActorSpawnerActor2 final : public ADBDBaseActorSpawnerActor2
{
public:
	class UActorSpawner*                          ActorSpawnerComponent;                             // 0x02B0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDActorSpawnerActor2">();
	}
	static class ADBDActorSpawnerActor2* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDActorSpawnerActor2>();
	}
};
static_assert(alignof(ADBDActorSpawnerActor2) == 0x000008, "Wrong alignment on ADBDActorSpawnerActor2");
static_assert(sizeof(ADBDActorSpawnerActor2) == 0x0002B8, "Wrong size on ADBDActorSpawnerActor2");
static_assert(offsetof(ADBDActorSpawnerActor2, ActorSpawnerComponent) == 0x0002B0, "Member 'ADBDActorSpawnerActor2::ActorSpawnerComponent' has a wrong offset!");

// Class DeadByDaylight.DBDTileSpawnPointActor2
// 0x0008 (0x02B8 - 0x02B0)
class ADBDTileSpawnPointActor2 final : public ADBDBaseActorSpawnerActor2
{
public:
	class UTileSpawnPoint*                        TileSpawnPointComponent;                           // 0x02B0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDTileSpawnPointActor2">();
	}
	static class ADBDTileSpawnPointActor2* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDTileSpawnPointActor2>();
	}
};
static_assert(alignof(ADBDTileSpawnPointActor2) == 0x000008, "Wrong alignment on ADBDTileSpawnPointActor2");
static_assert(sizeof(ADBDTileSpawnPointActor2) == 0x0002B8, "Wrong size on ADBDTileSpawnPointActor2");
static_assert(offsetof(ADBDTileSpawnPointActor2, TileSpawnPointComponent) == 0x0002B0, "Member 'ADBDTileSpawnPointActor2::TileSpawnPointComponent' has a wrong offset!");

// Class DeadByDaylight.EndGameComponent
// 0x00A0 (0x0148 - 0x00A8)
class UEndGameComponent : public UActorComponent
{
public:
	int32                                         _closedHatchesRequiredCount;                       // 0x00A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_AC[0x9C];                                      // 0x00AC(0x009C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DisableEndGameScenario();
	void FireEndGameSacrificeScoreEvent(const struct FGameEventData& GameEventData);
	void PauseEndGameTimer();
	void StartEndGame_Cheat();
	void UnpauseEndGameTimer();

	bool GetHasEndGameBegun() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndGameComponent">();
	}
	static class UEndGameComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndGameComponent>();
	}
};
static_assert(alignof(UEndGameComponent) == 0x000008, "Wrong alignment on UEndGameComponent");
static_assert(sizeof(UEndGameComponent) == 0x000148, "Wrong size on UEndGameComponent");
static_assert(offsetof(UEndGameComponent, _closedHatchesRequiredCount) == 0x0000A8, "Member 'UEndGameComponent::_closedHatchesRequiredCount' has a wrong offset!");

// Class DeadByDaylight.TutorialEndGameComponent
// 0x0008 (0x0150 - 0x0148)
class UTutorialEndGameComponent final : public UEndGameComponent
{
public:
	float                                         _timerMaxCompletionPercentage;                     // 0x0148(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_14C[0x4];                                      // 0x014C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetTimerMaxCompletionPercentage(const float& Percentage);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TutorialEndGameComponent">();
	}
	static class UTutorialEndGameComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTutorialEndGameComponent>();
	}
};
static_assert(alignof(UTutorialEndGameComponent) == 0x000008, "Wrong alignment on UTutorialEndGameComponent");
static_assert(sizeof(UTutorialEndGameComponent) == 0x000150, "Wrong size on UTutorialEndGameComponent");
static_assert(offsetof(UTutorialEndGameComponent, _timerMaxCompletionPercentage) == 0x000148, "Member 'UTutorialEndGameComponent::_timerMaxCompletionPercentage' has a wrong offset!");

// Class DeadByDaylight.EffectsLocator
// 0x0068 (0x0308 - 0x02A0)
class AEffectsLocator final : public AActor
{
public:
	TArray<struct FEffectsLocatorTargets>         AffectedActors;                                    // 0x02A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         ActorCaptureRadius;                                // 0x02B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B4[0x4];                                      // 0x02B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class AActor*>                           _encountered;                                      // 0x02B8(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)

public:
	void OnActorTick(class UMaterialInstanceDynamic* ActorMaterialInstanceDynamic);
	void OnEnterCollisionArea(class AActor* OverlappedActor, class AActor* OtherActor);
	void OnFoundActor(class AActor* FoundActor);
	void OnLeaveCollisionArea(class AActor* OverlappedActor, class AActor* OtherActor);
	void OnLostActor(class AActor* LostActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EffectsLocator">();
	}
	static class AEffectsLocator* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEffectsLocator>();
	}
};
static_assert(alignof(AEffectsLocator) == 0x000008, "Wrong alignment on AEffectsLocator");
static_assert(sizeof(AEffectsLocator) == 0x000308, "Wrong size on AEffectsLocator");
static_assert(offsetof(AEffectsLocator, AffectedActors) == 0x0002A0, "Member 'AEffectsLocator::AffectedActors' has a wrong offset!");
static_assert(offsetof(AEffectsLocator, ActorCaptureRadius) == 0x0002B0, "Member 'AEffectsLocator::ActorCaptureRadius' has a wrong offset!");
static_assert(offsetof(AEffectsLocator, _encountered) == 0x0002B8, "Member 'AEffectsLocator::_encountered' has a wrong offset!");

// Class DeadByDaylight.DBDActorVariationSpawnerActor2
// 0x0008 (0x02B8 - 0x02B0)
class ADBDActorVariationSpawnerActor2 final : public ADBDBaseActorSpawnerActor2
{
public:
	class UActorVariationSpawner*                 ActorVariationSpawnerComponent;                    // 0x02B0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDActorVariationSpawnerActor2">();
	}
	static class ADBDActorVariationSpawnerActor2* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDActorVariationSpawnerActor2>();
	}
};
static_assert(alignof(ADBDActorVariationSpawnerActor2) == 0x000008, "Wrong alignment on ADBDActorVariationSpawnerActor2");
static_assert(sizeof(ADBDActorVariationSpawnerActor2) == 0x0002B8, "Wrong size on ADBDActorVariationSpawnerActor2");
static_assert(offsetof(ADBDActorVariationSpawnerActor2, ActorVariationSpawnerComponent) == 0x0002B0, "Member 'ADBDActorVariationSpawnerActor2::ActorVariationSpawnerComponent' has a wrong offset!");

// Class DeadByDaylight.TileMatrix
// 0x0058 (0x0088 - 0x0030)
class UTileMatrix final : public UObject
{
public:
	TArray<struct FArrayOfATile>                  _matrix;                                           // 0x0030(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class ATile*>                          _tiles;                                            // 0x0040(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class ATile*>                          _extraTiles;                                       // 0x0050(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class AActor*                                 _basementActor;                                    // 0x0060(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FQuadrantInfo>                  _quadInfoArray;                                    // 0x0068(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<struct FArrayOfInt32>                  _quadIndexMatrix;                                  // 0x0078(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TileMatrix">();
	}
	static class UTileMatrix* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTileMatrix>();
	}
};
static_assert(alignof(UTileMatrix) == 0x000008, "Wrong alignment on UTileMatrix");
static_assert(sizeof(UTileMatrix) == 0x000088, "Wrong size on UTileMatrix");
static_assert(offsetof(UTileMatrix, _matrix) == 0x000030, "Member 'UTileMatrix::_matrix' has a wrong offset!");
static_assert(offsetof(UTileMatrix, _tiles) == 0x000040, "Member 'UTileMatrix::_tiles' has a wrong offset!");
static_assert(offsetof(UTileMatrix, _extraTiles) == 0x000050, "Member 'UTileMatrix::_extraTiles' has a wrong offset!");
static_assert(offsetof(UTileMatrix, _basementActor) == 0x000060, "Member 'UTileMatrix::_basementActor' has a wrong offset!");
static_assert(offsetof(UTileMatrix, _quadInfoArray) == 0x000068, "Member 'UTileMatrix::_quadInfoArray' has a wrong offset!");
static_assert(offsetof(UTileMatrix, _quadIndexMatrix) == 0x000078, "Member 'UTileMatrix::_quadIndexMatrix' has a wrong offset!");

// Class DeadByDaylight.DBDAggregateCullDistanceVolumes
// 0x0000 (0x02A0 - 0x02A0)
class ADBDAggregateCullDistanceVolumes final : public AActor
{
public:
	void SpawnCullDistanceVolumes();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDAggregateCullDistanceVolumes">();
	}
	static class ADBDAggregateCullDistanceVolumes* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDAggregateCullDistanceVolumes>();
	}
};
static_assert(alignof(ADBDAggregateCullDistanceVolumes) == 0x000008, "Wrong alignment on ADBDAggregateCullDistanceVolumes");
static_assert(sizeof(ADBDAggregateCullDistanceVolumes) == 0x0002A0, "Wrong size on ADBDAggregateCullDistanceVolumes");

// Class DeadByDaylight.SpecialEventsContainer
// 0x0278 (0x02A8 - 0x0030)
class USpecialEventsContainer final : public UObject
{
public:
	uint8                                         Pad_30[0x278];                                     // 0x0030(0x0278)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpecialEventsContainer">();
	}
	static class USpecialEventsContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpecialEventsContainer>();
	}
};
static_assert(alignof(USpecialEventsContainer) == 0x000008, "Wrong alignment on USpecialEventsContainer");
static_assert(sizeof(USpecialEventsContainer) == 0x0002A8, "Wrong size on USpecialEventsContainer");

// Class DeadByDaylight.DBDAggregateParticleSystemComponent
// 0x0060 (0x0920 - 0x08C0)
class UDBDAggregateParticleSystemComponent final : public UParticleSystemComponent
{
public:
	float                                         CullAngle;                                         // 0x08B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EndFadeDistance;                                   // 0x08BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSet<class USceneComponent*>                  LocatorComponentCache;                             // 0x08C0(0x0050)(ExportObject, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	bool                                          PendingReset;                                      // 0x0910(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_911[0xF];                                      // 0x0911(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDAggregateParticleSystemComponent">();
	}
	static class UDBDAggregateParticleSystemComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDAggregateParticleSystemComponent>();
	}
};
static_assert(alignof(UDBDAggregateParticleSystemComponent) == 0x000010, "Wrong alignment on UDBDAggregateParticleSystemComponent");
static_assert(sizeof(UDBDAggregateParticleSystemComponent) == 0x000920, "Wrong size on UDBDAggregateParticleSystemComponent");
static_assert(offsetof(UDBDAggregateParticleSystemComponent, CullAngle) == 0x0008B8, "Member 'UDBDAggregateParticleSystemComponent::CullAngle' has a wrong offset!");
static_assert(offsetof(UDBDAggregateParticleSystemComponent, EndFadeDistance) == 0x0008BC, "Member 'UDBDAggregateParticleSystemComponent::EndFadeDistance' has a wrong offset!");
static_assert(offsetof(UDBDAggregateParticleSystemComponent, LocatorComponentCache) == 0x0008C0, "Member 'UDBDAggregateParticleSystemComponent::LocatorComponentCache' has a wrong offset!");
static_assert(offsetof(UDBDAggregateParticleSystemComponent, PendingReset) == 0x000910, "Member 'UDBDAggregateParticleSystemComponent::PendingReset' has a wrong offset!");

// Class DeadByDaylight.Hatch
// 0x00A0 (0x0448 - 0x03A8)
class AHatch : public AInteractable
{
public:
	uint8                                         Pad_3A8[0x48];                                     // 0x03A8(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	EHatchState                                   _hatchState;                                       // 0x03F0(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3F1[0x1];                                      // 0x03F1(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _isEndGameOver;                                    // 0x03F2(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isForceOpen;                                      // 0x03F3(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3F4[0x4];                                      // 0x03F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UPrimitiveComponent*                    _baseCollision;                                    // 0x03F8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_400[0x10];                                     // 0x0400(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _hatchCloseDelay;                                  // 0x0410(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_438[0x10];                                     // 0x0438(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_CheckedChangeActiveState();
	void Authority_CheckedCloseHatch();
	void Authority_CheckedOpenForceClosedHatch();
	void Authority_CheckedOpenHatch();
	void Authority_OnCloseTimerComplete();
	void Authority_OnEndGameOver(const struct FGameplayTag& GameEventType, const struct FGameEventData& GameEventData);
	void Authority_OnHatchVisibilityChanged(bool IsVisible);
	void Authority_ResetTimer(float Duration);
	void Authority_SetHatchState(EHatchState NewState);
	void Authority_SetIsForceOpen(bool IsForcedOpen);
	void FXCloseHatch();
	void FXEndSmoke();
	void FXOpenHatch();
	void OnHatchStateModified(EHatchState OldState, EHatchState NewState);
	void OnHatchStateUnhidden();
	void OnRep_HatchState(EHatchState OldState);

	class UAnimationMontageSlave* GetAnimationMontageSlave() const;
	class USceneComponent* GetEscapeFocalPoint() const;
	class USceneComponent* GetHatchCenter() const;
	EHatchState GetHatchState() const;
	bool IsOpen() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Hatch">();
	}
	static class AHatch* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHatch>();
	}
};
static_assert(alignof(AHatch) == 0x000008, "Wrong alignment on AHatch");
static_assert(sizeof(AHatch) == 0x000448, "Wrong size on AHatch");
static_assert(offsetof(AHatch, _hatchState) == 0x0003F0, "Member 'AHatch::_hatchState' has a wrong offset!");
static_assert(offsetof(AHatch, _isEndGameOver) == 0x0003F2, "Member 'AHatch::_isEndGameOver' has a wrong offset!");
static_assert(offsetof(AHatch, _isForceOpen) == 0x0003F3, "Member 'AHatch::_isForceOpen' has a wrong offset!");
static_assert(offsetof(AHatch, _baseCollision) == 0x0003F8, "Member 'AHatch::_baseCollision' has a wrong offset!");
static_assert(offsetof(AHatch, _hatchCloseDelay) == 0x000410, "Member 'AHatch::_hatchCloseDelay' has a wrong offset!");

// Class DeadByDaylight.DBDAggregateParticleManager
// 0x0000 (0x02A0 - 0x02A0)
class ADBDAggregateParticleManager : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDAggregateParticleManager">();
	}
	static class ADBDAggregateParticleManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDAggregateParticleManager>();
	}
};
static_assert(alignof(ADBDAggregateParticleManager) == 0x000008, "Wrong alignment on ADBDAggregateParticleManager");
static_assert(sizeof(ADBDAggregateParticleManager) == 0x0002A0, "Wrong size on ADBDAggregateParticleManager");

// Class DeadByDaylight.DBDLocatorComponent
// 0x0000 (0x02C0 - 0x02C0)
class UDBDLocatorComponent : public USceneComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDLocatorComponent">();
	}
	static class UDBDLocatorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDLocatorComponent>();
	}
};
static_assert(alignof(UDBDLocatorComponent) == 0x000010, "Wrong alignment on UDBDLocatorComponent");
static_assert(sizeof(UDBDLocatorComponent) == 0x0002C0, "Wrong size on UDBDLocatorComponent");

// Class DeadByDaylight.DBDSpecialEventUtilities
// 0x0000 (0x0030 - 0x0030)
class UDBDSpecialEventUtilities final : public UBlueprintFunctionLibrary
{
public:
	static bool DoesPlayerHasEventOffering(const class ADBDPlayer* Player, EOfferingEffectType OfferingEffectType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDSpecialEventUtilities">();
	}
	static class UDBDSpecialEventUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDSpecialEventUtilities>();
	}
};
static_assert(alignof(UDBDSpecialEventUtilities) == 0x000008, "Wrong alignment on UDBDSpecialEventUtilities");
static_assert(sizeof(UDBDSpecialEventUtilities) == 0x000030, "Wrong size on UDBDSpecialEventUtilities");

// Class DeadByDaylight.DBDAggregateParticleLocatorComponent
// 0x0010 (0x02D0 - 0x02C0)
class UDBDAggregateParticleLocatorComponent final : public UDBDLocatorComponent
{
public:
	class UParticleSystem*                        Template;                                          // 0x02C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C8[0x8];                                      // 0x02C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDAggregateParticleLocatorComponent">();
	}
	static class UDBDAggregateParticleLocatorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDAggregateParticleLocatorComponent>();
	}
};
static_assert(alignof(UDBDAggregateParticleLocatorComponent) == 0x000010, "Wrong alignment on UDBDAggregateParticleLocatorComponent");
static_assert(sizeof(UDBDAggregateParticleLocatorComponent) == 0x0002D0, "Wrong size on UDBDAggregateParticleLocatorComponent");
static_assert(offsetof(UDBDAggregateParticleLocatorComponent, Template) == 0x0002C0, "Member 'UDBDAggregateParticleLocatorComponent::Template' has a wrong offset!");

// Class DeadByDaylight.DBDAIPlayerController
// 0x0028 (0x0878 - 0x0850)
class ADBDAIPlayerController final : public ADBDAIController
{
public:
	uint8                                         Pad_850[0x18];                                     // 0x0850(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UAICharacterBehaviour*>          _currentBehaviours;                                // 0x0868(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	void MovePlayerToActor(class AActor* Goal, float AcceptanceRadius);
	void OnBehaviourEndedHandler(class UAICharacterBehaviour* behaviourEnded);
	void PauseCharacterBehaviour(const class UClass* behaviourClass);
	void ResumeCharacterBehaviour(const class UClass* behaviourClass);
	void StartCharacterBehaviour(class UClass* behaviourClass, class UAICharacterBehaviourData* CharacterBehaviourData);
	void StopAllCharacterBehaviours();
	void StopCharacterBehaviour(const class UClass* behaviourClass);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDAIPlayerController">();
	}
	static class ADBDAIPlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDAIPlayerController>();
	}
};
static_assert(alignof(ADBDAIPlayerController) == 0x000008, "Wrong alignment on ADBDAIPlayerController");
static_assert(sizeof(ADBDAIPlayerController) == 0x000878, "Wrong size on ADBDAIPlayerController");
static_assert(offsetof(ADBDAIPlayerController, _currentBehaviours) == 0x000868, "Member 'ADBDAIPlayerController::_currentBehaviours' has a wrong offset!");

// Class DeadByDaylight.PlayerOverlapHISMComponent
// 0x0010 (0x0990 - 0x0980)
class UPlayerOverlapHISMComponent : public UHISMMaterialHelperComponent
{
public:
	int32                                         _playerInfluenceRadius;                            // 0x0978(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_97C[0x4];                                      // 0x097C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMaterialInterface*>             _playerOverlapOverrides;                           // 0x0980(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerOverlapHISMComponent">();
	}
	static class UPlayerOverlapHISMComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerOverlapHISMComponent>();
	}
};
static_assert(alignof(UPlayerOverlapHISMComponent) == 0x000010, "Wrong alignment on UPlayerOverlapHISMComponent");
static_assert(sizeof(UPlayerOverlapHISMComponent) == 0x000990, "Wrong size on UPlayerOverlapHISMComponent");
static_assert(offsetof(UPlayerOverlapHISMComponent, _playerInfluenceRadius) == 0x000978, "Member 'UPlayerOverlapHISMComponent::_playerInfluenceRadius' has a wrong offset!");
static_assert(offsetof(UPlayerOverlapHISMComponent, _playerOverlapOverrides) == 0x000980, "Member 'UPlayerOverlapHISMComponent::_playerOverlapOverrides' has a wrong offset!");

// Class DeadByDaylight.DBDAITypes
// 0x0228 (0x0258 - 0x0030)
class UDBDAITypes final : public UObject
{
public:
	struct FGameplayTag                           AISkills_Context_Service_Root;                     // 0x0030(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AISkills_Context_Task_Slasher_AttackTarget;        // 0x003C(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AISkills_Context_Service_Slasher_AttackTarget;     // 0x0048(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AISkills_Context_Task_Slasher_CrawlingTarget;      // 0x0054(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AISkills_Context_Service_Slasher_Goals;            // 0x0060(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AISkills_Context_Service_Slasher_CrawlingTarget;   // 0x006C(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AISkills_Context_Service_Slasher_Investigate_NotInChase; // 0x0078(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AISkills_Context_Service_Slasher_Investigate_InChase; // 0x0084(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AISkills_Context_Service_Slasher_Investigate_MoveAround; // 0x0090(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AISkills_Context_Service_Slasher_Patrol;           // 0x009C(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AISkills_Context_Service_Slasher_Patrol_MoveAround; // 0x00A8(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AISkills_Context_Service_Camper_Standing;          // 0x00B4(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AISkills_Context_Service_Camper_Crawling;          // 0x00C0(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AISkills_Context_Service_Camper_Flee_Run_Always;   // 0x00CC(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AISkills_Context_Service_Camper_Flee_Run_InChase;  // 0x00D8(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AISkills_Context_Service_Camper_Flee_Run_NotInChase; // 0x00E4(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AISkills_Context_Service_Camper_Patrol;            // 0x00F0(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AISkills_Context_Service_Camper_RescueCarriedFriend; // 0x00FC(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AISkills_Context_Service_Camper_RemoveTrap;        // 0x0108(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AISkills_Context_Service_Camper_Chained;           // 0x0114(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AISkills_Context_Service_Camper_HelpOther;         // 0x0120(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AISkills_Context_Service_Camper_GoalInTerror;      // 0x012C(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AISkills_Context_Service_Camper_Carried;           // 0x0138(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AISkills_Context_Service_Camper_UseSelfItem;       // 0x0144(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AISkills_Context_Service_Camper_Hiding;            // 0x0150(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AISkills_Context_Service_Camper_InLocker;          // 0x015C(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AISkills_Context_Service_Camper_Flee_InLocker;     // 0x0168(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AISkills_Context_Service_Camper_RepairGenerator;   // 0x0174(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AISkills_Context_Service_Camper_BeforeGoals;       // 0x0180(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AISkills_Context_Service_Camper_UseK32Emp;         // 0x018C(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AIBlackboard_InteractableWishList_FindSkill;       // 0x0198(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AIBlackboard_ActorWishList_FindSkill;              // 0x01A4(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AI_PointOfInterest_ActivatedDoor;                  // 0x01B0(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AI_PointOfInterest_ActivatedDoor_Opened;           // 0x01BC(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AI_PointOfInterest_BrokenGenerator;                // 0x01C8(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AI_PointOfInterest_OccupiedMeatHook;               // 0x01D4(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AI_PointOfInterest_HexTotem;                       // 0x01E0(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AI_Hearing_SilenceStatusEffect_Header;             // 0x01EC(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AI_PinLocation_WarpStart;                          // 0x01F8(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AI_PinLocation_WarpEnd;                            // 0x0204(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AI_PinLocation_EQS;                                // 0x0210(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AI_PinLocation_WishedObj;                          // 0x021C(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AI_PinLocation_GoTo;                               // 0x0228(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AI_PinObject_EQS;                                  // 0x0234(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AI_PinObject_WishedObj;                            // 0x0240(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AI_PinObject_GoTo;                                 // 0x024C(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDAITypes">();
	}
	static class UDBDAITypes* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDAITypes>();
	}
};
static_assert(alignof(UDBDAITypes) == 0x000008, "Wrong alignment on UDBDAITypes");
static_assert(sizeof(UDBDAITypes) == 0x000258, "Wrong size on UDBDAITypes");
static_assert(offsetof(UDBDAITypes, AISkills_Context_Service_Root) == 0x000030, "Member 'UDBDAITypes::AISkills_Context_Service_Root' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AISkills_Context_Task_Slasher_AttackTarget) == 0x00003C, "Member 'UDBDAITypes::AISkills_Context_Task_Slasher_AttackTarget' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AISkills_Context_Service_Slasher_AttackTarget) == 0x000048, "Member 'UDBDAITypes::AISkills_Context_Service_Slasher_AttackTarget' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AISkills_Context_Task_Slasher_CrawlingTarget) == 0x000054, "Member 'UDBDAITypes::AISkills_Context_Task_Slasher_CrawlingTarget' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AISkills_Context_Service_Slasher_Goals) == 0x000060, "Member 'UDBDAITypes::AISkills_Context_Service_Slasher_Goals' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AISkills_Context_Service_Slasher_CrawlingTarget) == 0x00006C, "Member 'UDBDAITypes::AISkills_Context_Service_Slasher_CrawlingTarget' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AISkills_Context_Service_Slasher_Investigate_NotInChase) == 0x000078, "Member 'UDBDAITypes::AISkills_Context_Service_Slasher_Investigate_NotInChase' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AISkills_Context_Service_Slasher_Investigate_InChase) == 0x000084, "Member 'UDBDAITypes::AISkills_Context_Service_Slasher_Investigate_InChase' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AISkills_Context_Service_Slasher_Investigate_MoveAround) == 0x000090, "Member 'UDBDAITypes::AISkills_Context_Service_Slasher_Investigate_MoveAround' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AISkills_Context_Service_Slasher_Patrol) == 0x00009C, "Member 'UDBDAITypes::AISkills_Context_Service_Slasher_Patrol' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AISkills_Context_Service_Slasher_Patrol_MoveAround) == 0x0000A8, "Member 'UDBDAITypes::AISkills_Context_Service_Slasher_Patrol_MoveAround' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AISkills_Context_Service_Camper_Standing) == 0x0000B4, "Member 'UDBDAITypes::AISkills_Context_Service_Camper_Standing' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AISkills_Context_Service_Camper_Crawling) == 0x0000C0, "Member 'UDBDAITypes::AISkills_Context_Service_Camper_Crawling' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AISkills_Context_Service_Camper_Flee_Run_Always) == 0x0000CC, "Member 'UDBDAITypes::AISkills_Context_Service_Camper_Flee_Run_Always' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AISkills_Context_Service_Camper_Flee_Run_InChase) == 0x0000D8, "Member 'UDBDAITypes::AISkills_Context_Service_Camper_Flee_Run_InChase' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AISkills_Context_Service_Camper_Flee_Run_NotInChase) == 0x0000E4, "Member 'UDBDAITypes::AISkills_Context_Service_Camper_Flee_Run_NotInChase' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AISkills_Context_Service_Camper_Patrol) == 0x0000F0, "Member 'UDBDAITypes::AISkills_Context_Service_Camper_Patrol' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AISkills_Context_Service_Camper_RescueCarriedFriend) == 0x0000FC, "Member 'UDBDAITypes::AISkills_Context_Service_Camper_RescueCarriedFriend' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AISkills_Context_Service_Camper_RemoveTrap) == 0x000108, "Member 'UDBDAITypes::AISkills_Context_Service_Camper_RemoveTrap' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AISkills_Context_Service_Camper_Chained) == 0x000114, "Member 'UDBDAITypes::AISkills_Context_Service_Camper_Chained' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AISkills_Context_Service_Camper_HelpOther) == 0x000120, "Member 'UDBDAITypes::AISkills_Context_Service_Camper_HelpOther' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AISkills_Context_Service_Camper_GoalInTerror) == 0x00012C, "Member 'UDBDAITypes::AISkills_Context_Service_Camper_GoalInTerror' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AISkills_Context_Service_Camper_Carried) == 0x000138, "Member 'UDBDAITypes::AISkills_Context_Service_Camper_Carried' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AISkills_Context_Service_Camper_UseSelfItem) == 0x000144, "Member 'UDBDAITypes::AISkills_Context_Service_Camper_UseSelfItem' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AISkills_Context_Service_Camper_Hiding) == 0x000150, "Member 'UDBDAITypes::AISkills_Context_Service_Camper_Hiding' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AISkills_Context_Service_Camper_InLocker) == 0x00015C, "Member 'UDBDAITypes::AISkills_Context_Service_Camper_InLocker' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AISkills_Context_Service_Camper_Flee_InLocker) == 0x000168, "Member 'UDBDAITypes::AISkills_Context_Service_Camper_Flee_InLocker' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AISkills_Context_Service_Camper_RepairGenerator) == 0x000174, "Member 'UDBDAITypes::AISkills_Context_Service_Camper_RepairGenerator' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AISkills_Context_Service_Camper_BeforeGoals) == 0x000180, "Member 'UDBDAITypes::AISkills_Context_Service_Camper_BeforeGoals' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AISkills_Context_Service_Camper_UseK32Emp) == 0x00018C, "Member 'UDBDAITypes::AISkills_Context_Service_Camper_UseK32Emp' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AIBlackboard_InteractableWishList_FindSkill) == 0x000198, "Member 'UDBDAITypes::AIBlackboard_InteractableWishList_FindSkill' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AIBlackboard_ActorWishList_FindSkill) == 0x0001A4, "Member 'UDBDAITypes::AIBlackboard_ActorWishList_FindSkill' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AI_PointOfInterest_ActivatedDoor) == 0x0001B0, "Member 'UDBDAITypes::AI_PointOfInterest_ActivatedDoor' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AI_PointOfInterest_ActivatedDoor_Opened) == 0x0001BC, "Member 'UDBDAITypes::AI_PointOfInterest_ActivatedDoor_Opened' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AI_PointOfInterest_BrokenGenerator) == 0x0001C8, "Member 'UDBDAITypes::AI_PointOfInterest_BrokenGenerator' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AI_PointOfInterest_OccupiedMeatHook) == 0x0001D4, "Member 'UDBDAITypes::AI_PointOfInterest_OccupiedMeatHook' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AI_PointOfInterest_HexTotem) == 0x0001E0, "Member 'UDBDAITypes::AI_PointOfInterest_HexTotem' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AI_Hearing_SilenceStatusEffect_Header) == 0x0001EC, "Member 'UDBDAITypes::AI_Hearing_SilenceStatusEffect_Header' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AI_PinLocation_WarpStart) == 0x0001F8, "Member 'UDBDAITypes::AI_PinLocation_WarpStart' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AI_PinLocation_WarpEnd) == 0x000204, "Member 'UDBDAITypes::AI_PinLocation_WarpEnd' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AI_PinLocation_EQS) == 0x000210, "Member 'UDBDAITypes::AI_PinLocation_EQS' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AI_PinLocation_WishedObj) == 0x00021C, "Member 'UDBDAITypes::AI_PinLocation_WishedObj' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AI_PinLocation_GoTo) == 0x000228, "Member 'UDBDAITypes::AI_PinLocation_GoTo' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AI_PinObject_EQS) == 0x000234, "Member 'UDBDAITypes::AI_PinObject_EQS' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AI_PinObject_WishedObj) == 0x000240, "Member 'UDBDAITypes::AI_PinObject_WishedObj' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AI_PinObject_GoTo) == 0x00024C, "Member 'UDBDAITypes::AI_PinObject_GoTo' has a wrong offset!");

// Class DeadByDaylight.DBDAnimationBudgetAllocatorActivator
// 0x0030 (0x00D8 - 0x00A8)
class UDBDAnimationBudgetAllocatorActivator final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x30];                                      // 0x00A8(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDAnimationBudgetAllocatorActivator">();
	}
	static class UDBDAnimationBudgetAllocatorActivator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDAnimationBudgetAllocatorActivator>();
	}
};
static_assert(alignof(UDBDAnimationBudgetAllocatorActivator) == 0x000008, "Wrong alignment on UDBDAnimationBudgetAllocatorActivator");
static_assert(sizeof(UDBDAnimationBudgetAllocatorActivator) == 0x0000D8, "Wrong size on UDBDAnimationBudgetAllocatorActivator");

// Class DeadByDaylight.DBDAssetManager
// 0x0000 (0x04F0 - 0x04F0)
class UDBDAssetManager final : public UAssetManager
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDAssetManager">();
	}
	static class UDBDAssetManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDAssetManager>();
	}
};
static_assert(alignof(UDBDAssetManager) == 0x000008, "Wrong alignment on UDBDAssetManager");
static_assert(sizeof(UDBDAssetManager) == 0x0004F0, "Wrong size on UDBDAssetManager");

// Class DeadByDaylight.HookableComponent
// 0x0180 (0x0228 - 0x00A8)
class UHookableComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             Cosmetic_OnDrainStateChanged;                      // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_B8[0x70];                                      // 0x00B8(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _drainStage;                                       // 0x0128(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_12C[0xFC];                                     // 0x012C(0x00FC)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_DebugSetHookDrainStage(int32 DrainStage);
	void Authority_DebugSetHookEscapeAutoFail(const bool Fail);
	void Authority_DebugSetHookEscapeAutoSuccess(const bool Success);
	void Multicast_DebugSetHookDrainStage(int32 DrainStage);
	void Multicast_SetDrainTimerPercentLeft(float PercentTime);
	void OnDrainStateChangeFX__DelegateSignature(int32 DrainState);
	void OnRep_DrainStage(int32 PreviousDrainStage);

	int32 GetDrainStage() const;
	float GetDrainTimerPercentLeft() const;
	int32 GetHookedCount() const;
	int32 GetSacrificeStageIndex() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HookableComponent">();
	}
	static class UHookableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHookableComponent>();
	}
};
static_assert(alignof(UHookableComponent) == 0x000008, "Wrong alignment on UHookableComponent");
static_assert(sizeof(UHookableComponent) == 0x000228, "Wrong size on UHookableComponent");
static_assert(offsetof(UHookableComponent, Cosmetic_OnDrainStateChanged) == 0x0000A8, "Member 'UHookableComponent::Cosmetic_OnDrainStateChanged' has a wrong offset!");
static_assert(offsetof(UHookableComponent, _drainStage) == 0x000128, "Member 'UHookableComponent::_drainStage' has a wrong offset!");

// Class DeadByDaylight.DBDHostSettingsParamsRanking
// 0x0008 (0x0048 - 0x0040)
class UDBDHostSettingsParamsRanking final : public UDBDHostSettingsParamsBase
{
public:
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDHostSettingsParamsRanking">();
	}
	static class UDBDHostSettingsParamsRanking* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDHostSettingsParamsRanking>();
	}
};
static_assert(alignof(UDBDHostSettingsParamsRanking) == 0x000008, "Wrong alignment on UDBDHostSettingsParamsRanking");
static_assert(sizeof(UDBDHostSettingsParamsRanking) == 0x000048, "Wrong size on UDBDHostSettingsParamsRanking");

// Class DeadByDaylight.DBDAtlantaTutorialParameters
// 0x0008 (0x0038 - 0x0030)
class UDBDAtlantaTutorialParameters final : public UObject
{
public:
	float                                         SurvTutorial_WiggleChargeRateMultiplier;           // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoClear, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDAtlantaTutorialParameters">();
	}
	static class UDBDAtlantaTutorialParameters* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDAtlantaTutorialParameters>();
	}
};
static_assert(alignof(UDBDAtlantaTutorialParameters) == 0x000008, "Wrong alignment on UDBDAtlantaTutorialParameters");
static_assert(sizeof(UDBDAtlantaTutorialParameters) == 0x000038, "Wrong size on UDBDAtlantaTutorialParameters");
static_assert(offsetof(UDBDAtlantaTutorialParameters, SurvTutorial_WiggleChargeRateMultiplier) == 0x000030, "Member 'UDBDAtlantaTutorialParameters::SurvTutorial_WiggleChargeRateMultiplier' has a wrong offset!");

// Class DeadByDaylight.DBDAttackerComponent
// 0x0120 (0x01C8 - 0x00A8)
class UDBDAttackerComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnAttackStartDelegate;                             // 0x00A8(0x0010)(ZeroConstructor, Transient, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnAttackFinishDelegate;                            // 0x00B8(0x0010)(ZeroConstructor, Transient, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_C8[0x38];                                      // 0x00C8(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _autonomousHitPredictionDelay;                     // 0x0100(0x0028)(Edit, NativeAccessSpecifierPrivate)
	TArray<class UDBDAttack*>                     _attacks;                                          // 0x0128(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_138[0x10];                                     // 0x0138(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UDBDAttack*                             _requestedAttack;                                  // 0x0148(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDBDAttack*                             _currentAttack;                                    // 0x0150(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_158[0x60];                                     // 0x0158(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAttackDelegatePair>            _attackHitDelegates;                               // 0x01B8(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	void Local_RequestAttack(const EAttackType AttackType);
	void Multicast_StoreAttack(const EAttackType AttackType);
	void OnAttackPhaseChangedDelegate__DelegateSignature(const EAttackType AttackType);
	void Server_StoreAttack(const EAttackType AttackType);

	bool IsAnyAttackTransitionRequested() const;
	bool IsAttacking() const;
	bool IsAttackTransitionRequested(const EAttackType AttackType) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDAttackerComponent">();
	}
	static class UDBDAttackerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDAttackerComponent>();
	}
};
static_assert(alignof(UDBDAttackerComponent) == 0x000008, "Wrong alignment on UDBDAttackerComponent");
static_assert(sizeof(UDBDAttackerComponent) == 0x0001C8, "Wrong size on UDBDAttackerComponent");
static_assert(offsetof(UDBDAttackerComponent, OnAttackStartDelegate) == 0x0000A8, "Member 'UDBDAttackerComponent::OnAttackStartDelegate' has a wrong offset!");
static_assert(offsetof(UDBDAttackerComponent, OnAttackFinishDelegate) == 0x0000B8, "Member 'UDBDAttackerComponent::OnAttackFinishDelegate' has a wrong offset!");
static_assert(offsetof(UDBDAttackerComponent, _autonomousHitPredictionDelay) == 0x000100, "Member 'UDBDAttackerComponent::_autonomousHitPredictionDelay' has a wrong offset!");
static_assert(offsetof(UDBDAttackerComponent, _attacks) == 0x000128, "Member 'UDBDAttackerComponent::_attacks' has a wrong offset!");
static_assert(offsetof(UDBDAttackerComponent, _requestedAttack) == 0x000148, "Member 'UDBDAttackerComponent::_requestedAttack' has a wrong offset!");
static_assert(offsetof(UDBDAttackerComponent, _currentAttack) == 0x000150, "Member 'UDBDAttackerComponent::_currentAttack' has a wrong offset!");
static_assert(offsetof(UDBDAttackerComponent, _attackHitDelegates) == 0x0001B8, "Member 'UDBDAttackerComponent::_attackHitDelegates' has a wrong offset!");

// Class DeadByDaylight.StoreRecommendationSubsystem
// 0x0080 (0x00B8 - 0x0038)
class UStoreRecommendationSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x78];                                      // 0x0038(0x0078)(Fixing Size After Last Property [ Dumper-7 ])
	class URemoteContentCacheSubsystem*           _remoteContentCacheSubsystem;                      // 0x00B0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StoreRecommendationSubsystem">();
	}
	static class UStoreRecommendationSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStoreRecommendationSubsystem>();
	}
};
static_assert(alignof(UStoreRecommendationSubsystem) == 0x000008, "Wrong alignment on UStoreRecommendationSubsystem");
static_assert(sizeof(UStoreRecommendationSubsystem) == 0x0000B8, "Wrong size on UStoreRecommendationSubsystem");
static_assert(offsetof(UStoreRecommendationSubsystem, _remoteContentCacheSubsystem) == 0x0000B0, "Member 'UStoreRecommendationSubsystem::_remoteContentCacheSubsystem' has a wrong offset!");

// Class DeadByDaylight.DBDMistManager
// 0x0008 (0x02A8 - 0x02A0)
class ADBDMistManager final : public AActor
{
public:
	class UDBDAggregateParticleSystemComponent*   _particleSystemComp;                               // 0x02A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDMistManager">();
	}
	static class ADBDMistManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDMistManager>();
	}
};
static_assert(alignof(ADBDMistManager) == 0x000008, "Wrong alignment on ADBDMistManager");
static_assert(sizeof(ADBDMistManager) == 0x0002A8, "Wrong size on ADBDMistManager");
static_assert(offsetof(ADBDMistManager, _particleSystemComp) == 0x0002A0, "Member 'ADBDMistManager::_particleSystemComp' has a wrong offset!");

// Class DeadByDaylight.DBDBaseInputHandler
// 0x00A8 (0x00D8 - 0x0030)
class UDBDBaseInputHandler final : public UObject
{
public:
	class APawn*                                  _pawn;                                             // 0x0030(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USpringArmComponent*                    _cameraBoom;                                       // 0x0038(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_40[0x98];                                      // 0x0040(0x0098)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDBaseInputHandler">();
	}
	static class UDBDBaseInputHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDBaseInputHandler>();
	}
};
static_assert(alignof(UDBDBaseInputHandler) == 0x000008, "Wrong alignment on UDBDBaseInputHandler");
static_assert(sizeof(UDBDBaseInputHandler) == 0x0000D8, "Wrong size on UDBDBaseInputHandler");
static_assert(offsetof(UDBDBaseInputHandler, _pawn) == 0x000030, "Member 'UDBDBaseInputHandler::_pawn' has a wrong offset!");
static_assert(offsetof(UDBDBaseInputHandler, _cameraBoom) == 0x000038, "Member 'UDBDBaseInputHandler::_cameraBoom' has a wrong offset!");

// Class DeadByDaylight.DBDNavModifierComponent
// 0x00A0 (0x0250 - 0x01B0)
class UDBDNavModifierComponent final : public UNavModifierComponent
{
public:
	bool                                          ForceUseFailsafeExtent;                            // 0x01B0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B1[0x3];                                      // 0x01B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UpdateModifierInterval;                            // 0x01B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          StartNavigationRelevant;                           // 0x01B8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AlwaysTickToCheckTransform;                        // 0x01B9(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RelevantPassiveMode;                               // 0x01BA(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1BB[0x5];                                      // 0x01BB(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                BoundCenterOffset;                                 // 0x01C0(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D8[0x78];                                     // 0x01D8(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDNavModifierComponent">();
	}
	static class UDBDNavModifierComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDNavModifierComponent>();
	}
};
static_assert(alignof(UDBDNavModifierComponent) == 0x000010, "Wrong alignment on UDBDNavModifierComponent");
static_assert(sizeof(UDBDNavModifierComponent) == 0x000250, "Wrong size on UDBDNavModifierComponent");
static_assert(offsetof(UDBDNavModifierComponent, ForceUseFailsafeExtent) == 0x0001B0, "Member 'UDBDNavModifierComponent::ForceUseFailsafeExtent' has a wrong offset!");
static_assert(offsetof(UDBDNavModifierComponent, UpdateModifierInterval) == 0x0001B4, "Member 'UDBDNavModifierComponent::UpdateModifierInterval' has a wrong offset!");
static_assert(offsetof(UDBDNavModifierComponent, StartNavigationRelevant) == 0x0001B8, "Member 'UDBDNavModifierComponent::StartNavigationRelevant' has a wrong offset!");
static_assert(offsetof(UDBDNavModifierComponent, AlwaysTickToCheckTransform) == 0x0001B9, "Member 'UDBDNavModifierComponent::AlwaysTickToCheckTransform' has a wrong offset!");
static_assert(offsetof(UDBDNavModifierComponent, RelevantPassiveMode) == 0x0001BA, "Member 'UDBDNavModifierComponent::RelevantPassiveMode' has a wrong offset!");
static_assert(offsetof(UDBDNavModifierComponent, BoundCenterOffset) == 0x0001C0, "Member 'UDBDNavModifierComponent::BoundCenterOffset' has a wrong offset!");

// Class DeadByDaylight.HISMMaterialHelperSettings
// 0x0050 (0x0088 - 0x0038)
class UHISMMaterialHelperSettings final : public UDataAsset
{
public:
	TMap<class UStaticMesh*, TSoftClassPtr<class UClass>> _meshMaterialOverride;                             // 0x0038(0x0050)(Edit, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HISMMaterialHelperSettings">();
	}
	static class UHISMMaterialHelperSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHISMMaterialHelperSettings>();
	}
};
static_assert(alignof(UHISMMaterialHelperSettings) == 0x000008, "Wrong alignment on UHISMMaterialHelperSettings");
static_assert(sizeof(UHISMMaterialHelperSettings) == 0x000088, "Wrong size on UHISMMaterialHelperSettings");
static_assert(offsetof(UHISMMaterialHelperSettings, _meshMaterialOverride) == 0x000038, "Member 'UHISMMaterialHelperSettings::_meshMaterialOverride' has a wrong offset!");

// Class DeadByDaylight.DBDBloodWebDefinition
// 0x0110 (0x0140 - 0x0030)
class UDBDBloodWebDefinition final : public UObject
{
public:
	uint8                                         Pad_30[0x110];                                     // 0x0030(0x0110)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDBloodWebDefinition">();
	}
	static class UDBDBloodWebDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDBloodWebDefinition>();
	}
};
static_assert(alignof(UDBDBloodWebDefinition) == 0x000008, "Wrong alignment on UDBDBloodWebDefinition");
static_assert(sizeof(UDBDBloodWebDefinition) == 0x000140, "Wrong size on UDBDBloodWebDefinition");

// Class DeadByDaylight.DBDBloodwebDefinitionBase
// 0x0000 (0x0030 - 0x0030)
class IDBDBloodwebDefinitionBase final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDBloodwebDefinitionBase">();
	}
	static class IDBDBloodwebDefinitionBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<IDBDBloodwebDefinitionBase>();
	}
};
static_assert(alignof(IDBDBloodwebDefinitionBase) == 0x000008, "Wrong alignment on IDBDBloodwebDefinitionBase");
static_assert(sizeof(IDBDBloodwebDefinitionBase) == 0x000030, "Wrong size on IDBDBloodwebDefinitionBase");

// Class DeadByDaylight.DBDLogo
// 0x0000 (0x02A0 - 0x02A0)
class ADBDLogo final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDLogo">();
	}
	static class ADBDLogo* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDLogo>();
	}
};
static_assert(alignof(ADBDLogo) == 0x000008, "Wrong alignment on ADBDLogo");
static_assert(sizeof(ADBDLogo) == 0x0002A0, "Wrong size on ADBDLogo");

// Class DeadByDaylight.DBDBotsUtilities
// 0x0000 (0x0030 - 0x0030)
class UDBDBotsUtilities final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDBotsUtilities">();
	}
	static class UDBDBotsUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDBotsUtilities>();
	}
};
static_assert(alignof(UDBDBotsUtilities) == 0x000008, "Wrong alignment on UDBDBotsUtilities");
static_assert(sizeof(UDBDBotsUtilities) == 0x000030, "Wrong size on UDBDBotsUtilities");

// Class DeadByDaylight.DBDCharacterUtilities
// 0x0000 (0x0030 - 0x0030)
class UDBDCharacterUtilities final : public UBlueprintFunctionLibrary
{
public:
	static EPlayerRole GetLocallyObservedPlayerRole(const class UObject* WorldContextObject);
	static bool IsAceVisconti(const class ADBDBasePlayer* TargetPlayer);
	static bool IsAdamFrancis(const class ADBDBasePlayer* TargetPlayer);
	static bool IsAshleyWilliams(const class ADBDBasePlayer* TargetPlayer);
	static bool IsClaudetteMorel(const class ADBDBasePlayer* TargetPlayer);
	static bool IsDavidKing(const class ADBDBasePlayer* TargetPlayer);
	static bool IsDavidTapp(const class ADBDBasePlayer* TargetPlayer);
	static bool IsDwightFairfield(const class ADBDBasePlayer* TargetPlayer);
	static bool IsFengMin(const class ADBDBasePlayer* TargetPlayer);
	static bool IsInDreamworld(const class ADBDPlayer* Player);
	static bool IsInSameTeamAsLocallyObservedPlayer(const class ADBDPlayer* TargetPlayer);
	static bool IsJakePark(const class ADBDBasePlayer* TargetPlayer);
	static bool IsJaneRomero(const class ADBDBasePlayer* TargetPlayer);
	static bool IsJeffJohansen(const class ADBDBasePlayer* TargetPlayer);
	static bool IsKateDenson(const class ADBDBasePlayer* TargetPlayer);
	static bool IsLaurieStrode(const class ADBDBasePlayer* TargetPlayer);
	static bool IsMegThomas(const class ADBDBasePlayer* TargetPlayer);
	static bool IsNancyWheeler(const class ADBDBasePlayer* TargetPlayer);
	static bool IsNeaKarlsson(const class ADBDBasePlayer* TargetPlayer);
	static bool IsPlague(const class ADBDBasePlayer* TargetPlayer);
	static bool IsQuentinSmith(const class ADBDBasePlayer* TargetPlayer);
	static bool IsSlasherLocallyObserved(const class UObject* WorldContextObject);
	static bool IsSteveHarrington(const class ADBDBasePlayer* TargetPlayer);
	static bool IsTheBlight(const class ADBDBasePlayer* TargetPlayer);
	static bool IsTheCannibal(const class ADBDBasePlayer* TargetPlayer);
	static bool IsTheClown(const class ADBDBasePlayer* TargetPlayer);
	static bool IsTheDemogorgon(const class ADBDBasePlayer* TargetPlayer);
	static bool IsTheDoctor(const class ADBDBasePlayer* TargetPlayer);
	static bool IsTheExecutioner(const class ADBDBasePlayer* TargetPlayer);
	static bool IsTheGhost(const class ADBDBasePlayer* TargetPlayer);
	static bool IsTheGoodGuy(const class ADBDBasePlayer* TargetPlayer);
	static bool IsTheHag(const class ADBDBasePlayer* TargetPlayer);
	static bool IsTheHillBilly(const class ADBDBasePlayer* TargetPlayer);
	static bool IsTheHuntress(const class ADBDBasePlayer* TargetPlayer);
	static bool IsTheLegion(const class ADBDBasePlayer* TargetPlayer);
	static bool IsTheNightmare(const class ADBDBasePlayer* TargetPlayer);
	static bool IsTheNurse(const class ADBDBasePlayer* TargetPlayer);
	static bool IsTheOni(const class ADBDBasePlayer* TargetPlayer);
	static bool IsTheOnryo(const class ADBDBasePlayer* TargetPlayer);
	static bool IsThePig(const class ADBDBasePlayer* TargetPlayer);
	static bool IsTheShape(const class ADBDBasePlayer* TargetPlayer);
	static bool IsTheSpirit(const class ADBDBasePlayer* TargetPlayer);
	static bool IsTheTrapper(const class ADBDBasePlayer* TargetPlayer);
	static bool IsTheTrickster(const class ADBDBasePlayer* TargetPlayer);
	static bool IsTheTwins(const class ADBDBasePlayer* TargetPlayer);
	static bool IsTheTwins_Brother(const class ADBDBasePlayer* TargetPlayer);
	static bool IsTheTwins_Sister(const class ADBDBasePlayer* TargetPlayer);
	static bool IsTheWraith(const class ADBDBasePlayer* TargetPlayer);
	static bool IsWilliamBillOverbeck(const class ADBDBasePlayer* TargetPlayer);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDCharacterUtilities">();
	}
	static class UDBDCharacterUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDCharacterUtilities>();
	}
};
static_assert(alignof(UDBDCharacterUtilities) == 0x000008, "Wrong alignment on UDBDCharacterUtilities");
static_assert(sizeof(UDBDCharacterUtilities) == 0x000030, "Wrong size on UDBDCharacterUtilities");

// Class DeadByDaylight.SkillCheck
// 0x0218 (0x02C0 - 0x00A8)
class USkillCheck final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0xC8];                                      // 0x00A8(0x00C8)(Fixing Size After Last Property [ Dumper-7 ])
	class ADBDPlayer*                             _owner;                                            // 0x0170(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UChargeableInteractionDefinition*       _currentInteraction;                               // 0x0178(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_180[0x70];                                     // 0x0180(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ESkillCheckCustomType>                 _customSkillCheckTypesAffectedByWarningModifiers;  // 0x01F0(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPrivate)
	uint8                                         Pad_200[0xC0];                                     // 0x0200(0x00C0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool CanSkillCheckTypeGrantScore(ESkillCheckCustomType Type);

	void Authority_OnSkillCheckTimeout();
	void Multicast_ActivateSkillCheck(class UChargeableInteractionDefinition* Interaction, ESkillCheckCustomType SkillCheckCustomType, const struct FSkillCheckDefinition& Definition, bool ExecuteOnlyOnNotControlled);
	void Multicast_DeactivateSkillCheck();
	void Multicast_OnTriggerContinuousCustomSkillCheck(class UChargeableInteractionDefinition* CurrentInteraction, ESkillCheckCustomType SkillCheckCustomType, const struct FSkillCheckDefinition& Definition);
	void Multicast_OnTriggerCustomSkillCheck(class UChargeableInteractionDefinition* CurrentInteraction, ESkillCheckCustomType SkillCheckCustomType, const class FString& ID, const class FString& Salt, const struct FSkillCheckDefinition& Definition);
	void Multicast_SkillCheckResponse(const struct FSkillCheckResponse& SkillCheckResponse, bool ExecuteOnlyOnNotControlled);
	void Server_ActivateSkillCheck(class UChargeableInteractionDefinition* Interaction, ESkillCheckCustomType SkillCheckCustomType, const struct FSkillCheckDefinition& Definition);
	void Server_DeactivateSkillCheck();
	void Server_OnSkillCheckFailure(const struct FSkillCheckResponse& SkillCheckResponse);
	void Server_OnSkillCheckSuccess(const struct FSkillCheckResponse& SkillCheckResponse);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SkillCheck">();
	}
	static class USkillCheck* GetDefaultObj()
	{
		return GetDefaultObjImpl<USkillCheck>();
	}
};
static_assert(alignof(USkillCheck) == 0x000008, "Wrong alignment on USkillCheck");
static_assert(sizeof(USkillCheck) == 0x0002C0, "Wrong size on USkillCheck");
static_assert(offsetof(USkillCheck, _owner) == 0x000170, "Member 'USkillCheck::_owner' has a wrong offset!");
static_assert(offsetof(USkillCheck, _currentInteraction) == 0x000178, "Member 'USkillCheck::_currentInteraction' has a wrong offset!");
static_assert(offsetof(USkillCheck, _customSkillCheckTypesAffectedByWarningModifiers) == 0x0001F0, "Member 'USkillCheck::_customSkillCheckTypesAffectedByWarningModifiers' has a wrong offset!");

// Class DeadByDaylight.DBDClientSyncer
// 0x01F8 (0x0498 - 0x02A0)
class ADBDClientSyncer final : public AActor
{
public:
	TArray<struct FSpawnInfo>                     _actorsToSpawnLocally;                             // 0x02A0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<struct FSpawnInfo>                     _currentQueue;                                     // 0x02B0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C0[0x8];                                      // 0x02C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UPaperTileMap*                          _tileMap;                                          // 0x02C8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D0[0x1C8];                                    // 0x02D0(0x01C8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Multicast_SyncActorToSpawnLocally(const TArray<struct FSpawnInfo>& SpawnInfos, int32 StartIndex);
	void Multicast_SyncFinalLocallySpawnCount(int32 NumLocal);
	void Multicast_SyncSeed(int32 Seed, class UPaperTileMap* TileMap, int32 GenerationPlayerCount, const class FString& PremadeMap);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDClientSyncer">();
	}
	static class ADBDClientSyncer* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDClientSyncer>();
	}
};
static_assert(alignof(ADBDClientSyncer) == 0x000008, "Wrong alignment on ADBDClientSyncer");
static_assert(sizeof(ADBDClientSyncer) == 0x000498, "Wrong size on ADBDClientSyncer");
static_assert(offsetof(ADBDClientSyncer, _actorsToSpawnLocally) == 0x0002A0, "Member 'ADBDClientSyncer::_actorsToSpawnLocally' has a wrong offset!");
static_assert(offsetof(ADBDClientSyncer, _currentQueue) == 0x0002B0, "Member 'ADBDClientSyncer::_currentQueue' has a wrong offset!");
static_assert(offsetof(ADBDClientSyncer, _tileMap) == 0x0002C8, "Member 'ADBDClientSyncer::_tileMap' has a wrong offset!");

// Class DeadByDaylight.SeasonEndRankRewardsPopupScreen
// 0x0000 (0x0148 - 0x0148)
class USeasonEndRankRewardsPopupScreen final : public UGenericPopupScreen
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SeasonEndRankRewardsPopupScreen">();
	}
	static class USeasonEndRankRewardsPopupScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<USeasonEndRankRewardsPopupScreen>();
	}
};
static_assert(alignof(USeasonEndRankRewardsPopupScreen) == 0x000008, "Wrong alignment on USeasonEndRankRewardsPopupScreen");
static_assert(sizeof(USeasonEndRankRewardsPopupScreen) == 0x000148, "Wrong size on USeasonEndRankRewardsPopupScreen");

// Class DeadByDaylight.DBDSignificanceStrategy
// 0x01E0 (0x0210 - 0x0030)
class UDBDSignificanceStrategy final : public USignificanceStrategy
{
public:
	struct FBHVRPerDetailModeFloat                _farDistance;                                      // 0x0030(0x00A0)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FBHVRPerDetailModeFloat                _auraRevealedMultiplier;                           // 0x00D0(0x00A0)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FBHVRPerDetailModeFloat                _auraRevealedMinimumSignificance;                  // 0x0170(0x00A0)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDSignificanceStrategy">();
	}
	static class UDBDSignificanceStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDSignificanceStrategy>();
	}
};
static_assert(alignof(UDBDSignificanceStrategy) == 0x000008, "Wrong alignment on UDBDSignificanceStrategy");
static_assert(sizeof(UDBDSignificanceStrategy) == 0x000210, "Wrong size on UDBDSignificanceStrategy");
static_assert(offsetof(UDBDSignificanceStrategy, _farDistance) == 0x000030, "Member 'UDBDSignificanceStrategy::_farDistance' has a wrong offset!");
static_assert(offsetof(UDBDSignificanceStrategy, _auraRevealedMultiplier) == 0x0000D0, "Member 'UDBDSignificanceStrategy::_auraRevealedMultiplier' has a wrong offset!");
static_assert(offsetof(UDBDSignificanceStrategy, _auraRevealedMinimumSignificance) == 0x000170, "Member 'UDBDSignificanceStrategy::_auraRevealedMinimumSignificance' has a wrong offset!");

// Class DeadByDaylight.DBDClipRegionComponent
// 0x0010 (0x02D0 - 0x02C0)
class UDBDClipRegionComponent : public UDBDLocatorComponent
{
public:
	TArray<struct FAffectedMaterialAndVariant>    AffectedMaterialsAndVariants;                      // 0x02C0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static void ApplyArrayOfClipsToDynamicMaterial(const TArray<class UDBDClipRegionComponent*>& InRegions, class UMaterialInstanceDynamic* DynamicInstanceToClip);

	void ApplyClip(class UMaterialInstanceDynamic* InMaterial2clip, int32 InRegionID);
	void ApplyClipToDynamicMaterial(class UMaterialInstanceDynamic* DynamicInstanceToClip, int32 InRegionID);
	float ClipDistance(class UMeshComponent* InMeshComponent);
	void NotifyShouldClipComponent(class UMeshComponent* InMeshComponent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDClipRegionComponent">();
	}
	static class UDBDClipRegionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDClipRegionComponent>();
	}
};
static_assert(alignof(UDBDClipRegionComponent) == 0x000010, "Wrong alignment on UDBDClipRegionComponent");
static_assert(sizeof(UDBDClipRegionComponent) == 0x0002D0, "Wrong size on UDBDClipRegionComponent");
static_assert(offsetof(UDBDClipRegionComponent, AffectedMaterialsAndVariants) == 0x0002C0, "Member 'UDBDClipRegionComponent::AffectedMaterialsAndVariants' has a wrong offset!");

// Class DeadByDaylight.UMGAlertsWidget
// 0x00D0 (0x0418 - 0x0348)
class UUMGAlertsWidget final : public UMobileBaseUserWidget
{
public:
	TSoftClassPtr<class UClass>                   AtlantaScoreAlertComponentClass;                   // 0x0348(0x0038)(Edit, NoClear, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   AtlantaStatusEffectAlertComponentClass;            // 0x0380(0x0038)(Edit, NoClear, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           CanvasPanelAlerts;                                 // 0x03B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         IdleTime;                                          // 0x03C0(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C4[0x44];                                     // 0x03C4(0x0044)(Fixing Size After Last Property [ Dumper-7 ])
	class UClass*                                 _scoreAlertClass;                                  // 0x0408(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UClass*                                 _statusEffectAlertClass;                           // 0x0410(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGAlertsWidget">();
	}
	static class UUMGAlertsWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGAlertsWidget>();
	}
};
static_assert(alignof(UUMGAlertsWidget) == 0x000008, "Wrong alignment on UUMGAlertsWidget");
static_assert(sizeof(UUMGAlertsWidget) == 0x000418, "Wrong size on UUMGAlertsWidget");
static_assert(offsetof(UUMGAlertsWidget, AtlantaScoreAlertComponentClass) == 0x000348, "Member 'UUMGAlertsWidget::AtlantaScoreAlertComponentClass' has a wrong offset!");
static_assert(offsetof(UUMGAlertsWidget, AtlantaStatusEffectAlertComponentClass) == 0x000380, "Member 'UUMGAlertsWidget::AtlantaStatusEffectAlertComponentClass' has a wrong offset!");
static_assert(offsetof(UUMGAlertsWidget, CanvasPanelAlerts) == 0x0003B8, "Member 'UUMGAlertsWidget::CanvasPanelAlerts' has a wrong offset!");
static_assert(offsetof(UUMGAlertsWidget, IdleTime) == 0x0003C0, "Member 'UUMGAlertsWidget::IdleTime' has a wrong offset!");
static_assert(offsetof(UUMGAlertsWidget, _scoreAlertClass) == 0x000408, "Member 'UUMGAlertsWidget::_scoreAlertClass' has a wrong offset!");
static_assert(offsetof(UUMGAlertsWidget, _statusEffectAlertClass) == 0x000410, "Member 'UUMGAlertsWidget::_statusEffectAlertClass' has a wrong offset!");

// Class DeadByDaylight.ColorBlindFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class UColorBlindFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void CallOnColorBlindSettingsChange(class AActor* CallingActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ColorBlindFunctionLibrary">();
	}
	static class UColorBlindFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UColorBlindFunctionLibrary>();
	}
};
static_assert(alignof(UColorBlindFunctionLibrary) == 0x000008, "Wrong alignment on UColorBlindFunctionLibrary");
static_assert(sizeof(UColorBlindFunctionLibrary) == 0x000030, "Wrong size on UColorBlindFunctionLibrary");

// Class DeadByDaylight.DBDConsoleCommandUtilities
// 0x0000 (0x0030 - 0x0030)
class UDBDConsoleCommandUtilities final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDConsoleCommandUtilities">();
	}
	static class UDBDConsoleCommandUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDConsoleCommandUtilities>();
	}
};
static_assert(alignof(UDBDConsoleCommandUtilities) == 0x000008, "Wrong alignment on UDBDConsoleCommandUtilities");
static_assert(sizeof(UDBDConsoleCommandUtilities) == 0x000030, "Wrong size on UDBDConsoleCommandUtilities");

// Class DeadByDaylight.DBDCurrencyConversionTunables
// 0x0050 (0x0088 - 0x0038)
class UDBDCurrencyConversionTunables final : public UDataAsset
{
public:
	TMap<ECurrencyType, struct FCurrencyConversion> Currencies;                                        // 0x0038(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDCurrencyConversionTunables">();
	}
	static class UDBDCurrencyConversionTunables* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDCurrencyConversionTunables>();
	}
};
static_assert(alignof(UDBDCurrencyConversionTunables) == 0x000008, "Wrong alignment on UDBDCurrencyConversionTunables");
static_assert(sizeof(UDBDCurrencyConversionTunables) == 0x000088, "Wrong size on UDBDCurrencyConversionTunables");
static_assert(offsetof(UDBDCurrencyConversionTunables, Currencies) == 0x000038, "Member 'UDBDCurrencyConversionTunables::Currencies' has a wrong offset!");

// Class DeadByDaylight.TileSpawnPoint
// 0x00A0 (0x0360 - 0x02C0)
#pragma pack(push, 0x1)
class alignas(0x10) UTileSpawnPoint : public USceneComponent
{
public:
	uint8                                         Pad_2C0[0x10];                                     // 0x02C0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	ETileSpawnPointType                           TileSpawnPointType;                                // 0x02D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D1[0x7];                                      // 0x02D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        Weight;                                            // 0x02D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   Visualization;                                     // 0x02E0(0x0038)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_318[0x20];                                     // 0x0318(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 _spawnedObject;                                    // 0x0338(0x0008)(Net, ZeroConstructor, Transient, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TSubclassOf<class AActor>>             ObjectSpawnModifier;                               // 0x0340(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	int32                                         _spawnPriorityTier;                                // 0x0350(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _weightInfluenceable;                              // 0x0354(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _weightInfluencer;                                 // 0x0355(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _activated;                                        // 0x0356(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_357[0x1];                                      // 0x0357(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_SpawnObject();
	void SetActivated(bool Activated);

	class AActor* GetSpawnedObject() const;
	bool IsActivated() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TileSpawnPoint">();
	}
	static class UTileSpawnPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTileSpawnPoint>();
	}
};
#pragma pack(pop)
static_assert(alignof(UTileSpawnPoint) == 0x000010, "Wrong alignment on UTileSpawnPoint");
static_assert(sizeof(UTileSpawnPoint) == 0x000360, "Wrong size on UTileSpawnPoint");
static_assert(offsetof(UTileSpawnPoint, TileSpawnPointType) == 0x0002D0, "Member 'UTileSpawnPoint::TileSpawnPointType' has a wrong offset!");
static_assert(offsetof(UTileSpawnPoint, Weight) == 0x0002D8, "Member 'UTileSpawnPoint::Weight' has a wrong offset!");
static_assert(offsetof(UTileSpawnPoint, Visualization) == 0x0002E0, "Member 'UTileSpawnPoint::Visualization' has a wrong offset!");
static_assert(offsetof(UTileSpawnPoint, _spawnedObject) == 0x000338, "Member 'UTileSpawnPoint::_spawnedObject' has a wrong offset!");
static_assert(offsetof(UTileSpawnPoint, ObjectSpawnModifier) == 0x000340, "Member 'UTileSpawnPoint::ObjectSpawnModifier' has a wrong offset!");
static_assert(offsetof(UTileSpawnPoint, _spawnPriorityTier) == 0x000350, "Member 'UTileSpawnPoint::_spawnPriorityTier' has a wrong offset!");
static_assert(offsetof(UTileSpawnPoint, _weightInfluenceable) == 0x000354, "Member 'UTileSpawnPoint::_weightInfluenceable' has a wrong offset!");
static_assert(offsetof(UTileSpawnPoint, _weightInfluencer) == 0x000355, "Member 'UTileSpawnPoint::_weightInfluencer' has a wrong offset!");
static_assert(offsetof(UTileSpawnPoint, _activated) == 0x000356, "Member 'UTileSpawnPoint::_activated' has a wrong offset!");

// Class DeadByDaylight.SearchableSpawnPoint
// 0x0000 (0x0360 - 0x0360)
class USearchableSpawnPoint final : public UTileSpawnPoint
{
public:
	TSubclassOf<class AActor>                     ActorToSpawn;                                      // 0x0358(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SearchableSpawnPoint">();
	}
	static class USearchableSpawnPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<USearchableSpawnPoint>();
	}
};
static_assert(alignof(USearchableSpawnPoint) == 0x000010, "Wrong alignment on USearchableSpawnPoint");
static_assert(sizeof(USearchableSpawnPoint) == 0x000360, "Wrong size on USearchableSpawnPoint");
static_assert(offsetof(USearchableSpawnPoint, ActorToSpawn) == 0x000358, "Member 'USearchableSpawnPoint::ActorToSpawn' has a wrong offset!");

// Class DeadByDaylight.DisplayStandCharmRequesterComponent
// 0x0028 (0x00D0 - 0x00A8)
class UDisplayStandCharmRequesterComponent final : public UActorComponent
{
public:
	TSubclassOf<class ACharm>                     _menuCharmClass;                                   // 0x00A8(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B0[0x20];                                      // 0x00B0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCharmDisplayed(class AActor* Actor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DisplayStandCharmRequesterComponent">();
	}
	static class UDisplayStandCharmRequesterComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDisplayStandCharmRequesterComponent>();
	}
};
static_assert(alignof(UDisplayStandCharmRequesterComponent) == 0x000008, "Wrong alignment on UDisplayStandCharmRequesterComponent");
static_assert(sizeof(UDisplayStandCharmRequesterComponent) == 0x0000D0, "Wrong size on UDisplayStandCharmRequesterComponent");
static_assert(offsetof(UDisplayStandCharmRequesterComponent, _menuCharmClass) == 0x0000A8, "Member 'UDisplayStandCharmRequesterComponent::_menuCharmClass' has a wrong offset!");

// Class DeadByDaylight.DBDCustomizationTool
// 0x11C8 (0x1468 - 0x02A0)
class ADBDCustomizationTool final : public AActor
{
public:
	TSoftClassPtr<class UClass>                   OverallLightingClass;                              // 0x02A0(0x0038)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDBDCustomizationToolData              CustomizationData;                                 // 0x02D8(0x1178)(Edit, Protected, NativeAccessSpecifierProtected)
	TArray<class AActor*>                         _spawnedActors;                                    // 0x1450(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1460[0x8];                                     // 0x1460(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDCustomizationTool">();
	}
	static class ADBDCustomizationTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDCustomizationTool>();
	}
};
static_assert(alignof(ADBDCustomizationTool) == 0x000008, "Wrong alignment on ADBDCustomizationTool");
static_assert(sizeof(ADBDCustomizationTool) == 0x001468, "Wrong size on ADBDCustomizationTool");
static_assert(offsetof(ADBDCustomizationTool, OverallLightingClass) == 0x0002A0, "Member 'ADBDCustomizationTool::OverallLightingClass' has a wrong offset!");
static_assert(offsetof(ADBDCustomizationTool, CustomizationData) == 0x0002D8, "Member 'ADBDCustomizationTool::CustomizationData' has a wrong offset!");
static_assert(offsetof(ADBDCustomizationTool, _spawnedActors) == 0x001450, "Member 'ADBDCustomizationTool::_spawnedActors' has a wrong offset!");

// Class DeadByDaylight.RitualEvaluatorBase
// 0x0000 (0x0030 - 0x0030)
class URitualEvaluatorBase final : public UObject
{
public:
	bool EvaluateEvent(const struct FRitualEvent& RitualEvent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RitualEvaluatorBase">();
	}
	static class URitualEvaluatorBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<URitualEvaluatorBase>();
	}
};
static_assert(alignof(URitualEvaluatorBase) == 0x000008, "Wrong alignment on URitualEvaluatorBase");
static_assert(sizeof(URitualEvaluatorBase) == 0x000030, "Wrong size on URitualEvaluatorBase");

// Class DeadByDaylight.StunnableInterface
// 0x0000 (0x0030 - 0x0030)
class IStunnableInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StunnableInterface">();
	}
	static class IStunnableInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IStunnableInterface>();
	}
};
static_assert(alignof(IStunnableInterface) == 0x000008, "Wrong alignment on IStunnableInterface");
static_assert(sizeof(IStunnableInterface) == 0x000030, "Wrong size on IStunnableInterface");

// Class DeadByDaylight.DisplayStandMeatHookRequesterComponent
// 0x0018 (0x00C0 - 0x00A8)
class UDisplayStandMeatHookRequesterComponent final : public UActorComponent
{
public:
	TSubclassOf<class AMenuMeatHook>              _meatHookClass;                                    // 0x00A8(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B0[0x10];                                      // 0x00B0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DisplayStandMeatHookRequesterComponent">();
	}
	static class UDisplayStandMeatHookRequesterComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDisplayStandMeatHookRequesterComponent>();
	}
};
static_assert(alignof(UDisplayStandMeatHookRequesterComponent) == 0x000008, "Wrong alignment on UDisplayStandMeatHookRequesterComponent");
static_assert(sizeof(UDisplayStandMeatHookRequesterComponent) == 0x0000C0, "Wrong size on UDisplayStandMeatHookRequesterComponent");
static_assert(offsetof(UDisplayStandMeatHookRequesterComponent, _meatHookClass) == 0x0000A8, "Member 'UDisplayStandMeatHookRequesterComponent::_meatHookClass' has a wrong offset!");

// Class DeadByDaylight.DBDDateTimeProvider
// 0x0000 (0x0030 - 0x0030)
class UDBDDateTimeProvider final : public UDateTimeProvider
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDDateTimeProvider">();
	}
	static class UDBDDateTimeProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDDateTimeProvider>();
	}
};
static_assert(alignof(UDBDDateTimeProvider) == 0x000008, "Wrong alignment on UDBDDateTimeProvider");
static_assert(sizeof(UDBDDateTimeProvider) == 0x000030, "Wrong size on UDBDDateTimeProvider");

// Class DeadByDaylight.DBDDebugCameraController
// 0x0000 (0x09E8 - 0x09E8)
class ADBDDebugCameraController final : public ADebugCameraController
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDDebugCameraController">();
	}
	static class ADBDDebugCameraController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDDebugCameraController>();
	}
};
static_assert(alignof(ADBDDebugCameraController) == 0x000008, "Wrong alignment on ADBDDebugCameraController");
static_assert(sizeof(ADBDDebugCameraController) == 0x0009E8, "Wrong size on ADBDDebugCameraController");

// Class DeadByDaylight.TimerGateDecrease
// 0x0008 (0x02A8 - 0x02A0)
class ATimerGateDecrease final : public AActor
{
public:
	class ATimerGate*                             TimerGate;                                         // 0x02A0(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void Update(float DeltaTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TimerGateDecrease">();
	}
	static class ATimerGateDecrease* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATimerGateDecrease>();
	}
};
static_assert(alignof(ATimerGateDecrease) == 0x000008, "Wrong alignment on ATimerGateDecrease");
static_assert(sizeof(ATimerGateDecrease) == 0x0002A8, "Wrong size on ATimerGateDecrease");
static_assert(offsetof(ATimerGateDecrease, TimerGate) == 0x0002A0, "Member 'ATimerGateDecrease::TimerGate' has a wrong offset!");

// Class DeadByDaylight.DoctorPowerAnimStateComponent
// 0x0008 (0x00B0 - 0x00A8)
class UDoctorPowerAnimStateComponent final : public UActorComponent
{
public:
	EDoctorAbilityType                            _abilityType;                                      // 0x00A8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDoctorAbilityPhase                           _abilityPhase;                                     // 0x00A9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AA[0x6];                                       // 0x00AA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetCurrentAbilityPhase(EDoctorAbilityPhase AbilityPhase);
	void SetCurrentAbilityType(EDoctorAbilityType AbilityType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DoctorPowerAnimStateComponent">();
	}
	static class UDoctorPowerAnimStateComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDoctorPowerAnimStateComponent>();
	}
};
static_assert(alignof(UDoctorPowerAnimStateComponent) == 0x000008, "Wrong alignment on UDoctorPowerAnimStateComponent");
static_assert(sizeof(UDoctorPowerAnimStateComponent) == 0x0000B0, "Wrong size on UDoctorPowerAnimStateComponent");
static_assert(offsetof(UDoctorPowerAnimStateComponent, _abilityType) == 0x0000A8, "Member 'UDoctorPowerAnimStateComponent::_abilityType' has a wrong offset!");
static_assert(offsetof(UDoctorPowerAnimStateComponent, _abilityPhase) == 0x0000A9, "Member 'UDoctorPowerAnimStateComponent::_abilityPhase' has a wrong offset!");

// Class DeadByDaylight.DBD_SoundClipUtil
// 0x00C8 (0x0170 - 0x00A8)
class UDBD_SoundClipUtil : public UActorComponent
{
public:
	TArray<struct FMapMeshToAkAudioEvent>         AudioMap;                                          // 0x00A8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<class FName, struct FMapMeshToAkAudioEvent> _audioEventMap;                                    // 0x00B8(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FMapSoundsToAvoid>              _objectsWhoHavePlayedASound;                       // 0x0108(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TMap<class UAkAudioEvent*, float>             _nextSoundPlayTime;                                // 0x0118(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_168[0x8];                                      // 0x0168(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_OnSoundTriggered(class AActor* Actor);
	class UAkAudioEvent* GetAudioEventForMesh(class UStaticMeshComponent* Usm);
	void OnCharacterEnterSoundRegion(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBD_SoundClipUtil">();
	}
	static class UDBD_SoundClipUtil* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBD_SoundClipUtil>();
	}
};
static_assert(alignof(UDBD_SoundClipUtil) == 0x000008, "Wrong alignment on UDBD_SoundClipUtil");
static_assert(sizeof(UDBD_SoundClipUtil) == 0x000170, "Wrong size on UDBD_SoundClipUtil");
static_assert(offsetof(UDBD_SoundClipUtil, AudioMap) == 0x0000A8, "Member 'UDBD_SoundClipUtil::AudioMap' has a wrong offset!");
static_assert(offsetof(UDBD_SoundClipUtil, _audioEventMap) == 0x0000B8, "Member 'UDBD_SoundClipUtil::_audioEventMap' has a wrong offset!");
static_assert(offsetof(UDBD_SoundClipUtil, _objectsWhoHavePlayedASound) == 0x000108, "Member 'UDBD_SoundClipUtil::_objectsWhoHavePlayedASound' has a wrong offset!");
static_assert(offsetof(UDBD_SoundClipUtil, _nextSoundPlayTime) == 0x000118, "Member 'UDBD_SoundClipUtil::_nextSoundPlayTime' has a wrong offset!");

// Class DeadByDaylight.DBDDebugInputComponent
// 0x0020 (0x00C8 - 0x00A8)
class UDBDDebugInputComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x20];                                      // 0x00A8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DBD_ItsAlive(bool AliveEnabled);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDDebugInputComponent">();
	}
	static class UDBDDebugInputComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDDebugInputComponent>();
	}
};
static_assert(alignof(UDBDDebugInputComponent) == 0x000008, "Wrong alignment on UDBDDebugInputComponent");
static_assert(sizeof(UDBDDebugInputComponent) == 0x0000C8, "Wrong size on UDBDDebugInputComponent");

// Class DeadByDaylight.DBDDecalComponent
// 0x0100 (0x0420 - 0x0320)
class UDBDDecalComponent final : public UDecalComponent
{
public:
	TArray<class UStaticMeshComponent*>           StaticMeshDecals;                                  // 0x0320(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TMap<class UStaticMeshComponent*, class UGlassStaticMesh*> StaticMeshGlass;                                   // 0x0330(0x0050)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UMaterialInstanceDynamic*>       MaterialInstances;                                 // 0x0380(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_390[0x80];                                     // 0x0390(0x0080)(Fixing Size After Last Property [ Dumper-7 ])
	class UDecalCollection*                       _decalCollection;                                  // 0x0410(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_418[0x8];                                      // 0x0418(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDDecalComponent">();
	}
	static class UDBDDecalComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDDecalComponent>();
	}
};
static_assert(alignof(UDBDDecalComponent) == 0x000010, "Wrong alignment on UDBDDecalComponent");
static_assert(sizeof(UDBDDecalComponent) == 0x000420, "Wrong size on UDBDDecalComponent");
static_assert(offsetof(UDBDDecalComponent, StaticMeshDecals) == 0x000320, "Member 'UDBDDecalComponent::StaticMeshDecals' has a wrong offset!");
static_assert(offsetof(UDBDDecalComponent, StaticMeshGlass) == 0x000330, "Member 'UDBDDecalComponent::StaticMeshGlass' has a wrong offset!");
static_assert(offsetof(UDBDDecalComponent, MaterialInstances) == 0x000380, "Member 'UDBDDecalComponent::MaterialInstances' has a wrong offset!");
static_assert(offsetof(UDBDDecalComponent, _decalCollection) == 0x000410, "Member 'UDBDDecalComponent::_decalCollection' has a wrong offset!");

// Class DeadByDaylight.FranklinsDemiseConsumedByEntityComponent
// 0x0070 (0x0118 - 0x00A8)
class UFranklinsDemiseConsumedByEntityComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x18];                                      // 0x00A8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UTimerObject*                           _consumeTimer;                                     // 0x00C0(0x0008)(ExportObject, Net, ZeroConstructor, InstancedReference, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C8[0x10];                                      // 0x00C8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UStatusEffect*                          _camperStatus;                                     // 0x00D8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ADBDPlayer*                             _previousOwner;                                    // 0x00E0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ADBDPlayer*                             _originatingPerkOwner;                             // 0x00E8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UChargerComponent*                      _itemChargerComponent;                             // 0x00F0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F8[0x20];                                      // 0x00F8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_StartConsume(float Duration, class ADBDPlayer* PreviousOwner, class ADBDPlayer* Slasher);
	void OnConsumedByEntity();
	void OnRep_ConsumeTimer();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FranklinsDemiseConsumedByEntityComponent">();
	}
	static class UFranklinsDemiseConsumedByEntityComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFranklinsDemiseConsumedByEntityComponent>();
	}
};
static_assert(alignof(UFranklinsDemiseConsumedByEntityComponent) == 0x000008, "Wrong alignment on UFranklinsDemiseConsumedByEntityComponent");
static_assert(sizeof(UFranklinsDemiseConsumedByEntityComponent) == 0x000118, "Wrong size on UFranklinsDemiseConsumedByEntityComponent");
static_assert(offsetof(UFranklinsDemiseConsumedByEntityComponent, _consumeTimer) == 0x0000C0, "Member 'UFranklinsDemiseConsumedByEntityComponent::_consumeTimer' has a wrong offset!");
static_assert(offsetof(UFranklinsDemiseConsumedByEntityComponent, _camperStatus) == 0x0000D8, "Member 'UFranklinsDemiseConsumedByEntityComponent::_camperStatus' has a wrong offset!");
static_assert(offsetof(UFranklinsDemiseConsumedByEntityComponent, _previousOwner) == 0x0000E0, "Member 'UFranklinsDemiseConsumedByEntityComponent::_previousOwner' has a wrong offset!");
static_assert(offsetof(UFranklinsDemiseConsumedByEntityComponent, _originatingPerkOwner) == 0x0000E8, "Member 'UFranklinsDemiseConsumedByEntityComponent::_originatingPerkOwner' has a wrong offset!");
static_assert(offsetof(UFranklinsDemiseConsumedByEntityComponent, _itemChargerComponent) == 0x0000F0, "Member 'UFranklinsDemiseConsumedByEntityComponent::_itemChargerComponent' has a wrong offset!");

// Class DeadByDaylight.DisplayStandCurrencyRequesterComponent
// 0x0010 (0x00B8 - 0x00A8)
class UDisplayStandCurrencyRequesterComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UClass*                                 _menuCurrencyDisplayableClass;                     // 0x00B0(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DisplayStandCurrencyRequesterComponent">();
	}
	static class UDisplayStandCurrencyRequesterComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDisplayStandCurrencyRequesterComponent>();
	}
};
static_assert(alignof(UDisplayStandCurrencyRequesterComponent) == 0x000008, "Wrong alignment on UDisplayStandCurrencyRequesterComponent");
static_assert(sizeof(UDisplayStandCurrencyRequesterComponent) == 0x0000B8, "Wrong size on UDisplayStandCurrencyRequesterComponent");
static_assert(offsetof(UDisplayStandCurrencyRequesterComponent, _menuCurrencyDisplayableClass) == 0x0000B0, "Member 'UDisplayStandCurrencyRequesterComponent::_menuCurrencyDisplayableClass' has a wrong offset!");

// Class DeadByDaylight.DesignTunableDataAsset
// 0x0248 (0x0280 - 0x0038)
class UDesignTunableDataAsset final : public UDataAsset
{
public:
	bool                                          _overrideDefaultLobby;                             // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   _lobbyOverrideName;                                // 0x003C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGameplayTag>                   _conspicuousActionEvents;                          // 0x0048(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	int8                                          EntityDispleasedKills;                             // 0x0058(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int8                                          BrutalKillerKills;                                 // 0x0059(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int8                                          RuthlessKillerKills;                               // 0x005A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int8                                          MercilessKillerKills;                              // 0x005B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WinStreakThresholdLarge;                           // 0x005C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WinStreakThresholdSmall;                           // 0x0060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxFearTokens;                                     // 0x0064(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         QuantityOfItemsToBuyBeforeFreeBloodwebRefresh;     // 0x0068(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPerkLevelDefinition>           PerkLevelDefinitions;                              // 0x0070(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TSet<struct FGameplayTag>                     MetaModifiers;                                     // 0x0080(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TSet<struct FGameplayTag>                     RangedSurvivorAuraPerceptionModifiers;             // 0x00D0(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TSet<struct FGameplayTag>                     SurvivorRevelatoryAuraPerceptionModifiers;         // 0x0120(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TSet<struct FGameplayTag>                     DisruptableAuraReadingFlags;                       // 0x0170(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   TextDesignTunableClass;                            // 0x01C0(0x0038)(Edit, BlueprintVisible, NoClear, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGameEventForwarderInfo>        GameEventForwarderInfos;                           // 0x01F8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   CoreUMGDesignTunableClass;                         // 0x0208(0x0038)(Edit, BlueprintVisible, NoClear, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UMenuCameraDesignTunables> SoftMenuCameraDesignTunable;                       // 0x0240(0x0038)(Edit, BlueprintVisible, NoClear, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameTypeModifierDefaults*              GameTypeModifierDefaults;                          // 0x0278(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DesignTunableDataAsset">();
	}
	static class UDesignTunableDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDesignTunableDataAsset>();
	}
};
static_assert(alignof(UDesignTunableDataAsset) == 0x000008, "Wrong alignment on UDesignTunableDataAsset");
static_assert(sizeof(UDesignTunableDataAsset) == 0x000280, "Wrong size on UDesignTunableDataAsset");
static_assert(offsetof(UDesignTunableDataAsset, _overrideDefaultLobby) == 0x000038, "Member 'UDesignTunableDataAsset::_overrideDefaultLobby' has a wrong offset!");
static_assert(offsetof(UDesignTunableDataAsset, _lobbyOverrideName) == 0x00003C, "Member 'UDesignTunableDataAsset::_lobbyOverrideName' has a wrong offset!");
static_assert(offsetof(UDesignTunableDataAsset, _conspicuousActionEvents) == 0x000048, "Member 'UDesignTunableDataAsset::_conspicuousActionEvents' has a wrong offset!");
static_assert(offsetof(UDesignTunableDataAsset, EntityDispleasedKills) == 0x000058, "Member 'UDesignTunableDataAsset::EntityDispleasedKills' has a wrong offset!");
static_assert(offsetof(UDesignTunableDataAsset, BrutalKillerKills) == 0x000059, "Member 'UDesignTunableDataAsset::BrutalKillerKills' has a wrong offset!");
static_assert(offsetof(UDesignTunableDataAsset, RuthlessKillerKills) == 0x00005A, "Member 'UDesignTunableDataAsset::RuthlessKillerKills' has a wrong offset!");
static_assert(offsetof(UDesignTunableDataAsset, MercilessKillerKills) == 0x00005B, "Member 'UDesignTunableDataAsset::MercilessKillerKills' has a wrong offset!");
static_assert(offsetof(UDesignTunableDataAsset, WinStreakThresholdLarge) == 0x00005C, "Member 'UDesignTunableDataAsset::WinStreakThresholdLarge' has a wrong offset!");
static_assert(offsetof(UDesignTunableDataAsset, WinStreakThresholdSmall) == 0x000060, "Member 'UDesignTunableDataAsset::WinStreakThresholdSmall' has a wrong offset!");
static_assert(offsetof(UDesignTunableDataAsset, MaxFearTokens) == 0x000064, "Member 'UDesignTunableDataAsset::MaxFearTokens' has a wrong offset!");
static_assert(offsetof(UDesignTunableDataAsset, QuantityOfItemsToBuyBeforeFreeBloodwebRefresh) == 0x000068, "Member 'UDesignTunableDataAsset::QuantityOfItemsToBuyBeforeFreeBloodwebRefresh' has a wrong offset!");
static_assert(offsetof(UDesignTunableDataAsset, PerkLevelDefinitions) == 0x000070, "Member 'UDesignTunableDataAsset::PerkLevelDefinitions' has a wrong offset!");
static_assert(offsetof(UDesignTunableDataAsset, MetaModifiers) == 0x000080, "Member 'UDesignTunableDataAsset::MetaModifiers' has a wrong offset!");
static_assert(offsetof(UDesignTunableDataAsset, RangedSurvivorAuraPerceptionModifiers) == 0x0000D0, "Member 'UDesignTunableDataAsset::RangedSurvivorAuraPerceptionModifiers' has a wrong offset!");
static_assert(offsetof(UDesignTunableDataAsset, SurvivorRevelatoryAuraPerceptionModifiers) == 0x000120, "Member 'UDesignTunableDataAsset::SurvivorRevelatoryAuraPerceptionModifiers' has a wrong offset!");
static_assert(offsetof(UDesignTunableDataAsset, DisruptableAuraReadingFlags) == 0x000170, "Member 'UDesignTunableDataAsset::DisruptableAuraReadingFlags' has a wrong offset!");
static_assert(offsetof(UDesignTunableDataAsset, TextDesignTunableClass) == 0x0001C0, "Member 'UDesignTunableDataAsset::TextDesignTunableClass' has a wrong offset!");
static_assert(offsetof(UDesignTunableDataAsset, GameEventForwarderInfos) == 0x0001F8, "Member 'UDesignTunableDataAsset::GameEventForwarderInfos' has a wrong offset!");
static_assert(offsetof(UDesignTunableDataAsset, CoreUMGDesignTunableClass) == 0x000208, "Member 'UDesignTunableDataAsset::CoreUMGDesignTunableClass' has a wrong offset!");
static_assert(offsetof(UDesignTunableDataAsset, SoftMenuCameraDesignTunable) == 0x000240, "Member 'UDesignTunableDataAsset::SoftMenuCameraDesignTunable' has a wrong offset!");
static_assert(offsetof(UDesignTunableDataAsset, GameTypeModifierDefaults) == 0x000278, "Member 'UDesignTunableDataAsset::GameTypeModifierDefaults' has a wrong offset!");

// Class DeadByDaylight.DBDTextDesignTunables
// 0x00D8 (0x0108 - 0x0030)
class UDBDTextDesignTunables : public UObject
{
public:
	class FText                                   LegalTextTitle;                                    // 0x0030(0x0018)(Edit, BlueprintVisible, Config, NativeAccessSpecifierPublic)
	class FText                                   LegalText;                                         // 0x0048(0x0018)(Edit, BlueprintVisible, Config, NativeAccessSpecifierPublic)
	class FText                                   ConsentTextTitle;                                  // 0x0060(0x0018)(Edit, BlueprintVisible, Config, NativeAccessSpecifierPublic)
	class FText                                   ConsentText;                                       // 0x0078(0x0018)(Edit, BlueprintVisible, Config, NativeAccessSpecifierPublic)
	class FText                                   LegalTextSIEA;                                     // 0x0090(0x0018)(Edit, BlueprintVisible, Config, NativeAccessSpecifierPublic)
	class FText                                   LegalTextSIEE;                                     // 0x00A8(0x0018)(Edit, BlueprintVisible, Config, NativeAccessSpecifierPublic)
	class FText                                   SystemMessage_ChatDisconnected;                    // 0x00C0(0x0018)(Edit, BlueprintVisible, Config, NativeAccessSpecifierPublic)
	class FText                                   SystemMessage_ChatReturnedToLobby;                 // 0x00D8(0x0018)(Edit, BlueprintVisible, Config, NativeAccessSpecifierPublic)
	class FText                                   SystemMessage_ChatMatchServerClosed;               // 0x00F0(0x0018)(Edit, BlueprintVisible, Config, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDTextDesignTunables">();
	}
	static class UDBDTextDesignTunables* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDTextDesignTunables>();
	}
};
static_assert(alignof(UDBDTextDesignTunables) == 0x000008, "Wrong alignment on UDBDTextDesignTunables");
static_assert(sizeof(UDBDTextDesignTunables) == 0x000108, "Wrong size on UDBDTextDesignTunables");
static_assert(offsetof(UDBDTextDesignTunables, LegalTextTitle) == 0x000030, "Member 'UDBDTextDesignTunables::LegalTextTitle' has a wrong offset!");
static_assert(offsetof(UDBDTextDesignTunables, LegalText) == 0x000048, "Member 'UDBDTextDesignTunables::LegalText' has a wrong offset!");
static_assert(offsetof(UDBDTextDesignTunables, ConsentTextTitle) == 0x000060, "Member 'UDBDTextDesignTunables::ConsentTextTitle' has a wrong offset!");
static_assert(offsetof(UDBDTextDesignTunables, ConsentText) == 0x000078, "Member 'UDBDTextDesignTunables::ConsentText' has a wrong offset!");
static_assert(offsetof(UDBDTextDesignTunables, LegalTextSIEA) == 0x000090, "Member 'UDBDTextDesignTunables::LegalTextSIEA' has a wrong offset!");
static_assert(offsetof(UDBDTextDesignTunables, LegalTextSIEE) == 0x0000A8, "Member 'UDBDTextDesignTunables::LegalTextSIEE' has a wrong offset!");
static_assert(offsetof(UDBDTextDesignTunables, SystemMessage_ChatDisconnected) == 0x0000C0, "Member 'UDBDTextDesignTunables::SystemMessage_ChatDisconnected' has a wrong offset!");
static_assert(offsetof(UDBDTextDesignTunables, SystemMessage_ChatReturnedToLobby) == 0x0000D8, "Member 'UDBDTextDesignTunables::SystemMessage_ChatReturnedToLobby' has a wrong offset!");
static_assert(offsetof(UDBDTextDesignTunables, SystemMessage_ChatMatchServerClosed) == 0x0000F0, "Member 'UDBDTextDesignTunables::SystemMessage_ChatMatchServerClosed' has a wrong offset!");

// Class DeadByDaylight.SlasherMovementComponent
// 0x0080 (0x14A0 - 0x1420)
class USlasherMovementComponent final : public UDBDCharacterMovementComponent
{
public:
	uint8                                         Pad_1420[0x18];                                    // 0x1420(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnHitLedgeEvent;                                   // 0x1438(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         OnHitLedgeEventCooldown;                           // 0x1448(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_144C[0x54];                                    // 0x144C(0x0054)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnHitLedgeEvent__DelegateSignature();

	float GetBaseMaxSpeed() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SlasherMovementComponent">();
	}
	static class USlasherMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USlasherMovementComponent>();
	}
};
static_assert(alignof(USlasherMovementComponent) == 0x000010, "Wrong alignment on USlasherMovementComponent");
static_assert(sizeof(USlasherMovementComponent) == 0x0014A0, "Wrong size on USlasherMovementComponent");
static_assert(offsetof(USlasherMovementComponent, OnHitLedgeEvent) == 0x001438, "Member 'USlasherMovementComponent::OnHitLedgeEvent' has a wrong offset!");
static_assert(offsetof(USlasherMovementComponent, OnHitLedgeEventCooldown) == 0x001448, "Member 'USlasherMovementComponent::OnHitLedgeEventCooldown' has a wrong offset!");

// Class DeadByDaylight.GameTypeModifierDefaults
// 0x0050 (0x0088 - 0x0038)
class UGameTypeModifierDefaults final : public UDataAsset
{
public:
	TMap<EGameTypeModifierName, struct FTypeFlexibleTunable> Modifiers;                                         // 0x0038(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameTypeModifierDefaults">();
	}
	static class UGameTypeModifierDefaults* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameTypeModifierDefaults>();
	}
};
static_assert(alignof(UGameTypeModifierDefaults) == 0x000008, "Wrong alignment on UGameTypeModifierDefaults");
static_assert(sizeof(UGameTypeModifierDefaults) == 0x000088, "Wrong size on UGameTypeModifierDefaults");
static_assert(offsetof(UGameTypeModifierDefaults, Modifiers) == 0x000038, "Member 'UGameTypeModifierDefaults::Modifiers' has a wrong offset!");

// Class DeadByDaylight.FriendSearchPopupScreen
// 0x0060 (0x01A8 - 0x0148)
class UFriendSearchPopupScreen final : public UGenericPopupScreen
{
public:
	uint8                                         Pad_148[0x60];                                     // 0x0148(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAcceptFriendInvite(const class FString& FriendKrakenID);
	void OnFriendSearchStart(const class FString& SearchText);
	void OnInviteFriend(const class FString& FriendKrakenID, bool IsOffNetwork);
	void OnUnblockPlayer(const class FString& FriendKrakenID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FriendSearchPopupScreen">();
	}
	static class UFriendSearchPopupScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFriendSearchPopupScreen>();
	}
};
static_assert(alignof(UFriendSearchPopupScreen) == 0x000008, "Wrong alignment on UFriendSearchPopupScreen");
static_assert(sizeof(UFriendSearchPopupScreen) == 0x0001A8, "Wrong size on UFriendSearchPopupScreen");

// Class DeadByDaylight.DBDDiceRoller
// 0x0000 (0x0030 - 0x0030)
class UDBDDiceRoller final : public UBlueprintFunctionLibrary
{
public:
	static bool CalculateOverTimeRollResult(const class AActor* RollingActor, float BaseProbability, float DeltaTime, float ExpectedTime, float MultiplicativeModifier, float AdditiveModifier);
	static bool CalculateRollResult(const class AActor* RollingActor, float BaseProbability, float MultiplicativeModifier, float AdditiveModifier);
	static bool CalculateTickedRollResult(const class AActor* RollingActor, float BaseProbability, float Ticks, float MultiplicativeModifier, float AdditiveModifier);
	static float GetInteractionRollSuccessPercentageByDiceRollType(const class UInteractionDefinition* Interaction, const class ADBDPlayer* RollingPlayer, EDiceRollType DiceRollType);
	static bool GetRollResultByDiceRollType(const class ADBDPlayer* RollingPlayer, EDiceRollType DiceRollType);
	static bool GetRollResultByTunableValue(const class AActor* RollingActor, class FName TunableValueName, float MultiplicativeModifier, float AdditiveModifier);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDDiceRoller">();
	}
	static class UDBDDiceRoller* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDDiceRoller>();
	}
};
static_assert(alignof(UDBDDiceRoller) == 0x000008, "Wrong alignment on UDBDDiceRoller");
static_assert(sizeof(UDBDDiceRoller) == 0x000030, "Wrong size on UDBDDiceRoller");

// Class DeadByDaylight.SkillData
// 0x0028 (0x0060 - 0x0038)
class USkillData final : public UDataAsset
{
public:
	TArray<TSubclassOf<class USkill>>             Skills;                                            // 0x0038(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          IsInnateSkill;                                     // 0x0048(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FDBDTunableRowHandleOverride>   TunableOverrides;                                  // 0x0050(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SkillData">();
	}
	static class USkillData* GetDefaultObj()
	{
		return GetDefaultObjImpl<USkillData>();
	}
};
static_assert(alignof(USkillData) == 0x000008, "Wrong alignment on USkillData");
static_assert(sizeof(USkillData) == 0x000060, "Wrong size on USkillData");
static_assert(offsetof(USkillData, Skills) == 0x000038, "Member 'USkillData::Skills' has a wrong offset!");
static_assert(offsetof(USkillData, IsInnateSkill) == 0x000048, "Member 'USkillData::IsInnateSkill' has a wrong offset!");
static_assert(offsetof(USkillData, TunableOverrides) == 0x000050, "Member 'USkillData::TunableOverrides' has a wrong offset!");

// Class DeadByDaylight.DedicatedServerStartupInitializerInterface
// 0x0000 (0x0030 - 0x0030)
class IDedicatedServerStartupInitializerInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DedicatedServerStartupInitializerInterface">();
	}
	static class IDedicatedServerStartupInitializerInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IDedicatedServerStartupInitializerInterface>();
	}
};
static_assert(alignof(IDedicatedServerStartupInitializerInterface) == 0x000008, "Wrong alignment on IDedicatedServerStartupInitializerInterface");
static_assert(sizeof(IDedicatedServerStartupInitializerInterface) == 0x000030, "Wrong size on IDedicatedServerStartupInitializerInterface");

// Class DeadByDaylight.UMGHudEditorDragConstraintWidget
// 0x0060 (0x0308 - 0x02A8)
class UUMGHudEditorDragConstraintWidget final : public UUserWidget
{
public:
	class USizeBox*                               LinkSizeBox;                                       // 0x02A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUserWidget*                            _childWidget;                                      // 0x02B0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUserWidget*                            _parentWidget;                                     // 0x02B8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C0[0x48];                                     // 0x02C0(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGHudEditorDragConstraintWidget">();
	}
	static class UUMGHudEditorDragConstraintWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGHudEditorDragConstraintWidget>();
	}
};
static_assert(alignof(UUMGHudEditorDragConstraintWidget) == 0x000008, "Wrong alignment on UUMGHudEditorDragConstraintWidget");
static_assert(sizeof(UUMGHudEditorDragConstraintWidget) == 0x000308, "Wrong size on UUMGHudEditorDragConstraintWidget");
static_assert(offsetof(UUMGHudEditorDragConstraintWidget, LinkSizeBox) == 0x0002A8, "Member 'UUMGHudEditorDragConstraintWidget::LinkSizeBox' has a wrong offset!");
static_assert(offsetof(UUMGHudEditorDragConstraintWidget, _childWidget) == 0x0002B0, "Member 'UUMGHudEditorDragConstraintWidget::_childWidget' has a wrong offset!");
static_assert(offsetof(UUMGHudEditorDragConstraintWidget, _parentWidget) == 0x0002B8, "Member 'UUMGHudEditorDragConstraintWidget::_parentWidget' has a wrong offset!");

// Class DeadByDaylight.SurvivorHitCosmeticHandler
// 0x0030 (0x0060 - 0x0030)
class USurvivorHitCosmeticHandler final : public UBaseReversibleInstantActionHandler
{
public:
	class UNiagaraComponent*                      _bloodSpurts;                                      // 0x0030(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_38[0x28];                                      // 0x0038(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnMontageStarted(const struct FAnimationMontageDescriptor& AnimMontageID, const float PlayRate);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SurvivorHitCosmeticHandler">();
	}
	static class USurvivorHitCosmeticHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<USurvivorHitCosmeticHandler>();
	}
};
static_assert(alignof(USurvivorHitCosmeticHandler) == 0x000008, "Wrong alignment on USurvivorHitCosmeticHandler");
static_assert(sizeof(USurvivorHitCosmeticHandler) == 0x000060, "Wrong size on USurvivorHitCosmeticHandler");
static_assert(offsetof(USurvivorHitCosmeticHandler, _bloodSpurts) == 0x000030, "Member 'USurvivorHitCosmeticHandler::_bloodSpurts' has a wrong offset!");

// Class DeadByDaylight.DBDEasyAntiCheatEGS
// 0x0000 (0x00C0 - 0x00C0)
class UDBDEasyAntiCheatEGS final : public UDBDEasyAntiCheatClient
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDEasyAntiCheatEGS">();
	}
	static class UDBDEasyAntiCheatEGS* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDEasyAntiCheatEGS>();
	}
};
static_assert(alignof(UDBDEasyAntiCheatEGS) == 0x000008, "Wrong alignment on UDBDEasyAntiCheatEGS");
static_assert(sizeof(UDBDEasyAntiCheatEGS) == 0x0000C0, "Wrong size on UDBDEasyAntiCheatEGS");

// Class DeadByDaylight.DragDropOperation_Widget
// 0x0128 (0x01C0 - 0x0098)
class UDragDropOperation_Widget final : public UDragDropOperation
{
public:
	class UUMGDragWidget*                         Widget;                                            // 0x0098(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPanelWidget*                           WidgetParent;                                      // 0x00A0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              StartPosition;                                     // 0x00A8(0x0010)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              WidgetLocalScale;                                  // 0x00B8(0x0010)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C8[0x18];                                      // 0x00C8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WidgetLocalOpacity;                                // 0x00E0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E4[0x4];                                       // 0x00E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              OnDropOffset;                                      // 0x00E8(0x0010)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              OnDragOffset;                                      // 0x00F8(0x0010)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAnchors                               WidgetSlotAnchors;                                 // 0x0108(0x0020)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FMargin                                WidgetSlotOffsets;                                 // 0x0128(0x0010)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector2D                              WidgetSlotPosition;                                // 0x0138(0x0010)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              WidgetSlotSize;                                    // 0x0148(0x0010)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          WidgetSlotAutoSize;                                // 0x0158(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_159[0x7];                                      // 0x0159(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              WidgetSlotAlignment;                               // 0x0160(0x0010)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WidgetSlotZOrder;                                  // 0x0170(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_174[0x4];                                      // 0x0174(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UUMGDragWidget*                         ChildLinkWidget;                                   // 0x0178(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_180[0x40];                                     // 0x0180(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DragDropOperation_Widget">();
	}
	static class UDragDropOperation_Widget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDragDropOperation_Widget>();
	}
};
static_assert(alignof(UDragDropOperation_Widget) == 0x000008, "Wrong alignment on UDragDropOperation_Widget");
static_assert(sizeof(UDragDropOperation_Widget) == 0x0001C0, "Wrong size on UDragDropOperation_Widget");
static_assert(offsetof(UDragDropOperation_Widget, Widget) == 0x000098, "Member 'UDragDropOperation_Widget::Widget' has a wrong offset!");
static_assert(offsetof(UDragDropOperation_Widget, WidgetParent) == 0x0000A0, "Member 'UDragDropOperation_Widget::WidgetParent' has a wrong offset!");
static_assert(offsetof(UDragDropOperation_Widget, StartPosition) == 0x0000A8, "Member 'UDragDropOperation_Widget::StartPosition' has a wrong offset!");
static_assert(offsetof(UDragDropOperation_Widget, WidgetLocalScale) == 0x0000B8, "Member 'UDragDropOperation_Widget::WidgetLocalScale' has a wrong offset!");
static_assert(offsetof(UDragDropOperation_Widget, WidgetLocalOpacity) == 0x0000E0, "Member 'UDragDropOperation_Widget::WidgetLocalOpacity' has a wrong offset!");
static_assert(offsetof(UDragDropOperation_Widget, OnDropOffset) == 0x0000E8, "Member 'UDragDropOperation_Widget::OnDropOffset' has a wrong offset!");
static_assert(offsetof(UDragDropOperation_Widget, OnDragOffset) == 0x0000F8, "Member 'UDragDropOperation_Widget::OnDragOffset' has a wrong offset!");
static_assert(offsetof(UDragDropOperation_Widget, WidgetSlotAnchors) == 0x000108, "Member 'UDragDropOperation_Widget::WidgetSlotAnchors' has a wrong offset!");
static_assert(offsetof(UDragDropOperation_Widget, WidgetSlotOffsets) == 0x000128, "Member 'UDragDropOperation_Widget::WidgetSlotOffsets' has a wrong offset!");
static_assert(offsetof(UDragDropOperation_Widget, WidgetSlotPosition) == 0x000138, "Member 'UDragDropOperation_Widget::WidgetSlotPosition' has a wrong offset!");
static_assert(offsetof(UDragDropOperation_Widget, WidgetSlotSize) == 0x000148, "Member 'UDragDropOperation_Widget::WidgetSlotSize' has a wrong offset!");
static_assert(offsetof(UDragDropOperation_Widget, WidgetSlotAutoSize) == 0x000158, "Member 'UDragDropOperation_Widget::WidgetSlotAutoSize' has a wrong offset!");
static_assert(offsetof(UDragDropOperation_Widget, WidgetSlotAlignment) == 0x000160, "Member 'UDragDropOperation_Widget::WidgetSlotAlignment' has a wrong offset!");
static_assert(offsetof(UDragDropOperation_Widget, WidgetSlotZOrder) == 0x000170, "Member 'UDragDropOperation_Widget::WidgetSlotZOrder' has a wrong offset!");
static_assert(offsetof(UDragDropOperation_Widget, ChildLinkWidget) == 0x000178, "Member 'UDragDropOperation_Widget::ChildLinkWidget' has a wrong offset!");

// Class DeadByDaylight.DBDEasyAntiCheatServer
// 0x0070 (0x00C0 - 0x0050)
class UDBDEasyAntiCheatServer final : public UDBDEasyAntiCheatEnable
{
public:
	uint8                                         Pad_50[0x70];                                      // 0x0050(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDEasyAntiCheatServer">();
	}
	static class UDBDEasyAntiCheatServer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDEasyAntiCheatServer>();
	}
};
static_assert(alignof(UDBDEasyAntiCheatServer) == 0x000008, "Wrong alignment on UDBDEasyAntiCheatServer");
static_assert(sizeof(UDBDEasyAntiCheatServer) == 0x0000C0, "Wrong size on UDBDEasyAntiCheatServer");

// Class DeadByDaylight.DBDGameAnalyticsComponent
// 0x0010 (0x00B8 - 0x00A8)
class UDBDGameAnalyticsComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x10];                                      // 0x00A8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDGameAnalyticsComponent">();
	}
	static class UDBDGameAnalyticsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDGameAnalyticsComponent>();
	}
};
static_assert(alignof(UDBDGameAnalyticsComponent) == 0x000008, "Wrong alignment on UDBDGameAnalyticsComponent");
static_assert(sizeof(UDBDGameAnalyticsComponent) == 0x0000B8, "Wrong size on UDBDGameAnalyticsComponent");

// Class DeadByDaylight.GameObjectiveBase
// 0x0040 (0x02E0 - 0x02A0)
class AGameObjectiveBase : public AInfo
{
public:
	uint8                                         Pad_2A0[0x30];                                     // 0x02A0(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           _type;                                             // 0x02D0(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isCompleted;                                      // 0x02DC(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isForcedCompleted;                                // 0x02DD(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isActive;                                         // 0x02DE(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2DF[0x1];                                      // 0x02DF(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_IsCompleted(bool WasCompleted);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameObjectiveBase">();
	}
	static class AGameObjectiveBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGameObjectiveBase>();
	}
};
static_assert(alignof(AGameObjectiveBase) == 0x000008, "Wrong alignment on AGameObjectiveBase");
static_assert(sizeof(AGameObjectiveBase) == 0x0002E0, "Wrong size on AGameObjectiveBase");
static_assert(offsetof(AGameObjectiveBase, _type) == 0x0002D0, "Member 'AGameObjectiveBase::_type' has a wrong offset!");
static_assert(offsetof(AGameObjectiveBase, _isCompleted) == 0x0002DC, "Member 'AGameObjectiveBase::_isCompleted' has a wrong offset!");
static_assert(offsetof(AGameObjectiveBase, _isForcedCompleted) == 0x0002DD, "Member 'AGameObjectiveBase::_isForcedCompleted' has a wrong offset!");
static_assert(offsetof(AGameObjectiveBase, _isActive) == 0x0002DE, "Member 'AGameObjectiveBase::_isActive' has a wrong offset!");

// Class DeadByDaylight.DisableOutlineComponent
// 0x0020 (0x00C8 - 0x00A8)
class UDisableOutlineComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x10];                                      // 0x00A8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameplayTag>                   _enableOutlineEvents;                              // 0x00B8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DisableOutlineComponent">();
	}
	static class UDisableOutlineComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDisableOutlineComponent>();
	}
};
static_assert(alignof(UDisableOutlineComponent) == 0x000008, "Wrong alignment on UDisableOutlineComponent");
static_assert(sizeof(UDisableOutlineComponent) == 0x0000C8, "Wrong size on UDisableOutlineComponent");
static_assert(offsetof(UDisableOutlineComponent, _enableOutlineEvents) == 0x0000B8, "Member 'UDisableOutlineComponent::_enableOutlineEvents' has a wrong offset!");

// Class DeadByDaylight.DBDGameEngine
// 0x0008 (0x1178 - 0x1170)
class UDBDGameEngine final : public UGameEngine
{
public:
	uint8                                         Pad_1170[0x8];                                     // 0x1170(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDGameEngine">();
	}
	static class UDBDGameEngine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDGameEngine>();
	}
};
static_assert(alignof(UDBDGameEngine) == 0x000008, "Wrong alignment on UDBDGameEngine");
static_assert(sizeof(UDBDGameEngine) == 0x001178, "Wrong size on UDBDGameEngine");

// Class DeadByDaylight.DBDGameEventForwarderComponent
// 0x0010 (0x00B8 - 0x00A8)
class UDBDGameEventForwarderComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x10];                                      // 0x00A8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDGameEventForwarderComponent">();
	}
	static class UDBDGameEventForwarderComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDGameEventForwarderComponent>();
	}
};
static_assert(alignof(UDBDGameEventForwarderComponent) == 0x000008, "Wrong alignment on UDBDGameEventForwarderComponent");
static_assert(sizeof(UDBDGameEventForwarderComponent) == 0x0000B8, "Wrong size on UDBDGameEventForwarderComponent");

// Class DeadByDaylight.EndGameEntity
// 0x0008 (0x02A8 - 0x02A0)
class AEndGameEntity : public AActor
{
public:
	class UDBDSkeletalMeshComponentBudgeted*      _skeletalMeshComponent;                            // 0x02A0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndGameEntity">();
	}
	static class AEndGameEntity* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndGameEntity>();
	}
};
static_assert(alignof(AEndGameEntity) == 0x000008, "Wrong alignment on AEndGameEntity");
static_assert(sizeof(AEndGameEntity) == 0x0002A8, "Wrong size on AEndGameEntity");
static_assert(offsetof(AEndGameEntity, _skeletalMeshComponent) == 0x0002A0, "Member 'AEndGameEntity::_skeletalMeshComponent' has a wrong offset!");

// Class DeadByDaylight.DBDGameEventUtilities
// 0x0000 (0x0030 - 0x0030)
class UDBDGameEventUtilities final : public UBlueprintFunctionLibrary
{
public:
	static void Authority_AccumulateOngoingGameEvent(const class UObject* WorldContextObject, const struct FGameplayTag& GameEventType, class ADBDPlayer* Instigator, class AActor* Target, float CustomValue, float OngoingWaitTime, class UObject* CustomObjectParameter, int32 CustomIntValue);
	static void Authority_DispatcherFireGameEvent(const class UObject* WorldContextObject, const struct FGameplayTag& GameEventType, bool broadcastOverNetwork, class ADBDPlayer* Instigator, class AActor* Target, float CustomValue, class UObject* CustomObjectParameter, int32 CustomIntValue);
	static void DispatcherFireGameEvent(const class UObject* WorldContextObject, const struct FGameplayTag& GameEventType, bool broadcastOverNetwork, class ADBDPlayer* Instigator, class AActor* Target, float CustomValue, class UObject* CustomObjectParameter, int32 CustomIntValue);
	static void LocallyDispatchGameEvent(const class UObject* WorldContextObject, const struct FGameplayTag& GameEventType, class ADBDPlayer* Instigator, class AActor* Target, float CustomValue, class UObject* CustomObjectParameter, int32 CustomIntValue);
	static void RemotelyDispatchGameEvent(const class UObject* WorldContextObject, const struct FGameplayTag& GameEventType, class ADBDPlayer* Instigator, class AActor* Target, float CustomValue, class UObject* CustomObjectParameter, int32 CustomIntValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDGameEventUtilities">();
	}
	static class UDBDGameEventUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDGameEventUtilities>();
	}
};
static_assert(alignof(UDBDGameEventUtilities) == 0x000008, "Wrong alignment on UDBDGameEventUtilities");
static_assert(sizeof(UDBDGameEventUtilities) == 0x000030, "Wrong size on UDBDGameEventUtilities");

// Class DeadByDaylight.DBDGameSession
// 0x0060 (0x0320 - 0x02C0)
class ADBDGameSession final : public AGameSession
{
public:
	uint8                                         Pad_2C0[0x60];                                     // 0x02C0(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDGameSession">();
	}
	static class ADBDGameSession* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDGameSession>();
	}
};
static_assert(alignof(ADBDGameSession) == 0x000008, "Wrong alignment on ADBDGameSession");
static_assert(sizeof(ADBDGameSession) == 0x000320, "Wrong size on ADBDGameSession");

// Class DeadByDaylight.EnergyPoweredInterface
// 0x0000 (0x0030 - 0x0030)
class IEnergyPoweredInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnergyPoweredInterface">();
	}
	static class IEnergyPoweredInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IEnergyPoweredInterface>();
	}
};
static_assert(alignof(IEnergyPoweredInterface) == 0x000008, "Wrong alignment on IEnergyPoweredInterface");
static_assert(sizeof(IEnergyPoweredInterface) == 0x000030, "Wrong size on IEnergyPoweredInterface");

// Class DeadByDaylight.DBDPlayerController
// 0x0230 (0x0B78 - 0x0948)
class ADBDPlayerController : public ADBDPlayerControllerBase
{
public:
	FMulticastInlineDelegateProperty_             OnPawnLeavingGame;                                 // 0x0948(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnLocallyObservedChanged;                          // 0x0958(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_968[0x98];                                     // 0x0968(0x0098)(Fixing Size After Last Property [ Dumper-7 ])
	class ANetworkFenceActor*                     _theFence;                                         // 0x0A00(0x0008)(Net, ZeroConstructor, Transient, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A08[0x8];                                      // 0x0A08(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UDBDBaseInputHandler*                   _inputHandler;                                     // 0x0A10(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A18[0x128];                                    // 0x0A18(0x0128)(Fixing Size After Last Property [ Dumper-7 ])
	class APawn*                                  _aiPawn;                                           // 0x0B40(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B48[0x8];                                      // 0x0B48(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	EPlayerRole                                   _controllerGameRole;                               // 0x0B50(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B51[0x27];                                     // 0x0B51(0x0027)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActivateAI(bool Activate, int32 PlayerRank);
	void Client_SetPlayerFinishStats(const struct FPlayerFinishStats& Stats);
	void Client_SetSpectatorMode(bool On);
	void Client_SetSpectatorModeInEditor(bool On, class ADBDPlayerState* SpectatingPlayerState);
	void Client_SpectateAI(class APawn* AiPawn);
	void ImplementRunLockMechanic();
	void OnRep_Fence();
	void Server_ClientTimeSinceLastLoadingProgress(float LastProgression);
	void Server_DebugSend(const class FString& Data);
	void Server_ForceGameObjectivesCompleted(bool COMPLETED);
	void Server_InitiateSecretRewardProcess(const TArray<class FName>& UnclaimedIds);
	void Server_LeaveGame(bool JoiningLobby);
	void Server_NotifyHasMoved();
	void Server_RequestEndGame();
	void Server_SetReadyToTravel();
	void Server_SetSpectatorMode(bool On);
	void Server_SetSpectatorModeInEditor(bool On, class ADBDPlayerState* SpectatingPlayerState);
	void ServerViewPlayer(const class FString& PlayerName);

	class APawn* GetAIPawn() const;
	class ADBDPlayer* GetControlledPlayer() const;
	class ADBDPlayer* GetSpectatedPlayer() const;
	class ADBDPlayerState* GetSpectatedPlayerState() const;
	bool IsSpectating() const;
	bool MobileJoystickInput_Pressed(int32 JoystickIndex) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDPlayerController">();
	}
	static class ADBDPlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDPlayerController>();
	}
};
static_assert(alignof(ADBDPlayerController) == 0x000008, "Wrong alignment on ADBDPlayerController");
static_assert(sizeof(ADBDPlayerController) == 0x000B78, "Wrong size on ADBDPlayerController");
static_assert(offsetof(ADBDPlayerController, OnPawnLeavingGame) == 0x000948, "Member 'ADBDPlayerController::OnPawnLeavingGame' has a wrong offset!");
static_assert(offsetof(ADBDPlayerController, OnLocallyObservedChanged) == 0x000958, "Member 'ADBDPlayerController::OnLocallyObservedChanged' has a wrong offset!");
static_assert(offsetof(ADBDPlayerController, _theFence) == 0x000A00, "Member 'ADBDPlayerController::_theFence' has a wrong offset!");
static_assert(offsetof(ADBDPlayerController, _inputHandler) == 0x000A10, "Member 'ADBDPlayerController::_inputHandler' has a wrong offset!");
static_assert(offsetof(ADBDPlayerController, _aiPawn) == 0x000B40, "Member 'ADBDPlayerController::_aiPawn' has a wrong offset!");
static_assert(offsetof(ADBDPlayerController, _controllerGameRole) == 0x000B50, "Member 'ADBDPlayerController::_controllerGameRole' has a wrong offset!");

// Class DeadByDaylight.DBDGameUserSettings
// 0x0398 (0x04E8 - 0x0150)
class UDBDGameUserSettings final : public UGameUserSettings
{
public:
	TArray<struct FInputActionKeyMapping>         ActionMappings;                                    // 0x0150(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<struct FInputAxisKeyMapping>           AxisMappings;                                      // 0x0160(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSetCustomizedHudsTimestamp;                      // 0x0170(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_180[0x18];                                     // 0x0180(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DeviceLoginTokenID;                                // 0x0198(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         ScalabilityLevel;                                  // 0x01A8(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          AutoScalabilitySet;                                // 0x01AC(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          AutoAdjust;                                        // 0x01AD(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1AE[0x2];                                      // 0x01AE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ScreenRenderSize;                                  // 0x01B0(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          HUDConstrainedAspectRatio;                         // 0x01B4(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1B5[0x3];                                      // 0x01B5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MenuScaleFactor;                                   // 0x01B8(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         HudScaleFactor;                                    // 0x01BC(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         SkillCheckScaleFactor;                             // 0x01C0(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          LargeText;                                         // 0x01C4(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          BloodwebInteractionBehaviour;                      // 0x01C5(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          TerrorRadiusVisualFeedback;                        // 0x01C6(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1C7[0x1];                                      // 0x01C7(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         FieldOfView;                                       // 0x01C8(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          HUDPlayerNamesVisibility;                          // 0x01CC(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          HUDKillerHookCountVisibility;                      // 0x01CD(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          HUDScoreEventsVisibility;                          // 0x01CE(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          HUDUseItemPickupPopupAbridgedVersion;              // 0x01CF(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          LegacyPrestigePortraits;                           // 0x01D0(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1D1[0x3];                                      // 0x01D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        FPSLimitMode;                                      // 0x01D4(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         AntiAliasingMode;                                  // 0x01D8(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          EnableFSR;                                         // 0x01DC(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1DD[0x3];                                      // 0x01DD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SharpnessValue;                                    // 0x01E0(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         XeSSMode;                                          // 0x01E4(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         MainVolume;                                        // 0x01E8(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          MainVolumeOn;                                      // 0x01EC(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1ED[0x3];                                      // 0x01ED(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MenuMusicVolume;                                   // 0x01F0(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          MenuMusicVolumeOn;                                 // 0x01F4(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          UseHeadphones;                                     // 0x01F5(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          MuteOnFocusLost;                                   // 0x01F6(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          HapticsVibrationPS5;                               // 0x01F7(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         KillerCameraSensitivity;                           // 0x01F8(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         SurvivorCameraSensitivity;                         // 0x01FC(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         KillerMouseSensitivity;                            // 0x0200(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         SurvivorMouseSensitivity;                          // 0x0204(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         KillerControllerSensitivity;                       // 0x0208(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         SurvivorControllerSensitivity;                     // 0x020C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          AimAssist;                                         // 0x0210(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_211[0x3];                                      // 0x0211(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ControlType;                                       // 0x0214(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          InvertY;                                           // 0x0218(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          SurvivorInvertY;                                   // 0x0219(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          KillerToggleInteractions;                          // 0x021A(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          SurvivorToggleInteractions;                        // 0x021B(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          SprintToCancel;                                    // 0x021C(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_21D[0x3];                                      // 0x021D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Language;                                          // 0x0220(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          LanguageIsDefinedByPlayer;                         // 0x0230(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_231[0x3];                                      // 0x0231(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         HighestWeightSeenNews;                             // 0x0234(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FSharedAuthenticationTokenInformation  SharedLoginInformation;                            // 0x0238(0x0030)(Config, NativeAccessSpecifierPrivate)
	uint32                                        LastPanelContextId;                                // 0x0268(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          ArchivesAutoPlayVoiceOver;                         // 0x026C(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          ArchivesFullscreenTextVisibility;                  // 0x026D(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          HasAcceptedCrossplayPopup;                         // 0x026E(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          HasAcceptedProgressionSystemInfoPopup;             // 0x026F(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          HasAcceptedHapticsVibrationPopup;                  // 0x0270(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_271[0x7];                                      // 0x0271(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBonusTierTooltipVisibility            BonusTierTooltipVisibility;                        // 0x0278(0x0018)(Config, NativeAccessSpecifierPrivate)
	bool                                          UseAtlantaCustomizedHuds;                          // 0x0290(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          UseAtlantaSurvivorQuickTurn;                       // 0x0291(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          UseAtlantaKillerQuickTurn;                         // 0x0292(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_293[0x5];                                      // 0x0293(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAtlantaCustomizedHudSettings>  AtlantaCustomizedHuds;                             // 0x0298(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A8[0x8];                                      // 0x02A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          ShowPortraitBorder;                                // 0x02B0(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B1[0x7];                                      // 0x02B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 PartyPrivacyState;                                 // 0x02B8(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         ColorBlindMode;                                    // 0x02C8(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         ColorBlindModeIntensity;                           // 0x02CC(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          BeginnerMode;                                      // 0x02D0(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          FogCommunications;                                 // 0x02D1(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          Subtitles;                                         // 0x02D2(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D3[0x1];                                      // 0x02D3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SubtitlesBackgroundOpacity;                        // 0x02D4(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         SubtitlesSize;                                     // 0x02D8(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsAnonymousMode;                                   // 0x02DC(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          AllowCopyrightedMusic;                             // 0x02DD(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          HideYourName;                                      // 0x02DE(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          HideOtherNames;                                    // 0x02DF(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          HiddenMatchmakingDelay;                            // 0x02E0(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2E1[0x3];                                      // 0x02E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PlayerCardAnimationMode;                           // 0x02E4(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          ArchivesChallengeProgression;                      // 0x02E8(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          DailyChallengeProgression;                         // 0x02E9(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          WeeklyChallengeProgression;                        // 0x02EA(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          EventChallengeProgression;                         // 0x02EB(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          AllChallengeProgression;                           // 0x02EC(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2ED[0x1FB];                                    // 0x02ED(0x01FB)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UDBDGameUserSettings* GetDBDGameUserSettings();

	bool GetArchivesChallengeProgression() const;
	bool GetBloodwebInteractionBehaviour() const;
	EColorVisionDeficiency GetColorBlindMode() const;
	int32 GetColorBlindModeIntensity() const;
	int32 GetFieldOfView() const;
	bool GetHUDKillerHookCountVisibility() const;
	bool GetHUDPlayerNamesVisibility() const;
	int32 GetHudScaleFactor() const;
	bool GetHUDScoreEventsVisibility() const;
	bool GetHUDUseItemPickupPopupAbridgedVersion() const;
	bool GetLargeText() const;
	bool GetLegacyPrestigePortraits() const;
	int32 GetMenuScaleFactor() const;
	int32 GetSkillCheckScaleFactor() const;
	bool GetTerrorRadiusVisualFeedback() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDGameUserSettings">();
	}
	static class UDBDGameUserSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDGameUserSettings>();
	}
};
static_assert(alignof(UDBDGameUserSettings) == 0x000008, "Wrong alignment on UDBDGameUserSettings");
static_assert(sizeof(UDBDGameUserSettings) == 0x0004E8, "Wrong size on UDBDGameUserSettings");
static_assert(offsetof(UDBDGameUserSettings, ActionMappings) == 0x000150, "Member 'UDBDGameUserSettings::ActionMappings' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, AxisMappings) == 0x000160, "Member 'UDBDGameUserSettings::AxisMappings' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, OnSetCustomizedHudsTimestamp) == 0x000170, "Member 'UDBDGameUserSettings::OnSetCustomizedHudsTimestamp' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, DeviceLoginTokenID) == 0x000198, "Member 'UDBDGameUserSettings::DeviceLoginTokenID' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, ScalabilityLevel) == 0x0001A8, "Member 'UDBDGameUserSettings::ScalabilityLevel' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, AutoScalabilitySet) == 0x0001AC, "Member 'UDBDGameUserSettings::AutoScalabilitySet' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, AutoAdjust) == 0x0001AD, "Member 'UDBDGameUserSettings::AutoAdjust' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, ScreenRenderSize) == 0x0001B0, "Member 'UDBDGameUserSettings::ScreenRenderSize' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, HUDConstrainedAspectRatio) == 0x0001B4, "Member 'UDBDGameUserSettings::HUDConstrainedAspectRatio' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, MenuScaleFactor) == 0x0001B8, "Member 'UDBDGameUserSettings::MenuScaleFactor' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, HudScaleFactor) == 0x0001BC, "Member 'UDBDGameUserSettings::HudScaleFactor' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, SkillCheckScaleFactor) == 0x0001C0, "Member 'UDBDGameUserSettings::SkillCheckScaleFactor' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, LargeText) == 0x0001C4, "Member 'UDBDGameUserSettings::LargeText' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, BloodwebInteractionBehaviour) == 0x0001C5, "Member 'UDBDGameUserSettings::BloodwebInteractionBehaviour' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, TerrorRadiusVisualFeedback) == 0x0001C6, "Member 'UDBDGameUserSettings::TerrorRadiusVisualFeedback' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, FieldOfView) == 0x0001C8, "Member 'UDBDGameUserSettings::FieldOfView' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, HUDPlayerNamesVisibility) == 0x0001CC, "Member 'UDBDGameUserSettings::HUDPlayerNamesVisibility' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, HUDKillerHookCountVisibility) == 0x0001CD, "Member 'UDBDGameUserSettings::HUDKillerHookCountVisibility' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, HUDScoreEventsVisibility) == 0x0001CE, "Member 'UDBDGameUserSettings::HUDScoreEventsVisibility' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, HUDUseItemPickupPopupAbridgedVersion) == 0x0001CF, "Member 'UDBDGameUserSettings::HUDUseItemPickupPopupAbridgedVersion' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, LegacyPrestigePortraits) == 0x0001D0, "Member 'UDBDGameUserSettings::LegacyPrestigePortraits' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, FPSLimitMode) == 0x0001D4, "Member 'UDBDGameUserSettings::FPSLimitMode' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, AntiAliasingMode) == 0x0001D8, "Member 'UDBDGameUserSettings::AntiAliasingMode' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, EnableFSR) == 0x0001DC, "Member 'UDBDGameUserSettings::EnableFSR' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, SharpnessValue) == 0x0001E0, "Member 'UDBDGameUserSettings::SharpnessValue' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, XeSSMode) == 0x0001E4, "Member 'UDBDGameUserSettings::XeSSMode' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, MainVolume) == 0x0001E8, "Member 'UDBDGameUserSettings::MainVolume' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, MainVolumeOn) == 0x0001EC, "Member 'UDBDGameUserSettings::MainVolumeOn' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, MenuMusicVolume) == 0x0001F0, "Member 'UDBDGameUserSettings::MenuMusicVolume' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, MenuMusicVolumeOn) == 0x0001F4, "Member 'UDBDGameUserSettings::MenuMusicVolumeOn' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, UseHeadphones) == 0x0001F5, "Member 'UDBDGameUserSettings::UseHeadphones' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, MuteOnFocusLost) == 0x0001F6, "Member 'UDBDGameUserSettings::MuteOnFocusLost' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, HapticsVibrationPS5) == 0x0001F7, "Member 'UDBDGameUserSettings::HapticsVibrationPS5' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, KillerCameraSensitivity) == 0x0001F8, "Member 'UDBDGameUserSettings::KillerCameraSensitivity' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, SurvivorCameraSensitivity) == 0x0001FC, "Member 'UDBDGameUserSettings::SurvivorCameraSensitivity' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, KillerMouseSensitivity) == 0x000200, "Member 'UDBDGameUserSettings::KillerMouseSensitivity' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, SurvivorMouseSensitivity) == 0x000204, "Member 'UDBDGameUserSettings::SurvivorMouseSensitivity' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, KillerControllerSensitivity) == 0x000208, "Member 'UDBDGameUserSettings::KillerControllerSensitivity' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, SurvivorControllerSensitivity) == 0x00020C, "Member 'UDBDGameUserSettings::SurvivorControllerSensitivity' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, AimAssist) == 0x000210, "Member 'UDBDGameUserSettings::AimAssist' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, ControlType) == 0x000214, "Member 'UDBDGameUserSettings::ControlType' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, InvertY) == 0x000218, "Member 'UDBDGameUserSettings::InvertY' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, SurvivorInvertY) == 0x000219, "Member 'UDBDGameUserSettings::SurvivorInvertY' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, KillerToggleInteractions) == 0x00021A, "Member 'UDBDGameUserSettings::KillerToggleInteractions' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, SurvivorToggleInteractions) == 0x00021B, "Member 'UDBDGameUserSettings::SurvivorToggleInteractions' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, SprintToCancel) == 0x00021C, "Member 'UDBDGameUserSettings::SprintToCancel' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, Language) == 0x000220, "Member 'UDBDGameUserSettings::Language' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, LanguageIsDefinedByPlayer) == 0x000230, "Member 'UDBDGameUserSettings::LanguageIsDefinedByPlayer' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, HighestWeightSeenNews) == 0x000234, "Member 'UDBDGameUserSettings::HighestWeightSeenNews' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, SharedLoginInformation) == 0x000238, "Member 'UDBDGameUserSettings::SharedLoginInformation' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, LastPanelContextId) == 0x000268, "Member 'UDBDGameUserSettings::LastPanelContextId' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, ArchivesAutoPlayVoiceOver) == 0x00026C, "Member 'UDBDGameUserSettings::ArchivesAutoPlayVoiceOver' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, ArchivesFullscreenTextVisibility) == 0x00026D, "Member 'UDBDGameUserSettings::ArchivesFullscreenTextVisibility' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, HasAcceptedCrossplayPopup) == 0x00026E, "Member 'UDBDGameUserSettings::HasAcceptedCrossplayPopup' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, HasAcceptedProgressionSystemInfoPopup) == 0x00026F, "Member 'UDBDGameUserSettings::HasAcceptedProgressionSystemInfoPopup' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, HasAcceptedHapticsVibrationPopup) == 0x000270, "Member 'UDBDGameUserSettings::HasAcceptedHapticsVibrationPopup' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, BonusTierTooltipVisibility) == 0x000278, "Member 'UDBDGameUserSettings::BonusTierTooltipVisibility' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, UseAtlantaCustomizedHuds) == 0x000290, "Member 'UDBDGameUserSettings::UseAtlantaCustomizedHuds' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, UseAtlantaSurvivorQuickTurn) == 0x000291, "Member 'UDBDGameUserSettings::UseAtlantaSurvivorQuickTurn' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, UseAtlantaKillerQuickTurn) == 0x000292, "Member 'UDBDGameUserSettings::UseAtlantaKillerQuickTurn' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, AtlantaCustomizedHuds) == 0x000298, "Member 'UDBDGameUserSettings::AtlantaCustomizedHuds' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, ShowPortraitBorder) == 0x0002B0, "Member 'UDBDGameUserSettings::ShowPortraitBorder' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, PartyPrivacyState) == 0x0002B8, "Member 'UDBDGameUserSettings::PartyPrivacyState' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, ColorBlindMode) == 0x0002C8, "Member 'UDBDGameUserSettings::ColorBlindMode' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, ColorBlindModeIntensity) == 0x0002CC, "Member 'UDBDGameUserSettings::ColorBlindModeIntensity' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, BeginnerMode) == 0x0002D0, "Member 'UDBDGameUserSettings::BeginnerMode' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, FogCommunications) == 0x0002D1, "Member 'UDBDGameUserSettings::FogCommunications' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, Subtitles) == 0x0002D2, "Member 'UDBDGameUserSettings::Subtitles' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, SubtitlesBackgroundOpacity) == 0x0002D4, "Member 'UDBDGameUserSettings::SubtitlesBackgroundOpacity' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, SubtitlesSize) == 0x0002D8, "Member 'UDBDGameUserSettings::SubtitlesSize' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, IsAnonymousMode) == 0x0002DC, "Member 'UDBDGameUserSettings::IsAnonymousMode' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, AllowCopyrightedMusic) == 0x0002DD, "Member 'UDBDGameUserSettings::AllowCopyrightedMusic' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, HideYourName) == 0x0002DE, "Member 'UDBDGameUserSettings::HideYourName' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, HideOtherNames) == 0x0002DF, "Member 'UDBDGameUserSettings::HideOtherNames' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, HiddenMatchmakingDelay) == 0x0002E0, "Member 'UDBDGameUserSettings::HiddenMatchmakingDelay' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, PlayerCardAnimationMode) == 0x0002E4, "Member 'UDBDGameUserSettings::PlayerCardAnimationMode' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, ArchivesChallengeProgression) == 0x0002E8, "Member 'UDBDGameUserSettings::ArchivesChallengeProgression' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, DailyChallengeProgression) == 0x0002E9, "Member 'UDBDGameUserSettings::DailyChallengeProgression' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, WeeklyChallengeProgression) == 0x0002EA, "Member 'UDBDGameUserSettings::WeeklyChallengeProgression' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, EventChallengeProgression) == 0x0002EB, "Member 'UDBDGameUserSettings::EventChallengeProgression' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, AllChallengeProgression) == 0x0002EC, "Member 'UDBDGameUserSettings::AllChallengeProgression' has a wrong offset!");

// Class DeadByDaylight.SpawnedActorReplicationComponent
// 0x0010 (0x00B8 - 0x00A8)
class USpawnedActorReplicationComponent final : public UActorComponent
{
public:
	TArray<class FName>                           _replicatedTags;                                   // 0x00A8(0x0010)(Net, ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpawnedActorReplicationComponent">();
	}
	static class USpawnedActorReplicationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpawnedActorReplicationComponent>();
	}
};
static_assert(alignof(USpawnedActorReplicationComponent) == 0x000008, "Wrong alignment on USpawnedActorReplicationComponent");
static_assert(sizeof(USpawnedActorReplicationComponent) == 0x0000B8, "Wrong size on USpawnedActorReplicationComponent");
static_assert(offsetof(USpawnedActorReplicationComponent, _replicatedTags) == 0x0000A8, "Member 'USpawnedActorReplicationComponent::_replicatedTags' has a wrong offset!");

// Class DeadByDaylight.DBDGameViewportClient
// 0x0030 (0x0400 - 0x03D0)
class UDBDGameViewportClient final : public UGameViewportClient
{
public:
	uint8                                         Pad_3D0[0x30];                                     // 0x03D0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDGameViewportClient">();
	}
	static class UDBDGameViewportClient* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDGameViewportClient>();
	}
};
static_assert(alignof(UDBDGameViewportClient) == 0x000008, "Wrong alignment on UDBDGameViewportClient");
static_assert(sizeof(UDBDGameViewportClient) == 0x000400, "Wrong size on UDBDGameViewportClient");

// Class DeadByDaylight.EmblemRankUtilities
// 0x0000 (0x0030 - 0x0030)
class UEmblemRankUtilities final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EmblemRankUtilities">();
	}
	static class UEmblemRankUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEmblemRankUtilities>();
	}
};
static_assert(alignof(UEmblemRankUtilities) == 0x000008, "Wrong alignment on UEmblemRankUtilities");
static_assert(sizeof(UEmblemRankUtilities) == 0x000030, "Wrong size on UEmblemRankUtilities");

// Class DeadByDaylight.DBDGame_Lobby
// 0x0080 (0x0480 - 0x0400)
class ADBDGame_Lobby final : public ADBDBaseGameMode
{
public:
	uint8                                         Pad_400[0x18];                                     // 0x0400(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UIdentityValidation*                    _identityValidation;                               // 0x0418(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_420[0x60];                                     // 0x0420(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DBD_AddBotToLobby(int32 SelectedCharacter, const class FString& Item, const class FString& Addon1, const class FString& Addon2, const class FString& Offering, const class FString& Perk1, const class FString& Perk2, const class FString& Perk3, const class FString& Perk4, int32 Rank);
	void DBD_AddBotToLobbyByName(const class FString& SelectedCharacter, const class FString& Item, const class FString& Addon1, const class FString& Addon2, const class FString& Offering, const class FString& Perk1, const class FString& Perk2, const class FString& Perk3, const class FString& Perk4, int32 Rank);
	void DBD_AddBotToLobbyNoLoadout(int32 SelectedCharacter);
	void DBD_AddBotToLobbyNoLoadoutByName(const class FString& SelectedCharacter);
	void DBD_FillLobby();
	void DBD_FillLobbyWithBotsByName(const class FString& SelectedKiller, int32 Rank);
	void DBD_RemoveBotByIndex(int32 botIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDGame_Lobby">();
	}
	static class ADBDGame_Lobby* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDGame_Lobby>();
	}
};
static_assert(alignof(ADBDGame_Lobby) == 0x000008, "Wrong alignment on ADBDGame_Lobby");
static_assert(sizeof(ADBDGame_Lobby) == 0x000480, "Wrong size on ADBDGame_Lobby");
static_assert(offsetof(ADBDGame_Lobby, _identityValidation) == 0x000418, "Member 'ADBDGame_Lobby::_identityValidation' has a wrong offset!");

// Class DeadByDaylight.DBDGame_Menu
// 0x0020 (0x0420 - 0x0400)
class ADBDGame_Menu final : public ADBDBaseGameMode
{
public:
	bool                                          StartWithSlasher;                                  // 0x0400(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_401[0x7];                                      // 0x0401(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ALevelSequenceActor*                    _sequenceFadeActor;                                // 0x0408(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ALevelSequenceActor*                    _sequenceIntroActor;                               // 0x0410(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ALevelSequenceActor*                    _sequenceLoopActor;                                // 0x0418(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDGame_Menu">();
	}
	static class ADBDGame_Menu* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDGame_Menu>();
	}
};
static_assert(alignof(ADBDGame_Menu) == 0x000008, "Wrong alignment on ADBDGame_Menu");
static_assert(sizeof(ADBDGame_Menu) == 0x000420, "Wrong size on ADBDGame_Menu");
static_assert(offsetof(ADBDGame_Menu, StartWithSlasher) == 0x000400, "Member 'ADBDGame_Menu::StartWithSlasher' has a wrong offset!");
static_assert(offsetof(ADBDGame_Menu, _sequenceFadeActor) == 0x000408, "Member 'ADBDGame_Menu::_sequenceFadeActor' has a wrong offset!");
static_assert(offsetof(ADBDGame_Menu, _sequenceIntroActor) == 0x000410, "Member 'ADBDGame_Menu::_sequenceIntroActor' has a wrong offset!");
static_assert(offsetof(ADBDGame_Menu, _sequenceLoopActor) == 0x000418, "Member 'ADBDGame_Menu::_sequenceLoopActor' has a wrong offset!");

// Class DeadByDaylight.UMGBaseAlertWidget
// 0x0048 (0x02F0 - 0x02A8)
class UUMGBaseAlertWidget : public UUserWidget
{
public:
	uint8                                         Pad_2A8[0x48];                                     // 0x02A8(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGBaseAlertWidget">();
	}
	static class UUMGBaseAlertWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGBaseAlertWidget>();
	}
};
static_assert(alignof(UUMGBaseAlertWidget) == 0x000008, "Wrong alignment on UUMGBaseAlertWidget");
static_assert(sizeof(UUMGBaseAlertWidget) == 0x0002F0, "Wrong size on UUMGBaseAlertWidget");

// Class DeadByDaylight.UMGGameplayAlertWidget
// 0x0000 (0x02F0 - 0x02F0)
class UUMGGameplayAlertWidget final : public UUMGBaseAlertWidget
{
public:
	void UpdateWidget(const struct FStatusEffectSlotData& StatusEffectData, const struct FInventorySlotData& OriginatorData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGGameplayAlertWidget">();
	}
	static class UUMGGameplayAlertWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGGameplayAlertWidget>();
	}
};
static_assert(alignof(UUMGGameplayAlertWidget) == 0x000008, "Wrong alignment on UUMGGameplayAlertWidget");
static_assert(sizeof(UUMGGameplayAlertWidget) == 0x0002F0, "Wrong size on UUMGGameplayAlertWidget");

// Class DeadByDaylight.DBDGame_Start
// 0x0088 (0x0488 - 0x0400)
class ADBDGame_Start final : public ADBDBaseGameMode
{
public:
	uint8                                         Pad_400[0x60];                                     // 0x0400(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	TScriptInterface<class IClientStartupInitializerInterface> _startupInitializer;                               // 0x0460(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_470[0x18];                                     // 0x0470(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDGame_Start">();
	}
	static class ADBDGame_Start* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDGame_Start>();
	}
};
static_assert(alignof(ADBDGame_Start) == 0x000008, "Wrong alignment on ADBDGame_Start");
static_assert(sizeof(ADBDGame_Start) == 0x000488, "Wrong size on ADBDGame_Start");
static_assert(offsetof(ADBDGame_Start, _startupInitializer) == 0x000460, "Member 'ADBDGame_Start::_startupInitializer' has a wrong offset!");

// Class DeadByDaylight.EscapeDoorAnimInstance
// 0x0010 (0x0370 - 0x0360)
class UEscapeDoorAnimInstance : public USleepingAnimInstance
{
public:
	bool                                          _isOpen;                                           // 0x0360(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isOpenByKiller;                                   // 0x0361(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_362[0xE];                                      // 0x0362(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void PlaySound(class UAkAudioEvent* AkEvent);
	void SetIsOpen(bool IsOpen);
	void SetIsOpenByKiller(const bool IsOpenByKiller);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EscapeDoorAnimInstance">();
	}
	static class UEscapeDoorAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEscapeDoorAnimInstance>();
	}
};
static_assert(alignof(UEscapeDoorAnimInstance) == 0x000010, "Wrong alignment on UEscapeDoorAnimInstance");
static_assert(sizeof(UEscapeDoorAnimInstance) == 0x000370, "Wrong size on UEscapeDoorAnimInstance");
static_assert(offsetof(UEscapeDoorAnimInstance, _isOpen) == 0x000360, "Member 'UEscapeDoorAnimInstance::_isOpen' has a wrong offset!");
static_assert(offsetof(UEscapeDoorAnimInstance, _isOpenByKiller) == 0x000361, "Member 'UEscapeDoorAnimInstance::_isOpenByKiller' has a wrong offset!");

// Class DeadByDaylight.DreamSnareOutlineUpdateStrategy
// 0x0018 (0x0108 - 0x00F0)
class UDreamSnareOutlineUpdateStrategy final : public UDefaultOutlineUpdateStrategy
{
public:
	uint8                                         Pad_F0[0x18];                                      // 0x00F0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DreamSnareOutlineUpdateStrategy">();
	}
	static class UDreamSnareOutlineUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDreamSnareOutlineUpdateStrategy>();
	}
};
static_assert(alignof(UDreamSnareOutlineUpdateStrategy) == 0x000008, "Wrong alignment on UDreamSnareOutlineUpdateStrategy");
static_assert(sizeof(UDreamSnareOutlineUpdateStrategy) == 0x000108, "Wrong size on UDreamSnareOutlineUpdateStrategy");

// Class DeadByDaylight.DBDGenericTeamAgentInterface
// 0x0000 (0x0030 - 0x0030)
class IDBDGenericTeamAgentInterface final : public IGenericTeamAgentInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDGenericTeamAgentInterface">();
	}
	static class IDBDGenericTeamAgentInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IDBDGenericTeamAgentInterface>();
	}
};
static_assert(alignof(IDBDGenericTeamAgentInterface) == 0x000008, "Wrong alignment on IDBDGenericTeamAgentInterface");
static_assert(sizeof(IDBDGenericTeamAgentInterface) == 0x000030, "Wrong size on IDBDGenericTeamAgentInterface");

// Class DeadByDaylight.DBDUtilTimer
// 0x0000 (0x0030 - 0x0030)
class UDBDUtilTimer final : public UBlueprintFunctionLibrary
{
public:
	static float GetPercentTimeElapsed(const struct FDBDTimer& Timer);
	static float GetPercentTimeLeft(const struct FDBDTimer& Timer);
	static float GetStartTime(const struct FDBDTimer& Timer);
	static float GetTimeElapsed(const struct FDBDTimer& Timer);
	static float GetTimeLeft(const struct FDBDTimer& Timer);
	static bool IsDone(const struct FDBDTimer& Timer);
	static void Reset(struct FDBDTimer& Timer);
	static void ResetTo(struct FDBDTimer& Timer, float Time);
	static void Stop(struct FDBDTimer& Timer);
	static void Update(struct FDBDTimer& Timer, float DeltaTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDUtilTimer">();
	}
	static class UDBDUtilTimer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDUtilTimer>();
	}
};
static_assert(alignof(UDBDUtilTimer) == 0x000008, "Wrong alignment on UDBDUtilTimer");
static_assert(sizeof(UDBDUtilTimer) == 0x000030, "Wrong size on UDBDUtilTimer");

// Class DeadByDaylight.DBDInGameHud
// 0x0028 (0x03C8 - 0x03A0)
class ADBDInGameHud : public ADBDBaseHud
{
public:
	class UFont*                                  _debugFontObj;                                     // 0x03A0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A8[0x18];                                     // 0x03A8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UCompetenceDebugger*                    _competenceDebugger;                               // 0x03C0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDInGameHud">();
	}
	static class ADBDInGameHud* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDInGameHud>();
	}
};
static_assert(alignof(ADBDInGameHud) == 0x000008, "Wrong alignment on ADBDInGameHud");
static_assert(sizeof(ADBDInGameHud) == 0x0003C8, "Wrong size on ADBDInGameHud");
static_assert(offsetof(ADBDInGameHud, _debugFontObj) == 0x0003A0, "Member 'ADBDInGameHud::_debugFontObj' has a wrong offset!");
static_assert(offsetof(ADBDInGameHud, _competenceDebugger) == 0x0003C0, "Member 'ADBDInGameHud::_competenceDebugger' has a wrong offset!");

// Class DeadByDaylight.DBDInitPlayerQueryYesNo
// 0x0080 (0x00B0 - 0x0030)
class UDBDInitPlayerQueryYesNo : public UDBDInitPlayerQuery
{
public:
	uint8                                         Pad_30[0x80];                                      // 0x0030(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDInitPlayerQueryYesNo">();
	}
	static class UDBDInitPlayerQueryYesNo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDInitPlayerQueryYesNo>();
	}
};
static_assert(alignof(UDBDInitPlayerQueryYesNo) == 0x000008, "Wrong alignment on UDBDInitPlayerQueryYesNo");
static_assert(sizeof(UDBDInitPlayerQueryYesNo) == 0x0000B0, "Wrong size on UDBDInitPlayerQueryYesNo");

// Class DeadByDaylight.DBDInitPlayerQueryYesNoSizeWifi
// 0x0010 (0x00C0 - 0x00B0)
class UDBDInitPlayerQueryYesNoSizeWifi final : public UDBDInitPlayerQueryYesNo
{
public:
	uint8                                         Pad_B0[0x10];                                      // 0x00B0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDInitPlayerQueryYesNoSizeWifi">();
	}
	static class UDBDInitPlayerQueryYesNoSizeWifi* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDInitPlayerQueryYesNoSizeWifi>();
	}
};
static_assert(alignof(UDBDInitPlayerQueryYesNoSizeWifi) == 0x000008, "Wrong alignment on UDBDInitPlayerQueryYesNoSizeWifi");
static_assert(sizeof(UDBDInitPlayerQueryYesNoSizeWifi) == 0x0000C0, "Wrong size on UDBDInitPlayerQueryYesNoSizeWifi");

// Class DeadByDaylight.StatusView
// 0x0070 (0x0310 - 0x02A0)
class AStatusView : public AActor
{
public:
	bool                                          _isActive;                                         // 0x02A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A1[0x3];                                      // 0x02A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _level;                                            // 0x02A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _percentageFill;                                   // 0x02A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isClockwiseTimer;                                 // 0x02AC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2AD[0x5B];                                     // 0x02AD(0x005B)(Fixing Size After Last Property [ Dumper-7 ])
	class ADBDPlayer*                             _localDBDPlayer;                                   // 0x0308(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void FireNotification(const struct FStatusViewSource& StatusViewSource);
	void ResetView(const class ADBDPlayer* DBDPlayer);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StatusView">();
	}
	static class AStatusView* GetDefaultObj()
	{
		return GetDefaultObjImpl<AStatusView>();
	}
};
static_assert(alignof(AStatusView) == 0x000008, "Wrong alignment on AStatusView");
static_assert(sizeof(AStatusView) == 0x000310, "Wrong size on AStatusView");
static_assert(offsetof(AStatusView, _isActive) == 0x0002A0, "Member 'AStatusView::_isActive' has a wrong offset!");
static_assert(offsetof(AStatusView, _level) == 0x0002A4, "Member 'AStatusView::_level' has a wrong offset!");
static_assert(offsetof(AStatusView, _percentageFill) == 0x0002A8, "Member 'AStatusView::_percentageFill' has a wrong offset!");
static_assert(offsetof(AStatusView, _isClockwiseTimer) == 0x0002AC, "Member 'AStatusView::_isClockwiseTimer' has a wrong offset!");
static_assert(offsetof(AStatusView, _localDBDPlayer) == 0x000308, "Member 'AStatusView::_localDBDPlayer' has a wrong offset!");

// Class DeadByDaylight.DBDInventoryUtilities
// 0x0000 (0x0030 - 0x0030)
class UDBDInventoryUtilities final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDInventoryUtilities">();
	}
	static class UDBDInventoryUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDInventoryUtilities>();
	}
};
static_assert(alignof(UDBDInventoryUtilities) == 0x000008, "Wrong alignment on UDBDInventoryUtilities");
static_assert(sizeof(UDBDInventoryUtilities) == 0x000030, "Wrong size on UDBDInventoryUtilities");

// Class DeadByDaylight.StateTagApplyingZone
// 0x0010 (0x0340 - 0x0330)
class UStateTagApplyingZone final : public UConfigurableCollisionComponent
{
public:
	TArray<struct FGameplayTag>                   _tagsToAdd;                                        // 0x0328(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class ADBDPlayer>                 _classFilter;                                      // 0x0338(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StateTagApplyingZone">();
	}
	static class UStateTagApplyingZone* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStateTagApplyingZone>();
	}
};
static_assert(alignof(UStateTagApplyingZone) == 0x000010, "Wrong alignment on UStateTagApplyingZone");
static_assert(sizeof(UStateTagApplyingZone) == 0x000340, "Wrong size on UStateTagApplyingZone");
static_assert(offsetof(UStateTagApplyingZone, _tagsToAdd) == 0x000328, "Member 'UStateTagApplyingZone::_tagsToAdd' has a wrong offset!");
static_assert(offsetof(UStateTagApplyingZone, _classFilter) == 0x000338, "Member 'UStateTagApplyingZone::_classFilter' has a wrong offset!");

// Class DeadByDaylight.EditorActorVisualization
// 0x00A0 (0x0360 - 0x02C0)
class UEditorActorVisualization final : public USceneComponent
{
public:
	TSoftClassPtr<class UClass>                   ActorVisualization;                                // 0x02C0(0x0038)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F8[0x8];                                      // 0x02F8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             RelativeTransform;                                 // 0x0300(0x0060)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EditorActorVisualization">();
	}
	static class UEditorActorVisualization* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEditorActorVisualization>();
	}
};
static_assert(alignof(UEditorActorVisualization) == 0x000010, "Wrong alignment on UEditorActorVisualization");
static_assert(sizeof(UEditorActorVisualization) == 0x000360, "Wrong size on UEditorActorVisualization");
static_assert(offsetof(UEditorActorVisualization, ActorVisualization) == 0x0002C0, "Member 'UEditorActorVisualization::ActorVisualization' has a wrong offset!");
static_assert(offsetof(UEditorActorVisualization, RelativeTransform) == 0x000300, "Member 'UEditorActorVisualization::RelativeTransform' has a wrong offset!");

// Class DeadByDaylight.DBDKeyDisplayInfo
// 0x0190 (0x01C0 - 0x0030)
class UDBDKeyDisplayInfo final : public UObject
{
public:
	TMap<class FName, struct FKeyDisplayInfo>     _keyDisplayInfoMap;                                // 0x0030(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_80[0xA0];                                      // 0x0080(0x00A0)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EInputInteractionType, class FName>      _interactionTypeToActionMap_Camper;                // 0x0120(0x0050)(NativeAccessSpecifierPrivate)
	TMap<EInputInteractionType, class FName>      _interactionTypeToActionMap_Slasher;               // 0x0170(0x0050)(NativeAccessSpecifierPrivate)

public:
	const class FName GetActionForInteractionType(EPlayerRole PlayerRole, EInputInteractionType InputInteractionType, bool UseGamePad, bool IgnoreInteractMash);
	const struct FKey GetFirstKeyForAction(class UPlayerInput* PlayerInput, class FName ActionName, bool UseGamePad);
	const struct FKeyDisplayInfo GetKeyDisplayInfo(const struct FKey& Key);
	const struct FKeyDisplayInfo GetKeyDisplayInfoForInteractionType(class UPlayerInput* PlayerInput, EPlayerRole PlayerRole, EInputInteractionType InteractionType, bool UseGamePad);
	const bool IsExcludedKey(const struct FKey& Key);
	const bool IsIgnoredKey(const struct FKey& Key);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDKeyDisplayInfo">();
	}
	static class UDBDKeyDisplayInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDKeyDisplayInfo>();
	}
};
static_assert(alignof(UDBDKeyDisplayInfo) == 0x000008, "Wrong alignment on UDBDKeyDisplayInfo");
static_assert(sizeof(UDBDKeyDisplayInfo) == 0x0001C0, "Wrong size on UDBDKeyDisplayInfo");
static_assert(offsetof(UDBDKeyDisplayInfo, _keyDisplayInfoMap) == 0x000030, "Member 'UDBDKeyDisplayInfo::_keyDisplayInfoMap' has a wrong offset!");
static_assert(offsetof(UDBDKeyDisplayInfo, _interactionTypeToActionMap_Camper) == 0x000120, "Member 'UDBDKeyDisplayInfo::_interactionTypeToActionMap_Camper' has a wrong offset!");
static_assert(offsetof(UDBDKeyDisplayInfo, _interactionTypeToActionMap_Slasher) == 0x000170, "Member 'UDBDKeyDisplayInfo::_interactionTypeToActionMap_Slasher' has a wrong offset!");

// Class DeadByDaylight.SpecialEventLoadingScreen
// 0x0018 (0x0140 - 0x0128)
class USpecialEventLoadingScreen final : public UScreenBase
{
public:
	uint8                                         Pad_128[0x18];                                     // 0x0128(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnLoadingTextTimerComplete() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpecialEventLoadingScreen">();
	}
	static class USpecialEventLoadingScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpecialEventLoadingScreen>();
	}
};
static_assert(alignof(USpecialEventLoadingScreen) == 0x000008, "Wrong alignment on USpecialEventLoadingScreen");
static_assert(sizeof(USpecialEventLoadingScreen) == 0x000140, "Wrong size on USpecialEventLoadingScreen");

// Class DeadByDaylight.DBDLobbyHud
// 0x0000 (0x03A0 - 0x03A0)
class ADBDLobbyHud final : public ADBDBaseHud
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDLobbyHud">();
	}
	static class ADBDLobbyHud* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDLobbyHud>();
	}
};
static_assert(alignof(ADBDLobbyHud) == 0x000008, "Wrong alignment on ADBDLobbyHud");
static_assert(sizeof(ADBDLobbyHud) == 0x0003A0, "Wrong size on ADBDLobbyHud");

// Class DeadByDaylight.DedicatedServerHandlerComponent
// 0x0038 (0x00E0 - 0x00A8)
class UDedicatedServerHandlerComponent final : public UActorComponent
{
public:
	TArray<struct FDailyRitualInstance>           _coreRituals;                                      // 0x00A8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B8[0x10];                                      // 0x00B8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         _ownedCharacters;                                  // 0x00C8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D8[0x8];                                       // 0x00D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnGameEvent(const struct FGameplayTag& GameEventType, const struct FGameEventData& GameEventData);
	void ReceiveGameEvent(EDBDScoreTypes ScoreType, float Amount, class AActor* Instigator, class AActor* Target);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DedicatedServerHandlerComponent">();
	}
	static class UDedicatedServerHandlerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDedicatedServerHandlerComponent>();
	}
};
static_assert(alignof(UDedicatedServerHandlerComponent) == 0x000008, "Wrong alignment on UDedicatedServerHandlerComponent");
static_assert(sizeof(UDedicatedServerHandlerComponent) == 0x0000E0, "Wrong size on UDedicatedServerHandlerComponent");
static_assert(offsetof(UDedicatedServerHandlerComponent, _coreRituals) == 0x0000A8, "Member 'UDedicatedServerHandlerComponent::_coreRituals' has a wrong offset!");
static_assert(offsetof(UDedicatedServerHandlerComponent, _ownedCharacters) == 0x0000C8, "Member 'UDedicatedServerHandlerComponent::_ownedCharacters' has a wrong offset!");

// Class DeadByDaylight.DBDLocalPlayer
// 0x0000 (0x02A8 - 0x02A8)
class UDBDLocalPlayer final : public ULocalPlayer
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDLocalPlayer">();
	}
	static class UDBDLocalPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDLocalPlayer>();
	}
};
static_assert(alignof(UDBDLocalPlayer) == 0x000008, "Wrong alignment on UDBDLocalPlayer");
static_assert(sizeof(UDBDLocalPlayer) == 0x0002A8, "Wrong size on UDBDLocalPlayer");

// Class DeadByDaylight.TriplanarDecalComponent
// 0x0050 (0x0310 - 0x02C0)
class UTriplanarDecalComponent final : public USceneComponent
{
public:
	float                                         MinHeight;                                         // 0x02C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Height;                                            // 0x02C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaskIntensity;                                     // 0x02C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CC[0x4];                                      // 0x02CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             TopTexture;                                        // 0x02D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             BottomTexture;                                     // 0x02D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             MaskTexture;                                       // 0x02E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDetailMode                                   MinQualitySetting;                                 // 0x02E8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E9[0x7];                                      // 0x02E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UDecalComponent*                        _triPlanarDecal;                                   // 0x02F0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UClass*                                 _triPlanarDecalClass;                              // 0x02F8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterial*                              _decalMaterial;                                    // 0x0300(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_308[0x8];                                      // 0x0308(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void UpdateTriplanarDecal();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TriplanarDecalComponent">();
	}
	static class UTriplanarDecalComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTriplanarDecalComponent>();
	}
};
static_assert(alignof(UTriplanarDecalComponent) == 0x000010, "Wrong alignment on UTriplanarDecalComponent");
static_assert(sizeof(UTriplanarDecalComponent) == 0x000310, "Wrong size on UTriplanarDecalComponent");
static_assert(offsetof(UTriplanarDecalComponent, MinHeight) == 0x0002C0, "Member 'UTriplanarDecalComponent::MinHeight' has a wrong offset!");
static_assert(offsetof(UTriplanarDecalComponent, Height) == 0x0002C4, "Member 'UTriplanarDecalComponent::Height' has a wrong offset!");
static_assert(offsetof(UTriplanarDecalComponent, MaskIntensity) == 0x0002C8, "Member 'UTriplanarDecalComponent::MaskIntensity' has a wrong offset!");
static_assert(offsetof(UTriplanarDecalComponent, TopTexture) == 0x0002D0, "Member 'UTriplanarDecalComponent::TopTexture' has a wrong offset!");
static_assert(offsetof(UTriplanarDecalComponent, BottomTexture) == 0x0002D8, "Member 'UTriplanarDecalComponent::BottomTexture' has a wrong offset!");
static_assert(offsetof(UTriplanarDecalComponent, MaskTexture) == 0x0002E0, "Member 'UTriplanarDecalComponent::MaskTexture' has a wrong offset!");
static_assert(offsetof(UTriplanarDecalComponent, MinQualitySetting) == 0x0002E8, "Member 'UTriplanarDecalComponent::MinQualitySetting' has a wrong offset!");
static_assert(offsetof(UTriplanarDecalComponent, _triPlanarDecal) == 0x0002F0, "Member 'UTriplanarDecalComponent::_triPlanarDecal' has a wrong offset!");
static_assert(offsetof(UTriplanarDecalComponent, _triPlanarDecalClass) == 0x0002F8, "Member 'UTriplanarDecalComponent::_triPlanarDecalClass' has a wrong offset!");
static_assert(offsetof(UTriplanarDecalComponent, _decalMaterial) == 0x000300, "Member 'UTriplanarDecalComponent::_decalMaterial' has a wrong offset!");

// Class DeadByDaylight.DBDMapFoliageDensityTunables
// 0x0010 (0x0040 - 0x0030)
class UDBDMapFoliageDensityTunables final : public UObject
{
public:
	TArray<struct FTypeFoliageToAutomateDensity>  FoliageToAutomateDensity;                          // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDMapFoliageDensityTunables">();
	}
	static class UDBDMapFoliageDensityTunables* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDMapFoliageDensityTunables>();
	}
};
static_assert(alignof(UDBDMapFoliageDensityTunables) == 0x000008, "Wrong alignment on UDBDMapFoliageDensityTunables");
static_assert(sizeof(UDBDMapFoliageDensityTunables) == 0x000040, "Wrong size on UDBDMapFoliageDensityTunables");
static_assert(offsetof(UDBDMapFoliageDensityTunables, FoliageToAutomateDensity) == 0x000030, "Member 'UDBDMapFoliageDensityTunables::FoliageToAutomateDensity' has a wrong offset!");

// Class DeadByDaylight.DBDMaterialBlueprintLibrary
// 0x0000 (0x0030 - 0x0030)
class UDBDMaterialBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static TArray<class UMaterialInstanceDynamic*> CreateDynamicMaterialInstanceForParticleSystem(class UParticleSystemComponent* System);
	static void SetTransformParameterInverseValueOnMaterialDynamic(class UMaterialInstanceDynamic* Material, class FName ParameterName, const struct FTransform& Value);
	static void SetTransformParameterValueOnMaterialDynamic(class UMaterialInstanceDynamic* Material, class FName ParameterName, const struct FTransform& Value);
	static void SetTransformParameterValueOnMeshComponent(class UMeshComponent* Mesh, class FName ParameterName, const struct FTransform& Value);
	static void SetVectorParameterValueOnMeshComponent(class UMeshComponent* Mesh, class FName ParameterName, const struct FLinearColor& Value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDMaterialBlueprintLibrary">();
	}
	static class UDBDMaterialBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDMaterialBlueprintLibrary>();
	}
};
static_assert(alignof(UDBDMaterialBlueprintLibrary) == 0x000008, "Wrong alignment on UDBDMaterialBlueprintLibrary");
static_assert(sizeof(UDBDMaterialBlueprintLibrary) == 0x000030, "Wrong size on UDBDMaterialBlueprintLibrary");

// Class DeadByDaylight.DBDMathBlueprintLibrary
// 0x0000 (0x0030 - 0x0030)
class UDBDMathBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static TArray<struct FLinearColor> TransformToMatrix(const struct FTransform& A);
	static struct FVector VectorAbsoluteValue(const struct FVector& A);
	static bool VectorIntersect(const struct FVector& OriginA, const struct FVector& ExtentA, const struct FVector& OriginB, const struct FVector& ExtentB);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDMathBlueprintLibrary">();
	}
	static class UDBDMathBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDMathBlueprintLibrary>();
	}
};
static_assert(alignof(UDBDMathBlueprintLibrary) == 0x000008, "Wrong alignment on UDBDMathBlueprintLibrary");
static_assert(sizeof(UDBDMathBlueprintLibrary) == 0x000030, "Wrong size on UDBDMathBlueprintLibrary");

// Class DeadByDaylight.SurvivorOutlineUpdateStrategy
// 0x0088 (0x01D0 - 0x0148)
class USurvivorOutlineUpdateStrategy final : public USourceBasedOutlineUpdateStrategy
{
public:
	struct FLinearColor                           _inDangerColorForSurvivor;                         // 0x0148(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           _noRecoveryDyingColor;                             // 0x0158(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           _fullRecoveryDyingColor;                           // 0x0168(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           _saviourColorForSurvivor;                          // 0x0178(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           _colorForKiller;                                   // 0x0188(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           _locallyObservedSurvivorColor;                     // 0x0198(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTexture*                               _revealedGradient;                                 // 0x01A8(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTexture*                               _nonRevealedGradient;                              // 0x01B0(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FGameplayTag>                   _revealToKillerDurationTags;                       // 0x01B8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	float                                         _revealToKillerLingerTimer;                        // 0x01C8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _trappedIconActive;                                // 0x01CC(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1CD[0x3];                                      // 0x01CD(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static TArray<class UGameplayModifierContainer*> GetEffectsProtectingFromKillerAuraReading(const class ACamperPlayer* Subject, const class ASlasherPlayer* Killer);
	static bool IsActivelyHidingAuraFromKiller(const class ACamperPlayer* Subject, const class ASlasherPlayer* Witness);

	void SetTrappedIconActive(bool Value);

	bool IsBlockingAuraReadingFromKiller(const class ASlasherPlayer* Killer) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SurvivorOutlineUpdateStrategy">();
	}
	static class USurvivorOutlineUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<USurvivorOutlineUpdateStrategy>();
	}
};
static_assert(alignof(USurvivorOutlineUpdateStrategy) == 0x000008, "Wrong alignment on USurvivorOutlineUpdateStrategy");
static_assert(sizeof(USurvivorOutlineUpdateStrategy) == 0x0001D0, "Wrong size on USurvivorOutlineUpdateStrategy");
static_assert(offsetof(USurvivorOutlineUpdateStrategy, _inDangerColorForSurvivor) == 0x000148, "Member 'USurvivorOutlineUpdateStrategy::_inDangerColorForSurvivor' has a wrong offset!");
static_assert(offsetof(USurvivorOutlineUpdateStrategy, _noRecoveryDyingColor) == 0x000158, "Member 'USurvivorOutlineUpdateStrategy::_noRecoveryDyingColor' has a wrong offset!");
static_assert(offsetof(USurvivorOutlineUpdateStrategy, _fullRecoveryDyingColor) == 0x000168, "Member 'USurvivorOutlineUpdateStrategy::_fullRecoveryDyingColor' has a wrong offset!");
static_assert(offsetof(USurvivorOutlineUpdateStrategy, _saviourColorForSurvivor) == 0x000178, "Member 'USurvivorOutlineUpdateStrategy::_saviourColorForSurvivor' has a wrong offset!");
static_assert(offsetof(USurvivorOutlineUpdateStrategy, _colorForKiller) == 0x000188, "Member 'USurvivorOutlineUpdateStrategy::_colorForKiller' has a wrong offset!");
static_assert(offsetof(USurvivorOutlineUpdateStrategy, _locallyObservedSurvivorColor) == 0x000198, "Member 'USurvivorOutlineUpdateStrategy::_locallyObservedSurvivorColor' has a wrong offset!");
static_assert(offsetof(USurvivorOutlineUpdateStrategy, _revealedGradient) == 0x0001A8, "Member 'USurvivorOutlineUpdateStrategy::_revealedGradient' has a wrong offset!");
static_assert(offsetof(USurvivorOutlineUpdateStrategy, _nonRevealedGradient) == 0x0001B0, "Member 'USurvivorOutlineUpdateStrategy::_nonRevealedGradient' has a wrong offset!");
static_assert(offsetof(USurvivorOutlineUpdateStrategy, _revealToKillerDurationTags) == 0x0001B8, "Member 'USurvivorOutlineUpdateStrategy::_revealToKillerDurationTags' has a wrong offset!");
static_assert(offsetof(USurvivorOutlineUpdateStrategy, _revealToKillerLingerTimer) == 0x0001C8, "Member 'USurvivorOutlineUpdateStrategy::_revealToKillerLingerTimer' has a wrong offset!");
static_assert(offsetof(USurvivorOutlineUpdateStrategy, _trappedIconActive) == 0x0001CC, "Member 'USurvivorOutlineUpdateStrategy::_trappedIconActive' has a wrong offset!");

// Class DeadByDaylight.SearchableItemStrategy
// 0x0008 (0x0038 - 0x0030)
class USearchableItemStrategy : public UObject
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SearchableItemStrategy">();
	}
	static class USearchableItemStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<USearchableItemStrategy>();
	}
};
static_assert(alignof(USearchableItemStrategy) == 0x000008, "Wrong alignment on USearchableItemStrategy");
static_assert(sizeof(USearchableItemStrategy) == 0x000038, "Wrong size on USearchableItemStrategy");

// Class DeadByDaylight.DBDHookUtilities
// 0x0000 (0x0030 - 0x0030)
class UDBDHookUtilities final : public UBlueprintFunctionLibrary
{
public:
	static float ComputeHookStrugglePercent(const class ACamperPlayer* HookedCamper, float HookStruggleThreshold);
	static bool IsFreddyHook(class AMeatHook* TargetHook);
	static bool IsHagHook(class AMeatHook* TargetHook);
	static bool IsHookOf(class AMeatHook* TargetHook, const struct FGameplayTag& HookTag);
	static bool IsHuntressHook(class AMeatHook* TargetHook);
	static bool IsLegionHook(class AMeatHook* TargetHook);
	static bool IsNurseHook(class AMeatHook* TargetHook);
	static bool IsPigHook(class AMeatHook* TargetHook);
	static bool IsWraithHook(class AMeatHook* TargetHook);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDHookUtilities">();
	}
	static class UDBDHookUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDHookUtilities>();
	}
};
static_assert(alignof(UDBDHookUtilities) == 0x000008, "Wrong alignment on UDBDHookUtilities");
static_assert(sizeof(UDBDHookUtilities) == 0x000030, "Wrong size on UDBDHookUtilities");

// Class DeadByDaylight.DBDMenuGameState
// 0x0008 (0x0A88 - 0x0A80)
class ADBDMenuGameState final : public ADBDGameState
{
public:
	class UMenuForcedLODHandler*                  _menuForcedLODHandler;                             // 0x0A80(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDMenuGameState">();
	}
	static class ADBDMenuGameState* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDMenuGameState>();
	}
};
static_assert(alignof(ADBDMenuGameState) == 0x000008, "Wrong alignment on ADBDMenuGameState");
static_assert(sizeof(ADBDMenuGameState) == 0x000A88, "Wrong size on ADBDMenuGameState");
static_assert(offsetof(ADBDMenuGameState, _menuForcedLODHandler) == 0x000A80, "Member 'ADBDMenuGameState::_menuForcedLODHandler' has a wrong offset!");

// Class DeadByDaylight.SurvivorAudioHandlerComponent
// 0x01E0 (0x0328 - 0x0148)
class USurvivorAudioHandlerComponent final : public UDBDPlayerAudioHandlerComponent
{
public:
	uint8                                         Pad_148[0x1E0];                                    // 0x0148(0x01E0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SurvivorAudioHandlerComponent">();
	}
	static class USurvivorAudioHandlerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USurvivorAudioHandlerComponent>();
	}
};
static_assert(alignof(USurvivorAudioHandlerComponent) == 0x000008, "Wrong alignment on USurvivorAudioHandlerComponent");
static_assert(sizeof(USurvivorAudioHandlerComponent) == 0x000328, "Wrong size on USurvivorAudioHandlerComponent");

// Class DeadByDaylight.DBDMenuPlayer
// 0x0120 (0x0850 - 0x0730)
class ADBDMenuPlayer final : public ADBDBasePlayer
{
public:
	uint8                                         Pad_728[0x28];                                     // 0x0728(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          RoleSelected;                                      // 0x0750(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsOnline;                                          // 0x0751(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_752[0x6];                                      // 0x0752(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnItemEquipped;                                    // 0x0758(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_768[0x18];                                     // 0x0768(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   MoriPreviewAnimClass;                              // 0x0780(0x0038)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UMaterialInterface>      DarkMaterial;                                      // 0x07B8(0x0038)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EItemHandPosition                             _handPosition;                                     // 0x07F0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7F1[0x7];                                      // 0x07F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UDBDSkeletalMeshComponentBudgeted*      ItemMesh;                                          // 0x07F8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialHelper*                        MaterialHelper;                                    // 0x0800(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCustomizedSkeletalMesh*                _customizedSkeletalMeshComponent;                  // 0x0808(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   _equippedItemName;                                 // 0x0810(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_81C[0x28];                                     // 0x081C(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _blockRotationDuringSpawnAnimationDuration;        // 0x0844(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isLocalPlayerCharacter;                           // 0x0848(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isReady;                                          // 0x0849(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_84A[0x6];                                      // 0x084A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BeginCreateSequence();
	void BeginDestroySequence_Internal();
	void BlockCharacterRotation(bool ShouldBlock);
	class UCharmSpawnerComponent* GetCharmSpawnerComponent();
	bool HasSameCharacterInLobby();
	bool IsInMenuPlayer();
	void OnAllPlayersReadyInOnlineLobby();
	void OnCustomizationTransactionCompleted(ECustomizationCategory Category);
	void OnFinishSpawnOnStand();
	void OnGuestPlayerDespawned(class ADBDMenuPlayer* Player);
	void OnGuestPlayerReadyChanged(class ADBDMenuPlayer* Player, bool IsReady);
	void OnGuestPlayerSpawned(class ADBDMenuPlayer* Player);
	void OnIsReadyChanged(bool IsReady);
	void OnLocalPlayerReadyChanged(bool IsReady);
	void OnLocalPlayerSpawned();
	void OnPlayerMaxPrestige();
	void PlayCharacterLevelUpVFX();
	void RestartInSequence_Internal();
	void WrappedOnDestroyed(class AActor* DestroyedActor);

	float GetBlockRotationAfterSpawningTime() const;
	EGameFlowStep GetCurrentMenu() const;
	EItemHandPosition GetHandPosition() const;
	bool GetIsLocalPlayerCharacter() const;
	bool GetIsReady() const;
	bool ShouldApplyPositionOffset() const;
	bool ShouldShowSpawnAnimation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDMenuPlayer">();
	}
	static class ADBDMenuPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDMenuPlayer>();
	}
};
static_assert(alignof(ADBDMenuPlayer) == 0x000010, "Wrong alignment on ADBDMenuPlayer");
static_assert(sizeof(ADBDMenuPlayer) == 0x000850, "Wrong size on ADBDMenuPlayer");
static_assert(offsetof(ADBDMenuPlayer, RoleSelected) == 0x000750, "Member 'ADBDMenuPlayer::RoleSelected' has a wrong offset!");
static_assert(offsetof(ADBDMenuPlayer, IsOnline) == 0x000751, "Member 'ADBDMenuPlayer::IsOnline' has a wrong offset!");
static_assert(offsetof(ADBDMenuPlayer, OnItemEquipped) == 0x000758, "Member 'ADBDMenuPlayer::OnItemEquipped' has a wrong offset!");
static_assert(offsetof(ADBDMenuPlayer, MoriPreviewAnimClass) == 0x000780, "Member 'ADBDMenuPlayer::MoriPreviewAnimClass' has a wrong offset!");
static_assert(offsetof(ADBDMenuPlayer, DarkMaterial) == 0x0007B8, "Member 'ADBDMenuPlayer::DarkMaterial' has a wrong offset!");
static_assert(offsetof(ADBDMenuPlayer, _handPosition) == 0x0007F0, "Member 'ADBDMenuPlayer::_handPosition' has a wrong offset!");
static_assert(offsetof(ADBDMenuPlayer, ItemMesh) == 0x0007F8, "Member 'ADBDMenuPlayer::ItemMesh' has a wrong offset!");
static_assert(offsetof(ADBDMenuPlayer, MaterialHelper) == 0x000800, "Member 'ADBDMenuPlayer::MaterialHelper' has a wrong offset!");
static_assert(offsetof(ADBDMenuPlayer, _customizedSkeletalMeshComponent) == 0x000808, "Member 'ADBDMenuPlayer::_customizedSkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(ADBDMenuPlayer, _equippedItemName) == 0x000810, "Member 'ADBDMenuPlayer::_equippedItemName' has a wrong offset!");
static_assert(offsetof(ADBDMenuPlayer, _blockRotationDuringSpawnAnimationDuration) == 0x000844, "Member 'ADBDMenuPlayer::_blockRotationDuringSpawnAnimationDuration' has a wrong offset!");
static_assert(offsetof(ADBDMenuPlayer, _isLocalPlayerCharacter) == 0x000848, "Member 'ADBDMenuPlayer::_isLocalPlayerCharacter' has a wrong offset!");
static_assert(offsetof(ADBDMenuPlayer, _isReady) == 0x000849, "Member 'ADBDMenuPlayer::_isReady' has a wrong offset!");

// Class DeadByDaylight.DBDMenuSilhouette
// 0x0000 (0x02A0 - 0x02A0)
class ADBDMenuSilhouette final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDMenuSilhouette">();
	}
	static class ADBDMenuSilhouette* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDMenuSilhouette>();
	}
};
static_assert(alignof(ADBDMenuSilhouette) == 0x000008, "Wrong alignment on ADBDMenuSilhouette");
static_assert(sizeof(ADBDMenuSilhouette) == 0x0002A0, "Wrong size on ADBDMenuSilhouette");

// Class DeadByDaylight.DBDMistLocatorComponent
// 0x0000 (0x02C0 - 0x02C0)
class UDBDMistLocatorComponent final : public UDBDLocatorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDMistLocatorComponent">();
	}
	static class UDBDMistLocatorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDMistLocatorComponent>();
	}
};
static_assert(alignof(UDBDMistLocatorComponent) == 0x000010, "Wrong alignment on UDBDMistLocatorComponent");
static_assert(sizeof(UDBDMistLocatorComponent) == 0x0002C0, "Wrong size on UDBDMistLocatorComponent");

// Class DeadByDaylight.DBDMoriUtilities
// 0x0000 (0x0030 - 0x0030)
class UDBDMoriUtilities final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDMoriUtilities">();
	}
	static class UDBDMoriUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDMoriUtilities>();
	}
};
static_assert(alignof(UDBDMoriUtilities) == 0x000008, "Wrong alignment on UDBDMoriUtilities");
static_assert(sizeof(UDBDMoriUtilities) == 0x000030, "Wrong size on UDBDMoriUtilities");

// Class DeadByDaylight.DBDOnlineSessionClient
// 0x0028 (0x0240 - 0x0218)
class UDBDOnlineSessionClient final : public UOnlineSessionClient
{
public:
	uint8                                         Pad_218[0x28];                                     // 0x0218(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDOnlineSessionClient">();
	}
	static class UDBDOnlineSessionClient* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDOnlineSessionClient>();
	}
};
static_assert(alignof(UDBDOnlineSessionClient) == 0x000008, "Wrong alignment on UDBDOnlineSessionClient");
static_assert(sizeof(UDBDOnlineSessionClient) == 0x000240, "Wrong size on UDBDOnlineSessionClient");

// Class DeadByDaylight.DBDOutlineComponentStencilConfiguration
// 0x0000 (0x0138 - 0x0138)
class UDBDOutlineComponentStencilConfiguration final : public UDBDOutlineComponentConfiguration
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDOutlineComponentStencilConfiguration">();
	}
	static class UDBDOutlineComponentStencilConfiguration* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDOutlineComponentStencilConfiguration>();
	}
};
static_assert(alignof(UDBDOutlineComponentStencilConfiguration) == 0x000008, "Wrong alignment on UDBDOutlineComponentStencilConfiguration");
static_assert(sizeof(UDBDOutlineComponentStencilConfiguration) == 0x000138, "Wrong size on UDBDOutlineComponentStencilConfiguration");

// Class DeadByDaylight.DBDParadiseGameMode
// 0x0000 (0x0400 - 0x0400)
class ADBDParadiseGameMode final : public ADBDBaseGameMode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDParadiseGameMode">();
	}
	static class ADBDParadiseGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDParadiseGameMode>();
	}
};
static_assert(alignof(ADBDParadiseGameMode) == 0x000008, "Wrong alignment on ADBDParadiseGameMode");
static_assert(sizeof(ADBDParadiseGameMode) == 0x000400, "Wrong size on ADBDParadiseGameMode");

// Class DeadByDaylight.DBDPersistentData
// 0x0DB0 (0x0DE0 - 0x0030)
class UDBDPersistentData final : public UObject
{
public:
	struct FGamePersistentData                    _gamePersistentData;                               // 0x0030(0x0108)(Transient, NativeAccessSpecifierPrivate)
	TArray<class FString>                         _keepDataIDs;                                      // 0x0138(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TMap<class FString, struct FPlayerPersistentData> _playerIdToPersistentDataMap;                      // 0x0148(0x0050)(Transient, NativeAccessSpecifierPrivate)
	struct FPlayerPersistentData                  _localPlayerPersistentData;                        // 0x0198(0x0BC8)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D60[0x50];                                     // 0x0D60(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCloudInventoryItem>            _cloudInventory;                                   // 0x0DB0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_DC0[0x20];                                     // 0x0DC0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDPersistentData">();
	}
	static class UDBDPersistentData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDPersistentData>();
	}
};
static_assert(alignof(UDBDPersistentData) == 0x000008, "Wrong alignment on UDBDPersistentData");
static_assert(sizeof(UDBDPersistentData) == 0x000DE0, "Wrong size on UDBDPersistentData");
static_assert(offsetof(UDBDPersistentData, _gamePersistentData) == 0x000030, "Member 'UDBDPersistentData::_gamePersistentData' has a wrong offset!");
static_assert(offsetof(UDBDPersistentData, _keepDataIDs) == 0x000138, "Member 'UDBDPersistentData::_keepDataIDs' has a wrong offset!");
static_assert(offsetof(UDBDPersistentData, _playerIdToPersistentDataMap) == 0x000148, "Member 'UDBDPersistentData::_playerIdToPersistentDataMap' has a wrong offset!");
static_assert(offsetof(UDBDPersistentData, _localPlayerPersistentData) == 0x000198, "Member 'UDBDPersistentData::_localPlayerPersistentData' has a wrong offset!");
static_assert(offsetof(UDBDPersistentData, _cloudInventory) == 0x000DB0, "Member 'UDBDPersistentData::_cloudInventory' has a wrong offset!");

// Class DeadByDaylight.DBDPlayerLevelManager
// 0x0168 (0x0198 - 0x0030)
class UDBDPlayerLevelManager final : public UObject
{
public:
	uint8                                         Pad_30[0x168];                                     // 0x0030(0x0168)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDPlayerLevelManager">();
	}
	static class UDBDPlayerLevelManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDPlayerLevelManager>();
	}
};
static_assert(alignof(UDBDPlayerLevelManager) == 0x000008, "Wrong alignment on UDBDPlayerLevelManager");
static_assert(sizeof(UDBDPlayerLevelManager) == 0x000198, "Wrong size on UDBDPlayerLevelManager");

// Class DeadByDaylight.DBDProjectileUtilities
// 0x0000 (0x0030 - 0x0030)
class UDBDProjectileUtilities final : public UBlueprintFunctionLibrary
{
public:
	static class UAuthoritativePoolProjectileProviderAdapter* CreateProjectilePoolAdapter(class UObject* Param_Outer, class UAuthoritativeActorPoolComponent* Pool);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDProjectileUtilities">();
	}
	static class UDBDProjectileUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDProjectileUtilities>();
	}
};
static_assert(alignof(UDBDProjectileUtilities) == 0x000008, "Wrong alignment on UDBDProjectileUtilities");
static_assert(sizeof(UDBDProjectileUtilities) == 0x000030, "Wrong size on UDBDProjectileUtilities");

// Class DeadByDaylight.DBDHostSettingsParamsJoinabilityPreset
// 0x0008 (0x0048 - 0x0040)
class UDBDHostSettingsParamsJoinabilityPreset final : public UDBDHostSettingsParamsBase
{
public:
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDHostSettingsParamsJoinabilityPreset">();
	}
	static class UDBDHostSettingsParamsJoinabilityPreset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDHostSettingsParamsJoinabilityPreset>();
	}
};
static_assert(alignof(UDBDHostSettingsParamsJoinabilityPreset) == 0x000008, "Wrong alignment on UDBDHostSettingsParamsJoinabilityPreset");
static_assert(sizeof(UDBDHostSettingsParamsJoinabilityPreset) == 0x000048, "Wrong size on UDBDHostSettingsParamsJoinabilityPreset");

// Class DeadByDaylight.DBDServerInstance
// 0x0080 (0x00B0 - 0x0030)
class UDBDServerInstance final : public UObject
{
public:
	uint8                                         Pad_30[0x68];                                      // 0x0030(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UDBDHostSettingsParamsBase*>     _pendingSessionUpdates;                            // 0x0098(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class UDBDGameInstance>        _gameInstance;                                     // 0x00A8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDServerInstance">();
	}
	static class UDBDServerInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDServerInstance>();
	}
};
static_assert(alignof(UDBDServerInstance) == 0x000008, "Wrong alignment on UDBDServerInstance");
static_assert(sizeof(UDBDServerInstance) == 0x0000B0, "Wrong size on UDBDServerInstance");
static_assert(offsetof(UDBDServerInstance, _pendingSessionUpdates) == 0x000098, "Member 'UDBDServerInstance::_pendingSessionUpdates' has a wrong offset!");
static_assert(offsetof(UDBDServerInstance, _gameInstance) == 0x0000A8, "Member 'UDBDServerInstance::_gameInstance' has a wrong offset!");

// Class DeadByDaylight.DBDSocialNotificationFactory
// 0x0040 (0x0070 - 0x0030)
class UDBDSocialNotificationFactory final : public UObject
{
public:
	TWeakObjectPtr<class UDBDGameInstance>        _gameInstance;                                     // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UToastManager*                          _toastMgr;                                         // 0x0038(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDBDPartyFacade*                        _partyFacade;                                      // 0x0040(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFriendManager*                         _friendManager;                                    // 0x0048(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             _toastTable;                                       // 0x0050(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_58[0x18];                                      // 0x0058(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDSocialNotificationFactory">();
	}
	static class UDBDSocialNotificationFactory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDSocialNotificationFactory>();
	}
};
static_assert(alignof(UDBDSocialNotificationFactory) == 0x000008, "Wrong alignment on UDBDSocialNotificationFactory");
static_assert(sizeof(UDBDSocialNotificationFactory) == 0x000070, "Wrong size on UDBDSocialNotificationFactory");
static_assert(offsetof(UDBDSocialNotificationFactory, _gameInstance) == 0x000030, "Member 'UDBDSocialNotificationFactory::_gameInstance' has a wrong offset!");
static_assert(offsetof(UDBDSocialNotificationFactory, _toastMgr) == 0x000038, "Member 'UDBDSocialNotificationFactory::_toastMgr' has a wrong offset!");
static_assert(offsetof(UDBDSocialNotificationFactory, _partyFacade) == 0x000040, "Member 'UDBDSocialNotificationFactory::_partyFacade' has a wrong offset!");
static_assert(offsetof(UDBDSocialNotificationFactory, _friendManager) == 0x000048, "Member 'UDBDSocialNotificationFactory::_friendManager' has a wrong offset!");
static_assert(offsetof(UDBDSocialNotificationFactory, _toastTable) == 0x000050, "Member 'UDBDSocialNotificationFactory::_toastTable' has a wrong offset!");

// Class DeadByDaylight.DBDSpectator
// 0x0020 (0x0370 - 0x0350)
class ADBDSpectator final : public ASpectatorPawn
{
public:
	uint8                                         Pad_350[0x20];                                     // 0x0350(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDSpectator">();
	}
	static class ADBDSpectator* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDSpectator>();
	}
};
static_assert(alignof(ADBDSpectator) == 0x000008, "Wrong alignment on ADBDSpectator");
static_assert(sizeof(ADBDSpectator) == 0x000370, "Wrong size on ADBDSpectator");

// Class DeadByDaylight.DBDSpringArmComponent
// 0x0090 (0x0450 - 0x03C0)
class UDBDSpringArmComponent final : public USpringArmComponent
{
public:
	uint8                                         bEnableComponentwiseCameraLag : 1;                 // 0x03C0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_3C1[0x7];                                      // 0x03C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ComponenwiseCameraLagSpeed;                        // 0x03C8(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetArmMinLength;                                // 0x03E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bEnableDistanceCameraLag : 1;                      // 0x03E4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_3E5[0x3];                                      // 0x03E5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CameraDistanceLagSpeed;                            // 0x03E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3EC[0x4];                                      // 0x03EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bDrawDebugTraceMarkers : 1;                        // 0x03F0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_3F1[0x7];                                      // 0x03F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class AActor>>          IgnoreActors;                                      // 0x03F8(0x0010)(ZeroConstructor, Transient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_408[0x48];                                     // 0x0408(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearIgnoreActors();
	void IgnoreActor(class AActor* Actor, bool bShouldIgnore);
	void ZoomCamera(float ZoomCount, float ZoomDuration);
	void ZoomCameraToDefault(float ZoomDuration);
	void ZoomCameraTowardsNewTargetArmLength(float NewTargetArmLength, float ZoomDuration);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDSpringArmComponent">();
	}
	static class UDBDSpringArmComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDSpringArmComponent>();
	}
};
static_assert(alignof(UDBDSpringArmComponent) == 0x000010, "Wrong alignment on UDBDSpringArmComponent");
static_assert(sizeof(UDBDSpringArmComponent) == 0x000450, "Wrong size on UDBDSpringArmComponent");
static_assert(offsetof(UDBDSpringArmComponent, ComponenwiseCameraLagSpeed) == 0x0003C8, "Member 'UDBDSpringArmComponent::ComponenwiseCameraLagSpeed' has a wrong offset!");
static_assert(offsetof(UDBDSpringArmComponent, TargetArmMinLength) == 0x0003E0, "Member 'UDBDSpringArmComponent::TargetArmMinLength' has a wrong offset!");
static_assert(offsetof(UDBDSpringArmComponent, CameraDistanceLagSpeed) == 0x0003E8, "Member 'UDBDSpringArmComponent::CameraDistanceLagSpeed' has a wrong offset!");
static_assert(offsetof(UDBDSpringArmComponent, IgnoreActors) == 0x0003F8, "Member 'UDBDSpringArmComponent::IgnoreActors' has a wrong offset!");

// Class DeadByDaylight.DBDTags
// 0x0000 (0x0030 - 0x0030)
class UDBDTags final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDTags">();
	}
	static class UDBDTags* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDTags>();
	}
};
static_assert(alignof(UDBDTags) == 0x000008, "Wrong alignment on UDBDTags");
static_assert(sizeof(UDBDTags) == 0x000030, "Wrong size on UDBDTags");

// Class DeadByDaylight.DBDTimerComponent
// 0x0030 (0x00D8 - 0x00A8)
class UDBDTimerComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x30];                                      // 0x00A8(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Pause();
	void Reset();
	void ResetTo(float Time);
	void Stop();
	void Unpause();
	void Update(float DeltaTime);

	float GetPercentTimeElapsed() const;
	float GetPercentTimeLeft() const;
	float GetStartTime() const;
	float GetTimeElapsed() const;
	float GetTimeLeft() const;
	bool IsDone() const;
	bool IsOnPause() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDTimerComponent">();
	}
	static class UDBDTimerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDTimerComponent>();
	}
};
static_assert(alignof(UDBDTimerComponent) == 0x000008, "Wrong alignment on UDBDTimerComponent");
static_assert(sizeof(UDBDTimerComponent) == 0x0000D8, "Wrong size on UDBDTimerComponent");

// Class DeadByDaylight.DBDUtilities
// 0x0000 (0x0030 - 0x0030)
class UDBDUtilities final : public UBlueprintFunctionLibrary
{
public:
	static class UActorComponent* AddComponentToActor(class UClass* CompClass, class FName CompName, class AActor* Actor);
	static bool BoxTraceAgainstActor(const struct FVector& Start, const struct FVector& End, const class UBoxComponent* Box, const class AActor* Actor, struct FHitResult* OutHitResult);
	static void CrashGameCausingInterrupt();
	static bool DBDCapsuleTraceSingle(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, float HalfHeight, ECollisionChannel TraceChannel, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, EDrawDebugTrace DrawDebugType, struct FHitResult* OutHit, bool bIgnoreSelf);
	static float DistanceFromPointToPane(const struct FVector& Point, const struct FPlane& Plane);
	static bool FindFloorSingle(const class UObject* WorldContextObject, const struct FVector& Location, float RaycastLength, struct FHitResult* OutHit);
	static class AActor* FindParentOfClass(class AActor* InChild, class UClass* InClass);
	static EShadowSystem GetActiveShadowSystem();
	static class FString GetActorOwnerName(class AActor* Actor);
	static void GetActorSpawners(TArray<class UActorSpawner*>* ActorSpawners);
	static float GetAnimSequenceLength(const class UAnimSequence* Sequence);
	static class AProceduralLevelBuilder* GetBuilder(const class UObject* WorldContextObject);
	static TArray<class AGenerator*> GetClosestGenerators(const TArray<class AGenerator*>& UnrevealedGenerators, const int32 ClosestGeneratorsCount);
	static struct FVector GetClosestPointOnOrbit(const struct FVector& CenterPoint, const struct FVector& OrbitterPosition, const float Distance);
	static struct FTransform GetClosestSnapTransformOnOrbit(const struct FVector& CenterPoint, const struct FVector& OrbitterPosition, const float Distance);
	static class AGenerator* GetClosestUnrepairedGenerator(const class AActor* Actor);
	static class FString GetComponentOwnerName(class UActorComponent* ActorComponent);
	static class ADBDAIPlayerController* GetDBDAIPlayerController(class ADBDPlayer* Player);
	static class UDBDGameInstance* GetDBDGameInstance(const class UObject* WorldContextObject);
	static class ADBDGameMode* GetDBDGameMode(const class UObject* WorldContextObject);
	static class ADBDGameState* GetDBDGameState(const class UObject* WorldContextObject);
	static float GetDistanceToNearestHookedSurvivor(const class ADBDPlayer* Player);
	static float GetEndGameTunableValue(const class UObject* WorldContextObject, class FName ValueName);
	static class AActor* GetFirstActorWithTag(class FName Tag, const TArray<class AActor*>& ActorsArray);
	static struct FVector GetFloorLocationAt(class UObject* WorldContextObject, const struct FVector& Location, float RaycastStartHeight, float RaycastEndHeight, bool UseComplex);
	static class FString GetFormattedNumberString(float Value, int32 MaxDecimals, int32 MinDecimals, bool LeadingZero);
	static class FText GetFormattedNumberText(float Value, int32 MaxDecimals, int32 MinDecimals, bool LeadingZero);
	static ECollisionChannel GetImpactCollisionObjectType(const class UPrimitiveComponent* Primitive);
	static struct FCollisionResponseContainer GetImpactCollisionResponseContainer(const class UPrimitiveComponent* Primitive);
	static int32 GetInventoryCount(const class UObject* WorldContextObject, int32 CharacterIndex, class FName ItemId);
	static int32 GetInventoryCountForMultipleCharacters(const class UObject* WorldContextObject, const TArray<int32>& CharacterIndexes, class FName ItemId);
	static class ADBDPlayerCameraManager* GetLocalDBDCameraManager(class UObject* WorldContextObject);
	static class ADBDPlayerControllerBase* GetLocalDBDPlayerController(const class UObject* WorldContextObject);
	static class ADBDPlayer* GetLocallyControlledCharacter(const class UObject* WorldContextObject);
	static EPlayerRole GetLocallyControlledCharacterRole(const class UObject* WorldContextObject);
	static class ASlasherPlayer* GetLocallyControlledKiller(const class UObject* WorldContextObject);
	static class ACamperPlayer* GetLocallyControlledSurvivor(const class UObject* WorldContextObject);
	static class ADBDPlayer* GetLocallyObservedCharacter(const class UObject* WorldContextObject);
	static EPlayerRole GetLocallyObservedCharacterRole(const class UObject* WorldContextObject);
	static class FString GetLogStringMaterialInfo(const class FString& InStr, const class UMaterialInterface* Root);
	static TArray<class UMaterialHelper*> GetMaterialHelpersAttachedToPlayerMesh(const class ADBDPlayer* Player);
	static float GetMontageLength(class UAnimMontage* Montage);
	static bool GetNearbyActorsOfType(class UWorld* World, const struct FVector& Center, float Radius, TArray<class AActor*>* OutNearbyActors, class UClass* ActorClassType, ECollisionChannel CollisionChannel, class AActor* IgnoreActor);
	static void GetNearbyCampers(class UWorld* World, const struct FVector& Center, float Radius, TArray<class ACamperPlayer*>* OutNearbyCampers, const TArray<class AActor*>& IgnoredCampers);
	static int32 GetNextPowerOf2(float Value);
	static class AActor* GetOuterMostActor(const class UAnimInstance* AnimInstance);
	static class ACamperPlayer* GetOwningCamper(const class UAnimInstance* AnimInstance);
	static class ADBDBasePlayer* GetOwningDBDBasePlayer(const class UAnimInstance* AnimInstance);
	static class ASlasherPlayer* GetOwningSlasher(const class UAnimInstance* AnimInstance);
	static float GetPercentOfRange(const float Val, const float Min, const float Max);
	static float GetPlayRateForMontage(class UAnimMontage* Montage, float Time);
	static struct FVector GetSimilarVector(const struct FVector& Vector, float MaximumDeviation);
	static float GetSlasherTunableValue(const class UObject* WorldContextObject, class FName ValueName);
	static float GetSquaredDistanceToKiller(const class AActor* Actor);
	static void GetTileSpawnPoints(TArray<class UTileSpawnPoint*>* TileSpawnPoints);
	static struct FTimespan GetTotalPlaytime(const class UObject* WorldContextObject, bool Update);
	static float GetVelocityXYAngleDegrees(const class AActor* Actor);
	static struct FVector GetXYVector(const struct FVector& Vector);
	static struct FRotator GetYawOnly(const struct FRotator& Rotation);
	static bool HasFloorForward(class UObject* WorldContextObject, const struct FVector& Location, const struct FVector& FowardVector, float Distance, float RaycastStartHeight, float RaycastEndHeight, TArray<struct FHitResult>* OutHits, struct FVector* RaycastStart);
	static bool HasLineOfSightToTarget(class UObject* WorldContextObject, const struct FVector& StartPosition, const struct FVector& TargetPosition, const class AActor* IgnoredActor, const bool UseComplex, const bool UseDebugLogs);
	static bool HasWalkableSurfaceForward(class UObject* WorldContextObject, const struct FVector& Location, const struct FVector& FowardVector, float Distance, float RaycastStartHeight, float RaycastEndHeight, TArray<struct FHitResult>* OutHits, struct FVector* RaycastStart);
	static bool IsClassChildOfOtherClasses(const class UClass* ClassToCheck, const TArray<class UClass*>& OtherClasses);
	static bool IsInKillerTeam(const class UObject* WorldContextObject);
	static bool IsInSurvivorTeam(const class UObject* WorldContextObject);
	static bool IsInTutorialLevel(const class UObject* WorldContextObject);
	static bool IsLocallyObservingAKiller(const class UObject* WorldContextObject);
	static bool IsLocallyObservingASurvivor(const class UObject* WorldContextObject);
	static bool IsNonViolent();
	static bool IsReplaceDisconnectedPlayersWithBotsActive();
	static bool IsServer(const class UObject* WorldContextObject);
	static bool IsSteamPIEGame(const class UObject* ContextObject);
	static void LogMeshMaterialInfo(const class FString& InStr, const class UMeshComponent* Root);
	static void LogString(const class FString& InStr);
	static bool NormalizeXY(struct FVector* Vector, float Tolerance);
	static int64 PointerToInt(class UObject* Obj);
	static void PrintStringEmbiggened(const class UObject* WorldContextObject, const class FString& InString, const struct FLinearColor& TextColor, float Duration, int32 Key, float Scale);
	static int32 ResolveCharacterIdFromPlayerState(const class ADBDPlayerState* PlayerState);
	static float Saturate(float Value);
	static void SetComponentCastHiddenShadow(class UPrimitiveComponent* Component, bool CastShadow);
	static bool SphereTraceAgainstActor(const struct FVector& Start, const struct FVector& End, const class USphereComponent* Sphere, const class AActor* Actor, struct FHitResult* OutHitResult);
	static bool SphereTraceSingle(const struct FVector& Start, const struct FVector& End, const class USphereComponent* Sphere, struct FHitResult* OutHitResult, const TArray<class AActor*>& IgnoredActors);
	static float ToAngle_negative180to180(float Angle);
	static bool WithinRange(float Min, float Max, float Value);
	static bool WithinRangeExclusive(float Min, float Max, float Value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDUtilities">();
	}
	static class UDBDUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDUtilities>();
	}
};
static_assert(alignof(UDBDUtilities) == 0x000008, "Wrong alignment on UDBDUtilities");
static_assert(sizeof(UDBDUtilities) == 0x000030, "Wrong size on UDBDUtilities");

// Class DeadByDaylight.DBD_CrossDissolver
// 0x0030 (0x00D8 - 0x00A8)
class UDBD_CrossDissolver : public UActorComponent
{
public:
	TArray<class UMaterialInterface*>             NewMaterials;                                      // 0x00A8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class USkeletalMeshComponent*>         BaseSkeletalMesh;                                  // 0x00B8(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class USkeletalMeshComponent*>         ClonedSkeletalMeshes;                              // 0x00C8(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	void KillClone();
	void MakeClone();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBD_CrossDissolver">();
	}
	static class UDBD_CrossDissolver* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBD_CrossDissolver>();
	}
};
static_assert(alignof(UDBD_CrossDissolver) == 0x000008, "Wrong alignment on UDBD_CrossDissolver");
static_assert(sizeof(UDBD_CrossDissolver) == 0x0000D8, "Wrong size on UDBD_CrossDissolver");
static_assert(offsetof(UDBD_CrossDissolver, NewMaterials) == 0x0000A8, "Member 'UDBD_CrossDissolver::NewMaterials' has a wrong offset!");
static_assert(offsetof(UDBD_CrossDissolver, BaseSkeletalMesh) == 0x0000B8, "Member 'UDBD_CrossDissolver::BaseSkeletalMesh' has a wrong offset!");
static_assert(offsetof(UDBD_CrossDissolver, ClonedSkeletalMeshes) == 0x0000C8, "Member 'UDBD_CrossDissolver::ClonedSkeletalMeshes' has a wrong offset!");

// Class DeadByDaylight.DecalCollection
// 0x0120 (0x0150 - 0x0030)
class UDecalCollection final : public UObject
{
public:
	TArray<class UDBDDecalComponent*>             _decalComponentsArray;                             // 0x0030(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TSet<class UDBDDecalComponent*>               _activeDecalComponents;                            // 0x0040(0x0050)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TSet<class UDBDDecalComponent*>               _inactiveDecalComponents;                          // 0x0090(0x0050)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<bool>                                  _DeltaZPool;                                       // 0x00E0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TMap<class UStaticMeshComponent*, int32>      _deltaZMultipliers;                                // 0x00F0(0x0050)(Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_140[0x8];                                      // 0x0140(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UDecalMaskedMaterialsList*              _decalProperties;                                  // 0x0148(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DecalCollection">();
	}
	static class UDecalCollection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDecalCollection>();
	}
};
static_assert(alignof(UDecalCollection) == 0x000008, "Wrong alignment on UDecalCollection");
static_assert(sizeof(UDecalCollection) == 0x000150, "Wrong size on UDecalCollection");
static_assert(offsetof(UDecalCollection, _decalComponentsArray) == 0x000030, "Member 'UDecalCollection::_decalComponentsArray' has a wrong offset!");
static_assert(offsetof(UDecalCollection, _activeDecalComponents) == 0x000040, "Member 'UDecalCollection::_activeDecalComponents' has a wrong offset!");
static_assert(offsetof(UDecalCollection, _inactiveDecalComponents) == 0x000090, "Member 'UDecalCollection::_inactiveDecalComponents' has a wrong offset!");
static_assert(offsetof(UDecalCollection, _DeltaZPool) == 0x0000E0, "Member 'UDecalCollection::_DeltaZPool' has a wrong offset!");
static_assert(offsetof(UDecalCollection, _deltaZMultipliers) == 0x0000F0, "Member 'UDecalCollection::_deltaZMultipliers' has a wrong offset!");
static_assert(offsetof(UDecalCollection, _decalProperties) == 0x000148, "Member 'UDecalCollection::_decalProperties' has a wrong offset!");

// Class DeadByDaylight.DecalSpawnerCollection
// 0x0050 (0x0080 - 0x0030)
class UDecalSpawnerCollection final : public UObject
{
public:
	TMap<class FName, class UDecalSpawner*>       _decalSpawners;                                    // 0x0030(0x0050)(Transient, NativeAccessSpecifierPrivate)

public:
	class UDecalSpawner* CreateDecalSpawner(const class UObject* WorldContextObject, class FName DecalSpawnerName, class UMaterialInterface* DecalMaterial, int32 PoolSize, ESpawnerStrategyType SpawnerStrateryType);
	void ReleaseDecalSpawner(class FName DecalSpawnerName);
	class UDBDDecalComponent* SpawnDecalAtLocation(class FName DecalSpawnerName, const struct FVector& DecalSize, const struct FVector& Location, const struct FRotator& Rotation, float LifeSpan, class FName DecalType, const int32 SortOrder);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DecalSpawnerCollection">();
	}
	static class UDecalSpawnerCollection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDecalSpawnerCollection>();
	}
};
static_assert(alignof(UDecalSpawnerCollection) == 0x000008, "Wrong alignment on UDecalSpawnerCollection");
static_assert(sizeof(UDecalSpawnerCollection) == 0x000080, "Wrong size on UDecalSpawnerCollection");
static_assert(offsetof(UDecalSpawnerCollection, _decalSpawners) == 0x000030, "Member 'UDecalSpawnerCollection::_decalSpawners' has a wrong offset!");

// Class DeadByDaylight.DedicatedServerManager
// 0x0048 (0x0080 - 0x0038)
class UDedicatedServerManager final : public UGameInstanceSubsystem
{
public:
	TScriptInterface<class IDedicatedServerStartupInitializerInterface> _startupInitializer;                               // 0x0038(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOnlineSystemHandler*                   _onlineSystemHandler;                              // 0x0048(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_50[0x30];                                      // 0x0050(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DedicatedServerManager">();
	}
	static class UDedicatedServerManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDedicatedServerManager>();
	}
};
static_assert(alignof(UDedicatedServerManager) == 0x000008, "Wrong alignment on UDedicatedServerManager");
static_assert(sizeof(UDedicatedServerManager) == 0x000080, "Wrong size on UDedicatedServerManager");
static_assert(offsetof(UDedicatedServerManager, _startupInitializer) == 0x000038, "Member 'UDedicatedServerManager::_startupInitializer' has a wrong offset!");
static_assert(offsetof(UDedicatedServerManager, _onlineSystemHandler) == 0x000048, "Member 'UDedicatedServerManager::_onlineSystemHandler' has a wrong offset!");

// Class DeadByDaylight.DemogorgonAnimProxy
// 0x0000 (0x0030 - 0x0030)
class IDemogorgonAnimProxy final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DemogorgonAnimProxy">();
	}
	static class IDemogorgonAnimProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<IDemogorgonAnimProxy>();
	}
};
static_assert(alignof(IDemogorgonAnimProxy) == 0x000008, "Wrong alignment on IDemogorgonAnimProxy");
static_assert(sizeof(IDemogorgonAnimProxy) == 0x000030, "Wrong size on IDemogorgonAnimProxy");

// Class DeadByDaylight.DesignTunablesSearchableItemStrategy
// 0x0010 (0x0048 - 0x0038)
class UDesignTunablesSearchableItemStrategy final : public USearchableItemStrategy
{
public:
	EItemRarity                                   ItemRarity;                                        // 0x0038(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   _itemIdToSpawn;                                    // 0x003C(0x000C)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DesignTunablesSearchableItemStrategy">();
	}
	static class UDesignTunablesSearchableItemStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDesignTunablesSearchableItemStrategy>();
	}
};
static_assert(alignof(UDesignTunablesSearchableItemStrategy) == 0x000008, "Wrong alignment on UDesignTunablesSearchableItemStrategy");
static_assert(sizeof(UDesignTunablesSearchableItemStrategy) == 0x000048, "Wrong size on UDesignTunablesSearchableItemStrategy");
static_assert(offsetof(UDesignTunablesSearchableItemStrategy, ItemRarity) == 0x000038, "Member 'UDesignTunablesSearchableItemStrategy::ItemRarity' has a wrong offset!");
static_assert(offsetof(UDesignTunablesSearchableItemStrategy, _itemIdToSpawn) == 0x00003C, "Member 'UDesignTunablesSearchableItemStrategy::_itemIdToSpawn' has a wrong offset!");

// Class DeadByDaylight.DestroyBreakableDefinition
// 0x0060 (0x07E0 - 0x0780)
class UDestroyBreakableDefinition : public UInteractionDefinition
{
public:
	float                                         _interactionTimePercentForDestroyEvent;            // 0x0778(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_77C[0x2C];                                     // 0x077C(0x002C)(Fixing Size After Last Property [ Dumper-7 ])
	class ABreakableBase*                         _breakable;                                        // 0x07A8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _fastInteractionAnimThreshold;                     // 0x07B0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7D8[0x8];                                      // 0x07D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class ABreakableBase* GetBreakable() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DestroyBreakableDefinition">();
	}
	static class UDestroyBreakableDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDestroyBreakableDefinition>();
	}
};
static_assert(alignof(UDestroyBreakableDefinition) == 0x000010, "Wrong alignment on UDestroyBreakableDefinition");
static_assert(sizeof(UDestroyBreakableDefinition) == 0x0007E0, "Wrong size on UDestroyBreakableDefinition");
static_assert(offsetof(UDestroyBreakableDefinition, _interactionTimePercentForDestroyEvent) == 0x000778, "Member 'UDestroyBreakableDefinition::_interactionTimePercentForDestroyEvent' has a wrong offset!");
static_assert(offsetof(UDestroyBreakableDefinition, _breakable) == 0x0007A8, "Member 'UDestroyBreakableDefinition::_breakable' has a wrong offset!");
static_assert(offsetof(UDestroyBreakableDefinition, _fastInteractionAnimThreshold) == 0x0007B0, "Member 'UDestroyBreakableDefinition::_fastInteractionAnimThreshold' has a wrong offset!");

// Class DeadByDaylight.DirectionalMinigameSurvivorComponent
// 0x0068 (0x0110 - 0x00A8)
class UDirectionalMinigameSurvivorComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x68];                                      // 0x00A8(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Client_StopInteraction(class UDirectionalMinigameComponent* DirectionalMinigame, EDirectionalMinigameResult Result);
	void Server_CancelMinigame(class UDirectionalMinigameComponent* DirectionalMinigame);
	void Server_EnterKey(class UDirectionalMinigameComponent* DirectionalMinigame, EDirectionalInputKey Key);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DirectionalMinigameSurvivorComponent">();
	}
	static class UDirectionalMinigameSurvivorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDirectionalMinigameSurvivorComponent>();
	}
};
static_assert(alignof(UDirectionalMinigameSurvivorComponent) == 0x000008, "Wrong alignment on UDirectionalMinigameSurvivorComponent");
static_assert(sizeof(UDirectionalMinigameSurvivorComponent) == 0x000110, "Wrong size on UDirectionalMinigameSurvivorComponent");

// Class DeadByDaylight.DistanceCheckPawnLocationOverride
// 0x0000 (0x0030 - 0x0030)
class IDistanceCheckPawnLocationOverride final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DistanceCheckPawnLocationOverride">();
	}
	static class IDistanceCheckPawnLocationOverride* GetDefaultObj()
	{
		return GetDefaultObjImpl<IDistanceCheckPawnLocationOverride>();
	}
};
static_assert(alignof(IDistanceCheckPawnLocationOverride) == 0x000008, "Wrong alignment on IDistanceCheckPawnLocationOverride");
static_assert(sizeof(IDistanceCheckPawnLocationOverride) == 0x000030, "Wrong size on IDistanceCheckPawnLocationOverride");

// Class DeadByDaylight.DlcHelper
// 0x0000 (0x0030 - 0x0030)
class UDlcHelper final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DlcHelper">();
	}
	static class UDlcHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDlcHelper>();
	}
};
static_assert(alignof(UDlcHelper) == 0x000008, "Wrong alignment on UDlcHelper");
static_assert(sizeof(UDlcHelper) == 0x000030, "Wrong size on UDlcHelper");

// Class DeadByDaylight.DreamSnareTrapPlacementValidationStrategy
// 0x0010 (0x0108 - 0x00F8)
class UDreamSnareTrapPlacementValidationStrategy final : public UDefaultObjectPlacementValidationStrategy
{
public:
	float                                         _numberOfGroundTest;                               // 0x00F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _trapRadius;                                       // 0x00FC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _maxElevationDifferentialOnTrapEdge;               // 0x0100(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_104[0x4];                                      // 0x0104(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DreamSnareTrapPlacementValidationStrategy">();
	}
	static class UDreamSnareTrapPlacementValidationStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDreamSnareTrapPlacementValidationStrategy>();
	}
};
static_assert(alignof(UDreamSnareTrapPlacementValidationStrategy) == 0x000008, "Wrong alignment on UDreamSnareTrapPlacementValidationStrategy");
static_assert(sizeof(UDreamSnareTrapPlacementValidationStrategy) == 0x000108, "Wrong size on UDreamSnareTrapPlacementValidationStrategy");
static_assert(offsetof(UDreamSnareTrapPlacementValidationStrategy, _numberOfGroundTest) == 0x0000F8, "Member 'UDreamSnareTrapPlacementValidationStrategy::_numberOfGroundTest' has a wrong offset!");
static_assert(offsetof(UDreamSnareTrapPlacementValidationStrategy, _trapRadius) == 0x0000FC, "Member 'UDreamSnareTrapPlacementValidationStrategy::_trapRadius' has a wrong offset!");
static_assert(offsetof(UDreamSnareTrapPlacementValidationStrategy, _maxElevationDifferentialOnTrapEdge) == 0x000100, "Member 'UDreamSnareTrapPlacementValidationStrategy::_maxElevationDifferentialOnTrapEdge' has a wrong offset!");

// Class DeadByDaylight.DreamworldOnlyComponent
// 0x0010 (0x02D0 - 0x02C0)
class UDreamworldOnlyComponent final : public USceneComponent
{
public:
	uint8                                         Pad_2C0[0x10];                                     // 0x02C0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DreamworldOnlyComponent">();
	}
	static class UDreamworldOnlyComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDreamworldOnlyComponent>();
	}
};
static_assert(alignof(UDreamworldOnlyComponent) == 0x000010, "Wrong alignment on UDreamworldOnlyComponent");
static_assert(sizeof(UDreamworldOnlyComponent) == 0x0002D0, "Wrong size on UDreamworldOnlyComponent");

// Class DeadByDaylight.DSQuestEventsHandlerComponent
// 0x00A0 (0x0148 - 0x00A8)
class UDSQuestEventsHandlerComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x70];                                      // 0x00A8(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UQuestEventEvaluatorBase*>       _evaluatorList;                                    // 0x0118(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_128[0x20];                                     // 0x0128(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DSQuestEventsHandlerComponent">();
	}
	static class UDSQuestEventsHandlerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDSQuestEventsHandlerComponent>();
	}
};
static_assert(alignof(UDSQuestEventsHandlerComponent) == 0x000008, "Wrong alignment on UDSQuestEventsHandlerComponent");
static_assert(sizeof(UDSQuestEventsHandlerComponent) == 0x000148, "Wrong size on UDSQuestEventsHandlerComponent");
static_assert(offsetof(UDSQuestEventsHandlerComponent, _evaluatorList) == 0x000118, "Member 'UDSQuestEventsHandlerComponent::_evaluatorList' has a wrong offset!");

// Class DeadByDaylight.DynamicGrass
// 0x0018 (0x02B8 - 0x02A0)
class ADynamicGrass : public AActor
{
public:
	class UMaterialParameterCollection*           _worldSettings;                                    // 0x02A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A8[0x10];                                     // 0x02A8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicGrass">();
	}
	static class ADynamicGrass* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADynamicGrass>();
	}
};
static_assert(alignof(ADynamicGrass) == 0x000008, "Wrong alignment on ADynamicGrass");
static_assert(sizeof(ADynamicGrass) == 0x0002B8, "Wrong size on ADynamicGrass");
static_assert(offsetof(ADynamicGrass, _worldSettings) == 0x0002A0, "Member 'ADynamicGrass::_worldSettings' has a wrong offset!");

// Class DeadByDaylight.EdgeObjectHandlingStrategy
// 0x0128 (0x0158 - 0x0030)
class UEdgeObjectHandlingStrategy final : public UObject
{
public:
	TArray<class UActorSpawner*>                  _edgeObjectSpawners;                               // 0x0030(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UActorSpawner*>                  _edgeObjectBlockers;                               // 0x0040(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_50[0x108];                                     // 0x0050(0x0108)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EdgeObjectHandlingStrategy">();
	}
	static class UEdgeObjectHandlingStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEdgeObjectHandlingStrategy>();
	}
};
static_assert(alignof(UEdgeObjectHandlingStrategy) == 0x000008, "Wrong alignment on UEdgeObjectHandlingStrategy");
static_assert(sizeof(UEdgeObjectHandlingStrategy) == 0x000158, "Wrong size on UEdgeObjectHandlingStrategy");
static_assert(offsetof(UEdgeObjectHandlingStrategy, _edgeObjectSpawners) == 0x000030, "Member 'UEdgeObjectHandlingStrategy::_edgeObjectSpawners' has a wrong offset!");
static_assert(offsetof(UEdgeObjectHandlingStrategy, _edgeObjectBlockers) == 0x000040, "Member 'UEdgeObjectHandlingStrategy::_edgeObjectBlockers' has a wrong offset!");

// Class DeadByDaylight.EditorMeshVisualization
// 0x00A0 (0x0360 - 0x02C0)
class UEditorMeshVisualization final : public USceneComponent
{
public:
	TSoftObjectPtr<class USkeletalMesh>           MeshVisualization;                                 // 0x02C0(0x0038)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F8[0x8];                                      // 0x02F8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             RelativeTransform;                                 // 0x0300(0x0060)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EditorMeshVisualization">();
	}
	static class UEditorMeshVisualization* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEditorMeshVisualization>();
	}
};
static_assert(alignof(UEditorMeshVisualization) == 0x000010, "Wrong alignment on UEditorMeshVisualization");
static_assert(sizeof(UEditorMeshVisualization) == 0x000360, "Wrong size on UEditorMeshVisualization");
static_assert(offsetof(UEditorMeshVisualization, MeshVisualization) == 0x0002C0, "Member 'UEditorMeshVisualization::MeshVisualization' has a wrong offset!");
static_assert(offsetof(UEditorMeshVisualization, RelativeTransform) == 0x000300, "Member 'UEditorMeshVisualization::RelativeTransform' has a wrong offset!");

// Class DeadByDaylight.EmblemRankContainer
// 0x0228 (0x0260 - 0x0038)
class UEmblemRankContainer final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x228];                                     // 0x0038(0x0228)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EmblemRankContainer">();
	}
	static class UEmblemRankContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEmblemRankContainer>();
	}
};
static_assert(alignof(UEmblemRankContainer) == 0x000008, "Wrong alignment on UEmblemRankContainer");
static_assert(sizeof(UEmblemRankContainer) == 0x000260, "Wrong size on UEmblemRankContainer");

// Class DeadByDaylight.EndGameEntityAnimInstance
// 0x0010 (0x0360 - 0x0350)
class UEndGameEntityAnimInstance : public UAnimInstance
{
public:
	bool                                          _isFront;                                          // 0x0350(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isBack;                                           // 0x0351(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_352[0xE];                                      // 0x0352(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndGameEntityAnimInstance">();
	}
	static class UEndGameEntityAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndGameEntityAnimInstance>();
	}
};
static_assert(alignof(UEndGameEntityAnimInstance) == 0x000010, "Wrong alignment on UEndGameEntityAnimInstance");
static_assert(sizeof(UEndGameEntityAnimInstance) == 0x000360, "Wrong size on UEndGameEntityAnimInstance");
static_assert(offsetof(UEndGameEntityAnimInstance, _isFront) == 0x000350, "Member 'UEndGameEntityAnimInstance::_isFront' has a wrong offset!");
static_assert(offsetof(UEndGameEntityAnimInstance, _isBack) == 0x000351, "Member 'UEndGameEntityAnimInstance::_isBack' has a wrong offset!");

// Class DeadByDaylight.EndGameStateComponent
// 0x0068 (0x0110 - 0x00A8)
class UEndGameStateComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0xC];                                       // 0x00A8(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _isEndGameOver;                                    // 0x00B4(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B5[0x3];                                       // 0x00B5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _worldTimeAtLastModification;                      // 0x00B8(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_BC[0x44];                                      // 0x00BC(0x0044)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _timeDilation;                                     // 0x0100(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isTimerPaused;                                    // 0x0104(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_105[0x3];                                      // 0x0105(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _normalTotalTimeElapsedAtLastTimeModification;     // 0x0108(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EEndGameScenarioTrigger                       _endGameScenarioTrigger;                           // 0x010C(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_10D[0x3];                                      // 0x010D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Multicast_SetIsInEndGameSimulation(bool EndGameSimulation);
	void OnRep_IsEndGameOver();
	void OnRep_IsTimerPaused();
	void OnRep_TimeDilation();
	void OnRep_WorldTimeAtLastDilationModification();

	float GetElapsedTimePercent() const;
	bool HasEndGameBegun() const;
	bool IsEndGameOver() const;
	bool IsTimerSlowedDown() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndGameStateComponent">();
	}
	static class UEndGameStateComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndGameStateComponent>();
	}
};
static_assert(alignof(UEndGameStateComponent) == 0x000008, "Wrong alignment on UEndGameStateComponent");
static_assert(sizeof(UEndGameStateComponent) == 0x000110, "Wrong size on UEndGameStateComponent");
static_assert(offsetof(UEndGameStateComponent, _isEndGameOver) == 0x0000B4, "Member 'UEndGameStateComponent::_isEndGameOver' has a wrong offset!");
static_assert(offsetof(UEndGameStateComponent, _worldTimeAtLastModification) == 0x0000B8, "Member 'UEndGameStateComponent::_worldTimeAtLastModification' has a wrong offset!");
static_assert(offsetof(UEndGameStateComponent, _timeDilation) == 0x000100, "Member 'UEndGameStateComponent::_timeDilation' has a wrong offset!");
static_assert(offsetof(UEndGameStateComponent, _isTimerPaused) == 0x000104, "Member 'UEndGameStateComponent::_isTimerPaused' has a wrong offset!");
static_assert(offsetof(UEndGameStateComponent, _normalTotalTimeElapsedAtLastTimeModification) == 0x000108, "Member 'UEndGameStateComponent::_normalTotalTimeElapsedAtLastTimeModification' has a wrong offset!");
static_assert(offsetof(UEndGameStateComponent, _endGameScenarioTrigger) == 0x00010C, "Member 'UEndGameStateComponent::_endGameScenarioTrigger' has a wrong offset!");

// Class DeadByDaylight.EnduranceVFXComponent
// 0x0020 (0x00C8 - 0x00A8)
class UEnduranceVFXComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x20];                                      // 0x00A8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ShowHighlight(class UGameplayModifierContainer* PreventKOSource);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnduranceVFXComponent">();
	}
	static class UEnduranceVFXComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnduranceVFXComponent>();
	}
};
static_assert(alignof(UEnduranceVFXComponent) == 0x000008, "Wrong alignment on UEnduranceVFXComponent");
static_assert(sizeof(UEnduranceVFXComponent) == 0x0000C8, "Wrong size on UEnduranceVFXComponent");

// Class DeadByDaylight.EnsureLoggingSubsystem
// 0x0038 (0x0070 - 0x0038)
class UEnsureLoggingSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x38];                                      // 0x0038(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnsureLoggingSubsystem">();
	}
	static class UEnsureLoggingSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnsureLoggingSubsystem>();
	}
};
static_assert(alignof(UEnsureLoggingSubsystem) == 0x000008, "Wrong alignment on UEnsureLoggingSubsystem");
static_assert(sizeof(UEnsureLoggingSubsystem) == 0x000070, "Wrong size on UEnsureLoggingSubsystem");

// Class DeadByDaylight.Entity
// 0x0020 (0x02C0 - 0x02A0)
class AEntity : public AActor
{
public:
	class UCurveFloat*                            _dissolveCurve;                                    // 0x02A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _revealsCurve;                                     // 0x02A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialHelper*                        _materialHelper;                                   // 0x02B0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USkeletalMeshComponent*                 _skeletalMesh;                                     // 0x02B8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void ChangeToIdleState();
	void ChangeToSacrificeState();
	void ChangeToStruggleState();
	void CompleteSacrifice(bool IsBasementHook);
	void HideEntity();
	void InitEntity(class AMeatHook* MeatHook);
	void OnReactionStart();
	void SetAnimationIsStruggling(bool IsStruggling);
	void SetAnimationStrugglePercent(float Percent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Entity">();
	}
	static class AEntity* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEntity>();
	}
};
static_assert(alignof(AEntity) == 0x000008, "Wrong alignment on AEntity");
static_assert(sizeof(AEntity) == 0x0002C0, "Wrong size on AEntity");
static_assert(offsetof(AEntity, _dissolveCurve) == 0x0002A0, "Member 'AEntity::_dissolveCurve' has a wrong offset!");
static_assert(offsetof(AEntity, _revealsCurve) == 0x0002A8, "Member 'AEntity::_revealsCurve' has a wrong offset!");
static_assert(offsetof(AEntity, _materialHelper) == 0x0002B0, "Member 'AEntity::_materialHelper' has a wrong offset!");
static_assert(offsetof(AEntity, _skeletalMesh) == 0x0002B8, "Member 'AEntity::_skeletalMesh' has a wrong offset!");

// Class DeadByDaylight.EnvironmentAnimatedObject
// 0x0000 (0x0320 - 0x0320)
class AEnvironmentAnimatedObject final : public ASkeletalMeshActorBudgeted
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvironmentAnimatedObject">();
	}
	static class AEnvironmentAnimatedObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEnvironmentAnimatedObject>();
	}
};
static_assert(alignof(AEnvironmentAnimatedObject) == 0x000008, "Wrong alignment on AEnvironmentAnimatedObject");
static_assert(sizeof(AEnvironmentAnimatedObject) == 0x000320, "Wrong size on AEnvironmentAnimatedObject");

// Class DeadByDaylight.EpicProfileDAL
// 0x0000 (0x0088 - 0x0088)
class UEpicProfileDAL final : public UPlayerProfileDAL
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EpicProfileDAL">();
	}
	static class UEpicProfileDAL* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEpicProfileDAL>();
	}
};
static_assert(alignof(UEpicProfileDAL) == 0x000008, "Wrong alignment on UEpicProfileDAL");
static_assert(sizeof(UEpicProfileDAL) == 0x000088, "Wrong size on UEpicProfileDAL");

// Class DeadByDaylight.EscapeBlocker
// 0x0040 (0x02E0 - 0x02A0)
class AEscapeBlocker : public AActor
{
public:
	uint8                                         Pad_2A0[0x8];                                      // 0x02A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBoxComponent*                          _camperBlocker;                                    // 0x02A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBoxComponent*                          _playerDetectionZone;                              // 0x02B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B8[0x28];                                     // 0x02B8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActivatePlayerBlockerFX();
	void DeactivatePlayerBlockerFX();
	void OnPlayerDetectionZoneBeginOverlap(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnPlayerDetectionZoneEndOverlap(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void SetCamperBlocker(class UBoxComponent* CamperBlocker);
	void SetPlayerDetectionZone(class UBoxComponent* PlayerDetectionZone);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EscapeBlocker">();
	}
	static class AEscapeBlocker* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEscapeBlocker>();
	}
};
static_assert(alignof(AEscapeBlocker) == 0x000008, "Wrong alignment on AEscapeBlocker");
static_assert(sizeof(AEscapeBlocker) == 0x0002E0, "Wrong size on AEscapeBlocker");
static_assert(offsetof(AEscapeBlocker, _camperBlocker) == 0x0002A8, "Member 'AEscapeBlocker::_camperBlocker' has a wrong offset!");
static_assert(offsetof(AEscapeBlocker, _playerDetectionZone) == 0x0002B0, "Member 'AEscapeBlocker::_playerDetectionZone' has a wrong offset!");

// Class DeadByDaylight.EscapeDoor
// 0x00E8 (0x0490 - 0x03A8)
class AEscapeDoor : public AInteractable
{
public:
	uint8                                         Pad_3A8[0x8];                                      // 0x03A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        EscapePositions;                                   // 0x03B0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UObject*>                        EscapeFire;                                        // 0x03C0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class UChargeableComponent*                   _killerOpenChargeable;                             // 0x03D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UChargeableComponent*                   _openChargeable;                                   // 0x03D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkComponent*                           _ak_audio_escape;                                  // 0x03E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UEscapeDoorAnimInstance*                _escapeDoorAnimInstance;                           // 0x03E8(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        _rootComponent;                                    // 0x03F0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _activated;                                        // 0x03F8(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3F9[0x7];                                      // 0x03F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USpotLightComponent*                    _spotlight;                                        // 0x0400(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_408[0x48];                                     // 0x0408(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class ACamperPlayer>>   _localOverlappingSurvivors;                        // 0x0450(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_460[0x8];                                      // 0x0460(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAIPerceptionStimuliSourceComponent*    _perceptionStimuliComponent;                       // 0x0468(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBlockableComponent*                    _doorSwitchBlockableComponent;                     // 0x0470(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_478[0x18];                                     // 0x0478(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UChargeableInteractionDefinition* GetOpenEscapeInteraction();
	void LightAllLights();
	void OnBlockDoorSwitchCosmetic();
	void OnEscapeZoneBeginOverlap(class AActor* OverlappingActor);
	void OnEscapeZoneEndOverlap(class AActor* OverlappingActor);
	void OnExitActivationChanged(bool Activated);
	void OnExitGateOpened(class ADBDPlayer* Player);
	void OnExitOpenChanged(bool OPENED);
	void OnPlayerEnterExitArea(class ADBDPlayer* Player);
	void OnPlayerExitExitArea(class ADBDPlayer* Player);
	void OnRep_Activated(bool OldActivated);
	void OnUnblockDoorSwitchCosmetic();
	void SetIsActivated(bool IsActivated);

	class USkeletalMeshComponent* GetDoorSkeletalMeshComponent() const;
	struct FVector GetEscapeSwitchFloorLocation() const;
	class UBoxComponent* GetExitArea() const;
	bool GetIsOpen() const;
	float GetOpenTime() const;
	struct FVector GetParadiseServerLocation() const;
	class USceneComponent* GetSwitchSceneComponent() const;
	bool IsActivated() const;
	bool IsDoorSwitchBlocked() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EscapeDoor">();
	}
	static class AEscapeDoor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEscapeDoor>();
	}
};
static_assert(alignof(AEscapeDoor) == 0x000008, "Wrong alignment on AEscapeDoor");
static_assert(sizeof(AEscapeDoor) == 0x000490, "Wrong size on AEscapeDoor");
static_assert(offsetof(AEscapeDoor, EscapePositions) == 0x0003B0, "Member 'AEscapeDoor::EscapePositions' has a wrong offset!");
static_assert(offsetof(AEscapeDoor, EscapeFire) == 0x0003C0, "Member 'AEscapeDoor::EscapeFire' has a wrong offset!");
static_assert(offsetof(AEscapeDoor, _killerOpenChargeable) == 0x0003D0, "Member 'AEscapeDoor::_killerOpenChargeable' has a wrong offset!");
static_assert(offsetof(AEscapeDoor, _openChargeable) == 0x0003D8, "Member 'AEscapeDoor::_openChargeable' has a wrong offset!");
static_assert(offsetof(AEscapeDoor, _ak_audio_escape) == 0x0003E0, "Member 'AEscapeDoor::_ak_audio_escape' has a wrong offset!");
static_assert(offsetof(AEscapeDoor, _escapeDoorAnimInstance) == 0x0003E8, "Member 'AEscapeDoor::_escapeDoorAnimInstance' has a wrong offset!");
static_assert(offsetof(AEscapeDoor, _rootComponent) == 0x0003F0, "Member 'AEscapeDoor::_rootComponent' has a wrong offset!");
static_assert(offsetof(AEscapeDoor, _activated) == 0x0003F8, "Member 'AEscapeDoor::_activated' has a wrong offset!");
static_assert(offsetof(AEscapeDoor, _spotlight) == 0x000400, "Member 'AEscapeDoor::_spotlight' has a wrong offset!");
static_assert(offsetof(AEscapeDoor, _localOverlappingSurvivors) == 0x000450, "Member 'AEscapeDoor::_localOverlappingSurvivors' has a wrong offset!");
static_assert(offsetof(AEscapeDoor, _perceptionStimuliComponent) == 0x000468, "Member 'AEscapeDoor::_perceptionStimuliComponent' has a wrong offset!");
static_assert(offsetof(AEscapeDoor, _doorSwitchBlockableComponent) == 0x000470, "Member 'AEscapeDoor::_doorSwitchBlockableComponent' has a wrong offset!");

// Class DeadByDaylight.EscapeOutlineUpdateStrategy
// 0x0020 (0x00F0 - 0x00D0)
class UEscapeOutlineUpdateStrategy final : public UOutlineUpdateStrategy
{
public:
	struct FLinearColor                           _doorOpenColorForSurvivor;                         // 0x00D0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           _doorOpenColorForKiller;                           // 0x00E0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EscapeOutlineUpdateStrategy">();
	}
	static class UEscapeOutlineUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEscapeOutlineUpdateStrategy>();
	}
};
static_assert(alignof(UEscapeOutlineUpdateStrategy) == 0x000008, "Wrong alignment on UEscapeOutlineUpdateStrategy");
static_assert(sizeof(UEscapeOutlineUpdateStrategy) == 0x0000F0, "Wrong size on UEscapeOutlineUpdateStrategy");
static_assert(offsetof(UEscapeOutlineUpdateStrategy, _doorOpenColorForSurvivor) == 0x0000D0, "Member 'UEscapeOutlineUpdateStrategy::_doorOpenColorForSurvivor' has a wrong offset!");
static_assert(offsetof(UEscapeOutlineUpdateStrategy, _doorOpenColorForKiller) == 0x0000E0, "Member 'UEscapeOutlineUpdateStrategy::_doorOpenColorForKiller' has a wrong offset!");

// Class DeadByDaylight.EscapeThroughHatch
// 0x0000 (0x0780 - 0x0780)
class UEscapeThroughHatch : public UBaseEscapeThroughHatch
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EscapeThroughHatch">();
	}
	static class UEscapeThroughHatch* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEscapeThroughHatch>();
	}
};
static_assert(alignof(UEscapeThroughHatch) == 0x000010, "Wrong alignment on UEscapeThroughHatch");
static_assert(sizeof(UEscapeThroughHatch) == 0x000780, "Wrong size on UEscapeThroughHatch");

// Class DeadByDaylight.EscapeTile2
// 0x0000 (0x0300 - 0x0300)
class AEscapeTile2 final : public ATile2
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EscapeTile2">();
	}
	static class AEscapeTile2* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEscapeTile2>();
	}
};
static_assert(alignof(AEscapeTile2) == 0x000008, "Wrong alignment on AEscapeTile2");
static_assert(sizeof(AEscapeTile2) == 0x000300, "Wrong size on AEscapeTile2");

// Class DeadByDaylight.EventCustomizationHelper
// 0x0000 (0x0030 - 0x0030)
class UEventCustomizationHelper final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventCustomizationHelper">();
	}
	static class UEventCustomizationHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventCustomizationHelper>();
	}
};
static_assert(alignof(UEventCustomizationHelper) == 0x000008, "Wrong alignment on UEventCustomizationHelper");
static_assert(sizeof(UEventCustomizationHelper) == 0x000030, "Wrong size on UEventCustomizationHelper");

// Class DeadByDaylight.EventGeneratorComponent
// 0x0020 (0x00D0 - 0x00B0)
class UEventGeneratorComponent final : public UEventObjectComponent
{
public:
	struct FGameplayTag                           _genCompletedScoreEvent;                           // 0x00B0(0x000C)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTag                           _genCompletedNoOfferingScoreEvent;                 // 0x00BC(0x000C)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EOfferingEffectType                           _offeringEffectTypeNeeded;                         // 0x00C8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _updateOutlineForSurvivor;                         // 0x00C9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _updateOutlineForSlasher;                          // 0x00CA(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_CB[0x5];                                       // 0x00CB(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_FireGenCompletedEventScore(bool IsAutoCompleted);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventGeneratorComponent">();
	}
	static class UEventGeneratorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventGeneratorComponent>();
	}
};
static_assert(alignof(UEventGeneratorComponent) == 0x000008, "Wrong alignment on UEventGeneratorComponent");
static_assert(sizeof(UEventGeneratorComponent) == 0x0000D0, "Wrong size on UEventGeneratorComponent");
static_assert(offsetof(UEventGeneratorComponent, _genCompletedScoreEvent) == 0x0000B0, "Member 'UEventGeneratorComponent::_genCompletedScoreEvent' has a wrong offset!");
static_assert(offsetof(UEventGeneratorComponent, _genCompletedNoOfferingScoreEvent) == 0x0000BC, "Member 'UEventGeneratorComponent::_genCompletedNoOfferingScoreEvent' has a wrong offset!");
static_assert(offsetof(UEventGeneratorComponent, _offeringEffectTypeNeeded) == 0x0000C8, "Member 'UEventGeneratorComponent::_offeringEffectTypeNeeded' has a wrong offset!");
static_assert(offsetof(UEventGeneratorComponent, _updateOutlineForSurvivor) == 0x0000C9, "Member 'UEventGeneratorComponent::_updateOutlineForSurvivor' has a wrong offset!");
static_assert(offsetof(UEventGeneratorComponent, _updateOutlineForSlasher) == 0x0000CA, "Member 'UEventGeneratorComponent::_updateOutlineForSlasher' has a wrong offset!");

// Class DeadByDaylight.EventHookComponent
// 0x0030 (0x00E0 - 0x00B0)
class UEventHookComponent final : public UEventObjectComponent
{
public:
	uint8                                         Pad_B0[0x10];                                      // 0x00B0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           _hookedOnEventHookScoreEvent;                      // 0x00C0(0x000C)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTag                           _hookedOnEventHookNoOfferingScoreEvent;            // 0x00CC(0x000C)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EOfferingEffectType                           _offeringEffectTypeNeeded;                         // 0x00D8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _rewardScoreOnFirstHookOnly;                       // 0x00D9(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _updateOutlineForSurvivor;                         // 0x00DA(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _updateOutlineForSlasher;                          // 0x00DB(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_DC[0x4];                                       // 0x00DC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_FireHookedScoreEvent(class ADBDPlayer* HookedPlayer);
	void SetOutlineCarryingColorToDefault();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventHookComponent">();
	}
	static class UEventHookComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventHookComponent>();
	}
};
static_assert(alignof(UEventHookComponent) == 0x000008, "Wrong alignment on UEventHookComponent");
static_assert(sizeof(UEventHookComponent) == 0x0000E0, "Wrong size on UEventHookComponent");
static_assert(offsetof(UEventHookComponent, _hookedOnEventHookScoreEvent) == 0x0000C0, "Member 'UEventHookComponent::_hookedOnEventHookScoreEvent' has a wrong offset!");
static_assert(offsetof(UEventHookComponent, _hookedOnEventHookNoOfferingScoreEvent) == 0x0000CC, "Member 'UEventHookComponent::_hookedOnEventHookNoOfferingScoreEvent' has a wrong offset!");
static_assert(offsetof(UEventHookComponent, _offeringEffectTypeNeeded) == 0x0000D8, "Member 'UEventHookComponent::_offeringEffectTypeNeeded' has a wrong offset!");
static_assert(offsetof(UEventHookComponent, _rewardScoreOnFirstHookOnly) == 0x0000D9, "Member 'UEventHookComponent::_rewardScoreOnFirstHookOnly' has a wrong offset!");
static_assert(offsetof(UEventHookComponent, _updateOutlineForSurvivor) == 0x0000DA, "Member 'UEventHookComponent::_updateOutlineForSurvivor' has a wrong offset!");
static_assert(offsetof(UEventHookComponent, _updateOutlineForSlasher) == 0x0000DB, "Member 'UEventHookComponent::_updateOutlineForSlasher' has a wrong offset!");

// Class DeadByDaylight.EventObjectItemWidgetInterface
// 0x0000 (0x0030 - 0x0030)
class IEventObjectItemWidgetInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventObjectItemWidgetInterface">();
	}
	static class IEventObjectItemWidgetInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IEventObjectItemWidgetInterface>();
	}
};
static_assert(alignof(IEventObjectItemWidgetInterface) == 0x000008, "Wrong alignment on IEventObjectItemWidgetInterface");
static_assert(sizeof(IEventObjectItemWidgetInterface) == 0x000030, "Wrong size on IEventObjectItemWidgetInterface");

// Class DeadByDaylight.EventSpawnableStaticMeshActor
// 0x0008 (0x02B8 - 0x02B0)
class AEventSpawnableStaticMeshActor final : public AStaticMeshActor
{
public:
	class UEventSpawnableComponent*               _eventSpawnableComponent;                          // 0x02B0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoClear, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventSpawnableStaticMeshActor">();
	}
	static class AEventSpawnableStaticMeshActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEventSpawnableStaticMeshActor>();
	}
};
static_assert(alignof(AEventSpawnableStaticMeshActor) == 0x000008, "Wrong alignment on AEventSpawnableStaticMeshActor");
static_assert(sizeof(AEventSpawnableStaticMeshActor) == 0x0002B8, "Wrong size on AEventSpawnableStaticMeshActor");
static_assert(offsetof(AEventSpawnableStaticMeshActor, _eventSpawnableComponent) == 0x0002B0, "Member 'AEventSpawnableStaticMeshActor::_eventSpawnableComponent' has a wrong offset!");

// Class DeadByDaylight.EvilWithinComponent
// 0x0088 (0x0130 - 0x00A8)
class UEvilWithinComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnTierChange;                                      // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	int32                                         _currentTier;                                      // 0x00B8(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _lastTierTimeStart;                                // 0x00BC(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C0[0x60];                                      // 0x00C0(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         _allowedSurvivorInteractionsForKill;               // 0x0120(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	void Authority_NotifyKill();
	void Authority_OnPlayerDisconnect(class ADBDPlayer* Player);
	void Authority_OnStalkPointsAdded(float StalkPoints);
	void OnLevelReadyToPlay();
	void OnRep_CurrentTier(int32 PreviousTier);

	bool CanBeStandingKilled(const class ADBDPlayer* Player) const;
	bool CanStandKill(const class ADBDPlayer* Player) const;
	int32 GetCurrentTier() const;
	int32 GetMaxTier() const;
	float GetPercentStalkingPointsInCurrentTier() const;
	float GetRequirementForTier(int32 Tier) const;
	bool IsAtLastTier() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EvilWithinComponent">();
	}
	static class UEvilWithinComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEvilWithinComponent>();
	}
};
static_assert(alignof(UEvilWithinComponent) == 0x000008, "Wrong alignment on UEvilWithinComponent");
static_assert(sizeof(UEvilWithinComponent) == 0x000130, "Wrong size on UEvilWithinComponent");
static_assert(offsetof(UEvilWithinComponent, OnTierChange) == 0x0000A8, "Member 'UEvilWithinComponent::OnTierChange' has a wrong offset!");
static_assert(offsetof(UEvilWithinComponent, _currentTier) == 0x0000B8, "Member 'UEvilWithinComponent::_currentTier' has a wrong offset!");
static_assert(offsetof(UEvilWithinComponent, _lastTierTimeStart) == 0x0000BC, "Member 'UEvilWithinComponent::_lastTierTimeStart' has a wrong offset!");
static_assert(offsetof(UEvilWithinComponent, _allowedSurvivorInteractionsForKill) == 0x000120, "Member 'UEvilWithinComponent::_allowedSurvivorInteractionsForKill' has a wrong offset!");

// Class DeadByDaylight.ExperimentsHelper
// 0x0000 (0x0030 - 0x0030)
class UExperimentsHelper final : public UObject
{
public:
	static bool GetAllActive(const class UObject* ContextObject, TArray<struct FCombinedExperimentData>* OutData);
	static bool GetCombinedData(const class UObject* ContextObject, class FName ExperimentId, struct FCombinedExperimentData* OutData);
	static bool IsActive(const class UObject* ContextObject, class FName ExperimentId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExperimentsHelper">();
	}
	static class UExperimentsHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UExperimentsHelper>();
	}
};
static_assert(alignof(UExperimentsHelper) == 0x000008, "Wrong alignment on UExperimentsHelper");
static_assert(sizeof(UExperimentsHelper) == 0x000030, "Wrong size on UExperimentsHelper");

// Class DeadByDaylight.ExperimentsSubsystem
// 0x0070 (0x00A8 - 0x0038)
class UExperimentsSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x70];                                      // 0x0038(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExperimentsSubsystem">();
	}
	static class UExperimentsSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UExperimentsSubsystem>();
	}
};
static_assert(alignof(UExperimentsSubsystem) == 0x000008, "Wrong alignment on UExperimentsSubsystem");
static_assert(sizeof(UExperimentsSubsystem) == 0x0000A8, "Wrong size on UExperimentsSubsystem");

// Class DeadByDaylight.ExposerCirclingComponent
// 0x0070 (0x0330 - 0x02C0)
class UExposerCirclingComponent final : public USceneComponent
{
public:
	bool                                          DirectionFollows;                                  // 0x02C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C1[0x3];                                      // 0x02C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinHeight;                                         // 0x02C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxHeight;                                         // 0x02C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinRadius;                                         // 0x02CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRadius;                                         // 0x02D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CirclingSpeed;                                     // 0x02D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceBetweenPoints;                             // 0x02D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BezierModifier;                                    // 0x02DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Samples;                                           // 0x02E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E4[0x4C];                                     // 0x02E4(0x004C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Reset();
	void SetIsCircling(bool Circling);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExposerCirclingComponent">();
	}
	static class UExposerCirclingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UExposerCirclingComponent>();
	}
};
static_assert(alignof(UExposerCirclingComponent) == 0x000010, "Wrong alignment on UExposerCirclingComponent");
static_assert(sizeof(UExposerCirclingComponent) == 0x000330, "Wrong size on UExposerCirclingComponent");
static_assert(offsetof(UExposerCirclingComponent, DirectionFollows) == 0x0002C0, "Member 'UExposerCirclingComponent::DirectionFollows' has a wrong offset!");
static_assert(offsetof(UExposerCirclingComponent, MinHeight) == 0x0002C4, "Member 'UExposerCirclingComponent::MinHeight' has a wrong offset!");
static_assert(offsetof(UExposerCirclingComponent, MaxHeight) == 0x0002C8, "Member 'UExposerCirclingComponent::MaxHeight' has a wrong offset!");
static_assert(offsetof(UExposerCirclingComponent, MinRadius) == 0x0002CC, "Member 'UExposerCirclingComponent::MinRadius' has a wrong offset!");
static_assert(offsetof(UExposerCirclingComponent, MaxRadius) == 0x0002D0, "Member 'UExposerCirclingComponent::MaxRadius' has a wrong offset!");
static_assert(offsetof(UExposerCirclingComponent, CirclingSpeed) == 0x0002D4, "Member 'UExposerCirclingComponent::CirclingSpeed' has a wrong offset!");
static_assert(offsetof(UExposerCirclingComponent, DistanceBetweenPoints) == 0x0002D8, "Member 'UExposerCirclingComponent::DistanceBetweenPoints' has a wrong offset!");
static_assert(offsetof(UExposerCirclingComponent, BezierModifier) == 0x0002DC, "Member 'UExposerCirclingComponent::BezierModifier' has a wrong offset!");
static_assert(offsetof(UExposerCirclingComponent, Samples) == 0x0002E0, "Member 'UExposerCirclingComponent::Samples' has a wrong offset!");

// Class DeadByDaylight.Fadeable
// 0x0000 (0x0030 - 0x0030)
class IFadeable final : public IInterface
{
public:
	void OnAlphaChanged(float NewAlpha, class AActor* Other);
	void OnFadeBegin(class AActor* Other);
	void OnFadeEnd(class AActor* Other);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Fadeable">();
	}
	static class IFadeable* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFadeable>();
	}
};
static_assert(alignof(IFadeable) == 0x000008, "Wrong alignment on IFadeable");
static_assert(sizeof(IFadeable) == 0x000030, "Wrong size on IFadeable");

// Class DeadByDaylight.FadeManager
// 0x00B8 (0x0358 - 0x02A0)
class AFadeManager final : public AActor
{
public:
	class AActor*                                 _batchedActors;                                    // 0x02A0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSet<class UMeshComponent*>                   _meshComponents;                                   // 0x02A8(0x0050)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FFadedMesh>                     _fadedMeshes;                                      // 0x02F8(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TSet<class UActorComponent*>                  _excludedActors;                                   // 0x0308(0x0050)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	bool AreAnyMaterialsFaded();
	void DBD_FadeAtCurrentCameraLocation(bool IsEnabled);
	void DBD_TurnCameraAroundPlayerWithFading(bool IsTurning);
	void FadeAt(const struct FVector& Location, bool AdjustAudioOcclusions);
	void RemoveFadeMaterials(bool AdjustAudioOcclusions);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FadeManager">();
	}
	static class AFadeManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFadeManager>();
	}
};
static_assert(alignof(AFadeManager) == 0x000008, "Wrong alignment on AFadeManager");
static_assert(sizeof(AFadeManager) == 0x000358, "Wrong size on AFadeManager");
static_assert(offsetof(AFadeManager, _batchedActors) == 0x0002A0, "Member 'AFadeManager::_batchedActors' has a wrong offset!");
static_assert(offsetof(AFadeManager, _meshComponents) == 0x0002A8, "Member 'AFadeManager::_meshComponents' has a wrong offset!");
static_assert(offsetof(AFadeManager, _fadedMeshes) == 0x0002F8, "Member 'AFadeManager::_fadedMeshes' has a wrong offset!");
static_assert(offsetof(AFadeManager, _excludedActors) == 0x000308, "Member 'AFadeManager::_excludedActors' has a wrong offset!");

// Class DeadByDaylight.FasterChestSearch
// 0x0000 (0x0380 - 0x0380)
class UFasterChestSearch final : public UStatusEffect
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FasterChestSearch">();
	}
	static class UFasterChestSearch* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFasterChestSearch>();
	}
};
static_assert(alignof(UFasterChestSearch) == 0x000008, "Wrong alignment on UFasterChestSearch");
static_assert(sizeof(UFasterChestSearch) == 0x000380, "Wrong size on UFasterChestSearch");

// Class DeadByDaylight.FearMarketPopupScreen
// 0x0000 (0x0148 - 0x0148)
class UFearMarketPopupScreen final : public UGenericPopupScreen
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FearMarketPopupScreen">();
	}
	static class UFearMarketPopupScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFearMarketPopupScreen>();
	}
};
static_assert(alignof(UFearMarketPopupScreen) == 0x000008, "Wrong alignment on UFearMarketPopupScreen");
static_assert(sizeof(UFearMarketPopupScreen) == 0x000148, "Wrong size on UFearMarketPopupScreen");

// Class DeadByDaylight.FinisherMoriHandlerComponent
// 0x0018 (0x00C0 - 0x00A8)
class UFinisherMoriHandlerComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             Cosmetic_OnMoriBecameAvailable;                    // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FinisherMoriHandlerComponent">();
	}
	static class UFinisherMoriHandlerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFinisherMoriHandlerComponent>();
	}
};
static_assert(alignof(UFinisherMoriHandlerComponent) == 0x000008, "Wrong alignment on UFinisherMoriHandlerComponent");
static_assert(sizeof(UFinisherMoriHandlerComponent) == 0x0000C0, "Wrong size on UFinisherMoriHandlerComponent");
static_assert(offsetof(UFinisherMoriHandlerComponent, Cosmetic_OnMoriBecameAvailable) == 0x0000A8, "Member 'UFinisherMoriHandlerComponent::Cosmetic_OnMoriBecameAvailable' has a wrong offset!");

// Class DeadByDaylight.FleeComponent
// 0x0028 (0x00D0 - 0x00A8)
class UFleeComponent final : public UActorComponent
{
public:
	class AActor*                                 _threat;                                           // 0x00A8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B0[0x20];                                      // 0x00B0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FleeComponent">();
	}
	static class UFleeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFleeComponent>();
	}
};
static_assert(alignof(UFleeComponent) == 0x000008, "Wrong alignment on UFleeComponent");
static_assert(sizeof(UFleeComponent) == 0x0000D0, "Wrong size on UFleeComponent");
static_assert(offsetof(UFleeComponent, _threat) == 0x0000A8, "Member 'UFleeComponent::_threat' has a wrong offset!");

// Class DeadByDaylight.FlickeringLight
// 0x03C8 (0x0690 - 0x02C8)
class AFlickeringLight final : public AGeneratorDrivenActor
{
public:
	EFlickeringLightType                          _lightComponentType;                               // 0x02C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EDetailMode                                   _detailLevelBeforeCastShadows;                     // 0x02CC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FPerPlatformBool                       _castShadow;                                       // 0x02CD(0x0001)(NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2CE[0x2];                                      // 0x02CE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBHVRPerDetailModeBool                 _isCastingShadow;                                  // 0x02D0(0x00A0)(Edit, NativeAccessSpecifierPrivate)
	struct FBHVRPerDetailModeFloat                _maxDrawDistance;                                  // 0x0370(0x00A0)(Edit, NativeAccessSpecifierPrivate)
	struct FBHVRPerDetailModeFloat                _maxDistanceFadeRange;                             // 0x0410(0x00A0)(Edit, NativeAccessSpecifierPrivate)
	struct FBHVRPerDetailModeBool                 _castCinematicShadowsOnly;                         // 0x04B0(0x00A0)(Edit, NativeAccessSpecifierPrivate)
	float                                         _innerConneAngle;                                  // 0x0550(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _outerConneAngle;                                  // 0x0554(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _sourceLength;                                     // 0x0558(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _sourceRadius;                                     // 0x055C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _intensity;                                        // 0x0560(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _generatorActivated;                               // 0x0564(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isTimelineSpeedRandom;                            // 0x0565(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_566[0x2];                                      // 0x0566(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _maximumTimelimeSpeed;                             // 0x0568(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _minimumTimelimeSpeed;                             // 0x056C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBHVRPerDetailModeBool                 _secondaryLightVisibility;                         // 0x0570(0x00A0)(Edit, NativeAccessSpecifierPrivate)
	float                                         _secondaryLightIntensity;                          // 0x0610(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_614[0x4];                                      // 0x0614(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                _secondaryLightTransform;                          // 0x0618(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FRotator                               _secondaryLightRotation;                           // 0x0630(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	float                                         _secondaryLightAttenuationRadius;                  // 0x0648(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           _secondaryLightColor;                              // 0x064C(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _secondaryLightSpecularScale;                      // 0x065C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         _isAlwaysCapturedAsON : 1;                         // 0x0660(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_661[0x7];                                      // 0x0661(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ULightIntensityTimelineComponent*       _lightIntensityTimeline;                           // 0x0668(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPointLightComponent*                   _pointLightComponent;                              // 0x0670(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPointLightComponent*                   _secondaryPointLightComponent;                     // 0x0678(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URectLightComponent*                    _rectLightComponent;                               // 0x0680(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USpotLightComponent*                    _spotLightComponent;                               // 0x0688(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class ULocalLightComponent* GetActiveLightComponent();
	class ULocalLightComponent* GetSecondaryLightComponent();
	bool GetSecondaryLightVisibilty();
	void Init();
	void StartFlickering();
	void StopFlickering();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlickeringLight">();
	}
	static class AFlickeringLight* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFlickeringLight>();
	}
};
static_assert(alignof(AFlickeringLight) == 0x000008, "Wrong alignment on AFlickeringLight");
static_assert(sizeof(AFlickeringLight) == 0x000690, "Wrong size on AFlickeringLight");
static_assert(offsetof(AFlickeringLight, _lightComponentType) == 0x0002C8, "Member 'AFlickeringLight::_lightComponentType' has a wrong offset!");
static_assert(offsetof(AFlickeringLight, _detailLevelBeforeCastShadows) == 0x0002CC, "Member 'AFlickeringLight::_detailLevelBeforeCastShadows' has a wrong offset!");
static_assert(offsetof(AFlickeringLight, _castShadow) == 0x0002CD, "Member 'AFlickeringLight::_castShadow' has a wrong offset!");
static_assert(offsetof(AFlickeringLight, _isCastingShadow) == 0x0002D0, "Member 'AFlickeringLight::_isCastingShadow' has a wrong offset!");
static_assert(offsetof(AFlickeringLight, _maxDrawDistance) == 0x000370, "Member 'AFlickeringLight::_maxDrawDistance' has a wrong offset!");
static_assert(offsetof(AFlickeringLight, _maxDistanceFadeRange) == 0x000410, "Member 'AFlickeringLight::_maxDistanceFadeRange' has a wrong offset!");
static_assert(offsetof(AFlickeringLight, _castCinematicShadowsOnly) == 0x0004B0, "Member 'AFlickeringLight::_castCinematicShadowsOnly' has a wrong offset!");
static_assert(offsetof(AFlickeringLight, _innerConneAngle) == 0x000550, "Member 'AFlickeringLight::_innerConneAngle' has a wrong offset!");
static_assert(offsetof(AFlickeringLight, _outerConneAngle) == 0x000554, "Member 'AFlickeringLight::_outerConneAngle' has a wrong offset!");
static_assert(offsetof(AFlickeringLight, _sourceLength) == 0x000558, "Member 'AFlickeringLight::_sourceLength' has a wrong offset!");
static_assert(offsetof(AFlickeringLight, _sourceRadius) == 0x00055C, "Member 'AFlickeringLight::_sourceRadius' has a wrong offset!");
static_assert(offsetof(AFlickeringLight, _intensity) == 0x000560, "Member 'AFlickeringLight::_intensity' has a wrong offset!");
static_assert(offsetof(AFlickeringLight, _generatorActivated) == 0x000564, "Member 'AFlickeringLight::_generatorActivated' has a wrong offset!");
static_assert(offsetof(AFlickeringLight, _isTimelineSpeedRandom) == 0x000565, "Member 'AFlickeringLight::_isTimelineSpeedRandom' has a wrong offset!");
static_assert(offsetof(AFlickeringLight, _maximumTimelimeSpeed) == 0x000568, "Member 'AFlickeringLight::_maximumTimelimeSpeed' has a wrong offset!");
static_assert(offsetof(AFlickeringLight, _minimumTimelimeSpeed) == 0x00056C, "Member 'AFlickeringLight::_minimumTimelimeSpeed' has a wrong offset!");
static_assert(offsetof(AFlickeringLight, _secondaryLightVisibility) == 0x000570, "Member 'AFlickeringLight::_secondaryLightVisibility' has a wrong offset!");
static_assert(offsetof(AFlickeringLight, _secondaryLightIntensity) == 0x000610, "Member 'AFlickeringLight::_secondaryLightIntensity' has a wrong offset!");
static_assert(offsetof(AFlickeringLight, _secondaryLightTransform) == 0x000618, "Member 'AFlickeringLight::_secondaryLightTransform' has a wrong offset!");
static_assert(offsetof(AFlickeringLight, _secondaryLightRotation) == 0x000630, "Member 'AFlickeringLight::_secondaryLightRotation' has a wrong offset!");
static_assert(offsetof(AFlickeringLight, _secondaryLightAttenuationRadius) == 0x000648, "Member 'AFlickeringLight::_secondaryLightAttenuationRadius' has a wrong offset!");
static_assert(offsetof(AFlickeringLight, _secondaryLightColor) == 0x00064C, "Member 'AFlickeringLight::_secondaryLightColor' has a wrong offset!");
static_assert(offsetof(AFlickeringLight, _secondaryLightSpecularScale) == 0x00065C, "Member 'AFlickeringLight::_secondaryLightSpecularScale' has a wrong offset!");
static_assert(offsetof(AFlickeringLight, _lightIntensityTimeline) == 0x000668, "Member 'AFlickeringLight::_lightIntensityTimeline' has a wrong offset!");
static_assert(offsetof(AFlickeringLight, _pointLightComponent) == 0x000670, "Member 'AFlickeringLight::_pointLightComponent' has a wrong offset!");
static_assert(offsetof(AFlickeringLight, _secondaryPointLightComponent) == 0x000678, "Member 'AFlickeringLight::_secondaryPointLightComponent' has a wrong offset!");
static_assert(offsetof(AFlickeringLight, _rectLightComponent) == 0x000680, "Member 'AFlickeringLight::_rectLightComponent' has a wrong offset!");
static_assert(offsetof(AFlickeringLight, _spotLightComponent) == 0x000688, "Member 'AFlickeringLight::_spotLightComponent' has a wrong offset!");

// Class DeadByDaylight.FoliageDensityContainer
// 0x00F8 (0x0398 - 0x02A0)
class AFoliageDensityContainer final : public AActor
{
public:
	TMap<class FName, class AFoliageActor*>       _foliageActors;                                    // 0x02A0(0x0050)(NativeAccessSpecifierPrivate)
	TMap<class FName, class UFoliageDensityHISM*> _foliageHISMs;                                     // 0x02F0(0x0050)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_340[0x50];                                     // 0x0340(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class UDBDMapFoliageDensityTunables*          _mapFoliageDensityTunables;                        // 0x0390(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FoliageDensityContainer">();
	}
	static class AFoliageDensityContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFoliageDensityContainer>();
	}
};
static_assert(alignof(AFoliageDensityContainer) == 0x000008, "Wrong alignment on AFoliageDensityContainer");
static_assert(sizeof(AFoliageDensityContainer) == 0x000398, "Wrong size on AFoliageDensityContainer");
static_assert(offsetof(AFoliageDensityContainer, _foliageActors) == 0x0002A0, "Member 'AFoliageDensityContainer::_foliageActors' has a wrong offset!");
static_assert(offsetof(AFoliageDensityContainer, _foliageHISMs) == 0x0002F0, "Member 'AFoliageDensityContainer::_foliageHISMs' has a wrong offset!");
static_assert(offsetof(AFoliageDensityContainer, _mapFoliageDensityTunables) == 0x000390, "Member 'AFoliageDensityContainer::_mapFoliageDensityTunables' has a wrong offset!");

// Class DeadByDaylight.FreeSpotAroundLocationSpawnStrategy
// 0x0028 (0x0058 - 0x0030)
class UFreeSpotAroundLocationSpawnStrategy final : public UCommentatorSpawnStrategy
{
public:
	float                                         _minSpawnRadius;                                   // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _maxSpawnRadius;                                   // 0x0034(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _floorDepth;                                       // 0x0038(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _collisionSphereRadius;                            // 0x003C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _checkForEveryAngleDegrees;                        // 0x0040(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _numberOfPositionToCheckInAnAngle;                 // 0x0044(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TSubclassOf<class AActor>>             _actorsToIgnore;                                   // 0x0048(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FreeSpotAroundLocationSpawnStrategy">();
	}
	static class UFreeSpotAroundLocationSpawnStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFreeSpotAroundLocationSpawnStrategy>();
	}
};
static_assert(alignof(UFreeSpotAroundLocationSpawnStrategy) == 0x000008, "Wrong alignment on UFreeSpotAroundLocationSpawnStrategy");
static_assert(sizeof(UFreeSpotAroundLocationSpawnStrategy) == 0x000058, "Wrong size on UFreeSpotAroundLocationSpawnStrategy");
static_assert(offsetof(UFreeSpotAroundLocationSpawnStrategy, _minSpawnRadius) == 0x000030, "Member 'UFreeSpotAroundLocationSpawnStrategy::_minSpawnRadius' has a wrong offset!");
static_assert(offsetof(UFreeSpotAroundLocationSpawnStrategy, _maxSpawnRadius) == 0x000034, "Member 'UFreeSpotAroundLocationSpawnStrategy::_maxSpawnRadius' has a wrong offset!");
static_assert(offsetof(UFreeSpotAroundLocationSpawnStrategy, _floorDepth) == 0x000038, "Member 'UFreeSpotAroundLocationSpawnStrategy::_floorDepth' has a wrong offset!");
static_assert(offsetof(UFreeSpotAroundLocationSpawnStrategy, _collisionSphereRadius) == 0x00003C, "Member 'UFreeSpotAroundLocationSpawnStrategy::_collisionSphereRadius' has a wrong offset!");
static_assert(offsetof(UFreeSpotAroundLocationSpawnStrategy, _checkForEveryAngleDegrees) == 0x000040, "Member 'UFreeSpotAroundLocationSpawnStrategy::_checkForEveryAngleDegrees' has a wrong offset!");
static_assert(offsetof(UFreeSpotAroundLocationSpawnStrategy, _numberOfPositionToCheckInAnAngle) == 0x000044, "Member 'UFreeSpotAroundLocationSpawnStrategy::_numberOfPositionToCheckInAnAngle' has a wrong offset!");
static_assert(offsetof(UFreeSpotAroundLocationSpawnStrategy, _actorsToIgnore) == 0x000048, "Member 'UFreeSpotAroundLocationSpawnStrategy::_actorsToIgnore' has a wrong offset!");

// Class DeadByDaylight.FrenzyData
// 0x0000 (0x0030 - 0x0030)
class IFrenzyData final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FrenzyData">();
	}
	static class IFrenzyData* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFrenzyData>();
	}
};
static_assert(alignof(IFrenzyData) == 0x000008, "Wrong alignment on IFrenzyData");
static_assert(sizeof(IFrenzyData) == 0x000030, "Wrong size on IFrenzyData");

// Class DeadByDaylight.FriendsListScreen
// 0x0128 (0x0250 - 0x0128)
class UFriendsListScreen final : public UScreenBase
{
public:
	uint8                                         Pad_128[0x128];                                    // 0x0128(0x0128)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAcceptFriendInvite(const class FString& FriendId);
	void OnBlockPlayer(const class FString& PlayerId);
	void OnCancelFriendInvite(const class FString& FriendId);
	void OnDeclineFriendInvite(const class FString& FriendId);
	void OnHideNameSelected(const class FString& PlayerId);
	void OnPartyJoinRequest(const class FString& FriendId);
	void OnRemoveFriend(const class FString& FriendId);
	void OnSearchForFriend();
	void OnSendPartyInvite(const class FString& FriendId);
	void OnShowNameSelected(const class FString& PlayerId);
	void OnUnblockPlayer(const class FString& PlayerId);
	void OnViewProfile(const class FString& FriendId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FriendsListScreen">();
	}
	static class UFriendsListScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFriendsListScreen>();
	}
};
static_assert(alignof(UFriendsListScreen) == 0x000008, "Wrong alignment on UFriendsListScreen");
static_assert(sizeof(UFriendsListScreen) == 0x000250, "Wrong size on UFriendsListScreen");

// Class DeadByDaylight.GameAssetLibrary
// 0x0018 (0x00C8 - 0x00B0)
class UGameAssetLibrary final : public UAssetLibrary
{
public:
	class UDBDGameInstance*                       _gameInstance;                                     // 0x00B0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B8[0x10];                                      // 0x00B8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameAssetLibrary">();
	}
	static class UGameAssetLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameAssetLibrary>();
	}
};
static_assert(alignof(UGameAssetLibrary) == 0x000008, "Wrong alignment on UGameAssetLibrary");
static_assert(sizeof(UGameAssetLibrary) == 0x0000C8, "Wrong size on UGameAssetLibrary");
static_assert(offsetof(UGameAssetLibrary, _gameInstance) == 0x0000B0, "Member 'UGameAssetLibrary::_gameInstance' has a wrong offset!");

// Class DeadByDaylight.GameEventListenerCollectionComponent
// 0x0018 (0x00C0 - 0x00A8)
class UGameEventListenerCollectionComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x18];                                      // 0x00A8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ListenToGameEvent(const struct FGameplayTag& EventType, TDelegate<void(struct FGameplayTag& GameEventType, struct FGameEventData& GameEventData)> DelegateToBind);
	void UnlistenToAllGameEvents();
	void UnlistenToGameEvent(const struct FGameplayTag& EventType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameEventListenerCollectionComponent">();
	}
	static class UGameEventListenerCollectionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameEventListenerCollectionComponent>();
	}
};
static_assert(alignof(UGameEventListenerCollectionComponent) == 0x000008, "Wrong alignment on UGameEventListenerCollectionComponent");
static_assert(sizeof(UGameEventListenerCollectionComponent) == 0x0000C0, "Wrong size on UGameEventListenerCollectionComponent");

// Class DeadByDaylight.GameObjective_ActorList
// 0x0038 (0x0318 - 0x02E0)
class AGameObjective_ActorList : public AGameObjectiveBase
{
public:
	TSubclassOf<class AActor>                     _actorClass;                                       // 0x02E0(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  _tags;                                             // 0x02E8(0x0020)(BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	TArray<class AActor*>                         _actors;                                           // 0x0308(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameObjective_ActorList">();
	}
	static class AGameObjective_ActorList* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGameObjective_ActorList>();
	}
};
static_assert(alignof(AGameObjective_ActorList) == 0x000008, "Wrong alignment on AGameObjective_ActorList");
static_assert(sizeof(AGameObjective_ActorList) == 0x000318, "Wrong size on AGameObjective_ActorList");
static_assert(offsetof(AGameObjective_ActorList, _actorClass) == 0x0002E0, "Member 'AGameObjective_ActorList::_actorClass' has a wrong offset!");
static_assert(offsetof(AGameObjective_ActorList, _tags) == 0x0002E8, "Member 'AGameObjective_ActorList::_tags' has a wrong offset!");
static_assert(offsetof(AGameObjective_ActorList, _actors) == 0x000308, "Member 'AGameObjective_ActorList::_actors' has a wrong offset!");

// Class DeadByDaylight.GameObjective_ActivatedGenerators
// 0x0010 (0x0328 - 0x0318)
class AGameObjective_ActivatedGenerators : public AGameObjective_ActorList
{
public:
	EActivatedGenerators_ObjectiveCountType       _objectiveCountType;                               // 0x0318(0x0001)(Edit, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_319[0x3];                                      // 0x0319(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _requiredCount;                                    // 0x031C(0x0004)(Edit, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _activatedCount;                                   // 0x0320(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_324[0x4];                                      // 0x0324(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnGeneratorActivated(bool Activated);
	void OnRep_ActivatedCount(int32 OldCount);
	void OnRep_RequiredCount(int32 OldCount);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameObjective_ActivatedGenerators">();
	}
	static class AGameObjective_ActivatedGenerators* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGameObjective_ActivatedGenerators>();
	}
};
static_assert(alignof(AGameObjective_ActivatedGenerators) == 0x000008, "Wrong alignment on AGameObjective_ActivatedGenerators");
static_assert(sizeof(AGameObjective_ActivatedGenerators) == 0x000328, "Wrong size on AGameObjective_ActivatedGenerators");
static_assert(offsetof(AGameObjective_ActivatedGenerators, _objectiveCountType) == 0x000318, "Member 'AGameObjective_ActivatedGenerators::_objectiveCountType' has a wrong offset!");
static_assert(offsetof(AGameObjective_ActivatedGenerators, _requiredCount) == 0x00031C, "Member 'AGameObjective_ActivatedGenerators::_requiredCount' has a wrong offset!");
static_assert(offsetof(AGameObjective_ActivatedGenerators, _activatedCount) == 0x000320, "Member 'AGameObjective_ActivatedGenerators::_activatedCount' has a wrong offset!");

// Class DeadByDaylight.GameplayModifierFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class UGameplayModifierFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void Authority_ClearAllPlayerGameplayFlags(class ADBDPlayer* TargetPlayer);
	static void Authority_ClearAllPlayerGameplayModifiers(class ADBDPlayer* TargetPlayer);
	static void Authority_ClearPlayerGameplayFlag(class ADBDPlayer* TargetPlayer, const struct FGameplayTag& FlagType);
	static void Authority_ClearPlayerGameplayModifier(class ADBDPlayer* TargetPlayer, const struct FGameplayTag& ModifierType);
	static void Authority_SetPlayerGameplayFlag(class ADBDPlayer* TargetPlayer, const struct FGameplayTag& FlagType);
	static void Authority_SetPlayerGameplayModifier(class ADBDPlayer* TargetPlayer, const struct FGameplayTag& ModifierType, float ModifierValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayModifierFunctionLibrary">();
	}
	static class UGameplayModifierFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayModifierFunctionLibrary>();
	}
};
static_assert(alignof(UGameplayModifierFunctionLibrary) == 0x000008, "Wrong alignment on UGameplayModifierFunctionLibrary");
static_assert(sizeof(UGameplayModifierFunctionLibrary) == 0x000030, "Wrong size on UGameplayModifierFunctionLibrary");

// Class DeadByDaylight.GameplayModifierFunctionLibraryStatusEffect
// 0x0000 (0x0380 - 0x0380)
class UGameplayModifierFunctionLibraryStatusEffect final : public UStatusEffect
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayModifierFunctionLibraryStatusEffect">();
	}
	static class UGameplayModifierFunctionLibraryStatusEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayModifierFunctionLibraryStatusEffect>();
	}
};
static_assert(alignof(UGameplayModifierFunctionLibraryStatusEffect) == 0x000008, "Wrong alignment on UGameplayModifierFunctionLibraryStatusEffect");
static_assert(sizeof(UGameplayModifierFunctionLibraryStatusEffect) == 0x000380, "Wrong size on UGameplayModifierFunctionLibraryStatusEffect");

// Class DeadByDaylight.GameplayNotificationManager
// 0x0028 (0x00D0 - 0x00A8)
class UGameplayNotificationManager final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x28];                                      // 0x00A8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FireGameplayNotification(const struct FGameplayNotificationData& NotificationData, bool AddToHistory);
	void Multicast_FireGameplayNotification(const class UGameplayModifierContainer* ModifierContainer, bool AddToHistory);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayNotificationManager">();
	}
	static class UGameplayNotificationManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayNotificationManager>();
	}
};
static_assert(alignof(UGameplayNotificationManager) == 0x000008, "Wrong alignment on UGameplayNotificationManager");
static_assert(sizeof(UGameplayNotificationManager) == 0x0000D0, "Wrong size on UGameplayNotificationManager");

// Class DeadByDaylight.GameplaySpawnerComponent
// 0x0038 (0x00E0 - 0x00A8)
class UGameplaySpawnerComponent : public UActorComponent
{
public:
	TArray<class UActorComponent*>                _spawnedComponents;                                // 0x00A8(0x0010)(ExportObject, Net, ZeroConstructor, RepNotify, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	int32                                         _numComponentsSpawned;                             // 0x00B8(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         _numComponentsToSpawn;                             // 0x00BC(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C0[0x20];                                      // 0x00C0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_SpawnedComponents();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplaySpawnerComponent">();
	}
	static class UGameplaySpawnerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplaySpawnerComponent>();
	}
};
static_assert(alignof(UGameplaySpawnerComponent) == 0x000008, "Wrong alignment on UGameplaySpawnerComponent");
static_assert(sizeof(UGameplaySpawnerComponent) == 0x0000E0, "Wrong size on UGameplaySpawnerComponent");
static_assert(offsetof(UGameplaySpawnerComponent, _spawnedComponents) == 0x0000A8, "Member 'UGameplaySpawnerComponent::_spawnedComponents' has a wrong offset!");
static_assert(offsetof(UGameplaySpawnerComponent, _numComponentsSpawned) == 0x0000B8, "Member 'UGameplaySpawnerComponent::_numComponentsSpawned' has a wrong offset!");
static_assert(offsetof(UGameplaySpawnerComponent, _numComponentsToSpawn) == 0x0000BC, "Member 'UGameplaySpawnerComponent::_numComponentsToSpawn' has a wrong offset!");

// Class DeadByDaylight.MutatorData
// 0x0010 (0x0048 - 0x0038)
class UMutatorData final : public UDataAsset
{
public:
	TArray<class UMutator*>                       _mutators;                                         // 0x0038(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MutatorData">();
	}
	static class UMutatorData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMutatorData>();
	}
};
static_assert(alignof(UMutatorData) == 0x000008, "Wrong alignment on UMutatorData");
static_assert(sizeof(UMutatorData) == 0x000048, "Wrong size on UMutatorData");
static_assert(offsetof(UMutatorData, _mutators) == 0x000038, "Member 'UMutatorData::_mutators' has a wrong offset!");

// Class DeadByDaylight.GateFactory
// 0x0000 (0x02A0 - 0x02A0)
class AGateFactory final : public AActor
{
public:
	class AGate* GetGate(EGateType GateType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GateFactory">();
	}
	static class AGateFactory* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGateFactory>();
	}
};
static_assert(alignof(AGateFactory) == 0x000008, "Wrong alignment on AGateFactory");
static_assert(sizeof(AGateFactory) == 0x0002A0, "Wrong size on AGateFactory");

// Class DeadByDaylight.GeneratorDrivenActorLinkerComponent
// 0x0008 (0x00B0 - 0x00A8)
class UGeneratorDrivenActorLinkerComponent final : public UActorComponent
{
public:
	class UActorSpawner*                          _owningSpawner;                                    // 0x00A8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GeneratorDrivenActorLinkerComponent">();
	}
	static class UGeneratorDrivenActorLinkerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGeneratorDrivenActorLinkerComponent>();
	}
};
static_assert(alignof(UGeneratorDrivenActorLinkerComponent) == 0x000008, "Wrong alignment on UGeneratorDrivenActorLinkerComponent");
static_assert(sizeof(UGeneratorDrivenActorLinkerComponent) == 0x0000B0, "Wrong size on UGeneratorDrivenActorLinkerComponent");
static_assert(offsetof(UGeneratorDrivenActorLinkerComponent, _owningSpawner) == 0x0000A8, "Member 'UGeneratorDrivenActorLinkerComponent::_owningSpawner' has a wrong offset!");

// Class DeadByDaylight.GeneratorEntity
// 0x0030 (0x02D0 - 0x02A0)
class AGeneratorEntity : public AActor
{
public:
	class AGenerator*                             _associatedGenerator;                              // 0x02A0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMontagePlayer*                         _montagePlayer;                                    // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B0[0x20];                                     // 0x02B0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void PlayMontage(const struct FAnimationMontageDescriptor& AnimMontageID, float PlayRate, bool IsFollower);
	void SetAssociatedGenerator(class AGenerator* Generator);
	void SetSkeletalMeshActive(bool Active);

	class UMontagePlayer* GetMontagePlayer() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GeneratorEntity">();
	}
	static class AGeneratorEntity* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGeneratorEntity>();
	}
};
static_assert(alignof(AGeneratorEntity) == 0x000008, "Wrong alignment on AGeneratorEntity");
static_assert(sizeof(AGeneratorEntity) == 0x0002D0, "Wrong size on AGeneratorEntity");
static_assert(offsetof(AGeneratorEntity, _associatedGenerator) == 0x0002A0, "Member 'AGeneratorEntity::_associatedGenerator' has a wrong offset!");
static_assert(offsetof(AGeneratorEntity, _montagePlayer) == 0x0002A8, "Member 'AGeneratorEntity::_montagePlayer' has a wrong offset!");

// Class DeadByDaylight.GeneratorEntityAnimInstance
// 0x0010 (0x0360 - 0x0350)
class UGeneratorEntityAnimInstance : public UAnimInstance
{
public:
	bool                                          IsCorrupted;                                       // 0x0350(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsCorrupted_End;                                   // 0x0351(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsUncorrupted;                                     // 0x0352(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsUncorrupted_End;                                 // 0x0353(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_354[0xC];                                      // 0x0354(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GeneratorEntityAnimInstance">();
	}
	static class UGeneratorEntityAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGeneratorEntityAnimInstance>();
	}
};
static_assert(alignof(UGeneratorEntityAnimInstance) == 0x000010, "Wrong alignment on UGeneratorEntityAnimInstance");
static_assert(sizeof(UGeneratorEntityAnimInstance) == 0x000360, "Wrong size on UGeneratorEntityAnimInstance");
static_assert(offsetof(UGeneratorEntityAnimInstance, IsCorrupted) == 0x000350, "Member 'UGeneratorEntityAnimInstance::IsCorrupted' has a wrong offset!");
static_assert(offsetof(UGeneratorEntityAnimInstance, IsCorrupted_End) == 0x000351, "Member 'UGeneratorEntityAnimInstance::IsCorrupted_End' has a wrong offset!");
static_assert(offsetof(UGeneratorEntityAnimInstance, IsUncorrupted) == 0x000352, "Member 'UGeneratorEntityAnimInstance::IsUncorrupted' has a wrong offset!");
static_assert(offsetof(UGeneratorEntityAnimInstance, IsUncorrupted_End) == 0x000353, "Member 'UGeneratorEntityAnimInstance::IsUncorrupted_End' has a wrong offset!");

// Class DeadByDaylight.GeneratorOutlineUpdateStrategy
// 0x0048 (0x0190 - 0x0148)
class UGeneratorOutlineUpdateStrategy final : public USourceBasedOutlineUpdateStrategy
{
public:
	struct FLinearColor                           _unrepairedAuraColor;                              // 0x0148(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           _fullyRepairedAuraColor;                           // 0x0158(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FKillerOutlineRevealSettings           _killerRevealSettings;                             // 0x0168(0x0008)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_170[0x20];                                     // 0x0170(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FLinearColor GetWhiteColor() const;
	struct FLinearColor GetYellowColor() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GeneratorOutlineUpdateStrategy">();
	}
	static class UGeneratorOutlineUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGeneratorOutlineUpdateStrategy>();
	}
};
static_assert(alignof(UGeneratorOutlineUpdateStrategy) == 0x000008, "Wrong alignment on UGeneratorOutlineUpdateStrategy");
static_assert(sizeof(UGeneratorOutlineUpdateStrategy) == 0x000190, "Wrong size on UGeneratorOutlineUpdateStrategy");
static_assert(offsetof(UGeneratorOutlineUpdateStrategy, _unrepairedAuraColor) == 0x000148, "Member 'UGeneratorOutlineUpdateStrategy::_unrepairedAuraColor' has a wrong offset!");
static_assert(offsetof(UGeneratorOutlineUpdateStrategy, _fullyRepairedAuraColor) == 0x000158, "Member 'UGeneratorOutlineUpdateStrategy::_fullyRepairedAuraColor' has a wrong offset!");
static_assert(offsetof(UGeneratorOutlineUpdateStrategy, _killerRevealSettings) == 0x000168, "Member 'UGeneratorOutlineUpdateStrategy::_killerRevealSettings' has a wrong offset!");

// Class DeadByDaylight.GenyReflectionCaptureComponent
// 0x0010 (0x02D0 - 0x02C0)
class UGenyReflectionCaptureComponent final : public USceneComponent
{
public:
	TArray<struct FReflectionCaptureTwoStates>    GeneratorDrivenReflectionCapture;                  // 0x02C0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GenyReflectionCaptureComponent">();
	}
	static class UGenyReflectionCaptureComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGenyReflectionCaptureComponent>();
	}
};
static_assert(alignof(UGenyReflectionCaptureComponent) == 0x000010, "Wrong alignment on UGenyReflectionCaptureComponent");
static_assert(sizeof(UGenyReflectionCaptureComponent) == 0x0002D0, "Wrong size on UGenyReflectionCaptureComponent");
static_assert(offsetof(UGenyReflectionCaptureComponent, GeneratorDrivenReflectionCapture) == 0x0002C0, "Member 'UGenyReflectionCaptureComponent::GeneratorDrivenReflectionCapture' has a wrong offset!");

// Class DeadByDaylight.GestureInteractionDefinition
// 0x0000 (0x0780 - 0x0780)
class UGestureInteractionDefinition : public UInteractionDefinition
{
public:
	EGestureID                                    _gestureID;                                        // 0x0778(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_779[0x7];                                      // 0x0779(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GestureInteractionDefinition">();
	}
	static class UGestureInteractionDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGestureInteractionDefinition>();
	}
};
static_assert(alignof(UGestureInteractionDefinition) == 0x000010, "Wrong alignment on UGestureInteractionDefinition");
static_assert(sizeof(UGestureInteractionDefinition) == 0x000780, "Wrong size on UGestureInteractionDefinition");
static_assert(offsetof(UGestureInteractionDefinition, _gestureID) == 0x000778, "Member 'UGestureInteractionDefinition::_gestureID' has a wrong offset!");

// Class DeadByDaylight.GiftManager
// 0x0038 (0x0070 - 0x0038)
class UGiftManager final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x38];                                      // 0x0038(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GiftManager">();
	}
	static class UGiftManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGiftManager>();
	}
};
static_assert(alignof(UGiftManager) == 0x000008, "Wrong alignment on UGiftManager");
static_assert(sizeof(UGiftManager) == 0x000070, "Wrong size on UGiftManager");

// Class DeadByDaylight.GlassStaticMesh
// 0x00A0 (0x0720 - 0x0680)
class UGlassStaticMesh final : public UStaticMeshComponent
{
public:
	uint8                                         Pad_678[0x88];                                     // 0x0678(0x0088)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                DefaultGlassNormalVector;                          // 0x0700(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_718[0x8];                                      // 0x0718(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GlassStaticMesh">();
	}
	static class UGlassStaticMesh* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGlassStaticMesh>();
	}
};
static_assert(alignof(UGlassStaticMesh) == 0x000010, "Wrong alignment on UGlassStaticMesh");
static_assert(sizeof(UGlassStaticMesh) == 0x000720, "Wrong size on UGlassStaticMesh");
static_assert(offsetof(UGlassStaticMesh, DefaultGlassNormalVector) == 0x000700, "Member 'UGlassStaticMesh::DefaultGlassNormalVector' has a wrong offset!");

// Class DeadByDaylight.GlassCollectionSubsystem
// 0x0010 (0x0048 - 0x0038)
class UGlassCollectionSubsystem final : public UGameInstanceSubsystem
{
public:
	TArray<class UGlassStaticMesh*>               _glassCollection;                                  // 0x0038(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GlassCollectionSubsystem">();
	}
	static class UGlassCollectionSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGlassCollectionSubsystem>();
	}
};
static_assert(alignof(UGlassCollectionSubsystem) == 0x000008, "Wrong alignment on UGlassCollectionSubsystem");
static_assert(sizeof(UGlassCollectionSubsystem) == 0x000048, "Wrong size on UGlassCollectionSubsystem");
static_assert(offsetof(UGlassCollectionSubsystem, _glassCollection) == 0x000038, "Member 'UGlassCollectionSubsystem::_glassCollection' has a wrong offset!");

// Class DeadByDaylight.GRDKProfileDAL
// 0x0000 (0x0088 - 0x0088)
class UGRDKProfileDAL final : public UPS4GRDKBaseProfileDAL
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GRDKProfileDAL">();
	}
	static class UGRDKProfileDAL* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGRDKProfileDAL>();
	}
};
static_assert(alignof(UGRDKProfileDAL) == 0x000008, "Wrong alignment on UGRDKProfileDAL");
static_assert(sizeof(UGRDKProfileDAL) == 0x000088, "Wrong size on UGRDKProfileDAL");

// Class DeadByDaylight.HangDiagnosticSubsystem
// 0x0068 (0x00A0 - 0x0038)
class UHangDiagnosticSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x68];                                      // 0x0038(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HangDiagnosticSubsystem">();
	}
	static class UHangDiagnosticSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHangDiagnosticSubsystem>();
	}
};
static_assert(alignof(UHangDiagnosticSubsystem) == 0x000008, "Wrong alignment on UHangDiagnosticSubsystem");
static_assert(sizeof(UHangDiagnosticSubsystem) == 0x0000A0, "Wrong size on UHangDiagnosticSubsystem");

// Class DeadByDaylight.StateSpeedCurveApplier
// 0x0108 (0x01B0 - 0x00A8)
class UStateSpeedCurveApplier final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x108];                                     // 0x00A8(0x0108)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StateSpeedCurveApplier">();
	}
	static class UStateSpeedCurveApplier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStateSpeedCurveApplier>();
	}
};
static_assert(alignof(UStateSpeedCurveApplier) == 0x000008, "Wrong alignment on UStateSpeedCurveApplier");
static_assert(sizeof(UStateSpeedCurveApplier) == 0x0001B0, "Wrong size on UStateSpeedCurveApplier");

// Class DeadByDaylight.HasTokenOrActivationTimerElapsedIconStrategy
// 0x0000 (0x0038 - 0x0038)
class UHasTokenOrActivationTimerElapsedIconStrategy final : public UBasePerkIconStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HasTokenOrActivationTimerElapsedIconStrategy">();
	}
	static class UHasTokenOrActivationTimerElapsedIconStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHasTokenOrActivationTimerElapsedIconStrategy>();
	}
};
static_assert(alignof(UHasTokenOrActivationTimerElapsedIconStrategy) == 0x000008, "Wrong alignment on UHasTokenOrActivationTimerElapsedIconStrategy");
static_assert(sizeof(UHasTokenOrActivationTimerElapsedIconStrategy) == 0x000038, "Wrong size on UHasTokenOrActivationTimerElapsedIconStrategy");

// Class DeadByDaylight.HasTokenOrCooldownTimerRemainingActivationElapsedIconStrategy
// 0x0000 (0x0038 - 0x0038)
class UHasTokenOrCooldownTimerRemainingActivationElapsedIconStrategy final : public UBasePerkIconStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HasTokenOrCooldownTimerRemainingActivationElapsedIconStrategy">();
	}
	static class UHasTokenOrCooldownTimerRemainingActivationElapsedIconStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHasTokenOrCooldownTimerRemainingActivationElapsedIconStrategy>();
	}
};
static_assert(alignof(UHasTokenOrCooldownTimerRemainingActivationElapsedIconStrategy) == 0x000008, "Wrong alignment on UHasTokenOrCooldownTimerRemainingActivationElapsedIconStrategy");
static_assert(sizeof(UHasTokenOrCooldownTimerRemainingActivationElapsedIconStrategy) == 0x000038, "Wrong size on UHasTokenOrCooldownTimerRemainingActivationElapsedIconStrategy");

// Class DeadByDaylight.SoftBanManager
// 0x0040 (0x0070 - 0x0030)
class USoftBanManager final : public UObject
{
public:
	uint8                                         Pad_30[0x40];                                      // 0x0030(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoftBanManager">();
	}
	static class USoftBanManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<USoftBanManager>();
	}
};
static_assert(alignof(USoftBanManager) == 0x000008, "Wrong alignment on USoftBanManager");
static_assert(sizeof(USoftBanManager) == 0x000070, "Wrong size on USoftBanManager");

// Class DeadByDaylight.HasTokenPerkIconStrategy
// 0x0000 (0x0038 - 0x0038)
class UHasTokenPerkIconStrategy final : public UBasePerkIconStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HasTokenPerkIconStrategy">();
	}
	static class UHasTokenPerkIconStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHasTokenPerkIconStrategy>();
	}
};
static_assert(alignof(UHasTokenPerkIconStrategy) == 0x000008, "Wrong alignment on UHasTokenPerkIconStrategy");
static_assert(sizeof(UHasTokenPerkIconStrategy) == 0x000038, "Wrong size on UHasTokenPerkIconStrategy");

// Class DeadByDaylight.HeldInputInteractionStarter
// 0x00F0 (0x0198 - 0x00A8)
class UHeldInputInteractionStarter final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0xF0];                                      // 0x00A8(0x00F0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HeldInputInteractionStarter">();
	}
	static class UHeldInputInteractionStarter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHeldInputInteractionStarter>();
	}
};
static_assert(alignof(UHeldInputInteractionStarter) == 0x000008, "Wrong alignment on UHeldInputInteractionStarter");
static_assert(sizeof(UHeldInputInteractionStarter) == 0x000198, "Wrong size on UHeldInputInteractionStarter");

// Class DeadByDaylight.HitValidationConfigsComponent
// 0x0050 (0x00F8 - 0x00A8)
class UHitValidationConfigsComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x50];                                      // 0x00A8(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DBD_PrintInGameHitValidationConfigs();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HitValidationConfigsComponent">();
	}
	static class UHitValidationConfigsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHitValidationConfigsComponent>();
	}
};
static_assert(alignof(UHitValidationConfigsComponent) == 0x000008, "Wrong alignment on UHitValidationConfigsComponent");
static_assert(sizeof(UHitValidationConfigsComponent) == 0x0000F8, "Wrong size on UHitValidationConfigsComponent");

// Class DeadByDaylight.HitValidatorComponent
// 0x0030 (0x00D8 - 0x00A8)
class UHitValidatorComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x28];                                      // 0x00A8(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UHitValidationConfigsComponent> _hitValidationConfigComponent;                     // 0x00D0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Multicast_DrawDebugHit(const struct FHitValidationReport& Report);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HitValidatorComponent">();
	}
	static class UHitValidatorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHitValidatorComponent>();
	}
};
static_assert(alignof(UHitValidatorComponent) == 0x000008, "Wrong alignment on UHitValidatorComponent");
static_assert(sizeof(UHitValidatorComponent) == 0x0000D8, "Wrong size on UHitValidatorComponent");
static_assert(offsetof(UHitValidatorComponent, _hitValidationConfigComponent) == 0x0000D0, "Member 'UHitValidatorComponent::_hitValidationConfigComponent' has a wrong offset!");

// Class DeadByDaylight.HitValidatorConfigurator
// 0x0018 (0x00C8 - 0x00B0)
class UHitValidatorConfigurator final : public UBaseHitValidationConfigurator
{
public:
	uint8                                         Pad_B0[0x18];                                      // 0x00B0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HitValidatorConfigurator">();
	}
	static class UHitValidatorConfigurator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHitValidatorConfigurator>();
	}
};
static_assert(alignof(UHitValidatorConfigurator) == 0x000008, "Wrong alignment on UHitValidatorConfigurator");
static_assert(sizeof(UHitValidatorConfigurator) == 0x0000C8, "Wrong size on UHitValidatorConfigurator");

// Class DeadByDaylight.HookAnalyticEvents
// 0x0000 (0x0030 - 0x0030)
class IHookAnalyticEvents final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HookAnalyticEvents">();
	}
	static class IHookAnalyticEvents* GetDefaultObj()
	{
		return GetDefaultObjImpl<IHookAnalyticEvents>();
	}
};
static_assert(alignof(IHookAnalyticEvents) == 0x000008, "Wrong alignment on IHookAnalyticEvents");
static_assert(sizeof(IHookAnalyticEvents) == 0x000030, "Wrong size on IHookAnalyticEvents");

// Class DeadByDaylight.HooksWithSurvivorRestrictedPlacementAreaStrategy
// 0x0090 (0x0138 - 0x00A8)
class UHooksWithSurvivorRestrictedPlacementAreaStrategy final : public URestrictedPlacementAreaStrategy
{
public:
	struct FDBDTunableRowHandle                   RestrictedSphericalRadius;                         // 0x00A8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          _isRestrictionLingeringEnabled;                    // 0x00D0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D1[0x7];                                       // 0x00D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _restrictionLingerTime;                            // 0x00D8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_100[0x4];                                      // 0x0100(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _useSphericalZoneForBasementHooks;                 // 0x0104(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_105[0x13];                                     // 0x0105(0x0013)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        RestrictedSphericalLocations;                      // 0x0118(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_128[0x10];                                     // 0x0128(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HooksWithSurvivorRestrictedPlacementAreaStrategy">();
	}
	static class UHooksWithSurvivorRestrictedPlacementAreaStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHooksWithSurvivorRestrictedPlacementAreaStrategy>();
	}
};
static_assert(alignof(UHooksWithSurvivorRestrictedPlacementAreaStrategy) == 0x000008, "Wrong alignment on UHooksWithSurvivorRestrictedPlacementAreaStrategy");
static_assert(sizeof(UHooksWithSurvivorRestrictedPlacementAreaStrategy) == 0x000138, "Wrong size on UHooksWithSurvivorRestrictedPlacementAreaStrategy");
static_assert(offsetof(UHooksWithSurvivorRestrictedPlacementAreaStrategy, RestrictedSphericalRadius) == 0x0000A8, "Member 'UHooksWithSurvivorRestrictedPlacementAreaStrategy::RestrictedSphericalRadius' has a wrong offset!");
static_assert(offsetof(UHooksWithSurvivorRestrictedPlacementAreaStrategy, _isRestrictionLingeringEnabled) == 0x0000D0, "Member 'UHooksWithSurvivorRestrictedPlacementAreaStrategy::_isRestrictionLingeringEnabled' has a wrong offset!");
static_assert(offsetof(UHooksWithSurvivorRestrictedPlacementAreaStrategy, _restrictionLingerTime) == 0x0000D8, "Member 'UHooksWithSurvivorRestrictedPlacementAreaStrategy::_restrictionLingerTime' has a wrong offset!");
static_assert(offsetof(UHooksWithSurvivorRestrictedPlacementAreaStrategy, _useSphericalZoneForBasementHooks) == 0x000104, "Member 'UHooksWithSurvivorRestrictedPlacementAreaStrategy::_useSphericalZoneForBasementHooks' has a wrong offset!");
static_assert(offsetof(UHooksWithSurvivorRestrictedPlacementAreaStrategy, RestrictedSphericalLocations) == 0x000118, "Member 'UHooksWithSurvivorRestrictedPlacementAreaStrategy::RestrictedSphericalLocations' has a wrong offset!");

// Class DeadByDaylight.HudScreen
// 0x0318 (0x0440 - 0x0128)
class UHudScreen final : public UScreenBase
{
public:
	uint8                                         Pad_128[0xD8];                                     // 0x0128(0x00D8)(Fixing Size After Last Property [ Dumper-7 ])
	class UCoreHudRootWidget*                     _rootWidget;                                       // 0x0200(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_208[0xB0];                                     // 0x0208(0x00B0)(Fixing Size After Last Property [ Dumper-7 ])
	class ATutorialsUtilities*                    _tutorialsUtilities;                               // 0x02B8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<TScriptInterface<class IPlayerStatusViewInterface>> _playerStatusInterfaces;                           // 0x02C0(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	struct FInteractionProgressViewData           _interactionProgressViewData;                      // 0x02D0(0x0078)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_348[0x50];                                     // 0x0348(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPlayerStatusViewData>          _playerStatusViewData;                             // 0x0398(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3A8[0x98];                                     // 0x03A8(0x0098)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnHemorrhageAnimationComplete();
	void OnHideStartSequenceCompleted();
	void OnHUDWidgetFadeOutCompleted();
	void OnTutorialHudFadeInTriggered();
	void OnTutorialHudFadeOutTriggered();

	void OnHUDWidgetDelayCompleted() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HudScreen">();
	}
	static class UHudScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHudScreen>();
	}
};
static_assert(alignof(UHudScreen) == 0x000008, "Wrong alignment on UHudScreen");
static_assert(sizeof(UHudScreen) == 0x000440, "Wrong size on UHudScreen");
static_assert(offsetof(UHudScreen, _rootWidget) == 0x000200, "Member 'UHudScreen::_rootWidget' has a wrong offset!");
static_assert(offsetof(UHudScreen, _tutorialsUtilities) == 0x0002B8, "Member 'UHudScreen::_tutorialsUtilities' has a wrong offset!");
static_assert(offsetof(UHudScreen, _playerStatusInterfaces) == 0x0002C0, "Member 'UHudScreen::_playerStatusInterfaces' has a wrong offset!");
static_assert(offsetof(UHudScreen, _interactionProgressViewData) == 0x0002D0, "Member 'UHudScreen::_interactionProgressViewData' has a wrong offset!");
static_assert(offsetof(UHudScreen, _playerStatusViewData) == 0x000398, "Member 'UHudScreen::_playerStatusViewData' has a wrong offset!");

// Class DeadByDaylight.StoreSpecialPackSubsystem
// 0x0120 (0x0158 - 0x0038)
class UStoreSpecialPackSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x120];                                     // 0x0038(0x0120)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	FMulticastInlineDelegateProperty_ GetSpecialPacksUpdatedDelegate();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StoreSpecialPackSubsystem">();
	}
	static class UStoreSpecialPackSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStoreSpecialPackSubsystem>();
	}
};
static_assert(alignof(UStoreSpecialPackSubsystem) == 0x000008, "Wrong alignment on UStoreSpecialPackSubsystem");
static_assert(sizeof(UStoreSpecialPackSubsystem) == 0x000158, "Wrong size on UStoreSpecialPackSubsystem");

// Class DeadByDaylight.HudUIUtilities
// 0x0000 (0x0030 - 0x0030)
class UHudUIUtilities final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HudUIUtilities">();
	}
	static class UHudUIUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHudUIUtilities>();
	}
};
static_assert(alignof(UHudUIUtilities) == 0x000008, "Wrong alignment on UHudUIUtilities");
static_assert(sizeof(UHudUIUtilities) == 0x000030, "Wrong size on UHudUIUtilities");

// Class DeadByDaylight.ButtonPromptSource
// 0x0000 (0x0030 - 0x0030)
class IButtonPromptSource final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ButtonPromptSource">();
	}
	static class IButtonPromptSource* GetDefaultObj()
	{
		return GetDefaultObjImpl<IButtonPromptSource>();
	}
};
static_assert(alignof(IButtonPromptSource) == 0x000008, "Wrong alignment on IButtonPromptSource");
static_assert(sizeof(IButtonPromptSource) == 0x000030, "Wrong size on IButtonPromptSource");

// Class DeadByDaylight.TriggerableWorldObjectComponent
// 0x0098 (0x0140 - 0x00A8)
class UTriggerableWorldObjectComponent : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnTriggered;                                       // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerReset;                                    // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         _triggerResetTime;                                 // 0x00C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _randomChance;                                     // 0x00CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _rollFrequency;                                    // 0x00D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D4[0xC];                                       // 0x00D4(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UPrimitiveComponent>     _conditionalTriggerVolume;                         // 0x00E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSet<class ADBDPlayer*>                       _conditionalVolumeOverlappingPlayers;              // 0x00E8(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class UPrimitiveComponent>     _guaranteedTriggerVolume;                          // 0x0138(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Authority_ConditionalVolumeBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& HitResult);
	void Authority_ConditionalVolumeEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void Authority_GuaranteedVolumeOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& HitResult);
	void Authority_ResetTrigger();
	void Authority_Trigger(class AActor* Instigator, const struct FVector& TriggerLocation);
	bool CanPlayerTriggerConditional(class ADBDPlayer* Player);
	bool CanPlayerTriggerGuaranteed(class ADBDPlayer* Player);
	void GetConditionalModifiers(class ADBDPlayer* Player, float* OutAdditive, float* OutMultiplicative);
	void Multicast_OnTriggered(class AActor* Instigator, const struct FVector& TriggerLocation);
	void Multicast_OnTriggerReset();
	void SetConditionalTriggerVolume(class UPrimitiveComponent* Volume);
	void SetGuaranteedTriggerVolume(class UPrimitiveComponent* Volume);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TriggerableWorldObjectComponent">();
	}
	static class UTriggerableWorldObjectComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTriggerableWorldObjectComponent>();
	}
};
static_assert(alignof(UTriggerableWorldObjectComponent) == 0x000008, "Wrong alignment on UTriggerableWorldObjectComponent");
static_assert(sizeof(UTriggerableWorldObjectComponent) == 0x000140, "Wrong size on UTriggerableWorldObjectComponent");
static_assert(offsetof(UTriggerableWorldObjectComponent, OnTriggered) == 0x0000A8, "Member 'UTriggerableWorldObjectComponent::OnTriggered' has a wrong offset!");
static_assert(offsetof(UTriggerableWorldObjectComponent, OnTriggerReset) == 0x0000B8, "Member 'UTriggerableWorldObjectComponent::OnTriggerReset' has a wrong offset!");
static_assert(offsetof(UTriggerableWorldObjectComponent, _triggerResetTime) == 0x0000C8, "Member 'UTriggerableWorldObjectComponent::_triggerResetTime' has a wrong offset!");
static_assert(offsetof(UTriggerableWorldObjectComponent, _randomChance) == 0x0000CC, "Member 'UTriggerableWorldObjectComponent::_randomChance' has a wrong offset!");
static_assert(offsetof(UTriggerableWorldObjectComponent, _rollFrequency) == 0x0000D0, "Member 'UTriggerableWorldObjectComponent::_rollFrequency' has a wrong offset!");
static_assert(offsetof(UTriggerableWorldObjectComponent, _conditionalTriggerVolume) == 0x0000E0, "Member 'UTriggerableWorldObjectComponent::_conditionalTriggerVolume' has a wrong offset!");
static_assert(offsetof(UTriggerableWorldObjectComponent, _conditionalVolumeOverlappingPlayers) == 0x0000E8, "Member 'UTriggerableWorldObjectComponent::_conditionalVolumeOverlappingPlayers' has a wrong offset!");
static_assert(offsetof(UTriggerableWorldObjectComponent, _guaranteedTriggerVolume) == 0x000138, "Member 'UTriggerableWorldObjectComponent::_guaranteedTriggerVolume' has a wrong offset!");

// Class DeadByDaylight.CannibalChainsawPower
// 0x0000 (0x0030 - 0x0030)
class ICannibalChainsawPower final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CannibalChainsawPower">();
	}
	static class ICannibalChainsawPower* GetDefaultObj()
	{
		return GetDefaultObjImpl<ICannibalChainsawPower>();
	}
};
static_assert(alignof(ICannibalChainsawPower) == 0x000008, "Wrong alignment on ICannibalChainsawPower");
static_assert(sizeof(ICannibalChainsawPower) == 0x000030, "Wrong size on ICannibalChainsawPower");

// Class DeadByDaylight.ChargeableProgressSource
// 0x0000 (0x0030 - 0x0030)
class IChargeableProgressSource final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChargeableProgressSource">();
	}
	static class IChargeableProgressSource* GetDefaultObj()
	{
		return GetDefaultObjImpl<IChargeableProgressSource>();
	}
};
static_assert(alignof(IChargeableProgressSource) == 0x000008, "Wrong alignment on IChargeableProgressSource");
static_assert(sizeof(IChargeableProgressSource) == 0x000030, "Wrong size on IChargeableProgressSource");

// Class DeadByDaylight.Ethereal
// 0x0000 (0x0030 - 0x0030)
class IEthereal final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ethereal">();
	}
	static class IEthereal* GetDefaultObj()
	{
		return GetDefaultObjImpl<IEthereal>();
	}
};
static_assert(alignof(IEthereal) == 0x000008, "Wrong alignment on IEthereal");
static_assert(sizeof(IEthereal) == 0x000030, "Wrong size on IEthereal");

// Class DeadByDaylight.Highlightable
// 0x0000 (0x0030 - 0x0030)
class IHighlightable final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Highlightable">();
	}
	static class IHighlightable* GetDefaultObj()
	{
		return GetDefaultObjImpl<IHighlightable>();
	}
};
static_assert(alignof(IHighlightable) == 0x000008, "Wrong alignment on IHighlightable");
static_assert(sizeof(IHighlightable) == 0x000030, "Wrong size on IHighlightable");

// Class DeadByDaylight.KillerControls
// 0x0000 (0x0030 - 0x0030)
class IKillerControls final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerControls">();
	}
	static class IKillerControls* GetDefaultObj()
	{
		return GetDefaultObjImpl<IKillerControls>();
	}
};
static_assert(alignof(IKillerControls) == 0x000008, "Wrong alignment on IKillerControls");
static_assert(sizeof(IKillerControls) == 0x000030, "Wrong size on IKillerControls");

// Class DeadByDaylight.ImmobilizeUtilities
// 0x0000 (0x0030 - 0x0030)
class UImmobilizeUtilities final : public UBlueprintFunctionLibrary
{
public:
	static EGuidedState GetGuidedState(const class ADBDPlayer* Player);
	static EImmobilizedState GetImmobilizeState(const class ADBDPlayer* Player);
	static bool HasGuidedState(const class ADBDPlayer* Player, EGuidedState GuidedState);
	static bool HasImmobilizeState(const class ADBDPlayer* Player, EImmobilizedState ImmobilizeState);
	static bool IsGuided(const class ADBDPlayer* Player);
	static bool IsGuidedByPlayer(const class ADBDPlayer* Player, const class ADBDPlayer* GuidingPlayer);
	static bool IsImmobilized(const class ADBDPlayer* Player);
	static void RemoveAllGuidingPlayers(class ADBDPlayer* Player);
	static void SetImmobilizeState(class ADBDPlayer* Player, EImmobilizedState ImmobilizeState);
	static void StartGuiding(class ADBDPlayer* Player, EGuidedState GuidedState, class ADBDPlayer* GuidingPlayer);
	static void StopGuiding(class ADBDPlayer* Player, class ADBDPlayer* PreviouslyGuidingPlayer);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ImmobilizeUtilities">();
	}
	static class UImmobilizeUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UImmobilizeUtilities>();
	}
};
static_assert(alignof(UImmobilizeUtilities) == 0x000008, "Wrong alignment on UImmobilizeUtilities");
static_assert(sizeof(UImmobilizeUtilities) == 0x000030, "Wrong size on UImmobilizeUtilities");

// Class DeadByDaylight.InactiveCooldownTimerPerkIconStrategy
// 0x0000 (0x0038 - 0x0038)
class UInactiveCooldownTimerPerkIconStrategy final : public UBasePerkIconStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InactiveCooldownTimerPerkIconStrategy">();
	}
	static class UInactiveCooldownTimerPerkIconStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInactiveCooldownTimerPerkIconStrategy>();
	}
};
static_assert(alignof(UInactiveCooldownTimerPerkIconStrategy) == 0x000008, "Wrong alignment on UInactiveCooldownTimerPerkIconStrategy");
static_assert(sizeof(UInactiveCooldownTimerPerkIconStrategy) == 0x000038, "Wrong size on UInactiveCooldownTimerPerkIconStrategy");

// Class DeadByDaylight.InboxUtilities
// 0x0000 (0x0030 - 0x0030)
class UInboxUtilities final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InboxUtilities">();
	}
	static class UInboxUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInboxUtilities>();
	}
};
static_assert(alignof(UInboxUtilities) == 0x000008, "Wrong alignment on UInboxUtilities");
static_assert(sizeof(UInboxUtilities) == 0x000030, "Wrong size on UInboxUtilities");

// Class DeadByDaylight.InfectedInteractableComponent
// 0x00E8 (0x0190 - 0x00A8)
class UInfectedInteractableComponent final : public UActorComponent
{
public:
	class UCurveFloat*                            VomitAlphaCurve;                                   // 0x00A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   VomitAlphaParameterName;                           // 0x00B0(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTimelineComponent*                     _vomitAlphaTimeline;                               // 0x00C0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C8[0xC8];                                      // 0x00C8(0x00C8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnHitWithVomit();
	void Authority_OnOwningInteractableBeginOrEndUse(bool InUse, class ADBDPlayer* InteractingPlayer);
	void Multicast_DebugDisplayLifetime(float RemainingLifeTime);
	void Multicast_DestroyComponent();
	void Multicast_FadeInVomit();
	void Multicast_FadeOutVomit();
	void OnVomitAlphaUpdate(float Alpha);
	void SetInteractableMeshAlpha(float Alpha);

	class ACamperPlayer* Authority_GetEquippingPlayer() const;
	bool Authority_IsAMaxSicknessSurvivorInteracting() const;
	class AInteractable* GetOwningInteractable() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InfectedInteractableComponent">();
	}
	static class UInfectedInteractableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInfectedInteractableComponent>();
	}
};
static_assert(alignof(UInfectedInteractableComponent) == 0x000008, "Wrong alignment on UInfectedInteractableComponent");
static_assert(sizeof(UInfectedInteractableComponent) == 0x000190, "Wrong size on UInfectedInteractableComponent");
static_assert(offsetof(UInfectedInteractableComponent, VomitAlphaCurve) == 0x0000A8, "Member 'UInfectedInteractableComponent::VomitAlphaCurve' has a wrong offset!");
static_assert(offsetof(UInfectedInteractableComponent, VomitAlphaParameterName) == 0x0000B0, "Member 'UInfectedInteractableComponent::VomitAlphaParameterName' has a wrong offset!");
static_assert(offsetof(UInfectedInteractableComponent, _vomitAlphaTimeline) == 0x0000C0, "Member 'UInfectedInteractableComponent::_vomitAlphaTimeline' has a wrong offset!");

// Class DeadByDaylight.InGameAssetPreloaderGatherer
// 0x0000 (0x0030 - 0x0030)
class UInGameAssetPreloaderGatherer : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InGameAssetPreloaderGatherer">();
	}
	static class UInGameAssetPreloaderGatherer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInGameAssetPreloaderGatherer>();
	}
};
static_assert(alignof(UInGameAssetPreloaderGatherer) == 0x000008, "Wrong alignment on UInGameAssetPreloaderGatherer");
static_assert(sizeof(UInGameAssetPreloaderGatherer) == 0x000030, "Wrong size on UInGameAssetPreloaderGatherer");

// Class DeadByDaylight.InGameLoadoutAssetGatherer
// 0x0000 (0x0030 - 0x0030)
class UInGameLoadoutAssetGatherer final : public UInGameAssetPreloaderGatherer
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InGameLoadoutAssetGatherer">();
	}
	static class UInGameLoadoutAssetGatherer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInGameLoadoutAssetGatherer>();
	}
};
static_assert(alignof(UInGameLoadoutAssetGatherer) == 0x000008, "Wrong alignment on UInGameLoadoutAssetGatherer");
static_assert(sizeof(UInGameLoadoutAssetGatherer) == 0x000030, "Wrong size on UInGameLoadoutAssetGatherer");

// Class DeadByDaylight.StorefrontConfiguration
// 0x0050 (0x0088 - 0x0038)
class UStorefrontConfiguration final : public UDataAsset
{
public:
	TMap<EStorefrontState, struct FStorefrontStateData> States;                                            // 0x0038(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StorefrontConfiguration">();
	}
	static class UStorefrontConfiguration* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStorefrontConfiguration>();
	}
};
static_assert(alignof(UStorefrontConfiguration) == 0x000008, "Wrong alignment on UStorefrontConfiguration");
static_assert(sizeof(UStorefrontConfiguration) == 0x000088, "Wrong size on UStorefrontConfiguration");
static_assert(offsetof(UStorefrontConfiguration, States) == 0x000038, "Member 'UStorefrontConfiguration::States' has a wrong offset!");

// Class DeadByDaylight.IniAssetLibrary
// 0x0010 (0x00C0 - 0x00B0)
class UIniAssetLibrary final : public UAssetLibrary
{
public:
	uint8                                         Pad_B0[0x10];                                      // 0x00B0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IniAssetLibrary">();
	}
	static class UIniAssetLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIniAssetLibrary>();
	}
};
static_assert(alignof(UIniAssetLibrary) == 0x000008, "Wrong alignment on UIniAssetLibrary");
static_assert(sizeof(UIniAssetLibrary) == 0x0000C0, "Wrong size on UIniAssetLibrary");

// Class DeadByDaylight.InteractionAnimNotify
// 0x0010 (0x0050 - 0x0040)
class UInteractionAnimNotify final : public UAnimNotify
{
public:
	class FName                                   NotifyId;                                          // 0x0040(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionAnimNotify">();
	}
	static class UInteractionAnimNotify* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionAnimNotify>();
	}
};
static_assert(alignof(UInteractionAnimNotify) == 0x000008, "Wrong alignment on UInteractionAnimNotify");
static_assert(sizeof(UInteractionAnimNotify) == 0x000050, "Wrong size on UInteractionAnimNotify");
static_assert(offsetof(UInteractionAnimNotify, NotifyId) == 0x000040, "Member 'UInteractionAnimNotify::NotifyId' has a wrong offset!");

// Class DeadByDaylight.InteractionDetectorComponent
// 0x0100 (0x01A8 - 0x00A8)
class UInteractionDetectorComponent final : public UActorComponent
{
public:
	class UPrimitiveComponent*                    _detectionPrimitive;                               // 0x00A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSet<class AInteractable*>                    _overlappingInteractables;                         // 0x00B0(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TSet<class UPrimitiveComponent*>              _overlappingPrimitiveComponents;                   // 0x0100(0x0050)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TSet<class AActor*>                           _ignoredActors;                                    // 0x0150(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_1A0[0x8];                                      // 0x01A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddIgnoredActor(class AActor* Ignored);
	void BeginOverlapCallback(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool FromSweep, const struct FHitResult& SweepResult);
	void EndOverlapCallback(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void OnLocallyObservedChanged(class ADBDPlayer* Player);
	void SetDetectionPrimitive(class UPrimitiveComponent* DetectionPrimitive);

	class UPrimitiveComponent* GetDetectionPrimitive() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionDetectorComponent">();
	}
	static class UInteractionDetectorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionDetectorComponent>();
	}
};
static_assert(alignof(UInteractionDetectorComponent) == 0x000008, "Wrong alignment on UInteractionDetectorComponent");
static_assert(sizeof(UInteractionDetectorComponent) == 0x0001A8, "Wrong size on UInteractionDetectorComponent");
static_assert(offsetof(UInteractionDetectorComponent, _detectionPrimitive) == 0x0000A8, "Member 'UInteractionDetectorComponent::_detectionPrimitive' has a wrong offset!");
static_assert(offsetof(UInteractionDetectorComponent, _overlappingInteractables) == 0x0000B0, "Member 'UInteractionDetectorComponent::_overlappingInteractables' has a wrong offset!");
static_assert(offsetof(UInteractionDetectorComponent, _overlappingPrimitiveComponents) == 0x000100, "Member 'UInteractionDetectorComponent::_overlappingPrimitiveComponents' has a wrong offset!");
static_assert(offsetof(UInteractionDetectorComponent, _ignoredActors) == 0x000150, "Member 'UInteractionDetectorComponent::_ignoredActors' has a wrong offset!");

// Class DeadByDaylight.Interactor
// 0x0070 (0x0330 - 0x02C0)
class UInteractor final : public USceneComponent
{
public:
	class FString                                 InteractorName;                                    // 0x02C0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D0[0x30];                                     // 0x02D0(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          IsUsable;                                          // 0x0300(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_301[0x3];                                      // 0x0301(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FObjectLock                            _lock;                                             // 0x0304(0x0008)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
	struct FObjectLock                            _reservation;                                      // 0x030C(0x0008)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_314[0x4];                                      // 0x0314(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UInteractionDefinition*                 _currentInteraction;                               // 0x0318(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UInteractionDefinition*>         _interactionDefinitions;                           // 0x0320(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	void BPPostInitializeComponents();
	void Multicast_LockStatus(class ADBDPlayer* Player, class UInteractionDefinition* CurrentInteraction, bool Lock);
	void Multicast_ReservationStatus(class ADBDPlayer* Player, bool Lock);
	void SetIsUsable(bool IsUsableParam);

	class ADBDPlayer* Authority_GetInteractingPlayer() const;
	bool CanPerformInteraction(const class ADBDPlayer* Player, const class UInteractionDefinition* Definition) const;
	class UInteractionDefinition* GetCurrentInteraction() const;
	class AInteractable* GetInteractable() const;
	class ADBDPlayer* GetInteractingPlayerRaw() const;
	const TArray<class UInteractionDefinition*> GetInteractionDefinitions() const;
	bool GetIsUsable() const;
	bool IsInteracting() const;
	bool IsInterruptionPossible(const class ADBDPlayer* Interruptor, const class ADBDPlayer* Interruptee, const class UInteractionDefinition* Definition, const class UInterruptionDefinition* Interruption) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Interactor">();
	}
	static class UInteractor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractor>();
	}
};
static_assert(alignof(UInteractor) == 0x000010, "Wrong alignment on UInteractor");
static_assert(sizeof(UInteractor) == 0x000330, "Wrong size on UInteractor");
static_assert(offsetof(UInteractor, InteractorName) == 0x0002C0, "Member 'UInteractor::InteractorName' has a wrong offset!");
static_assert(offsetof(UInteractor, IsUsable) == 0x000300, "Member 'UInteractor::IsUsable' has a wrong offset!");
static_assert(offsetof(UInteractor, _lock) == 0x000304, "Member 'UInteractor::_lock' has a wrong offset!");
static_assert(offsetof(UInteractor, _reservation) == 0x00030C, "Member 'UInteractor::_reservation' has a wrong offset!");
static_assert(offsetof(UInteractor, _currentInteraction) == 0x000318, "Member 'UInteractor::_currentInteraction' has a wrong offset!");
static_assert(offsetof(UInteractor, _interactionDefinitions) == 0x000320, "Member 'UInteractor::_interactionDefinitions' has a wrong offset!");

// Class DeadByDaylight.InterruptionDefinition
// 0x00F0 (0x03B0 - 0x02C0)
class UInterruptionDefinition : public USceneComponent
{
public:
	class FName                                   InterruptionID;                                    // 0x02C0(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _usesWorldCoordinates;                             // 0x02CC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _snapInterruptor;                                  // 0x02CD(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2CE[0x2];                                      // 0x02CE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             _interruptionSnapPointForInterruptor;              // 0x02D0(0x0060)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FAnimationMontageDescriptor            _animationMontageToPlayOnInterruptionEnterForInterruptor; // 0x0330(0x0020)(Edit, NativeAccessSpecifierPrivate)
	struct FAnimationMontageDescriptor            _animationMontageToPlayOnInterruptionForInterruptorNew; // 0x0350(0x0020)(Edit, NativeAccessSpecifierPrivate)
	struct FAnimationMontageDescriptor            _animationMontageToPlayOnInterruptionForInterrupteeNew; // 0x0370(0x0020)(Edit, NativeAccessSpecifierPrivate)
	bool                                          _pickUpOnInterrupt;                                // 0x0390(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _canInterruptWhileCarrying;                        // 0x0391(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _useMontageFollower;                               // 0x0392(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_393[0x1];                                      // 0x0393(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _maxHeightDeltaBetweenCharacters;                  // 0x0394(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTag                           _interruptionScoreEvent;                           // 0x0398(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3A4[0xC];                                      // 0x03A4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnInterruptionEnterStart(class ADBDPlayer* Interruptor, class ADBDPlayer* Interruptee);
	void OnInterruptionExitEnd(class ADBDPlayer* Interruptor, class ADBDPlayer* Interruptee);
	void OnInterruptionUpdateStart(class ADBDPlayer* Interruptor, class ADBDPlayer* Interruptee);
	void SetInterruptorSnapPoint(const struct FTransform& Point);

	bool CanInterruptWhileCarrying() const;
	class AInteractable* GetInteractable() const;
	class UInteractionDefinition* GetInteractionDefinition() const;
	struct FVector GetInterruptionSnapPointPositionForInterruptor(const class ADBDPlayer* Interruptor, const class ADBDPlayer* Interruptee) const;
	struct FRotator GetInterruptionSnapPointRotationForInterruptor(const class ADBDPlayer* Interruptor, const class ADBDPlayer* Interruptee) const;
	bool InteractionCheckHeightDelta(const class ADBDPlayer* Interruptor, const class ADBDPlayer* Interruptee) const;
	bool IsInterruptionPossible(const class ADBDPlayer* Interruptor, const class ADBDPlayer* Interruptee) const;
	bool IsUsingAttack() const;
	bool IsUsingMontageFollower() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterruptionDefinition">();
	}
	static class UInterruptionDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterruptionDefinition>();
	}
};
static_assert(alignof(UInterruptionDefinition) == 0x000010, "Wrong alignment on UInterruptionDefinition");
static_assert(sizeof(UInterruptionDefinition) == 0x0003B0, "Wrong size on UInterruptionDefinition");
static_assert(offsetof(UInterruptionDefinition, InterruptionID) == 0x0002C0, "Member 'UInterruptionDefinition::InterruptionID' has a wrong offset!");
static_assert(offsetof(UInterruptionDefinition, _usesWorldCoordinates) == 0x0002CC, "Member 'UInterruptionDefinition::_usesWorldCoordinates' has a wrong offset!");
static_assert(offsetof(UInterruptionDefinition, _snapInterruptor) == 0x0002CD, "Member 'UInterruptionDefinition::_snapInterruptor' has a wrong offset!");
static_assert(offsetof(UInterruptionDefinition, _interruptionSnapPointForInterruptor) == 0x0002D0, "Member 'UInterruptionDefinition::_interruptionSnapPointForInterruptor' has a wrong offset!");
static_assert(offsetof(UInterruptionDefinition, _animationMontageToPlayOnInterruptionEnterForInterruptor) == 0x000330, "Member 'UInterruptionDefinition::_animationMontageToPlayOnInterruptionEnterForInterruptor' has a wrong offset!");
static_assert(offsetof(UInterruptionDefinition, _animationMontageToPlayOnInterruptionForInterruptorNew) == 0x000350, "Member 'UInterruptionDefinition::_animationMontageToPlayOnInterruptionForInterruptorNew' has a wrong offset!");
static_assert(offsetof(UInterruptionDefinition, _animationMontageToPlayOnInterruptionForInterrupteeNew) == 0x000370, "Member 'UInterruptionDefinition::_animationMontageToPlayOnInterruptionForInterrupteeNew' has a wrong offset!");
static_assert(offsetof(UInterruptionDefinition, _pickUpOnInterrupt) == 0x000390, "Member 'UInterruptionDefinition::_pickUpOnInterrupt' has a wrong offset!");
static_assert(offsetof(UInterruptionDefinition, _canInterruptWhileCarrying) == 0x000391, "Member 'UInterruptionDefinition::_canInterruptWhileCarrying' has a wrong offset!");
static_assert(offsetof(UInterruptionDefinition, _useMontageFollower) == 0x000392, "Member 'UInterruptionDefinition::_useMontageFollower' has a wrong offset!");
static_assert(offsetof(UInterruptionDefinition, _maxHeightDeltaBetweenCharacters) == 0x000394, "Member 'UInterruptionDefinition::_maxHeightDeltaBetweenCharacters' has a wrong offset!");
static_assert(offsetof(UInterruptionDefinition, _interruptionScoreEvent) == 0x000398, "Member 'UInterruptionDefinition::_interruptionScoreEvent' has a wrong offset!");

// Class DeadByDaylight.InventoryHandler
// 0x0060 (0x0098 - 0x0038)
class UInventoryHandler final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x60];                                      // 0x0038(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InventoryHandler">();
	}
	static class UInventoryHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInventoryHandler>();
	}
};
static_assert(alignof(UInventoryHandler) == 0x000008, "Wrong alignment on UInventoryHandler");
static_assert(sizeof(UInventoryHandler) == 0x000098, "Wrong size on UInventoryHandler");

// Class DeadByDaylight.PresentablePower
// 0x0000 (0x0030 - 0x0030)
class IPresentablePower final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PresentablePower">();
	}
	static class IPresentablePower* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPresentablePower>();
	}
};
static_assert(alignof(IPresentablePower) == 0x000008, "Wrong alignment on IPresentablePower");
static_assert(sizeof(IPresentablePower) == 0x000030, "Wrong size on IPresentablePower");

// Class DeadByDaylight.IsMaximumInfected
// 0x0000 (0x00C0 - 0x00C0)
class UIsMaximumInfected final : public UGameplayModifierCondition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IsMaximumInfected">();
	}
	static class UIsMaximumInfected* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIsMaximumInfected>();
	}
};
static_assert(alignof(UIsMaximumInfected) == 0x000008, "Wrong alignment on UIsMaximumInfected");
static_assert(sizeof(UIsMaximumInfected) == 0x0000C0, "Wrong size on UIsMaximumInfected");

// Class DeadByDaylight.SpectatingActorLinker
// 0x0000 (0x0030 - 0x0030)
class ISpectatingActorLinker final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpectatingActorLinker">();
	}
	static class ISpectatingActorLinker* GetDefaultObj()
	{
		return GetDefaultObjImpl<ISpectatingActorLinker>();
	}
};
static_assert(alignof(ISpectatingActorLinker) == 0x000008, "Wrong alignment on ISpectatingActorLinker");
static_assert(sizeof(ISpectatingActorLinker) == 0x000030, "Wrong size on ISpectatingActorLinker");

// Class DeadByDaylight.StruggleSkillCheck
// 0x0000 (0x0030 - 0x0030)
class IStruggleSkillCheck final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StruggleSkillCheck">();
	}
	static class IStruggleSkillCheck* GetDefaultObj()
	{
		return GetDefaultObjImpl<IStruggleSkillCheck>();
	}
};
static_assert(alignof(IStruggleSkillCheck) == 0x000008, "Wrong alignment on IStruggleSkillCheck");
static_assert(sizeof(IStruggleSkillCheck) == 0x000030, "Wrong size on IStruggleSkillCheck");

// Class DeadByDaylight.ShopCameraManager
// 0x0028 (0x02C8 - 0x02A0)
class AShopCameraManager final : public AActor
{
public:
	struct FNamedButton                           ReloadDBBtn;                                       // 0x02A0(0x0018)(Edit, NativeAccessSpecifierPrivate)
	TArray<struct FRoleGenderCharacterRotation>   CharacterRotation;                                 // 0x02B8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShopCameraManager">();
	}
	static class AShopCameraManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AShopCameraManager>();
	}
};
static_assert(alignof(AShopCameraManager) == 0x000008, "Wrong alignment on AShopCameraManager");
static_assert(sizeof(AShopCameraManager) == 0x0002C8, "Wrong size on AShopCameraManager");
static_assert(offsetof(AShopCameraManager, ReloadDBBtn) == 0x0002A0, "Member 'AShopCameraManager::ReloadDBBtn' has a wrong offset!");
static_assert(offsetof(AShopCameraManager, CharacterRotation) == 0x0002B8, "Member 'AShopCameraManager::CharacterRotation' has a wrong offset!");

// Class DeadByDaylight.TeleportInteractable
// 0x0000 (0x0030 - 0x0030)
class ITeleportInteractable final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TeleportInteractable">();
	}
	static class ITeleportInteractable* GetDefaultObj()
	{
		return GetDefaultObjImpl<ITeleportInteractable>();
	}
};
static_assert(alignof(ITeleportInteractable) == 0x000008, "Wrong alignment on ITeleportInteractable");
static_assert(sizeof(ITeleportInteractable) == 0x000030, "Wrong size on ITeleportInteractable");

// Class DeadByDaylight.ItemAddonDataAsset
// 0x0000 (0x0090 - 0x0090)
class UItemAddonDataAsset final : public UGameplayModifierContainerDataAsset
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemAddonDataAsset">();
	}
	static class UItemAddonDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemAddonDataAsset>();
	}
};
static_assert(alignof(UItemAddonDataAsset) == 0x000008, "Wrong alignment on UItemAddonDataAsset");
static_assert(sizeof(UItemAddonDataAsset) == 0x000090, "Wrong size on UItemAddonDataAsset");

// Class DeadByDaylight.ItemPerformedInteraction
// 0x0000 (0x0030 - 0x0030)
class IItemPerformedInteraction final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemPerformedInteraction">();
	}
	static class IItemPerformedInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<IItemPerformedInteraction>();
	}
};
static_assert(alignof(IItemPerformedInteraction) == 0x000008, "Wrong alignment on IItemPerformedInteraction");
static_assert(sizeof(IItemPerformedInteraction) == 0x000030, "Wrong size on IItemPerformedInteraction");

// Class DeadByDaylight.SurvivorSpecialEventStatusIndicatorComponent
// 0x0058 (0x0100 - 0x00A8)
class USurvivorSpecialEventStatusIndicatorComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x18];                                      // 0x00A8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class ULocalPlayerTrackerComponent*           _localPlayerTracker;                               // 0x00C0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTag                           _specialEventStatusStateTag;                       // 0x00C8(0x000C)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D4[0x2C];                                      // 0x00D4(0x002C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_OnStatusIndicatorShown();
	void OnStatusChanged();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SurvivorSpecialEventStatusIndicatorComponent">();
	}
	static class USurvivorSpecialEventStatusIndicatorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USurvivorSpecialEventStatusIndicatorComponent>();
	}
};
static_assert(alignof(USurvivorSpecialEventStatusIndicatorComponent) == 0x000008, "Wrong alignment on USurvivorSpecialEventStatusIndicatorComponent");
static_assert(sizeof(USurvivorSpecialEventStatusIndicatorComponent) == 0x000100, "Wrong size on USurvivorSpecialEventStatusIndicatorComponent");
static_assert(offsetof(USurvivorSpecialEventStatusIndicatorComponent, _localPlayerTracker) == 0x0000C0, "Member 'USurvivorSpecialEventStatusIndicatorComponent::_localPlayerTracker' has a wrong offset!");
static_assert(offsetof(USurvivorSpecialEventStatusIndicatorComponent, _specialEventStatusStateTag) == 0x0000C8, "Member 'USurvivorSpecialEventStatusIndicatorComponent::_specialEventStatusStateTag' has a wrong offset!");

// Class DeadByDaylight.ItemPickupAdditionalDataInterface
// 0x0000 (0x0030 - 0x0030)
class IItemPickupAdditionalDataInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemPickupAdditionalDataInterface">();
	}
	static class IItemPickupAdditionalDataInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IItemPickupAdditionalDataInterface>();
	}
};
static_assert(alignof(IItemPickupAdditionalDataInterface) == 0x000008, "Wrong alignment on IItemPickupAdditionalDataInterface");
static_assert(sizeof(IItemPickupAdditionalDataInterface) == 0x000030, "Wrong size on IItemPickupAdditionalDataInterface");

// Class DeadByDaylight.ItemVfx
// 0x0010 (0x02B8 - 0x02A8)
class AItemVfx final : public ABaseVFX
{
public:
	TArray<class UFXSystemComponent*>             _particleSystems;                                  // 0x02A8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	void AddNiagaraComponent(class UNiagaraComponent* NiagaraComponent);
	void AddParticleSystemComponent(class UParticleSystemComponent* ParticleSystemComponent);
	void AttachToSkeletalMesh(class USkeletalMeshComponent* SkeletonPart);
	void ClearParticleSystems();
	void OnAttackBegin();
	void OnAttackEnd();
	class UNiagaraComponent* SpawnNiagaraSystemAttached(class UNiagaraSystem* SystemTemplate, class USceneComponent* AttachToComponent, class FName AttachPointName, EAttachLocation LocationType, bool AutoDestroy, ENCPoolMethod PoolingMethod, const struct FVector& Location, const struct FRotator& Rotation, const struct FVector& Scale, bool AutoActivate, bool PreCullCheck, bool AbsoluteRotation, bool HideInFPV);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemVfx">();
	}
	static class AItemVfx* GetDefaultObj()
	{
		return GetDefaultObjImpl<AItemVfx>();
	}
};
static_assert(alignof(AItemVfx) == 0x000008, "Wrong alignment on AItemVfx");
static_assert(sizeof(AItemVfx) == 0x0002B8, "Wrong size on AItemVfx");
static_assert(offsetof(AItemVfx, _particleSystems) == 0x0002A8, "Member 'AItemVfx::_particleSystems' has a wrong offset!");

// Class DeadByDaylight.ViewRotationStrategy
// 0x0000 (0x0030 - 0x0030)
class IViewRotationStrategy final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ViewRotationStrategy">();
	}
	static class IViewRotationStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<IViewRotationStrategy>();
	}
};
static_assert(alignof(IViewRotationStrategy) == 0x000008, "Wrong alignment on IViewRotationStrategy");
static_assert(sizeof(IViewRotationStrategy) == 0x000030, "Wrong size on IViewRotationStrategy");

// Class DeadByDaylight.K31UIDataInterface
// 0x0000 (0x0030 - 0x0030)
class IK31UIDataInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K31UIDataInterface">();
	}
	static class IK31UIDataInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IK31UIDataInterface>();
	}
};
static_assert(alignof(IK31UIDataInterface) == 0x000008, "Wrong alignment on IK31UIDataInterface");
static_assert(sizeof(IK31UIDataInterface) == 0x000030, "Wrong size on IK31UIDataInterface");

// Class DeadByDaylight.KillerAudioHandlerComponent
// 0x0080 (0x01C8 - 0x0148)
class UKillerAudioHandlerComponent : public UDBDPlayerAudioHandlerComponent
{
public:
	struct FDBDTunableRowHandle                   _killerMovingShockTime;                            // 0x0148(0x0028)(Edit, NativeAccessSpecifierPrivate)
	class FString                                 _shockEvent;                                       // 0x0170(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTagQuery                      _movingShockCondition;                             // 0x0180(0x0048)(Edit, NativeAccessSpecifierPrivate)

public:
	void ChaseTriggerKillerReactionSpecificSurvivorSFX(class ADBDPlayer* Camper);
	void HitImpactOnSurvivorSFX(class ACamperPlayer* Camper, EAttackType AttackType, bool IsWeaponHit);
	void OnChaseStart(class ADBDPlayer* ChasedSurvivor);
	void TriggerKillerReactionSpecificSurvivorSFX(class ADBDPlayer* Camper);
	void TriggerSurvivorDamageHitAudioSFX(class ACamperPlayer* Camper, EAttackType AttackType, bool CausedKO, bool IsWeaponHit, bool IsLightHit);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerAudioHandlerComponent">();
	}
	static class UKillerAudioHandlerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillerAudioHandlerComponent>();
	}
};
static_assert(alignof(UKillerAudioHandlerComponent) == 0x000008, "Wrong alignment on UKillerAudioHandlerComponent");
static_assert(sizeof(UKillerAudioHandlerComponent) == 0x0001C8, "Wrong size on UKillerAudioHandlerComponent");
static_assert(offsetof(UKillerAudioHandlerComponent, _killerMovingShockTime) == 0x000148, "Member 'UKillerAudioHandlerComponent::_killerMovingShockTime' has a wrong offset!");
static_assert(offsetof(UKillerAudioHandlerComponent, _shockEvent) == 0x000170, "Member 'UKillerAudioHandlerComponent::_shockEvent' has a wrong offset!");
static_assert(offsetof(UKillerAudioHandlerComponent, _movingShockCondition) == 0x000180, "Member 'UKillerAudioHandlerComponent::_movingShockCondition' has a wrong offset!");

// Class DeadByDaylight.KillerBloodFXComponent
// 0x0018 (0x00C0 - 0x00A8)
class UKillerBloodFXComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x18];                                      // 0x00A8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void PlayBloodSplatter();
	void StopBloodSplatter();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerBloodFXComponent">();
	}
	static class UKillerBloodFXComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillerBloodFXComponent>();
	}
};
static_assert(alignof(UKillerBloodFXComponent) == 0x000008, "Wrong alignment on UKillerBloodFXComponent");
static_assert(sizeof(UKillerBloodFXComponent) == 0x0000C0, "Wrong size on UKillerBloodFXComponent");

// Class DeadByDaylight.KillerBloodFXInterface
// 0x0000 (0x0030 - 0x0030)
class IKillerBloodFXInterface final : public IInterface
{
public:
	void PlayBloodSplatter();
	void StopBloodSplatter();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerBloodFXInterface">();
	}
	static class IKillerBloodFXInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IKillerBloodFXInterface>();
	}
};
static_assert(alignof(IKillerBloodFXInterface) == 0x000008, "Wrong alignment on IKillerBloodFXInterface");
static_assert(sizeof(IKillerBloodFXInterface) == 0x000030, "Wrong size on IKillerBloodFXInterface");

// Class DeadByDaylight.KillerDependentObjectInterface
// 0x0000 (0x0030 - 0x0030)
class IKillerDependentObjectInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerDependentObjectInterface">();
	}
	static class IKillerDependentObjectInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IKillerDependentObjectInterface>();
	}
};
static_assert(alignof(IKillerDependentObjectInterface) == 0x000008, "Wrong alignment on IKillerDependentObjectInterface");
static_assert(sizeof(IKillerDependentObjectInterface) == 0x000030, "Wrong size on IKillerDependentObjectInterface");

// Class DeadByDaylight.KillerHitCosmeticHandler
// 0x0018 (0x0048 - 0x0030)
class UKillerHitCosmeticHandler final : public UBaseReversibleInstantActionHandler
{
public:
	uint8                                         Pad_30[0x18];                                      // 0x0030(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerHitCosmeticHandler">();
	}
	static class UKillerHitCosmeticHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillerHitCosmeticHandler>();
	}
};
static_assert(alignof(UKillerHitCosmeticHandler) == 0x000008, "Wrong alignment on UKillerHitCosmeticHandler");
static_assert(sizeof(UKillerHitCosmeticHandler) == 0x000048, "Wrong size on UKillerHitCosmeticHandler");

// Class DeadByDaylight.KillerInstinctInterface
// 0x0000 (0x0030 - 0x0030)
class IKillerInstinctInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerInstinctInterface">();
	}
	static class IKillerInstinctInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IKillerInstinctInterface>();
	}
};
static_assert(alignof(IKillerInstinctInterface) == 0x000008, "Wrong alignment on IKillerInstinctInterface");
static_assert(sizeof(IKillerInstinctInterface) == 0x000030, "Wrong size on IKillerInstinctInterface");

// Class DeadByDaylight.KillerIntroComponent
// 0x0030 (0x00D8 - 0x00A8)
class UKillerIntroComponent final : public UActorComponent
{
public:
	float                                         _percentOfCameraPanInProgressRequiredToHideKiller; // 0x00A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _cameraPanInAmountToSquish;                        // 0x00AC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EFPVTransitionStrategy                        _cameraPanInHidingStrategy;                        // 0x00B0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B1[0x3];                                       // 0x00B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _startKillerIntroDelay;                            // 0x00B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B8[0x20];                                      // 0x00B8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void KillerCameraPanInUpdateNative(const float KillerIntroCompletedPercent);
	void OnIntroCompleted();
	void OnLevelReadyToPlay();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerIntroComponent">();
	}
	static class UKillerIntroComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillerIntroComponent>();
	}
};
static_assert(alignof(UKillerIntroComponent) == 0x000008, "Wrong alignment on UKillerIntroComponent");
static_assert(sizeof(UKillerIntroComponent) == 0x0000D8, "Wrong size on UKillerIntroComponent");
static_assert(offsetof(UKillerIntroComponent, _percentOfCameraPanInProgressRequiredToHideKiller) == 0x0000A8, "Member 'UKillerIntroComponent::_percentOfCameraPanInProgressRequiredToHideKiller' has a wrong offset!");
static_assert(offsetof(UKillerIntroComponent, _cameraPanInAmountToSquish) == 0x0000AC, "Member 'UKillerIntroComponent::_cameraPanInAmountToSquish' has a wrong offset!");
static_assert(offsetof(UKillerIntroComponent, _cameraPanInHidingStrategy) == 0x0000B0, "Member 'UKillerIntroComponent::_cameraPanInHidingStrategy' has a wrong offset!");
static_assert(offsetof(UKillerIntroComponent, _startKillerIntroDelay) == 0x0000B4, "Member 'UKillerIntroComponent::_startKillerIntroDelay' has a wrong offset!");

// Class DeadByDaylight.KillerOpenGate
// 0x0050 (0x0910 - 0x08C0)
class UKillerOpenGate : public UChargeableInteractionDefinition
{
public:
	struct FAnimationMontageDescriptor            _openGateMontage;                                  // 0x08C0(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_8E0[0x30];                                     // 0x08E0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void UpdateSwitch() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerOpenGate">();
	}
	static class UKillerOpenGate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillerOpenGate>();
	}
};
static_assert(alignof(UKillerOpenGate) == 0x000010, "Wrong alignment on UKillerOpenGate");
static_assert(sizeof(UKillerOpenGate) == 0x000910, "Wrong size on UKillerOpenGate");
static_assert(offsetof(UKillerOpenGate, _openGateMontage) == 0x0008C0, "Member 'UKillerOpenGate::_openGateMontage' has a wrong offset!");

// Class DeadByDaylight.TokenCounter
// 0x0028 (0x0058 - 0x0030)
class UTokenCounter final : public UObject
{
public:
	uint8                                         Pad_30[0x18];                                      // 0x0030(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _tokenCount;                                       // 0x0048(0x0004)(BlueprintVisible, Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         _maxTokenCount;                                    // 0x004C(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_DecrementToken();
	void Authority_IncrementToken();
	void Authority_SetMaxTokenCount(int32 Value);
	void Authority_SetTokenCount(int32 Value);
	void OnRep_TokenCount(int32 OldCount);

	int32 GetMaxTokenCount() const;
	int32 GetTokenCount() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TokenCounter">();
	}
	static class UTokenCounter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTokenCounter>();
	}
};
static_assert(alignof(UTokenCounter) == 0x000008, "Wrong alignment on UTokenCounter");
static_assert(sizeof(UTokenCounter) == 0x000058, "Wrong size on UTokenCounter");
static_assert(offsetof(UTokenCounter, _tokenCount) == 0x000048, "Member 'UTokenCounter::_tokenCount' has a wrong offset!");
static_assert(offsetof(UTokenCounter, _maxTokenCount) == 0x00004C, "Member 'UTokenCounter::_maxTokenCount' has a wrong offset!");

// Class DeadByDaylight.KillerProjectileDodgeComponent
// 0x0030 (0x00D8 - 0x00A8)
class UKillerProjectileDodgeComponent final : public UActorComponent
{
public:
	class AKillerProjectile*                      _killerProjectile;                                 // 0x00A8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class ACamperPlayer*>                  _proximitySurvivors;                               // 0x00B0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C0[0x18];                                      // 0x00C0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnKillerProjectileFinished(class AActor* SurvivorHit);
	void OnKillerProjectileFinishedWithoutCollision();
	void OnKillerProjectileLaunched();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerProjectileDodgeComponent">();
	}
	static class UKillerProjectileDodgeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillerProjectileDodgeComponent>();
	}
};
static_assert(alignof(UKillerProjectileDodgeComponent) == 0x000008, "Wrong alignment on UKillerProjectileDodgeComponent");
static_assert(sizeof(UKillerProjectileDodgeComponent) == 0x0000D8, "Wrong size on UKillerProjectileDodgeComponent");
static_assert(offsetof(UKillerProjectileDodgeComponent, _killerProjectile) == 0x0000A8, "Member 'UKillerProjectileDodgeComponent::_killerProjectile' has a wrong offset!");
static_assert(offsetof(UKillerProjectileDodgeComponent, _proximitySurvivors) == 0x0000B0, "Member 'UKillerProjectileDodgeComponent::_proximitySurvivors' has a wrong offset!");

// Class DeadByDaylight.KillerSoundCuesComponent
// 0x0010 (0x00B8 - 0x00A8)
class UKillerSoundCuesComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x10];                                      // 0x00A8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void StartTrackingActor(class AActor* ActorToStartTracking, class FName DistanceDataID);
	void StartTrackingActorWithLifetime(class AActor* ActorToStartTracking, class FName DistanceDataID, float TrackerLifetime);
	void StopTrackingActor(class AActor* ActorToStopTracking);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerSoundCuesComponent">();
	}
	static class UKillerSoundCuesComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillerSoundCuesComponent>();
	}
};
static_assert(alignof(UKillerSoundCuesComponent) == 0x000008, "Wrong alignment on UKillerSoundCuesComponent");
static_assert(sizeof(UKillerSoundCuesComponent) == 0x0000B8, "Wrong size on UKillerSoundCuesComponent");

// Class DeadByDaylight.LacerationUIData
// 0x0000 (0x0030 - 0x0030)
class ILacerationUIData final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LacerationUIData">();
	}
	static class ILacerationUIData* GetDefaultObj()
	{
		return GetDefaultObjImpl<ILacerationUIData>();
	}
};
static_assert(alignof(ILacerationUIData) == 0x000008, "Wrong alignment on ILacerationUIData");
static_assert(sizeof(ILacerationUIData) == 0x000030, "Wrong size on ILacerationUIData");

// Class DeadByDaylight.LanternInteractable
// 0x0050 (0x03F8 - 0x03A8)
class ALanternInteractable final : public AInteractable
{
public:
	FMulticastInlineDelegateProperty_             OnLanternStateChanged;                             // 0x03A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnLanternCollectedByPlayerCosmetic;                // 0x03B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C8[0x18];                                     // 0x03C8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ALanternLightCollectable>   _collectableClass;                                 // 0x03E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3E8[0x10];                                     // 0x03E8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ChangeLanternState(ELanternState NewLanternState);
	void CollectLight(class ADBDPlayer* Player);
	void OnBackToCollectableTimerEnd();
	void OnCamperLeavingHook(const struct FGameplayTag& GameEventType, const struct FGameEventData& GameEventData);
	void OnCamperWasHooked(const struct FGameplayTag& GameEventType, const struct FGameEventData& GameEventData);
	void OnSlasherDestroyedLantern(const struct FGameplayTag& GameEventType, const struct FGameEventData& GameEventData);
	void SlasherDestroyLantern(class ADBDPlayer* Player);

	bool CanBeCollected() const;
	bool CanBeDestroyed() const;
	ELanternState GetLanternState() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LanternInteractable">();
	}
	static class ALanternInteractable* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALanternInteractable>();
	}
};
static_assert(alignof(ALanternInteractable) == 0x000008, "Wrong alignment on ALanternInteractable");
static_assert(sizeof(ALanternInteractable) == 0x0003F8, "Wrong size on ALanternInteractable");
static_assert(offsetof(ALanternInteractable, OnLanternStateChanged) == 0x0003A8, "Member 'ALanternInteractable::OnLanternStateChanged' has a wrong offset!");
static_assert(offsetof(ALanternInteractable, OnLanternCollectedByPlayerCosmetic) == 0x0003B8, "Member 'ALanternInteractable::OnLanternCollectedByPlayerCosmetic' has a wrong offset!");
static_assert(offsetof(ALanternInteractable, _collectableClass) == 0x0003E0, "Member 'ALanternInteractable::_collectableClass' has a wrong offset!");

// Class DeadByDaylight.LegalMenuScreen
// 0x0048 (0x0170 - 0x0128)
class ULegalMenuScreen final : public UScreenBase
{
public:
	uint8                                         Pad_128[0x48];                                     // 0x0128(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAcceptClick();
	void OnDeclineClick();
	void OnOkClick();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LegalMenuScreen">();
	}
	static class ULegalMenuScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULegalMenuScreen>();
	}
};
static_assert(alignof(ULegalMenuScreen) == 0x000008, "Wrong alignment on ULegalMenuScreen");
static_assert(sizeof(ULegalMenuScreen) == 0x000170, "Wrong size on ULegalMenuScreen");

// Class DeadByDaylight.LevelAISetupComponent
// 0x0000 (0x00A8 - 0x00A8)
class ULevelAISetupComponent final : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelAISetupComponent">();
	}
	static class ULevelAISetupComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULevelAISetupComponent>();
	}
};
static_assert(alignof(ULevelAISetupComponent) == 0x000008, "Wrong alignment on ULevelAISetupComponent");
static_assert(sizeof(ULevelAISetupComponent) == 0x0000A8, "Wrong size on ULevelAISetupComponent");

// Class DeadByDaylight.WorldRunawayMeshComponent
// 0x0030 (0x1160 - 0x1130)
class UWorldRunawayMeshComponent : public UDBDSkeletalMeshComponentBudgeted
{
public:
	float                                         ResetCooldown;                                     // 0x1130(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _runAwayMustTickDuration;                          // 0x1134(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _returnMustTickDuration;                           // 0x1138(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_113C[0x24];                                    // 0x113C(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetShouldRunAway(bool Should);
	void SetShouldRunAwayWithDelay(bool Should, float Delay);
	void SetShouldRunAwayWithRandomDelay(bool Should, float DelayRange);

	bool GetShouldRunAway() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WorldRunawayMeshComponent">();
	}
	static class UWorldRunawayMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWorldRunawayMeshComponent>();
	}
};
static_assert(alignof(UWorldRunawayMeshComponent) == 0x000010, "Wrong alignment on UWorldRunawayMeshComponent");
static_assert(sizeof(UWorldRunawayMeshComponent) == 0x001160, "Wrong size on UWorldRunawayMeshComponent");
static_assert(offsetof(UWorldRunawayMeshComponent, ResetCooldown) == 0x001130, "Member 'UWorldRunawayMeshComponent::ResetCooldown' has a wrong offset!");
static_assert(offsetof(UWorldRunawayMeshComponent, _runAwayMustTickDuration) == 0x001134, "Member 'UWorldRunawayMeshComponent::_runAwayMustTickDuration' has a wrong offset!");
static_assert(offsetof(UWorldRunawayMeshComponent, _returnMustTickDuration) == 0x001138, "Member 'UWorldRunawayMeshComponent::_returnMustTickDuration' has a wrong offset!");

// Class DeadByDaylight.LevelCrowWRMeshComponent
// 0x0000 (0x1160 - 0x1160)
class ULevelCrowWRMeshComponent : public UWorldRunawayMeshComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelCrowWRMeshComponent">();
	}
	static class ULevelCrowWRMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULevelCrowWRMeshComponent>();
	}
};
static_assert(alignof(ULevelCrowWRMeshComponent) == 0x000010, "Wrong alignment on ULevelCrowWRMeshComponent");
static_assert(sizeof(ULevelCrowWRMeshComponent) == 0x001160, "Wrong size on ULevelCrowWRMeshComponent");

// Class DeadByDaylight.LevelParadise
// 0x0090 (0x0330 - 0x02A0)
class ALevelParadise : public AActor
{
public:
	float                                         LoopStartDistance;                                 // 0x02A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LoopDistance;                                      // 0x02A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        MainPlayerSpawnPoint;                              // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class USceneComponent*>                OtherSurvivorSpawnPoints;                          // 0x02B0(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class USceneComponent*>                ParadiseTiles;                                     // 0x02C0(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class AActor*                                 ParadiseViewTarget;                                // 0x02D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D8[0x40];                                     // 0x02D8(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	class ADBDPlayer*                             _spawnedMainPawn;                                  // 0x0318(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USceneComponent*                        _runnerComponent;                                  // 0x0320(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _fadeOutDuration;                                  // 0x0328(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _fadeInDuration;                                   // 0x032C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnInterpolationDone();
	void ParadiseEntered(const struct FParadiseData& PlayerData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelParadise">();
	}
	static class ALevelParadise* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALevelParadise>();
	}
};
static_assert(alignof(ALevelParadise) == 0x000008, "Wrong alignment on ALevelParadise");
static_assert(sizeof(ALevelParadise) == 0x000330, "Wrong size on ALevelParadise");
static_assert(offsetof(ALevelParadise, LoopStartDistance) == 0x0002A0, "Member 'ALevelParadise::LoopStartDistance' has a wrong offset!");
static_assert(offsetof(ALevelParadise, LoopDistance) == 0x0002A4, "Member 'ALevelParadise::LoopDistance' has a wrong offset!");
static_assert(offsetof(ALevelParadise, MainPlayerSpawnPoint) == 0x0002A8, "Member 'ALevelParadise::MainPlayerSpawnPoint' has a wrong offset!");
static_assert(offsetof(ALevelParadise, OtherSurvivorSpawnPoints) == 0x0002B0, "Member 'ALevelParadise::OtherSurvivorSpawnPoints' has a wrong offset!");
static_assert(offsetof(ALevelParadise, ParadiseTiles) == 0x0002C0, "Member 'ALevelParadise::ParadiseTiles' has a wrong offset!");
static_assert(offsetof(ALevelParadise, ParadiseViewTarget) == 0x0002D0, "Member 'ALevelParadise::ParadiseViewTarget' has a wrong offset!");
static_assert(offsetof(ALevelParadise, _spawnedMainPawn) == 0x000318, "Member 'ALevelParadise::_spawnedMainPawn' has a wrong offset!");
static_assert(offsetof(ALevelParadise, _runnerComponent) == 0x000320, "Member 'ALevelParadise::_runnerComponent' has a wrong offset!");
static_assert(offsetof(ALevelParadise, _fadeOutDuration) == 0x000328, "Member 'ALevelParadise::_fadeOutDuration' has a wrong offset!");
static_assert(offsetof(ALevelParadise, _fadeInDuration) == 0x00032C, "Member 'ALevelParadise::_fadeInDuration' has a wrong offset!");

// Class DeadByDaylight.LightFollower
// 0x0030 (0x00D8 - 0x00A8)
class ULightFollower final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x30];                                      // 0x00A8(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddFollower(class ULightComponent* Follower);
	void SetLeader(class ULightComponent* Leader, float MaxIntensity);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LightFollower">();
	}
	static class ULightFollower* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULightFollower>();
	}
};
static_assert(alignof(ULightFollower) == 0x000008, "Wrong alignment on ULightFollower");
static_assert(sizeof(ULightFollower) == 0x0000D8, "Wrong size on ULightFollower");

// Class DeadByDaylight.LightFunctionActorSpawner
// 0x0010 (0x03B0 - 0x03A0)
class ULightFunctionActorSpawner final : public UActorSpawner
{
public:
	class UTexture*                               LightFunctionTexture;                              // 0x03A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A8[0x8];                                      // 0x03A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LightFunctionActorSpawner">();
	}
	static class ULightFunctionActorSpawner* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULightFunctionActorSpawner>();
	}
};
static_assert(alignof(ULightFunctionActorSpawner) == 0x000010, "Wrong alignment on ULightFunctionActorSpawner");
static_assert(sizeof(ULightFunctionActorSpawner) == 0x0003B0, "Wrong size on ULightFunctionActorSpawner");
static_assert(offsetof(ULightFunctionActorSpawner, LightFunctionTexture) == 0x0003A0, "Member 'ULightFunctionActorSpawner::LightFunctionTexture' has a wrong offset!");

// Class DeadByDaylight.LightingData
// 0x0080 (0x00B8 - 0x0038)
class ULightingData final : public UDataAsset
{
public:
	TSoftClassPtr<class UClass>                   DefaultLighting;                                   // 0x0038(0x0038)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FSceneLightingDescription>      Descriptions;                                      // 0x0070(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TSoftClassPtr<class UClass>                   AdaptiveShadowMapControllersActor;                 // 0x0080(0x0038)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LightingData">();
	}
	static class ULightingData* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULightingData>();
	}
};
static_assert(alignof(ULightingData) == 0x000008, "Wrong alignment on ULightingData");
static_assert(sizeof(ULightingData) == 0x0000B8, "Wrong size on ULightingData");
static_assert(offsetof(ULightingData, DefaultLighting) == 0x000038, "Member 'ULightingData::DefaultLighting' has a wrong offset!");
static_assert(offsetof(ULightingData, Descriptions) == 0x000070, "Member 'ULightingData::Descriptions' has a wrong offset!");
static_assert(offsetof(ULightingData, AdaptiveShadowMapControllersActor) == 0x000080, "Member 'ULightingData::AdaptiveShadowMapControllersActor' has a wrong offset!");

// Class DeadByDaylight.LightingFactory
// 0x0008 (0x0038 - 0x0030)
class ULightingFactory final : public UObject
{
public:
	class ULightingData*                          _data;                                             // 0x0030(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LightingFactory">();
	}
	static class ULightingFactory* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULightingFactory>();
	}
};
static_assert(alignof(ULightingFactory) == 0x000008, "Wrong alignment on ULightingFactory");
static_assert(sizeof(ULightingFactory) == 0x000038, "Wrong size on ULightingFactory");
static_assert(offsetof(ULightingFactory, _data) == 0x000030, "Member 'ULightingFactory::_data' has a wrong offset!");

// Class DeadByDaylight.LightingHelper
// 0x0108 (0x0138 - 0x0030)
class ULightingHelper final : public UObject
{
public:
	uint8                                         Pad_30[0x18];                                      // 0x0030(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class ABaseSky*                               _levelLighting;                                    // 0x0048(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ABaseSky*                               _levelLightingFixed;                               // 0x0050(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ABaseSky*                               _levelLightingSpawned;                             // 0x0058(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ABaseSky*                               _levelLightingWithoutExposure;                     // 0x0060(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 _adaptiveShadowMapControllersActor;                // 0x0068(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ULightingInterpolator*                  _lightingInterpolator;                             // 0x0070(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ULightingFactory*                       _lightingFactory;                                  // 0x0078(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPostProcessComponent*                  _postProcessCache;                                 // 0x0080(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _bIsChangeCondition;                               // 0x0088(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_89[0x3];                                       // 0x0089(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   _changeLightingThemeName;                          // 0x008C(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_98[0xA0];                                      // 0x0098(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DBD_ModifyExposure(float Value);
	class AActor* GetASMController();
	class UActorComponent* GetInitialComponentState(class FName ComponentName);
	class UClass* GetSourceLevelLightingClass();
	class UTextureCube* GetTextureCube(class FName MapTheme);
	void ToggleLightingChange(bool bActivateLightingChange, class FName ThemeName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LightingHelper">();
	}
	static class ULightingHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULightingHelper>();
	}
};
static_assert(alignof(ULightingHelper) == 0x000008, "Wrong alignment on ULightingHelper");
static_assert(sizeof(ULightingHelper) == 0x000138, "Wrong size on ULightingHelper");
static_assert(offsetof(ULightingHelper, _levelLighting) == 0x000048, "Member 'ULightingHelper::_levelLighting' has a wrong offset!");
static_assert(offsetof(ULightingHelper, _levelLightingFixed) == 0x000050, "Member 'ULightingHelper::_levelLightingFixed' has a wrong offset!");
static_assert(offsetof(ULightingHelper, _levelLightingSpawned) == 0x000058, "Member 'ULightingHelper::_levelLightingSpawned' has a wrong offset!");
static_assert(offsetof(ULightingHelper, _levelLightingWithoutExposure) == 0x000060, "Member 'ULightingHelper::_levelLightingWithoutExposure' has a wrong offset!");
static_assert(offsetof(ULightingHelper, _adaptiveShadowMapControllersActor) == 0x000068, "Member 'ULightingHelper::_adaptiveShadowMapControllersActor' has a wrong offset!");
static_assert(offsetof(ULightingHelper, _lightingInterpolator) == 0x000070, "Member 'ULightingHelper::_lightingInterpolator' has a wrong offset!");
static_assert(offsetof(ULightingHelper, _lightingFactory) == 0x000078, "Member 'ULightingHelper::_lightingFactory' has a wrong offset!");
static_assert(offsetof(ULightingHelper, _postProcessCache) == 0x000080, "Member 'ULightingHelper::_postProcessCache' has a wrong offset!");
static_assert(offsetof(ULightingHelper, _bIsChangeCondition) == 0x000088, "Member 'ULightingHelper::_bIsChangeCondition' has a wrong offset!");
static_assert(offsetof(ULightingHelper, _changeLightingThemeName) == 0x00008C, "Member 'ULightingHelper::_changeLightingThemeName' has a wrong offset!");

// Class DeadByDaylight.TutorialGameMode
// 0x0038 (0x0458 - 0x0420)
class ATutorialGameMode final : public ADBDBaseMatchGameMode
{
public:
	uint8                                         Pad_420[0x10];                                     // 0x0420(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UTutorialObjectiveController*           _tutorialObjectiveController;                      // 0x0430(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTutorialNotificationController*        _tutorialNotificationController;                   // 0x0438(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTutorialHighlightController*           _tutorialHighlightController;                      // 0x0440(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAtlantaTutorialPlayerHudController*    _atlantaTutorialPlayerHudController;               // 0x0448(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_450[0x8];                                      // 0x0450(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCanStartAtlantaTutorialChange__DelegateSignature(bool CanStartTutorial);
	void SetEscapeActivated();
	void SetGameObjective(TSubclassOf<class AGameObjective_ActivatedGenerators> GameObjectiveClass);

	class UAtlantaTutorialPlayerHudController* GetAtlantaTutorialPlayerHudController() const;
	class UTutorialHighlightController* GetTutorialHighlightController() const;
	class UTutorialNotificationController* GetTutorialNotificationController() const;
	class UTutorialObjectiveController* GetTutorialObjectiveController() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TutorialGameMode">();
	}
	static class ATutorialGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATutorialGameMode>();
	}
};
static_assert(alignof(ATutorialGameMode) == 0x000008, "Wrong alignment on ATutorialGameMode");
static_assert(sizeof(ATutorialGameMode) == 0x000458, "Wrong size on ATutorialGameMode");
static_assert(offsetof(ATutorialGameMode, _tutorialObjectiveController) == 0x000430, "Member 'ATutorialGameMode::_tutorialObjectiveController' has a wrong offset!");
static_assert(offsetof(ATutorialGameMode, _tutorialNotificationController) == 0x000438, "Member 'ATutorialGameMode::_tutorialNotificationController' has a wrong offset!");
static_assert(offsetof(ATutorialGameMode, _tutorialHighlightController) == 0x000440, "Member 'ATutorialGameMode::_tutorialHighlightController' has a wrong offset!");
static_assert(offsetof(ATutorialGameMode, _atlantaTutorialPlayerHudController) == 0x000448, "Member 'ATutorialGameMode::_atlantaTutorialPlayerHudController' has a wrong offset!");

// Class DeadByDaylight.LightingInterpolator
// 0x0050 (0x0080 - 0x0030)
class ULightingInterpolator final : public UObject
{
public:
	FMulticastInlineDelegateProperty_             OnInterpolationDone;                               // 0x0030(0x0010)(ZeroConstructor, Transient, InstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x38];                                      // 0x0040(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	class ABaseSky*                               _targetLighting;                                   // 0x0078(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static void LerpHeightFog(class UExponentialHeightFogComponent* Target, const class UExponentialHeightFogComponent* A, const class UExponentialHeightFogComponent* B, float Alpha, float ThresholdBeforeSwitchingtoB);
	static void LerpLight(class ULightComponent* Target, class ULightComponent* A, class ULightComponent* B, float Alpha);
	static void LerpSkylight(class USkyLightComponent* Target, class USkyLightComponent* A, class USkyLightComponent* B, float Alpha);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LightingInterpolator">();
	}
	static class ULightingInterpolator* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULightingInterpolator>();
	}
};
static_assert(alignof(ULightingInterpolator) == 0x000008, "Wrong alignment on ULightingInterpolator");
static_assert(sizeof(ULightingInterpolator) == 0x000080, "Wrong size on ULightingInterpolator");
static_assert(offsetof(ULightingInterpolator, OnInterpolationDone) == 0x000030, "Member 'ULightingInterpolator::OnInterpolationDone' has a wrong offset!");
static_assert(offsetof(ULightingInterpolator, _targetLighting) == 0x000078, "Member 'ULightingInterpolator::_targetLighting' has a wrong offset!");

// Class DeadByDaylight.SpawnerStrategy
// 0x0000 (0x0030 - 0x0030)
class USpawnerStrategy : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpawnerStrategy">();
	}
	static class USpawnerStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpawnerStrategy>();
	}
};
static_assert(alignof(USpawnerStrategy) == 0x000008, "Wrong alignment on USpawnerStrategy");
static_assert(sizeof(USpawnerStrategy) == 0x000030, "Wrong size on USpawnerStrategy");

// Class DeadByDaylight.LimitAccumulationSpawnerStrategy
// 0x0010 (0x0040 - 0x0030)
class ULimitAccumulationSpawnerStrategy final : public USpawnerStrategy
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetMaxOverlapping(int32 MaxOverlapping);
	void SetRecycleDistancePercentage(float RecycleDistancePercentage);
	void SetRecycleThresholdPercentage(float RecycleThresholdPercentage);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LimitAccumulationSpawnerStrategy">();
	}
	static class ULimitAccumulationSpawnerStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULimitAccumulationSpawnerStrategy>();
	}
};
static_assert(alignof(ULimitAccumulationSpawnerStrategy) == 0x000008, "Wrong alignment on ULimitAccumulationSpawnerStrategy");
static_assert(sizeof(ULimitAccumulationSpawnerStrategy) == 0x000040, "Wrong size on ULimitAccumulationSpawnerStrategy");

// Class DeadByDaylight.LimitedTimeGameModeManager
// 0x0058 (0x0090 - 0x0038)
class ULimitedTimeGameModeManager final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x58];                                      // 0x0038(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LimitedTimeGameModeManager">();
	}
	static class ULimitedTimeGameModeManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULimitedTimeGameModeManager>();
	}
};
static_assert(alignof(ULimitedTimeGameModeManager) == 0x000008, "Wrong alignment on ULimitedTimeGameModeManager");
static_assert(sizeof(ULimitedTimeGameModeManager) == 0x000090, "Wrong size on ULimitedTimeGameModeManager");

// Class DeadByDaylight.LoadingScreen
// 0x0018 (0x0140 - 0x0128)
class ULoadingScreen final : public UScreenBase
{
public:
	uint8                                         Pad_128[0x18];                                     // 0x0128(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnLoadingTextTimerComplete() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoadingScreen">();
	}
	static class ULoadingScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoadingScreen>();
	}
};
static_assert(alignof(ULoadingScreen) == 0x000008, "Wrong alignment on ULoadingScreen");
static_assert(sizeof(ULoadingScreen) == 0x000140, "Wrong size on ULoadingScreen");

// Class DeadByDaylight.TileVisitedAnalyticsComponent
// 0x0050 (0x00F8 - 0x00A8)
class UTileVisitedAnalyticsComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x50];                                      // 0x00A8(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TileVisitedAnalyticsComponent">();
	}
	static class UTileVisitedAnalyticsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTileVisitedAnalyticsComponent>();
	}
};
static_assert(alignof(UTileVisitedAnalyticsComponent) == 0x000008, "Wrong alignment on UTileVisitedAnalyticsComponent");
static_assert(sizeof(UTileVisitedAnalyticsComponent) == 0x0000F8, "Wrong size on UTileVisitedAnalyticsComponent");

// Class DeadByDaylight.LoadingUtilities
// 0x0000 (0x0030 - 0x0030)
class ULoadingUtilities final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoadingUtilities">();
	}
	static class ULoadingUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoadingUtilities>();
	}
};
static_assert(alignof(ULoadingUtilities) == 0x000008, "Wrong alignment on ULoadingUtilities");
static_assert(sizeof(ULoadingUtilities) == 0x000030, "Wrong size on ULoadingUtilities");

// Class DeadByDaylight.LoadoutControllerSubsystem
// 0x0000 (0x0038 - 0x0038)
class ULoadoutControllerSubsystem final : public UGameInstanceSubsystem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoadoutControllerSubsystem">();
	}
	static class ULoadoutControllerSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoadoutControllerSubsystem>();
	}
};
static_assert(alignof(ULoadoutControllerSubsystem) == 0x000008, "Wrong alignment on ULoadoutControllerSubsystem");
static_assert(sizeof(ULoadoutControllerSubsystem) == 0x000038, "Wrong size on ULoadoutControllerSubsystem");

// Class DeadByDaylight.LoadoutPresetController
// 0x0000 (0x0030 - 0x0030)
class ULoadoutPresetController final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoadoutPresetController">();
	}
	static class ULoadoutPresetController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoadoutPresetController>();
	}
};
static_assert(alignof(ULoadoutPresetController) == 0x000008, "Wrong alignment on ULoadoutPresetController");
static_assert(sizeof(ULoadoutPresetController) == 0x000030, "Wrong size on ULoadoutPresetController");

// Class DeadByDaylight.UMGScoreAlertWidget
// 0x0000 (0x02F0 - 0x02F0)
class UUMGScoreAlertWidget final : public UUMGBaseAlertWidget
{
public:
	void UpdateWidget(EDBDScoreCategory ScoreType, const class FString& Title, int32 ScoreValue, float Progress, const class FText& DefaultScoreText);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGScoreAlertWidget">();
	}
	static class UUMGScoreAlertWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGScoreAlertWidget>();
	}
};
static_assert(alignof(UUMGScoreAlertWidget) == 0x000008, "Wrong alignment on UUMGScoreAlertWidget");
static_assert(sizeof(UUMGScoreAlertWidget) == 0x0002F0, "Wrong size on UUMGScoreAlertWidget");

// Class DeadByDaylight.LobbyControllerSubsystem
// 0x0130 (0x0168 - 0x0038)
class ULobbyControllerSubsystem final : public UGameInstanceSubsystem
{
public:
	TWeakObjectPtr<class ULobbyDisplayStandController> _localPlayerDisplayStandController;                // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class FString, class ULobbyDisplayStandController*> _displayStandControllers;                          // 0x0040(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_90[0xD8];                                      // 0x0090(0x00D8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LobbyControllerSubsystem">();
	}
	static class ULobbyControllerSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULobbyControllerSubsystem>();
	}
};
static_assert(alignof(ULobbyControllerSubsystem) == 0x000008, "Wrong alignment on ULobbyControllerSubsystem");
static_assert(sizeof(ULobbyControllerSubsystem) == 0x000168, "Wrong size on ULobbyControllerSubsystem");
static_assert(offsetof(ULobbyControllerSubsystem, _localPlayerDisplayStandController) == 0x000038, "Member 'ULobbyControllerSubsystem::_localPlayerDisplayStandController' has a wrong offset!");
static_assert(offsetof(ULobbyControllerSubsystem, _displayStandControllers) == 0x000040, "Member 'ULobbyControllerSubsystem::_displayStandControllers' has a wrong offset!");

// Class DeadByDaylight.LobbyLevel
// 0x00A8 (0x0350 - 0x02A8)
class ALobbyLevel : public ALevelScriptActor
{
public:
	uint8                                         Pad_2A8[0x48];                                     // 0x02A8(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ADisplayStand*>                  _registeredDisplayStands;                          // 0x02F0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	EWorldFlowEvent                               LobbyLoadedEvent;                                  // 0x0300(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_301[0x7];                                      // 0x0301(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                _moriPreviewSpawnLocation;                         // 0x0308(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_320[0x30];                                     // 0x0320(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAdditionalSubLevelsLoaded();
	void OnAnimationPreviewCompleted(class UAnimationPreviewSubsystem* Subsystem, const struct FAnimationPreviewRequest& Request, bool CompletedSuccessfully);
	void OnAnimationPreviewStarted(class UAnimationPreviewSubsystem* Subsystem, const struct FAnimationPreviewRequest& Request);
	void OnLobbySubLevelLoaded();
	void OnShopSubLevelLoaded();
	void ReceiveAnimationPreviewCompleted();
	void ReceiveAnimationPreviewStarted();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LobbyLevel">();
	}
	static class ALobbyLevel* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALobbyLevel>();
	}
};
static_assert(alignof(ALobbyLevel) == 0x000008, "Wrong alignment on ALobbyLevel");
static_assert(sizeof(ALobbyLevel) == 0x000350, "Wrong size on ALobbyLevel");
static_assert(offsetof(ALobbyLevel, _registeredDisplayStands) == 0x0002F0, "Member 'ALobbyLevel::_registeredDisplayStands' has a wrong offset!");
static_assert(offsetof(ALobbyLevel, LobbyLoadedEvent) == 0x000300, "Member 'ALobbyLevel::LobbyLoadedEvent' has a wrong offset!");
static_assert(offsetof(ALobbyLevel, _moriPreviewSpawnLocation) == 0x000308, "Member 'ALobbyLevel::_moriPreviewSpawnLocation' has a wrong offset!");

// Class DeadByDaylight.LocalEventManager
// 0x17D0 (0x1808 - 0x0038)
class ULocalEventManager final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x17D0];                                    // 0x0038(0x17D0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LocalEventManager">();
	}
	static class ULocalEventManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULocalEventManager>();
	}
};
static_assert(alignof(ULocalEventManager) == 0x000008, "Wrong alignment on ULocalEventManager");
static_assert(sizeof(ULocalEventManager) == 0x001808, "Wrong size on ULocalEventManager");

// Class DeadByDaylight.LocalizationSearchSubsystem
// 0x0000 (0x0038 - 0x0038)
class ULocalizationSearchSubsystem final : public UGameInstanceSubsystem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LocalizationSearchSubsystem">();
	}
	static class ULocalizationSearchSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULocalizationSearchSubsystem>();
	}
};
static_assert(alignof(ULocalizationSearchSubsystem) == 0x000008, "Wrong alignment on ULocalizationSearchSubsystem");
static_assert(sizeof(ULocalizationSearchSubsystem) == 0x000038, "Wrong size on ULocalizationSearchSubsystem");

// Class DeadByDaylight.UMGHtmlRichText
// 0x0000 (0x0890 - 0x0890)
class UUMGHtmlRichText final : public URichTextBlock
{
public:
	void SetHTMLText(const class FString& InText);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGHtmlRichText">();
	}
	static class UUMGHtmlRichText* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGHtmlRichText>();
	}
};
static_assert(alignof(UUMGHtmlRichText) == 0x000010, "Wrong alignment on UUMGHtmlRichText");
static_assert(sizeof(UUMGHtmlRichText) == 0x000890, "Wrong size on UUMGHtmlRichText");

// Class DeadByDaylight.LocalPlayerTrackerComponent
// 0x0010 (0x00B8 - 0x00A8)
class ULocalPlayerTrackerComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             TrackerOnLocallyObservedChanged;                   // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void TriggerOnLocallyObservedChanged();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LocalPlayerTrackerComponent">();
	}
	static class ULocalPlayerTrackerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULocalPlayerTrackerComponent>();
	}
};
static_assert(alignof(ULocalPlayerTrackerComponent) == 0x000008, "Wrong alignment on ULocalPlayerTrackerComponent");
static_assert(sizeof(ULocalPlayerTrackerComponent) == 0x0000B8, "Wrong size on ULocalPlayerTrackerComponent");
static_assert(offsetof(ULocalPlayerTrackerComponent, TrackerOnLocallyObservedChanged) == 0x0000A8, "Member 'ULocalPlayerTrackerComponent::TrackerOnLocallyObservedChanged' has a wrong offset!");

// Class DeadByDaylight.LocalPlayerUtilities
// 0x0000 (0x0030 - 0x0030)
class ULocalPlayerUtilities final : public UBlueprintFunctionLibrary
{
public:
	static class ADBDPlayerState* GetFirstLocalValidHumanPlayerState(const class UObject* WorldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LocalPlayerUtilities">();
	}
	static class ULocalPlayerUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULocalPlayerUtilities>();
	}
};
static_assert(alignof(ULocalPlayerUtilities) == 0x000008, "Wrong alignment on ULocalPlayerUtilities");
static_assert(sizeof(ULocalPlayerUtilities) == 0x000030, "Wrong size on ULocalPlayerUtilities");

// Class DeadByDaylight.LockerAmmoActorOutlineUpdateStrategy
// 0x0000 (0x00F0 - 0x00F0)
class ULockerAmmoActorOutlineUpdateStrategy final : public UDefaultOutlineUpdateStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LockerAmmoActorOutlineUpdateStrategy">();
	}
	static class ULockerAmmoActorOutlineUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULockerAmmoActorOutlineUpdateStrategy>();
	}
};
static_assert(alignof(ULockerAmmoActorOutlineUpdateStrategy) == 0x000008, "Wrong alignment on ULockerAmmoActorOutlineUpdateStrategy");
static_assert(sizeof(ULockerAmmoActorOutlineUpdateStrategy) == 0x0000F0, "Wrong size on ULockerAmmoActorOutlineUpdateStrategy");

// Class DeadByDaylight.LockerAnimInstance
// 0x0000 (0x0360 - 0x0360)
class ULockerAnimInstance : public USleepingAnimInstance
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LockerAnimInstance">();
	}
	static class ULockerAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULockerAnimInstance>();
	}
};
static_assert(alignof(ULockerAnimInstance) == 0x000010, "Wrong alignment on ULockerAnimInstance");
static_assert(sizeof(ULockerAnimInstance) == 0x000360, "Wrong size on ULockerAnimInstance");

// Class DeadByDaylight.LockerOutlineUpdateStrategy
// 0x0018 (0x0160 - 0x0148)
class ULockerOutlineUpdateStrategy final : public USourceBasedOutlineUpdateStrategy
{
public:
	uint8                                         Pad_148[0x18];                                     // 0x0148(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FLinearColor GetRedColor() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LockerOutlineUpdateStrategy">();
	}
	static class ULockerOutlineUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULockerOutlineUpdateStrategy>();
	}
};
static_assert(alignof(ULockerOutlineUpdateStrategy) == 0x000008, "Wrong alignment on ULockerOutlineUpdateStrategy");
static_assert(sizeof(ULockerOutlineUpdateStrategy) == 0x000160, "Wrong size on ULockerOutlineUpdateStrategy");

// Class DeadByDaylight.LoudNoiseEventSystem
// 0x0090 (0x0138 - 0x00A8)
class ULoudNoiseEventSystem final : public UActorComponent
{
public:
	TArray<struct FGameplayTag>                   _requiredPlayerStateTags;                          // 0x00A8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FGameplayTag>                   _preventativePlayerStateTags;                      // 0x00B8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_C8[0x70];                                      // 0x00C8(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoudNoiseEventSystem">();
	}
	static class ULoudNoiseEventSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoudNoiseEventSystem>();
	}
};
static_assert(alignof(ULoudNoiseEventSystem) == 0x000008, "Wrong alignment on ULoudNoiseEventSystem");
static_assert(sizeof(ULoudNoiseEventSystem) == 0x000138, "Wrong size on ULoudNoiseEventSystem");
static_assert(offsetof(ULoudNoiseEventSystem, _requiredPlayerStateTags) == 0x0000A8, "Member 'ULoudNoiseEventSystem::_requiredPlayerStateTags' has a wrong offset!");
static_assert(offsetof(ULoudNoiseEventSystem, _preventativePlayerStateTags) == 0x0000B8, "Member 'ULoudNoiseEventSystem::_preventativePlayerStateTags' has a wrong offset!");

// Class DeadByDaylight.LoudNoiseHUDIndicator
// 0x00A0 (0x0360 - 0x02C0)
class ULoudNoiseHUDIndicator final : public USceneComponent
{
public:
	class UStaticMesh*                            MaskMesh;                                          // 0x02C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            DistortionMesh;                                    // 0x02C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EdgePadding;                                       // 0x02D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CornerRoundness;                                   // 0x02D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScreenFadeOutDistance;                             // 0x02D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2DC[0x4];                                      // 0x02DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             LoudNoiseAddedEvent;                               // 0x02E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F0[0x60];                                     // 0x02F0(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLoudNoiseIndicatorData>        _trackedNoises;                                    // 0x0350(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	void AddTrackedNoise(const struct FVector& Location, float Duration);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoudNoiseHUDIndicator">();
	}
	static class ULoudNoiseHUDIndicator* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoudNoiseHUDIndicator>();
	}
};
static_assert(alignof(ULoudNoiseHUDIndicator) == 0x000010, "Wrong alignment on ULoudNoiseHUDIndicator");
static_assert(sizeof(ULoudNoiseHUDIndicator) == 0x000360, "Wrong size on ULoudNoiseHUDIndicator");
static_assert(offsetof(ULoudNoiseHUDIndicator, MaskMesh) == 0x0002C0, "Member 'ULoudNoiseHUDIndicator::MaskMesh' has a wrong offset!");
static_assert(offsetof(ULoudNoiseHUDIndicator, DistortionMesh) == 0x0002C8, "Member 'ULoudNoiseHUDIndicator::DistortionMesh' has a wrong offset!");
static_assert(offsetof(ULoudNoiseHUDIndicator, EdgePadding) == 0x0002D0, "Member 'ULoudNoiseHUDIndicator::EdgePadding' has a wrong offset!");
static_assert(offsetof(ULoudNoiseHUDIndicator, CornerRoundness) == 0x0002D4, "Member 'ULoudNoiseHUDIndicator::CornerRoundness' has a wrong offset!");
static_assert(offsetof(ULoudNoiseHUDIndicator, ScreenFadeOutDistance) == 0x0002D8, "Member 'ULoudNoiseHUDIndicator::ScreenFadeOutDistance' has a wrong offset!");
static_assert(offsetof(ULoudNoiseHUDIndicator, LoudNoiseAddedEvent) == 0x0002E0, "Member 'ULoudNoiseHUDIndicator::LoudNoiseAddedEvent' has a wrong offset!");
static_assert(offsetof(ULoudNoiseHUDIndicator, _trackedNoises) == 0x000350, "Member 'ULoudNoiseHUDIndicator::_trackedNoises' has a wrong offset!");

// Class DeadByDaylight.LoudNoiseNotifier
// 0x0000 (0x0030 - 0x0030)
class ULoudNoiseNotifier final : public UBlueprintFunctionLibrary
{
public:
	static bool CanSeeLoudNoise(const class UObject* WorldContextObject, const struct FVector& Location);
	static void Fire(const class UObject* WorldContextObject, class AActor* Instigator, const struct FVector& Location, bool ShouldTrack, float AudibleRange, class ADBDPlayer* InstigatingPlayer, bool IsQuickAction, bool IsDeceivingNoise);
	static void FireWithTimeBudgeter(const class UObject* WorldContextObject, class AActor* Instigator, const struct FVector& Location, bool ShouldTrack, float AudibleRange, class ADBDPlayer* InstigatingPlayer, bool IsQuickAction);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoudNoiseNotifier">();
	}
	static class ULoudNoiseNotifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoudNoiseNotifier>();
	}
};
static_assert(alignof(ULoudNoiseNotifier) == 0x000008, "Wrong alignment on ULoudNoiseNotifier");
static_assert(sizeof(ULoudNoiseNotifier) == 0x000030, "Wrong size on ULoudNoiseNotifier");

// Class DeadByDaylight.LteUIUtilities
// 0x0000 (0x0030 - 0x0030)
class ULteUIUtilities final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LteUIUtilities">();
	}
	static class ULteUIUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULteUIUtilities>();
	}
};
static_assert(alignof(ULteUIUtilities) == 0x000008, "Wrong alignment on ULteUIUtilities");
static_assert(sizeof(ULteUIUtilities) == 0x000030, "Wrong size on ULteUIUtilities");

// Class DeadByDaylight.LunarEventComponent
// 0x0048 (0x00F0 - 0x00A8)
class ULunarEventComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x10];                                      // 0x00A8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _lanternCollectedCount;                            // 0x00B8(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         _additionalEventProgressCount;                     // 0x00BC(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C0[0x30];                                      // 0x00C0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnCamperEscape(const struct FGameplayTag& GameEventType, const struct FGameEventData& GameEventData);
	void Authority_OnCamperLostLantern(const struct FGameplayTag& GameEventType, const struct FGameEventData& GameEventData);
	void Authority_OnDestroyCamperLightGameEvent(const struct FGameplayTag& GameEventType, const struct FGameEventData& GameEventData);
	void Authority_OnFixGenerator(const struct FGameplayTag& GameEventType, const struct FGameEventData& GameEventData);
	void Authority_OnPickupLantern(const struct FGameplayTag& GameEventType, const struct FGameEventData& GameEventData);
	void Authority_OnPlayerLeaveGame(const struct FGameplayTag& GameEventType, const struct FGameEventData& GameEventData);
	void Authority_OnSlasherDestroysLantern(const struct FGameplayTag& GameEventType, const struct FGameEventData& GameEventData);
	void Local_OnCamperEscape(const struct FGameplayTag& GameEventType, const struct FGameEventData& GameEventData);
	void Local_OnCamperLostLantern(const struct FGameplayTag& GameEventType, const struct FGameEventData& GameEventData);
	void Multicast_ResetLanternLight(class ALanternInteractable* LanternInteractable);
	void OnFinishedPlaying(const struct FGameplayTag& GameEventType, const struct FGameEventData& GameEventData);
	void OnLanternHoldTimerEnd();
	void OnRep_lanternCollectedCount();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LunarEventComponent">();
	}
	static class ULunarEventComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULunarEventComponent>();
	}
};
static_assert(alignof(ULunarEventComponent) == 0x000008, "Wrong alignment on ULunarEventComponent");
static_assert(sizeof(ULunarEventComponent) == 0x0000F0, "Wrong size on ULunarEventComponent");
static_assert(offsetof(ULunarEventComponent, _lanternCollectedCount) == 0x0000B8, "Member 'ULunarEventComponent::_lanternCollectedCount' has a wrong offset!");
static_assert(offsetof(ULunarEventComponent, _additionalEventProgressCount) == 0x0000BC, "Member 'ULunarEventComponent::_additionalEventProgressCount' has a wrong offset!");

// Class DeadByDaylight.MagicFountain
// 0x0020 (0x03C8 - 0x03A8)
class AMagicFountain final : public AInteractable
{
public:
	uint8                                         Pad_3A8[0x8];                                      // 0x03A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                AIInteractionOffset;                               // 0x03B0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	bool IsCorrupted() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MagicFountain">();
	}
	static class AMagicFountain* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMagicFountain>();
	}
};
static_assert(alignof(AMagicFountain) == 0x000008, "Wrong alignment on AMagicFountain");
static_assert(sizeof(AMagicFountain) == 0x0003C8, "Wrong size on AMagicFountain");
static_assert(offsetof(AMagicFountain, AIInteractionOffset) == 0x0003B0, "Member 'AMagicFountain::AIInteractionOffset' has a wrong offset!");

// Class DeadByDaylight.ManualIconStrategy
// 0x0008 (0x0040 - 0x0038)
class UManualIconStrategy final : public UBasePerkIconStrategy
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ManualIconStrategy">();
	}
	static class UManualIconStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UManualIconStrategy>();
	}
};
static_assert(alignof(UManualIconStrategy) == 0x000008, "Wrong alignment on UManualIconStrategy");
static_assert(sizeof(UManualIconStrategy) == 0x000040, "Wrong size on UManualIconStrategy");

// Class DeadByDaylight.MapActorComponent
// 0x0030 (0x00D8 - 0x00A8)
class UMapActorComponent final : public UActorComponent
{
public:
	EMapActorCategory                             Category;                                          // 0x00A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UPrimitiveComponent*                    _mapActorCollider;                                 // 0x00B0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B8[0x18];                                      // 0x00B8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _detectionEnabled;                                 // 0x00D0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D1[0x7];                                       // 0x00D1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Multicast_SetDetectionEnabled(bool Enabled);

	bool GetDetectionEnabled() const;
	bool IsKnownBy(const class ADBDPlayer* Character) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapActorComponent">();
	}
	static class UMapActorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapActorComponent>();
	}
};
static_assert(alignof(UMapActorComponent) == 0x000008, "Wrong alignment on UMapActorComponent");
static_assert(sizeof(UMapActorComponent) == 0x0000D8, "Wrong size on UMapActorComponent");
static_assert(offsetof(UMapActorComponent, Category) == 0x0000A8, "Member 'UMapActorComponent::Category' has a wrong offset!");
static_assert(offsetof(UMapActorComponent, _mapActorCollider) == 0x0000B0, "Member 'UMapActorComponent::_mapActorCollider' has a wrong offset!");
static_assert(offsetof(UMapActorComponent, _detectionEnabled) == 0x0000D0, "Member 'UMapActorComponent::_detectionEnabled' has a wrong offset!");

// Class DeadByDaylight.MapActorDB
// 0x0050 (0x0080 - 0x0030)
class UMapActorDB final : public UObject
{
public:
	uint8                                         Pad_30[0x50];                                      // 0x0030(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	TArray<EMapActorCategory> CopyListMinusCategories(const TArray<EMapActorCategory>& Categories, const TArray<EMapActorCategory>& CategoriesToRemove) const;
	class AActor* GetRandom(EMapActorCategory Category) const;
	TArray<class AActor*> GetUniqueRandom(const TArray<EMapActorCategory>& Categories, int32 Count) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapActorDB">();
	}
	static class UMapActorDB* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapActorDB>();
	}
};
static_assert(alignof(UMapActorDB) == 0x000008, "Wrong alignment on UMapActorDB");
static_assert(sizeof(UMapActorDB) == 0x000080, "Wrong size on UMapActorDB");

// Class DeadByDaylight.MapData
// 0x00B8 (0x00F0 - 0x0038)
class UMapData final : public UDataAsset
{
public:
	class FName                                   ThemeName;                                         // 0x0038(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ThemeWeather;                                      // 0x0044(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AudioStateThemes;                                  // 0x0050(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AudioStateWeather;                                 // 0x005C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AudioThemeEvent;                                   // 0x0068(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AudioLimitPointEvent;                              // 0x0074(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAkAudioBank>            AudioThemeSoundBank;                               // 0x0080(0x0038)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MapWidth;                                          // 0x00B8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MapHeight;                                         // 0x00BC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Draft;                                             // 0x00C0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C1[0x7];                                       // 0x00C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTileProperties>                MapTileProperties;                                 // 0x00C8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class UBlackboardData*                        Blackboard;                                        // 0x00D8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Gesture;                                           // 0x00E0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E1[0x7];                                       // 0x00E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UProceduralGenerationData*              _proceduralGenerationData;                         // 0x00E8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapData">();
	}
	static class UMapData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapData>();
	}
};
static_assert(alignof(UMapData) == 0x000008, "Wrong alignment on UMapData");
static_assert(sizeof(UMapData) == 0x0000F0, "Wrong size on UMapData");
static_assert(offsetof(UMapData, ThemeName) == 0x000038, "Member 'UMapData::ThemeName' has a wrong offset!");
static_assert(offsetof(UMapData, ThemeWeather) == 0x000044, "Member 'UMapData::ThemeWeather' has a wrong offset!");
static_assert(offsetof(UMapData, AudioStateThemes) == 0x000050, "Member 'UMapData::AudioStateThemes' has a wrong offset!");
static_assert(offsetof(UMapData, AudioStateWeather) == 0x00005C, "Member 'UMapData::AudioStateWeather' has a wrong offset!");
static_assert(offsetof(UMapData, AudioThemeEvent) == 0x000068, "Member 'UMapData::AudioThemeEvent' has a wrong offset!");
static_assert(offsetof(UMapData, AudioLimitPointEvent) == 0x000074, "Member 'UMapData::AudioLimitPointEvent' has a wrong offset!");
static_assert(offsetof(UMapData, AudioThemeSoundBank) == 0x000080, "Member 'UMapData::AudioThemeSoundBank' has a wrong offset!");
static_assert(offsetof(UMapData, MapWidth) == 0x0000B8, "Member 'UMapData::MapWidth' has a wrong offset!");
static_assert(offsetof(UMapData, MapHeight) == 0x0000BC, "Member 'UMapData::MapHeight' has a wrong offset!");
static_assert(offsetof(UMapData, Draft) == 0x0000C0, "Member 'UMapData::Draft' has a wrong offset!");
static_assert(offsetof(UMapData, MapTileProperties) == 0x0000C8, "Member 'UMapData::MapTileProperties' has a wrong offset!");
static_assert(offsetof(UMapData, Blackboard) == 0x0000D8, "Member 'UMapData::Blackboard' has a wrong offset!");
static_assert(offsetof(UMapData, Gesture) == 0x0000E0, "Member 'UMapData::Gesture' has a wrong offset!");
static_assert(offsetof(UMapData, _proceduralGenerationData) == 0x0000E8, "Member 'UMapData::_proceduralGenerationData' has a wrong offset!");

// Class DeadByDaylight.MapSpecificSpawnActorsComponent
// 0x0018 (0x00C0 - 0x00A8)
class UMapSpecificSpawnActorsComponent final : public UMapSpecificGameStateComponent
{
public:
	EGameTypeModifierName                         _shouldSpawnModifier;                              // 0x00A8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMapSpecificSpawnActorData>     _actorsToSpawn;                                    // 0x00B0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	void Authority_OnLevelReadyToPlay();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapSpecificSpawnActorsComponent">();
	}
	static class UMapSpecificSpawnActorsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapSpecificSpawnActorsComponent>();
	}
};
static_assert(alignof(UMapSpecificSpawnActorsComponent) == 0x000008, "Wrong alignment on UMapSpecificSpawnActorsComponent");
static_assert(sizeof(UMapSpecificSpawnActorsComponent) == 0x0000C0, "Wrong size on UMapSpecificSpawnActorsComponent");
static_assert(offsetof(UMapSpecificSpawnActorsComponent, _shouldSpawnModifier) == 0x0000A8, "Member 'UMapSpecificSpawnActorsComponent::_shouldSpawnModifier' has a wrong offset!");
static_assert(offsetof(UMapSpecificSpawnActorsComponent, _actorsToSpawn) == 0x0000B0, "Member 'UMapSpecificSpawnActorsComponent::_actorsToSpawn' has a wrong offset!");

// Class DeadByDaylight.MarketingInvitationPopupManager
// 0x0040 (0x0078 - 0x0038)
class UMarketingInvitationPopupManager final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x40];                                      // 0x0038(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarketingInvitationPopupManager">();
	}
	static class UMarketingInvitationPopupManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMarketingInvitationPopupManager>();
	}
};
static_assert(alignof(UMarketingInvitationPopupManager) == 0x000008, "Wrong alignment on UMarketingInvitationPopupManager");
static_assert(sizeof(UMarketingInvitationPopupManager) == 0x000078, "Wrong size on UMarketingInvitationPopupManager");

// Class DeadByDaylight.SectionnedChargeableComponent
// 0x0008 (0x0320 - 0x0318)
class USectionnedChargeableComponent final : public UChargeableComponent
{
public:
	uint8                                         _sections;                                         // 0x0318(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_319[0x7];                                      // 0x0319(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetSectionChargeRemaining() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SectionnedChargeableComponent">();
	}
	static class USectionnedChargeableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USectionnedChargeableComponent>();
	}
};
static_assert(alignof(USectionnedChargeableComponent) == 0x000008, "Wrong alignment on USectionnedChargeableComponent");
static_assert(sizeof(USectionnedChargeableComponent) == 0x000320, "Wrong size on USectionnedChargeableComponent");
static_assert(offsetof(USectionnedChargeableComponent, _sections) == 0x000318, "Member 'USectionnedChargeableComponent::_sections' has a wrong offset!");

// Class DeadByDaylight.MatchIncentivesManager
// 0x0078 (0x00B0 - 0x0038)
class UMatchIncentivesManager final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x78];                                      // 0x0038(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchIncentivesManager">();
	}
	static class UMatchIncentivesManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchIncentivesManager>();
	}
};
static_assert(alignof(UMatchIncentivesManager) == 0x000008, "Wrong alignment on UMatchIncentivesManager");
static_assert(sizeof(UMatchIncentivesManager) == 0x0000B0, "Wrong size on UMatchIncentivesManager");

// Class DeadByDaylight.MatchmakingFlowSubsystem
// 0x00E8 (0x0120 - 0x0038)
class UMatchmakingFlowSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0xE8];                                      // 0x0038(0x00E8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchmakingFlowSubsystem">();
	}
	static class UMatchmakingFlowSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchmakingFlowSubsystem>();
	}
};
static_assert(alignof(UMatchmakingFlowSubsystem) == 0x000008, "Wrong alignment on UMatchmakingFlowSubsystem");
static_assert(sizeof(UMatchmakingFlowSubsystem) == 0x000120, "Wrong size on UMatchmakingFlowSubsystem");

// Class DeadByDaylight.MatchMakingWidgetScreen
// 0x0000 (0x0128 - 0x0128)
class UMatchMakingWidgetScreen final : public UScreenBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchMakingWidgetScreen">();
	}
	static class UMatchMakingWidgetScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchMakingWidgetScreen>();
	}
};
static_assert(alignof(UMatchMakingWidgetScreen) == 0x000008, "Wrong alignment on UMatchMakingWidgetScreen");
static_assert(sizeof(UMatchMakingWidgetScreen) == 0x000128, "Wrong size on UMatchMakingWidgetScreen");

// Class DeadByDaylight.MeatHook
// 0x0318 (0x06C0 - 0x03A8)
class AMeatHook : public AInteractable
{
public:
	uint8                                         Pad_3A8[0x68];                                     // 0x03A8(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          WasSurvivorStruggleCancelled;                      // 0x0410(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsSacrificeEnabled;                                // 0x0411(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_412[0x6];                                      // 0x0412(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                AIInteractionOffset;                               // 0x0418(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_430[0x60];                                     // 0x0430(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UDBDClipRegionComponent*>        ClipRegions;                                       // 0x0490(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	bool                                          IsSurvivorStruggling;                              // 0x04A0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsInBasement;                                      // 0x04A1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsBreakable;                                       // 0x04A2(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsSabotageable;                                    // 0x04A3(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          CanBeScourgeHook;                                  // 0x04A4(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4A5[0x3];                                      // 0x04A5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           HookIdentityTag;                                   // 0x04A8(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          SnapHookedCharacter;                               // 0x04B4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          FullyHooked;                                       // 0x04B5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4B6[0x2];                                      // 0x04B6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _struggleThreshold;                                // 0x04B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4BC[0x4];                                      // 0x04BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCharacterPusherComponent*              _characterPusher;                                  // 0x04C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCapsuleComponent*                      _slasherCollisionBlocker;                          // 0x04C8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCapsuleComponent*                      _conditionalSlasherCollisionBlocker;               // 0x04D0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  _conditionalSlasherCollisionBlockerPresenceTags;   // 0x04D8(0x0020)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  _stateTagsToApplyOnBeginPlay;                      // 0x04F8(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _sacrificedHookRespawnDuration;                    // 0x0518(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UPollableEventListener*                 _eventListener;                                    // 0x0540(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ACamperPlayer*                          _hookedSurvivor;                                   // 0x0548(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ADBDPlayer*                             _hookBreakerPlayer;                                // 0x0550(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_558[0x68];                                     // 0x0558(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class ACamperPlayer*>                    _campersThatSabotagedMeatHook;                     // 0x05C0(0x0050)(Transient, NativeAccessSpecifierPrivate)
	class UInteractor*                            _mainInteractor;                                   // 0x0610(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UChargeableInteractionDefinition*       _unhook;                                           // 0x0618(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USceneComponent*                        _camperHookedSnapTransform;                        // 0x0620(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AEntity*                                _entity;                                           // 0x0628(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_630[0x20];                                     // 0x0630(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UAIPerceptionStimuliSourceComponent*    _perceptionStimuliComponent;                       // 0x0650(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ADBDPlayer*                             _interactingPlayer;                                // 0x0658(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMapActorComponent*                     _cachedMapActor;                                   // 0x0660(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_668[0x58];                                     // 0x0668(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_SetHookedSurvivor(class ACamperPlayer* Survivor);
	void Authority_SetIsBrokenFromUnhook(bool IsBrokenFromUnhook, class ADBDPlayer* HookBreaker, float OverrideBaseHookRespawnDuration);
	void Authority_SetIsSabotaged(bool IsSabotaged, class ADBDPlayer* Saboteur, bool UseCamperHookRespawnDurationModifiers, float OverrideBaseHookRespawnDuration);
	void Authority_SetIsSacrificed(bool IsSacrificed);
	void Authority_SignalSurvivorAttemptingEscape();
	void Authority_SignalSurvivorAttemptingEscapeAborted();
	void Authority_SignalUnhookingAborted();
	void Authority_SignalUnhookingCharged();
	void Authority_SignalUnhookingEnter();
	void BP_OnHookInteractionStarted();
	void BroadcastUnhook(class ADBDPlayer* Rescuer);
	void Cosmetic_SetAsScourgeHookStart();
	void Local_MoveSurvivorToHook(class ACamperPlayer* Survivor, const float Duration);
	void Multicast_EscapeAttemptResult(class ADBDPlayer* Player, bool Result);
	void Multicast_RefreshCharmCustomization();
	void Multicast_SetHookedSurvivor(class ACamperPlayer* Survivor);
	void Multicast_SetIsBrokenFromUnhook(bool SetIsBrokendFromUnhook, class ADBDPlayer* HookBreaker, float OverrideBaseHookRespawnDuration);
	void Multicast_SetIsSabotaged(bool SetIsSabotaged, class ADBDPlayer* HookBreaker, bool UseCamperHookRespawnDurationModifiers, float OverrideBaseHookRespawnDuration);
	void Multicast_SetIsSacrificed(bool IsSacrificed);
	void OnAutoRepair();
	void OnHookedEnter();
	void OnHookedExit();
	void OnHookedIdle();
	void OnHookedSurvivorAttacked();
	void OnHookedSurvivorChanged(class ACamperPlayer* before, class ACamperPlayer* After);
	void OnHookingEnter();
	void OnHookingExit();
	void OnOwnerReplicated();
	void OnReaction();
	void OnReactionIn();
	void OnSacrificeIn();
	void OnSacrificeOut();
	void OnStartPushingPlayer(class ACharacter* Character);
	void OnStopPushingPlayer(class ACharacter* Character);
	void OnStruggleEnter();
	void OnStruggleExit();
	void OnStruggleSkillCheckFailed_Cosmetic();
	void OnTickStruggle(float DeltaTime);
	void SetEntity(class AEntity* Entity);
	void SetInteractingPlayer(class ADBDPlayer* InteractingPlayer);
	void SetIsBeingSabotaged(bool IsBeingSabotaged);
	void SetMapActor(class UMapActorComponent* Value);
	void UpdateSlasherBlockerCollision();

	bool CanBeSabotaged() const;
	bool CanHookSurvivor() const;
	bool CanSurvivorAttemptEscape(const class ACamperPlayer* Survivor) const;
	bool CanSurvivorStruggle(class ACamperPlayer* Survivor) const;
	bool CanUnhookSurvivor(const class ACamperPlayer* Survivor) const;
	void DebugHookedSurvivor(class ACamperPlayer* ExpectedSurvivor) const;
	void FireHookSoundEvent(const class FName NoiseRangeTunable, const class ADBDPlayer* SoundInstigator) const;
	class USceneComponent* GetCamperHookedSnapTransform() const;
	class USceneComponent* GetCamperUnkookFocalPointTransform() const;
	class UCharacterPusherComponent* GetCharacterPusher() const;
	class UChargeableInteractionDefinition* GetEscapeHookInteraction() const;
	class UHookableComponent* GetHookableComponentOfHookedActor() const;
	class ACamperPlayer* GetHookedSurvivor() const;
	struct FVector GetHookPosition() const;
	class ADBDPlayer* GetInteractingPlayer() const;
	class UPrimitiveComponent* GetInteractorPrimitiveComponent() const;
	class UBoxComponent* GetInteractorZoneComponent() const;
	bool GetIsBroken() const;
	bool GetIsInBasement() const;
	bool GetIsSabotaged() const;
	bool GetIsSacrificed() const;
	class UInteractor* GetMainInteractor() const;
	class UAkComponent* GetMeatHookAkAudioComponent() const;
	class UMontagePlayer* GetMontagePlayer() const;
	float GetSabotageHookRespawnDuration() const;
	class ADBDPlayer* GetSaboteurPlayer() const;
	float GetStrugglePercent() const;
	float GetStruggleThreshold() const;
	struct FAnimationMontageDescriptor GetUnhookInMontageDescriptor() const;
	class UChargeableInteractionDefinition* GetUnhookInteraction() const;
	struct FAnimationMontageDescriptor GetUnhookOutMontageDescriptor() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MeatHook">();
	}
	static class AMeatHook* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMeatHook>();
	}
};
static_assert(alignof(AMeatHook) == 0x000008, "Wrong alignment on AMeatHook");
static_assert(sizeof(AMeatHook) == 0x0006C0, "Wrong size on AMeatHook");
static_assert(offsetof(AMeatHook, WasSurvivorStruggleCancelled) == 0x000410, "Member 'AMeatHook::WasSurvivorStruggleCancelled' has a wrong offset!");
static_assert(offsetof(AMeatHook, IsSacrificeEnabled) == 0x000411, "Member 'AMeatHook::IsSacrificeEnabled' has a wrong offset!");
static_assert(offsetof(AMeatHook, AIInteractionOffset) == 0x000418, "Member 'AMeatHook::AIInteractionOffset' has a wrong offset!");
static_assert(offsetof(AMeatHook, ClipRegions) == 0x000490, "Member 'AMeatHook::ClipRegions' has a wrong offset!");
static_assert(offsetof(AMeatHook, IsSurvivorStruggling) == 0x0004A0, "Member 'AMeatHook::IsSurvivorStruggling' has a wrong offset!");
static_assert(offsetof(AMeatHook, IsInBasement) == 0x0004A1, "Member 'AMeatHook::IsInBasement' has a wrong offset!");
static_assert(offsetof(AMeatHook, IsBreakable) == 0x0004A2, "Member 'AMeatHook::IsBreakable' has a wrong offset!");
static_assert(offsetof(AMeatHook, IsSabotageable) == 0x0004A3, "Member 'AMeatHook::IsSabotageable' has a wrong offset!");
static_assert(offsetof(AMeatHook, CanBeScourgeHook) == 0x0004A4, "Member 'AMeatHook::CanBeScourgeHook' has a wrong offset!");
static_assert(offsetof(AMeatHook, HookIdentityTag) == 0x0004A8, "Member 'AMeatHook::HookIdentityTag' has a wrong offset!");
static_assert(offsetof(AMeatHook, SnapHookedCharacter) == 0x0004B4, "Member 'AMeatHook::SnapHookedCharacter' has a wrong offset!");
static_assert(offsetof(AMeatHook, FullyHooked) == 0x0004B5, "Member 'AMeatHook::FullyHooked' has a wrong offset!");
static_assert(offsetof(AMeatHook, _struggleThreshold) == 0x0004B8, "Member 'AMeatHook::_struggleThreshold' has a wrong offset!");
static_assert(offsetof(AMeatHook, _characterPusher) == 0x0004C0, "Member 'AMeatHook::_characterPusher' has a wrong offset!");
static_assert(offsetof(AMeatHook, _slasherCollisionBlocker) == 0x0004C8, "Member 'AMeatHook::_slasherCollisionBlocker' has a wrong offset!");
static_assert(offsetof(AMeatHook, _conditionalSlasherCollisionBlocker) == 0x0004D0, "Member 'AMeatHook::_conditionalSlasherCollisionBlocker' has a wrong offset!");
static_assert(offsetof(AMeatHook, _conditionalSlasherCollisionBlockerPresenceTags) == 0x0004D8, "Member 'AMeatHook::_conditionalSlasherCollisionBlockerPresenceTags' has a wrong offset!");
static_assert(offsetof(AMeatHook, _stateTagsToApplyOnBeginPlay) == 0x0004F8, "Member 'AMeatHook::_stateTagsToApplyOnBeginPlay' has a wrong offset!");
static_assert(offsetof(AMeatHook, _sacrificedHookRespawnDuration) == 0x000518, "Member 'AMeatHook::_sacrificedHookRespawnDuration' has a wrong offset!");
static_assert(offsetof(AMeatHook, _eventListener) == 0x000540, "Member 'AMeatHook::_eventListener' has a wrong offset!");
static_assert(offsetof(AMeatHook, _hookedSurvivor) == 0x000548, "Member 'AMeatHook::_hookedSurvivor' has a wrong offset!");
static_assert(offsetof(AMeatHook, _hookBreakerPlayer) == 0x000550, "Member 'AMeatHook::_hookBreakerPlayer' has a wrong offset!");
static_assert(offsetof(AMeatHook, _campersThatSabotagedMeatHook) == 0x0005C0, "Member 'AMeatHook::_campersThatSabotagedMeatHook' has a wrong offset!");
static_assert(offsetof(AMeatHook, _mainInteractor) == 0x000610, "Member 'AMeatHook::_mainInteractor' has a wrong offset!");
static_assert(offsetof(AMeatHook, _unhook) == 0x000618, "Member 'AMeatHook::_unhook' has a wrong offset!");
static_assert(offsetof(AMeatHook, _camperHookedSnapTransform) == 0x000620, "Member 'AMeatHook::_camperHookedSnapTransform' has a wrong offset!");
static_assert(offsetof(AMeatHook, _entity) == 0x000628, "Member 'AMeatHook::_entity' has a wrong offset!");
static_assert(offsetof(AMeatHook, _perceptionStimuliComponent) == 0x000650, "Member 'AMeatHook::_perceptionStimuliComponent' has a wrong offset!");
static_assert(offsetof(AMeatHook, _interactingPlayer) == 0x000658, "Member 'AMeatHook::_interactingPlayer' has a wrong offset!");
static_assert(offsetof(AMeatHook, _cachedMapActor) == 0x000660, "Member 'AMeatHook::_cachedMapActor' has a wrong offset!");

// Class DeadByDaylight.MeatHookAnimInstance
// 0x0010 (0x0360 - 0x0350)
class UMeatHookAnimInstance : public UAnimInstance
{
public:
	bool                                          IsBroken;                                          // 0x0350(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_351[0x3];                                      // 0x0351(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Yaw;                                               // 0x0354(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsSurvivorStruggling;                              // 0x0358(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_359[0x7];                                      // 0x0359(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MeatHookAnimInstance">();
	}
	static class UMeatHookAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMeatHookAnimInstance>();
	}
};
static_assert(alignof(UMeatHookAnimInstance) == 0x000010, "Wrong alignment on UMeatHookAnimInstance");
static_assert(sizeof(UMeatHookAnimInstance) == 0x000360, "Wrong size on UMeatHookAnimInstance");
static_assert(offsetof(UMeatHookAnimInstance, IsBroken) == 0x000350, "Member 'UMeatHookAnimInstance::IsBroken' has a wrong offset!");
static_assert(offsetof(UMeatHookAnimInstance, Yaw) == 0x000354, "Member 'UMeatHookAnimInstance::Yaw' has a wrong offset!");
static_assert(offsetof(UMeatHookAnimInstance, IsSurvivorStruggling) == 0x000358, "Member 'UMeatHookAnimInstance::IsSurvivorStruggling' has a wrong offset!");

// Class DeadByDaylight.MeatHookEntityVisibilityComponent
// 0x0030 (0x00D8 - 0x00A8)
class UMeatHookEntityVisibilityComponent final : public UActorComponent
{
public:
	class AEntity*                                _entity;                                           // 0x00A8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B0[0x1C];                                      // 0x00B0(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _entityReappearSpeed;                              // 0x00CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _entityDisappearSpeed;                             // 0x00D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MeatHookEntityVisibilityComponent">();
	}
	static class UMeatHookEntityVisibilityComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMeatHookEntityVisibilityComponent>();
	}
};
static_assert(alignof(UMeatHookEntityVisibilityComponent) == 0x000008, "Wrong alignment on UMeatHookEntityVisibilityComponent");
static_assert(sizeof(UMeatHookEntityVisibilityComponent) == 0x0000D8, "Wrong size on UMeatHookEntityVisibilityComponent");
static_assert(offsetof(UMeatHookEntityVisibilityComponent, _entity) == 0x0000A8, "Member 'UMeatHookEntityVisibilityComponent::_entity' has a wrong offset!");
static_assert(offsetof(UMeatHookEntityVisibilityComponent, _entityReappearSpeed) == 0x0000CC, "Member 'UMeatHookEntityVisibilityComponent::_entityReappearSpeed' has a wrong offset!");
static_assert(offsetof(UMeatHookEntityVisibilityComponent, _entityDisappearSpeed) == 0x0000D0, "Member 'UMeatHookEntityVisibilityComponent::_entityDisappearSpeed' has a wrong offset!");

// Class DeadByDaylight.MeatHookStateMachine
// 0x0000 (0x0120 - 0x0120)
class UMeatHookStateMachine final : public UStateMachine
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MeatHookStateMachine">();
	}
	static class UMeatHookStateMachine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMeatHookStateMachine>();
	}
};
static_assert(alignof(UMeatHookStateMachine) == 0x000010, "Wrong alignment on UMeatHookStateMachine");
static_assert(sizeof(UMeatHookStateMachine) == 0x000120, "Wrong size on UMeatHookStateMachine");

// Class DeadByDaylight.MemoryTracker
// 0x0000 (0x02A0 - 0x02A0)
class AMemoryTracker final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MemoryTracker">();
	}
	static class AMemoryTracker* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMemoryTracker>();
	}
};
static_assert(alignof(AMemoryTracker) == 0x000008, "Wrong alignment on AMemoryTracker");
static_assert(sizeof(AMemoryTracker) == 0x0002A0, "Wrong size on AMemoryTracker");

// Class DeadByDaylight.MenuAssetLibrary
// 0x0010 (0x0130 - 0x0120)
class UMenuAssetLibrary final : public UItemsAssetLibrary
{
public:
	uint8                                         Pad_120[0x10];                                     // 0x0120(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MenuAssetLibrary">();
	}
	static class UMenuAssetLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMenuAssetLibrary>();
	}
};
static_assert(alignof(UMenuAssetLibrary) == 0x000008, "Wrong alignment on UMenuAssetLibrary");
static_assert(sizeof(UMenuAssetLibrary) == 0x000130, "Wrong size on UMenuAssetLibrary");

// Class DeadByDaylight.MenuCameraActor
// 0x0100 (0x0AB0 - 0x09B0)
class AMenuCameraActor : public ACameraActor
{
public:
	uint8                                         Pad_9B0[0x100];                                    // 0x09B0(0x0100)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CanTransition();
	void K2_TransitionFinished(EDBDCameraViewType View);
	void K2_TransitionStarted(EDBDCameraViewType View);

	EDBDCameraViewType GetActiveView() const;
	struct FMenuCameraView GetTransitionInitView() const;
	struct FMenuCameraView GetTransitionTargetView() const;
	bool TransitionInProgress() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MenuCameraActor">();
	}
	static class AMenuCameraActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMenuCameraActor>();
	}
};
static_assert(alignof(AMenuCameraActor) == 0x000010, "Wrong alignment on AMenuCameraActor");
static_assert(sizeof(AMenuCameraActor) == 0x000AB0, "Wrong size on AMenuCameraActor");

// Class DeadByDaylight.StartScreenBase
// 0x0000 (0x02A8 - 0x02A8)
class AStartScreenBase final : public ALevelScriptActor
{
public:
	void BeginDestroyTravelSequence();
	void TravelToMenu();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StartScreenBase">();
	}
	static class AStartScreenBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AStartScreenBase>();
	}
};
static_assert(alignof(AStartScreenBase) == 0x000008, "Wrong alignment on AStartScreenBase");
static_assert(sizeof(AStartScreenBase) == 0x0002A8, "Wrong size on AStartScreenBase");

// Class DeadByDaylight.MenuCameraDesignTunables
// 0x0060 (0x0098 - 0x0038)
class UMenuCameraDesignTunables final : public UDataAsset
{
public:
	TSubclassOf<class AMenuCameraActor>           CameraClass;                                       // 0x0038(0x0008)(Edit, ZeroConstructor, NoClear, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            TransitionCurve;                                   // 0x0040(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EDBDCameraViewType, struct FMenuCameraView> Views;                                             // 0x0048(0x0050)(Edit, EditFixedSize, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MenuCameraDesignTunables">();
	}
	static class UMenuCameraDesignTunables* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMenuCameraDesignTunables>();
	}
};
static_assert(alignof(UMenuCameraDesignTunables) == 0x000008, "Wrong alignment on UMenuCameraDesignTunables");
static_assert(sizeof(UMenuCameraDesignTunables) == 0x000098, "Wrong size on UMenuCameraDesignTunables");
static_assert(offsetof(UMenuCameraDesignTunables, CameraClass) == 0x000038, "Member 'UMenuCameraDesignTunables::CameraClass' has a wrong offset!");
static_assert(offsetof(UMenuCameraDesignTunables, TransitionCurve) == 0x000040, "Member 'UMenuCameraDesignTunables::TransitionCurve' has a wrong offset!");
static_assert(offsetof(UMenuCameraDesignTunables, Views) == 0x000048, "Member 'UMenuCameraDesignTunables::Views' has a wrong offset!");

// Class DeadByDaylight.MenuCameraSystem
// 0x00A0 (0x00D8 - 0x0038)
class UMenuCameraSystem final : public UWorldSubsystem
{
public:
	class UMenuCameraDesignTunables*              _tunables;                                         // 0x0038(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AMenuCameraActor*                       _cameraTarget;                                     // 0x0040(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<EDBDCameraViewType, class ACameraActor*> _reservedTargets;                                  // 0x0048(0x0050)(Transient, NativeAccessSpecifierPrivate)
	EDBDCameraViewType                            _currentViewType;                                  // 0x0098(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             _onTransitionStart;                                // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B0[0x18];                                      // 0x00B0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             _onTransitionFinishedBP;                           // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)

public:
	bool Transition(const struct FMenuCameraTransitionParams& Params_0);

	bool CanTransition() const;
	EDBDCameraViewType GetActiveViewType() const;
	class UCameraComponent* GetCamera() const;
	EDBDCameraViewType GetCurrentCameraViewType() const;
	struct FMenuCameraView GetTransitionInitView() const;
	struct FMenuCameraView GetTransitionTargetView() const;
	bool IsTransitionInProgress() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MenuCameraSystem">();
	}
	static class UMenuCameraSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMenuCameraSystem>();
	}
};
static_assert(alignof(UMenuCameraSystem) == 0x000008, "Wrong alignment on UMenuCameraSystem");
static_assert(sizeof(UMenuCameraSystem) == 0x0000D8, "Wrong size on UMenuCameraSystem");
static_assert(offsetof(UMenuCameraSystem, _tunables) == 0x000038, "Member 'UMenuCameraSystem::_tunables' has a wrong offset!");
static_assert(offsetof(UMenuCameraSystem, _cameraTarget) == 0x000040, "Member 'UMenuCameraSystem::_cameraTarget' has a wrong offset!");
static_assert(offsetof(UMenuCameraSystem, _reservedTargets) == 0x000048, "Member 'UMenuCameraSystem::_reservedTargets' has a wrong offset!");
static_assert(offsetof(UMenuCameraSystem, _currentViewType) == 0x000098, "Member 'UMenuCameraSystem::_currentViewType' has a wrong offset!");
static_assert(offsetof(UMenuCameraSystem, _onTransitionStart) == 0x0000A0, "Member 'UMenuCameraSystem::_onTransitionStart' has a wrong offset!");
static_assert(offsetof(UMenuCameraSystem, _onTransitionFinishedBP) == 0x0000C8, "Member 'UMenuCameraSystem::_onTransitionFinishedBP' has a wrong offset!");

// Class DeadByDaylight.SlasherStateMachine
// 0x0000 (0x0120 - 0x0120)
class USlasherStateMachine final : public UPlayerStateMachine
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SlasherStateMachine">();
	}
	static class USlasherStateMachine* GetDefaultObj()
	{
		return GetDefaultObjImpl<USlasherStateMachine>();
	}
};
static_assert(alignof(USlasherStateMachine) == 0x000010, "Wrong alignment on USlasherStateMachine");
static_assert(sizeof(USlasherStateMachine) == 0x000120, "Wrong size on USlasherStateMachine");

// Class DeadByDaylight.MenuMeatHook
// 0x0028 (0x02C8 - 0x02A0)
class AMenuMeatHook final : public AActor
{
public:
	uint8                                         Pad_2A0[0x10];                                     // 0x02A0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UCharmSpawnerComponent*                 _charmSpawnerComponent;                            // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B8[0x10];                                     // 0x02B8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BeginDestroySequence_Internal();
	void OnCharmsUpdated(const TArray<struct FCharmIdSlot>& CharmIDs);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MenuMeatHook">();
	}
	static class AMenuMeatHook* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMenuMeatHook>();
	}
};
static_assert(alignof(AMenuMeatHook) == 0x000008, "Wrong alignment on AMenuMeatHook");
static_assert(sizeof(AMenuMeatHook) == 0x0002C8, "Wrong size on AMenuMeatHook");
static_assert(offsetof(AMenuMeatHook, _charmSpawnerComponent) == 0x0002B0, "Member 'AMenuMeatHook::_charmSpawnerComponent' has a wrong offset!");

// Class DeadByDaylight.MenuUtilities
// 0x0000 (0x0030 - 0x0030)
class UMenuUtilities final : public UBlueprintFunctionLibrary
{
public:
	static bool AreAllGuestCharactersReady();
	static TArray<class ADBDMenuPlayer*> GetAllMenuCharacters();
	static class ADBDMenuPlayer* GetLocalPlayerCharacter(const class UObject* ContextObject);
	static class UMenuCameraSystem* GetMenuCameraSystem(const class UObject* ContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MenuUtilities">();
	}
	static class UMenuUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMenuUtilities>();
	}
};
static_assert(alignof(UMenuUtilities) == 0x000008, "Wrong alignment on UMenuUtilities");
static_assert(sizeof(UMenuUtilities) == 0x000030, "Wrong size on UMenuUtilities");

// Class DeadByDaylight.MigrationSubsystem
// 0x0058 (0x0090 - 0x0038)
class UMigrationSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x58];                                      // 0x0038(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MigrationSubsystem">();
	}
	static class UMigrationSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMigrationSubsystem>();
	}
};
static_assert(alignof(UMigrationSubsystem) == 0x000008, "Wrong alignment on UMigrationSubsystem");
static_assert(sizeof(UMigrationSubsystem) == 0x000090, "Wrong size on UMigrationSubsystem");

// Class DeadByDaylight.MoriableComponent
// 0x00C8 (0x0170 - 0x00A8)
class UMoriableComponent final : public UActorComponent
{
public:
	TArray<class UInteractionDefinition*>         _moriInteractions;                                 // 0x00A8(0x0010)(ExportObject, Net, ZeroConstructor, Transient, RepNotify, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UStatusEffect>              _disruptAuraReadingStatusEffect;                   // 0x00B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C0[0xB0];                                      // 0x00C0(0x00B0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnMoriFinished(bool HasBeenKilledByMori);
	void OnMoriUpdateStart();
	void OnRep_MoriInteractions();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoriableComponent">();
	}
	static class UMoriableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoriableComponent>();
	}
};
static_assert(alignof(UMoriableComponent) == 0x000008, "Wrong alignment on UMoriableComponent");
static_assert(sizeof(UMoriableComponent) == 0x000170, "Wrong size on UMoriableComponent");
static_assert(offsetof(UMoriableComponent, _moriInteractions) == 0x0000A8, "Member 'UMoriableComponent::_moriInteractions' has a wrong offset!");
static_assert(offsetof(UMoriableComponent, _disruptAuraReadingStatusEffect) == 0x0000B8, "Member 'UMoriableComponent::_disruptAuraReadingStatusEffect' has a wrong offset!");

// Class DeadByDaylight.MoriComponent
// 0x00F8 (0x01A0 - 0x00A8)
class UMoriComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x18];                                      // 0x00A8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnMoriBegin;                                       // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnMoriEnd;                                         // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UInteractionDefinition>> _moriInteractionClasses;                           // 0x00E0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F0[0x8];                                       // 0x00F0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UStatusEffect>              _disruptAuraReadingStatusEffect;                   // 0x00F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_100[0xA0];                                     // 0x0100(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnMoriChargeCompleted(class ACamperPlayer* SurvivorTarget);
	void OnMoriFinished();
	void OnMoriStateChanged__DelegateSignature();
	void OnMoriUpdateStart();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoriComponent">();
	}
	static class UMoriComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoriComponent>();
	}
};
static_assert(alignof(UMoriComponent) == 0x000008, "Wrong alignment on UMoriComponent");
static_assert(sizeof(UMoriComponent) == 0x0001A0, "Wrong size on UMoriComponent");
static_assert(offsetof(UMoriComponent, OnMoriBegin) == 0x0000C0, "Member 'UMoriComponent::OnMoriBegin' has a wrong offset!");
static_assert(offsetof(UMoriComponent, OnMoriEnd) == 0x0000D0, "Member 'UMoriComponent::OnMoriEnd' has a wrong offset!");
static_assert(offsetof(UMoriComponent, _moriInteractionClasses) == 0x0000E0, "Member 'UMoriComponent::_moriInteractionClasses' has a wrong offset!");
static_assert(offsetof(UMoriComponent, _disruptAuraReadingStatusEffect) == 0x0000F8, "Member 'UMoriComponent::_disruptAuraReadingStatusEffect' has a wrong offset!");

// Class DeadByDaylight.MovementModifierActor
// 0x0008 (0x02A8 - 0x02A0)
class AMovementModifierActor final : public AActor
{
public:
	float                                         MaxSpeedMultiplier;                                // 0x02A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A4[0x4];                                      // 0x02A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovementModifierActor">();
	}
	static class AMovementModifierActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMovementModifierActor>();
	}
};
static_assert(alignof(AMovementModifierActor) == 0x000008, "Wrong alignment on AMovementModifierActor");
static_assert(sizeof(AMovementModifierActor) == 0x0002A8, "Wrong size on AMovementModifierActor");
static_assert(offsetof(AMovementModifierActor, MaxSpeedMultiplier) == 0x0002A0, "Member 'AMovementModifierActor::MaxSpeedMultiplier' has a wrong offset!");

// Class DeadByDaylight.MultipleLightsFader
// 0x0028 (0x02C8 - 0x02A0)
class AMultipleLightsFader : public AActor
{
public:
	TArray<class ULightComponent*>                _affectedLights;                                   // 0x02A0(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<float>                                 _lightOriginalIntensities;                         // 0x02B0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	float                                         _timeMultiplier;                                   // 0x02C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C4[0x4];                                      // 0x02C4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetAffectedLights(const TArray<class ULightComponent*>& AffectedLights);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MultipleLightsFader">();
	}
	static class AMultipleLightsFader* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMultipleLightsFader>();
	}
};
static_assert(alignof(AMultipleLightsFader) == 0x000008, "Wrong alignment on AMultipleLightsFader");
static_assert(sizeof(AMultipleLightsFader) == 0x0002C8, "Wrong size on AMultipleLightsFader");
static_assert(offsetof(AMultipleLightsFader, _affectedLights) == 0x0002A0, "Member 'AMultipleLightsFader::_affectedLights' has a wrong offset!");
static_assert(offsetof(AMultipleLightsFader, _lightOriginalIntensities) == 0x0002B0, "Member 'AMultipleLightsFader::_lightOriginalIntensities' has a wrong offset!");
static_assert(offsetof(AMultipleLightsFader, _timeMultiplier) == 0x0002C0, "Member 'AMultipleLightsFader::_timeMultiplier' has a wrong offset!");

// Class DeadByDaylight.Mutator
// 0x0010 (0x0040 - 0x0030)
class UMutator : public UObject
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Mutator">();
	}
	static class UMutator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMutator>();
	}
};
static_assert(alignof(UMutator) == 0x000008, "Wrong alignment on UMutator");
static_assert(sizeof(UMutator) == 0x000040, "Wrong size on UMutator");

// Class DeadByDaylight.MutatorSpawnerComponent
// 0x0018 (0x00F8 - 0x00E0)
class UMutatorSpawnerComponent final : public UGameplaySpawnerComponent
{
public:
	TArray<class UMutator*>                       _spawnedMutators;                                  // 0x00E0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F0[0x8];                                       // 0x00F0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MutatorSpawnerComponent">();
	}
	static class UMutatorSpawnerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMutatorSpawnerComponent>();
	}
};
static_assert(alignof(UMutatorSpawnerComponent) == 0x000008, "Wrong alignment on UMutatorSpawnerComponent");
static_assert(sizeof(UMutatorSpawnerComponent) == 0x0000F8, "Wrong size on UMutatorSpawnerComponent");
static_assert(offsetof(UMutatorSpawnerComponent, _spawnedMutators) == 0x0000E0, "Member 'UMutatorSpawnerComponent::_spawnedMutators' has a wrong offset!");

// Class DeadByDaylight.MysteryBoxSubsystem
// 0x0178 (0x01B0 - 0x0038)
class UMysteryBoxSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x178];                                     // 0x0038(0x0178)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnGameInstanceInitialized();
	void OnNextClaimTimeTimerElapsed(const class FString& Campaign);
	void OnTimeTravel(bool Success, const class FString& Date);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MysteryBoxSubsystem">();
	}
	static class UMysteryBoxSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMysteryBoxSubsystem>();
	}
};
static_assert(alignof(UMysteryBoxSubsystem) == 0x000008, "Wrong alignment on UMysteryBoxSubsystem");
static_assert(sizeof(UMysteryBoxSubsystem) == 0x0001B0, "Wrong size on UMysteryBoxSubsystem");

// Class DeadByDaylight.NatAudioAmbienceBox
// 0x0010 (0x05E0 - 0x05D0)
class UNatAudioAmbienceBox final : public UAmbienceBoxComponent
{
public:
	class UAkAudioEvent*                          _onBeginOverlapAudioEvent;                         // 0x05D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          _onEndOverlapAudioEvent;                           // 0x05D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnBeginOverlapAudioAmbience(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnEndOverlapAudioAmbience(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NatAudioAmbienceBox">();
	}
	static class UNatAudioAmbienceBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNatAudioAmbienceBox>();
	}
};
static_assert(alignof(UNatAudioAmbienceBox) == 0x000010, "Wrong alignment on UNatAudioAmbienceBox");
static_assert(sizeof(UNatAudioAmbienceBox) == 0x0005E0, "Wrong size on UNatAudioAmbienceBox");
static_assert(offsetof(UNatAudioAmbienceBox, _onBeginOverlapAudioEvent) == 0x0005D0, "Member 'UNatAudioAmbienceBox::_onBeginOverlapAudioEvent' has a wrong offset!");
static_assert(offsetof(UNatAudioAmbienceBox, _onEndOverlapAudioEvent) == 0x0005D8, "Member 'UNatAudioAmbienceBox::_onEndOverlapAudioEvent' has a wrong offset!");

// Class DeadByDaylight.NatAudioCustomMesh
// 0x0010 (0x0690 - 0x0680)
class UNatAudioCustomMesh final : public UAudioCustomMeshComponent
{
public:
	class UAkAudioEvent*                          _onBeginOverlapAudioEvent;                         // 0x0678(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          _onEndOverlapAudioEvent;                           // 0x0680(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_688[0x8];                                      // 0x0688(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnBeginOverlapAudioMesh(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnEndOverlapAudioMesh(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NatAudioCustomMesh">();
	}
	static class UNatAudioCustomMesh* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNatAudioCustomMesh>();
	}
};
static_assert(alignof(UNatAudioCustomMesh) == 0x000010, "Wrong alignment on UNatAudioCustomMesh");
static_assert(sizeof(UNatAudioCustomMesh) == 0x000690, "Wrong size on UNatAudioCustomMesh");
static_assert(offsetof(UNatAudioCustomMesh, _onBeginOverlapAudioEvent) == 0x000678, "Member 'UNatAudioCustomMesh::_onBeginOverlapAudioEvent' has a wrong offset!");
static_assert(offsetof(UNatAudioCustomMesh, _onEndOverlapAudioEvent) == 0x000680, "Member 'UNatAudioCustomMesh::_onEndOverlapAudioEvent' has a wrong offset!");

// Class DeadByDaylight.NavArea_BearTrap
// 0x0000 (0x0050 - 0x0050)
class UNavArea_BearTrap final : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavArea_BearTrap">();
	}
	static class UNavArea_BearTrap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavArea_BearTrap>();
	}
};
static_assert(alignof(UNavArea_BearTrap) == 0x000008, "Wrong alignment on UNavArea_BearTrap");
static_assert(sizeof(UNavArea_BearTrap) == 0x000050, "Wrong size on UNavArea_BearTrap");

// Class DeadByDaylight.StalkerComponent
// 0x0078 (0x0120 - 0x00A8)
class UStalkerComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x28];                                      // 0x00A8(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _distributeStalkRate;                              // 0x00D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _canStalkWhileInChase;                             // 0x00D1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D2[0x6];                                       // 0x00D2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UStalkedComponent*>              _playerStalkedComponents;                          // 0x00D8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E8[0x10];                                      // 0x00E8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UChargeableComponent*                   _stalkPointsChargeable;                            // 0x00F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_100[0x20];                                     // 0x0100(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPlayerBeingStalkedChanged(bool IsBeingStalked);
	void OnStalkPointsAdded__DelegateSignature(float StalkPoints);

	bool CanStalk() const;
	float GetMaxStalkingPoints() const;
	float GetPercentStalkingPoints() const;
	float GetScoreMultiplier() const;
	float GetTotalStalkingPoints() const;
	bool HasMaxStalkPoints() const;
	bool IsStalkingSomeone() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StalkerComponent">();
	}
	static class UStalkerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStalkerComponent>();
	}
};
static_assert(alignof(UStalkerComponent) == 0x000008, "Wrong alignment on UStalkerComponent");
static_assert(sizeof(UStalkerComponent) == 0x000120, "Wrong size on UStalkerComponent");
static_assert(offsetof(UStalkerComponent, _distributeStalkRate) == 0x0000D0, "Member 'UStalkerComponent::_distributeStalkRate' has a wrong offset!");
static_assert(offsetof(UStalkerComponent, _canStalkWhileInChase) == 0x0000D1, "Member 'UStalkerComponent::_canStalkWhileInChase' has a wrong offset!");
static_assert(offsetof(UStalkerComponent, _playerStalkedComponents) == 0x0000D8, "Member 'UStalkerComponent::_playerStalkedComponents' has a wrong offset!");
static_assert(offsetof(UStalkerComponent, _stalkPointsChargeable) == 0x0000F8, "Member 'UStalkerComponent::_stalkPointsChargeable' has a wrong offset!");

// Class DeadByDaylight.NavArea_Danger
// 0x0000 (0x0050 - 0x0050)
class UNavArea_Danger final : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavArea_Danger">();
	}
	static class UNavArea_Danger* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavArea_Danger>();
	}
};
static_assert(alignof(UNavArea_Danger) == 0x000008, "Wrong alignment on UNavArea_Danger");
static_assert(sizeof(UNavArea_Danger) == 0x000050, "Wrong size on UNavArea_Danger");

// Class DeadByDaylight.NavArea_Slasher
// 0x0000 (0x0050 - 0x0050)
class UNavArea_Slasher final : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavArea_Slasher">();
	}
	static class UNavArea_Slasher* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavArea_Slasher>();
	}
};
static_assert(alignof(UNavArea_Slasher) == 0x000008, "Wrong alignment on UNavArea_Slasher");
static_assert(sizeof(UNavArea_Slasher) == 0x000050, "Wrong size on UNavArea_Slasher");

// Class DeadByDaylight.NavArea_Turret
// 0x0000 (0x0050 - 0x0050)
class UNavArea_Turret final : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavArea_Turret">();
	}
	static class UNavArea_Turret* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavArea_Turret>();
	}
};
static_assert(alignof(UNavArea_Turret) == 0x000008, "Wrong alignment on UNavArea_Turret");
static_assert(sizeof(UNavArea_Turret) == 0x000050, "Wrong size on UNavArea_Turret");

// Class DeadByDaylight.NavigationScreen
// 0x01A8 (0x02D0 - 0x0128)
class UNavigationScreen final : public UScreenBase
{
public:
	uint8                                         Pad_128[0x1A8];                                    // 0x0128(0x01A8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAddPlayerClick(int32 buttonId);
	void OnBankClick(int32 CurrencyTypeInt);
	void OnCancelButtonClick();
	void OnCharacterSwapArrowClick(bool IsNext);
	void OnChatInputMouseOver(bool IsMouseOver);
	void OnDailyRitualsClick();
	void OnFadeOutEnded();
	void OnInviteFriendClick();
	void OnMatchMakingBanTimeout();
	void OnMatchManagementButtonClick();
	void OnPerkPreviewPerkSlotClicked(int32 SlotIndex);
	void OnPlayerInfoClick(int32 PlayerId);
	void OnPlayerOptionSelected(const class FString& KrakenId, const class FString& PlayerId, uint8 Option);
	void OnReadyButtonClick();
	void OnSendChatMsgButtonClick(const class FString& Message);
	void OnSettingsClick();
	void OnToggleChatVisibility();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavigationScreen">();
	}
	static class UNavigationScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavigationScreen>();
	}
};
static_assert(alignof(UNavigationScreen) == 0x000008, "Wrong alignment on UNavigationScreen");
static_assert(sizeof(UNavigationScreen) == 0x0002D0, "Wrong size on UNavigationScreen");

// Class DeadByDaylight.NavigationStateComponent
// 0x0110 (0x01B8 - 0x00A8)
class UNavigationStateComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x4B];                                      // 0x00A8(0x004B)(Fixing Size After Last Property [ Dumper-7 ])
	EImmobilizedState                             _immobilizedState;                                 // 0x00F3(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F4[0x4];                                       // 0x00F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGuidingInfo                           _guidedState;                                      // 0x00F8(0x0018)(Net, RepNotify, NativeAccessSpecifierPrivate)
	uint8                                         Pad_110[0x98];                                     // 0x0110(0x0098)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ADBDPlayer*>                     _local_oldGuidedPlayers;                           // 0x01A8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	void OnControllerChanged(class APawn* Pawn, class AController* OldController, class AController* NewController);
	void OnRep_GuidedState(const struct FGuidingInfo& PreviousState);
	void OnRep_ImmobilizedState(EImmobilizedState PreviousState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavigationStateComponent">();
	}
	static class UNavigationStateComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavigationStateComponent>();
	}
};
static_assert(alignof(UNavigationStateComponent) == 0x000008, "Wrong alignment on UNavigationStateComponent");
static_assert(sizeof(UNavigationStateComponent) == 0x0001B8, "Wrong size on UNavigationStateComponent");
static_assert(offsetof(UNavigationStateComponent, _immobilizedState) == 0x0000F3, "Member 'UNavigationStateComponent::_immobilizedState' has a wrong offset!");
static_assert(offsetof(UNavigationStateComponent, _guidedState) == 0x0000F8, "Member 'UNavigationStateComponent::_guidedState' has a wrong offset!");
static_assert(offsetof(UNavigationStateComponent, _local_oldGuidedPlayers) == 0x0001A8, "Member 'UNavigationStateComponent::_local_oldGuidedPlayers' has a wrong offset!");

// Class DeadByDaylight.NewContentPopupScreen
// 0x0000 (0x0148 - 0x0148)
class UNewContentPopupScreen final : public UGenericPopupScreen
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NewContentPopupScreen">();
	}
	static class UNewContentPopupScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNewContentPopupScreen>();
	}
};
static_assert(alignof(UNewContentPopupScreen) == 0x000008, "Wrong alignment on UNewContentPopupScreen");
static_assert(sizeof(UNewContentPopupScreen) == 0x000148, "Wrong size on UNewContentPopupScreen");

// Class DeadByDaylight.NewsContentManager
// 0x00D0 (0x0100 - 0x0030)
class UNewsContentManager final : public UObject
{
public:
	uint8                                         Pad_30[0x18];                                      // 0x0030(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UDBDGameInstance>        _gameInstance;                                     // 0x0048(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_50[0xB0];                                      // 0x0050(0x00B0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NewsContentManager">();
	}
	static class UNewsContentManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNewsContentManager>();
	}
};
static_assert(alignof(UNewsContentManager) == 0x000008, "Wrong alignment on UNewsContentManager");
static_assert(sizeof(UNewsContentManager) == 0x000100, "Wrong size on UNewsContentManager");
static_assert(offsetof(UNewsContentManager, _gameInstance) == 0x000048, "Member 'UNewsContentManager::_gameInstance' has a wrong offset!");

// Class DeadByDaylight.NoAccumulationSpawnerStrategy
// 0x0000 (0x0030 - 0x0030)
class UNoAccumulationSpawnerStrategy final : public USpawnerStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NoAccumulationSpawnerStrategy">();
	}
	static class UNoAccumulationSpawnerStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNoAccumulationSpawnerStrategy>();
	}
};
static_assert(alignof(UNoAccumulationSpawnerStrategy) == 0x000008, "Wrong alignment on UNoAccumulationSpawnerStrategy");
static_assert(sizeof(UNoAccumulationSpawnerStrategy) == 0x000030, "Wrong size on UNoAccumulationSpawnerStrategy");

// Class DeadByDaylight.ObjectiveScreenIndicatorWorldMarkerComponent
// 0x0000 (0x02E0 - 0x02E0)
class UObjectiveScreenIndicatorWorldMarkerComponent final : public UScreenIndicatorWorldMarkerComponent
{
public:
	class UTexture2D*                             IndicatorHudScreenIcon;                            // 0x02D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ObjectiveScreenIndicatorWorldMarkerComponent">();
	}
	static class UObjectiveScreenIndicatorWorldMarkerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UObjectiveScreenIndicatorWorldMarkerComponent>();
	}
};
static_assert(alignof(UObjectiveScreenIndicatorWorldMarkerComponent) == 0x000010, "Wrong alignment on UObjectiveScreenIndicatorWorldMarkerComponent");
static_assert(sizeof(UObjectiveScreenIndicatorWorldMarkerComponent) == 0x0002E0, "Wrong size on UObjectiveScreenIndicatorWorldMarkerComponent");
static_assert(offsetof(UObjectiveScreenIndicatorWorldMarkerComponent, IndicatorHudScreenIcon) == 0x0002D8, "Member 'UObjectiveScreenIndicatorWorldMarkerComponent::IndicatorHudScreenIcon' has a wrong offset!");

// Class DeadByDaylight.AlwaysUseCurrentLocationPlacementStrategy
// 0x0000 (0x0068 - 0x0068)
class UAlwaysUseCurrentLocationPlacementStrategy final : public UObjectPlacementUpdateStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AlwaysUseCurrentLocationPlacementStrategy">();
	}
	static class UAlwaysUseCurrentLocationPlacementStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAlwaysUseCurrentLocationPlacementStrategy>();
	}
};
static_assert(alignof(UAlwaysUseCurrentLocationPlacementStrategy) == 0x000008, "Wrong alignment on UAlwaysUseCurrentLocationPlacementStrategy");
static_assert(sizeof(UAlwaysUseCurrentLocationPlacementStrategy) == 0x000068, "Wrong size on UAlwaysUseCurrentLocationPlacementStrategy");

// Class DeadByDaylight.StoreControllerSubsystem
// 0x0008 (0x0040 - 0x0038)
class UStoreControllerSubsystem final : public UGameInstanceSubsystem
{
public:
	class UStoreDisplayStandController*           _displayStandController;                           // 0x0038(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StoreControllerSubsystem">();
	}
	static class UStoreControllerSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStoreControllerSubsystem>();
	}
};
static_assert(alignof(UStoreControllerSubsystem) == 0x000008, "Wrong alignment on UStoreControllerSubsystem");
static_assert(sizeof(UStoreControllerSubsystem) == 0x000040, "Wrong size on UStoreControllerSubsystem");
static_assert(offsetof(UStoreControllerSubsystem, _displayStandController) == 0x000038, "Member 'UStoreControllerSubsystem::_displayStandController' has a wrong offset!");

// Class DeadByDaylight.NavMeshObjectPlacementValidationStrategy
// 0x0008 (0x0100 - 0x00F8)
class UNavMeshObjectPlacementValidationStrategy final : public UDefaultObjectPlacementValidationStrategy
{
public:
	float                                         _navPathMaxLength;                                 // 0x00F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_FC[0x4];                                       // 0x00FC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavMeshObjectPlacementValidationStrategy">();
	}
	static class UNavMeshObjectPlacementValidationStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavMeshObjectPlacementValidationStrategy>();
	}
};
static_assert(alignof(UNavMeshObjectPlacementValidationStrategy) == 0x000008, "Wrong alignment on UNavMeshObjectPlacementValidationStrategy");
static_assert(sizeof(UNavMeshObjectPlacementValidationStrategy) == 0x000100, "Wrong size on UNavMeshObjectPlacementValidationStrategy");
static_assert(offsetof(UNavMeshObjectPlacementValidationStrategy, _navPathMaxLength) == 0x0000F8, "Member 'UNavMeshObjectPlacementValidationStrategy::_navPathMaxLength' has a wrong offset!");

// Class DeadByDaylight.OfferingCardAnim
// 0x0020 (0x0370 - 0x0350)
class UOfferingCardAnim final : public UAnimInstance
{
public:
	FMulticastInlineDelegateProperty_             _onCardDissolved;                                  // 0x0350(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPrivate)
	EOfferingAnimState                            _activeState;                                      // 0x0360(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isRevealed;                                       // 0x0361(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_362[0xE];                                      // 0x0362(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OfferingCardAnim">();
	}
	static class UOfferingCardAnim* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOfferingCardAnim>();
	}
};
static_assert(alignof(UOfferingCardAnim) == 0x000010, "Wrong alignment on UOfferingCardAnim");
static_assert(sizeof(UOfferingCardAnim) == 0x000370, "Wrong size on UOfferingCardAnim");
static_assert(offsetof(UOfferingCardAnim, _onCardDissolved) == 0x000350, "Member 'UOfferingCardAnim::_onCardDissolved' has a wrong offset!");
static_assert(offsetof(UOfferingCardAnim, _activeState) == 0x000360, "Member 'UOfferingCardAnim::_activeState' has a wrong offset!");
static_assert(offsetof(UOfferingCardAnim, _isRevealed) == 0x000361, "Member 'UOfferingCardAnim::_isRevealed' has a wrong offset!");

// Class DeadByDaylight.OfferingCard
// 0x0020 (0x02C0 - 0x02A0)
class AOfferingCard final : public AActor
{
public:
	TArray<struct FRarityTexture>                 _rarityTextures;                                   // 0x02A0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FOfferingTypeTexture>           _offeringTypeTextures;                             // 0x02B0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	void ChangeAnimationClass(const TSubclassOf<class UOfferingCardAnim>& AnimationClass);
	void ChangeState(EOfferingAnimState State);
	void HandleCardDissolved();
	void HandleStateChanged(EOfferingAnimState State);

	class UOfferingCardAnim* GetCardAnimation() const;
	EOfferingAnimState GetState() const;
	bool IsRevealed() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OfferingCard">();
	}
	static class AOfferingCard* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOfferingCard>();
	}
};
static_assert(alignof(AOfferingCard) == 0x000008, "Wrong alignment on AOfferingCard");
static_assert(sizeof(AOfferingCard) == 0x0002C0, "Wrong size on AOfferingCard");
static_assert(offsetof(AOfferingCard, _rarityTextures) == 0x0002A0, "Member 'AOfferingCard::_rarityTextures' has a wrong offset!");
static_assert(offsetof(AOfferingCard, _offeringTypeTextures) == 0x0002B0, "Member 'AOfferingCard::_offeringTypeTextures' has a wrong offset!");

// Class DeadByDaylight.OfferingHandler
// 0x0018 (0x0048 - 0x0030)
class UOfferingHandler final : public UObject
{
public:
	class UDBDGameInstance*                       _gameInstance;                                     // 0x0030(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class FName>                           _levelPerkIDs;                                     // 0x0038(0x0010)(Net, ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OfferingHandler">();
	}
	static class UOfferingHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOfferingHandler>();
	}
};
static_assert(alignof(UOfferingHandler) == 0x000008, "Wrong alignment on UOfferingHandler");
static_assert(sizeof(UOfferingHandler) == 0x000048, "Wrong size on UOfferingHandler");
static_assert(offsetof(UOfferingHandler, _gameInstance) == 0x000030, "Member 'UOfferingHandler::_gameInstance' has a wrong offset!");
static_assert(offsetof(UOfferingHandler, _levelPerkIDs) == 0x000038, "Member 'UOfferingHandler::_levelPerkIDs' has a wrong offset!");

// Class DeadByDaylight.OfferingSequenceManager
// 0x00C0 (0x0360 - 0x02A0)
class AOfferingSequenceManager : public AActor
{
public:
	class UDBDGameInstance*                       _gameInstance;                                     // 0x02A0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APlayerController*                      _localPlayerController;                            // 0x02A8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOfferingHandler*                       _offeringHandler;                                  // 0x02B0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AOfferingSequenceAssets*                _sequenceAssets;                                   // 0x02B8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ADBDLobbyHud*                           _hud;                                              // 0x02C0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ACameraActor*                           _offeringCamera;                                   // 0x02C8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<uint8, class AOfferingCard*>             _spawnedCards;                                     // 0x02D0(0x0050)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_320[0x10];                                     // 0x0320(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AOfferingCard>              _defaultCardsClass;                                // 0x0330(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class AOfferingCard>              _eventCardsClass;                                  // 0x0338(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_340[0x20];                                     // 0x0340(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FadeInScreen();
	void HandleSequenceEnded();
	void HandleSequenceStarted();
	void HandleSequenceStateChanged(EOfferingSequenceState State);

	bool ContainsDefaultCard() const;
	bool ContainsEventCard() const;
	EOfferingSequenceState GetCurrentState() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OfferingSequenceManager">();
	}
	static class AOfferingSequenceManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOfferingSequenceManager>();
	}
};
static_assert(alignof(AOfferingSequenceManager) == 0x000008, "Wrong alignment on AOfferingSequenceManager");
static_assert(sizeof(AOfferingSequenceManager) == 0x000360, "Wrong size on AOfferingSequenceManager");
static_assert(offsetof(AOfferingSequenceManager, _gameInstance) == 0x0002A0, "Member 'AOfferingSequenceManager::_gameInstance' has a wrong offset!");
static_assert(offsetof(AOfferingSequenceManager, _localPlayerController) == 0x0002A8, "Member 'AOfferingSequenceManager::_localPlayerController' has a wrong offset!");
static_assert(offsetof(AOfferingSequenceManager, _offeringHandler) == 0x0002B0, "Member 'AOfferingSequenceManager::_offeringHandler' has a wrong offset!");
static_assert(offsetof(AOfferingSequenceManager, _sequenceAssets) == 0x0002B8, "Member 'AOfferingSequenceManager::_sequenceAssets' has a wrong offset!");
static_assert(offsetof(AOfferingSequenceManager, _hud) == 0x0002C0, "Member 'AOfferingSequenceManager::_hud' has a wrong offset!");
static_assert(offsetof(AOfferingSequenceManager, _offeringCamera) == 0x0002C8, "Member 'AOfferingSequenceManager::_offeringCamera' has a wrong offset!");
static_assert(offsetof(AOfferingSequenceManager, _spawnedCards) == 0x0002D0, "Member 'AOfferingSequenceManager::_spawnedCards' has a wrong offset!");
static_assert(offsetof(AOfferingSequenceManager, _defaultCardsClass) == 0x000330, "Member 'AOfferingSequenceManager::_defaultCardsClass' has a wrong offset!");
static_assert(offsetof(AOfferingSequenceManager, _eventCardsClass) == 0x000338, "Member 'AOfferingSequenceManager::_eventCardsClass' has a wrong offset!");

// Class DeadByDaylight.OfferingUtilities
// 0x0000 (0x0030 - 0x0030)
class UOfferingUtilities final : public UBlueprintFunctionLibrary
{
public:
	static bool HasItemLossProtection(const class ADBDPlayer* Player);
	static bool HasOfferingOfType(const class UObject* WorldContextObject, EOfferingEffectType OfferingEffectType, int32 PlayerId);
	static bool IsPlayerEquippedWithOfferingWithTag(const class ADBDPlayer* Player, const class FName OfferingTag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OfferingUtilities">();
	}
	static class UOfferingUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOfferingUtilities>();
	}
};
static_assert(alignof(UOfferingUtilities) == 0x000008, "Wrong alignment on UOfferingUtilities");
static_assert(sizeof(UOfferingUtilities) == 0x000030, "Wrong size on UOfferingUtilities");

// Class DeadByDaylight.StateTagUtilities
// 0x0000 (0x0030 - 0x0030)
class UStateTagUtilities final : public UBlueprintFunctionLibrary
{
public:
	static void AddStateTag(const TScriptInterface<class IObjectStateProvider> ObjectStateProvider, const struct FGameplayTag& Tag);
	static void AddStateTagToPlayer(const class ADBDPlayer* Player, const struct FGameplayTag& Tag);
	static void AddTagWithSource(const TScriptInterface<class IObjectStateProvider> ObjectStateProvider, const struct FGameplayTag& Tag, const class UObject* Source);
	static bool CurrentInteractionHasAnyStateTag(const class ADBDPlayer* Player, const struct FGameplayTagContainer& Tags);
	static bool CurrentInteractionHasStateTag(const class ADBDPlayer* Player, const struct FGameplayTag& Tag);
	static bool HasAnyStateTags(const TScriptInterface<class IObjectStateProvider> ObjectStateProvider, const struct FGameplayTagContainer& Tags);
	static bool HasStateTag(const TScriptInterface<class IObjectStateProvider> ObjectStateProvider, const struct FGameplayTag& Tag);
	static bool InteractionHasStateTag(const class UInteractionDefinition* Interaction, const struct FGameplayTag& Tag);
	static void RemoveStateTag(const TScriptInterface<class IObjectStateProvider> ObjectStateProvider, const struct FGameplayTag& Tag);
	static void RemoveStateTagToPlayer(const class ADBDPlayer* Player, const struct FGameplayTag& Tag);
	static void RemoveTagWithSource(const TScriptInterface<class IObjectStateProvider> ObjectStateProvider, const struct FGameplayTag& Tag, const class UObject* Source);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StateTagUtilities">();
	}
	static class UStateTagUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStateTagUtilities>();
	}
};
static_assert(alignof(UStateTagUtilities) == 0x000008, "Wrong alignment on UStateTagUtilities");
static_assert(sizeof(UStateTagUtilities) == 0x000030, "Wrong size on UStateTagUtilities");

// Class DeadByDaylight.OfflineLobbyLevel
// 0x0210 (0x0560 - 0x0350)
class AOfflineLobbyLevel final : public ALobbyLevel
{
public:
	struct FVector                                _partyLobbyInviteButtonOffset;                     // 0x0350(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TWeakObjectPtr<class APlayerStart>>    _roleSelectionCamperSpawns;                        // 0x0368(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<TWeakObjectPtr<class APlayerStart>>    _roleSelectionSlasherSpawns;                       // 0x0378(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class ADisplayStand>           _offlineLobbyLocalSlasherSpawn;                    // 0x0388(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                _partyLobbyEmptySlotFxOffset;                      // 0x0390(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class ADisplayStand>           _offlineLobbyLocalCamperSpawn;                     // 0x03A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FVector>                        _partyLobbySlasherPOVTrackerOffsets;               // 0x03B0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TSoftClassPtr<class UClass>                   _partyLobbyEmptySlotSilhouette;                    // 0x03C0(0x0038)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<TWeakObjectPtr<class ADisplayStand>>   _partyLobbySlasherDisplayStands;                   // 0x03F8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<TWeakObjectPtr<class ADisplayStand>>   _partyLobbyCamperDisplayStands;                    // 0x0408(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_418[0x10];                                     // 0x0418(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   _meatHookForCustomization;                         // 0x0428(0x0038)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class ATargetPoint>            _meatHookSpawn;                                    // 0x0460(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftClassPtr<class UClass>                   _charmForCustomizationZoom;                        // 0x0468(0x0038)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class ATargetPoint>            _camperCharmSpawn;                                 // 0x04A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class ATargetPoint>            _slasherCharmSpawn;                                // 0x04A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<TWeakObjectPtr<class ADisplayStand>, TWeakObjectPtr<class ADBDMenuSilhouette>> _partyLobbyEmptySlotPawns;                         // 0x04B0(0x0050)(Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_500[0x48];                                     // 0x0500(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         _destroyingPawns;                                  // 0x0548(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_558[0x8];                                      // 0x0558(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CheckDestroyingPawns(class AActor* DestroyedActor);
	void OnCharacterSpawned(class ADBDMenuPlayer* Player);
	void OnStateChanged(EOfflineLobbyState LobbyState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OfflineLobbyLevel">();
	}
	static class AOfflineLobbyLevel* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOfflineLobbyLevel>();
	}
};
static_assert(alignof(AOfflineLobbyLevel) == 0x000008, "Wrong alignment on AOfflineLobbyLevel");
static_assert(sizeof(AOfflineLobbyLevel) == 0x000560, "Wrong size on AOfflineLobbyLevel");
static_assert(offsetof(AOfflineLobbyLevel, _partyLobbyInviteButtonOffset) == 0x000350, "Member 'AOfflineLobbyLevel::_partyLobbyInviteButtonOffset' has a wrong offset!");
static_assert(offsetof(AOfflineLobbyLevel, _roleSelectionCamperSpawns) == 0x000368, "Member 'AOfflineLobbyLevel::_roleSelectionCamperSpawns' has a wrong offset!");
static_assert(offsetof(AOfflineLobbyLevel, _roleSelectionSlasherSpawns) == 0x000378, "Member 'AOfflineLobbyLevel::_roleSelectionSlasherSpawns' has a wrong offset!");
static_assert(offsetof(AOfflineLobbyLevel, _offlineLobbyLocalSlasherSpawn) == 0x000388, "Member 'AOfflineLobbyLevel::_offlineLobbyLocalSlasherSpawn' has a wrong offset!");
static_assert(offsetof(AOfflineLobbyLevel, _partyLobbyEmptySlotFxOffset) == 0x000390, "Member 'AOfflineLobbyLevel::_partyLobbyEmptySlotFxOffset' has a wrong offset!");
static_assert(offsetof(AOfflineLobbyLevel, _offlineLobbyLocalCamperSpawn) == 0x0003A8, "Member 'AOfflineLobbyLevel::_offlineLobbyLocalCamperSpawn' has a wrong offset!");
static_assert(offsetof(AOfflineLobbyLevel, _partyLobbySlasherPOVTrackerOffsets) == 0x0003B0, "Member 'AOfflineLobbyLevel::_partyLobbySlasherPOVTrackerOffsets' has a wrong offset!");
static_assert(offsetof(AOfflineLobbyLevel, _partyLobbyEmptySlotSilhouette) == 0x0003C0, "Member 'AOfflineLobbyLevel::_partyLobbyEmptySlotSilhouette' has a wrong offset!");
static_assert(offsetof(AOfflineLobbyLevel, _partyLobbySlasherDisplayStands) == 0x0003F8, "Member 'AOfflineLobbyLevel::_partyLobbySlasherDisplayStands' has a wrong offset!");
static_assert(offsetof(AOfflineLobbyLevel, _partyLobbyCamperDisplayStands) == 0x000408, "Member 'AOfflineLobbyLevel::_partyLobbyCamperDisplayStands' has a wrong offset!");
static_assert(offsetof(AOfflineLobbyLevel, _meatHookForCustomization) == 0x000428, "Member 'AOfflineLobbyLevel::_meatHookForCustomization' has a wrong offset!");
static_assert(offsetof(AOfflineLobbyLevel, _meatHookSpawn) == 0x000460, "Member 'AOfflineLobbyLevel::_meatHookSpawn' has a wrong offset!");
static_assert(offsetof(AOfflineLobbyLevel, _charmForCustomizationZoom) == 0x000468, "Member 'AOfflineLobbyLevel::_charmForCustomizationZoom' has a wrong offset!");
static_assert(offsetof(AOfflineLobbyLevel, _camperCharmSpawn) == 0x0004A0, "Member 'AOfflineLobbyLevel::_camperCharmSpawn' has a wrong offset!");
static_assert(offsetof(AOfflineLobbyLevel, _slasherCharmSpawn) == 0x0004A8, "Member 'AOfflineLobbyLevel::_slasherCharmSpawn' has a wrong offset!");
static_assert(offsetof(AOfflineLobbyLevel, _partyLobbyEmptySlotPawns) == 0x0004B0, "Member 'AOfflineLobbyLevel::_partyLobbyEmptySlotPawns' has a wrong offset!");
static_assert(offsetof(AOfflineLobbyLevel, _destroyingPawns) == 0x000548, "Member 'AOfflineLobbyLevel::_destroyingPawns' has a wrong offset!");

// Class DeadByDaylight.OnboardingUtilities
// 0x0000 (0x0030 - 0x0030)
class UOnboardingUtilities final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnboardingUtilities">();
	}
	static class UOnboardingUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOnboardingUtilities>();
	}
};
static_assert(alignof(UOnboardingUtilities) == 0x000008, "Wrong alignment on UOnboardingUtilities");
static_assert(sizeof(UOnboardingUtilities) == 0x000030, "Wrong size on UOnboardingUtilities");

// Class DeadByDaylight.OniBasicAttackComponent
// 0x0010 (0x00B8 - 0x00A8)
class UOniBasicAttackComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x10];                                      // 0x00A8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OniBasicAttackComponent">();
	}
	static class UOniBasicAttackComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOniBasicAttackComponent>();
	}
};
static_assert(alignof(UOniBasicAttackComponent) == 0x000008, "Wrong alignment on UOniBasicAttackComponent");
static_assert(sizeof(UOniBasicAttackComponent) == 0x0000B8, "Wrong size on UOniBasicAttackComponent");

// Class DeadByDaylight.OniDemonModeAttackStateComponent
// 0x0018 (0x00C8 - 0x00B0)
class UOniDemonModeAttackStateComponent final : public UChargedAttackStateComponent
{
public:
	FMulticastInlineDelegateProperty_             OnChargedAttackReadyChanged;                       // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_C0[0x8];                                       // 0x00C0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Multicast_ClearChargingState();
	void Server_ClearChargingState();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OniDemonModeAttackStateComponent">();
	}
	static class UOniDemonModeAttackStateComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOniDemonModeAttackStateComponent>();
	}
};
static_assert(alignof(UOniDemonModeAttackStateComponent) == 0x000008, "Wrong alignment on UOniDemonModeAttackStateComponent");
static_assert(sizeof(UOniDemonModeAttackStateComponent) == 0x0000C8, "Wrong size on UOniDemonModeAttackStateComponent");
static_assert(offsetof(UOniDemonModeAttackStateComponent, OnChargedAttackReadyChanged) == 0x0000B0, "Member 'UOniDemonModeAttackStateComponent::OnChargedAttackReadyChanged' has a wrong offset!");

// Class DeadByDaylight.OnlineLobbyLevel
// 0x0038 (0x0388 - 0x0350)
class AOnlineLobbyLevel final : public ALobbyLevel
{
public:
	class UProceduralGenerationData*              ProceduralGenerationData;                          // 0x0350(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        _onlineLobbySlasherPOVTrackerOffsets;              // 0x0358(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TArray<TWeakObjectPtr<class ADisplayStand>>   _onlineLobbyCamperDisplayStands;                   // 0x0368(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<TWeakObjectPtr<class ADisplayStand>>   _onlineLobbySlasherDisplayStands;                  // 0x0378(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnlineLobbyLevel">();
	}
	static class AOnlineLobbyLevel* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOnlineLobbyLevel>();
	}
};
static_assert(alignof(AOnlineLobbyLevel) == 0x000008, "Wrong alignment on AOnlineLobbyLevel");
static_assert(sizeof(AOnlineLobbyLevel) == 0x000388, "Wrong size on AOnlineLobbyLevel");
static_assert(offsetof(AOnlineLobbyLevel, ProceduralGenerationData) == 0x000350, "Member 'AOnlineLobbyLevel::ProceduralGenerationData' has a wrong offset!");
static_assert(offsetof(AOnlineLobbyLevel, _onlineLobbySlasherPOVTrackerOffsets) == 0x000358, "Member 'AOnlineLobbyLevel::_onlineLobbySlasherPOVTrackerOffsets' has a wrong offset!");
static_assert(offsetof(AOnlineLobbyLevel, _onlineLobbyCamperDisplayStands) == 0x000368, "Member 'AOnlineLobbyLevel::_onlineLobbyCamperDisplayStands' has a wrong offset!");
static_assert(offsetof(AOnlineLobbyLevel, _onlineLobbySlasherDisplayStands) == 0x000378, "Member 'AOnlineLobbyLevel::_onlineLobbySlasherDisplayStands' has a wrong offset!");

// Class DeadByDaylight.SpawnElement
// 0x0000 (0x0030 - 0x0030)
class ISpawnElement final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpawnElement">();
	}
	static class ISpawnElement* GetDefaultObj()
	{
		return GetDefaultObjImpl<ISpawnElement>();
	}
};
static_assert(alignof(ISpawnElement) == 0x000008, "Wrong alignment on ISpawnElement");
static_assert(sizeof(ISpawnElement) == 0x000030, "Wrong size on ISpawnElement");

// Class DeadByDaylight.OnlinePrivilegeManager
// 0x0008 (0x0040 - 0x0038)
class UOnlinePrivilegeManager final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnlinePrivilegeManager">();
	}
	static class UOnlinePrivilegeManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOnlinePrivilegeManager>();
	}
};
static_assert(alignof(UOnlinePrivilegeManager) == 0x000008, "Wrong alignment on UOnlinePrivilegeManager");
static_assert(sizeof(UOnlinePrivilegeManager) == 0x000040, "Wrong size on UOnlinePrivilegeManager");

// Class DeadByDaylight.OnlineSystemHandler
// 0x04E8 (0x0518 - 0x0030)
class UOnlineSystemHandler final : public UObject
{
public:
	uint8                                         Pad_30[0x1D0];                                     // 0x0030(0x01D0)(Fixing Size After Last Property [ Dumper-7 ])
	class ULocalPlayer*                           _cachedLocalPlayer;                                // 0x0200(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDBDGameInstance*                       _gameInstance;                                     // 0x0208(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGameSessionDS*                         _gameSessionDS;                                    // 0x0210(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_218[0x270];                                    // 0x0218(0x0270)(Fixing Size After Last Property [ Dumper-7 ])
	class UDBDServerInstance*                     _serverInstance;                                   // 0x0488(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_490[0x30];                                     // 0x0490(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class UCrossPlatformManager*                  _crossPlatformManager;                             // 0x04C0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4C8[0x50];                                     // 0x04C8(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnlineSystemHandler">();
	}
	static class UOnlineSystemHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOnlineSystemHandler>();
	}
};
static_assert(alignof(UOnlineSystemHandler) == 0x000008, "Wrong alignment on UOnlineSystemHandler");
static_assert(sizeof(UOnlineSystemHandler) == 0x000518, "Wrong size on UOnlineSystemHandler");
static_assert(offsetof(UOnlineSystemHandler, _cachedLocalPlayer) == 0x000200, "Member 'UOnlineSystemHandler::_cachedLocalPlayer' has a wrong offset!");
static_assert(offsetof(UOnlineSystemHandler, _gameInstance) == 0x000208, "Member 'UOnlineSystemHandler::_gameInstance' has a wrong offset!");
static_assert(offsetof(UOnlineSystemHandler, _gameSessionDS) == 0x000210, "Member 'UOnlineSystemHandler::_gameSessionDS' has a wrong offset!");
static_assert(offsetof(UOnlineSystemHandler, _serverInstance) == 0x000488, "Member 'UOnlineSystemHandler::_serverInstance' has a wrong offset!");
static_assert(offsetof(UOnlineSystemHandler, _crossPlatformManager) == 0x0004C0, "Member 'UOnlineSystemHandler::_crossPlatformManager' has a wrong offset!");

// Class DeadByDaylight.OnScreenDebugComponent
// 0x0010 (0x00B8 - 0x00A8)
class UOnScreenDebugComponent final : public UActorComponent
{
public:
	TArray<struct FOnScreenDebugInfo>             _messages;                                         // 0x00A8(0x0010)(Net, ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnScreenDebugComponent">();
	}
	static class UOnScreenDebugComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOnScreenDebugComponent>();
	}
};
static_assert(alignof(UOnScreenDebugComponent) == 0x000008, "Wrong alignment on UOnScreenDebugComponent");
static_assert(sizeof(UOnScreenDebugComponent) == 0x0000B8, "Wrong size on UOnScreenDebugComponent");
static_assert(offsetof(UOnScreenDebugComponent, _messages) == 0x0000A8, "Member 'UOnScreenDebugComponent::_messages' has a wrong offset!");

// Class DeadByDaylight.SurvivorBloodFXComponent
// 0x0000 (0x00A8 - 0x00A8)
class USurvivorBloodFXComponent : public UActorComponent
{
public:
	class UNiagaraComponent* SpawnBloodSpurts();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SurvivorBloodFXComponent">();
	}
	static class USurvivorBloodFXComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USurvivorBloodFXComponent>();
	}
};
static_assert(alignof(USurvivorBloodFXComponent) == 0x000008, "Wrong alignment on USurvivorBloodFXComponent");
static_assert(sizeof(USurvivorBloodFXComponent) == 0x0000A8, "Wrong size on USurvivorBloodFXComponent");

// Class DeadByDaylight.OpenHatch
// 0x0000 (0x0780 - 0x0780)
class UOpenHatch final : public UBaseEscapeThroughHatch
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OpenHatch">();
	}
	static class UOpenHatch* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOpenHatch>();
	}
};
static_assert(alignof(UOpenHatch) == 0x000010, "Wrong alignment on UOpenHatch");
static_assert(sizeof(UOpenHatch) == 0x000780, "Wrong size on UOpenHatch");

// Class DeadByDaylight.OpenSupplyCrateInteraction
// 0x0010 (0x08D0 - 0x08C0)
class UOpenSupplyCrateInteraction final : public UChargeableInteractionDefinition
{
public:
	class ASupplyCrateInteractable*               _owningSupplyCrate;                                // 0x08C0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          _successExitTimeAnimSequenceReference;             // 0x08C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OpenSupplyCrateInteraction">();
	}
	static class UOpenSupplyCrateInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOpenSupplyCrateInteraction>();
	}
};
static_assert(alignof(UOpenSupplyCrateInteraction) == 0x000010, "Wrong alignment on UOpenSupplyCrateInteraction");
static_assert(sizeof(UOpenSupplyCrateInteraction) == 0x0008D0, "Wrong size on UOpenSupplyCrateInteraction");
static_assert(offsetof(UOpenSupplyCrateInteraction, _owningSupplyCrate) == 0x0008C0, "Member 'UOpenSupplyCrateInteraction::_owningSupplyCrate' has a wrong offset!");
static_assert(offsetof(UOpenSupplyCrateInteraction, _successExitTimeAnimSequenceReference) == 0x0008C8, "Member 'UOpenSupplyCrateInteraction::_successExitTimeAnimSequenceReference' has a wrong offset!");

// Class DeadByDaylight.OutfitHelper
// 0x0000 (0x0030 - 0x0030)
class UOutfitHelper final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OutfitHelper">();
	}
	static class UOutfitHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOutfitHelper>();
	}
};
static_assert(alignof(UOutfitHelper) == 0x000008, "Wrong alignment on UOutfitHelper");
static_assert(sizeof(UOutfitHelper) == 0x000030, "Wrong size on UOutfitHelper");

// Class DeadByDaylight.OutlineReveal
// 0x00A8 (0x00D8 - 0x0030)
class UOutlineReveal final : public UObject
{
public:
	uint8                                         Pad_30[0x70];                                      // 0x0030(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ADBDPlayer*>                     _affectedCharacters;                               // 0x00A0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B0[0x28];                                      // 0x00B0(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OutlineReveal">();
	}
	static class UOutlineReveal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOutlineReveal>();
	}
};
static_assert(alignof(UOutlineReveal) == 0x000008, "Wrong alignment on UOutlineReveal");
static_assert(sizeof(UOutlineReveal) == 0x0000D8, "Wrong size on UOutlineReveal");
static_assert(offsetof(UOutlineReveal, _affectedCharacters) == 0x0000A0, "Member 'UOutlineReveal::_affectedCharacters' has a wrong offset!");

// Class DeadByDaylight.OutOfSightMeshRotator
// 0x0028 (0x00D0 - 0x00A8)
class UOutOfSightMeshRotator final : public UActorComponent
{
public:
	float                                         _maxDistance;                                      // 0x00A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _dotProductThreshold;                              // 0x00AC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ADBDPlayer*                             _locallyObservedPlayer;                            // 0x00B0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UMeshComponent*>                 _meshesToRotate;                                   // 0x00B8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	float                                         _rotationOffset;                                   // 0x00C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_CC[0x4];                                       // 0x00CC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetMeshesToRotate(const TArray<class UMeshComponent*>& MeshesToRotate);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OutOfSightMeshRotator">();
	}
	static class UOutOfSightMeshRotator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOutOfSightMeshRotator>();
	}
};
static_assert(alignof(UOutOfSightMeshRotator) == 0x000008, "Wrong alignment on UOutOfSightMeshRotator");
static_assert(sizeof(UOutOfSightMeshRotator) == 0x0000D0, "Wrong size on UOutOfSightMeshRotator");
static_assert(offsetof(UOutOfSightMeshRotator, _maxDistance) == 0x0000A8, "Member 'UOutOfSightMeshRotator::_maxDistance' has a wrong offset!");
static_assert(offsetof(UOutOfSightMeshRotator, _dotProductThreshold) == 0x0000AC, "Member 'UOutOfSightMeshRotator::_dotProductThreshold' has a wrong offset!");
static_assert(offsetof(UOutOfSightMeshRotator, _locallyObservedPlayer) == 0x0000B0, "Member 'UOutOfSightMeshRotator::_locallyObservedPlayer' has a wrong offset!");
static_assert(offsetof(UOutOfSightMeshRotator, _meshesToRotate) == 0x0000B8, "Member 'UOutOfSightMeshRotator::_meshesToRotate' has a wrong offset!");
static_assert(offsetof(UOutOfSightMeshRotator, _rotationOffset) == 0x0000C8, "Member 'UOutOfSightMeshRotator::_rotationOffset' has a wrong offset!");

// Class DeadByDaylight.OverlayMenuScreen
// 0x01E0 (0x0308 - 0x0128)
class UOverlayMenuScreen final : public UScreenBase
{
public:
	uint8                                         Pad_128[0x1E0];                                    // 0x0128(0x01E0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAimAssistClick(bool Value);
	void OnAtlantaSettingButtonClick(int32 buttonId);
	void OnBackButtonClick();
	void OnCustomerSupportButtonClick();
	void OnEULAButtonClick();
	void OnForumsButtonClick();
	void OnKillerCameraSensitivityChanged(int32 Value);
	void OnLanguageChange(int32 Value);
	void OnPlayerInfoClick(const class FString& PlayerId);
	void OnPrivacyPolicyButtonClick();
	void OnQuitButtonClick();
	void OnRequestKeyBindingInput(int32 ID, const class FString& Key);
	void OnResetDefaultKeybindings();
	void OnResetDefaultSettings();
	void OnSelectTab(int32 TabIndex);
	void OnSettingsOptionButtonClicked(int32 ID);
	void OnSettingsOptionCheckboxSelected(int32 ID, bool IsSelected);
	void OnSettingsOptionIntValueChanged(int32 ID, int32 Value);
	void OnSurvivorCameraSensitivityChanged(int32 Value);
	void SetGameType(EGameType GameType, bool IsInCustomMatchManagerMode);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OverlayMenuScreen">();
	}
	static class UOverlayMenuScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOverlayMenuScreen>();
	}
};
static_assert(alignof(UOverlayMenuScreen) == 0x000008, "Wrong alignment on UOverlayMenuScreen");
static_assert(sizeof(UOverlayMenuScreen) == 0x000308, "Wrong size on UOverlayMenuScreen");

// Class DeadByDaylight.Pallet
// 0x0158 (0x0500 - 0x03A8)
class APallet : public AInteractable
{
public:
	uint8                                         Pad_3A8[0x8];                                      // 0x03A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PalletDownEvadeDoorFrontPointOffset;               // 0x03B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B4[0x1C];                                     // 0x03B4(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             Cosmetic_OnPalletStateChanged;                     // 0x03D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	EPalletState                                  _state;                                            // 0x03E0(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isPendingDestruction;                             // 0x03E1(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isIllusionaryPalletDown;                          // 0x03E2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isDestroyedByEntity;                              // 0x03E3(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3E4[0x4];                                      // 0x03E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMontagePlayer*                         _montagePlayer;                                    // 0x03E8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimationMontageSlave*                 _animationMontageSlave;                            // 0x03F0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        _leftInteractionSceneComponent;                    // 0x03F8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        _rightInteractionSceneComponent;                   // 0x0400(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractionDefinition*                 _destroyLeft;                                      // 0x0408(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInteractionDefinition*                 _destroyRight;                                     // 0x0410(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBoxComponent*                          _pushBox;                                          // 0x0418(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBoxComponent*                          _downedPalletCollider;                             // 0x0420(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPrimitiveComponent*                    _upPalletCollider;                                 // 0x0428(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _maxDotproductThresholdForPulldownAccross;         // 0x0430(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _fallDuration;                                     // 0x0434(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBoxComponent*                          _stunBoxLeft;                                      // 0x0438(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBoxComponent*                          _stunBoxRight;                                     // 0x0440(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSet<class AActor*>                           _stunnedActors;                                    // 0x0448(0x0050)(Transient, NativeAccessSpecifierPrivate)
	class ADBDPlayer*                             _playerExecutingPulldown;                          // 0x0498(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FPalletPushSettings                    _pushSettings;                                     // 0x04A0(0x0002)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4A2[0x3E];                                     // 0x04A2(0x003E)(Fixing Size After Last Property [ Dumper-7 ])
	class UDBDNavEvadeLoopComponent*              _navEvadeLoopComponent;                            // 0x04E0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPalletPulldownBlockerComponent*        _palletPulldownBlockerComponent;                   // 0x04E8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isDreamPallet;                                    // 0x04F0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isFragile;                                        // 0x04F1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4F2[0x6];                                      // 0x04F2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class USpawnedActorReplicationComponent*      _spawnedActorReplicationComponent;                 // 0x04F8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Authority_OnOverlapPushBox(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void BP_ExplodePallet(class ADBDPlayer* Player);
	void Cosmetic_OnPalletPulldownBlockedByEntityHide();
	void Cosmetic_OnPalletPulldownBlockedByEntityShow();
	void Cosmetic_PalletPullDownFXImmediateHide();
	void EntityExplodePallet(class ADBDPlayer* Player);
	void ExplodePallet(class ADBDPlayer* Player, bool KickPallet);
	void ExplodeStunPallet(class ADBDPlayer* Player);
	class UPrimitiveComponent* GetZoneForRestrictedPlacement();
	void Multicast_ExplodePallet(class ADBDPlayer* Player, bool byEntity);
	void Multicast_PulldownPallet();
	void Multicast_ResetPallet();
	void Multicast_StunActor(class AActor* Actor, class ACamperPlayer* Survivor, bool StunBreakPallet);
	void OnFallen();
	void OnPalletPulledUp_BP();
	void OnPalletStateChangedCosmetic__DelegateSignature(EPalletState NewState);
	void OnPalletStunHit();
	void OnStunOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void PullDown(class ADBDPlayer* Player, const struct FPalletPushSettings& PushSettings, const EPalletStunZoneSideStrategy StunZoneSideStrategy);
	void PulldownPallet();
	void ResetPallet();
	void SetPalletState(EPalletState State);
	void SetPendingDestruction(bool IsPendingDestruction);

	bool CanPulldown(const class ADBDPlayer* Player, const struct FVector& InteractionAxis, const bool IsStationary) const;
	void GetDestructibleAreaPrimitiveComponents(TArray<class UPrimitiveComponent*>* Prims) const;
	float GetFallDuration() const;
	bool GetIsDreamPallet() const;
	bool GetIsFragile() const;
	bool GetIsPulledDown() const;
	class USkeletalMeshComponent* GetPalletSkeletalMeshComponent() const;
	class ADBDPlayer* GetPlayerDoingPulldown() const;
	bool IsDestroyedByEntity() const;
	bool IsPendingDestruction() const;
	bool IsPulldownBlockedByEntity() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Pallet">();
	}
	static class APallet* GetDefaultObj()
	{
		return GetDefaultObjImpl<APallet>();
	}
};
static_assert(alignof(APallet) == 0x000008, "Wrong alignment on APallet");
static_assert(sizeof(APallet) == 0x000500, "Wrong size on APallet");
static_assert(offsetof(APallet, PalletDownEvadeDoorFrontPointOffset) == 0x0003B0, "Member 'APallet::PalletDownEvadeDoorFrontPointOffset' has a wrong offset!");
static_assert(offsetof(APallet, Cosmetic_OnPalletStateChanged) == 0x0003D0, "Member 'APallet::Cosmetic_OnPalletStateChanged' has a wrong offset!");
static_assert(offsetof(APallet, _state) == 0x0003E0, "Member 'APallet::_state' has a wrong offset!");
static_assert(offsetof(APallet, _isPendingDestruction) == 0x0003E1, "Member 'APallet::_isPendingDestruction' has a wrong offset!");
static_assert(offsetof(APallet, _isIllusionaryPalletDown) == 0x0003E2, "Member 'APallet::_isIllusionaryPalletDown' has a wrong offset!");
static_assert(offsetof(APallet, _isDestroyedByEntity) == 0x0003E3, "Member 'APallet::_isDestroyedByEntity' has a wrong offset!");
static_assert(offsetof(APallet, _montagePlayer) == 0x0003E8, "Member 'APallet::_montagePlayer' has a wrong offset!");
static_assert(offsetof(APallet, _animationMontageSlave) == 0x0003F0, "Member 'APallet::_animationMontageSlave' has a wrong offset!");
static_assert(offsetof(APallet, _leftInteractionSceneComponent) == 0x0003F8, "Member 'APallet::_leftInteractionSceneComponent' has a wrong offset!");
static_assert(offsetof(APallet, _rightInteractionSceneComponent) == 0x000400, "Member 'APallet::_rightInteractionSceneComponent' has a wrong offset!");
static_assert(offsetof(APallet, _destroyLeft) == 0x000408, "Member 'APallet::_destroyLeft' has a wrong offset!");
static_assert(offsetof(APallet, _destroyRight) == 0x000410, "Member 'APallet::_destroyRight' has a wrong offset!");
static_assert(offsetof(APallet, _pushBox) == 0x000418, "Member 'APallet::_pushBox' has a wrong offset!");
static_assert(offsetof(APallet, _downedPalletCollider) == 0x000420, "Member 'APallet::_downedPalletCollider' has a wrong offset!");
static_assert(offsetof(APallet, _upPalletCollider) == 0x000428, "Member 'APallet::_upPalletCollider' has a wrong offset!");
static_assert(offsetof(APallet, _maxDotproductThresholdForPulldownAccross) == 0x000430, "Member 'APallet::_maxDotproductThresholdForPulldownAccross' has a wrong offset!");
static_assert(offsetof(APallet, _fallDuration) == 0x000434, "Member 'APallet::_fallDuration' has a wrong offset!");
static_assert(offsetof(APallet, _stunBoxLeft) == 0x000438, "Member 'APallet::_stunBoxLeft' has a wrong offset!");
static_assert(offsetof(APallet, _stunBoxRight) == 0x000440, "Member 'APallet::_stunBoxRight' has a wrong offset!");
static_assert(offsetof(APallet, _stunnedActors) == 0x000448, "Member 'APallet::_stunnedActors' has a wrong offset!");
static_assert(offsetof(APallet, _playerExecutingPulldown) == 0x000498, "Member 'APallet::_playerExecutingPulldown' has a wrong offset!");
static_assert(offsetof(APallet, _pushSettings) == 0x0004A0, "Member 'APallet::_pushSettings' has a wrong offset!");
static_assert(offsetof(APallet, _navEvadeLoopComponent) == 0x0004E0, "Member 'APallet::_navEvadeLoopComponent' has a wrong offset!");
static_assert(offsetof(APallet, _palletPulldownBlockerComponent) == 0x0004E8, "Member 'APallet::_palletPulldownBlockerComponent' has a wrong offset!");
static_assert(offsetof(APallet, _isDreamPallet) == 0x0004F0, "Member 'APallet::_isDreamPallet' has a wrong offset!");
static_assert(offsetof(APallet, _isFragile) == 0x0004F1, "Member 'APallet::_isFragile' has a wrong offset!");
static_assert(offsetof(APallet, _spawnedActorReplicationComponent) == 0x0004F8, "Member 'APallet::_spawnedActorReplicationComponent' has a wrong offset!");

// Class DeadByDaylight.SubtitlesManager
// 0x00B8 (0x00F0 - 0x0038)
class USubtitlesManager final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x24];                                      // 0x0038(0x0024)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UAkGameObject>           _currentSubtitleEventTarget;                       // 0x005C(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_64[0x8C];                                      // 0x0064(0x008C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class FString GetAudioEventNameFromLocalizedTextId(const class FString& TextId);
	static class FString GetForcedAudioOrDialogLine();
	static bool HasAnimNotifyPlayedForThisMatch(const class FString& AnimNotify);
	static bool IsDebuggingSubtitles();
	static int32 Post2DAkEventWithSubtitles(const TArray<struct FAkEventWithSubtitle>& AkEventRandomizer, class UAkAudioEvent** AkEventPlayed);
	static int32 PostAkEventWithSubtitles(class UAkGameObject* Target, const TArray<struct FAkEventWithSubtitle>& AkEventRandomizer, float MaxSubtitleDistance, int32 CallbackMask, const TDelegate<void(EAkCallbackType CallbackType, class UAkCallbackInfo* CallbackInfo)>& PostEventCallback, class UAkAudioEvent** AkEventPlayed);
	static void RecordAnimNotifyPlayedForThisMatch(const class FString& AnimNotify);

	void On3DEventCallback(EAkCallbackType CallbackType, class UAkCallbackInfo* CallbackInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SubtitlesManager">();
	}
	static class USubtitlesManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<USubtitlesManager>();
	}
};
static_assert(alignof(USubtitlesManager) == 0x000008, "Wrong alignment on USubtitlesManager");
static_assert(sizeof(USubtitlesManager) == 0x0000F0, "Wrong size on USubtitlesManager");
static_assert(offsetof(USubtitlesManager, _currentSubtitleEventTarget) == 0x00005C, "Member 'USubtitlesManager::_currentSubtitleEventTarget' has a wrong offset!");

// Class DeadByDaylight.PalletDropInteractionDefinition
// 0x0090 (0x0810 - 0x0780)
class UPalletDropInteractionDefinition : public UInteractionDefinition
{
public:
	EPalletStunZoneSideStrategy                   _stunZoneSideStrategy;                             // 0x0778(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_779[0x7];                                      // 0x0779(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _palletVacuumSpeedBoost;                           // 0x0780(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _loudNoiseRange;                                   // 0x07A8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	bool                                          _isStationary;                                     // 0x07D0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7D1[0x3F];                                     // 0x07D1(0x003F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPalletDropped();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalletDropInteractionDefinition">();
	}
	static class UPalletDropInteractionDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalletDropInteractionDefinition>();
	}
};
static_assert(alignof(UPalletDropInteractionDefinition) == 0x000010, "Wrong alignment on UPalletDropInteractionDefinition");
static_assert(sizeof(UPalletDropInteractionDefinition) == 0x000810, "Wrong size on UPalletDropInteractionDefinition");
static_assert(offsetof(UPalletDropInteractionDefinition, _stunZoneSideStrategy) == 0x000778, "Member 'UPalletDropInteractionDefinition::_stunZoneSideStrategy' has a wrong offset!");
static_assert(offsetof(UPalletDropInteractionDefinition, _palletVacuumSpeedBoost) == 0x000780, "Member 'UPalletDropInteractionDefinition::_palletVacuumSpeedBoost' has a wrong offset!");
static_assert(offsetof(UPalletDropInteractionDefinition, _loudNoiseRange) == 0x0007A8, "Member 'UPalletDropInteractionDefinition::_loudNoiseRange' has a wrong offset!");
static_assert(offsetof(UPalletDropInteractionDefinition, _isStationary) == 0x0007D0, "Member 'UPalletDropInteractionDefinition::_isStationary' has a wrong offset!");

// Class DeadByDaylight.PalletPulldownBlockerComponent
// 0x0078 (0x0120 - 0x00A8)
class UPalletPulldownBlockerComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x60];                                      // 0x00A8(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _isPalletPulldownBlockedByEntity;                  // 0x0108(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_109[0x7];                                      // 0x0109(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                _palletToBlock;                                    // 0x0110(0x0008)(Net, ZeroConstructor, Transient, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _blockedDisappearFxTime;                           // 0x0118(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_11C[0x4];                                      // 0x011C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Multicast_PalletPulldownBlockedHideCosmetic(class UObject* PalletToUnblock);
	void Multicast_PalletPulldownBlockedShowCosmetic(class UObject* PalletToBlock);
	void OnRep_PalletToBlock(class UObject* OldPalletToBlock);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalletPulldownBlockerComponent">();
	}
	static class UPalletPulldownBlockerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalletPulldownBlockerComponent>();
	}
};
static_assert(alignof(UPalletPulldownBlockerComponent) == 0x000008, "Wrong alignment on UPalletPulldownBlockerComponent");
static_assert(sizeof(UPalletPulldownBlockerComponent) == 0x000120, "Wrong size on UPalletPulldownBlockerComponent");
static_assert(offsetof(UPalletPulldownBlockerComponent, _isPalletPulldownBlockedByEntity) == 0x000108, "Member 'UPalletPulldownBlockerComponent::_isPalletPulldownBlockedByEntity' has a wrong offset!");
static_assert(offsetof(UPalletPulldownBlockerComponent, _palletToBlock) == 0x000110, "Member 'UPalletPulldownBlockerComponent::_palletToBlock' has a wrong offset!");
static_assert(offsetof(UPalletPulldownBlockerComponent, _blockedDisappearFxTime) == 0x000118, "Member 'UPalletPulldownBlockerComponent::_blockedDisappearFxTime' has a wrong offset!");

// Class DeadByDaylight.PalletUtilities
// 0x0000 (0x0030 - 0x0030)
class UPalletUtilities final : public UObject
{
public:
	static TSoftClassPtr<class UClass> GetDreamPalletBP(const class UObject* WorldContextObject);
	static TSoftObjectPtr<class UStaticMesh> GetIllusionaryPalletStaticMesh(const class UObject* WorldContextObjec);
	static TSoftClassPtr<class UClass> GetPalletTrackerBP(const class UObject* WorldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalletUtilities">();
	}
	static class UPalletUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalletUtilities>();
	}
};
static_assert(alignof(UPalletUtilities) == 0x000008, "Wrong alignment on UPalletUtilities");
static_assert(sizeof(UPalletUtilities) == 0x000030, "Wrong size on UPalletUtilities");

// Class DeadByDaylight.PanelScreen
// 0x03A8 (0x04D0 - 0x0128)
class UPanelScreen final : public UScreenBase
{
public:
	uint8                                         Pad_128[0x3A8];                                    // 0x0128(0x03A8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAvailableItemClicked(int32 ClickedItemIndex);
	void OnAvailableItemsSortingChange(int32 NewSorting);
	void OnBloodwebCenterButtonHovered();
	void OnBloodwebCenterButtonSelected();
	void OnChallengesButtonClick();
	void OnCharacterSlotButtonClick(int32 CharacterIndex);
	void OnCharInfoClick();
	void OnConfirmCollectSelectedNode(int32 CharacterId);
	void OnCustomizationPlayMoriSelected();
	void OnCustomizationPlaySecondMoriSelected();
	void OnCustomizationPresetClick(int32 Param_Index);
	void OnCustomizationSearchClear();
	void OnCustomizationSearchClicked();
	void OnEquipableSlotClicked(int32 ClickedSlotCategory, int32 ClickedSlotIndex);
	void OnEventButtonClick();
	void OnItemSelected(int32 ItemIndex);
	void OnItemUnselected(int32 ItemIndex);
	void OnLevelUpDone();
	void OnLevelUpShown();
	void OnLoadoutPresetClick(int32 Param_Index);
	void OnLoadoutSearchClear();
	void OnLoadoutSearchClicked();
	void OnLoadoutSlotButtonClick(int32 SlotIndex);
	void OnNodeCollectionAnimDone();
	void OnNodeConsumptionAnimDone();
	void OnPanelsHidden();
	void OnPrestigeUp(int32 CharacterId);
	void OnRegenerateButtonClick(int32 CharacterId);
	void OnReservedBloodPoints(int32 CharacterId, int32 BloodPoints, bool FullCost);
	void OnRoleButtonClick();
	void OnRotateCharacter(float MouseDistanceChange);
	void OnSelectedEquipableSlotZoomChange(bool ZoomIn);
	void OnSequenceStepCompleted(int32 CharacterId, int32 ID);
	void OnShrineOfSecretsButtonClick();
	void OnSideTabButtonClick(int32 TabIndex);
	void OnStoreButtonClick();
	void OnWebBuilt(int32 CharacterId, bool IsEmpty);
	void OnWebNodeHovered(int32 ID);
	void OnWebNodeSelected(int32 CharacterId, int32 ID, int32 NodeDepth);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PanelScreen">();
	}
	static class UPanelScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPanelScreen>();
	}
};
static_assert(alignof(UPanelScreen) == 0x000008, "Wrong alignment on UPanelScreen");
static_assert(sizeof(UPanelScreen) == 0x0004D0, "Wrong size on UPanelScreen");

// Class DeadByDaylight.TutorialAssetLibrary
// 0x0010 (0x00C0 - 0x00B0)
class UTutorialAssetLibrary final : public UAssetLibrary
{
public:
	uint8                                         Pad_B0[0x10];                                      // 0x00B0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TutorialAssetLibrary">();
	}
	static class UTutorialAssetLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTutorialAssetLibrary>();
	}
};
static_assert(alignof(UTutorialAssetLibrary) == 0x000008, "Wrong alignment on UTutorialAssetLibrary");
static_assert(sizeof(UTutorialAssetLibrary) == 0x0000C0, "Wrong size on UTutorialAssetLibrary");

// Class DeadByDaylight.ParticleSystemDistanceFaderComponent
// 0x0020 (0x00C8 - 0x00A8)
class UParticleSystemDistanceFaderComponent final : public UActorComponent
{
public:
	class UParticleSystemComponent*               ParticleSystemComponent;                           // 0x00A8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   OpacityParameterName;                              // 0x00B0(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StartFadeDistance;                                 // 0x00BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EndFadeDistance;                                   // 0x00C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C4[0x4];                                       // 0x00C4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleSystemDistanceFaderComponent">();
	}
	static class UParticleSystemDistanceFaderComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleSystemDistanceFaderComponent>();
	}
};
static_assert(alignof(UParticleSystemDistanceFaderComponent) == 0x000008, "Wrong alignment on UParticleSystemDistanceFaderComponent");
static_assert(sizeof(UParticleSystemDistanceFaderComponent) == 0x0000C8, "Wrong size on UParticleSystemDistanceFaderComponent");
static_assert(offsetof(UParticleSystemDistanceFaderComponent, ParticleSystemComponent) == 0x0000A8, "Member 'UParticleSystemDistanceFaderComponent::ParticleSystemComponent' has a wrong offset!");
static_assert(offsetof(UParticleSystemDistanceFaderComponent, OpacityParameterName) == 0x0000B0, "Member 'UParticleSystemDistanceFaderComponent::OpacityParameterName' has a wrong offset!");
static_assert(offsetof(UParticleSystemDistanceFaderComponent, StartFadeDistance) == 0x0000BC, "Member 'UParticleSystemDistanceFaderComponent::StartFadeDistance' has a wrong offset!");
static_assert(offsetof(UParticleSystemDistanceFaderComponent, EndFadeDistance) == 0x0000C0, "Member 'UParticleSystemDistanceFaderComponent::EndFadeDistance' has a wrong offset!");

// Class DeadByDaylight.PawnAudioManager
// 0x0020 (0x0058 - 0x0038)
class UPawnAudioManager final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x20];                                      // 0x0038(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool ForcePawnAudioPriority(class ADBDBasePlayer* Pawn);
	bool IsPawnCurrentlyActive(class ADBDBasePlayer* Pawn);
	bool PostAudioEventIfPawnCurrent(class ADBDBasePlayer* Pawn, class UAkAudioEvent* AudioEvent);
	void RegisterSlasherPawnAudio(class ADBDBasePlayer* SlasherPawn, TDelegate<void()> OnAudioEnabled, TDelegate<void()> OnAudioDisabled);
	void UnregisterSlasherPawnAudio(class ADBDBasePlayer* SlasherPawn);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PawnAudioManager">();
	}
	static class UPawnAudioManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPawnAudioManager>();
	}
};
static_assert(alignof(UPawnAudioManager) == 0x000008, "Wrong alignment on UPawnAudioManager");
static_assert(sizeof(UPawnAudioManager) == 0x000058, "Wrong size on UPawnAudioManager");

// Class DeadByDaylight.PerkCollectionComponent
// 0x0028 (0x00D0 - 0x00A8)
class UPerkCollectionComponent final : public UActorComponent
{
public:
	TArray<class UPerk*>                          _array;                                            // 0x00A8(0x0010)(ExportObject, Net, ZeroConstructor, Transient, RepNotify, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B8[0x18];                                      // 0x00B8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_Array(const TArray<class UPerk*>& OldArray);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PerkCollectionComponent">();
	}
	static class UPerkCollectionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPerkCollectionComponent>();
	}
};
static_assert(alignof(UPerkCollectionComponent) == 0x000008, "Wrong alignment on UPerkCollectionComponent");
static_assert(sizeof(UPerkCollectionComponent) == 0x0000D0, "Wrong size on UPerkCollectionComponent");
static_assert(offsetof(UPerkCollectionComponent, _array) == 0x0000A8, "Member 'UPerkCollectionComponent::_array' has a wrong offset!");

// Class DeadByDaylight.TileEventComponent
// 0x0010 (0x00B8 - 0x00A8)
class UTileEventComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x10];                                      // 0x00A8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TileEventComponent">();
	}
	static class UTileEventComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTileEventComponent>();
	}
};
static_assert(alignof(UTileEventComponent) == 0x000008, "Wrong alignment on UTileEventComponent");
static_assert(sizeof(UTileEventComponent) == 0x0000B8, "Wrong size on UTileEventComponent");

// Class DeadByDaylight.PerkDataAsset
// 0x0000 (0x0090 - 0x0090)
class UPerkDataAsset final : public UGameplayModifierContainerDataAsset
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PerkDataAsset">();
	}
	static class UPerkDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPerkDataAsset>();
	}
};
static_assert(alignof(UPerkDataAsset) == 0x000008, "Wrong alignment on UPerkDataAsset");
static_assert(sizeof(UPerkDataAsset) == 0x000090, "Wrong size on UPerkDataAsset");

// Class DeadByDaylight.PerkManagerOwnerInterface
// 0x0000 (0x0030 - 0x0030)
class IPerkManagerOwnerInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PerkManagerOwnerInterface">();
	}
	static class IPerkManagerOwnerInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPerkManagerOwnerInterface>();
	}
};
static_assert(alignof(IPerkManagerOwnerInterface) == 0x000008, "Wrong alignment on IPerkManagerOwnerInterface");
static_assert(sizeof(IPerkManagerOwnerInterface) == 0x000030, "Wrong size on IPerkManagerOwnerInterface");

// Class DeadByDaylight.PerkOwnerInterface
// 0x0000 (0x0030 - 0x0030)
class IPerkOwnerInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PerkOwnerInterface">();
	}
	static class IPerkOwnerInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPerkOwnerInterface>();
	}
};
static_assert(alignof(IPerkOwnerInterface) == 0x000008, "Wrong alignment on IPerkOwnerInterface");
static_assert(sizeof(IPerkOwnerInterface) == 0x000030, "Wrong size on IPerkOwnerInterface");

// Class DeadByDaylight.PerkTrappableComponent
// 0x0048 (0x00F0 - 0x00A8)
class UPerkTrappableComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnAddTrap;                                         // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRemoveTrap;                                      // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TSubclassOf<class AInteractable>              _interactableType;                                 // 0x00C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<ETrapType>                             _trapsOnInteractable;                              // 0x00D0(0x0010)(Net, ZeroConstructor, RepNotify, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_E0[0x10];                                      // 0x00E0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_TrapsOnInteractable();
	void OnTrapAddedOrRemoved__DelegateSignature(const ETrapType TrapType);

	bool HasAnyTrap() const;
	bool HasTrap(const ETrapType TrapType) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PerkTrappableComponent">();
	}
	static class UPerkTrappableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPerkTrappableComponent>();
	}
};
static_assert(alignof(UPerkTrappableComponent) == 0x000008, "Wrong alignment on UPerkTrappableComponent");
static_assert(sizeof(UPerkTrappableComponent) == 0x0000F0, "Wrong size on UPerkTrappableComponent");
static_assert(offsetof(UPerkTrappableComponent, OnAddTrap) == 0x0000A8, "Member 'UPerkTrappableComponent::OnAddTrap' has a wrong offset!");
static_assert(offsetof(UPerkTrappableComponent, OnRemoveTrap) == 0x0000B8, "Member 'UPerkTrappableComponent::OnRemoveTrap' has a wrong offset!");
static_assert(offsetof(UPerkTrappableComponent, _interactableType) == 0x0000C8, "Member 'UPerkTrappableComponent::_interactableType' has a wrong offset!");
static_assert(offsetof(UPerkTrappableComponent, _trapsOnInteractable) == 0x0000D0, "Member 'UPerkTrappableComponent::_trapsOnInteractable' has a wrong offset!");

// Class DeadByDaylight.PerkUtilitiesInterface
// 0x0000 (0x0030 - 0x0030)
class IPerkUtilitiesInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PerkUtilitiesInterface">();
	}
	static class IPerkUtilitiesInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPerkUtilitiesInterface>();
	}
};
static_assert(alignof(IPerkUtilitiesInterface) == 0x000008, "Wrong alignment on IPerkUtilitiesInterface");
static_assert(sizeof(IPerkUtilitiesInterface) == 0x000030, "Wrong size on IPerkUtilitiesInterface");

// Class DeadByDaylight.PerspectiveEffectActivator
// 0x0078 (0x0120 - 0x00A8)
class UPerspectiveEffectActivator final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x18];                                      // 0x00A8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, struct FPerspectiveEffectData> _perspectiveEffects;                               // 0x00C0(0x0050)(Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_110[0x10];                                     // 0x0110(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsEffectActive(class FName EffectName);
	void RegisterEffect(class FName EffectName, const struct FPerspectiveEffectData& EffectData);
	void SetWantsActive(class FName EffectName, bool WantsActive);
	void UnregisterEffect(class FName EffectName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PerspectiveEffectActivator">();
	}
	static class UPerspectiveEffectActivator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPerspectiveEffectActivator>();
	}
};
static_assert(alignof(UPerspectiveEffectActivator) == 0x000008, "Wrong alignment on UPerspectiveEffectActivator");
static_assert(sizeof(UPerspectiveEffectActivator) == 0x000120, "Wrong size on UPerspectiveEffectActivator");
static_assert(offsetof(UPerspectiveEffectActivator, _perspectiveEffects) == 0x0000C0, "Member 'UPerspectiveEffectActivator::_perspectiveEffects' has a wrong offset!");

// Class DeadByDaylight.PlagueUtilities
// 0x0000 (0x0030 - 0x0030)
class UPlagueUtilities final : public UBlueprintFunctionLibrary
{
public:
	static void Authority_AddSicknessToPlayer(class ADBDPlayer* Player, float SicknessToAdd);
	static class USurvivorPlagueEffect* GetPlagueEffect(const class ADBDPlayer* Player);
	static bool HasMaxLevelSickness(const class ADBDPlayer* Player);
	static bool IsInfected(const class ADBDPlayer* Player);
	static bool IsPlagueDebugModeActive();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlagueUtilities">();
	}
	static class UPlagueUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlagueUtilities>();
	}
};
static_assert(alignof(UPlagueUtilities) == 0x000008, "Wrong alignment on UPlagueUtilities");
static_assert(sizeof(UPlagueUtilities) == 0x000030, "Wrong size on UPlagueUtilities");

// Class DeadByDaylight.PlatformHelper
// 0x0000 (0x0030 - 0x0030)
class UPlatformHelper final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlatformHelper">();
	}
	static class UPlatformHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlatformHelper>();
	}
};
static_assert(alignof(UPlatformHelper) == 0x000008, "Wrong alignment on UPlatformHelper");
static_assert(sizeof(UPlatformHelper) == 0x000030, "Wrong size on UPlatformHelper");

// Class DeadByDaylight.PlayerCardSubsystem
// 0x0000 (0x0038 - 0x0038)
class UPlayerCardSubsystem final : public UGameInstanceSubsystem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerCardSubsystem">();
	}
	static class UPlayerCardSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerCardSubsystem>();
	}
};
static_assert(alignof(UPlayerCardSubsystem) == 0x000008, "Wrong alignment on UPlayerCardSubsystem");
static_assert(sizeof(UPlayerCardSubsystem) == 0x000038, "Wrong size on UPlayerCardSubsystem");

// Class DeadByDaylight.PlayerDebugComponent
// 0x0008 (0x00B0 - 0x00A8)
class UPlayerDebugComponent final : public UActorComponent
{
public:
	bool                                          _disableStartUpdateMontageDuringEnter;             // 0x00A8(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _allowPalletPullUpInteraction;                     // 0x00A9(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_AA[0x6];                                       // 0x00AA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerDebugComponent">();
	}
	static class UPlayerDebugComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerDebugComponent>();
	}
};
static_assert(alignof(UPlayerDebugComponent) == 0x000008, "Wrong alignment on UPlayerDebugComponent");
static_assert(sizeof(UPlayerDebugComponent) == 0x0000B0, "Wrong size on UPlayerDebugComponent");
static_assert(offsetof(UPlayerDebugComponent, _disableStartUpdateMontageDuringEnter) == 0x0000A8, "Member 'UPlayerDebugComponent::_disableStartUpdateMontageDuringEnter' has a wrong offset!");
static_assert(offsetof(UPlayerDebugComponent, _allowPalletPullUpInteraction) == 0x0000A9, "Member 'UPlayerDebugComponent::_allowPalletPullUpInteraction' has a wrong offset!");

// Class DeadByDaylight.StorePurchasingPopupHandler
// 0x0008 (0x0040 - 0x0038)
class UStorePurchasingPopupHandler final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StorePurchasingPopupHandler">();
	}
	static class UStorePurchasingPopupHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStorePurchasingPopupHandler>();
	}
};
static_assert(alignof(UStorePurchasingPopupHandler) == 0x000008, "Wrong alignment on UStorePurchasingPopupHandler");
static_assert(sizeof(UStorePurchasingPopupHandler) == 0x000040, "Wrong size on UStorePurchasingPopupHandler");

// Class DeadByDaylight.PlayerGameRelevancyComponent
// 0x0070 (0x0118 - 0x00A8)
class UPlayerGameRelevancyComponent final : public UActorComponent
{
public:
	struct FTagStateBool                          _isRelevantToGameplay;                             // 0x00A8(0x0048)(Net, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F0[0x28];                                      // 0x00F0(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerGameRelevancyComponent">();
	}
	static class UPlayerGameRelevancyComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerGameRelevancyComponent>();
	}
};
static_assert(alignof(UPlayerGameRelevancyComponent) == 0x000008, "Wrong alignment on UPlayerGameRelevancyComponent");
static_assert(sizeof(UPlayerGameRelevancyComponent) == 0x000118, "Wrong size on UPlayerGameRelevancyComponent");
static_assert(offsetof(UPlayerGameRelevancyComponent, _isRelevantToGameplay) == 0x0000A8, "Member 'UPlayerGameRelevancyComponent::_isRelevantToGameplay' has a wrong offset!");

// Class DeadByDaylight.PlayerInGameAssetPreloadState
// 0x0018 (0x00C0 - 0x00A8)
class UPlayerInGameAssetPreloadState final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x18];                                      // 0x00A8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Server_SetPreloadCompleted(const class FString& PreloadInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerInGameAssetPreloadState">();
	}
	static class UPlayerInGameAssetPreloadState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerInGameAssetPreloadState>();
	}
};
static_assert(alignof(UPlayerInGameAssetPreloadState) == 0x000008, "Wrong alignment on UPlayerInGameAssetPreloadState");
static_assert(sizeof(UPlayerInGameAssetPreloadState) == 0x0000C0, "Wrong size on UPlayerInGameAssetPreloadState");

// Class DeadByDaylight.TrapInstallerComponent
// 0x0010 (0x00B8 - 0x00A8)
class UTrapInstallerComponent final : public UActorComponent
{
public:
	TArray<class USurvivorTrapPerk*>              _ownedTrapPerks;                                   // 0x00A8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TrapInstallerComponent">();
	}
	static class UTrapInstallerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTrapInstallerComponent>();
	}
};
static_assert(alignof(UTrapInstallerComponent) == 0x000008, "Wrong alignment on UTrapInstallerComponent");
static_assert(sizeof(UTrapInstallerComponent) == 0x0000B8, "Wrong size on UTrapInstallerComponent");
static_assert(offsetof(UTrapInstallerComponent, _ownedTrapPerks) == 0x0000A8, "Member 'UTrapInstallerComponent::_ownedTrapPerks' has a wrong offset!");

// Class DeadByDaylight.PlayerLockerStateComponent
// 0x00A8 (0x0150 - 0x00A8)
class UPlayerLockerStateComponent final : public UActorComponent
{
public:
	TWeakObjectPtr<class ALocker>                 _lockerPlayerIsHidingIn;                           // 0x00A8(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class ALocker>                 _lockerBeingOpenedByPlayer;                        // 0x00B0(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B8[0x98];                                      // 0x00B8(0x0098)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnSurvivorEndPlay(class AActor* Actor, EEndPlayReason EndPlayReason);
	void Multicast_EjectSurvivor(class ALocker* Locker);
	void OnRep_LockerBeingOpenedByPlayer();
	void OnRep_LockerPlayerIsHidingIn();
	void OnSurvivorHealthChanged(ECamperDamageState before, ECamperDamageState After);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerLockerStateComponent">();
	}
	static class UPlayerLockerStateComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerLockerStateComponent>();
	}
};
static_assert(alignof(UPlayerLockerStateComponent) == 0x000008, "Wrong alignment on UPlayerLockerStateComponent");
static_assert(sizeof(UPlayerLockerStateComponent) == 0x000150, "Wrong size on UPlayerLockerStateComponent");
static_assert(offsetof(UPlayerLockerStateComponent, _lockerPlayerIsHidingIn) == 0x0000A8, "Member 'UPlayerLockerStateComponent::_lockerPlayerIsHidingIn' has a wrong offset!");
static_assert(offsetof(UPlayerLockerStateComponent, _lockerBeingOpenedByPlayer) == 0x0000B0, "Member 'UPlayerLockerStateComponent::_lockerBeingOpenedByPlayer' has a wrong offset!");

// Class DeadByDaylight.PlayerMoveBackAndForthComponent
// 0x0050 (0x00F8 - 0x00A8)
class UPlayerMoveBackAndForthComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x50];                                      // 0x00A8(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnMoveTimerDone();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerMoveBackAndForthComponent">();
	}
	static class UPlayerMoveBackAndForthComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerMoveBackAndForthComponent>();
	}
};
static_assert(alignof(UPlayerMoveBackAndForthComponent) == 0x000008, "Wrong alignment on UPlayerMoveBackAndForthComponent");
static_assert(sizeof(UPlayerMoveBackAndForthComponent) == 0x0000F8, "Wrong size on UPlayerMoveBackAndForthComponent");

// Class DeadByDaylight.PlayerNameRegistration
// 0x0068 (0x0098 - 0x0030)
class UPlayerNameRegistration final : public UObject
{
public:
	uint8                                         Pad_30[0x68];                                      // 0x0030(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerNameRegistration">();
	}
	static class UPlayerNameRegistration* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerNameRegistration>();
	}
};
static_assert(alignof(UPlayerNameRegistration) == 0x000008, "Wrong alignment on UPlayerNameRegistration");
static_assert(sizeof(UPlayerNameRegistration) == 0x000098, "Wrong size on UPlayerNameRegistration");

// Class DeadByDaylight.SpherePlayerOverlapComponent
// 0x0000 (0x05C0 - 0x05C0)
class USpherePlayerOverlapComponent final : public USphereComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpherePlayerOverlapComponent">();
	}
	static class USpherePlayerOverlapComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpherePlayerOverlapComponent>();
	}
};
static_assert(alignof(USpherePlayerOverlapComponent) == 0x000010, "Wrong alignment on USpherePlayerOverlapComponent");
static_assert(sizeof(USpherePlayerOverlapComponent) == 0x0005C0, "Wrong size on USpherePlayerOverlapComponent");

// Class DeadByDaylight.CapsulePlayerOverlapComponent
// 0x0000 (0x05C0 - 0x05C0)
class UCapsulePlayerOverlapComponent final : public UCapsuleComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CapsulePlayerOverlapComponent">();
	}
	static class UCapsulePlayerOverlapComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCapsulePlayerOverlapComponent>();
	}
};
static_assert(alignof(UCapsulePlayerOverlapComponent) == 0x000010, "Wrong alignment on UCapsulePlayerOverlapComponent");
static_assert(sizeof(UCapsulePlayerOverlapComponent) == 0x0005C0, "Wrong size on UCapsulePlayerOverlapComponent");

// Class DeadByDaylight.BoxPlayerOverlapComponent
// 0x0000 (0x05D0 - 0x05D0)
class UBoxPlayerOverlapComponent final : public UBoxComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BoxPlayerOverlapComponent">();
	}
	static class UBoxPlayerOverlapComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBoxPlayerOverlapComponent>();
	}
};
static_assert(alignof(UBoxPlayerOverlapComponent) == 0x000010, "Wrong alignment on UBoxPlayerOverlapComponent");
static_assert(sizeof(UBoxPlayerOverlapComponent) == 0x0005D0, "Wrong size on UBoxPlayerOverlapComponent");

// Class DeadByDaylight.PlayerPerspectiveComponent
// 0x00A8 (0x0150 - 0x00A8)
class UPlayerPerspectiveComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0xA8];                                      // 0x00A8(0x00A8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPawnControllerChanged(class APawn* Pawn, class AController* OldController, class AController* NewController);
	void UpdateLocallyObserved();

	bool IsLocallyObserved() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerPerspectiveComponent">();
	}
	static class UPlayerPerspectiveComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerPerspectiveComponent>();
	}
};
static_assert(alignof(UPlayerPerspectiveComponent) == 0x000008, "Wrong alignment on UPlayerPerspectiveComponent");
static_assert(sizeof(UPlayerPerspectiveComponent) == 0x000150, "Wrong size on UPlayerPerspectiveComponent");

// Class DeadByDaylight.PlayerReportManager
// 0x00A0 (0x00D8 - 0x0038)
class UPlayerReportManager final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UDBDGameInstance*                       _gameInstance;                                     // 0x0040(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_48[0x90];                                      // 0x0048(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerReportManager">();
	}
	static class UPlayerReportManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerReportManager>();
	}
};
static_assert(alignof(UPlayerReportManager) == 0x000008, "Wrong alignment on UPlayerReportManager");
static_assert(sizeof(UPlayerReportManager) == 0x0000D8, "Wrong size on UPlayerReportManager");
static_assert(offsetof(UPlayerReportManager, _gameInstance) == 0x000040, "Member 'UPlayerReportManager::_gameInstance' has a wrong offset!");

// Class DeadByDaylight.PlayerScoreComponent
// 0x00A8 (0x0150 - 0x00A8)
class UPlayerScoreComponent final : public UActorComponent
{
public:
	TSoftObjectPtr<class UDataTable>              _scoreEmitterDB;                                   // 0x00A8(0x0038)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSet<class UPlayerScoreEmitter*>              _emitters;                                         // 0x00E0(0x0050)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_130[0x20];                                     // 0x0130(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerScoreComponent">();
	}
	static class UPlayerScoreComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerScoreComponent>();
	}
};
static_assert(alignof(UPlayerScoreComponent) == 0x000008, "Wrong alignment on UPlayerScoreComponent");
static_assert(sizeof(UPlayerScoreComponent) == 0x000150, "Wrong size on UPlayerScoreComponent");
static_assert(offsetof(UPlayerScoreComponent, _scoreEmitterDB) == 0x0000A8, "Member 'UPlayerScoreComponent::_scoreEmitterDB' has a wrong offset!");
static_assert(offsetof(UPlayerScoreComponent, _emitters) == 0x0000E0, "Member 'UPlayerScoreComponent::_emitters' has a wrong offset!");

// Class DeadByDaylight.PlayerSkeletalMeshComponentBudgeted
// 0x0000 (0x1130 - 0x1130)
class UPlayerSkeletalMeshComponentBudgeted final : public UDBDSkeletalMeshComponentBudgeted
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerSkeletalMeshComponentBudgeted">();
	}
	static class UPlayerSkeletalMeshComponentBudgeted* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerSkeletalMeshComponentBudgeted>();
	}
};
static_assert(alignof(UPlayerSkeletalMeshComponentBudgeted) == 0x000010, "Wrong alignment on UPlayerSkeletalMeshComponentBudgeted");
static_assert(sizeof(UPlayerSkeletalMeshComponentBudgeted) == 0x001130, "Wrong size on UPlayerSkeletalMeshComponentBudgeted");

// Class DeadByDaylight.PlayerStateScoreEmitter
// 0x00B8 (0x00F0 - 0x0038)
class UPlayerStateScoreEmitter final : public UPlayerScoreEmitter
{
public:
	struct FGameplayTag                           _scoreTag;                                         // 0x0038(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _scoreUpdateInterval;                              // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTagQuery                      _tagQuery;                                         // 0x0048(0x0048)(Edit, NativeAccessSpecifierPrivate)
	uint8                                         Pad_90[0x60];                                      // 0x0090(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerStateScoreEmitter">();
	}
	static class UPlayerStateScoreEmitter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerStateScoreEmitter>();
	}
};
static_assert(alignof(UPlayerStateScoreEmitter) == 0x000008, "Wrong alignment on UPlayerStateScoreEmitter");
static_assert(sizeof(UPlayerStateScoreEmitter) == 0x0000F0, "Wrong size on UPlayerStateScoreEmitter");
static_assert(offsetof(UPlayerStateScoreEmitter, _scoreTag) == 0x000038, "Member 'UPlayerStateScoreEmitter::_scoreTag' has a wrong offset!");
static_assert(offsetof(UPlayerStateScoreEmitter, _scoreUpdateInterval) == 0x000044, "Member 'UPlayerStateScoreEmitter::_scoreUpdateInterval' has a wrong offset!");
static_assert(offsetof(UPlayerStateScoreEmitter, _tagQuery) == 0x000048, "Member 'UPlayerStateScoreEmitter::_tagQuery' has a wrong offset!");

// Class DeadByDaylight.ShopNewSeenItemSubsystem
// 0x0038 (0x0070 - 0x0038)
class UShopNewSeenItemSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x38];                                      // 0x0038(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShopNewSeenItemSubsystem">();
	}
	static class UShopNewSeenItemSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShopNewSeenItemSubsystem>();
	}
};
static_assert(alignof(UShopNewSeenItemSubsystem) == 0x000008, "Wrong alignment on UShopNewSeenItemSubsystem");
static_assert(sizeof(UShopNewSeenItemSubsystem) == 0x000070, "Wrong size on UShopNewSeenItemSubsystem");

// Class DeadByDaylight.PollableEventListener
// 0x0010 (0x00B8 - 0x00A8)
class UPollableEventListener final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x10];                                      // 0x00A8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PollableEventListener">();
	}
	static class UPollableEventListener* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPollableEventListener>();
	}
};
static_assert(alignof(UPollableEventListener) == 0x000008, "Wrong alignment on UPollableEventListener");
static_assert(sizeof(UPollableEventListener) == 0x0000B8, "Wrong size on UPollableEventListener");

// Class DeadByDaylight.UIController
// 0x0028 (0x0058 - 0x0030)
class UUIController final : public UObject
{
public:
	class UGFxObject*                             M_UIControllerObj;                                 // 0x0030(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_38[0x20];                                      // 0x0038(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DrawBlockingArea(const class FString& ID, const struct FGeometry& Geometry);
	void RemoveBlockingArea(const class FString& ID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIController">();
	}
	static class UUIController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIController>();
	}
};
static_assert(alignof(UUIController) == 0x000008, "Wrong alignment on UUIController");
static_assert(sizeof(UUIController) == 0x000058, "Wrong size on UUIController");
static_assert(offsetof(UUIController, M_UIControllerObj) == 0x000030, "Member 'UUIController::M_UIControllerObj' has a wrong offset!");

// Class DeadByDaylight.PoolableProjectileComponent
// 0x0000 (0x00C8 - 0x00C8)
class UPoolableProjectileComponent final : public UAuthoritativePoolableActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PoolableProjectileComponent">();
	}
	static class UPoolableProjectileComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPoolableProjectileComponent>();
	}
};
static_assert(alignof(UPoolableProjectileComponent) == 0x000008, "Wrong alignment on UPoolableProjectileComponent");
static_assert(sizeof(UPoolableProjectileComponent) == 0x0000C8, "Wrong size on UPoolableProjectileComponent");

// Class DeadByDaylight.PopupFactory
// 0x0008 (0x0038 - 0x0030)
class UPopupFactory final : public UObject
{
public:
	class UDBDGameInstance*                       _gameInstance;                                     // 0x0030(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PopupFactory">();
	}
	static class UPopupFactory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPopupFactory>();
	}
};
static_assert(alignof(UPopupFactory) == 0x000008, "Wrong alignment on UPopupFactory");
static_assert(sizeof(UPopupFactory) == 0x000038, "Wrong size on UPopupFactory");
static_assert(offsetof(UPopupFactory, _gameInstance) == 0x000030, "Member 'UPopupFactory::_gameInstance' has a wrong offset!");

// Class DeadByDaylight.PopupSequencer
// 0x0040 (0x0070 - 0x0030)
class alignas(0x10) UPopupSequencer final : public UObject
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UDBDGameInstance*                       _gameInstance;                                     // 0x0038(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_40[0x30];                                      // 0x0040(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PopupSequencer">();
	}
	static class UPopupSequencer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPopupSequencer>();
	}
};
static_assert(alignof(UPopupSequencer) == 0x000010, "Wrong alignment on UPopupSequencer");
static_assert(sizeof(UPopupSequencer) == 0x000070, "Wrong size on UPopupSequencer");
static_assert(offsetof(UPopupSequencer, _gameInstance) == 0x000038, "Member 'UPopupSequencer::_gameInstance' has a wrong offset!");

// Class DeadByDaylight.PostProcessUpdate
// 0x0000 (0x02A0 - 0x02A0)
class APostProcessUpdate final : public AActor
{
public:
	void PostProcessToggle(bool Toggle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PostProcessUpdate">();
	}
	static class APostProcessUpdate* GetDefaultObj()
	{
		return GetDefaultObjImpl<APostProcessUpdate>();
	}
};
static_assert(alignof(APostProcessUpdate) == 0x000008, "Wrong alignment on APostProcessUpdate");
static_assert(sizeof(APostProcessUpdate) == 0x0002A0, "Wrong size on APostProcessUpdate");

// Class DeadByDaylight.PowerWidgetData
// 0x0070 (0x00A8 - 0x0038)
class UPowerWidgetData final : public UDataAsset
{
public:
	TMap<struct FGameplayTag, TSoftObjectPtr<class UTexture2D>> _icons;                                            // 0x0038(0x0050)(Edit, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	class FName                                   _widgetId;                                         // 0x0088(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EInputInteractionType                         _interactionInputType;                             // 0x0094(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EInteractionPromptType                        _interactionPromptType;                            // 0x0095(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_96[0x2];                                       // 0x0096(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           _presentationId;                                   // 0x0098(0x000C)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PowerWidgetData">();
	}
	static class UPowerWidgetData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPowerWidgetData>();
	}
};
static_assert(alignof(UPowerWidgetData) == 0x000008, "Wrong alignment on UPowerWidgetData");
static_assert(sizeof(UPowerWidgetData) == 0x0000A8, "Wrong size on UPowerWidgetData");
static_assert(offsetof(UPowerWidgetData, _icons) == 0x000038, "Member 'UPowerWidgetData::_icons' has a wrong offset!");
static_assert(offsetof(UPowerWidgetData, _widgetId) == 0x000088, "Member 'UPowerWidgetData::_widgetId' has a wrong offset!");
static_assert(offsetof(UPowerWidgetData, _interactionInputType) == 0x000094, "Member 'UPowerWidgetData::_interactionInputType' has a wrong offset!");
static_assert(offsetof(UPowerWidgetData, _interactionPromptType) == 0x000095, "Member 'UPowerWidgetData::_interactionPromptType' has a wrong offset!");
static_assert(offsetof(UPowerWidgetData, _presentationId) == 0x000098, "Member 'UPowerWidgetData::_presentationId' has a wrong offset!");

// Class DeadByDaylight.PremiumTransactionSubsystem
// 0x0020 (0x0058 - 0x0038)
class UPremiumTransactionSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x20];                                      // 0x0038(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PremiumTransactionSubsystem">();
	}
	static class UPremiumTransactionSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPremiumTransactionSubsystem>();
	}
};
static_assert(alignof(UPremiumTransactionSubsystem) == 0x000008, "Wrong alignment on UPremiumTransactionSubsystem");
static_assert(sizeof(UPremiumTransactionSubsystem) == 0x000058, "Wrong size on UPremiumTransactionSubsystem");

// Class DeadByDaylight.PresenterUtilities
// 0x0000 (0x0030 - 0x0030)
class UPresenterUtilities final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PresenterUtilities">();
	}
	static class UPresenterUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPresenterUtilities>();
	}
};
static_assert(alignof(UPresenterUtilities) == 0x000008, "Wrong alignment on UPresenterUtilities");
static_assert(sizeof(UPresenterUtilities) == 0x000030, "Wrong size on UPresenterUtilities");

// Class DeadByDaylight.PresetControllerSubsystem
// 0x0010 (0x0048 - 0x0038)
class UPresetControllerSubsystem final : public UGameInstanceSubsystem
{
public:
	class ULoadoutPresetController*               _loadoutController;                                // 0x0038(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCustomizationPresetController*         _customizationController;                          // 0x0040(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PresetControllerSubsystem">();
	}
	static class UPresetControllerSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPresetControllerSubsystem>();
	}
};
static_assert(alignof(UPresetControllerSubsystem) == 0x000008, "Wrong alignment on UPresetControllerSubsystem");
static_assert(sizeof(UPresetControllerSubsystem) == 0x000048, "Wrong size on UPresetControllerSubsystem");
static_assert(offsetof(UPresetControllerSubsystem, _loadoutController) == 0x000038, "Member 'UPresetControllerSubsystem::_loadoutController' has a wrong offset!");
static_assert(offsetof(UPresetControllerSubsystem, _customizationController) == 0x000040, "Member 'UPresetControllerSubsystem::_customizationController' has a wrong offset!");

// Class DeadByDaylight.TutorialGameState
// 0x00A0 (0x0B20 - 0x0A80)
class ATutorialGameState final : public ADBDGameState
{
public:
	FMulticastInlineDelegateProperty_             OnCurrentTutorialStepChanged;                      // 0x0A80(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_A90[0x38];                                     // 0x0A90(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _forceHatchVisible;                                // 0x0AC8(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_AC9[0x57];                                     // 0x0AC9(0x0057)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCurrentTutorialStepChanged__DelegateSignature(ETutorialStep Step);
	void SetCurrentTutorialStep(ETutorialStep Step);
	void SetForcedHatchVisibility(bool Param_IsHatchVisible);
	void TutorialEndReached();

	void CompleteLocallyControlledCharacterIntros() const;
	ETutorialStep GetCurrentTutorialStep() const;
	bool IsTutorialStarted() const;
	void SetEscapeRequirementsVisibility(bool IsVisible) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TutorialGameState">();
	}
	static class ATutorialGameState* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATutorialGameState>();
	}
};
static_assert(alignof(ATutorialGameState) == 0x000008, "Wrong alignment on ATutorialGameState");
static_assert(sizeof(ATutorialGameState) == 0x000B20, "Wrong size on ATutorialGameState");
static_assert(offsetof(ATutorialGameState, OnCurrentTutorialStepChanged) == 0x000A80, "Member 'ATutorialGameState::OnCurrentTutorialStepChanged' has a wrong offset!");
static_assert(offsetof(ATutorialGameState, _forceHatchVisible) == 0x000AC8, "Member 'ATutorialGameState::_forceHatchVisible' has a wrong offset!");

// Class DeadByDaylight.ProceduralGenerationData
// 0x0138 (0x0170 - 0x0038)
class UProceduralGenerationData final : public UDataAsset
{
public:
	TArray<struct FQuadrantSpawnTypeProperties>   QuadrantSpawnTypeProperties;                       // 0x0038(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FQuadrantSpawnCategories>       QuadrantSpawnCategories;                           // 0x0048(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FThemeProperties>               ThemeProperties;                                   // 0x0058(0x0010)(ZeroConstructor, Deprecated, NativeAccessSpecifierPublic)
	TArray<struct FKillerItemDependencies>        KillersItemDependencies;                           // 0x0068(0x0010)(ZeroConstructor, Deprecated, NativeAccessSpecifierPublic)
	class UCurveFloat*                            SurvivorItemPopulationProbability;                 // 0x0078(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSurvivorItemProperties>        SurvivorItemProperty;                              // 0x0080(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FEscapeTypeObjects>             EscapeTypeActors;                                  // 0x0090(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<TSoftClassPtr<class UClass>>           Basements;                                         // 0x00A0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<struct FGameplayElementsPopulation>    ElementsPopulation;                                // 0x00B0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FManagedGameplayElementsPopulation> ManagedElementsPopulation;                         // 0x00C0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FSurvivorGroupingProbability>   SurvivorGroupingProbabilities;                     // 0x00D0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FVector                                ProceduralMapOffset;                               // 0x00E0(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProceduralTileWidth;                               // 0x00F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProceduralTileHeight;                              // 0x00FC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ProceduralQuadTileMapOffset;                       // 0x0100(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProceduralQuadTileCubeWidth;                       // 0x0118(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DifficultyModifier;                                // 0x011C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CharacterCameraHeight;                             // 0x0120(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CharacterCollisionRadius;                          // 0x0124(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpawnerCollisionRadius;                            // 0x0128(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TotemVisualHeight;                                 // 0x012C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClosestSurvivorDistanceWeight;                     // 0x0130(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KillerDistanceWeight;                              // 0x0134(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSpecialBehaviourPopulation>    SpecialBehaviourPopulation;                        // 0x0138(0x0010)(ZeroConstructor, Deprecated, NativeAccessSpecifierPrivate)
	TArray<struct FEventSubstitionData>           _eventProperties;                                  // 0x0148(0x0010)(ZeroConstructor, Deprecated, NativeAccessSpecifierPrivate)
	uint8                                         Pad_158[0x18];                                     // 0x0158(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProceduralGenerationData">();
	}
	static class UProceduralGenerationData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProceduralGenerationData>();
	}
};
static_assert(alignof(UProceduralGenerationData) == 0x000008, "Wrong alignment on UProceduralGenerationData");
static_assert(sizeof(UProceduralGenerationData) == 0x000170, "Wrong size on UProceduralGenerationData");
static_assert(offsetof(UProceduralGenerationData, QuadrantSpawnTypeProperties) == 0x000038, "Member 'UProceduralGenerationData::QuadrantSpawnTypeProperties' has a wrong offset!");
static_assert(offsetof(UProceduralGenerationData, QuadrantSpawnCategories) == 0x000048, "Member 'UProceduralGenerationData::QuadrantSpawnCategories' has a wrong offset!");
static_assert(offsetof(UProceduralGenerationData, ThemeProperties) == 0x000058, "Member 'UProceduralGenerationData::ThemeProperties' has a wrong offset!");
static_assert(offsetof(UProceduralGenerationData, KillersItemDependencies) == 0x000068, "Member 'UProceduralGenerationData::KillersItemDependencies' has a wrong offset!");
static_assert(offsetof(UProceduralGenerationData, SurvivorItemPopulationProbability) == 0x000078, "Member 'UProceduralGenerationData::SurvivorItemPopulationProbability' has a wrong offset!");
static_assert(offsetof(UProceduralGenerationData, SurvivorItemProperty) == 0x000080, "Member 'UProceduralGenerationData::SurvivorItemProperty' has a wrong offset!");
static_assert(offsetof(UProceduralGenerationData, EscapeTypeActors) == 0x000090, "Member 'UProceduralGenerationData::EscapeTypeActors' has a wrong offset!");
static_assert(offsetof(UProceduralGenerationData, Basements) == 0x0000A0, "Member 'UProceduralGenerationData::Basements' has a wrong offset!");
static_assert(offsetof(UProceduralGenerationData, ElementsPopulation) == 0x0000B0, "Member 'UProceduralGenerationData::ElementsPopulation' has a wrong offset!");
static_assert(offsetof(UProceduralGenerationData, ManagedElementsPopulation) == 0x0000C0, "Member 'UProceduralGenerationData::ManagedElementsPopulation' has a wrong offset!");
static_assert(offsetof(UProceduralGenerationData, SurvivorGroupingProbabilities) == 0x0000D0, "Member 'UProceduralGenerationData::SurvivorGroupingProbabilities' has a wrong offset!");
static_assert(offsetof(UProceduralGenerationData, ProceduralMapOffset) == 0x0000E0, "Member 'UProceduralGenerationData::ProceduralMapOffset' has a wrong offset!");
static_assert(offsetof(UProceduralGenerationData, ProceduralTileWidth) == 0x0000F8, "Member 'UProceduralGenerationData::ProceduralTileWidth' has a wrong offset!");
static_assert(offsetof(UProceduralGenerationData, ProceduralTileHeight) == 0x0000FC, "Member 'UProceduralGenerationData::ProceduralTileHeight' has a wrong offset!");
static_assert(offsetof(UProceduralGenerationData, ProceduralQuadTileMapOffset) == 0x000100, "Member 'UProceduralGenerationData::ProceduralQuadTileMapOffset' has a wrong offset!");
static_assert(offsetof(UProceduralGenerationData, ProceduralQuadTileCubeWidth) == 0x000118, "Member 'UProceduralGenerationData::ProceduralQuadTileCubeWidth' has a wrong offset!");
static_assert(offsetof(UProceduralGenerationData, DifficultyModifier) == 0x00011C, "Member 'UProceduralGenerationData::DifficultyModifier' has a wrong offset!");
static_assert(offsetof(UProceduralGenerationData, CharacterCameraHeight) == 0x000120, "Member 'UProceduralGenerationData::CharacterCameraHeight' has a wrong offset!");
static_assert(offsetof(UProceduralGenerationData, CharacterCollisionRadius) == 0x000124, "Member 'UProceduralGenerationData::CharacterCollisionRadius' has a wrong offset!");
static_assert(offsetof(UProceduralGenerationData, SpawnerCollisionRadius) == 0x000128, "Member 'UProceduralGenerationData::SpawnerCollisionRadius' has a wrong offset!");
static_assert(offsetof(UProceduralGenerationData, TotemVisualHeight) == 0x00012C, "Member 'UProceduralGenerationData::TotemVisualHeight' has a wrong offset!");
static_assert(offsetof(UProceduralGenerationData, ClosestSurvivorDistanceWeight) == 0x000130, "Member 'UProceduralGenerationData::ClosestSurvivorDistanceWeight' has a wrong offset!");
static_assert(offsetof(UProceduralGenerationData, KillerDistanceWeight) == 0x000134, "Member 'UProceduralGenerationData::KillerDistanceWeight' has a wrong offset!");
static_assert(offsetof(UProceduralGenerationData, SpecialBehaviourPopulation) == 0x000138, "Member 'UProceduralGenerationData::SpecialBehaviourPopulation' has a wrong offset!");
static_assert(offsetof(UProceduralGenerationData, _eventProperties) == 0x000148, "Member 'UProceduralGenerationData::_eventProperties' has a wrong offset!");

// Class DeadByDaylight.ProceduralLevelBuilder
// 0x11D0 (0x1470 - 0x02A0)
class AProceduralLevelBuilder : public AActor
{
public:
	uint8                                         Pad_2A0[0x40];                                     // 0x02A0(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 PathToMapDirectory;                                // 0x02E0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PathToTilesDirectory;                              // 0x02F0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PathToEventSpawnablesDirectory;                    // 0x0300(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         EventSpawnablesParentDirectories;                  // 0x0310(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         EventSpawnablePositionWeightCoefficient;           // 0x0320(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EventSpawnablePositionWeightPowerBase;             // 0x0324(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EGameplayElementType, float>             StaticActorSpawnerDecorationBudgets;               // 0x0328(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<ETileSpawnPointType, float>              StaticSpawnPointDecorationBudgets;                 // 0x0378(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         KillerMinProximityFromCamper;                      // 0x03C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SurvivorMinProximityFromOtherCamper;               // 0x03CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinProximityBetweenGenerators;                     // 0x03D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinProximityBetweenChests;                         // 0x03D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinProximityBetweenTotems;                         // 0x03D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SurvivorMinProximityFromGenerator;                 // 0x03DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SurvivorMinProximityFromTotem;                     // 0x03E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SurvivorMaxLineOfSightFromTotem;                   // 0x03E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinProximityBetweenSpecialBehaviourItems;          // 0x03E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpecialBehaviourItemMinProximityFromSurvivor;      // 0x03EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpecialBehaviourItemMinProximityFromKiller;        // 0x03F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3F4[0x4];                                      // 0x03F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UPaperTileMap>              DebugMap;                                          // 0x03F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class ATile>>              DebugTiles;                                        // 0x0400(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	float                                         SmallMeatLockerMinProximityFromKillerLair;         // 0x0410(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FactorToAdjustToWhenOutOfProximity;                // 0x0414(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FactorToAdjustToWhenInLineOfSight;                 // 0x0418(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeightAmplifier;                                   // 0x041C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeightAmplifierActivationHeight;                   // 0x0420(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_424[0x4];                                      // 0x0424(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UProceduralGenerationData*              ProceduralGenerationData;                          // 0x0428(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataTable>              AmbiancePriorities;                                // 0x0430(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataAsset>              PerMapLightData;                                   // 0x0468(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TileWeightRateOfDecay;                             // 0x04A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         QuadTileWeightRateOfDecay;                         // 0x04A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A8[0x18];                                     // 0x04A8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UClass*                                 _tileClass;                                        // 0x04C0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4C8[0x1E8];                                    // 0x04C8(0x01E8)(Fixing Size After Last Property [ Dumper-7 ])
	class UMapData*                               _mapData;                                          // 0x06B0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class ATile*>                          _outOfWorldTiles;                                  // 0x06B8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class UAkAudioBank*                           _ambientAudioBank;                                 // 0x06C8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UObjectLibrary*                         _availableTilesLibrary;                            // 0x06D0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UObjectLibrary*                         _availableEventSpawnablesLibrary;                  // 0x06D8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6E0[0xE8];                                     // 0x06E0(0x00E8)(Fixing Size After Last Property [ Dumper-7 ])
	class UObjectLibrary*                         _availableDerivedTileLibrary;                      // 0x07C8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7D0[0x38];                                     // 0x07D0(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGeneratedLevelData                    _generatedData;                                    // 0x0808(0x0380)(ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B88[0x380];                                    // 0x0B88(0x0380)(Fixing Size After Last Property [ Dumper-7 ])
	class UTileMatrix*                            _tileMatrix;                                       // 0x0F08(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTileBank*                              _tileBank;                                         // 0x0F10(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F18[0x68];                                     // 0x0F18(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	class UActorSpawner*                          _killerLairSpawner;                                // 0x0F80(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F88[0x8];                                      // 0x0F88(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSoftObjectPath>                _preloadAssetReferences;                           // 0x0F90(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<TSubclassOf<class AActor>>             _chestItemAssetReferences;                         // 0x0FA0(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<class UClass*>                         _slasherPawns;                                     // 0x0FB0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_FC0[0x20];                                     // 0x0FC0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ATile*>                          _tilesThatHaveBeenSpawned;                         // 0x0FE0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_FF0[0x18];                                     // 0x0FF0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         _eventSpawnablesThatHaveBeenStreamed;              // 0x1008(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1018[0x18];                                    // 0x1018(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class AProceduralLevelData*                   _debugProceduralDatas;                             // 0x1030(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ADBDClientSyncer*                       _syncer;                                           // 0x1038(0x0008)(Net, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBlackboardComponent*                   _blackboardComp;                                   // 0x1040(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1048[0x50];                                    // 0x1048(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class UEdgeObjectHandlingStrategy*            _edgeObjectHandlingStrategy;                       // 0x1098(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_10A0[0x2F8];                                   // 0x10A0(0x02F8)(Fixing Size After Last Property [ Dumper-7 ])
	class ATile*                                  _backupKillerLairTile;                             // 0x1398(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_13A0[0x78];                                    // 0x13A0(0x0078)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class AActor*, struct FSpawnInfo>        _spawnedActorAttachmentInfo;                       // 0x1418(0x0050)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1468[0x8];                                     // 0x1468(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyMist(float Modifier);
	void BuildFromSeed();
	void Multicast_DebugShareGenerationData(const struct FGenerationParams& UsedParams);
	void RemoveMist();
	class AActor* SpawnActor(class UClass* ActorClass, ETileSpawnPointType SpawnPointType);
	void StartGenerationOnSyncerReady();
	void SyncSeeds();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProceduralLevelBuilder">();
	}
	static class AProceduralLevelBuilder* GetDefaultObj()
	{
		return GetDefaultObjImpl<AProceduralLevelBuilder>();
	}
};
static_assert(alignof(AProceduralLevelBuilder) == 0x000008, "Wrong alignment on AProceduralLevelBuilder");
static_assert(sizeof(AProceduralLevelBuilder) == 0x001470, "Wrong size on AProceduralLevelBuilder");
static_assert(offsetof(AProceduralLevelBuilder, PathToMapDirectory) == 0x0002E0, "Member 'AProceduralLevelBuilder::PathToMapDirectory' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, PathToTilesDirectory) == 0x0002F0, "Member 'AProceduralLevelBuilder::PathToTilesDirectory' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, PathToEventSpawnablesDirectory) == 0x000300, "Member 'AProceduralLevelBuilder::PathToEventSpawnablesDirectory' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, EventSpawnablesParentDirectories) == 0x000310, "Member 'AProceduralLevelBuilder::EventSpawnablesParentDirectories' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, EventSpawnablePositionWeightCoefficient) == 0x000320, "Member 'AProceduralLevelBuilder::EventSpawnablePositionWeightCoefficient' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, EventSpawnablePositionWeightPowerBase) == 0x000324, "Member 'AProceduralLevelBuilder::EventSpawnablePositionWeightPowerBase' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, StaticActorSpawnerDecorationBudgets) == 0x000328, "Member 'AProceduralLevelBuilder::StaticActorSpawnerDecorationBudgets' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, StaticSpawnPointDecorationBudgets) == 0x000378, "Member 'AProceduralLevelBuilder::StaticSpawnPointDecorationBudgets' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, KillerMinProximityFromCamper) == 0x0003C8, "Member 'AProceduralLevelBuilder::KillerMinProximityFromCamper' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, SurvivorMinProximityFromOtherCamper) == 0x0003CC, "Member 'AProceduralLevelBuilder::SurvivorMinProximityFromOtherCamper' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, MinProximityBetweenGenerators) == 0x0003D0, "Member 'AProceduralLevelBuilder::MinProximityBetweenGenerators' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, MinProximityBetweenChests) == 0x0003D4, "Member 'AProceduralLevelBuilder::MinProximityBetweenChests' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, MinProximityBetweenTotems) == 0x0003D8, "Member 'AProceduralLevelBuilder::MinProximityBetweenTotems' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, SurvivorMinProximityFromGenerator) == 0x0003DC, "Member 'AProceduralLevelBuilder::SurvivorMinProximityFromGenerator' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, SurvivorMinProximityFromTotem) == 0x0003E0, "Member 'AProceduralLevelBuilder::SurvivorMinProximityFromTotem' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, SurvivorMaxLineOfSightFromTotem) == 0x0003E4, "Member 'AProceduralLevelBuilder::SurvivorMaxLineOfSightFromTotem' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, MinProximityBetweenSpecialBehaviourItems) == 0x0003E8, "Member 'AProceduralLevelBuilder::MinProximityBetweenSpecialBehaviourItems' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, SpecialBehaviourItemMinProximityFromSurvivor) == 0x0003EC, "Member 'AProceduralLevelBuilder::SpecialBehaviourItemMinProximityFromSurvivor' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, SpecialBehaviourItemMinProximityFromKiller) == 0x0003F0, "Member 'AProceduralLevelBuilder::SpecialBehaviourItemMinProximityFromKiller' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, DebugMap) == 0x0003F8, "Member 'AProceduralLevelBuilder::DebugMap' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, DebugTiles) == 0x000400, "Member 'AProceduralLevelBuilder::DebugTiles' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, SmallMeatLockerMinProximityFromKillerLair) == 0x000410, "Member 'AProceduralLevelBuilder::SmallMeatLockerMinProximityFromKillerLair' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, FactorToAdjustToWhenOutOfProximity) == 0x000414, "Member 'AProceduralLevelBuilder::FactorToAdjustToWhenOutOfProximity' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, FactorToAdjustToWhenInLineOfSight) == 0x000418, "Member 'AProceduralLevelBuilder::FactorToAdjustToWhenInLineOfSight' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, HeightAmplifier) == 0x00041C, "Member 'AProceduralLevelBuilder::HeightAmplifier' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, HeightAmplifierActivationHeight) == 0x000420, "Member 'AProceduralLevelBuilder::HeightAmplifierActivationHeight' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, ProceduralGenerationData) == 0x000428, "Member 'AProceduralLevelBuilder::ProceduralGenerationData' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, AmbiancePriorities) == 0x000430, "Member 'AProceduralLevelBuilder::AmbiancePriorities' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, PerMapLightData) == 0x000468, "Member 'AProceduralLevelBuilder::PerMapLightData' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, TileWeightRateOfDecay) == 0x0004A0, "Member 'AProceduralLevelBuilder::TileWeightRateOfDecay' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, QuadTileWeightRateOfDecay) == 0x0004A4, "Member 'AProceduralLevelBuilder::QuadTileWeightRateOfDecay' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, _tileClass) == 0x0004C0, "Member 'AProceduralLevelBuilder::_tileClass' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, _mapData) == 0x0006B0, "Member 'AProceduralLevelBuilder::_mapData' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, _outOfWorldTiles) == 0x0006B8, "Member 'AProceduralLevelBuilder::_outOfWorldTiles' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, _ambientAudioBank) == 0x0006C8, "Member 'AProceduralLevelBuilder::_ambientAudioBank' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, _availableTilesLibrary) == 0x0006D0, "Member 'AProceduralLevelBuilder::_availableTilesLibrary' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, _availableEventSpawnablesLibrary) == 0x0006D8, "Member 'AProceduralLevelBuilder::_availableEventSpawnablesLibrary' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, _availableDerivedTileLibrary) == 0x0007C8, "Member 'AProceduralLevelBuilder::_availableDerivedTileLibrary' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, _generatedData) == 0x000808, "Member 'AProceduralLevelBuilder::_generatedData' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, _tileMatrix) == 0x000F08, "Member 'AProceduralLevelBuilder::_tileMatrix' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, _tileBank) == 0x000F10, "Member 'AProceduralLevelBuilder::_tileBank' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, _killerLairSpawner) == 0x000F80, "Member 'AProceduralLevelBuilder::_killerLairSpawner' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, _preloadAssetReferences) == 0x000F90, "Member 'AProceduralLevelBuilder::_preloadAssetReferences' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, _chestItemAssetReferences) == 0x000FA0, "Member 'AProceduralLevelBuilder::_chestItemAssetReferences' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, _slasherPawns) == 0x000FB0, "Member 'AProceduralLevelBuilder::_slasherPawns' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, _tilesThatHaveBeenSpawned) == 0x000FE0, "Member 'AProceduralLevelBuilder::_tilesThatHaveBeenSpawned' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, _eventSpawnablesThatHaveBeenStreamed) == 0x001008, "Member 'AProceduralLevelBuilder::_eventSpawnablesThatHaveBeenStreamed' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, _debugProceduralDatas) == 0x001030, "Member 'AProceduralLevelBuilder::_debugProceduralDatas' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, _syncer) == 0x001038, "Member 'AProceduralLevelBuilder::_syncer' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, _blackboardComp) == 0x001040, "Member 'AProceduralLevelBuilder::_blackboardComp' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, _edgeObjectHandlingStrategy) == 0x001098, "Member 'AProceduralLevelBuilder::_edgeObjectHandlingStrategy' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, _backupKillerLairTile) == 0x001398, "Member 'AProceduralLevelBuilder::_backupKillerLairTile' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, _spawnedActorAttachmentInfo) == 0x001418, "Member 'AProceduralLevelBuilder::_spawnedActorAttachmentInfo' has a wrong offset!");

// Class DeadByDaylight.ProceduralLevelData
// 0x0410 (0x06B0 - 0x02A0)
class AProceduralLevelData final : public AActor
{
public:
	TSoftObjectPtr<class UPaperTileMap>           SelectedPaperMap;                                  // 0x02A0(0x0038)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GenerationSeed;                                    // 0x02D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGameType                                     GameType;                                          // 0x02DC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2DD[0x3];                                      // 0x02DD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SpecialEventId;                                    // 0x02E0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGeneratedLevelData                    GeneratedData;                                     // 0x02F0(0x0380)(Edit, BlueprintVisible, BlueprintReadOnly, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class FName>                           Offerings;                                         // 0x0670(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         PerksLevel;                                        // 0x0680(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_684[0x4];                                      // 0x0684(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           Perks;                                             // 0x0688(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          SkipGameplayElementGeneration;                     // 0x0698(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_699[0x7];                                      // 0x0699(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 _builder;                                          // 0x06A0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UClass*                                 _builderClassDef;                                  // 0x06A8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProceduralLevelData">();
	}
	static class AProceduralLevelData* GetDefaultObj()
	{
		return GetDefaultObjImpl<AProceduralLevelData>();
	}
};
static_assert(alignof(AProceduralLevelData) == 0x000008, "Wrong alignment on AProceduralLevelData");
static_assert(sizeof(AProceduralLevelData) == 0x0006B0, "Wrong size on AProceduralLevelData");
static_assert(offsetof(AProceduralLevelData, SelectedPaperMap) == 0x0002A0, "Member 'AProceduralLevelData::SelectedPaperMap' has a wrong offset!");
static_assert(offsetof(AProceduralLevelData, GenerationSeed) == 0x0002D8, "Member 'AProceduralLevelData::GenerationSeed' has a wrong offset!");
static_assert(offsetof(AProceduralLevelData, GameType) == 0x0002DC, "Member 'AProceduralLevelData::GameType' has a wrong offset!");
static_assert(offsetof(AProceduralLevelData, SpecialEventId) == 0x0002E0, "Member 'AProceduralLevelData::SpecialEventId' has a wrong offset!");
static_assert(offsetof(AProceduralLevelData, GeneratedData) == 0x0002F0, "Member 'AProceduralLevelData::GeneratedData' has a wrong offset!");
static_assert(offsetof(AProceduralLevelData, Offerings) == 0x000670, "Member 'AProceduralLevelData::Offerings' has a wrong offset!");
static_assert(offsetof(AProceduralLevelData, PerksLevel) == 0x000680, "Member 'AProceduralLevelData::PerksLevel' has a wrong offset!");
static_assert(offsetof(AProceduralLevelData, Perks) == 0x000688, "Member 'AProceduralLevelData::Perks' has a wrong offset!");
static_assert(offsetof(AProceduralLevelData, SkipGameplayElementGeneration) == 0x000698, "Member 'AProceduralLevelData::SkipGameplayElementGeneration' has a wrong offset!");
static_assert(offsetof(AProceduralLevelData, _builder) == 0x0006A0, "Member 'AProceduralLevelData::_builder' has a wrong offset!");
static_assert(offsetof(AProceduralLevelData, _builderClassDef) == 0x0006A8, "Member 'AProceduralLevelData::_builderClassDef' has a wrong offset!");

// Class DeadByDaylight.PromoCodeManager
// 0x0018 (0x0050 - 0x0038)
class UPromoCodeManager final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x18];                                      // 0x0038(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PromoCodeManager">();
	}
	static class UPromoCodeManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPromoCodeManager>();
	}
};
static_assert(alignof(UPromoCodeManager) == 0x000008, "Wrong alignment on UPromoCodeManager");
static_assert(sizeof(UPromoCodeManager) == 0x000050, "Wrong size on UPromoCodeManager");

// Class DeadByDaylight.TimerGate
// 0x0010 (0x02C8 - 0x02B8)
class ATimerGate final : public AGate
{
public:
	float                                         _currentTime;                                      // 0x02B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BC[0xC];                                      // 0x02BC(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddTime(float Time);
	void RemoveTime(float Time);
	void Reset();
	void Rushed(bool Success);
	void SetValues(float TimerDuration, float RushGain, float RushBlockDuration);
	void Update(float DeltaTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TimerGate">();
	}
	static class ATimerGate* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATimerGate>();
	}
};
static_assert(alignof(ATimerGate) == 0x000008, "Wrong alignment on ATimerGate");
static_assert(sizeof(ATimerGate) == 0x0002C8, "Wrong size on ATimerGate");
static_assert(offsetof(ATimerGate, _currentTime) == 0x0002B8, "Member 'ATimerGate::_currentTime' has a wrong offset!");

// Class DeadByDaylight.PromoPackUtilities
// 0x0000 (0x0030 - 0x0030)
class UPromoPackUtilities final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PromoPackUtilities">();
	}
	static class UPromoPackUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPromoPackUtilities>();
	}
};
static_assert(alignof(UPromoPackUtilities) == 0x000008, "Wrong alignment on UPromoPackUtilities");
static_assert(sizeof(UPromoPackUtilities) == 0x000030, "Wrong size on UPromoPackUtilities");

// Class DeadByDaylight.ProtectionHitComponent
// 0x0070 (0x0118 - 0x00A8)
class UProtectionHitComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x50];                                      // 0x00A8(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ACamperPlayer*>                  _nearbyInjuredSurvivors;                           // 0x00F8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_108[0x10];                                     // 0x0108(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_HandleProtectionScoringEvents();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProtectionHitComponent">();
	}
	static class UProtectionHitComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProtectionHitComponent>();
	}
};
static_assert(alignof(UProtectionHitComponent) == 0x000008, "Wrong alignment on UProtectionHitComponent");
static_assert(sizeof(UProtectionHitComponent) == 0x000118, "Wrong size on UProtectionHitComponent");
static_assert(offsetof(UProtectionHitComponent, _nearbyInjuredSurvivors) == 0x0000F8, "Member 'UProtectionHitComponent::_nearbyInjuredSurvivors' has a wrong offset!");

// Class DeadByDaylight.ProximityToActorsIterativeWeightAdjustmentStrategy
// 0x0070 (0x00A0 - 0x0030)
class UProximityToActorsIterativeWeightAdjustmentStrategy : public UIterativeWeightAdjustmentStrategy
{
public:
	TArray<class USceneComponent*>                _unmatchedActorLocations;                          // 0x0030(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<TScriptInterface<class IWeightedElement>> _selectedSpawners;                                 // 0x0040(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	int32                                         _currentPass;                                      // 0x0050(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            _penaltyFromDistanceToClosestSpawnObject;          // 0x0058(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _penaltyFromDistanceToClosestSpawnObjectWhenActorHasOtherSpawnObjectNearby; // 0x0060(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _scoreFromDistanceFromClosestActor;                // 0x0068(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _actorCloseToSpawnObjectDistanceThreshold;         // 0x0070(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	int32                                         _spawnerCountPerActor;                             // 0x0098(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProximityToActorsIterativeWeightAdjustmentStrategy">();
	}
	static class UProximityToActorsIterativeWeightAdjustmentStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProximityToActorsIterativeWeightAdjustmentStrategy>();
	}
};
static_assert(alignof(UProximityToActorsIterativeWeightAdjustmentStrategy) == 0x000008, "Wrong alignment on UProximityToActorsIterativeWeightAdjustmentStrategy");
static_assert(sizeof(UProximityToActorsIterativeWeightAdjustmentStrategy) == 0x0000A0, "Wrong size on UProximityToActorsIterativeWeightAdjustmentStrategy");
static_assert(offsetof(UProximityToActorsIterativeWeightAdjustmentStrategy, _unmatchedActorLocations) == 0x000030, "Member 'UProximityToActorsIterativeWeightAdjustmentStrategy::_unmatchedActorLocations' has a wrong offset!");
static_assert(offsetof(UProximityToActorsIterativeWeightAdjustmentStrategy, _selectedSpawners) == 0x000040, "Member 'UProximityToActorsIterativeWeightAdjustmentStrategy::_selectedSpawners' has a wrong offset!");
static_assert(offsetof(UProximityToActorsIterativeWeightAdjustmentStrategy, _currentPass) == 0x000050, "Member 'UProximityToActorsIterativeWeightAdjustmentStrategy::_currentPass' has a wrong offset!");
static_assert(offsetof(UProximityToActorsIterativeWeightAdjustmentStrategy, _penaltyFromDistanceToClosestSpawnObject) == 0x000058, "Member 'UProximityToActorsIterativeWeightAdjustmentStrategy::_penaltyFromDistanceToClosestSpawnObject' has a wrong offset!");
static_assert(offsetof(UProximityToActorsIterativeWeightAdjustmentStrategy, _penaltyFromDistanceToClosestSpawnObjectWhenActorHasOtherSpawnObjectNearby) == 0x000060, "Member 'UProximityToActorsIterativeWeightAdjustmentStrategy::_penaltyFromDistanceToClosestSpawnObjectWhenActorHasOtherSpawnObjectNearby' has a wrong offset!");
static_assert(offsetof(UProximityToActorsIterativeWeightAdjustmentStrategy, _scoreFromDistanceFromClosestActor) == 0x000068, "Member 'UProximityToActorsIterativeWeightAdjustmentStrategy::_scoreFromDistanceFromClosestActor' has a wrong offset!");
static_assert(offsetof(UProximityToActorsIterativeWeightAdjustmentStrategy, _actorCloseToSpawnObjectDistanceThreshold) == 0x000070, "Member 'UProximityToActorsIterativeWeightAdjustmentStrategy::_actorCloseToSpawnObjectDistanceThreshold' has a wrong offset!");
static_assert(offsetof(UProximityToActorsIterativeWeightAdjustmentStrategy, _spawnerCountPerActor) == 0x000098, "Member 'UProximityToActorsIterativeWeightAdjustmentStrategy::_spawnerCountPerActor' has a wrong offset!");

// Class DeadByDaylight.UMGUtilities
// 0x0000 (0x0030 - 0x0030)
class UUMGUtilities final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGUtilities">();
	}
	static class UUMGUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGUtilities>();
	}
};
static_assert(alignof(UUMGUtilities) == 0x000008, "Wrong alignment on UUMGUtilities");
static_assert(sizeof(UUMGUtilities) == 0x000030, "Wrong size on UUMGUtilities");

// Class DeadByDaylight.ProximityToSpawnPointTypeIterativeWeightAdjustmentStrategy
// 0x0008 (0x00A8 - 0x00A0)
class UProximityToSpawnPointTypeIterativeWeightAdjustmentStrategy final : public UProximityToActorsIterativeWeightAdjustmentStrategy
{
public:
	ETileSpawnPointType                           _spawnPointType;                                   // 0x00A0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProximityToSpawnPointTypeIterativeWeightAdjustmentStrategy">();
	}
	static class UProximityToSpawnPointTypeIterativeWeightAdjustmentStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProximityToSpawnPointTypeIterativeWeightAdjustmentStrategy>();
	}
};
static_assert(alignof(UProximityToSpawnPointTypeIterativeWeightAdjustmentStrategy) == 0x000008, "Wrong alignment on UProximityToSpawnPointTypeIterativeWeightAdjustmentStrategy");
static_assert(sizeof(UProximityToSpawnPointTypeIterativeWeightAdjustmentStrategy) == 0x0000A8, "Wrong size on UProximityToSpawnPointTypeIterativeWeightAdjustmentStrategy");
static_assert(offsetof(UProximityToSpawnPointTypeIterativeWeightAdjustmentStrategy, _spawnPointType) == 0x0000A0, "Member 'UProximityToSpawnPointTypeIterativeWeightAdjustmentStrategy::_spawnPointType' has a wrong offset!");

// Class DeadByDaylight.PS4ProfileDAL
// 0x0000 (0x0088 - 0x0088)
class UPS4ProfileDAL final : public UPS4GRDKBaseProfileDAL
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PS4ProfileDAL">();
	}
	static class UPS4ProfileDAL* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPS4ProfileDAL>();
	}
};
static_assert(alignof(UPS4ProfileDAL) == 0x000008, "Wrong alignment on UPS4ProfileDAL");
static_assert(sizeof(UPS4ProfileDAL) == 0x000088, "Wrong size on UPS4ProfileDAL");

// Class DeadByDaylight.PS5ProfileDAL
// 0x0000 (0x0088 - 0x0088)
class UPS5ProfileDAL final : public UPlayerProfileDAL
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PS5ProfileDAL">();
	}
	static class UPS5ProfileDAL* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPS5ProfileDAL>();
	}
};
static_assert(alignof(UPS5ProfileDAL) == 0x000008, "Wrong alignment on UPS5ProfileDAL");
static_assert(sizeof(UPS5ProfileDAL) == 0x000088, "Wrong size on UPS5ProfileDAL");

// Class DeadByDaylight.PurpleGlyphBloodTrailComponent
// 0x0010 (0x0270 - 0x0260)
class UPurpleGlyphBloodTrailComponent final : public UBloodTrailComponent
{
public:
	uint8                                         Pad_260[0x10];                                     // 0x0260(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DeactivateGlyphBloodTrail();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PurpleGlyphBloodTrailComponent">();
	}
	static class UPurpleGlyphBloodTrailComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPurpleGlyphBloodTrailComponent>();
	}
};
static_assert(alignof(UPurpleGlyphBloodTrailComponent) == 0x000010, "Wrong alignment on UPurpleGlyphBloodTrailComponent");
static_assert(sizeof(UPurpleGlyphBloodTrailComponent) == 0x000270, "Wrong size on UPurpleGlyphBloodTrailComponent");

// Class DeadByDaylight.PushableInterface
// 0x0000 (0x0030 - 0x0030)
class IPushableInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PushableInterface">();
	}
	static class IPushableInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPushableInterface>();
	}
};
static_assert(alignof(IPushableInterface) == 0x000008, "Wrong alignment on IPushableInterface");
static_assert(sizeof(IPushableInterface) == 0x000030, "Wrong size on IPushableInterface");

// Class DeadByDaylight.SlasherInteractable
// 0x0008 (0x03E8 - 0x03E0)
class ASlasherInteractable : public APlayerInteractable
{
public:
	class UInteractor*                            _genericStunInteractor;                            // 0x03E0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SlasherInteractable">();
	}
	static class ASlasherInteractable* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASlasherInteractable>();
	}
};
static_assert(alignof(ASlasherInteractable) == 0x000008, "Wrong alignment on ASlasherInteractable");
static_assert(sizeof(ASlasherInteractable) == 0x0003E8, "Wrong size on ASlasherInteractable");
static_assert(offsetof(ASlasherInteractable, _genericStunInteractor) == 0x0003E0, "Member 'ASlasherInteractable::_genericStunInteractor' has a wrong offset!");

// Class DeadByDaylight.RankManager
// 0x00A8 (0x00D8 - 0x0030)
class URankManager final : public UObject
{
public:
	uint8                                         Pad_30[0xA8];                                      // 0x0030(0x00A8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RankManager">();
	}
	static class URankManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<URankManager>();
	}
};
static_assert(alignof(URankManager) == 0x000008, "Wrong alignment on URankManager");
static_assert(sizeof(URankManager) == 0x0000D8, "Wrong size on URankManager");

// Class DeadByDaylight.RBTOutlineUpdateStrategy
// 0x0000 (0x00F0 - 0x00F0)
class URBTOutlineUpdateStrategy final : public UDefaultOutlineUpdateStrategy
{
public:
	bool IsRevealedToLocalPlayer_BP(const class ADBDPlayer* Player) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RBTOutlineUpdateStrategy">();
	}
	static class URBTOutlineUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<URBTOutlineUpdateStrategy>();
	}
};
static_assert(alignof(URBTOutlineUpdateStrategy) == 0x000008, "Wrong alignment on URBTOutlineUpdateStrategy");
static_assert(sizeof(URBTOutlineUpdateStrategy) == 0x0000F0, "Wrong size on URBTOutlineUpdateStrategy");

// Class DeadByDaylight.RecentGameEventTracker
// 0x00A0 (0x00D8 - 0x0038)
class URecentGameEventTracker final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0xA0];                                      // 0x0038(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RecentGameEventTracker">();
	}
	static class URecentGameEventTracker* GetDefaultObj()
	{
		return GetDefaultObjImpl<URecentGameEventTracker>();
	}
};
static_assert(alignof(URecentGameEventTracker) == 0x000008, "Wrong alignment on URecentGameEventTracker");
static_assert(sizeof(URecentGameEventTracker) == 0x0000D8, "Wrong size on URecentGameEventTracker");

// Class DeadByDaylight.UMGHtmlTextDecorator
// 0x0000 (0x0030 - 0x0030)
class UUMGHtmlTextDecorator final : public URichTextBlockDecorator
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGHtmlTextDecorator">();
	}
	static class UUMGHtmlTextDecorator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGHtmlTextDecorator>();
	}
};
static_assert(alignof(UUMGHtmlTextDecorator) == 0x000008, "Wrong alignment on UUMGHtmlTextDecorator");
static_assert(sizeof(UUMGHtmlTextDecorator) == 0x000030, "Wrong size on UUMGHtmlTextDecorator");

// Class DeadByDaylight.RecoverInteractableDefinition
// 0x0030 (0x08F0 - 0x08C0)
class URecoverInteractableDefinition : public UChargeableInteractionDefinition
{
public:
	class FName                                   _recoverStopPercentTunableName;                    // 0x08C0(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   _camperRecoverHealSpeedMultiplierTunableName;      // 0x08CC(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8D8[0x18];                                     // 0x08D8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsKillerInteracting() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RecoverInteractableDefinition">();
	}
	static class URecoverInteractableDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<URecoverInteractableDefinition>();
	}
};
static_assert(alignof(URecoverInteractableDefinition) == 0x000010, "Wrong alignment on URecoverInteractableDefinition");
static_assert(sizeof(URecoverInteractableDefinition) == 0x0008F0, "Wrong size on URecoverInteractableDefinition");
static_assert(offsetof(URecoverInteractableDefinition, _recoverStopPercentTunableName) == 0x0008C0, "Member 'URecoverInteractableDefinition::_recoverStopPercentTunableName' has a wrong offset!");
static_assert(offsetof(URecoverInteractableDefinition, _camperRecoverHealSpeedMultiplierTunableName) == 0x0008CC, "Member 'URecoverInteractableDefinition::_camperRecoverHealSpeedMultiplierTunableName' has a wrong offset!");

// Class DeadByDaylight.RegionFinder
// 0x0078 (0x00A8 - 0x0030)
class URegionFinder : public UObject
{
public:
	TArray<struct FRegion>                        Regions;                                           // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         TIMEOUT;                                           // 0x0040(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x64];                                      // 0x0044(0x0064)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RegionFinder">();
	}
	static class URegionFinder* GetDefaultObj()
	{
		return GetDefaultObjImpl<URegionFinder>();
	}
};
static_assert(alignof(URegionFinder) == 0x000008, "Wrong alignment on URegionFinder");
static_assert(sizeof(URegionFinder) == 0x0000A8, "Wrong size on URegionFinder");
static_assert(offsetof(URegionFinder, Regions) == 0x000030, "Member 'URegionFinder::Regions' has a wrong offset!");
static_assert(offsetof(URegionFinder, TIMEOUT) == 0x000040, "Member 'URegionFinder::TIMEOUT' has a wrong offset!");

// Class DeadByDaylight.RenderingFeaturesSequencer
// 0x0048 (0x0078 - 0x0030)
class URenderingFeaturesSequencer final : public UObject
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class ADBDAggregateCullDistanceVolumes*       _aggregateCullDistanceVolumes;                     // 0x0040(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWorld*                                 _world;                                            // 0x0048(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_50[0x28];                                      // 0x0050(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RenderingFeaturesSequencer">();
	}
	static class URenderingFeaturesSequencer* GetDefaultObj()
	{
		return GetDefaultObjImpl<URenderingFeaturesSequencer>();
	}
};
static_assert(alignof(URenderingFeaturesSequencer) == 0x000008, "Wrong alignment on URenderingFeaturesSequencer");
static_assert(sizeof(URenderingFeaturesSequencer) == 0x000078, "Wrong size on URenderingFeaturesSequencer");
static_assert(offsetof(URenderingFeaturesSequencer, _aggregateCullDistanceVolumes) == 0x000040, "Member 'URenderingFeaturesSequencer::_aggregateCullDistanceVolumes' has a wrong offset!");
static_assert(offsetof(URenderingFeaturesSequencer, _world) == 0x000048, "Member 'URenderingFeaturesSequencer::_world' has a wrong offset!");

// Class DeadByDaylight.RepairDependantPerkInterface
// 0x0000 (0x0030 - 0x0030)
class IRepairDependantPerkInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RepairDependantPerkInterface">();
	}
	static class IRepairDependantPerkInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IRepairDependantPerkInterface>();
	}
};
static_assert(alignof(IRepairDependantPerkInterface) == 0x000008, "Wrong alignment on IRepairDependantPerkInterface");
static_assert(sizeof(IRepairDependantPerkInterface) == 0x000030, "Wrong size on IRepairDependantPerkInterface");

// Class DeadByDaylight.RestrictedPlacementAreaDefaultStrategy
// 0x0008 (0x00B0 - 0x00A8)
class URestrictedPlacementAreaDefaultStrategy final : public URestrictedPlacementAreaStrategy
{
public:
	TSubclassOf<class AActor>                     RestrictedActor;                                   // 0x00A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RestrictedPlacementAreaDefaultStrategy">();
	}
	static class URestrictedPlacementAreaDefaultStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<URestrictedPlacementAreaDefaultStrategy>();
	}
};
static_assert(alignof(URestrictedPlacementAreaDefaultStrategy) == 0x000008, "Wrong alignment on URestrictedPlacementAreaDefaultStrategy");
static_assert(sizeof(URestrictedPlacementAreaDefaultStrategy) == 0x0000B0, "Wrong size on URestrictedPlacementAreaDefaultStrategy");
static_assert(offsetof(URestrictedPlacementAreaDefaultStrategy, RestrictedActor) == 0x0000A8, "Member 'URestrictedPlacementAreaDefaultStrategy::RestrictedActor' has a wrong offset!");

// Class DeadByDaylight.ReverseBearTrap
// 0x00C0 (0x0468 - 0x03A8)
class AReverseBearTrap final : public AInteractable
{
public:
	uint8                                         Pad_3A8[0x8];                                      // 0x03A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 _rbtMesh;                                          // 0x03B0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimationMontageSlave*                 _animMontageSlave;                                 // 0x03B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C0[0x4];                                      // 0x03C0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _keyID;                                            // 0x03C4(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         _attemptsNeededToDetach;                           // 0x03C8(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3CC[0x8C];                                     // 0x03CC(0x008C)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _exitGatesPoweredAfterAttachment;                  // 0x0458(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _generatorFixedAfterAttachment;                    // 0x0459(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_45A[0xE];                                      // 0x045A(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AttachSurvivor(class ACamperPlayer* Survivor);
	void Authority_GenerateAttemptsNeeded(const int32 RemainingAttemptsTotal, const int32 RemainingRBTs, const int32 NumRemovers);
	void Authority_OnGeneratorRepaired(const struct FGameplayTag& GameEventType, const struct FGameEventData& GameEventData);
	void Authority_SetKeyID(int32 KeyId);
	void DetachSurvivor(class ACamperPlayer* Survivor);
	void FastForwardExecutionTimer(float DeltaTime);
	void IncrementAttemptsMade();
	void NotifyDetachStarted(class ACamperPlayer* Survivor);
	void NotifyOnAttachSurvivorBegin(class ACamperPlayer* Survivor);
	void OnAttachSurvivor(class ACamperPlayer* Survivor);
	void OnAttachSurvivorBegin(class ACamperPlayer* Survivor);
	void OnDetachSurvivor(class ACamperPlayer* Survivor);
	void OnEnterWarningZone();
	void OnExitWarningZone();
	void OnWarningLevelChanged(int32 PreviousWarningLevel, int32 CurrentWarningLevel);
	void ResetExecutionTimer(float Time);
	void SetGateClosedAtAttachment(bool CLOSED);
	void SetVisible(bool Visible);
	void StopExecutionTimer();
	void StopMontage();

	bool CanExecute() const;
	class ACamperPlayer* GetAttachedSurvivor() const;
	int32 GetAttemptsMade() const;
	int32 GetAttemptsNeeded() const;
	float GetExecutionTimerPercentTimeElapsed() const;
	float GetExecutionTimerTimeLeft() const;
	bool GetExitGatesPoweredAfterAttachment() const;
	bool GetGeneratorFixedAfterAttachment() const;
	int32 GetKeyID() const;
	int32 GetWarningLevel() const;
	bool GetWasGateClosedAtAttachment() const;
	bool HasDetachStarted() const;
	bool IsExecutionTimerActive() const;
	bool IsExecutionTimerDone() const;
	bool IsInWarningZone() const;
	bool IsRBTActivated() const;
	bool ShouldUpdateExecutionTimer() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReverseBearTrap">();
	}
	static class AReverseBearTrap* GetDefaultObj()
	{
		return GetDefaultObjImpl<AReverseBearTrap>();
	}
};
static_assert(alignof(AReverseBearTrap) == 0x000008, "Wrong alignment on AReverseBearTrap");
static_assert(sizeof(AReverseBearTrap) == 0x000468, "Wrong size on AReverseBearTrap");
static_assert(offsetof(AReverseBearTrap, _rbtMesh) == 0x0003B0, "Member 'AReverseBearTrap::_rbtMesh' has a wrong offset!");
static_assert(offsetof(AReverseBearTrap, _animMontageSlave) == 0x0003B8, "Member 'AReverseBearTrap::_animMontageSlave' has a wrong offset!");
static_assert(offsetof(AReverseBearTrap, _keyID) == 0x0003C4, "Member 'AReverseBearTrap::_keyID' has a wrong offset!");
static_assert(offsetof(AReverseBearTrap, _attemptsNeededToDetach) == 0x0003C8, "Member 'AReverseBearTrap::_attemptsNeededToDetach' has a wrong offset!");
static_assert(offsetof(AReverseBearTrap, _exitGatesPoweredAfterAttachment) == 0x000458, "Member 'AReverseBearTrap::_exitGatesPoweredAfterAttachment' has a wrong offset!");
static_assert(offsetof(AReverseBearTrap, _generatorFixedAfterAttachment) == 0x000459, "Member 'AReverseBearTrap::_generatorFixedAfterAttachment' has a wrong offset!");

// Class DeadByDaylight.SpecificTypeChestItemStrategy
// 0x0008 (0x0040 - 0x0038)
class USpecificTypeChestItemStrategy final : public USearchableItemStrategy
{
public:
	EItemRarity                                   ItemRarity;                                        // 0x0038(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpecificTypeChestItemStrategy">();
	}
	static class USpecificTypeChestItemStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpecificTypeChestItemStrategy>();
	}
};
static_assert(alignof(USpecificTypeChestItemStrategy) == 0x000008, "Wrong alignment on USpecificTypeChestItemStrategy");
static_assert(sizeof(USpecificTypeChestItemStrategy) == 0x000040, "Wrong size on USpecificTypeChestItemStrategy");
static_assert(offsetof(USpecificTypeChestItemStrategy, ItemRarity) == 0x000038, "Member 'USpecificTypeChestItemStrategy::ItemRarity' has a wrong offset!");

// Class DeadByDaylight.ReverseBearTrapRemover
// 0x0030 (0x03D8 - 0x03A8)
class AReverseBearTrapRemover final : public AInteractable
{
public:
	uint8                                         Pad_3A8[0x8];                                      // 0x03A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 _keys;                                             // 0x03B0(0x0010)(Net, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<int32>                                 _keysSearched;                                     // 0x03C0(0x0010)(Net, ZeroConstructor, NativeAccessSpecifierPrivate)
	class UMapActorComponent*                     _mapActor;                                         // 0x03D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void AddKey(int32 KeyId);
	void AddSearchedKey(int32 KeyId);
	void PlayRemoveFailMontage();

	class AReverseBearTrap* GetAttachedRBT(class AActor* Player) const;
	class UPrimitiveComponent* GetInteractorPrimitiveComponent() const;
	class UMapActorComponent* GetMapActor() const;
	bool HasKey(int32 KeyId) const;
	bool HasSearchedForKey(int32 KeyId) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReverseBearTrapRemover">();
	}
	static class AReverseBearTrapRemover* GetDefaultObj()
	{
		return GetDefaultObjImpl<AReverseBearTrapRemover>();
	}
};
static_assert(alignof(AReverseBearTrapRemover) == 0x000008, "Wrong alignment on AReverseBearTrapRemover");
static_assert(sizeof(AReverseBearTrapRemover) == 0x0003D8, "Wrong size on AReverseBearTrapRemover");
static_assert(offsetof(AReverseBearTrapRemover, _keys) == 0x0003B0, "Member 'AReverseBearTrapRemover::_keys' has a wrong offset!");
static_assert(offsetof(AReverseBearTrapRemover, _keysSearched) == 0x0003C0, "Member 'AReverseBearTrapRemover::_keysSearched' has a wrong offset!");
static_assert(offsetof(AReverseBearTrapRemover, _mapActor) == 0x0003D0, "Member 'AReverseBearTrapRemover::_mapActor' has a wrong offset!");

// Class DeadByDaylight.ReverseBearTrapUtilities
// 0x0000 (0x0030 - 0x0030)
class UReverseBearTrapUtilities final : public UBlueprintFunctionLibrary
{
public:
	static class AReverseBearTrap* GetAttachedRBT(class ADBDPlayer* Player);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReverseBearTrapUtilities">();
	}
	static class UReverseBearTrapUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReverseBearTrapUtilities>();
	}
};
static_assert(alignof(UReverseBearTrapUtilities) == 0x000008, "Wrong alignment on UReverseBearTrapUtilities");
static_assert(sizeof(UReverseBearTrapUtilities) == 0x000030, "Wrong size on UReverseBearTrapUtilities");

// Class DeadByDaylight.RewardTrackContainer
// 0x01D0 (0x0200 - 0x0030)
class URewardTrackContainer final : public UObject
{
public:
	uint8                                         Pad_30[0x1D0];                                     // 0x0030(0x01D0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RewardTrackContainer">();
	}
	static class URewardTrackContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<URewardTrackContainer>();
	}
};
static_assert(alignof(URewardTrackContainer) == 0x000008, "Wrong alignment on URewardTrackContainer");
static_assert(sizeof(URewardTrackContainer) == 0x000200, "Wrong size on URewardTrackContainer");

// Class DeadByDaylight.SlashableActivationSourceCollection
// 0x0040 (0x00E8 - 0x00A8)
class USlashableActivationSourceCollection final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x40];                                      // 0x00A8(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void AddSource(class UObject* Source);
	static void ForceActivate(const class UObject* WorldContextObject);
	static void RemoveSource(class UObject* Source);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SlashableActivationSourceCollection">();
	}
	static class USlashableActivationSourceCollection* GetDefaultObj()
	{
		return GetDefaultObjImpl<USlashableActivationSourceCollection>();
	}
};
static_assert(alignof(USlashableActivationSourceCollection) == 0x000008, "Wrong alignment on USlashableActivationSourceCollection");
static_assert(sizeof(USlashableActivationSourceCollection) == 0x0000E8, "Wrong size on USlashableActivationSourceCollection");

// Class DeadByDaylight.RewardUtilities
// 0x0000 (0x0030 - 0x0030)
class URewardUtilities final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RewardUtilities">();
	}
	static class URewardUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<URewardUtilities>();
	}
};
static_assert(alignof(URewardUtilities) == 0x000008, "Wrong alignment on URewardUtilities");
static_assert(sizeof(URewardUtilities) == 0x000030, "Wrong size on URewardUtilities");

// Class DeadByDaylight.RitualsManager
// 0x0238 (0x0270 - 0x0038)
class URitualsManager final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x90];                                      // 0x0038(0x0090)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDailyRitualContainer                  _cachedRitualContainer;                            // 0x00C8(0x0028)(NativeAccessSpecifierPrivate)
	struct FDailyRitualInstance                   _cachedDismissalReplacement;                       // 0x00F0(0x0078)(NativeAccessSpecifierPrivate)
	struct FDailyRitualInstance                   _cachedClaimedReplacement;                         // 0x0168(0x0078)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_1E0[0x70];                                     // 0x01E0(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCoreRitualsContent                    _s3Content;                                        // 0x0250(0x0018)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_268[0x8];                                      // 0x0268(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RitualsManager">();
	}
	static class URitualsManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<URitualsManager>();
	}
};
static_assert(alignof(URitualsManager) == 0x000008, "Wrong alignment on URitualsManager");
static_assert(sizeof(URitualsManager) == 0x000270, "Wrong size on URitualsManager");
static_assert(offsetof(URitualsManager, _cachedRitualContainer) == 0x0000C8, "Member 'URitualsManager::_cachedRitualContainer' has a wrong offset!");
static_assert(offsetof(URitualsManager, _cachedDismissalReplacement) == 0x0000F0, "Member 'URitualsManager::_cachedDismissalReplacement' has a wrong offset!");
static_assert(offsetof(URitualsManager, _cachedClaimedReplacement) == 0x000168, "Member 'URitualsManager::_cachedClaimedReplacement' has a wrong offset!");
static_assert(offsetof(URitualsManager, _s3Content) == 0x000250, "Member 'URitualsManager::_s3Content' has a wrong offset!");

// Class DeadByDaylight.RootMovie
// 0x0070 (0x00A0 - 0x0030)
class URootMovie final : public UObject
{
public:
	class FString                                 SwfAssetName;                                      // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGFxMoviePlayer*                        SwfMoviePlayer;                                    // 0x0040(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x10];                                      // 0x0048(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UScreenController*                      M_ScreenController;                                // 0x0058(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIController*                          M_UIController;                                    // 0x0060(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGameInstance*                          M_GameInstance;                                    // 0x0068(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDBDInputManager*                       _inputManager;                                     // 0x0070(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_78[0x28];                                      // 0x0078(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddCursorBlockingWidget(const class FString& ID, float X, float Y, float Width, float Height);
	void OnAssert(int32 Type, const class FString& Message);
	void OnFlashReady();
	void OnMovieClosed();
	void OnScreenEnter(const class FString& ScreenId);
	void OnScreenLeave(const class FString& ScreenId);
	void OnScreenReady(const class FString& ScreenId);
	void OpenLinkInBrowser(const class FString& LinkAddress);
	void PlaySound(const class FString& SoundId);
	void RegisterScreenControl(class UGFxObject* FlashObj);
	void RegisterUIControl(class UGFxObject* FlashObj);
	void RegisterView(const class FString& ScreenId, class UGFxObject* ScreenObject);
	void RemoveCursorBlockingWidget(const class FString& ID);
	void SetCursorAsSticky(bool IsSticky, bool LockVertical, bool LockHorizontal, float StickinessOverride);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RootMovie">();
	}
	static class URootMovie* GetDefaultObj()
	{
		return GetDefaultObjImpl<URootMovie>();
	}
};
static_assert(alignof(URootMovie) == 0x000008, "Wrong alignment on URootMovie");
static_assert(sizeof(URootMovie) == 0x0000A0, "Wrong size on URootMovie");
static_assert(offsetof(URootMovie, SwfAssetName) == 0x000030, "Member 'URootMovie::SwfAssetName' has a wrong offset!");
static_assert(offsetof(URootMovie, SwfMoviePlayer) == 0x000040, "Member 'URootMovie::SwfMoviePlayer' has a wrong offset!");
static_assert(offsetof(URootMovie, M_ScreenController) == 0x000058, "Member 'URootMovie::M_ScreenController' has a wrong offset!");
static_assert(offsetof(URootMovie, M_UIController) == 0x000060, "Member 'URootMovie::M_UIController' has a wrong offset!");
static_assert(offsetof(URootMovie, M_GameInstance) == 0x000068, "Member 'URootMovie::M_GameInstance' has a wrong offset!");
static_assert(offsetof(URootMovie, _inputManager) == 0x000070, "Member 'URootMovie::_inputManager' has a wrong offset!");

// Class DeadByDaylight.RPCMonitor
// 0x0050 (0x0088 - 0x0038)
class URPCMonitor final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RPCMonitor">();
	}
	static class URPCMonitor* GetDefaultObj()
	{
		return GetDefaultObjImpl<URPCMonitor>();
	}
};
static_assert(alignof(URPCMonitor) == 0x000008, "Wrong alignment on URPCMonitor");
static_assert(sizeof(URPCMonitor) == 0x000088, "Wrong size on URPCMonitor");

// Class DeadByDaylight.S3GameConfigs
// 0x0638 (0x0670 - 0x0038)
class US3GameConfigs final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x638];                                     // 0x0038(0x0638)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"S3GameConfigs">();
	}
	static class US3GameConfigs* GetDefaultObj()
	{
		return GetDefaultObjImpl<US3GameConfigs>();
	}
};
static_assert(alignof(US3GameConfigs) == 0x000008, "Wrong alignment on US3GameConfigs");
static_assert(sizeof(US3GameConfigs) == 0x000670, "Wrong size on US3GameConfigs");

// Class DeadByDaylight.UMGDragWidget_HudEditor
// 0x0060 (0x0330 - 0x02D0)
class UUMGDragWidget_HudEditor final : public UUMGDragWidget
{
public:
	uint8                                         Pad_2D0[0x20];                                     // 0x02D0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UUserWidget>                OnSelectionWidgetClass;                            // 0x02F0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UUMGHudEditorDragConstraintWidget> DragLinkWidgetClass;                               // 0x02F8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCustomWidgetWrapper_HudEditor*         _customWrapper;                                    // 0x0300(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUserWidget*                            _selectionWidget;                                  // 0x0308(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUMGHudEditorDragConstraintWidget*      _dragLinkWidget;                                   // 0x0310(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUMGDragWidget_HudEditor*               _parentLinkWidget;                                 // 0x0318(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUMGDragWidget_HudEditor*               _childLinkWidget;                                  // 0x0320(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_328[0x8];                                      // 0x0328(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetOnSelection(bool IsSelected);

	class UCustomWidgetWrapper_HudEditor* GetCustomWrapper() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGDragWidget_HudEditor">();
	}
	static class UUMGDragWidget_HudEditor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGDragWidget_HudEditor>();
	}
};
static_assert(alignof(UUMGDragWidget_HudEditor) == 0x000008, "Wrong alignment on UUMGDragWidget_HudEditor");
static_assert(sizeof(UUMGDragWidget_HudEditor) == 0x000330, "Wrong size on UUMGDragWidget_HudEditor");
static_assert(offsetof(UUMGDragWidget_HudEditor, OnSelectionWidgetClass) == 0x0002F0, "Member 'UUMGDragWidget_HudEditor::OnSelectionWidgetClass' has a wrong offset!");
static_assert(offsetof(UUMGDragWidget_HudEditor, DragLinkWidgetClass) == 0x0002F8, "Member 'UUMGDragWidget_HudEditor::DragLinkWidgetClass' has a wrong offset!");
static_assert(offsetof(UUMGDragWidget_HudEditor, _customWrapper) == 0x000300, "Member 'UUMGDragWidget_HudEditor::_customWrapper' has a wrong offset!");
static_assert(offsetof(UUMGDragWidget_HudEditor, _selectionWidget) == 0x000308, "Member 'UUMGDragWidget_HudEditor::_selectionWidget' has a wrong offset!");
static_assert(offsetof(UUMGDragWidget_HudEditor, _dragLinkWidget) == 0x000310, "Member 'UUMGDragWidget_HudEditor::_dragLinkWidget' has a wrong offset!");
static_assert(offsetof(UUMGDragWidget_HudEditor, _parentLinkWidget) == 0x000318, "Member 'UUMGDragWidget_HudEditor::_parentLinkWidget' has a wrong offset!");
static_assert(offsetof(UUMGDragWidget_HudEditor, _childLinkWidget) == 0x000320, "Member 'UUMGDragWidget_HudEditor::_childLinkWidget' has a wrong offset!");

// Class DeadByDaylight.S3GameConfigsDS
// 0x01A8 (0x01E0 - 0x0038)
class US3GameConfigsDS final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x1A8];                                     // 0x0038(0x01A8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"S3GameConfigsDS">();
	}
	static class US3GameConfigsDS* GetDefaultObj()
	{
		return GetDefaultObjImpl<US3GameConfigsDS>();
	}
};
static_assert(alignof(US3GameConfigsDS) == 0x000008, "Wrong alignment on US3GameConfigsDS");
static_assert(sizeof(US3GameConfigsDS) == 0x0001E0, "Wrong size on US3GameConfigsDS");

// Class DeadByDaylight.SacrificeEnd
// 0x0000 (0x02F0 - 0x02F0)
class ASacrificeEnd : public AEmitter
{
public:
	void FX_SacrificeEnd();
	void FX_SacrificeEnd_Basement();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SacrificeEnd">();
	}
	static class ASacrificeEnd* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASacrificeEnd>();
	}
};
static_assert(alignof(ASacrificeEnd) == 0x000008, "Wrong alignment on ASacrificeEnd");
static_assert(sizeof(ASacrificeEnd) == 0x0002F0, "Wrong size on ASacrificeEnd");

// Class DeadByDaylight.ScourgeHookManagerComponent
// 0x0098 (0x0140 - 0x00A8)
class UScourgeHookManagerComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x88];                                      // 0x00A8(0x0088)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class AMeatHook>>       _scourgeHooks;                                     // 0x0130(0x0010)(Net, ZeroConstructor, Transient, RepNotify, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	void OnRep_ScourgeHooks();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScourgeHookManagerComponent">();
	}
	static class UScourgeHookManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScourgeHookManagerComponent>();
	}
};
static_assert(alignof(UScourgeHookManagerComponent) == 0x000008, "Wrong alignment on UScourgeHookManagerComponent");
static_assert(sizeof(UScourgeHookManagerComponent) == 0x000140, "Wrong size on UScourgeHookManagerComponent");
static_assert(offsetof(UScourgeHookManagerComponent, _scourgeHooks) == 0x000130, "Member 'UScourgeHookManagerComponent::_scourgeHooks' has a wrong offset!");

// Class DeadByDaylight.ScreamComponent
// 0x0030 (0x00D8 - 0x00A8)
class UScreamComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             _onScreamRevealOwner;                              // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	class UPerkManager*                           _perkManager;                                      // 0x00B8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMontagePlayer*                         _montagePlayer;                                    // 0x00C0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FGameplayTag>                   _tagsPreventingScream;                             // 0x00C8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	void OnDamageStateChanged(ECamperDamageState OldDamageState, ECamperDamageState NewDamageState);
	void ScreamRevealOwner__DelegateSignature(const float ScreamRevealDuration, const bool SpawnBubbleIndicator);
	bool TriggerScreamEventsAndAndAnimationIfPossible(bool FireLoudNoiseEvent, const struct FMontagePlaybackDefinition& MontageDefinition, float AudibleRange);
	bool TriggerScreamEventsIfPossible(bool FireLoudNoiseEvent, float AudibleRange);

	bool CanScream() const;
	bool GetCanScreamAndPreventNextScreamIfNeeded() const;
	void ScreamRevealOwner(const bool SpawnBubbleIndicator, const float ScreamRevealDuration) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScreamComponent">();
	}
	static class UScreamComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScreamComponent>();
	}
};
static_assert(alignof(UScreamComponent) == 0x000008, "Wrong alignment on UScreamComponent");
static_assert(sizeof(UScreamComponent) == 0x0000D8, "Wrong size on UScreamComponent");
static_assert(offsetof(UScreamComponent, _onScreamRevealOwner) == 0x0000A8, "Member 'UScreamComponent::_onScreamRevealOwner' has a wrong offset!");
static_assert(offsetof(UScreamComponent, _perkManager) == 0x0000B8, "Member 'UScreamComponent::_perkManager' has a wrong offset!");
static_assert(offsetof(UScreamComponent, _montagePlayer) == 0x0000C0, "Member 'UScreamComponent::_montagePlayer' has a wrong offset!");
static_assert(offsetof(UScreamComponent, _tagsPreventingScream) == 0x0000C8, "Member 'UScreamComponent::_tagsPreventingScream' has a wrong offset!");

// Class DeadByDaylight.ScreenController
// 0x02B0 (0x02E0 - 0x0030)
class UScreenController final : public UObject
{
public:
	class UDBDGameInstance*                       _gameInstance;                                     // 0x0030(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGFxObject*                             _screenControllerObj;                              // 0x0038(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGFxMoviePlayer*                        _moviePlayer;                                      // 0x0040(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class FString, class UScreenBase*>       _screenDictionary;                                 // 0x0048(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMap<class FString, EScreenType>              _screenTypeDictionary;                             // 0x0098(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMap<class UClass*, TWeakObjectPtr<class UUserWidget>> _cachedUMGScreens;                                 // 0x00E8(0x0050)(ExportObject, Transient, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_138[0x1A8];                                    // 0x0138(0x01A8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScreenController">();
	}
	static class UScreenController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScreenController>();
	}
};
static_assert(alignof(UScreenController) == 0x000008, "Wrong alignment on UScreenController");
static_assert(sizeof(UScreenController) == 0x0002E0, "Wrong size on UScreenController");
static_assert(offsetof(UScreenController, _gameInstance) == 0x000030, "Member 'UScreenController::_gameInstance' has a wrong offset!");
static_assert(offsetof(UScreenController, _screenControllerObj) == 0x000038, "Member 'UScreenController::_screenControllerObj' has a wrong offset!");
static_assert(offsetof(UScreenController, _moviePlayer) == 0x000040, "Member 'UScreenController::_moviePlayer' has a wrong offset!");
static_assert(offsetof(UScreenController, _screenDictionary) == 0x000048, "Member 'UScreenController::_screenDictionary' has a wrong offset!");
static_assert(offsetof(UScreenController, _screenTypeDictionary) == 0x000098, "Member 'UScreenController::_screenTypeDictionary' has a wrong offset!");
static_assert(offsetof(UScreenController, _cachedUMGScreens) == 0x0000E8, "Member 'UScreenController::_cachedUMGScreens' has a wrong offset!");

// Class DeadByDaylight.ScreenshotOniHook
// 0x0020 (0x0050 - 0x0030)
class UScreenshotOniHook final : public UObject
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   OniId;                                             // 0x0038(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   DemonModeTag;                                      // 0x0044(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScreenshotOniHook">();
	}
	static class UScreenshotOniHook* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScreenshotOniHook>();
	}
};
static_assert(alignof(UScreenshotOniHook) == 0x000008, "Wrong alignment on UScreenshotOniHook");
static_assert(sizeof(UScreenshotOniHook) == 0x000050, "Wrong size on UScreenshotOniHook");
static_assert(offsetof(UScreenshotOniHook, OniId) == 0x000038, "Member 'UScreenshotOniHook::OniId' has a wrong offset!");
static_assert(offsetof(UScreenshotOniHook, DemonModeTag) == 0x000044, "Member 'UScreenshotOniHook::DemonModeTag' has a wrong offset!");

// Class DeadByDaylight.ScreenshotPhysicsWeaponHook
// 0x0018 (0x0048 - 0x0030)
class UScreenshotPhysicsWeaponHook final : public UObject
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           KillersId;                                         // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScreenshotPhysicsWeaponHook">();
	}
	static class UScreenshotPhysicsWeaponHook* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScreenshotPhysicsWeaponHook>();
	}
};
static_assert(alignof(UScreenshotPhysicsWeaponHook) == 0x000008, "Wrong alignment on UScreenshotPhysicsWeaponHook");
static_assert(sizeof(UScreenshotPhysicsWeaponHook) == 0x000048, "Wrong size on UScreenshotPhysicsWeaponHook");
static_assert(offsetof(UScreenshotPhysicsWeaponHook, KillersId) == 0x000038, "Member 'UScreenshotPhysicsWeaponHook::KillersId' has a wrong offset!");

// Class DeadByDaylight.StatusEffectDataAsset
// 0x0000 (0x0090 - 0x0090)
class UStatusEffectDataAsset final : public UGameplayModifierContainerDataAsset
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StatusEffectDataAsset">();
	}
	static class UStatusEffectDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStatusEffectDataAsset>();
	}
};
static_assert(alignof(UStatusEffectDataAsset) == 0x000008, "Wrong alignment on UStatusEffectDataAsset");
static_assert(sizeof(UStatusEffectDataAsset) == 0x000090, "Wrong size on UStatusEffectDataAsset");

// Class DeadByDaylight.ScreenshotPreviewWidget
// 0x0000 (0x02A8 - 0x02A8)
class UScreenshotPreviewWidget final : public UUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScreenshotPreviewWidget">();
	}
	static class UScreenshotPreviewWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScreenshotPreviewWidget>();
	}
};
static_assert(alignof(UScreenshotPreviewWidget) == 0x000008, "Wrong alignment on UScreenshotPreviewWidget");
static_assert(sizeof(UScreenshotPreviewWidget) == 0x0002A8, "Wrong size on UScreenshotPreviewWidget");

// Class DeadByDaylight.ScreenshotSpiritHook
// 0x0060 (0x0090 - 0x0030)
class UScreenshotSpiritHook final : public UObject
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SpiritId;                                          // 0x0038(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UMaterial>               MaterialToFind;                                    // 0x0048(0x0038)(Edit, BlueprintVisible, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   MaterialFieldName;                                 // 0x0080(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaterialFieldValue;                                // 0x008C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScreenshotSpiritHook">();
	}
	static class UScreenshotSpiritHook* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScreenshotSpiritHook>();
	}
};
static_assert(alignof(UScreenshotSpiritHook) == 0x000008, "Wrong alignment on UScreenshotSpiritHook");
static_assert(sizeof(UScreenshotSpiritHook) == 0x000090, "Wrong size on UScreenshotSpiritHook");
static_assert(offsetof(UScreenshotSpiritHook, SpiritId) == 0x000038, "Member 'UScreenshotSpiritHook::SpiritId' has a wrong offset!");
static_assert(offsetof(UScreenshotSpiritHook, MaterialToFind) == 0x000048, "Member 'UScreenshotSpiritHook::MaterialToFind' has a wrong offset!");
static_assert(offsetof(UScreenshotSpiritHook, MaterialFieldName) == 0x000080, "Member 'UScreenshotSpiritHook::MaterialFieldName' has a wrong offset!");
static_assert(offsetof(UScreenshotSpiritHook, MaterialFieldValue) == 0x00008C, "Member 'UScreenshotSpiritHook::MaterialFieldValue' has a wrong offset!");

// Class DeadByDaylight.ScreenshotTool
// 0x0000 (0x03F8 - 0x03F8)
class AScreenshotTool final : public ACharacterTool
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScreenshotTool">();
	}
	static class AScreenshotTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<AScreenshotTool>();
	}
};
static_assert(alignof(AScreenshotTool) == 0x000008, "Wrong alignment on AScreenshotTool");
static_assert(sizeof(AScreenshotTool) == 0x0003F8, "Wrong size on AScreenshotTool");

// Class DeadByDaylight.SpecialEventGameplaySpawnerComponent
// 0x0000 (0x00E0 - 0x00E0)
class USpecialEventGameplaySpawnerComponent final : public UGameplaySpawnerComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpecialEventGameplaySpawnerComponent">();
	}
	static class USpecialEventGameplaySpawnerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpecialEventGameplaySpawnerComponent>();
	}
};
static_assert(alignof(USpecialEventGameplaySpawnerComponent) == 0x000008, "Wrong alignment on USpecialEventGameplaySpawnerComponent");
static_assert(sizeof(USpecialEventGameplaySpawnerComponent) == 0x0000E0, "Wrong size on USpecialEventGameplaySpawnerComponent");

// Class DeadByDaylight.ScreenshotToolConfigurationAsset
// 0x0160 (0x0198 - 0x0038)
class UScreenshotToolConfigurationAsset final : public UDataAsset
{
public:
	float                                         SceneSetupDelay;                                   // 0x0038(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UpdateCameraFromViewSettings;                      // 0x003C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AutoSelectActorInEditor;                           // 0x003D(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SaveAndCheckoutAssets;                             // 0x003E(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3F[0x1];                                       // 0x003F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, class FString>              ConsoleVariables;                                  // 0x0040(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class FName>                           ConsoleCommands;                                   // 0x0090(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FScreenshotToolPathInfo                TempIconPathInfo;                                  // 0x00A0(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FScreenshotToolPathInfo                AssetPathInfo;                                     // 0x00B8(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          ExportAllIconsInOneFrame;                          // 0x00D0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D1[0x1];                                       // 0x00D1(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	uint16                                        IconsExportedPerFrame;                             // 0x00D2(0x0002)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FScreenshotPreviewAction               PreviewAction;                                     // 0x00D8(0x0098)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FScreenshotExportAction                ExportAction;                                      // 0x0170(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UObject>>            HookClasses;                                       // 0x0188(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScreenshotToolConfigurationAsset">();
	}
	static class UScreenshotToolConfigurationAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScreenshotToolConfigurationAsset>();
	}
};
static_assert(alignof(UScreenshotToolConfigurationAsset) == 0x000008, "Wrong alignment on UScreenshotToolConfigurationAsset");
static_assert(sizeof(UScreenshotToolConfigurationAsset) == 0x000198, "Wrong size on UScreenshotToolConfigurationAsset");
static_assert(offsetof(UScreenshotToolConfigurationAsset, SceneSetupDelay) == 0x000038, "Member 'UScreenshotToolConfigurationAsset::SceneSetupDelay' has a wrong offset!");
static_assert(offsetof(UScreenshotToolConfigurationAsset, UpdateCameraFromViewSettings) == 0x00003C, "Member 'UScreenshotToolConfigurationAsset::UpdateCameraFromViewSettings' has a wrong offset!");
static_assert(offsetof(UScreenshotToolConfigurationAsset, AutoSelectActorInEditor) == 0x00003D, "Member 'UScreenshotToolConfigurationAsset::AutoSelectActorInEditor' has a wrong offset!");
static_assert(offsetof(UScreenshotToolConfigurationAsset, SaveAndCheckoutAssets) == 0x00003E, "Member 'UScreenshotToolConfigurationAsset::SaveAndCheckoutAssets' has a wrong offset!");
static_assert(offsetof(UScreenshotToolConfigurationAsset, ConsoleVariables) == 0x000040, "Member 'UScreenshotToolConfigurationAsset::ConsoleVariables' has a wrong offset!");
static_assert(offsetof(UScreenshotToolConfigurationAsset, ConsoleCommands) == 0x000090, "Member 'UScreenshotToolConfigurationAsset::ConsoleCommands' has a wrong offset!");
static_assert(offsetof(UScreenshotToolConfigurationAsset, TempIconPathInfo) == 0x0000A0, "Member 'UScreenshotToolConfigurationAsset::TempIconPathInfo' has a wrong offset!");
static_assert(offsetof(UScreenshotToolConfigurationAsset, AssetPathInfo) == 0x0000B8, "Member 'UScreenshotToolConfigurationAsset::AssetPathInfo' has a wrong offset!");
static_assert(offsetof(UScreenshotToolConfigurationAsset, ExportAllIconsInOneFrame) == 0x0000D0, "Member 'UScreenshotToolConfigurationAsset::ExportAllIconsInOneFrame' has a wrong offset!");
static_assert(offsetof(UScreenshotToolConfigurationAsset, IconsExportedPerFrame) == 0x0000D2, "Member 'UScreenshotToolConfigurationAsset::IconsExportedPerFrame' has a wrong offset!");
static_assert(offsetof(UScreenshotToolConfigurationAsset, PreviewAction) == 0x0000D8, "Member 'UScreenshotToolConfigurationAsset::PreviewAction' has a wrong offset!");
static_assert(offsetof(UScreenshotToolConfigurationAsset, ExportAction) == 0x000170, "Member 'UScreenshotToolConfigurationAsset::ExportAction' has a wrong offset!");
static_assert(offsetof(UScreenshotToolConfigurationAsset, HookClasses) == 0x000188, "Member 'UScreenshotToolConfigurationAsset::HookClasses' has a wrong offset!");

// Class DeadByDaylight.ScreenshotToolAnimationAsset
// 0x0020 (0x0058 - 0x0038)
class UScreenshotToolAnimationAsset final : public UDataAsset
{
public:
	TArray<struct FOutfitAnimation>               AnimByOutfit;                                      // 0x0038(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FCharacterRoleAnimation>        AnimByCharacter;                                   // 0x0048(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScreenshotToolAnimationAsset">();
	}
	static class UScreenshotToolAnimationAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScreenshotToolAnimationAsset>();
	}
};
static_assert(alignof(UScreenshotToolAnimationAsset) == 0x000008, "Wrong alignment on UScreenshotToolAnimationAsset");
static_assert(sizeof(UScreenshotToolAnimationAsset) == 0x000058, "Wrong size on UScreenshotToolAnimationAsset");
static_assert(offsetof(UScreenshotToolAnimationAsset, AnimByOutfit) == 0x000038, "Member 'UScreenshotToolAnimationAsset::AnimByOutfit' has a wrong offset!");
static_assert(offsetof(UScreenshotToolAnimationAsset, AnimByCharacter) == 0x000048, "Member 'UScreenshotToolAnimationAsset::AnimByCharacter' has a wrong offset!");

// Class DeadByDaylight.ScreenshotToolAsset
// 0x0038 (0x0070 - 0x0038)
class UScreenshotToolAsset final : public UDataAsset
{
public:
	struct FNamedButton                           ReloadDBBtn;                                       // 0x0038(0x0018)(Edit, NativeAccessSpecifierPublic)
	class UScreenshotToolViewAsset*               Views;                                             // 0x0050(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UScreenshotToolAnimationAsset*          Animations;                                        // 0x0058(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UScreenshotToolConfigurationAsset*      Configuration;                                     // 0x0060(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             ViewsOverridesDB;                                  // 0x0068(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScreenshotToolAsset">();
	}
	static class UScreenshotToolAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScreenshotToolAsset>();
	}
};
static_assert(alignof(UScreenshotToolAsset) == 0x000008, "Wrong alignment on UScreenshotToolAsset");
static_assert(sizeof(UScreenshotToolAsset) == 0x000070, "Wrong size on UScreenshotToolAsset");
static_assert(offsetof(UScreenshotToolAsset, ReloadDBBtn) == 0x000038, "Member 'UScreenshotToolAsset::ReloadDBBtn' has a wrong offset!");
static_assert(offsetof(UScreenshotToolAsset, Views) == 0x000050, "Member 'UScreenshotToolAsset::Views' has a wrong offset!");
static_assert(offsetof(UScreenshotToolAsset, Animations) == 0x000058, "Member 'UScreenshotToolAsset::Animations' has a wrong offset!");
static_assert(offsetof(UScreenshotToolAsset, Configuration) == 0x000060, "Member 'UScreenshotToolAsset::Configuration' has a wrong offset!");
static_assert(offsetof(UScreenshotToolAsset, ViewsOverridesDB) == 0x000068, "Member 'UScreenshotToolAsset::ViewsOverridesDB' has a wrong offset!");

// Class DeadByDaylight.ScreenshotToolHook
// 0x0000 (0x0030 - 0x0030)
class IScreenshotToolHook final : public IInterface
{
public:
	void PostBatchItems(const TArray<struct FCharacterToolItemData>& Items);
	void PostHookConstruction();
	void PostSpawnCharacter(class ADBDMenuPlayer* Character);
	void PostSpawnCharm(class ACharm* Charm);
	void PostStateChanged(EScreenshotToolState PreviousState, EScreenshotToolState CurrentState);
	void PostTakeItemScreenshot(const struct FCharacterToolItemData& Item, bool Success);
	void PostUpdateCharacter(class ADBDMenuPlayer* Character);
	void PreBatchItems();
	void PreDestroyCharacter(class ADBDMenuPlayer* Character);
	void PreDestroyCharm(class ACharm* Charm);
	void PreHookDestruction();
	void PreSpawnCharacter(class ADBDMenuPlayer* Character, struct FCharacterToolSpawnParameters* SpawnParams);
	void PreSpawnCharm(const struct FCustomizationItemData& Item);
	void PreTakeItemScreenshot(const struct FCharacterToolItemData& Item);
	void ScreenshotBeginPlay(bool IsPIE);

	bool IsPIEOnly() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScreenshotToolHook">();
	}
	static class IScreenshotToolHook* GetDefaultObj()
	{
		return GetDefaultObjImpl<IScreenshotToolHook>();
	}
};
static_assert(alignof(IScreenshotToolHook) == 0x000008, "Wrong alignment on IScreenshotToolHook");
static_assert(sizeof(IScreenshotToolHook) == 0x000030, "Wrong size on IScreenshotToolHook");

// Class DeadByDaylight.SurvivorHitSprintEffect
// 0x0000 (0x0380 - 0x0380)
class USurvivorHitSprintEffect : public UStatusEffect
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SurvivorHitSprintEffect">();
	}
	static class USurvivorHitSprintEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<USurvivorHitSprintEffect>();
	}
};
static_assert(alignof(USurvivorHitSprintEffect) == 0x000008, "Wrong alignment on USurvivorHitSprintEffect");
static_assert(sizeof(USurvivorHitSprintEffect) == 0x000380, "Wrong size on USurvivorHitSprintEffect");

// Class DeadByDaylight.ScreenshotVFXCharmHook
// 0x0018 (0x0048 - 0x0030)
class UScreenshotVFXCharmHook final : public UObject
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FScreenshotVFXCharmHookCharm>   Charms;                                            // 0x0038(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScreenshotVFXCharmHook">();
	}
	static class UScreenshotVFXCharmHook* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScreenshotVFXCharmHook>();
	}
};
static_assert(alignof(UScreenshotVFXCharmHook) == 0x000008, "Wrong alignment on UScreenshotVFXCharmHook");
static_assert(sizeof(UScreenshotVFXCharmHook) == 0x000048, "Wrong size on UScreenshotVFXCharmHook");
static_assert(offsetof(UScreenshotVFXCharmHook, Charms) == 0x000038, "Member 'UScreenshotVFXCharmHook::Charms' has a wrong offset!");

// Class DeadByDaylight.ScreenSpaceLocationComponent
// 0x0040 (0x0300 - 0x02C0)
class UScreenSpaceLocationComponent final : public USceneComponent
{
public:
	float                                         ScreenSpaceX;                                      // 0x02C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ScreenSpaceY;                                      // 0x02C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         FrameDelay;                                        // 0x02C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _updatePositionOnFovChanged;                       // 0x02CC(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _updatePositionOnViewportSizeChanged;              // 0x02CD(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2CE[0x2];                                      // 0x02CE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              _currentResolution;                                // 0x02D0(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FTransform>                     _previousTransforms;                               // 0x02E0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2F0[0x10];                                     // 0x02F0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FVector2D GetCurrentResolution() const;
	bool HasValidPosition() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScreenSpaceLocationComponent">();
	}
	static class UScreenSpaceLocationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScreenSpaceLocationComponent>();
	}
};
static_assert(alignof(UScreenSpaceLocationComponent) == 0x000010, "Wrong alignment on UScreenSpaceLocationComponent");
static_assert(sizeof(UScreenSpaceLocationComponent) == 0x000300, "Wrong size on UScreenSpaceLocationComponent");
static_assert(offsetof(UScreenSpaceLocationComponent, ScreenSpaceX) == 0x0002C0, "Member 'UScreenSpaceLocationComponent::ScreenSpaceX' has a wrong offset!");
static_assert(offsetof(UScreenSpaceLocationComponent, ScreenSpaceY) == 0x0002C4, "Member 'UScreenSpaceLocationComponent::ScreenSpaceY' has a wrong offset!");
static_assert(offsetof(UScreenSpaceLocationComponent, FrameDelay) == 0x0002C8, "Member 'UScreenSpaceLocationComponent::FrameDelay' has a wrong offset!");
static_assert(offsetof(UScreenSpaceLocationComponent, _updatePositionOnFovChanged) == 0x0002CC, "Member 'UScreenSpaceLocationComponent::_updatePositionOnFovChanged' has a wrong offset!");
static_assert(offsetof(UScreenSpaceLocationComponent, _updatePositionOnViewportSizeChanged) == 0x0002CD, "Member 'UScreenSpaceLocationComponent::_updatePositionOnViewportSizeChanged' has a wrong offset!");
static_assert(offsetof(UScreenSpaceLocationComponent, _currentResolution) == 0x0002D0, "Member 'UScreenSpaceLocationComponent::_currentResolution' has a wrong offset!");
static_assert(offsetof(UScreenSpaceLocationComponent, _previousTransforms) == 0x0002E0, "Member 'UScreenSpaceLocationComponent::_previousTransforms' has a wrong offset!");

// Class DeadByDaylight.SeancePerformerComponent
// 0x0018 (0x00C0 - 0x00A8)
class USeancePerformerComponent final : public UActorComponent
{
public:
	TArray<class USeancePerk*>                    _ownedSeancePerks;                                 // 0x00A8(0x0010)(ExportObject, Net, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	float                                         _ritualInteractionMultiplierAdditive;              // 0x00B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_OnInteractionCompleted();
	void Cosmetic_OnStartedInteracting();
	void Cosmetic_OnStoppedInteracting(bool Interrupted);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SeancePerformerComponent">();
	}
	static class USeancePerformerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USeancePerformerComponent>();
	}
};
static_assert(alignof(USeancePerformerComponent) == 0x000008, "Wrong alignment on USeancePerformerComponent");
static_assert(sizeof(USeancePerformerComponent) == 0x0000C0, "Wrong size on USeancePerformerComponent");
static_assert(offsetof(USeancePerformerComponent, _ownedSeancePerks) == 0x0000A8, "Member 'USeancePerformerComponent::_ownedSeancePerks' has a wrong offset!");
static_assert(offsetof(USeancePerformerComponent, _ritualInteractionMultiplierAdditive) == 0x0000B8, "Member 'USeancePerformerComponent::_ritualInteractionMultiplierAdditive' has a wrong offset!");

// Class DeadByDaylight.SeancePerkIconStrategy
// 0x0000 (0x0038 - 0x0038)
class USeancePerkIconStrategy final : public UBasePerkIconStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SeancePerkIconStrategy">();
	}
	static class USeancePerkIconStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<USeancePerkIconStrategy>();
	}
};
static_assert(alignof(USeancePerkIconStrategy) == 0x000008, "Wrong alignment on USeancePerkIconStrategy");
static_assert(sizeof(USeancePerkIconStrategy) == 0x000038, "Wrong size on USeancePerkIconStrategy");

// Class DeadByDaylight.SeanceRitualSpot
// 0x0098 (0x0440 - 0x03A8)
class ASeanceRitualSpot final : public AInteractable
{
public:
	uint8                                         Pad_3A8[0x10];                                     // 0x03A8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UChargeableComponent*                   _ritualChargeable;                                 // 0x03B8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _secondsToCharge;                                  // 0x03C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _dechargeRate;                                     // 0x03C4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ACamperPlayer*                          _ritualOriginator;                                 // 0x03C8(0x0008)(Net, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class ACamperPlayer*>                  _survivorsPerformingRitual;                        // 0x03D0(0x0010)(Net, ZeroConstructor, Transient, RepNotify, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UStatusEffect>              _revealAuraEffectClass;                            // 0x03E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _ritualUseable;                                    // 0x03E8(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3E9[0x7];                                      // 0x03E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class ADBDPlayer*, float>                _authority_progressAmountsCumulative;              // 0x03F0(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)

public:
	void Authority_OnChargeApplied(float IndividualChargeAmount, float TotalChargeAmount, class AActor* ChargeInstigator, bool WasCoop, float DeltaTime);
	void Authority_OnPerformRitualChargePercentChanged(class UChargeableComponent* ChargeableComponent, float PercentCompletionChange, float TotalPercentComplete);
	void Cosmetic_OnInteractionCompleted();
	void Cosmetic_OnInteractionUpdate(const class ADBDPlayer* InteractingPlayer, const float ChargePercent);
	void Cosmetic_OnStartedInteracting(class ADBDPlayer* InteractingPlayer, bool IsOriginator);
	void Cosmetic_OnStoppedInteracting(bool Interrupted);
	void Cosmetic_SurvivorsPerformingRitualUpdated();
	void Multicast_OnSeanceCompleted(class ACamperPlayer* Originator);
	bool OnFinishedRitual();
	void OnRep_SurvivorsPerformingRitual();

	TArray<class ACamperPlayer*> GetRitualPerformers() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SeanceRitualSpot">();
	}
	static class ASeanceRitualSpot* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASeanceRitualSpot>();
	}
};
static_assert(alignof(ASeanceRitualSpot) == 0x000008, "Wrong alignment on ASeanceRitualSpot");
static_assert(sizeof(ASeanceRitualSpot) == 0x000440, "Wrong size on ASeanceRitualSpot");
static_assert(offsetof(ASeanceRitualSpot, _ritualChargeable) == 0x0003B8, "Member 'ASeanceRitualSpot::_ritualChargeable' has a wrong offset!");
static_assert(offsetof(ASeanceRitualSpot, _secondsToCharge) == 0x0003C0, "Member 'ASeanceRitualSpot::_secondsToCharge' has a wrong offset!");
static_assert(offsetof(ASeanceRitualSpot, _dechargeRate) == 0x0003C4, "Member 'ASeanceRitualSpot::_dechargeRate' has a wrong offset!");
static_assert(offsetof(ASeanceRitualSpot, _ritualOriginator) == 0x0003C8, "Member 'ASeanceRitualSpot::_ritualOriginator' has a wrong offset!");
static_assert(offsetof(ASeanceRitualSpot, _survivorsPerformingRitual) == 0x0003D0, "Member 'ASeanceRitualSpot::_survivorsPerformingRitual' has a wrong offset!");
static_assert(offsetof(ASeanceRitualSpot, _revealAuraEffectClass) == 0x0003E0, "Member 'ASeanceRitualSpot::_revealAuraEffectClass' has a wrong offset!");
static_assert(offsetof(ASeanceRitualSpot, _ritualUseable) == 0x0003E8, "Member 'ASeanceRitualSpot::_ritualUseable' has a wrong offset!");
static_assert(offsetof(ASeanceRitualSpot, _authority_progressAmountsCumulative) == 0x0003F0, "Member 'ASeanceRitualSpot::_authority_progressAmountsCumulative' has a wrong offset!");

// Class DeadByDaylight.SearchableOutlineUpdateStrategy
// 0x0010 (0x0158 - 0x0148)
class USearchableOutlineUpdateStrategy final : public USourceBasedOutlineUpdateStrategy
{
public:
	struct FLinearColor                           _blockedChestColor;                                // 0x0148(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SearchableOutlineUpdateStrategy">();
	}
	static class USearchableOutlineUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<USearchableOutlineUpdateStrategy>();
	}
};
static_assert(alignof(USearchableOutlineUpdateStrategy) == 0x000008, "Wrong alignment on USearchableOutlineUpdateStrategy");
static_assert(sizeof(USearchableOutlineUpdateStrategy) == 0x000158, "Wrong size on USearchableOutlineUpdateStrategy");
static_assert(offsetof(USearchableOutlineUpdateStrategy, _blockedChestColor) == 0x000148, "Member 'USearchableOutlineUpdateStrategy::_blockedChestColor' has a wrong offset!");

// Class DeadByDaylight.SurvivorActivityData
// 0x0010 (0x0048 - 0x0038)
class USurvivorActivityData final : public UDataAsset
{
public:
	TArray<struct FSurvivorActivity>              _allPossibleActivities;                            // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SurvivorActivityData">();
	}
	static class USurvivorActivityData* GetDefaultObj()
	{
		return GetDefaultObjImpl<USurvivorActivityData>();
	}
};
static_assert(alignof(USurvivorActivityData) == 0x000008, "Wrong alignment on USurvivorActivityData");
static_assert(sizeof(USurvivorActivityData) == 0x000048, "Wrong size on USurvivorActivityData");
static_assert(offsetof(USurvivorActivityData, _allPossibleActivities) == 0x000038, "Member 'USurvivorActivityData::_allPossibleActivities' has a wrong offset!");

// Class DeadByDaylight.SeasonEndPopupScreen
// 0x0000 (0x0148 - 0x0148)
class USeasonEndPopupScreen final : public UGenericPopupScreen
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SeasonEndPopupScreen">();
	}
	static class USeasonEndPopupScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<USeasonEndPopupScreen>();
	}
};
static_assert(alignof(USeasonEndPopupScreen) == 0x000008, "Wrong alignment on USeasonEndPopupScreen");
static_assert(sizeof(USeasonEndPopupScreen) == 0x000148, "Wrong size on USeasonEndPopupScreen");

// Class DeadByDaylight.SkillCollectionComponent
// 0x0038 (0x00E0 - 0x00A8)
class USkillCollectionComponent final : public UActorComponent
{
public:
	TArray<class USkill*>                         _array;                                            // 0x00A8(0x0010)(ExportObject, Net, ZeroConstructor, Transient, RepNotify, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B8[0x18];                                      // 0x00B8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   _characterClassID;                                 // 0x00D0(0x000C)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_DC[0x4];                                       // 0x00DC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_Array(const TArray<class USkill*>& OldArray);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SkillCollectionComponent">();
	}
	static class USkillCollectionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USkillCollectionComponent>();
	}
};
static_assert(alignof(USkillCollectionComponent) == 0x000008, "Wrong alignment on USkillCollectionComponent");
static_assert(sizeof(USkillCollectionComponent) == 0x0000E0, "Wrong size on USkillCollectionComponent");
static_assert(offsetof(USkillCollectionComponent, _array) == 0x0000A8, "Member 'USkillCollectionComponent::_array' has a wrong offset!");
static_assert(offsetof(USkillCollectionComponent, _characterClassID) == 0x0000D0, "Member 'USkillCollectionComponent::_characterClassID' has a wrong offset!");

// Class DeadByDaylight.SlashableInterface
// 0x0000 (0x0030 - 0x0030)
class ISlashableInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SlashableInterface">();
	}
	static class ISlashableInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ISlashableInterface>();
	}
};
static_assert(alignof(ISlashableInterface) == 0x000008, "Wrong alignment on ISlashableInterface");
static_assert(sizeof(ISlashableInterface) == 0x000030, "Wrong size on ISlashableInterface");

// Class DeadByDaylight.SlasherAnimInstance
// 0x0210 (0x0560 - 0x0350)
class USlasherAnimInstance final : public UAnimInstance
{
public:
	FMulticastInlineDelegateProperty_             OnFootTrapped;                                     // 0x0350(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	EIntroState                                   _introState;                                       // 0x0360(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isCrouched;                                       // 0x0361(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isRevvingChainsaw;                                // 0x0362(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isAttackSuccessMontagePlaying;                    // 0x0363(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isCamOn;                                          // 0x0364(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isAttacking;                                      // 0x0365(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isAnyMontagePlaying;                              // 0x0366(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isFrenzy;                                         // 0x0367(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isFrenzyCD;                                       // 0x0368(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isInParadise;                                     // 0x0369(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _enableArmOverrideTier3;                           // 0x036A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isRingingBell;                                    // 0x036B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isCarrying;                                       // 0x036C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_36D[0x3];                                      // 0x036D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                _firstPersonCarryOffset;                           // 0x0370(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                _firstPersonCarryOffsetLookingDown;                // 0x0388(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isPassivePhaseWalking;                            // 0x03A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isActivePhaseWalking;                             // 0x03A1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isInAir;                                          // 0x03A2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isVaultingToFall;                                 // 0x03A3(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isSpectator;                                      // 0x03A4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _firstPersonView;                                  // 0x03A5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isIdle;                                           // 0x03A6(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _validSlasher;                                     // 0x03A7(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _animDirection;                                    // 0x03A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _animSpeed;                                        // 0x03AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _animPitch;                                        // 0x03B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _animTurning;                                      // 0x03B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _animYaw;                                          // 0x03B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _pelvisHeight;                                     // 0x03BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _idleTime;                                         // 0x03C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _directionSwitch;                                  // 0x03C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                _leftClearFrontSpaceVector;                        // 0x03C8(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                _rightClearFrontSpaceVector;                       // 0x03E0(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                _velocity;                                         // 0x03F8(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                _rightFootEffectorLocation;                        // 0x0410(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                _leftFootEffectorLocation;                         // 0x0428(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               _meshRotation;                                     // 0x0440(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TArray<class UAnimMontage*>                   _attackSuccessAnimations;                          // 0x0458(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class UAnimMontage*>                   _camOnAnimations;                                  // 0x0468(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class ASlasherPlayer*                         _mySlasher;                                        // 0x0478(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTagStateBool                          _isVaultingToFallState;                            // 0x0480(0x0048)(Transient, Protected, NativeAccessSpecifierProtected)
	EInteractionAnimation                         _interactionType;                                  // 0x04C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4C9[0xF];                                      // 0x04C9(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _demogorgonTeleportDuration;                       // 0x04D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4DC[0x4];                                      // 0x04DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UChargedAttackStateComponent*           _demogorgonChargedAttackStateComponent;            // 0x04E0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isDemogorgonCharging;                             // 0x04E8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4E9[0x3];                                      // 0x04E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _demogorgonChargingPercent;                        // 0x04EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOniDemonModeAttackStateComponent*      _oniAttackState;                                   // 0x04F0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isOniCharging;                                    // 0x04F8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EOniAttackType                                _oniAttackType;                                    // 0x04F9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4FA[0x2];                                      // 0x04FA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _oniChargeDuration;                                // 0x04FC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAttackSubstate                               _previousAttackSubstate;                           // 0x0500(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAttackSubstate                               _attackSubState;                                   // 0x0501(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_502[0x6];                                      // 0x0502(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UEvilWithinComponent*                   _evilWithinComponent;                              // 0x0508(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_510[0x10];                                     // 0x0510(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UArmIKSensorComponent*                  _armIKSensorComponent;                             // 0x0520(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_528[0x18];                                     // 0x0528(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimEffectHandler*                     _animEffectHandlerForSFX;                          // 0x0540(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimEffectHandler*                     _animEffectHandlerForVFX;                          // 0x0548(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UAnimEffectHandler>         _animEffectHandlerClassForSFX;                     // 0x0550(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UAnimEffectHandler>         _animEffectHandlerClassForVFX;                     // 0x0558(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void CallOnFootTrapped();
	void SetIsCrouched(const bool Value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SlasherAnimInstance">();
	}
	static class USlasherAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USlasherAnimInstance>();
	}
};
static_assert(alignof(USlasherAnimInstance) == 0x000010, "Wrong alignment on USlasherAnimInstance");
static_assert(sizeof(USlasherAnimInstance) == 0x000560, "Wrong size on USlasherAnimInstance");
static_assert(offsetof(USlasherAnimInstance, OnFootTrapped) == 0x000350, "Member 'USlasherAnimInstance::OnFootTrapped' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _introState) == 0x000360, "Member 'USlasherAnimInstance::_introState' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _isCrouched) == 0x000361, "Member 'USlasherAnimInstance::_isCrouched' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _isRevvingChainsaw) == 0x000362, "Member 'USlasherAnimInstance::_isRevvingChainsaw' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _isAttackSuccessMontagePlaying) == 0x000363, "Member 'USlasherAnimInstance::_isAttackSuccessMontagePlaying' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _isCamOn) == 0x000364, "Member 'USlasherAnimInstance::_isCamOn' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _isAttacking) == 0x000365, "Member 'USlasherAnimInstance::_isAttacking' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _isAnyMontagePlaying) == 0x000366, "Member 'USlasherAnimInstance::_isAnyMontagePlaying' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _isFrenzy) == 0x000367, "Member 'USlasherAnimInstance::_isFrenzy' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _isFrenzyCD) == 0x000368, "Member 'USlasherAnimInstance::_isFrenzyCD' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _isInParadise) == 0x000369, "Member 'USlasherAnimInstance::_isInParadise' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _enableArmOverrideTier3) == 0x00036A, "Member 'USlasherAnimInstance::_enableArmOverrideTier3' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _isRingingBell) == 0x00036B, "Member 'USlasherAnimInstance::_isRingingBell' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _isCarrying) == 0x00036C, "Member 'USlasherAnimInstance::_isCarrying' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _firstPersonCarryOffset) == 0x000370, "Member 'USlasherAnimInstance::_firstPersonCarryOffset' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _firstPersonCarryOffsetLookingDown) == 0x000388, "Member 'USlasherAnimInstance::_firstPersonCarryOffsetLookingDown' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _isPassivePhaseWalking) == 0x0003A0, "Member 'USlasherAnimInstance::_isPassivePhaseWalking' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _isActivePhaseWalking) == 0x0003A1, "Member 'USlasherAnimInstance::_isActivePhaseWalking' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _isInAir) == 0x0003A2, "Member 'USlasherAnimInstance::_isInAir' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _isVaultingToFall) == 0x0003A3, "Member 'USlasherAnimInstance::_isVaultingToFall' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _isSpectator) == 0x0003A4, "Member 'USlasherAnimInstance::_isSpectator' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _firstPersonView) == 0x0003A5, "Member 'USlasherAnimInstance::_firstPersonView' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _isIdle) == 0x0003A6, "Member 'USlasherAnimInstance::_isIdle' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _validSlasher) == 0x0003A7, "Member 'USlasherAnimInstance::_validSlasher' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _animDirection) == 0x0003A8, "Member 'USlasherAnimInstance::_animDirection' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _animSpeed) == 0x0003AC, "Member 'USlasherAnimInstance::_animSpeed' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _animPitch) == 0x0003B0, "Member 'USlasherAnimInstance::_animPitch' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _animTurning) == 0x0003B4, "Member 'USlasherAnimInstance::_animTurning' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _animYaw) == 0x0003B8, "Member 'USlasherAnimInstance::_animYaw' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _pelvisHeight) == 0x0003BC, "Member 'USlasherAnimInstance::_pelvisHeight' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _idleTime) == 0x0003C0, "Member 'USlasherAnimInstance::_idleTime' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _directionSwitch) == 0x0003C4, "Member 'USlasherAnimInstance::_directionSwitch' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _leftClearFrontSpaceVector) == 0x0003C8, "Member 'USlasherAnimInstance::_leftClearFrontSpaceVector' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _rightClearFrontSpaceVector) == 0x0003E0, "Member 'USlasherAnimInstance::_rightClearFrontSpaceVector' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _velocity) == 0x0003F8, "Member 'USlasherAnimInstance::_velocity' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _rightFootEffectorLocation) == 0x000410, "Member 'USlasherAnimInstance::_rightFootEffectorLocation' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _leftFootEffectorLocation) == 0x000428, "Member 'USlasherAnimInstance::_leftFootEffectorLocation' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _meshRotation) == 0x000440, "Member 'USlasherAnimInstance::_meshRotation' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _attackSuccessAnimations) == 0x000458, "Member 'USlasherAnimInstance::_attackSuccessAnimations' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _camOnAnimations) == 0x000468, "Member 'USlasherAnimInstance::_camOnAnimations' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _mySlasher) == 0x000478, "Member 'USlasherAnimInstance::_mySlasher' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _isVaultingToFallState) == 0x000480, "Member 'USlasherAnimInstance::_isVaultingToFallState' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _interactionType) == 0x0004C8, "Member 'USlasherAnimInstance::_interactionType' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _demogorgonTeleportDuration) == 0x0004D8, "Member 'USlasherAnimInstance::_demogorgonTeleportDuration' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _demogorgonChargedAttackStateComponent) == 0x0004E0, "Member 'USlasherAnimInstance::_demogorgonChargedAttackStateComponent' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _isDemogorgonCharging) == 0x0004E8, "Member 'USlasherAnimInstance::_isDemogorgonCharging' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _demogorgonChargingPercent) == 0x0004EC, "Member 'USlasherAnimInstance::_demogorgonChargingPercent' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _oniAttackState) == 0x0004F0, "Member 'USlasherAnimInstance::_oniAttackState' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _isOniCharging) == 0x0004F8, "Member 'USlasherAnimInstance::_isOniCharging' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _oniAttackType) == 0x0004F9, "Member 'USlasherAnimInstance::_oniAttackType' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _oniChargeDuration) == 0x0004FC, "Member 'USlasherAnimInstance::_oniChargeDuration' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _previousAttackSubstate) == 0x000500, "Member 'USlasherAnimInstance::_previousAttackSubstate' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _attackSubState) == 0x000501, "Member 'USlasherAnimInstance::_attackSubState' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _evilWithinComponent) == 0x000508, "Member 'USlasherAnimInstance::_evilWithinComponent' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _armIKSensorComponent) == 0x000520, "Member 'USlasherAnimInstance::_armIKSensorComponent' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _animEffectHandlerForSFX) == 0x000540, "Member 'USlasherAnimInstance::_animEffectHandlerForSFX' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _animEffectHandlerForVFX) == 0x000548, "Member 'USlasherAnimInstance::_animEffectHandlerForVFX' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _animEffectHandlerClassForSFX) == 0x000550, "Member 'USlasherAnimInstance::_animEffectHandlerClassForSFX' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _animEffectHandlerClassForVFX) == 0x000558, "Member 'USlasherAnimInstance::_animEffectHandlerClassForVFX' has a wrong offset!");

// Class DeadByDaylight.SpecialBehaviourGameplaySpawnerComponent
// 0x0000 (0x00E0 - 0x00E0)
class USpecialBehaviourGameplaySpawnerComponent final : public UGameplaySpawnerComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpecialBehaviourGameplaySpawnerComponent">();
	}
	static class USpecialBehaviourGameplaySpawnerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpecialBehaviourGameplaySpawnerComponent>();
	}
};
static_assert(alignof(USpecialBehaviourGameplaySpawnerComponent) == 0x000008, "Wrong alignment on USpecialBehaviourGameplaySpawnerComponent");
static_assert(sizeof(USpecialBehaviourGameplaySpawnerComponent) == 0x0000E0, "Wrong size on USpecialBehaviourGameplaySpawnerComponent");

// Class DeadByDaylight.SpecialEventCustomizationsComponent
// 0x0110 (0x0140 - 0x0030)
class USpecialEventCustomizationsComponent final : public UObject
{
public:
	uint8                                         Pad_30[0x110];                                     // 0x0030(0x0110)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpecialEventCustomizationsComponent">();
	}
	static class USpecialEventCustomizationsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpecialEventCustomizationsComponent>();
	}
};
static_assert(alignof(USpecialEventCustomizationsComponent) == 0x000008, "Wrong alignment on USpecialEventCustomizationsComponent");
static_assert(sizeof(USpecialEventCustomizationsComponent) == 0x000140, "Wrong size on USpecialEventCustomizationsComponent");

// Class DeadByDaylight.specialeventmanager
// 0x0168 (0x0198 - 0x0030)
class USpecialeventmanager final : public UObject
{
public:
	uint8                                         Pad_30[0x30];                                      // 0x0030(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class USpecialEventsContainer*                _eventsContainer;                                  // 0x0060(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USpecialEventCustomizationsComponent*   _customizationsComponent;                          // 0x0068(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_70[0x128];                                     // 0x0070(0x0128)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool GetCurrentMainSpecialEvent(const class UObject* WorldContextObject, struct FCombinedSpecialEventData* OutSpecialEventData);
	static bool GetCurrentSpecialEvent(const class UObject* WorldContextObject, struct FCombinedSpecialEventData* OutSpecialEventData);
	static bool GetEventMainEndDate(const class FString& EventID, struct FDateTime* OutDate);
	static bool GetEventPostEndDate(const class FString& EventID, struct FDateTime* OutDate);
	static bool GetEventStartDate(const class FString& EventID, struct FDateTime* OutDate);
	static bool GetEventTimeSinceStartDate(const class FString& EventID, struct FTimespan* OutDate);
	static bool GetEventTimeTillMainEndDate(const class FString& EventID, struct FTimespan* OutDate);
	static bool GetEventTimeTillPostEndDate(const class FString& EventID, struct FTimespan* OutDate);
	static struct FDateTime GetMainEndDate(const struct FCombinedSpecialEventData& SpecialEventData);
	static struct FDateTime GetPostEndDate(const struct FCombinedSpecialEventData& SpecialEventData);
	static bool GetSpecialEvent(const class UObject* WorldContextObject, const class FName EventID, struct FCombinedSpecialEventData* OutSpecialEventData);
	static struct FDateTime GetStartDate(const struct FCombinedSpecialEventData& SpecialEventData);
	static ESpecialEventStatus GetStatus(const struct FCombinedSpecialEventData& SpecialEventData);
	static struct FTimespan GetTimeSinceStartDate(const struct FCombinedSpecialEventData& SpecialEventData);
	static struct FTimespan GetTimeTillMainEndDate(const struct FCombinedSpecialEventData& SpecialEventData);
	static struct FTimespan GetTimeTillPostEndDate(const struct FCombinedSpecialEventData& SpecialEventData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"specialeventmanager">();
	}
	static class USpecialeventmanager* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpecialeventmanager>();
	}
};
static_assert(alignof(USpecialeventmanager) == 0x000008, "Wrong alignment on USpecialeventmanager");
static_assert(sizeof(USpecialeventmanager) == 0x000198, "Wrong size on USpecialeventmanager");
static_assert(offsetof(USpecialeventmanager, _eventsContainer) == 0x000060, "Member 'USpecialeventmanager::_eventsContainer' has a wrong offset!");
static_assert(offsetof(USpecialeventmanager, _customizationsComponent) == 0x000068, "Member 'USpecialeventmanager::_customizationsComponent' has a wrong offset!");

// Class DeadByDaylight.SplashScreen
// 0x0018 (0x0140 - 0x0128)
class USplashScreen final : public UScreenBase
{
public:
	uint8                                         Pad_128[0x18];                                     // 0x0128(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnSaveGamePopupComplete();

	void HidePressKeyState() const;
	void SetVersionText(const class FString& VersionText) const;
	void ShowLoadingState() const;
	void ShowPressKeyState() const;
	void ShowSaveGamePopup() const;
	void ShowSpecialEventVisual(const struct FSpecialEventUIInfo& EventInfo) const;
	void UpdateLoadingProgression(const class FString& LoadingProgression) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SplashScreen">();
	}
	static class USplashScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<USplashScreen>();
	}
};
static_assert(alignof(USplashScreen) == 0x000008, "Wrong alignment on USplashScreen");
static_assert(sizeof(USplashScreen) == 0x000140, "Wrong size on USplashScreen");

// Class DeadByDaylight.SpringArmCameraTargetingStrategy
// 0x0018 (0x0068 - 0x0050)
class USpringArmCameraTargetingStrategy final : public UBaseCameraTargetingStrategy
{
public:
	uint8                                         Pad_50[0x18];                                      // 0x0050(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpringArmCameraTargetingStrategy">();
	}
	static class USpringArmCameraTargetingStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpringArmCameraTargetingStrategy>();
	}
};
static_assert(alignof(USpringArmCameraTargetingStrategy) == 0x000008, "Wrong alignment on USpringArmCameraTargetingStrategy");
static_assert(sizeof(USpringArmCameraTargetingStrategy) == 0x000068, "Wrong size on USpringArmCameraTargetingStrategy");

// Class DeadByDaylight.StartLitActivationTimerRemainingCooldownElapsedIconStrategy
// 0x0000 (0x0038 - 0x0038)
class UStartLitActivationTimerRemainingCooldownElapsedIconStrategy final : public UBasePerkIconStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StartLitActivationTimerRemainingCooldownElapsedIconStrategy">();
	}
	static class UStartLitActivationTimerRemainingCooldownElapsedIconStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStartLitActivationTimerRemainingCooldownElapsedIconStrategy>();
	}
};
static_assert(alignof(UStartLitActivationTimerRemainingCooldownElapsedIconStrategy) == 0x000008, "Wrong alignment on UStartLitActivationTimerRemainingCooldownElapsedIconStrategy");
static_assert(sizeof(UStartLitActivationTimerRemainingCooldownElapsedIconStrategy) == 0x000038, "Wrong size on UStartLitActivationTimerRemainingCooldownElapsedIconStrategy");

// Class DeadByDaylight.StationarySpotLightComponent
// 0x0000 (0x0520 - 0x0520)
class UStationarySpotLightComponent final : public USpotLightComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StationarySpotLightComponent">();
	}
	static class UStationarySpotLightComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStationarySpotLightComponent>();
	}
};
static_assert(alignof(UStationarySpotLightComponent) == 0x000010, "Wrong alignment on UStationarySpotLightComponent");
static_assert(sizeof(UStationarySpotLightComponent) == 0x000520, "Wrong size on UStationarySpotLightComponent");

// Class DeadByDaylight.SupplyCrateInteractable
// 0x0118 (0x04C0 - 0x03A8)
class ASupplyCrateInteractable final : public AInteractable
{
public:
	uint8                                         Pad_3A8[0x38];                                     // 0x03A8(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	class UChargeableComponent*                   _chargeableComponent;                              // 0x03E0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class ACollectable>               _containedCollectable;                             // 0x03E8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _openInteractionSecondsToCharge;                   // 0x03F0(0x0028)(Edit, NativeAccessSpecifierPrivate)
	class ACollectable*                           _itemInSupplyCrate;                                // 0x0418(0x0008)(Net, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USceneComponent*                        _containingItemSpawnPoint;                         // 0x0420(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USceneComponent*                        _itemDropPoint;                                    // 0x0428(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isOpen;                                           // 0x0430(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isAutoClosing;                                    // 0x0431(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_432[0x3E];                                     // 0x0432(0x003E)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _crateSelfClosingTime;                             // 0x0470(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _crateAutoCloseAnimationTime;                      // 0x0498(0x0028)(Edit, NativeAccessSpecifierPrivate)

public:
	void OnIsClosing();
	void OnIsOpened();
	void OnRep_IsAutoClosing();
	void OnRep_IsOpen();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SupplyCrateInteractable">();
	}
	static class ASupplyCrateInteractable* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASupplyCrateInteractable>();
	}
};
static_assert(alignof(ASupplyCrateInteractable) == 0x000008, "Wrong alignment on ASupplyCrateInteractable");
static_assert(sizeof(ASupplyCrateInteractable) == 0x0004C0, "Wrong size on ASupplyCrateInteractable");
static_assert(offsetof(ASupplyCrateInteractable, _chargeableComponent) == 0x0003E0, "Member 'ASupplyCrateInteractable::_chargeableComponent' has a wrong offset!");
static_assert(offsetof(ASupplyCrateInteractable, _containedCollectable) == 0x0003E8, "Member 'ASupplyCrateInteractable::_containedCollectable' has a wrong offset!");
static_assert(offsetof(ASupplyCrateInteractable, _openInteractionSecondsToCharge) == 0x0003F0, "Member 'ASupplyCrateInteractable::_openInteractionSecondsToCharge' has a wrong offset!");
static_assert(offsetof(ASupplyCrateInteractable, _itemInSupplyCrate) == 0x000418, "Member 'ASupplyCrateInteractable::_itemInSupplyCrate' has a wrong offset!");
static_assert(offsetof(ASupplyCrateInteractable, _containingItemSpawnPoint) == 0x000420, "Member 'ASupplyCrateInteractable::_containingItemSpawnPoint' has a wrong offset!");
static_assert(offsetof(ASupplyCrateInteractable, _itemDropPoint) == 0x000428, "Member 'ASupplyCrateInteractable::_itemDropPoint' has a wrong offset!");
static_assert(offsetof(ASupplyCrateInteractable, _isOpen) == 0x000430, "Member 'ASupplyCrateInteractable::_isOpen' has a wrong offset!");
static_assert(offsetof(ASupplyCrateInteractable, _isAutoClosing) == 0x000431, "Member 'ASupplyCrateInteractable::_isAutoClosing' has a wrong offset!");
static_assert(offsetof(ASupplyCrateInteractable, _crateSelfClosingTime) == 0x000470, "Member 'ASupplyCrateInteractable::_crateSelfClosingTime' has a wrong offset!");
static_assert(offsetof(ASupplyCrateInteractable, _crateAutoCloseAnimationTime) == 0x000498, "Member 'ASupplyCrateInteractable::_crateAutoCloseAnimationTime' has a wrong offset!");

// Class DeadByDaylight.SurvivorActivityIndicatorComponent
// 0x0160 (0x0208 - 0x00A8)
class USurvivorActivityIndicatorComponent : public UActorComponent
{
public:
	uint8                                         Pad_A8[0xB0];                                      // 0x00A8(0x00B0)(Fixing Size After Last Property [ Dumper-7 ])
	class USurvivorActivityData*                  _activitiesDataAsset;                              // 0x0158(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_160[0x30];                                     // 0x0160(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _durationNeededToEnableUI;                         // 0x0190(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_194[0x74];                                     // 0x0194(0x0074)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnCamperEscape(const struct FGameplayTag& GameplayTag, const struct FGameEventData& GameEventData);
	void HandleStartActivityIfStillInEffect(const struct FSurvivorActivity& ActivityViewInfo);
	void Multicast_OnCamperEscape();
	void OnChargeableProgressChanged(class UChargeableComponent* ChargeableComponent, float TotalPercentComplete);
	void OnDamageStateChanged(ECamperDamageState OldDamageState, ECamperDamageState CurrentDamageState);
	void OnPlayerDropped();
	void OnPlayerPickedUp(class ADBDPlayer* Picker);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SurvivorActivityIndicatorComponent">();
	}
	static class USurvivorActivityIndicatorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USurvivorActivityIndicatorComponent>();
	}
};
static_assert(alignof(USurvivorActivityIndicatorComponent) == 0x000008, "Wrong alignment on USurvivorActivityIndicatorComponent");
static_assert(sizeof(USurvivorActivityIndicatorComponent) == 0x000208, "Wrong size on USurvivorActivityIndicatorComponent");
static_assert(offsetof(USurvivorActivityIndicatorComponent, _activitiesDataAsset) == 0x000158, "Member 'USurvivorActivityIndicatorComponent::_activitiesDataAsset' has a wrong offset!");
static_assert(offsetof(USurvivorActivityIndicatorComponent, _durationNeededToEnableUI) == 0x000190, "Member 'USurvivorActivityIndicatorComponent::_durationNeededToEnableUI' has a wrong offset!");

// Class DeadByDaylight.SurvivorDisconnectionComponent
// 0x0000 (0x00A8 - 0x00A8)
class USurvivorDisconnectionComponent final : public UActorComponent
{
public:
	void Authority_OnPlayerDisconnected(class ADBDPlayer* Player);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SurvivorDisconnectionComponent">();
	}
	static class USurvivorDisconnectionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USurvivorDisconnectionComponent>();
	}
};
static_assert(alignof(USurvivorDisconnectionComponent) == 0x000008, "Wrong alignment on USurvivorDisconnectionComponent");
static_assert(sizeof(USurvivorDisconnectionComponent) == 0x0000A8, "Wrong size on USurvivorDisconnectionComponent");

// Class DeadByDaylight.SurvivorPlagueEffect
// 0x01F0 (0x0570 - 0x0380)
class USurvivorPlagueEffect final : public UStatusEffect
{
public:
	uint8                                         Pad_380[0x48];                                     // 0x0380(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _sicknessAmount;                                   // 0x03C8(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _sicknessCap;                                      // 0x03CC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _vomitSlowDuration;                                // 0x03D0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _vomitSlowAmount;                                  // 0x03D4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<float>                                 _sicknessThresholds;                               // 0x03D8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPrivate)
	bool                                          _wasRecentlyHitByVomit;                            // 0x03E8(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3E9[0x7];                                      // 0x03E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         _nonNauseatingInteractions;                        // 0x03F0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_400[0x18];                                     // 0x0400(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTunableStat                           _sicknessGainPerSecondFromInfectedInteractable;    // 0x0418(0x0080)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_498[0x88];                                     // 0x0498(0x0088)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _debugMode;                                        // 0x0520(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_521[0x3F];                                     // 0x0521(0x003F)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UStatusEffect>              _exposeMaximumSickSurvivorEffect;                  // 0x0560(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _brokenMaximumSickSurvivorEffect;                  // 0x0568(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Authority_AddSickness(float SicknessToAdd);
	void Authority_InfectInteractable(class AInteractable* Interactable);
	void Authority_OnHitBySuperVomitProjectile();
	void Authority_OnHitByVomitProjectile(float SicknessToAdd);
	void Authority_OnHitByVomitProjectileAesthetic();
	void Authority_ResetSickness(float NewSickness);
	void Multicast_AddOnScreenDebugMessage(uint64 Key, float Duration, const struct FColor& DisplayColor, const class FString& DebugMessage);
	void Multicast_OnMaxSicknessReached();
	void Multicast_OnSicknessChanged(float NewSickness);
	void Multicast_OnSicknessCured();
	void Multicast_OnSurvivorBecomesInfected();
	void Multicast_OnSurvivorVomit();
	void OnHitByVomit(bool IsSuperVomit);
	void OnMaxSicknessReached_Aesthetic();
	void OnRep_SicknessAmount();
	void OnSicknessChanged_Aesthetic(float NewSickness);
	void OnSicknessCured_Aesthetic();
	void OnSurvivorBecomesInfected_Aesthetic();
	void OnSurvivorDisguisedOrUndisguised(bool IsDisguised);
	void OnSurvivorVomit_Aesthetic();
	void RefreshSicknessGainValues();

	uint8 GetMaxSicknessLevel() const;
	float GetSicknessAmount() const;
	uint8 GetSicknessLevel() const;
	float GetSicknessPercentage() const;
	TArray<float> GetSicknessThresholds() const;
	bool HasMaxLevelSickness() const;
	bool IsDebugModeActive() const;
	bool IsInfected() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SurvivorPlagueEffect">();
	}
	static class USurvivorPlagueEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<USurvivorPlagueEffect>();
	}
};
static_assert(alignof(USurvivorPlagueEffect) == 0x000008, "Wrong alignment on USurvivorPlagueEffect");
static_assert(sizeof(USurvivorPlagueEffect) == 0x000570, "Wrong size on USurvivorPlagueEffect");
static_assert(offsetof(USurvivorPlagueEffect, _sicknessAmount) == 0x0003C8, "Member 'USurvivorPlagueEffect::_sicknessAmount' has a wrong offset!");
static_assert(offsetof(USurvivorPlagueEffect, _sicknessCap) == 0x0003CC, "Member 'USurvivorPlagueEffect::_sicknessCap' has a wrong offset!");
static_assert(offsetof(USurvivorPlagueEffect, _vomitSlowDuration) == 0x0003D0, "Member 'USurvivorPlagueEffect::_vomitSlowDuration' has a wrong offset!");
static_assert(offsetof(USurvivorPlagueEffect, _vomitSlowAmount) == 0x0003D4, "Member 'USurvivorPlagueEffect::_vomitSlowAmount' has a wrong offset!");
static_assert(offsetof(USurvivorPlagueEffect, _sicknessThresholds) == 0x0003D8, "Member 'USurvivorPlagueEffect::_sicknessThresholds' has a wrong offset!");
static_assert(offsetof(USurvivorPlagueEffect, _wasRecentlyHitByVomit) == 0x0003E8, "Member 'USurvivorPlagueEffect::_wasRecentlyHitByVomit' has a wrong offset!");
static_assert(offsetof(USurvivorPlagueEffect, _nonNauseatingInteractions) == 0x0003F0, "Member 'USurvivorPlagueEffect::_nonNauseatingInteractions' has a wrong offset!");
static_assert(offsetof(USurvivorPlagueEffect, _sicknessGainPerSecondFromInfectedInteractable) == 0x000418, "Member 'USurvivorPlagueEffect::_sicknessGainPerSecondFromInfectedInteractable' has a wrong offset!");
static_assert(offsetof(USurvivorPlagueEffect, _debugMode) == 0x000520, "Member 'USurvivorPlagueEffect::_debugMode' has a wrong offset!");
static_assert(offsetof(USurvivorPlagueEffect, _exposeMaximumSickSurvivorEffect) == 0x000560, "Member 'USurvivorPlagueEffect::_exposeMaximumSickSurvivorEffect' has a wrong offset!");
static_assert(offsetof(USurvivorPlagueEffect, _brokenMaximumSickSurvivorEffect) == 0x000568, "Member 'USurvivorPlagueEffect::_brokenMaximumSickSurvivorEffect' has a wrong offset!");

// Class DeadByDaylight.SurvivorStatusInterface
// 0x0000 (0x0030 - 0x0030)
class ISurvivorStatusInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SurvivorStatusInterface">();
	}
	static class ISurvivorStatusInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ISurvivorStatusInterface>();
	}
};
static_assert(alignof(ISurvivorStatusInterface) == 0x000008, "Wrong alignment on ISurvivorStatusInterface");
static_assert(sizeof(ISurvivorStatusInterface) == 0x000030, "Wrong size on ISurvivorStatusInterface");

// Class DeadByDaylight.SwitchProfileDAL
// 0x0000 (0x0088 - 0x0088)
class USwitchProfileDAL final : public UPlayerProfileDAL
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SwitchProfileDAL">();
	}
	static class USwitchProfileDAL* GetDefaultObj()
	{
		return GetDefaultObjImpl<USwitchProfileDAL>();
	}
};
static_assert(alignof(USwitchProfileDAL) == 0x000008, "Wrong alignment on USwitchProfileDAL");
static_assert(sizeof(USwitchProfileDAL) == 0x000088, "Wrong size on USwitchProfileDAL");

// Class DeadByDaylight.TallyScreen
// 0x00B0 (0x01D8 - 0x0128)
class UTallyScreen final : public UScreenBase
{
public:
	uint8                                         Pad_128[0xB0];                                     // 0x0128(0x00B0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnBloodwebButtonClick();
	void OnCustomerSupportButtonClick();
	void OnLeaveButtonClick();
	void OnLevelingSequenceComplete();
	void OnRateMatch(int32 RateValue);
	void OnSpectateButtonClick();
	void OnUpdateUMGTallyScoreboardVisibility(bool IsVisible);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TallyScreen">();
	}
	static class UTallyScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTallyScreen>();
	}
};
static_assert(alignof(UTallyScreen) == 0x000008, "Wrong alignment on UTallyScreen");
static_assert(sizeof(UTallyScreen) == 0x0001D8, "Wrong size on UTallyScreen");

// Class DeadByDaylight.TickInEditorSkeletalMesh
// 0x0000 (0x0320 - 0x0320)
class ATickInEditorSkeletalMesh final : public ASkeletalMeshActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TickInEditorSkeletalMesh">();
	}
	static class ATickInEditorSkeletalMesh* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATickInEditorSkeletalMesh>();
	}
};
static_assert(alignof(ATickInEditorSkeletalMesh) == 0x000008, "Wrong alignment on ATickInEditorSkeletalMesh");
static_assert(sizeof(ATickInEditorSkeletalMesh) == 0x000320, "Wrong size on ATickInEditorSkeletalMesh");

// Class DeadByDaylight.TileSpawnPointSelector
// 0x0020 (0x02E0 - 0x02C0)
class UTileSpawnPointSelector final : public USceneComponent
{
public:
	TArray<struct FSelectableTileSpawnPoint>      _tileSpawnPoints;                                  // 0x02C0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D0[0x10];                                     // 0x02D0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TileSpawnPointSelector">();
	}
	static class UTileSpawnPointSelector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTileSpawnPointSelector>();
	}
};
static_assert(alignof(UTileSpawnPointSelector) == 0x000010, "Wrong alignment on UTileSpawnPointSelector");
static_assert(sizeof(UTileSpawnPointSelector) == 0x0002E0, "Wrong size on UTileSpawnPointSelector");
static_assert(offsetof(UTileSpawnPointSelector, _tileSpawnPoints) == 0x0002C0, "Member 'UTileSpawnPointSelector::_tileSpawnPoints' has a wrong offset!");

// Class DeadByDaylight.ToolBoxInterface
// 0x0000 (0x0030 - 0x0030)
class IToolBoxInterface final : public IInterface
{
public:
	class UChargerComponent* GetChargerComponent();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ToolBoxInterface">();
	}
	static class IToolBoxInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IToolBoxInterface>();
	}
};
static_assert(alignof(IToolBoxInterface) == 0x000008, "Wrong alignment on IToolBoxInterface");
static_assert(sizeof(IToolBoxInterface) == 0x000030, "Wrong size on IToolBoxInterface");

// Class DeadByDaylight.TotemOutlineUpdateStrategy
// 0x0038 (0x0180 - 0x0148)
class UTotemOutlineUpdateStrategy final : public USourceBasedOutlineUpdateStrategy
{
public:
	struct FLinearColor                           _revealedColorToSurvivor;                          // 0x0148(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           _boonTotemRevealedColorToSurvivor;                 // 0x0158(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveLinearColor*                      _revealedColorToKiller;                            // 0x0168(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           _blockedTotemColor;                                // 0x0170(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TotemOutlineUpdateStrategy">();
	}
	static class UTotemOutlineUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTotemOutlineUpdateStrategy>();
	}
};
static_assert(alignof(UTotemOutlineUpdateStrategy) == 0x000008, "Wrong alignment on UTotemOutlineUpdateStrategy");
static_assert(sizeof(UTotemOutlineUpdateStrategy) == 0x000180, "Wrong size on UTotemOutlineUpdateStrategy");
static_assert(offsetof(UTotemOutlineUpdateStrategy, _revealedColorToSurvivor) == 0x000148, "Member 'UTotemOutlineUpdateStrategy::_revealedColorToSurvivor' has a wrong offset!");
static_assert(offsetof(UTotemOutlineUpdateStrategy, _boonTotemRevealedColorToSurvivor) == 0x000158, "Member 'UTotemOutlineUpdateStrategy::_boonTotemRevealedColorToSurvivor' has a wrong offset!");
static_assert(offsetof(UTotemOutlineUpdateStrategy, _revealedColorToKiller) == 0x000168, "Member 'UTotemOutlineUpdateStrategy::_revealedColorToKiller' has a wrong offset!");
static_assert(offsetof(UTotemOutlineUpdateStrategy, _blockedTotemColor) == 0x000170, "Member 'UTotemOutlineUpdateStrategy::_blockedTotemColor' has a wrong offset!");

// Class DeadByDaylight.TrapChemicalBomb
// 0x0018 (0x02B8 - 0x02A0)
class ATrapChemicalBomb final : public AActor
{
public:
	ETrapBombState                                _currentState;                                     // 0x02A0(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A1[0x7];                                      // 0x02A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ADBDPlayer*                             _trapPlacer;                                       // 0x02A8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APallet*                                _placedPallet;                                     // 0x02B0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnRep_CurrentState();

	class APallet* GetPallet() const;
	ETrapBombState GetState() const;
	class ADBDPlayer* GetTrapPlacer() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TrapChemicalBomb">();
	}
	static class ATrapChemicalBomb* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATrapChemicalBomb>();
	}
};
static_assert(alignof(ATrapChemicalBomb) == 0x000008, "Wrong alignment on ATrapChemicalBomb");
static_assert(sizeof(ATrapChemicalBomb) == 0x0002B8, "Wrong size on ATrapChemicalBomb");
static_assert(offsetof(ATrapChemicalBomb, _currentState) == 0x0002A0, "Member 'ATrapChemicalBomb::_currentState' has a wrong offset!");
static_assert(offsetof(ATrapChemicalBomb, _trapPlacer) == 0x0002A8, "Member 'ATrapChemicalBomb::_trapPlacer' has a wrong offset!");
static_assert(offsetof(ATrapChemicalBomb, _placedPallet) == 0x0002B0, "Member 'ATrapChemicalBomb::_placedPallet' has a wrong offset!");

// Class DeadByDaylight.TrapIconStrategy
// 0x0000 (0x0038 - 0x0038)
class UTrapIconStrategy final : public UBasePerkIconStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TrapIconStrategy">();
	}
	static class UTrapIconStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTrapIconStrategy>();
	}
};
static_assert(alignof(UTrapIconStrategy) == 0x000008, "Wrong alignment on UTrapIconStrategy");
static_assert(sizeof(UTrapIconStrategy) == 0x000038, "Wrong size on UTrapIconStrategy");

// Class DeadByDaylight.TriggerableActivatorComponent
// 0x0048 (0x00F0 - 0x00A8)
class UTriggerableActivatorComponent final : public UActorComponent
{
public:
	TSoftClassPtr<class UClass>                   _triggerableClass;                                 // 0x00A8(0x0038)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UTriggerableWorldObjectComponent*> _triggerables;                                     // 0x00E0(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	void Authority_OnLevelReadyToPlay();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TriggerableActivatorComponent">();
	}
	static class UTriggerableActivatorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTriggerableActivatorComponent>();
	}
};
static_assert(alignof(UTriggerableActivatorComponent) == 0x000008, "Wrong alignment on UTriggerableActivatorComponent");
static_assert(sizeof(UTriggerableActivatorComponent) == 0x0000F0, "Wrong size on UTriggerableActivatorComponent");
static_assert(offsetof(UTriggerableActivatorComponent, _triggerableClass) == 0x0000A8, "Member 'UTriggerableActivatorComponent::_triggerableClass' has a wrong offset!");
static_assert(offsetof(UTriggerableActivatorComponent, _triggerables) == 0x0000E0, "Member 'UTriggerableActivatorComponent::_triggerables' has a wrong offset!");

// Class DeadByDaylight.TutorialFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class UTutorialFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class ATutorialGameMode* GetTutorialGameMode(class UObject* WorldContextObject);
	static class ATutorialGameState* GetTutorialGameState(class UObject* WorldContextObject);
	static class UTutorialHighlightController* GetTutorialHighlightController(class UObject* WorldContextObject);
	static class UTutorialNotificationController* GetTutorialNotificationController(class UObject* WorldContextObject);
	static class UTutorialObjectiveController* GetTutorialObjectiveController(class UObject* WorldContextObject);
	static bool IsInTutorial(const class UObject* WorldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TutorialFunctionLibrary">();
	}
	static class UTutorialFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTutorialFunctionLibrary>();
	}
};
static_assert(alignof(UTutorialFunctionLibrary) == 0x000008, "Wrong alignment on UTutorialFunctionLibrary");
static_assert(sizeof(UTutorialFunctionLibrary) == 0x000030, "Wrong size on UTutorialFunctionLibrary");

// Class DeadByDaylight.TutorialHighlightController
// 0x0018 (0x0048 - 0x0030)
class UTutorialHighlightController final : public UObject
{
public:
	uint8                                         Pad_30[0x18];                                      // 0x0030(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetHudComponentHighlight(EHudComponent HudComponent, bool Show);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TutorialHighlightController">();
	}
	static class UTutorialHighlightController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTutorialHighlightController>();
	}
};
static_assert(alignof(UTutorialHighlightController) == 0x000008, "Wrong alignment on UTutorialHighlightController");
static_assert(sizeof(UTutorialHighlightController) == 0x000048, "Wrong size on UTutorialHighlightController");

// Class DeadByDaylight.TutorialLevel
// 0x0040 (0x02E8 - 0x02A8)
class ATutorialLevel final : public ALevelScriptActor
{
public:
	bool                                          _tutorialStarted;                                  // 0x02A8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A9[0x3F];                                     // 0x02A9(0x003F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddObjective(class FName ObjectiveId);
	void CompleteObjective(class FName ObjectiveId);
	void DisplayBlockingNotification(class FName NotificationId);
	void DisplayNotification(class FName NotificationId, float Time);
	void HandleNotificationDismissed(class FName NotificationId);
	void HandleTutorialStepReached();
	void OnNotificationDismissed(class FName NotificationId);
	void OnTutorialStepUpdated(ETutorialStep TutorialStep);
	void RemoveObjective(class FName ObjectiveId);
	void SetHandledTutorialStep(ETutorialStep TutorialStep);
	void StartTutorial();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TutorialLevel">();
	}
	static class ATutorialLevel* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATutorialLevel>();
	}
};
static_assert(alignof(ATutorialLevel) == 0x000008, "Wrong alignment on ATutorialLevel");
static_assert(sizeof(ATutorialLevel) == 0x0002E8, "Wrong size on ATutorialLevel");
static_assert(offsetof(ATutorialLevel, _tutorialStarted) == 0x0002A8, "Member 'ATutorialLevel::_tutorialStarted' has a wrong offset!");

// Class DeadByDaylight.TutorialNotificationController
// 0x0080 (0x00B0 - 0x0030)
class UTutorialNotificationController final : public UObject
{
public:
	FMulticastInlineDelegateProperty_             OnBlockingNotificationDismissedEvent;              // 0x0030(0x0010)(ZeroConstructor, Transient, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x70];                                      // 0x0040(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HideNotification(bool RemoveAllCachedNotifs);
	void OnBlockingNotificationDismissed();
	void OnBlockingNotificationDismissedEvent__DelegateSignature(class FName TutorialNotificationId);
	void ShowBlockingNotification(class FName TutorialNotificationId);
	void ShowNotification(class FName TutorialNotificationId, float Duration);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TutorialNotificationController">();
	}
	static class UTutorialNotificationController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTutorialNotificationController>();
	}
};
static_assert(alignof(UTutorialNotificationController) == 0x000008, "Wrong alignment on UTutorialNotificationController");
static_assert(sizeof(UTutorialNotificationController) == 0x0000B0, "Wrong size on UTutorialNotificationController");
static_assert(offsetof(UTutorialNotificationController, OnBlockingNotificationDismissedEvent) == 0x000030, "Member 'UTutorialNotificationController::OnBlockingNotificationDismissedEvent' has a wrong offset!");

// Class DeadByDaylight.TutorialsUtilities
// 0x0038 (0x02D8 - 0x02A0)
class ATutorialsUtilities final : public AActor
{
public:
	FMulticastInlineDelegateProperty_             OnTutorialUIReady;                                 // 0x02A0(0x0010)(ZeroConstructor, Transient, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B0[0x28];                                     // 0x02B0(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void DestroyAI(class AAIController* AIController);
	static class ATutorialsUtilities* GetTutorialsUtilities(class UObject* WorldContextObject);

	void TriggerTutorialHudFadeIn();
	void TriggerTutorialHudFadeOut();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TutorialsUtilities">();
	}
	static class ATutorialsUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATutorialsUtilities>();
	}
};
static_assert(alignof(ATutorialsUtilities) == 0x000008, "Wrong alignment on ATutorialsUtilities");
static_assert(sizeof(ATutorialsUtilities) == 0x0002D8, "Wrong size on ATutorialsUtilities");
static_assert(offsetof(ATutorialsUtilities, OnTutorialUIReady) == 0x0002A0, "Member 'ATutorialsUtilities::OnTutorialUIReady' has a wrong offset!");

// Class DeadByDaylight.AnimationWidget
// 0x0008 (0x02B0 - 0x02A8)
class UAnimationWidget final : public UUserWidget
{
public:
	float                                         _playRate;                                         // 0x02A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2AC[0x4];                                      // 0x02AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetPlayRate(float Rate);

	float GetPlayRate() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimationWidget">();
	}
	static class UAnimationWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimationWidget>();
	}
};
static_assert(alignof(UAnimationWidget) == 0x000008, "Wrong alignment on UAnimationWidget");
static_assert(sizeof(UAnimationWidget) == 0x0002B0, "Wrong size on UAnimationWidget");
static_assert(offsetof(UAnimationWidget, _playRate) == 0x0002A8, "Member 'UAnimationWidget::_playRate' has a wrong offset!");

// Class DeadByDaylight.UMGGenericPopup
// 0x0098 (0x03E0 - 0x0348)
class UUMGGenericPopup final : public UMobileBaseUserWidget
{
public:
	class URichTextBlock*                         Title;                                             // 0x0348(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUMGHtmlRichText*                       Message;                                           // 0x0350(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 TitleBackground;                                   // 0x0358(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 TitleSmoke;                                        // 0x0360(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUMGPopupButton*                        RegressionPopupButton;                             // 0x0368(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUMGPopupButton*                        AlternativePopupButton;                            // 0x0370(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUMGPopupButton*                        ProgressionPopupButton;                            // 0x0378(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSlateColor                            ErrorTitleSmokeColor;                              // 0x0380(0x0014)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSlateColor                            ErrorTitleBackgroundColor;                         // 0x0394(0x0014)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSlateColor                            DefaultTitleSmokeColor;                            // 0x03A8(0x0014)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSlateColor                            DefaultTitleBackgroundColor;                       // 0x03BC(0x0014)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D0[0x10];                                     // 0x03D0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPopupAppearance();
	void OnPopupDisappearance();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGGenericPopup">();
	}
	static class UUMGGenericPopup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGGenericPopup>();
	}
};
static_assert(alignof(UUMGGenericPopup) == 0x000008, "Wrong alignment on UUMGGenericPopup");
static_assert(sizeof(UUMGGenericPopup) == 0x0003E0, "Wrong size on UUMGGenericPopup");
static_assert(offsetof(UUMGGenericPopup, Title) == 0x000348, "Member 'UUMGGenericPopup::Title' has a wrong offset!");
static_assert(offsetof(UUMGGenericPopup, Message) == 0x000350, "Member 'UUMGGenericPopup::Message' has a wrong offset!");
static_assert(offsetof(UUMGGenericPopup, TitleBackground) == 0x000358, "Member 'UUMGGenericPopup::TitleBackground' has a wrong offset!");
static_assert(offsetof(UUMGGenericPopup, TitleSmoke) == 0x000360, "Member 'UUMGGenericPopup::TitleSmoke' has a wrong offset!");
static_assert(offsetof(UUMGGenericPopup, RegressionPopupButton) == 0x000368, "Member 'UUMGGenericPopup::RegressionPopupButton' has a wrong offset!");
static_assert(offsetof(UUMGGenericPopup, AlternativePopupButton) == 0x000370, "Member 'UUMGGenericPopup::AlternativePopupButton' has a wrong offset!");
static_assert(offsetof(UUMGGenericPopup, ProgressionPopupButton) == 0x000378, "Member 'UUMGGenericPopup::ProgressionPopupButton' has a wrong offset!");
static_assert(offsetof(UUMGGenericPopup, ErrorTitleSmokeColor) == 0x000380, "Member 'UUMGGenericPopup::ErrorTitleSmokeColor' has a wrong offset!");
static_assert(offsetof(UUMGGenericPopup, ErrorTitleBackgroundColor) == 0x000394, "Member 'UUMGGenericPopup::ErrorTitleBackgroundColor' has a wrong offset!");
static_assert(offsetof(UUMGGenericPopup, DefaultTitleSmokeColor) == 0x0003A8, "Member 'UUMGGenericPopup::DefaultTitleSmokeColor' has a wrong offset!");
static_assert(offsetof(UUMGGenericPopup, DefaultTitleBackgroundColor) == 0x0003BC, "Member 'UUMGGenericPopup::DefaultTitleBackgroundColor' has a wrong offset!");

// Class DeadByDaylight.UMGHudEditorLayoutScreen
// 0x0010 (0x02B8 - 0x02A8)
class UUMGHudEditorLayoutScreen final : public UUserWidget
{
public:
	TArray<class UUMGDragWidget_HudEditor*>       _editableWidgets;                                  // 0x02A8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGHudEditorLayoutScreen">();
	}
	static class UUMGHudEditorLayoutScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGHudEditorLayoutScreen>();
	}
};
static_assert(alignof(UUMGHudEditorLayoutScreen) == 0x000008, "Wrong alignment on UUMGHudEditorLayoutScreen");
static_assert(sizeof(UUMGHudEditorLayoutScreen) == 0x0002B8, "Wrong size on UUMGHudEditorLayoutScreen");
static_assert(offsetof(UUMGHudEditorLayoutScreen, _editableWidgets) == 0x0002A8, "Member 'UUMGHudEditorLayoutScreen::_editableWidgets' has a wrong offset!");

// Class DeadByDaylight.UMGHudEditorVersionWidget
// 0x0028 (0x02D0 - 0x02A8)
class UUMGHudEditorVersionWidget final : public UUserWidget
{
public:
	class UButton*                                VersionButton;                                     // 0x02A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGDragWidget_HudEditor*               _onEditWidget;                                     // 0x02B0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B8[0x18];                                     // 0x02B8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Hide();
	void OnButtonClick();
	void Show();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGHudEditorVersionWidget">();
	}
	static class UUMGHudEditorVersionWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGHudEditorVersionWidget>();
	}
};
static_assert(alignof(UUMGHudEditorVersionWidget) == 0x000008, "Wrong alignment on UUMGHudEditorVersionWidget");
static_assert(sizeof(UUMGHudEditorVersionWidget) == 0x0002D0, "Wrong size on UUMGHudEditorVersionWidget");
static_assert(offsetof(UUMGHudEditorVersionWidget, VersionButton) == 0x0002A8, "Member 'UUMGHudEditorVersionWidget::VersionButton' has a wrong offset!");
static_assert(offsetof(UUMGHudEditorVersionWidget, _onEditWidget) == 0x0002B0, "Member 'UUMGHudEditorVersionWidget::_onEditWidget' has a wrong offset!");

// Class DeadByDaylight.UnbrokenPalletsRestrictedPlacementAreaStrategy
// 0x0020 (0x00C8 - 0x00A8)
class UUnbrokenPalletsRestrictedPlacementAreaStrategy final : public URestrictedPlacementAreaStrategy
{
public:
	TArray<class APallet*>                        _unbrokenPallets;                                  // 0x00A8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class FName                                   _palletCollisionBoxWhenDroppedTagName;             // 0x00B8(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C4[0x4];                                       // 0x00C4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnbrokenPalletsRestrictedPlacementAreaStrategy">();
	}
	static class UUnbrokenPalletsRestrictedPlacementAreaStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnbrokenPalletsRestrictedPlacementAreaStrategy>();
	}
};
static_assert(alignof(UUnbrokenPalletsRestrictedPlacementAreaStrategy) == 0x000008, "Wrong alignment on UUnbrokenPalletsRestrictedPlacementAreaStrategy");
static_assert(sizeof(UUnbrokenPalletsRestrictedPlacementAreaStrategy) == 0x0000C8, "Wrong size on UUnbrokenPalletsRestrictedPlacementAreaStrategy");
static_assert(offsetof(UUnbrokenPalletsRestrictedPlacementAreaStrategy, _unbrokenPallets) == 0x0000A8, "Member 'UUnbrokenPalletsRestrictedPlacementAreaStrategy::_unbrokenPallets' has a wrong offset!");
static_assert(offsetof(UUnbrokenPalletsRestrictedPlacementAreaStrategy, _palletCollisionBoxWhenDroppedTagName) == 0x0000B8, "Member 'UUnbrokenPalletsRestrictedPlacementAreaStrategy::_palletCollisionBoxWhenDroppedTagName' has a wrong offset!");

// Class DeadByDaylight.UnlockPersonalPerksPopupScreen
// 0x0000 (0x0148 - 0x0148)
class UUnlockPersonalPerksPopupScreen final : public UGenericPopupScreen
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnlockPersonalPerksPopupScreen">();
	}
	static class UUnlockPersonalPerksPopupScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnlockPersonalPerksPopupScreen>();
	}
};
static_assert(alignof(UUnlockPersonalPerksPopupScreen) == 0x000008, "Wrong alignment on UUnlockPersonalPerksPopupScreen");
static_assert(sizeof(UUnlockPersonalPerksPopupScreen) == 0x000148, "Wrong size on UUnlockPersonalPerksPopupScreen");

// Class DeadByDaylight.VaultableComponent
// 0x0020 (0x00C8 - 0x00A8)
class UVaultableComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnVault;                                           // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_B8[0x10];                                      // 0x00B8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnChaseEnded(class ADBDPlayer* Survivor, float ChaseTimer);
	void SignalVault(class ADBDPlayer* Survivor, float InteractionTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VaultableComponent">();
	}
	static class UVaultableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVaultableComponent>();
	}
};
static_assert(alignof(UVaultableComponent) == 0x000008, "Wrong alignment on UVaultableComponent");
static_assert(sizeof(UVaultableComponent) == 0x0000C8, "Wrong size on UVaultableComponent");
static_assert(offsetof(UVaultableComponent, OnVault) == 0x0000A8, "Member 'UVaultableComponent::OnVault' has a wrong offset!");

// Class DeadByDaylight.VisibleHatchRestrictedPlacementAreaStrategy
// 0x0008 (0x00B0 - 0x00A8)
class UVisibleHatchRestrictedPlacementAreaStrategy final : public URestrictedPlacementAreaStrategy
{
public:
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VisibleHatchRestrictedPlacementAreaStrategy">();
	}
	static class UVisibleHatchRestrictedPlacementAreaStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVisibleHatchRestrictedPlacementAreaStrategy>();
	}
};
static_assert(alignof(UVisibleHatchRestrictedPlacementAreaStrategy) == 0x000008, "Wrong alignment on UVisibleHatchRestrictedPlacementAreaStrategy");
static_assert(sizeof(UVisibleHatchRestrictedPlacementAreaStrategy) == 0x0000B0, "Wrong size on UVisibleHatchRestrictedPlacementAreaStrategy");

// Class DeadByDaylight.VisualFXOverrideInterface
// 0x0000 (0x0030 - 0x0030)
class IVisualFXOverrideInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VisualFXOverrideInterface">();
	}
	static class IVisualFXOverrideInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IVisualFXOverrideInterface>();
	}
};
static_assert(alignof(IVisualFXOverrideInterface) == 0x000008, "Wrong alignment on IVisualFXOverrideInterface");
static_assert(sizeof(IVisualFXOverrideInterface) == 0x000030, "Wrong size on IVisualFXOverrideInterface");

// Class DeadByDaylight.VisualFXOverrideUtilities
// 0x0000 (0x0030 - 0x0030)
class UVisualFXOverrideUtilities final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VisualFXOverrideUtilities">();
	}
	static class UVisualFXOverrideUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVisualFXOverrideUtilities>();
	}
};
static_assert(alignof(UVisualFXOverrideUtilities) == 0x000008, "Wrong alignment on UVisualFXOverrideUtilities");
static_assert(sizeof(UVisualFXOverrideUtilities) == 0x000030, "Wrong size on UVisualFXOverrideUtilities");

// Class DeadByDaylight.WakerObject
// 0x0028 (0x03D0 - 0x03A8)
class AWakerObject final : public AInteractable
{
public:
	uint8                                         Pad_3A8[0x8];                                      // 0x03A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UCamperDreamworldComponent*             _linkedCamperDreamworldComponent;                  // 0x03B0(0x0008)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsInteracting;                                     // 0x03B8(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _chargeComplete;                                   // 0x03B9(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3BA[0x16];                                     // 0x03BA(0x0016)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BindToCamperDreamStateChanged(class ADBDPlayer* Player);
	void LinkCampersOnLevelReadyToPlay();
	void OnAnyCamperDreamStateChanged(bool IsInDreamworld, bool LocallyObservedChanged);
	void OnLinkedCamperDreamStateChanged(bool IsInDreamworld, bool LocallyObservedChanged);
	void OnNewLinkedCamper(class UCamperDreamworldComponent* DreamworldComponent);
	void OnRep_LinkedCamperChanged(class UCamperDreamworldComponent* Previous);
	void SetChargeComplete(bool Complete);
	void UpdateVisibilityAndOutline();

	bool CanWakeUpCamper(const class ADBDPlayer* Camper) const;
	bool GetChargeComplete() const;
	float GetInteractionPercentComplete() const;
	class UPrimitiveComponent* GetInteractorPrimitiveComponent() const;
	bool GetIsInteracting() const;
	class USkeletalMeshComponent* GetMesh() const;
	bool HasLinkedCamper() const;
	bool IsLinkedToCamper(const class ADBDPlayer* Camper) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WakerObject">();
	}
	static class AWakerObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWakerObject>();
	}
};
static_assert(alignof(AWakerObject) == 0x000008, "Wrong alignment on AWakerObject");
static_assert(sizeof(AWakerObject) == 0x0003D0, "Wrong size on AWakerObject");
static_assert(offsetof(AWakerObject, _linkedCamperDreamworldComponent) == 0x0003B0, "Member 'AWakerObject::_linkedCamperDreamworldComponent' has a wrong offset!");
static_assert(offsetof(AWakerObject, IsInteracting) == 0x0003B8, "Member 'AWakerObject::IsInteracting' has a wrong offset!");
static_assert(offsetof(AWakerObject, _chargeComplete) == 0x0003B9, "Member 'AWakerObject::_chargeComplete' has a wrong offset!");

// Class DeadByDaylight.WalesCypherParameters
// 0x0018 (0x0050 - 0x0038)
class UWalesCypherParameters final : public UDataAsset
{
public:
	class FString                                 AUDIO_EVENT;                                       // 0x0038(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SLASHER_INDEX;                                     // 0x0048(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CAMPER_INDEX;                                      // 0x004C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WalesCypherParameters">();
	}
	static class UWalesCypherParameters* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWalesCypherParameters>();
	}
};
static_assert(alignof(UWalesCypherParameters) == 0x000008, "Wrong alignment on UWalesCypherParameters");
static_assert(sizeof(UWalesCypherParameters) == 0x000050, "Wrong size on UWalesCypherParameters");
static_assert(offsetof(UWalesCypherParameters, AUDIO_EVENT) == 0x000038, "Member 'UWalesCypherParameters::AUDIO_EVENT' has a wrong offset!");
static_assert(offsetof(UWalesCypherParameters, SLASHER_INDEX) == 0x000048, "Member 'UWalesCypherParameters::SLASHER_INDEX' has a wrong offset!");
static_assert(offsetof(UWalesCypherParameters, CAMPER_INDEX) == 0x00004C, "Member 'UWalesCypherParameters::CAMPER_INDEX' has a wrong offset!");

// Class DeadByDaylight.WalletHandler
// 0x0140 (0x0170 - 0x0030)
class UWalletHandler final : public UObject
{
public:
	uint8                                         Pad_30[0x140];                                     // 0x0030(0x0140)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WalletHandler">();
	}
	static class UWalletHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWalletHandler>();
	}
};
static_assert(alignof(UWalletHandler) == 0x000008, "Wrong alignment on UWalletHandler");
static_assert(sizeof(UWalletHandler) == 0x000170, "Wrong size on UWalletHandler");

// Class DeadByDaylight.WCSRComponent
// 0x0018 (0x0140 - 0x0128)
class UWCSRComponent : public UDBDSRComponent
{
public:
	class UAkAudioEvent*                          _breakSoundEvent;                                  // 0x0128(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FCharacterDropdown>             _eligibleCharacters;                               // 0x0130(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	void Client_PlayBreakSound();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WCSRComponent">();
	}
	static class UWCSRComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWCSRComponent>();
	}
};
static_assert(alignof(UWCSRComponent) == 0x000008, "Wrong alignment on UWCSRComponent");
static_assert(sizeof(UWCSRComponent) == 0x000140, "Wrong size on UWCSRComponent");
static_assert(offsetof(UWCSRComponent, _breakSoundEvent) == 0x000128, "Member 'UWCSRComponent::_breakSoundEvent' has a wrong offset!");
static_assert(offsetof(UWCSRComponent, _eligibleCharacters) == 0x000130, "Member 'UWCSRComponent::_eligibleCharacters' has a wrong offset!");

// Class DeadByDaylight.WeightBasedSearchableItemStrategy
// 0x0010 (0x0048 - 0x0038)
class UWeightBasedSearchableItemStrategy final : public USearchableItemStrategy
{
public:
	TArray<struct FWeightBasedItemData>           _weightBasedItems;                                 // 0x0038(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeightBasedSearchableItemStrategy">();
	}
	static class UWeightBasedSearchableItemStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeightBasedSearchableItemStrategy>();
	}
};
static_assert(alignof(UWeightBasedSearchableItemStrategy) == 0x000008, "Wrong alignment on UWeightBasedSearchableItemStrategy");
static_assert(sizeof(UWeightBasedSearchableItemStrategy) == 0x000048, "Wrong size on UWeightBasedSearchableItemStrategy");
static_assert(offsetof(UWeightBasedSearchableItemStrategy, _weightBasedItems) == 0x000038, "Member 'UWeightBasedSearchableItemStrategy::_weightBasedItems' has a wrong offset!");

// Class DeadByDaylight.WeightedElement
// 0x0000 (0x0030 - 0x0030)
class IWeightedElement final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeightedElement">();
	}
	static class IWeightedElement* GetDefaultObj()
	{
		return GetDefaultObjImpl<IWeightedElement>();
	}
};
static_assert(alignof(IWeightedElement) == 0x000008, "Wrong alignment on IWeightedElement");
static_assert(sizeof(IWeightedElement) == 0x000030, "Wrong size on IWeightedElement");

// Class DeadByDaylight.Window
// 0x00A8 (0x0450 - 0x03A8)
class AWindow : public AInteractable
{
public:
	class UBoxComponent*                          _windowCollider;                                   // 0x03A8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          _collisionBox1;                                    // 0x03B0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          _collisionBox2;                                    // 0x03B8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          _interactionZone1;                                 // 0x03C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          _interactionZone2;                                 // 0x03C8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isBlockedByLevel;                                 // 0x03D0(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3D1[0x7];                                      // 0x03D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class ACamperPlayer*, struct FVaultData> _survivorVaultData;                                // 0x03D8(0x0050)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_428[0x8];                                      // 0x0428(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBlockableComponent*                    _blockableComponent;                               // 0x0430(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_438[0x10];                                     // 0x0438(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UDBDNavEvadeLoopComponent*              _navEvadeLoopComponent;                            // 0x0448(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Authority_OnVaultInternal(class ADBDPlayer* Player, bool CanBlockVault);
	void Authority_SetBlockedByLevel(bool IsBlockedByLevel);
	void NotifyOnFastVault(class ADBDPlayer* Player, class UInteractionDefinition* Interaction);
	void OnFastVault(class ADBDPlayer* Player, class UInteractionDefinition* Interaction);
	void OnRep_blockedByLevel();

	bool IsWindowVaultBlockedFor(const class ADBDPlayer* Player) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Window">();
	}
	static class AWindow* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWindow>();
	}
};
static_assert(alignof(AWindow) == 0x000008, "Wrong alignment on AWindow");
static_assert(sizeof(AWindow) == 0x000450, "Wrong size on AWindow");
static_assert(offsetof(AWindow, _windowCollider) == 0x0003A8, "Member 'AWindow::_windowCollider' has a wrong offset!");
static_assert(offsetof(AWindow, _collisionBox1) == 0x0003B0, "Member 'AWindow::_collisionBox1' has a wrong offset!");
static_assert(offsetof(AWindow, _collisionBox2) == 0x0003B8, "Member 'AWindow::_collisionBox2' has a wrong offset!");
static_assert(offsetof(AWindow, _interactionZone1) == 0x0003C0, "Member 'AWindow::_interactionZone1' has a wrong offset!");
static_assert(offsetof(AWindow, _interactionZone2) == 0x0003C8, "Member 'AWindow::_interactionZone2' has a wrong offset!");
static_assert(offsetof(AWindow, _isBlockedByLevel) == 0x0003D0, "Member 'AWindow::_isBlockedByLevel' has a wrong offset!");
static_assert(offsetof(AWindow, _survivorVaultData) == 0x0003D8, "Member 'AWindow::_survivorVaultData' has a wrong offset!");
static_assert(offsetof(AWindow, _blockableComponent) == 0x000430, "Member 'AWindow::_blockableComponent' has a wrong offset!");
static_assert(offsetof(AWindow, _navEvadeLoopComponent) == 0x000448, "Member 'AWindow::_navEvadeLoopComponent' has a wrong offset!");

// Class DeadByDaylight.XboxProfileDAL
// 0x0000 (0x0088 - 0x0088)
class UXboxProfileDAL final : public UPlayerProfileDAL
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"XboxProfileDAL">();
	}
	static class UXboxProfileDAL* GetDefaultObj()
	{
		return GetDefaultObjImpl<UXboxProfileDAL>();
	}
};
static_assert(alignof(UXboxProfileDAL) == 0x000008, "Wrong alignment on UXboxProfileDAL");
static_assert(sizeof(UXboxProfileDAL) == 0x000088, "Wrong size on UXboxProfileDAL");

// Class DeadByDaylight.ZoneDetectorComponent
// 0x0038 (0x00E0 - 0x00A8)
class UZoneDetectorComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x18];                                      // 0x00A8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UPrimitiveComponent*>            _zones;                                            // 0x00C0(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class FName>                           _tags;                                             // 0x00D0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	void OnOverlapEnter(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnOverlapExit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ZoneDetectorComponent">();
	}
	static class UZoneDetectorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UZoneDetectorComponent>();
	}
};
static_assert(alignof(UZoneDetectorComponent) == 0x000008, "Wrong alignment on UZoneDetectorComponent");
static_assert(sizeof(UZoneDetectorComponent) == 0x0000E0, "Wrong size on UZoneDetectorComponent");
static_assert(offsetof(UZoneDetectorComponent, _zones) == 0x0000C0, "Member 'UZoneDetectorComponent::_zones' has a wrong offset!");
static_assert(offsetof(UZoneDetectorComponent, _tags) == 0x0000D0, "Member 'UZoneDetectorComponent::_tags' has a wrong offset!");

}

