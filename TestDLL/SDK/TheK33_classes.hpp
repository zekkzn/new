#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: TheK33

#include "Basic.hpp"

#include "DBDInteraction_classes.hpp"
#include "DBDSharedTypes_structs.hpp"
#include "DBDGameplay_classes.hpp"
#include "TheK33_structs.hpp"
#include "NavigationSystem_classes.hpp"
#include "DBDCompetence_classes.hpp"
#include "AnimationUtilities_structs.hpp"
#include "DeadByDaylight_classes.hpp"
#include "DBDAnimation_classes.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "DataTableUtilities_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "StatSystem_structs.hpp"
#include "GameplayTagUtilities_structs.hpp"
#include "DBDCosmetic_classes.hpp"
#include "DBDAttack_classes.hpp"
#include "GameplayUtilities_classes.hpp"
#include "QueryService_structs.hpp"
#include "GameplayTags_structs.hpp"


namespace SDK
{

// Class TheK33.CollectFatherKeyCardInteraction
// 0x0000 (0x07B0 - 0x07B0)
class UCollectFatherKeyCardInteraction final : public UCollectItemInteraction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CollectFatherKeyCardInteraction">();
	}
	static class UCollectFatherKeyCardInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCollectFatherKeyCardInteraction>();
	}
};
static_assert(alignof(UCollectFatherKeyCardInteraction) == 0x000010, "Wrong alignment on UCollectFatherKeyCardInteraction");
static_assert(sizeof(UCollectFatherKeyCardInteraction) == 0x0007B0, "Wrong size on UCollectFatherKeyCardInteraction");

// Class TheK33.FatherTerminalHackingInteraction
// 0x00D0 (0x0850 - 0x0780)
class UFatherTerminalHackingInteraction final : public UInteractionDefinition
{
public:
	FMulticastInlineDelegateProperty_             Cosmetic_OnCooldownTimerStartOrDoneEvent;          // 0x0778(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             Cosmetic_OnInteractionStarted;                     // 0x0788(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             Cosmetic_OnSuccessfullyEndMiniGameAnimationStarted; // 0x0798(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FDirectionalMiniGameDefinition         _miniGameDefinition;                               // 0x07A8(0x0020)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         _cooldownDurationSeconds;                          // 0x07C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7CC[0x14];                                     // 0x07CC(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _isHackingCompleted;                               // 0x07E0(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isCooldownTimerRunning;                           // 0x07E1(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _useSuccessfullyEndMiniGameExit;                   // 0x07E2(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7E3[0x5];                                      // 0x07E3(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAnimationMontageDescriptor            _successfullyEndMiniGameAnimationMontageDescriptor; // 0x07E8(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_808[0x48];                                     // 0x0808(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnCooldownTimerDone();
	void Authority_OnMinigameEnd(class ACamperPlayer* Survivor, EDirectionalMinigameResult Result);
	void OnRep_IsCooldownTimerRunning();
	void OnWormholeTerminalHackingCooldownTimerStartOrDone__DelegateSignature(bool IsRunning);
	void OnWormholeTerminalHackingInteractionStarted__DelegateSignature();
	void OnWormholeTerminalSuccessfullyEndMiniGameAnimationStarted__DelegateSignature();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FatherTerminalHackingInteraction">();
	}
	static class UFatherTerminalHackingInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFatherTerminalHackingInteraction>();
	}
};
static_assert(alignof(UFatherTerminalHackingInteraction) == 0x000010, "Wrong alignment on UFatherTerminalHackingInteraction");
static_assert(sizeof(UFatherTerminalHackingInteraction) == 0x000850, "Wrong size on UFatherTerminalHackingInteraction");
static_assert(offsetof(UFatherTerminalHackingInteraction, Cosmetic_OnCooldownTimerStartOrDoneEvent) == 0x000778, "Member 'UFatherTerminalHackingInteraction::Cosmetic_OnCooldownTimerStartOrDoneEvent' has a wrong offset!");
static_assert(offsetof(UFatherTerminalHackingInteraction, Cosmetic_OnInteractionStarted) == 0x000788, "Member 'UFatherTerminalHackingInteraction::Cosmetic_OnInteractionStarted' has a wrong offset!");
static_assert(offsetof(UFatherTerminalHackingInteraction, Cosmetic_OnSuccessfullyEndMiniGameAnimationStarted) == 0x000798, "Member 'UFatherTerminalHackingInteraction::Cosmetic_OnSuccessfullyEndMiniGameAnimationStarted' has a wrong offset!");
static_assert(offsetof(UFatherTerminalHackingInteraction, _miniGameDefinition) == 0x0007A8, "Member 'UFatherTerminalHackingInteraction::_miniGameDefinition' has a wrong offset!");
static_assert(offsetof(UFatherTerminalHackingInteraction, _cooldownDurationSeconds) == 0x0007C8, "Member 'UFatherTerminalHackingInteraction::_cooldownDurationSeconds' has a wrong offset!");
static_assert(offsetof(UFatherTerminalHackingInteraction, _isHackingCompleted) == 0x0007E0, "Member 'UFatherTerminalHackingInteraction::_isHackingCompleted' has a wrong offset!");
static_assert(offsetof(UFatherTerminalHackingInteraction, _isCooldownTimerRunning) == 0x0007E1, "Member 'UFatherTerminalHackingInteraction::_isCooldownTimerRunning' has a wrong offset!");
static_assert(offsetof(UFatherTerminalHackingInteraction, _useSuccessfullyEndMiniGameExit) == 0x0007E2, "Member 'UFatherTerminalHackingInteraction::_useSuccessfullyEndMiniGameExit' has a wrong offset!");
static_assert(offsetof(UFatherTerminalHackingInteraction, _successfullyEndMiniGameAnimationMontageDescriptor) == 0x0007E8, "Member 'UFatherTerminalHackingInteraction::_successfullyEndMiniGameAnimationMontageDescriptor' has a wrong offset!");

// Class TheK33.K33TunnelBlockCosmeticActorSpawner
// 0x0170 (0x0430 - 0x02C0)
class UK33TunnelBlockCosmeticActorSpawner final : public USceneComponent
{
public:
	uint8                                         Pad_2C0[0xE8];                                     // 0x02C0(0x00E8)(Fixing Size After Last Property [ Dumper-7 ])
	struct FK33CosmeticTunnelBlockSpawnInfo       _cosmeticBlockSpawnInfo;                           // 0x03A8(0x0048)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TSoftClassPtr<class UClass>                   _selectedTunnelBlockCosmeticClass;                 // 0x03F0(0x0038)(Transient, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         _editorVariationIndex;                             // 0x0428(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_42C[0x4];                                      // 0x042C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K33TunnelBlockCosmeticActorSpawner">();
	}
	static class UK33TunnelBlockCosmeticActorSpawner* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK33TunnelBlockCosmeticActorSpawner>();
	}
};
static_assert(alignof(UK33TunnelBlockCosmeticActorSpawner) == 0x000010, "Wrong alignment on UK33TunnelBlockCosmeticActorSpawner");
static_assert(sizeof(UK33TunnelBlockCosmeticActorSpawner) == 0x000430, "Wrong size on UK33TunnelBlockCosmeticActorSpawner");
static_assert(offsetof(UK33TunnelBlockCosmeticActorSpawner, _cosmeticBlockSpawnInfo) == 0x0003A8, "Member 'UK33TunnelBlockCosmeticActorSpawner::_cosmeticBlockSpawnInfo' has a wrong offset!");
static_assert(offsetof(UK33TunnelBlockCosmeticActorSpawner, _selectedTunnelBlockCosmeticClass) == 0x0003F0, "Member 'UK33TunnelBlockCosmeticActorSpawner::_selectedTunnelBlockCosmeticClass' has a wrong offset!");
static_assert(offsetof(UK33TunnelBlockCosmeticActorSpawner, _editorVariationIndex) == 0x000428, "Member 'UK33TunnelBlockCosmeticActorSpawner::_editorVariationIndex' has a wrong offset!");

// Class TheK33.IsInRangeOfK33ControlStation
// 0x0000 (0x00F8 - 0x00F8)
class UIsInRangeOfK33ControlStation final : public UAnyActorPairQueryRangeIsTrue
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IsInRangeOfK33ControlStation">();
	}
	static class UIsInRangeOfK33ControlStation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIsInRangeOfK33ControlStation>();
	}
};
static_assert(alignof(UIsInRangeOfK33ControlStation) == 0x000008, "Wrong alignment on UIsInRangeOfK33ControlStation");
static_assert(sizeof(UIsInRangeOfK33ControlStation) == 0x0000F8, "Wrong size on UIsInRangeOfK33ControlStation");

// Class TheK33.K33TunnelPulse
// 0x0098 (0x0338 - 0x02A0)
class AK33TunnelPulse final : public AActor
{
public:
	uint8                                         Pad_2A0[0x8];                                      // 0x02A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _lastPulseForwardOffset;                           // 0x02A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _lastPulseUpOffset;                                // 0x02AC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _sideOffsetCurveMultiplier;                        // 0x02B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _firstTunnelBlockSideOffsetCurveMultiplier;        // 0x02B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _lastTunnelBlockSideOffsetCurveMultiplier;         // 0x02C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _sideOffsetSize;                                   // 0x02C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2CC[0x6C];                                     // 0x02CC(0x006C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_ActivatePulse(int32 IdInPulseWave);
	void Cosmetic_DeactivatePulse();

	float Cosmetic_GetFadeOutPercentage() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K33TunnelPulse">();
	}
	static class AK33TunnelPulse* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK33TunnelPulse>();
	}
};
static_assert(alignof(AK33TunnelPulse) == 0x000008, "Wrong alignment on AK33TunnelPulse");
static_assert(sizeof(AK33TunnelPulse) == 0x000338, "Wrong size on AK33TunnelPulse");
static_assert(offsetof(AK33TunnelPulse, _lastPulseForwardOffset) == 0x0002A8, "Member 'AK33TunnelPulse::_lastPulseForwardOffset' has a wrong offset!");
static_assert(offsetof(AK33TunnelPulse, _lastPulseUpOffset) == 0x0002AC, "Member 'AK33TunnelPulse::_lastPulseUpOffset' has a wrong offset!");
static_assert(offsetof(AK33TunnelPulse, _sideOffsetCurveMultiplier) == 0x0002B0, "Member 'AK33TunnelPulse::_sideOffsetCurveMultiplier' has a wrong offset!");
static_assert(offsetof(AK33TunnelPulse, _firstTunnelBlockSideOffsetCurveMultiplier) == 0x0002B8, "Member 'AK33TunnelPulse::_firstTunnelBlockSideOffsetCurveMultiplier' has a wrong offset!");
static_assert(offsetof(AK33TunnelPulse, _lastTunnelBlockSideOffsetCurveMultiplier) == 0x0002C0, "Member 'AK33TunnelPulse::_lastTunnelBlockSideOffsetCurveMultiplier' has a wrong offset!");
static_assert(offsetof(AK33TunnelPulse, _sideOffsetSize) == 0x0002C8, "Member 'AK33TunnelPulse::_sideOffsetSize' has a wrong offset!");

// Class TheK33.K33AnimInstance
// 0x0010 (0x0730 - 0x0720)
class UK33AnimInstance final : public UKillerAnimInstance
{
public:
	bool                                          _isQuadruped;                                      // 0x0720(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isInSpecialMode;                                  // 0x0721(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isTailAttacking;                                  // 0x0722(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isTailAttackCharging;                             // 0x0723(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isInTunnel;                                       // 0x0724(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _useQuadrupedIK;                                   // 0x0725(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _useBipedIK;                                       // 0x0726(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _useLookAt;                                        // 0x0727(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _usePushBack;                                      // 0x0728(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isBeingHitByTurret;                               // 0x0729(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _pushBackQuadrupedActive;                          // 0x072A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _pushBackBipedActive;                              // 0x072B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_72C[0x4];                                      // 0x072C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K33AnimInstance">();
	}
	static class UK33AnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK33AnimInstance>();
	}
};
static_assert(alignof(UK33AnimInstance) == 0x000010, "Wrong alignment on UK33AnimInstance");
static_assert(sizeof(UK33AnimInstance) == 0x000730, "Wrong size on UK33AnimInstance");
static_assert(offsetof(UK33AnimInstance, _isQuadruped) == 0x000720, "Member 'UK33AnimInstance::_isQuadruped' has a wrong offset!");
static_assert(offsetof(UK33AnimInstance, _isInSpecialMode) == 0x000721, "Member 'UK33AnimInstance::_isInSpecialMode' has a wrong offset!");
static_assert(offsetof(UK33AnimInstance, _isTailAttacking) == 0x000722, "Member 'UK33AnimInstance::_isTailAttacking' has a wrong offset!");
static_assert(offsetof(UK33AnimInstance, _isTailAttackCharging) == 0x000723, "Member 'UK33AnimInstance::_isTailAttackCharging' has a wrong offset!");
static_assert(offsetof(UK33AnimInstance, _isInTunnel) == 0x000724, "Member 'UK33AnimInstance::_isInTunnel' has a wrong offset!");
static_assert(offsetof(UK33AnimInstance, _useQuadrupedIK) == 0x000725, "Member 'UK33AnimInstance::_useQuadrupedIK' has a wrong offset!");
static_assert(offsetof(UK33AnimInstance, _useBipedIK) == 0x000726, "Member 'UK33AnimInstance::_useBipedIK' has a wrong offset!");
static_assert(offsetof(UK33AnimInstance, _useLookAt) == 0x000727, "Member 'UK33AnimInstance::_useLookAt' has a wrong offset!");
static_assert(offsetof(UK33AnimInstance, _usePushBack) == 0x000728, "Member 'UK33AnimInstance::_usePushBack' has a wrong offset!");
static_assert(offsetof(UK33AnimInstance, _isBeingHitByTurret) == 0x000729, "Member 'UK33AnimInstance::_isBeingHitByTurret' has a wrong offset!");
static_assert(offsetof(UK33AnimInstance, _pushBackQuadrupedActive) == 0x00072A, "Member 'UK33AnimInstance::_pushBackQuadrupedActive' has a wrong offset!");
static_assert(offsetof(UK33AnimInstance, _pushBackBipedActive) == 0x00072B, "Member 'UK33AnimInstance::_pushBackBipedActive' has a wrong offset!");

// Class TheK33.K33CheatComponent
// 0x0000 (0x00A8 - 0x00A8)
class UK33CheatComponent final : public UActorComponent
{
public:
	void DBD_K33DrawTunnelBlockConnections(float SecondsToDisplay);
	void DBD_K33ForceSpecialMode(uint8 Force);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K33CheatComponent">();
	}
	static class UK33CheatComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK33CheatComponent>();
	}
};
static_assert(alignof(UK33CheatComponent) == 0x000008, "Wrong alignment on UK33CheatComponent");
static_assert(sizeof(UK33CheatComponent) == 0x0000A8, "Wrong size on UK33CheatComponent");

// Class TheK33.K33TailAttackInteraction
// 0x00B0 (0x0970 - 0x08C0)
class UK33TailAttackInteraction final : public UChargeableInteractionDefinition
{
public:
	struct FDBDTunableRowHandle                   _interactionViewPitchMax;                          // 0x08C0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _interactionViewPitchMin;                          // 0x08E8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _cancelAttackMovementSlowdownDuration;             // 0x0910(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _cancelAttackMovementSlowdownCurve;                // 0x0938(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_940[0x30];                                     // 0x0940(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K33TailAttackInteraction">();
	}
	static class UK33TailAttackInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK33TailAttackInteraction>();
	}
};
static_assert(alignof(UK33TailAttackInteraction) == 0x000010, "Wrong alignment on UK33TailAttackInteraction");
static_assert(sizeof(UK33TailAttackInteraction) == 0x000970, "Wrong size on UK33TailAttackInteraction");
static_assert(offsetof(UK33TailAttackInteraction, _interactionViewPitchMax) == 0x0008C0, "Member 'UK33TailAttackInteraction::_interactionViewPitchMax' has a wrong offset!");
static_assert(offsetof(UK33TailAttackInteraction, _interactionViewPitchMin) == 0x0008E8, "Member 'UK33TailAttackInteraction::_interactionViewPitchMin' has a wrong offset!");
static_assert(offsetof(UK33TailAttackInteraction, _cancelAttackMovementSlowdownDuration) == 0x000910, "Member 'UK33TailAttackInteraction::_cancelAttackMovementSlowdownDuration' has a wrong offset!");
static_assert(offsetof(UK33TailAttackInteraction, _cancelAttackMovementSlowdownCurve) == 0x000938, "Member 'UK33TailAttackInteraction::_cancelAttackMovementSlowdownCurve' has a wrong offset!");

// Class TheK33.K33CollectTurretFromControlStationInteraction
// 0x0070 (0x0990 - 0x0920)
class UK33CollectTurretFromControlStationInteraction final : public UBasicChargeableInteraction
{
public:
	uint8                                         Pad_920[0x50];                                     // 0x0920(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAnimationMontageDescriptor            _cancelMontage;                                    // 0x0970(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K33CollectTurretFromControlStationInteraction">();
	}
	static class UK33CollectTurretFromControlStationInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK33CollectTurretFromControlStationInteraction>();
	}
};
static_assert(alignof(UK33CollectTurretFromControlStationInteraction) == 0x000010, "Wrong alignment on UK33CollectTurretFromControlStationInteraction");
static_assert(sizeof(UK33CollectTurretFromControlStationInteraction) == 0x000990, "Wrong size on UK33CollectTurretFromControlStationInteraction");
static_assert(offsetof(UK33CollectTurretFromControlStationInteraction, _cancelMontage) == 0x000970, "Member 'UK33CollectTurretFromControlStationInteraction::_cancelMontage' has a wrong offset!");

// Class TheK33.K33ControlStation
// 0x0230 (0x05D8 - 0x03A8)
class AK33ControlStation final : public AInteractable
{
public:
	class UDBDSkeletalMeshComponentBudgeted*      _skeletalMeshComponent_TunnelEntranceSection;      // 0x03A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDBDSkeletalMeshComponentBudgeted*      _skeletalMeshComponent_turretSpawnerSection;       // 0x03B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UK33ControlStationTurretSpawnerOutlineUpdateStrategy* _outlineStrategy_TurretSpawnerSection;             // 0x03B8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UK33ControlStationTunnelEntranceOutlineUpdateStrategy* _outlineStrategy_TunnelEntranceSection;            // 0x03C0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDBDOutlineComponent*                   _outlineComponent_tunnelEntranceSection;           // 0x03C8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDBDOutlineComponent*                   _outlineComponent_turretSpawnerSection;            // 0x03D0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBoxComponent*                          _interactionCollisionZone;                         // 0x03D8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInteractor*                            _interactor;                                       // 0x03E0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AK33TunnelBlock*                        _linkedTunnelBlock;                                // 0x03E8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftClassPtr<class UClass>                   _exitTunnelInteractableClass;                      // 0x03F0(0x0038)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AK33ExitTunnelInteractable*             _exitTunnelInteractable;                           // 0x0428(0x0008)(Net, ZeroConstructor, Transient, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMontagePlayer*                         _montagePlayer_turretSpawnerSection;               // 0x0430(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMontagePlayer*                         _montagePlayer_tunnelEntranceSection;              // 0x0438(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimationMontageSlave*                 _animationSlave_turretSpawnerSection;              // 0x0440(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimationMontageSlave*                 _animationSlave_tunnelEntranceSection;             // 0x0448(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class AK33Turret>              _linkedTurret;                                     // 0x0450(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EControlStationState                          _currentState;                                     // 0x0458(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_459[0x3];                                      // 0x0459(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   _turretSocketName;                                 // 0x045C(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_468[0x30];                                     // 0x0468(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _spawningDuration;                                 // 0x0498(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _turretAvailabilityCooldownDuration;               // 0x04C0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4E8[0x30];                                     // 0x04E8(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _worldTimeAtCooldownStart;                         // 0x0518(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _malfunctionDuration;                              // 0x051C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_520[0x28];                                     // 0x0520(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _blockExitTime;                                    // 0x0548(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_570[0x60];                                     // 0x0570(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _isMalfunctioning;                                 // 0x05D0(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5D1[0x7];                                      // 0x05D1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_OnControlStationEnteringState(EControlStationState EnteringState);
	void Cosmetic_OnControlStationExitingState(EControlStationState ExitingState);
	void Cosmetic_OnTurretInPoolCountChanged(const int32 TurretCount);
	void Cosmetic_SetTunnelCapVisibility(bool IsVisible);
	void Cosmetic_StartControlStationMalfunctionReaction();
	void Cosmetic_StopControlStationMalfunctionReaction();
	void Cosmetic_UpdateControlStationCooldown(float CooldownElapsedTimePercent);
	void OnRep_CurrentState(EControlStationState OldState);
	void OnRep_ExitTunnelInteractable();
	void OnRep_IsMalfunctioning();

	struct FVector GetKillerExitTunnelEndLocation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K33ControlStation">();
	}
	static class AK33ControlStation* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK33ControlStation>();
	}
};
static_assert(alignof(AK33ControlStation) == 0x000008, "Wrong alignment on AK33ControlStation");
static_assert(sizeof(AK33ControlStation) == 0x0005D8, "Wrong size on AK33ControlStation");
static_assert(offsetof(AK33ControlStation, _skeletalMeshComponent_TunnelEntranceSection) == 0x0003A8, "Member 'AK33ControlStation::_skeletalMeshComponent_TunnelEntranceSection' has a wrong offset!");
static_assert(offsetof(AK33ControlStation, _skeletalMeshComponent_turretSpawnerSection) == 0x0003B0, "Member 'AK33ControlStation::_skeletalMeshComponent_turretSpawnerSection' has a wrong offset!");
static_assert(offsetof(AK33ControlStation, _outlineStrategy_TurretSpawnerSection) == 0x0003B8, "Member 'AK33ControlStation::_outlineStrategy_TurretSpawnerSection' has a wrong offset!");
static_assert(offsetof(AK33ControlStation, _outlineStrategy_TunnelEntranceSection) == 0x0003C0, "Member 'AK33ControlStation::_outlineStrategy_TunnelEntranceSection' has a wrong offset!");
static_assert(offsetof(AK33ControlStation, _outlineComponent_tunnelEntranceSection) == 0x0003C8, "Member 'AK33ControlStation::_outlineComponent_tunnelEntranceSection' has a wrong offset!");
static_assert(offsetof(AK33ControlStation, _outlineComponent_turretSpawnerSection) == 0x0003D0, "Member 'AK33ControlStation::_outlineComponent_turretSpawnerSection' has a wrong offset!");
static_assert(offsetof(AK33ControlStation, _interactionCollisionZone) == 0x0003D8, "Member 'AK33ControlStation::_interactionCollisionZone' has a wrong offset!");
static_assert(offsetof(AK33ControlStation, _interactor) == 0x0003E0, "Member 'AK33ControlStation::_interactor' has a wrong offset!");
static_assert(offsetof(AK33ControlStation, _linkedTunnelBlock) == 0x0003E8, "Member 'AK33ControlStation::_linkedTunnelBlock' has a wrong offset!");
static_assert(offsetof(AK33ControlStation, _exitTunnelInteractableClass) == 0x0003F0, "Member 'AK33ControlStation::_exitTunnelInteractableClass' has a wrong offset!");
static_assert(offsetof(AK33ControlStation, _exitTunnelInteractable) == 0x000428, "Member 'AK33ControlStation::_exitTunnelInteractable' has a wrong offset!");
static_assert(offsetof(AK33ControlStation, _montagePlayer_turretSpawnerSection) == 0x000430, "Member 'AK33ControlStation::_montagePlayer_turretSpawnerSection' has a wrong offset!");
static_assert(offsetof(AK33ControlStation, _montagePlayer_tunnelEntranceSection) == 0x000438, "Member 'AK33ControlStation::_montagePlayer_tunnelEntranceSection' has a wrong offset!");
static_assert(offsetof(AK33ControlStation, _animationSlave_turretSpawnerSection) == 0x000440, "Member 'AK33ControlStation::_animationSlave_turretSpawnerSection' has a wrong offset!");
static_assert(offsetof(AK33ControlStation, _animationSlave_tunnelEntranceSection) == 0x000448, "Member 'AK33ControlStation::_animationSlave_tunnelEntranceSection' has a wrong offset!");
static_assert(offsetof(AK33ControlStation, _linkedTurret) == 0x000450, "Member 'AK33ControlStation::_linkedTurret' has a wrong offset!");
static_assert(offsetof(AK33ControlStation, _currentState) == 0x000458, "Member 'AK33ControlStation::_currentState' has a wrong offset!");
static_assert(offsetof(AK33ControlStation, _turretSocketName) == 0x00045C, "Member 'AK33ControlStation::_turretSocketName' has a wrong offset!");
static_assert(offsetof(AK33ControlStation, _spawningDuration) == 0x000498, "Member 'AK33ControlStation::_spawningDuration' has a wrong offset!");
static_assert(offsetof(AK33ControlStation, _turretAvailabilityCooldownDuration) == 0x0004C0, "Member 'AK33ControlStation::_turretAvailabilityCooldownDuration' has a wrong offset!");
static_assert(offsetof(AK33ControlStation, _worldTimeAtCooldownStart) == 0x000518, "Member 'AK33ControlStation::_worldTimeAtCooldownStart' has a wrong offset!");
static_assert(offsetof(AK33ControlStation, _malfunctionDuration) == 0x00051C, "Member 'AK33ControlStation::_malfunctionDuration' has a wrong offset!");
static_assert(offsetof(AK33ControlStation, _blockExitTime) == 0x000548, "Member 'AK33ControlStation::_blockExitTime' has a wrong offset!");
static_assert(offsetof(AK33ControlStation, _isMalfunctioning) == 0x0005D0, "Member 'AK33ControlStation::_isMalfunctioning' has a wrong offset!");

// Class TheK33.K33ControlStationAttackableComponent
// 0x0000 (0x00A8 - 0x00A8)
class UK33ControlStationAttackableComponent final : public UAttackableComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K33ControlStationAttackableComponent">();
	}
	static class UK33ControlStationAttackableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK33ControlStationAttackableComponent>();
	}
};
static_assert(alignof(UK33ControlStationAttackableComponent) == 0x000008, "Wrong alignment on UK33ControlStationAttackableComponent");
static_assert(sizeof(UK33ControlStationAttackableComponent) == 0x0000A8, "Wrong size on UK33ControlStationAttackableComponent");

// Class TheK33.K33ControlStationTunnelConnection
// 0x0028 (0x02C8 - 0x02A0)
class AK33ControlStationTunnelConnection final : public AActor
{
public:
	class UStaticMeshComponent*                   _tunnelConnectionMesh;                             // 0x02A0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A8[0x20];                                     // 0x02A8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K33ControlStationTunnelConnection">();
	}
	static class AK33ControlStationTunnelConnection* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK33ControlStationTunnelConnection>();
	}
};
static_assert(alignof(AK33ControlStationTunnelConnection) == 0x000008, "Wrong alignment on AK33ControlStationTunnelConnection");
static_assert(sizeof(AK33ControlStationTunnelConnection) == 0x0002C8, "Wrong size on AK33ControlStationTunnelConnection");
static_assert(offsetof(AK33ControlStationTunnelConnection, _tunnelConnectionMesh) == 0x0002A0, "Member 'AK33ControlStationTunnelConnection::_tunnelConnectionMesh' has a wrong offset!");

// Class TheK33.K33TunnelMovementInputAccelerationConstraintStrategyComponent
// 0x0010 (0x00B8 - 0x00A8)
class UK33TunnelMovementInputAccelerationConstraintStrategyComponent final : public UBaseInputAccelerationConstraintStrategy
{
public:
	TArray<struct FVector>                        _forcedDirectionalInputs;                          // 0x00A8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K33TunnelMovementInputAccelerationConstraintStrategyComponent">();
	}
	static class UK33TunnelMovementInputAccelerationConstraintStrategyComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK33TunnelMovementInputAccelerationConstraintStrategyComponent>();
	}
};
static_assert(alignof(UK33TunnelMovementInputAccelerationConstraintStrategyComponent) == 0x000008, "Wrong alignment on UK33TunnelMovementInputAccelerationConstraintStrategyComponent");
static_assert(sizeof(UK33TunnelMovementInputAccelerationConstraintStrategyComponent) == 0x0000B8, "Wrong size on UK33TunnelMovementInputAccelerationConstraintStrategyComponent");
static_assert(offsetof(UK33TunnelMovementInputAccelerationConstraintStrategyComponent, _forcedDirectionalInputs) == 0x0000A8, "Member 'UK33TunnelMovementInputAccelerationConstraintStrategyComponent::_forcedDirectionalInputs' has a wrong offset!");

// Class TheK33.K33ControlStationTunnelEntranceOutlineUpdateStrategy
// 0x0020 (0x0168 - 0x0148)
class UK33ControlStationTunnelEntranceOutlineUpdateStrategy final : public USourceBasedOutlineUpdateStrategy
{
public:
	struct FLinearColor                           _controlStationIsFlaggedForTarget;                 // 0x0148(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           _controlStationIsSelected;                         // 0x0158(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K33ControlStationTunnelEntranceOutlineUpdateStrategy">();
	}
	static class UK33ControlStationTunnelEntranceOutlineUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK33ControlStationTunnelEntranceOutlineUpdateStrategy>();
	}
};
static_assert(alignof(UK33ControlStationTunnelEntranceOutlineUpdateStrategy) == 0x000008, "Wrong alignment on UK33ControlStationTunnelEntranceOutlineUpdateStrategy");
static_assert(sizeof(UK33ControlStationTunnelEntranceOutlineUpdateStrategy) == 0x000168, "Wrong size on UK33ControlStationTunnelEntranceOutlineUpdateStrategy");
static_assert(offsetof(UK33ControlStationTunnelEntranceOutlineUpdateStrategy, _controlStationIsFlaggedForTarget) == 0x000148, "Member 'UK33ControlStationTunnelEntranceOutlineUpdateStrategy::_controlStationIsFlaggedForTarget' has a wrong offset!");
static_assert(offsetof(UK33ControlStationTunnelEntranceOutlineUpdateStrategy, _controlStationIsSelected) == 0x000158, "Member 'UK33ControlStationTunnelEntranceOutlineUpdateStrategy::_controlStationIsSelected' has a wrong offset!");

// Class TheK33.K33Turret
// 0x0100 (0x0650 - 0x0550)
class AK33Turret final : public ACollectable
{
public:
	class USceneComponent*                        _rootComponent;                                    // 0x0550(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USpherePlayerOverlapComponent*          _interactableZone;                                 // 0x0558(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractor*                            _turretInteractor;                                 // 0x0560(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDropItemInteraction*                   _dropInteraction;                                  // 0x0568(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCollectItemInteraction*                _collectInteraction;                               // 0x0570(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDBDOutlineComponent*                   _outlineComponent;                                 // 0x0578(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialHelper*                        _materialHelper;                                   // 0x0580(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UK33TurretOutlineUpdateStrategy*        _turretOutlineUpdateStrategy;                      // 0x0588(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UChargeableComponent*                   _turretRepairChargeable;                           // 0x0590(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMontagePlayer*                         _montagePlayer;                                    // 0x0598(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimationMontageSlave*                 _montageFollower;                                  // 0x05A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          _turretCollision;                                  // 0x05A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          _tailAttackCollision;                              // 0x05B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UK33TurretDangerPredictionComponent*    _dangerPredictionComponent;                        // 0x05B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDBDNavModifierComponent*               _navModifierComponent;                             // 0x05C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        _laserRoot;                                        // 0x05C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAuthoritativePoolableActorComponent*   _poolableActorComponent;                           // 0x05D0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStateController*                       _turretStateController;                            // 0x05D8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   _detectionSocketName;                              // 0x05E0(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5EC[0x64];                                     // 0x05EC(0x0064)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_BipMotionTrackerFX(const float DistanceToKiller);
	void Cosmetic_OnKillerEnteredSpecialModeFXReaction();
	void Cosmetic_OnTurretDetectionRangeChanged(float NewRange);
	void Cosmetic_OnTurretHeatChanged(float HeatAmount);
	void Cosmetic_UpdateLaserLength(const float LaserLength);
	void Cosmetic_UpdateMotionTrackerSoundVolume(const float DistanceToKiller);
	void Cosmetic_UpdateTurretVolumeRTPC(const int32 TurretsInRangeCount);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K33Turret">();
	}
	static class AK33Turret* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK33Turret>();
	}
};
static_assert(alignof(AK33Turret) == 0x000008, "Wrong alignment on AK33Turret");
static_assert(sizeof(AK33Turret) == 0x000650, "Wrong size on AK33Turret");
static_assert(offsetof(AK33Turret, _rootComponent) == 0x000550, "Member 'AK33Turret::_rootComponent' has a wrong offset!");
static_assert(offsetof(AK33Turret, _interactableZone) == 0x000558, "Member 'AK33Turret::_interactableZone' has a wrong offset!");
static_assert(offsetof(AK33Turret, _turretInteractor) == 0x000560, "Member 'AK33Turret::_turretInteractor' has a wrong offset!");
static_assert(offsetof(AK33Turret, _dropInteraction) == 0x000568, "Member 'AK33Turret::_dropInteraction' has a wrong offset!");
static_assert(offsetof(AK33Turret, _collectInteraction) == 0x000570, "Member 'AK33Turret::_collectInteraction' has a wrong offset!");
static_assert(offsetof(AK33Turret, _outlineComponent) == 0x000578, "Member 'AK33Turret::_outlineComponent' has a wrong offset!");
static_assert(offsetof(AK33Turret, _materialHelper) == 0x000580, "Member 'AK33Turret::_materialHelper' has a wrong offset!");
static_assert(offsetof(AK33Turret, _turretOutlineUpdateStrategy) == 0x000588, "Member 'AK33Turret::_turretOutlineUpdateStrategy' has a wrong offset!");
static_assert(offsetof(AK33Turret, _turretRepairChargeable) == 0x000590, "Member 'AK33Turret::_turretRepairChargeable' has a wrong offset!");
static_assert(offsetof(AK33Turret, _montagePlayer) == 0x000598, "Member 'AK33Turret::_montagePlayer' has a wrong offset!");
static_assert(offsetof(AK33Turret, _montageFollower) == 0x0005A0, "Member 'AK33Turret::_montageFollower' has a wrong offset!");
static_assert(offsetof(AK33Turret, _turretCollision) == 0x0005A8, "Member 'AK33Turret::_turretCollision' has a wrong offset!");
static_assert(offsetof(AK33Turret, _tailAttackCollision) == 0x0005B0, "Member 'AK33Turret::_tailAttackCollision' has a wrong offset!");
static_assert(offsetof(AK33Turret, _dangerPredictionComponent) == 0x0005B8, "Member 'AK33Turret::_dangerPredictionComponent' has a wrong offset!");
static_assert(offsetof(AK33Turret, _navModifierComponent) == 0x0005C0, "Member 'AK33Turret::_navModifierComponent' has a wrong offset!");
static_assert(offsetof(AK33Turret, _laserRoot) == 0x0005C8, "Member 'AK33Turret::_laserRoot' has a wrong offset!");
static_assert(offsetof(AK33Turret, _poolableActorComponent) == 0x0005D0, "Member 'AK33Turret::_poolableActorComponent' has a wrong offset!");
static_assert(offsetof(AK33Turret, _turretStateController) == 0x0005D8, "Member 'AK33Turret::_turretStateController' has a wrong offset!");
static_assert(offsetof(AK33Turret, _detectionSocketName) == 0x0005E0, "Member 'AK33Turret::_detectionSocketName' has a wrong offset!");

// Class TheK33.K33ControlStationTurretSpawnerAnimInstance
// 0x0020 (0x03A0 - 0x0380)
class UK33ControlStationTurretSpawnerAnimInstance final : public UDBDBaseAnimInstance
{
public:
	bool                                          _isBoxOpening;                                     // 0x0380(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isBoxOpened;                                      // 0x0381(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_382[0x2];                                      // 0x0382(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _boxOpeningPlayRate;                               // 0x0384(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_388[0x8];                                      // 0x0388(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          _spawnTurretAnimSequence;                          // 0x0390(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_398[0x8];                                      // 0x0398(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K33ControlStationTurretSpawnerAnimInstance">();
	}
	static class UK33ControlStationTurretSpawnerAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK33ControlStationTurretSpawnerAnimInstance>();
	}
};
static_assert(alignof(UK33ControlStationTurretSpawnerAnimInstance) == 0x000010, "Wrong alignment on UK33ControlStationTurretSpawnerAnimInstance");
static_assert(sizeof(UK33ControlStationTurretSpawnerAnimInstance) == 0x0003A0, "Wrong size on UK33ControlStationTurretSpawnerAnimInstance");
static_assert(offsetof(UK33ControlStationTurretSpawnerAnimInstance, _isBoxOpening) == 0x000380, "Member 'UK33ControlStationTurretSpawnerAnimInstance::_isBoxOpening' has a wrong offset!");
static_assert(offsetof(UK33ControlStationTurretSpawnerAnimInstance, _isBoxOpened) == 0x000381, "Member 'UK33ControlStationTurretSpawnerAnimInstance::_isBoxOpened' has a wrong offset!");
static_assert(offsetof(UK33ControlStationTurretSpawnerAnimInstance, _boxOpeningPlayRate) == 0x000384, "Member 'UK33ControlStationTurretSpawnerAnimInstance::_boxOpeningPlayRate' has a wrong offset!");
static_assert(offsetof(UK33ControlStationTurretSpawnerAnimInstance, _spawnTurretAnimSequence) == 0x000390, "Member 'UK33ControlStationTurretSpawnerAnimInstance::_spawnTurretAnimSequence' has a wrong offset!");

// Class TheK33.K33ControlStationTurretSpawnerOutlineUpdateStrategy
// 0x0028 (0x0118 - 0x00F0)
class UK33ControlStationTurretSpawnerOutlineUpdateStrategy final : public UDefaultOutlineUpdateStrategy
{
public:
	struct FDBDTunableRowHandle                   _maxDistanceToRevealToSurvivor;                    // 0x00F0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K33ControlStationTurretSpawnerOutlineUpdateStrategy">();
	}
	static class UK33ControlStationTurretSpawnerOutlineUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK33ControlStationTurretSpawnerOutlineUpdateStrategy>();
	}
};
static_assert(alignof(UK33ControlStationTurretSpawnerOutlineUpdateStrategy) == 0x000008, "Wrong alignment on UK33ControlStationTurretSpawnerOutlineUpdateStrategy");
static_assert(sizeof(UK33ControlStationTurretSpawnerOutlineUpdateStrategy) == 0x000118, "Wrong size on UK33ControlStationTurretSpawnerOutlineUpdateStrategy");
static_assert(offsetof(UK33ControlStationTurretSpawnerOutlineUpdateStrategy, _maxDistanceToRevealToSurvivor) == 0x0000F0, "Member 'UK33ControlStationTurretSpawnerOutlineUpdateStrategy::_maxDistanceToRevealToSurvivor' has a wrong offset!");

// Class TheK33.K33DeployTurretInteraction
// 0x00B0 (0x09D0 - 0x0920)
class UK33DeployTurretInteraction final : public UBasicChargeableInteraction
{
public:
	uint8                                         Pad_920[0x70];                                     // 0x0920(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAnimationMontageDescriptor            _cancelMontage;                                    // 0x0990(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	float                                         _cancelDeployDuration;                             // 0x09B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_9B4[0x4];                                      // 0x09B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                _dropOffLocation;                                  // 0x09B8(0x0018)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K33DeployTurretInteraction">();
	}
	static class UK33DeployTurretInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK33DeployTurretInteraction>();
	}
};
static_assert(alignof(UK33DeployTurretInteraction) == 0x000010, "Wrong alignment on UK33DeployTurretInteraction");
static_assert(sizeof(UK33DeployTurretInteraction) == 0x0009D0, "Wrong size on UK33DeployTurretInteraction");
static_assert(offsetof(UK33DeployTurretInteraction, _cancelMontage) == 0x000990, "Member 'UK33DeployTurretInteraction::_cancelMontage' has a wrong offset!");
static_assert(offsetof(UK33DeployTurretInteraction, _cancelDeployDuration) == 0x0009B0, "Member 'UK33DeployTurretInteraction::_cancelDeployDuration' has a wrong offset!");
static_assert(offsetof(UK33DeployTurretInteraction, _dropOffLocation) == 0x0009B8, "Member 'UK33DeployTurretInteraction::_dropOffLocation' has a wrong offset!");

// Class TheK33.K33TunnelProceduralGenerationComponent
// 0x00D0 (0x0178 - 0x00A8)
class UK33TunnelProceduralGenerationComponent final : public UKillerSpecificGameStateComponent
{
public:
	struct FK33TunnelBlockSpawnData               _blocksSpawnData;                                  // 0x00A8(0x0018)(Net, RepNotify, NativeAccessSpecifierPrivate)
	TMap<EK33TunnelBlockType, TSoftClassPtr<class UClass>> _tunnelBlockAssetsReferences;                      // 0x00C0(0x0050)(Edit, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	TMap<EK33TunnelBlockType, class UClass*>      _tunnelBlockAssetClasses;                          // 0x0110(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TArray<class AK33TunnelBlock*>                _tunnelBlocks;                                     // 0x0160(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	float                                         _blockSize;                                        // 0x0170(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _basementHeightOffset;                             // 0x0174(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnRep_BlockSpawnData();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K33TunnelProceduralGenerationComponent">();
	}
	static class UK33TunnelProceduralGenerationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK33TunnelProceduralGenerationComponent>();
	}
};
static_assert(alignof(UK33TunnelProceduralGenerationComponent) == 0x000008, "Wrong alignment on UK33TunnelProceduralGenerationComponent");
static_assert(sizeof(UK33TunnelProceduralGenerationComponent) == 0x000178, "Wrong size on UK33TunnelProceduralGenerationComponent");
static_assert(offsetof(UK33TunnelProceduralGenerationComponent, _blocksSpawnData) == 0x0000A8, "Member 'UK33TunnelProceduralGenerationComponent::_blocksSpawnData' has a wrong offset!");
static_assert(offsetof(UK33TunnelProceduralGenerationComponent, _tunnelBlockAssetsReferences) == 0x0000C0, "Member 'UK33TunnelProceduralGenerationComponent::_tunnelBlockAssetsReferences' has a wrong offset!");
static_assert(offsetof(UK33TunnelProceduralGenerationComponent, _tunnelBlockAssetClasses) == 0x000110, "Member 'UK33TunnelProceduralGenerationComponent::_tunnelBlockAssetClasses' has a wrong offset!");
static_assert(offsetof(UK33TunnelProceduralGenerationComponent, _tunnelBlocks) == 0x000160, "Member 'UK33TunnelProceduralGenerationComponent::_tunnelBlocks' has a wrong offset!");
static_assert(offsetof(UK33TunnelProceduralGenerationComponent, _blockSize) == 0x000170, "Member 'UK33TunnelProceduralGenerationComponent::_blockSize' has a wrong offset!");
static_assert(offsetof(UK33TunnelProceduralGenerationComponent, _basementHeightOffset) == 0x000174, "Member 'UK33TunnelProceduralGenerationComponent::_basementHeightOffset' has a wrong offset!");

// Class TheK33.K33EnterTunnelInteraction
// 0x0110 (0x09D0 - 0x08C0)
class UK33EnterTunnelInteraction final : public UChargeableInteractionDefinition
{
public:
	struct FAnimationMontageDescriptor            _confirmEnterControlStationMontage;                // 0x08C0(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FAnimationMontageDescriptor            _cancelMontage;                                    // 0x08E0(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FAnimationMontageDescriptor            _afterTeleportationMontage;                        // 0x0900(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FVector                                _cameraTransitionOffset;                           // 0x0920(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _chargeInteractionTime;                            // 0x0938(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	float                                         _hideWorldElementsMontagePercentageTime;           // 0x0960(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _fadeOutDuration;                                  // 0x0964(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_968[0x68];                                     // 0x0968(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Multicast_TeleportPlayerToTunnel(class ADBDPlayer* Player, const struct FVector& Location, const struct FRotator& Rotation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K33EnterTunnelInteraction">();
	}
	static class UK33EnterTunnelInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK33EnterTunnelInteraction>();
	}
};
static_assert(alignof(UK33EnterTunnelInteraction) == 0x000010, "Wrong alignment on UK33EnterTunnelInteraction");
static_assert(sizeof(UK33EnterTunnelInteraction) == 0x0009D0, "Wrong size on UK33EnterTunnelInteraction");
static_assert(offsetof(UK33EnterTunnelInteraction, _confirmEnterControlStationMontage) == 0x0008C0, "Member 'UK33EnterTunnelInteraction::_confirmEnterControlStationMontage' has a wrong offset!");
static_assert(offsetof(UK33EnterTunnelInteraction, _cancelMontage) == 0x0008E0, "Member 'UK33EnterTunnelInteraction::_cancelMontage' has a wrong offset!");
static_assert(offsetof(UK33EnterTunnelInteraction, _afterTeleportationMontage) == 0x000900, "Member 'UK33EnterTunnelInteraction::_afterTeleportationMontage' has a wrong offset!");
static_assert(offsetof(UK33EnterTunnelInteraction, _cameraTransitionOffset) == 0x000920, "Member 'UK33EnterTunnelInteraction::_cameraTransitionOffset' has a wrong offset!");
static_assert(offsetof(UK33EnterTunnelInteraction, _chargeInteractionTime) == 0x000938, "Member 'UK33EnterTunnelInteraction::_chargeInteractionTime' has a wrong offset!");
static_assert(offsetof(UK33EnterTunnelInteraction, _hideWorldElementsMontagePercentageTime) == 0x000960, "Member 'UK33EnterTunnelInteraction::_hideWorldElementsMontagePercentageTime' has a wrong offset!");
static_assert(offsetof(UK33EnterTunnelInteraction, _fadeOutDuration) == 0x000964, "Member 'UK33EnterTunnelInteraction::_fadeOutDuration' has a wrong offset!");

// Class TheK33.K33ExitTunnelInteractable
// 0x0038 (0x03E0 - 0x03A8)
class AK33ExitTunnelInteractable final : public AInteractable
{
public:
	class USceneComponent*                        _rootComponent;                                    // 0x03A8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInteractor*                            _interactor;                                       // 0x03B0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBoxComponent*                          _interactionCollisionZone;                         // 0x03B8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AK33ControlStation*                     _linkedControlStation;                             // 0x03C0(0x0008)(Net, ZeroConstructor, Transient, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                _targetLocation;                                   // 0x03C8(0x0018)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnRep_LinkedControlStation();
	void OnRep_TargetLocation();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K33ExitTunnelInteractable">();
	}
	static class AK33ExitTunnelInteractable* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK33ExitTunnelInteractable>();
	}
};
static_assert(alignof(AK33ExitTunnelInteractable) == 0x000008, "Wrong alignment on AK33ExitTunnelInteractable");
static_assert(sizeof(AK33ExitTunnelInteractable) == 0x0003E0, "Wrong size on AK33ExitTunnelInteractable");
static_assert(offsetof(AK33ExitTunnelInteractable, _rootComponent) == 0x0003A8, "Member 'AK33ExitTunnelInteractable::_rootComponent' has a wrong offset!");
static_assert(offsetof(AK33ExitTunnelInteractable, _interactor) == 0x0003B0, "Member 'AK33ExitTunnelInteractable::_interactor' has a wrong offset!");
static_assert(offsetof(AK33ExitTunnelInteractable, _interactionCollisionZone) == 0x0003B8, "Member 'AK33ExitTunnelInteractable::_interactionCollisionZone' has a wrong offset!");
static_assert(offsetof(AK33ExitTunnelInteractable, _linkedControlStation) == 0x0003C0, "Member 'AK33ExitTunnelInteractable::_linkedControlStation' has a wrong offset!");
static_assert(offsetof(AK33ExitTunnelInteractable, _targetLocation) == 0x0003C8, "Member 'AK33ExitTunnelInteractable::_targetLocation' has a wrong offset!");

// Class TheK33.K33ExitTunnelInteraction
// 0x0210 (0x0990 - 0x0780)
class UK33ExitTunnelInteraction final : public UInteractionDefinition
{
public:
	struct FDBDTunableRowHandle                   _firstAnimationTime;                               // 0x0778(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _secondAnimationTime;                              // 0x07A0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _killerInstinctTriggerDistance;                    // 0x07C8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _killerInstinctLingerTime;                         // 0x07F0(0x0080)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _exitTunnelPenaltyRange;                           // 0x0870(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _exitTunnelPenaltyPercentage;                      // 0x0898(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _killerInstinctStatusEffectClass;                  // 0x08C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _exitTunnelAnimationTime;                          // 0x08C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _toggleMeshVisibilityAnimationPercentageTime;      // 0x08CC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                _cameraOffset;                                     // 0x08D0(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _cameraRotationSpeed;                              // 0x08E8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _fadeOutDuration;                                  // 0x08EC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8F0[0x93];                                     // 0x08F0(0x0093)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _useExitTimePenalty;                               // 0x0983(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_984[0xC];                                      // 0x0984(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Multicast_OnSnapTransitionCompleted(class ADBDPlayer* Player, const struct FVector& Location, const struct FRotator& Rotation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K33ExitTunnelInteraction">();
	}
	static class UK33ExitTunnelInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK33ExitTunnelInteraction>();
	}
};
static_assert(alignof(UK33ExitTunnelInteraction) == 0x000010, "Wrong alignment on UK33ExitTunnelInteraction");
static_assert(sizeof(UK33ExitTunnelInteraction) == 0x000990, "Wrong size on UK33ExitTunnelInteraction");
static_assert(offsetof(UK33ExitTunnelInteraction, _firstAnimationTime) == 0x000778, "Member 'UK33ExitTunnelInteraction::_firstAnimationTime' has a wrong offset!");
static_assert(offsetof(UK33ExitTunnelInteraction, _secondAnimationTime) == 0x0007A0, "Member 'UK33ExitTunnelInteraction::_secondAnimationTime' has a wrong offset!");
static_assert(offsetof(UK33ExitTunnelInteraction, _killerInstinctTriggerDistance) == 0x0007C8, "Member 'UK33ExitTunnelInteraction::_killerInstinctTriggerDistance' has a wrong offset!");
static_assert(offsetof(UK33ExitTunnelInteraction, _killerInstinctLingerTime) == 0x0007F0, "Member 'UK33ExitTunnelInteraction::_killerInstinctLingerTime' has a wrong offset!");
static_assert(offsetof(UK33ExitTunnelInteraction, _exitTunnelPenaltyRange) == 0x000870, "Member 'UK33ExitTunnelInteraction::_exitTunnelPenaltyRange' has a wrong offset!");
static_assert(offsetof(UK33ExitTunnelInteraction, _exitTunnelPenaltyPercentage) == 0x000898, "Member 'UK33ExitTunnelInteraction::_exitTunnelPenaltyPercentage' has a wrong offset!");
static_assert(offsetof(UK33ExitTunnelInteraction, _killerInstinctStatusEffectClass) == 0x0008C0, "Member 'UK33ExitTunnelInteraction::_killerInstinctStatusEffectClass' has a wrong offset!");
static_assert(offsetof(UK33ExitTunnelInteraction, _exitTunnelAnimationTime) == 0x0008C8, "Member 'UK33ExitTunnelInteraction::_exitTunnelAnimationTime' has a wrong offset!");
static_assert(offsetof(UK33ExitTunnelInteraction, _toggleMeshVisibilityAnimationPercentageTime) == 0x0008CC, "Member 'UK33ExitTunnelInteraction::_toggleMeshVisibilityAnimationPercentageTime' has a wrong offset!");
static_assert(offsetof(UK33ExitTunnelInteraction, _cameraOffset) == 0x0008D0, "Member 'UK33ExitTunnelInteraction::_cameraOffset' has a wrong offset!");
static_assert(offsetof(UK33ExitTunnelInteraction, _cameraRotationSpeed) == 0x0008E8, "Member 'UK33ExitTunnelInteraction::_cameraRotationSpeed' has a wrong offset!");
static_assert(offsetof(UK33ExitTunnelInteraction, _fadeOutDuration) == 0x0008EC, "Member 'UK33ExitTunnelInteraction::_fadeOutDuration' has a wrong offset!");
static_assert(offsetof(UK33ExitTunnelInteraction, _useExitTimePenalty) == 0x000983, "Member 'UK33ExitTunnelInteraction::_useExitTimePenalty' has a wrong offset!");

// Class TheK33.K33FallOutOfWorldPositionFinderComponent
// 0x0008 (0x00B0 - 0x00A8)
class UK33FallOutOfWorldPositionFinderComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K33FallOutOfWorldPositionFinderComponent">();
	}
	static class UK33FallOutOfWorldPositionFinderComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK33FallOutOfWorldPositionFinderComponent>();
	}
};
static_assert(alignof(UK33FallOutOfWorldPositionFinderComponent) == 0x000008, "Wrong alignment on UK33FallOutOfWorldPositionFinderComponent");
static_assert(sizeof(UK33FallOutOfWorldPositionFinderComponent) == 0x0000B0, "Wrong size on UK33FallOutOfWorldPositionFinderComponent");

// Class TheK33.K33TurretAnimInstance
// 0x0070 (0x03F0 - 0x0380)
class UK33TurretAnimInstance final : public UDBDBaseAnimInstance
{
public:
	bool                                          _isInPool;                                         // 0x0380(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isInsideControlStation;                           // 0x0381(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isBeingCollected;                                 // 0x0382(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isCarryable;                                      // 0x0383(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isAttachedToSurvivor;                             // 0x0384(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isBeingDeployed;                                  // 0x0385(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isDeployCancelled;                                // 0x0386(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isDeployed;                                       // 0x0387(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isBeingUndeployed;                                // 0x0388(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isUndeployCancelled;                              // 0x0389(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isFiring;                                         // 0x038A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isOverheated;                                     // 0x038B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isBeingRepaired;                                  // 0x038C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isDestroyed;                                      // 0x038D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_38E[0x2];                                      // 0x038E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _isFiringAlpha;                                    // 0x0390(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isMalfunctioning;                                 // 0x0394(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_395[0x3];                                      // 0x0395(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _animYaw;                                          // 0x0398(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _frontLegPitch;                                    // 0x039C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _backLegsPitch;                                    // 0x03A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A4[0x4C];                                     // 0x03A4(0x004C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K33TurretAnimInstance">();
	}
	static class UK33TurretAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK33TurretAnimInstance>();
	}
};
static_assert(alignof(UK33TurretAnimInstance) == 0x000010, "Wrong alignment on UK33TurretAnimInstance");
static_assert(sizeof(UK33TurretAnimInstance) == 0x0003F0, "Wrong size on UK33TurretAnimInstance");
static_assert(offsetof(UK33TurretAnimInstance, _isInPool) == 0x000380, "Member 'UK33TurretAnimInstance::_isInPool' has a wrong offset!");
static_assert(offsetof(UK33TurretAnimInstance, _isInsideControlStation) == 0x000381, "Member 'UK33TurretAnimInstance::_isInsideControlStation' has a wrong offset!");
static_assert(offsetof(UK33TurretAnimInstance, _isBeingCollected) == 0x000382, "Member 'UK33TurretAnimInstance::_isBeingCollected' has a wrong offset!");
static_assert(offsetof(UK33TurretAnimInstance, _isCarryable) == 0x000383, "Member 'UK33TurretAnimInstance::_isCarryable' has a wrong offset!");
static_assert(offsetof(UK33TurretAnimInstance, _isAttachedToSurvivor) == 0x000384, "Member 'UK33TurretAnimInstance::_isAttachedToSurvivor' has a wrong offset!");
static_assert(offsetof(UK33TurretAnimInstance, _isBeingDeployed) == 0x000385, "Member 'UK33TurretAnimInstance::_isBeingDeployed' has a wrong offset!");
static_assert(offsetof(UK33TurretAnimInstance, _isDeployCancelled) == 0x000386, "Member 'UK33TurretAnimInstance::_isDeployCancelled' has a wrong offset!");
static_assert(offsetof(UK33TurretAnimInstance, _isDeployed) == 0x000387, "Member 'UK33TurretAnimInstance::_isDeployed' has a wrong offset!");
static_assert(offsetof(UK33TurretAnimInstance, _isBeingUndeployed) == 0x000388, "Member 'UK33TurretAnimInstance::_isBeingUndeployed' has a wrong offset!");
static_assert(offsetof(UK33TurretAnimInstance, _isUndeployCancelled) == 0x000389, "Member 'UK33TurretAnimInstance::_isUndeployCancelled' has a wrong offset!");
static_assert(offsetof(UK33TurretAnimInstance, _isFiring) == 0x00038A, "Member 'UK33TurretAnimInstance::_isFiring' has a wrong offset!");
static_assert(offsetof(UK33TurretAnimInstance, _isOverheated) == 0x00038B, "Member 'UK33TurretAnimInstance::_isOverheated' has a wrong offset!");
static_assert(offsetof(UK33TurretAnimInstance, _isBeingRepaired) == 0x00038C, "Member 'UK33TurretAnimInstance::_isBeingRepaired' has a wrong offset!");
static_assert(offsetof(UK33TurretAnimInstance, _isDestroyed) == 0x00038D, "Member 'UK33TurretAnimInstance::_isDestroyed' has a wrong offset!");
static_assert(offsetof(UK33TurretAnimInstance, _isFiringAlpha) == 0x000390, "Member 'UK33TurretAnimInstance::_isFiringAlpha' has a wrong offset!");
static_assert(offsetof(UK33TurretAnimInstance, _isMalfunctioning) == 0x000394, "Member 'UK33TurretAnimInstance::_isMalfunctioning' has a wrong offset!");
static_assert(offsetof(UK33TurretAnimInstance, _animYaw) == 0x000398, "Member 'UK33TurretAnimInstance::_animYaw' has a wrong offset!");
static_assert(offsetof(UK33TurretAnimInstance, _frontLegPitch) == 0x00039C, "Member 'UK33TurretAnimInstance::_frontLegPitch' has a wrong offset!");
static_assert(offsetof(UK33TurretAnimInstance, _backLegsPitch) == 0x0003A0, "Member 'UK33TurretAnimInstance::_backLegsPitch' has a wrong offset!");

// Class TheK33.K33FeetVFX
// 0x0098 (0x0338 - 0x02A0)
class AK33FeetVFX final : public AActor
{
public:
	uint8                                         Pad_2A0[0x8];                                      // 0x02A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	EK33Foot                                      _currentFootType;                                  // 0x02A8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A9[0x3];                                      // 0x02A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _footstepEffectDuration;                           // 0x02AC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_             OnAcquiredChanged;                                 // 0x02B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C0[0x78];                                     // 0x02C0(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_TriggerFootstepTimeline(EK33Foot FootType, float EffectLifetime, const struct FVector& KillerLocation);
	void Cosmetic_TriggerFootstepVisibility(EK33Foot FootType, bool IsVisible);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K33FeetVFX">();
	}
	static class AK33FeetVFX* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK33FeetVFX>();
	}
};
static_assert(alignof(AK33FeetVFX) == 0x000008, "Wrong alignment on AK33FeetVFX");
static_assert(sizeof(AK33FeetVFX) == 0x000338, "Wrong size on AK33FeetVFX");
static_assert(offsetof(AK33FeetVFX, _currentFootType) == 0x0002A8, "Member 'AK33FeetVFX::_currentFootType' has a wrong offset!");
static_assert(offsetof(AK33FeetVFX, _footstepEffectDuration) == 0x0002AC, "Member 'AK33FeetVFX::_footstepEffectDuration' has a wrong offset!");
static_assert(offsetof(AK33FeetVFX, OnAcquiredChanged) == 0x0002B0, "Member 'AK33FeetVFX::OnAcquiredChanged' has a wrong offset!");

// Class TheK33.K33FXInterface
// 0x0000 (0x0030 - 0x0030)
class IK33FXInterface final : public IInterface
{
public:
	void Cosmetic_OnKillerShotByTurret();
	void Cosmetic_OnSpecialModeChanged(bool IsInSpecialMode);
	void Cosmetic_OnSurvivorHitByTailAttack(class ACamperPlayer* Player);
	void Cosmetic_OnTurretDamageChanged(float DamagePercent);
	void Cosmetic_OnTurretHitByTailAttack(class AK33Turret* Turret);
	void Cosmetic_OnTurretMaxDamageReceived();
	void Cosmetic_SetKillerFPVAudioAmbiance(bool IsTunnelAmbianceActive);
	void Cosmetic_SetKillerInvisibleUnderCurrentFloor(bool ShouldKillerBeInvisibleUnderFloor);
	void Cosmetic_SetVisibility(bool IsVisible);
	void Cosmetic_StopTailAttackVFX();
	void Cosmetic_TailAttackObstructedVFX(const struct FVector& ObstructionLocation);
	void Cosmetic_TriggerTunnelTransitionFadeIn(float TimeBeforeFadeIn);
	void Cosmetic_TriggerTunnelTransitionFadeOut(float TimeBeforeFadeOut);
	void Cosmetic_UpdateTailAttackVFX(const struct FVector& Location, const struct FRotator& Rotation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K33FXInterface">();
	}
	static class IK33FXInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IK33FXInterface>();
	}
};
static_assert(alignof(IK33FXInterface) == 0x000008, "Wrong alignment on IK33FXInterface");
static_assert(sizeof(IK33FXInterface) == 0x000030, "Wrong size on IK33FXInterface");

// Class TheK33.K33Husk
// 0x0038 (0x0328 - 0x02F0)
class AK33Husk final : public APoseableHusk
{
public:
	class UMontagePlayer*                         _montagePlayer;                                    // 0x02F0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTerrorRadiusEmitterComponent*          _terrorRadiusEmitterComponent;                     // 0x02F8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkComponent*                           _huskAudioComponent;                               // 0x0300(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _terrorRadiusDistanceOffsetCurve;                  // 0x0308(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_310[0x18];                                     // 0x0310(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K33Husk">();
	}
	static class AK33Husk* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK33Husk>();
	}
};
static_assert(alignof(AK33Husk) == 0x000008, "Wrong alignment on AK33Husk");
static_assert(sizeof(AK33Husk) == 0x000328, "Wrong size on AK33Husk");
static_assert(offsetof(AK33Husk, _montagePlayer) == 0x0002F0, "Member 'AK33Husk::_montagePlayer' has a wrong offset!");
static_assert(offsetof(AK33Husk, _terrorRadiusEmitterComponent) == 0x0002F8, "Member 'AK33Husk::_terrorRadiusEmitterComponent' has a wrong offset!");
static_assert(offsetof(AK33Husk, _huskAudioComponent) == 0x000300, "Member 'AK33Husk::_huskAudioComponent' has a wrong offset!");
static_assert(offsetof(AK33Husk, _terrorRadiusDistanceOffsetCurve) == 0x000308, "Member 'AK33Husk::_terrorRadiusDistanceOffsetCurve' has a wrong offset!");

// Class TheK33.K33HuskAnimInstance
// 0x0020 (0x03A0 - 0x0380)
class UK33HuskAnimInstance final : public UDBDBaseAnimInstance
{
public:
	bool                                          _isFPV;                                            // 0x0380(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_381[0x3];                                      // 0x0381(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _cameraPitchValue;                                 // 0x0384(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_388[0x18];                                     // 0x0388(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	const class UCustomizedSkeletalMesh* GetCopiedCustomizedSkeletalMesh() const;
	const class USkeletalMeshComponent* GetCopiedSkeletalMesh() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K33HuskAnimInstance">();
	}
	static class UK33HuskAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK33HuskAnimInstance>();
	}
};
static_assert(alignof(UK33HuskAnimInstance) == 0x000010, "Wrong alignment on UK33HuskAnimInstance");
static_assert(sizeof(UK33HuskAnimInstance) == 0x0003A0, "Wrong size on UK33HuskAnimInstance");
static_assert(offsetof(UK33HuskAnimInstance, _isFPV) == 0x000380, "Member 'UK33HuskAnimInstance::_isFPV' has a wrong offset!");
static_assert(offsetof(UK33HuskAnimInstance, _cameraPitchValue) == 0x000384, "Member 'UK33HuskAnimInstance::_cameraPitchValue' has a wrong offset!");

// Class TheK33.K33KillerControlStationSelectorComponent
// 0x0250 (0x02F8 - 0x00A8)
class UK33KillerControlStationSelectorComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x18];                                      // 0x00A8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _thresholdDeltaSquaredDistanceForBestTargetRecalculation; // 0x00C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _minDeltaDotProductForBestTargetRecalculation;     // 0x00C4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _minDotProductForEligibleControlStationTarget;     // 0x00C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _minDistanceForEligibleControlStationTargetOutsideTunnel; // 0x00CC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D0[0x8];                                       // 0x00D0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   _actorIndicatorClass;                              // 0x00D8(0x0038)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftClassPtr<class UClass>                   _tunnelNavigationComponentClass;                   // 0x0110(0x0038)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ADBDActorIndicator*                     _indicatorInstance;                                // 0x0148(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UK33TunnelNavigationComponent*          _tunnelNavigationComponentInstance;                // 0x0150(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_158[0x18];                                     // 0x0158(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class AK33ControlStation*                     _replicated_selectedControlStation;                // 0x0170(0x0008)(Net, ZeroConstructor, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAimDirectionProvider*                  _aimDirectionProvider;                             // 0x0178(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_180[0x178];                                    // 0x0180(0x0178)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_Replicated_SelectedControlStation(class AK33ControlStation* PreviousSelectedControlStation);
	void Server_SetSelectedControlStation(class AK33ControlStation* ControlStation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K33KillerControlStationSelectorComponent">();
	}
	static class UK33KillerControlStationSelectorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK33KillerControlStationSelectorComponent>();
	}
};
static_assert(alignof(UK33KillerControlStationSelectorComponent) == 0x000008, "Wrong alignment on UK33KillerControlStationSelectorComponent");
static_assert(sizeof(UK33KillerControlStationSelectorComponent) == 0x0002F8, "Wrong size on UK33KillerControlStationSelectorComponent");
static_assert(offsetof(UK33KillerControlStationSelectorComponent, _thresholdDeltaSquaredDistanceForBestTargetRecalculation) == 0x0000C0, "Member 'UK33KillerControlStationSelectorComponent::_thresholdDeltaSquaredDistanceForBestTargetRecalculation' has a wrong offset!");
static_assert(offsetof(UK33KillerControlStationSelectorComponent, _minDeltaDotProductForBestTargetRecalculation) == 0x0000C4, "Member 'UK33KillerControlStationSelectorComponent::_minDeltaDotProductForBestTargetRecalculation' has a wrong offset!");
static_assert(offsetof(UK33KillerControlStationSelectorComponent, _minDotProductForEligibleControlStationTarget) == 0x0000C8, "Member 'UK33KillerControlStationSelectorComponent::_minDotProductForEligibleControlStationTarget' has a wrong offset!");
static_assert(offsetof(UK33KillerControlStationSelectorComponent, _minDistanceForEligibleControlStationTargetOutsideTunnel) == 0x0000CC, "Member 'UK33KillerControlStationSelectorComponent::_minDistanceForEligibleControlStationTargetOutsideTunnel' has a wrong offset!");
static_assert(offsetof(UK33KillerControlStationSelectorComponent, _actorIndicatorClass) == 0x0000D8, "Member 'UK33KillerControlStationSelectorComponent::_actorIndicatorClass' has a wrong offset!");
static_assert(offsetof(UK33KillerControlStationSelectorComponent, _tunnelNavigationComponentClass) == 0x000110, "Member 'UK33KillerControlStationSelectorComponent::_tunnelNavigationComponentClass' has a wrong offset!");
static_assert(offsetof(UK33KillerControlStationSelectorComponent, _indicatorInstance) == 0x000148, "Member 'UK33KillerControlStationSelectorComponent::_indicatorInstance' has a wrong offset!");
static_assert(offsetof(UK33KillerControlStationSelectorComponent, _tunnelNavigationComponentInstance) == 0x000150, "Member 'UK33KillerControlStationSelectorComponent::_tunnelNavigationComponentInstance' has a wrong offset!");
static_assert(offsetof(UK33KillerControlStationSelectorComponent, _replicated_selectedControlStation) == 0x000170, "Member 'UK33KillerControlStationSelectorComponent::_replicated_selectedControlStation' has a wrong offset!");
static_assert(offsetof(UK33KillerControlStationSelectorComponent, _aimDirectionProvider) == 0x000178, "Member 'UK33KillerControlStationSelectorComponent::_aimDirectionProvider' has a wrong offset!");

// Class TheK33.K33KillerStunnedByTurretStatusEffect
// 0x0030 (0x03B0 - 0x0380)
class UK33KillerStunnedByTurretStatusEffect final : public UStatusEffect
{
public:
	class UCurveFloat*                            _movementSpeedCurve;                               // 0x0380(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _movementSpeedDuration;                            // 0x0388(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K33KillerStunnedByTurretStatusEffect">();
	}
	static class UK33KillerStunnedByTurretStatusEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK33KillerStunnedByTurretStatusEffect>();
	}
};
static_assert(alignof(UK33KillerStunnedByTurretStatusEffect) == 0x000008, "Wrong alignment on UK33KillerStunnedByTurretStatusEffect");
static_assert(sizeof(UK33KillerStunnedByTurretStatusEffect) == 0x0003B0, "Wrong size on UK33KillerStunnedByTurretStatusEffect");
static_assert(offsetof(UK33KillerStunnedByTurretStatusEffect, _movementSpeedCurve) == 0x000380, "Member 'UK33KillerStunnedByTurretStatusEffect::_movementSpeedCurve' has a wrong offset!");
static_assert(offsetof(UK33KillerStunnedByTurretStatusEffect, _movementSpeedDuration) == 0x000388, "Member 'UK33KillerStunnedByTurretStatusEffect::_movementSpeedDuration' has a wrong offset!");

// Class TheK33.K33KillerTunnelStateComponent
// 0x02C0 (0x0368 - 0x00A8)
class UK33KillerTunnelStateComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTagStateBool                          _isInTunnel;                                       // 0x00B0(0x0048)(Net, RepNotify, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F8[0x8];                                       // 0x00F8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UK33TunnelMovementInputAccelerationConstraintStrategyComponent> _movementInputConstraintStrategyClass;             // 0x0100(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UK33TunnelMovementInputAccelerationConstraintStrategyComponent* _movementInputConstraintStrategy;                  // 0x0108(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<TSubclassOf<class AActor>>             _inTunnelUntouchedClasses;                         // 0x0110(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_120[0x50];                                     // 0x0120(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   _controlStationTunnelConnectionClass;              // 0x0170(0x0038)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AK33ControlStationTunnelConnection*     _controlStationTunnelConnectionInstance;           // 0x01A8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _accelerationMultiplier;                           // 0x01B0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _heightOffsetForDistanceChecks;                    // 0x01D8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	float                                         _defaultOcclusionRefreshInterval;                  // 0x0200(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _minAnimPitchInTunnel;                             // 0x0204(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_208[0x22];                                     // 0x0208(0x0022)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _worldElementsVisibility;                          // 0x022A(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _tunnelElementsVisibility;                         // 0x022B(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EK33KillerBlockCollisionType                  _killerCollisionBlockType;                         // 0x022C(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_22D[0x3];                                      // 0x022D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UAmbianceManagerDataAsset*              _tunnelAmbiance;                                   // 0x0230(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_238[0x130];                                    // 0x0238(0x0130)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnLevelReadyToPlay();
	void OnRep_IsInTunnel();
	void OnRep_KillerCollisionBlockType();
	void OnRep_TunnelElementsVisibility();
	void OnRep_WorldElementsVisibility();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K33KillerTunnelStateComponent">();
	}
	static class UK33KillerTunnelStateComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK33KillerTunnelStateComponent>();
	}
};
static_assert(alignof(UK33KillerTunnelStateComponent) == 0x000008, "Wrong alignment on UK33KillerTunnelStateComponent");
static_assert(sizeof(UK33KillerTunnelStateComponent) == 0x000368, "Wrong size on UK33KillerTunnelStateComponent");
static_assert(offsetof(UK33KillerTunnelStateComponent, _isInTunnel) == 0x0000B0, "Member 'UK33KillerTunnelStateComponent::_isInTunnel' has a wrong offset!");
static_assert(offsetof(UK33KillerTunnelStateComponent, _movementInputConstraintStrategyClass) == 0x000100, "Member 'UK33KillerTunnelStateComponent::_movementInputConstraintStrategyClass' has a wrong offset!");
static_assert(offsetof(UK33KillerTunnelStateComponent, _movementInputConstraintStrategy) == 0x000108, "Member 'UK33KillerTunnelStateComponent::_movementInputConstraintStrategy' has a wrong offset!");
static_assert(offsetof(UK33KillerTunnelStateComponent, _inTunnelUntouchedClasses) == 0x000110, "Member 'UK33KillerTunnelStateComponent::_inTunnelUntouchedClasses' has a wrong offset!");
static_assert(offsetof(UK33KillerTunnelStateComponent, _controlStationTunnelConnectionClass) == 0x000170, "Member 'UK33KillerTunnelStateComponent::_controlStationTunnelConnectionClass' has a wrong offset!");
static_assert(offsetof(UK33KillerTunnelStateComponent, _controlStationTunnelConnectionInstance) == 0x0001A8, "Member 'UK33KillerTunnelStateComponent::_controlStationTunnelConnectionInstance' has a wrong offset!");
static_assert(offsetof(UK33KillerTunnelStateComponent, _accelerationMultiplier) == 0x0001B0, "Member 'UK33KillerTunnelStateComponent::_accelerationMultiplier' has a wrong offset!");
static_assert(offsetof(UK33KillerTunnelStateComponent, _heightOffsetForDistanceChecks) == 0x0001D8, "Member 'UK33KillerTunnelStateComponent::_heightOffsetForDistanceChecks' has a wrong offset!");
static_assert(offsetof(UK33KillerTunnelStateComponent, _defaultOcclusionRefreshInterval) == 0x000200, "Member 'UK33KillerTunnelStateComponent::_defaultOcclusionRefreshInterval' has a wrong offset!");
static_assert(offsetof(UK33KillerTunnelStateComponent, _minAnimPitchInTunnel) == 0x000204, "Member 'UK33KillerTunnelStateComponent::_minAnimPitchInTunnel' has a wrong offset!");
static_assert(offsetof(UK33KillerTunnelStateComponent, _worldElementsVisibility) == 0x00022A, "Member 'UK33KillerTunnelStateComponent::_worldElementsVisibility' has a wrong offset!");
static_assert(offsetof(UK33KillerTunnelStateComponent, _tunnelElementsVisibility) == 0x00022B, "Member 'UK33KillerTunnelStateComponent::_tunnelElementsVisibility' has a wrong offset!");
static_assert(offsetof(UK33KillerTunnelStateComponent, _killerCollisionBlockType) == 0x00022C, "Member 'UK33KillerTunnelStateComponent::_killerCollisionBlockType' has a wrong offset!");
static_assert(offsetof(UK33KillerTunnelStateComponent, _tunnelAmbiance) == 0x000230, "Member 'UK33KillerTunnelStateComponent::_tunnelAmbiance' has a wrong offset!");

// Class TheK33.K33P01
// 0x0030 (0x0450 - 0x0420)
class UK33P01 final : public UPerk
{
public:
	float                                         _perkCooldownTime[0x3];                            // 0x0420(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _screamRevealRangeFromLocker;                      // 0x042C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _blindedStatusEffect;                              // 0x0430(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _blindedEffectDuration[0x3];                       // 0x0438(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_444[0xC];                                      // 0x0444(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetBlindedEffectDurationAtLevel() const;
	float GetPerkCooldownTimeAtLevel() const;
	float GetScreamRevealRange() const;
	void Multicast_SurvivorRevealed(const class ACamperPlayer* Survivor) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K33P01">();
	}
	static class UK33P01* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK33P01>();
	}
};
static_assert(alignof(UK33P01) == 0x000008, "Wrong alignment on UK33P01");
static_assert(sizeof(UK33P01) == 0x000450, "Wrong size on UK33P01");
static_assert(offsetof(UK33P01, _perkCooldownTime) == 0x000420, "Member 'UK33P01::_perkCooldownTime' has a wrong offset!");
static_assert(offsetof(UK33P01, _screamRevealRangeFromLocker) == 0x00042C, "Member 'UK33P01::_screamRevealRangeFromLocker' has a wrong offset!");
static_assert(offsetof(UK33P01, _blindedStatusEffect) == 0x000430, "Member 'UK33P01::_blindedStatusEffect' has a wrong offset!");
static_assert(offsetof(UK33P01, _blindedEffectDuration) == 0x000438, "Member 'UK33P01::_blindedEffectDuration' has a wrong offset!");

// Class TheK33.K33TurretFiringState
// 0x0018 (0x0068 - 0x0050)
class UK33TurretFiringState final : public UBaseReplicatedState
{
public:
	uint8                                         Pad_50[0x18];                                      // 0x0050(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K33TurretFiringState">();
	}
	static class UK33TurretFiringState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK33TurretFiringState>();
	}
};
static_assert(alignof(UK33TurretFiringState) == 0x000008, "Wrong alignment on UK33TurretFiringState");
static_assert(sizeof(UK33TurretFiringState) == 0x000068, "Wrong size on UK33TurretFiringState");

// Class TheK33.K33P02
// 0x0020 (0x0440 - 0x0420)
class UK33P02 final : public UPerk
{
public:
	TSubclassOf<class UStatusEffect>              _hasteStatusEffect;                                // 0x0420(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _hasteDuration[0x3];                               // 0x0428(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _hasteAmount;                                      // 0x0434(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStatusEffect*                          _hasteEffect;                                      // 0x0438(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	float GetHasteAmount() const;
	float GetHasteDurationAtLevel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K33P02">();
	}
	static class UK33P02* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK33P02>();
	}
};
static_assert(alignof(UK33P02) == 0x000008, "Wrong alignment on UK33P02");
static_assert(sizeof(UK33P02) == 0x000440, "Wrong size on UK33P02");
static_assert(offsetof(UK33P02, _hasteStatusEffect) == 0x000420, "Member 'UK33P02::_hasteStatusEffect' has a wrong offset!");
static_assert(offsetof(UK33P02, _hasteDuration) == 0x000428, "Member 'UK33P02::_hasteDuration' has a wrong offset!");
static_assert(offsetof(UK33P02, _hasteAmount) == 0x000434, "Member 'UK33P02::_hasteAmount' has a wrong offset!");
static_assert(offsetof(UK33P02, _hasteEffect) == 0x000438, "Member 'UK33P02::_hasteEffect' has a wrong offset!");

// Class TheK33.K33P03
// 0x0028 (0x0448 - 0x0420)
class UK33P03 final : public UPerk
{
public:
	float                                         _perkAuraRevealDuration[0x3];                      // 0x0420(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _obliviousDuration[0x3];                           // 0x042C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _revealedStatusEffect;                             // 0x0438(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _obliviousStatusEffect;                            // 0x0440(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	float GetObliviousDurationAtLevel() const;
	float GetPerkAuraRevealDurationAtLevel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K33P03">();
	}
	static class UK33P03* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK33P03>();
	}
};
static_assert(alignof(UK33P03) == 0x000008, "Wrong alignment on UK33P03");
static_assert(sizeof(UK33P03) == 0x000448, "Wrong size on UK33P03");
static_assert(offsetof(UK33P03, _perkAuraRevealDuration) == 0x000420, "Member 'UK33P03::_perkAuraRevealDuration' has a wrong offset!");
static_assert(offsetof(UK33P03, _obliviousDuration) == 0x00042C, "Member 'UK33P03::_obliviousDuration' has a wrong offset!");
static_assert(offsetof(UK33P03, _revealedStatusEffect) == 0x000438, "Member 'UK33P03::_revealedStatusEffect' has a wrong offset!");
static_assert(offsetof(UK33P03, _obliviousStatusEffect) == 0x000440, "Member 'UK33P03::_obliviousStatusEffect' has a wrong offset!");

// Class TheK33.K33Power
// 0x0180 (0x06D0 - 0x0550)
class AK33Power final : public ACollectable
{
public:
	uint8                                         Pad_550[0x18];                                     // 0x0550(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UChargeableComponent*                   _tailAttackChargeableComponent;                    // 0x0568(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractor*                            _interactor;                                       // 0x0570(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxPlayerOverlapComponent*             _interactionVolume;                                // 0x0578(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTunableStat                           _tailAttackChargeTime;                             // 0x0580(0x0080)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UK33PowerChargePresentationItemProgressComponent* _powerChargePresentationItemProgress;              // 0x0600(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPowerChargeComponent*                  _k33PowerCharge;                                   // 0x0608(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ULocalActorPoolComponent*               _feetActorPool;                                    // 0x0610(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<TSubclassOf<class UStatusEffect>>      _killerStatusEffects;                              // 0x0618(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<TSubclassOf<class UStatusEffect>>      _survivorStatusEffects;                            // 0x0628(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	TSubclassOf<class UK33KillerTunnelStateComponent> _killerTunnelComponentClass;                       // 0x0638(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UK33QuadrupedComponent>     _quadrupedComponentClass;                          // 0x0640(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UK33KillerControlStationSelectorComponent> _controlStationSelectorComponentClass;             // 0x0648(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UK33SurvivorDetectionComponent> _survivorDetectionComponentClass;                  // 0x0650(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UK33TurretDamageComponent>  _turretDamageComponentClass;                       // 0x0658(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UK33TurretPlacer>           _turretPlacerComponentClass;                       // 0x0660(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class AK33Husk>                   _k33HuskClass;                                     // 0x0668(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UK33TurretPlacer*>               _turretPlacers;                                    // 0x0670(0x0010)(ExportObject, Net, ZeroConstructor, RepNotify, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint32                                        _feetPoolSize;                                     // 0x0680(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_684[0x4];                                      // 0x0684(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AK33FeetVFX>                _feetActorClass;                                   // 0x0688(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AK33Husk*                               _k33Husk;                                          // 0x0690(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_698[0x20];                                     // 0x0698(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UActorPoolInitializer*                  _turretPoolInitializer;                            // 0x06B8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAuthoritativeActorPoolComponent*       _turretPool;                                       // 0x06C0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6C8[0x8];                                      // 0x06C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UK33TailAttackInteraction* GetTailAttackInteraction();
	void OnRep_TurretPlacers();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K33Power">();
	}
	static class AK33Power* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK33Power>();
	}
};
static_assert(alignof(AK33Power) == 0x000008, "Wrong alignment on AK33Power");
static_assert(sizeof(AK33Power) == 0x0006D0, "Wrong size on AK33Power");
static_assert(offsetof(AK33Power, _tailAttackChargeableComponent) == 0x000568, "Member 'AK33Power::_tailAttackChargeableComponent' has a wrong offset!");
static_assert(offsetof(AK33Power, _interactor) == 0x000570, "Member 'AK33Power::_interactor' has a wrong offset!");
static_assert(offsetof(AK33Power, _interactionVolume) == 0x000578, "Member 'AK33Power::_interactionVolume' has a wrong offset!");
static_assert(offsetof(AK33Power, _tailAttackChargeTime) == 0x000580, "Member 'AK33Power::_tailAttackChargeTime' has a wrong offset!");
static_assert(offsetof(AK33Power, _powerChargePresentationItemProgress) == 0x000600, "Member 'AK33Power::_powerChargePresentationItemProgress' has a wrong offset!");
static_assert(offsetof(AK33Power, _k33PowerCharge) == 0x000608, "Member 'AK33Power::_k33PowerCharge' has a wrong offset!");
static_assert(offsetof(AK33Power, _feetActorPool) == 0x000610, "Member 'AK33Power::_feetActorPool' has a wrong offset!");
static_assert(offsetof(AK33Power, _killerStatusEffects) == 0x000618, "Member 'AK33Power::_killerStatusEffects' has a wrong offset!");
static_assert(offsetof(AK33Power, _survivorStatusEffects) == 0x000628, "Member 'AK33Power::_survivorStatusEffects' has a wrong offset!");
static_assert(offsetof(AK33Power, _killerTunnelComponentClass) == 0x000638, "Member 'AK33Power::_killerTunnelComponentClass' has a wrong offset!");
static_assert(offsetof(AK33Power, _quadrupedComponentClass) == 0x000640, "Member 'AK33Power::_quadrupedComponentClass' has a wrong offset!");
static_assert(offsetof(AK33Power, _controlStationSelectorComponentClass) == 0x000648, "Member 'AK33Power::_controlStationSelectorComponentClass' has a wrong offset!");
static_assert(offsetof(AK33Power, _survivorDetectionComponentClass) == 0x000650, "Member 'AK33Power::_survivorDetectionComponentClass' has a wrong offset!");
static_assert(offsetof(AK33Power, _turretDamageComponentClass) == 0x000658, "Member 'AK33Power::_turretDamageComponentClass' has a wrong offset!");
static_assert(offsetof(AK33Power, _turretPlacerComponentClass) == 0x000660, "Member 'AK33Power::_turretPlacerComponentClass' has a wrong offset!");
static_assert(offsetof(AK33Power, _k33HuskClass) == 0x000668, "Member 'AK33Power::_k33HuskClass' has a wrong offset!");
static_assert(offsetof(AK33Power, _turretPlacers) == 0x000670, "Member 'AK33Power::_turretPlacers' has a wrong offset!");
static_assert(offsetof(AK33Power, _feetPoolSize) == 0x000680, "Member 'AK33Power::_feetPoolSize' has a wrong offset!");
static_assert(offsetof(AK33Power, _feetActorClass) == 0x000688, "Member 'AK33Power::_feetActorClass' has a wrong offset!");
static_assert(offsetof(AK33Power, _k33Husk) == 0x000690, "Member 'AK33Power::_k33Husk' has a wrong offset!");
static_assert(offsetof(AK33Power, _turretPoolInitializer) == 0x0006B8, "Member 'AK33Power::_turretPoolInitializer' has a wrong offset!");
static_assert(offsetof(AK33Power, _turretPool) == 0x0006C0, "Member 'AK33Power::_turretPool' has a wrong offset!");

// Class TheK33.K33PowerAddon20StatusEffect
// 0x0028 (0x03A8 - 0x0380)
class UK33PowerAddon20StatusEffect final : public UStatusEffect
{
public:
	struct FDBDTunableRowHandle                   _effectDuration;                                   // 0x0380(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K33PowerAddon20StatusEffect">();
	}
	static class UK33PowerAddon20StatusEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK33PowerAddon20StatusEffect>();
	}
};
static_assert(alignof(UK33PowerAddon20StatusEffect) == 0x000008, "Wrong alignment on UK33PowerAddon20StatusEffect");
static_assert(sizeof(UK33PowerAddon20StatusEffect) == 0x0003A8, "Wrong size on UK33PowerAddon20StatusEffect");
static_assert(offsetof(UK33PowerAddon20StatusEffect, _effectDuration) == 0x000380, "Member 'UK33PowerAddon20StatusEffect::_effectDuration' has a wrong offset!");

// Class TheK33.K33PowerAnimInstance
// 0x0010 (0x06C0 - 0x06B0)
class UK33PowerAnimInstance final : public UBaseKillerAttackSubAnimInstance
{
public:
	bool                                          _isObstructionFar;                                 // 0x06B0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6B1[0x3];                                      // 0x06B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _obstructionDistance;                              // 0x06B4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6B8[0x8];                                      // 0x06B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K33PowerAnimInstance">();
	}
	static class UK33PowerAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK33PowerAnimInstance>();
	}
};
static_assert(alignof(UK33PowerAnimInstance) == 0x000010, "Wrong alignment on UK33PowerAnimInstance");
static_assert(sizeof(UK33PowerAnimInstance) == 0x0006C0, "Wrong size on UK33PowerAnimInstance");
static_assert(offsetof(UK33PowerAnimInstance, _isObstructionFar) == 0x0006B0, "Member 'UK33PowerAnimInstance::_isObstructionFar' has a wrong offset!");
static_assert(offsetof(UK33PowerAnimInstance, _obstructionDistance) == 0x0006B4, "Member 'UK33PowerAnimInstance::_obstructionDistance' has a wrong offset!");

// Class TheK33.K33PowerChargePresentationItemProgressComponent
// 0x0030 (0x00E0 - 0x00B0)
class UK33PowerChargePresentationItemProgressComponent final : public UPresentationItemProgressComponent
{
public:
	uint8                                         Pad_B0[0x30];                                      // 0x00B0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K33PowerChargePresentationItemProgressComponent">();
	}
	static class UK33PowerChargePresentationItemProgressComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK33PowerChargePresentationItemProgressComponent>();
	}
};
static_assert(alignof(UK33PowerChargePresentationItemProgressComponent) == 0x000008, "Wrong alignment on UK33PowerChargePresentationItemProgressComponent");
static_assert(sizeof(UK33PowerChargePresentationItemProgressComponent) == 0x0000E0, "Wrong size on UK33PowerChargePresentationItemProgressComponent");

// Class TheK33.K33Power_Addon_14
// 0x0018 (0x0310 - 0x02F8)
class UK33Power_Addon_14 final : public UOnEventBaseAddon
{
public:
	TSubclassOf<class UStatusEffect>              _blindnessStatusEffect;                            // 0x02F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _blindnessDuration;                                // 0x0300(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _survivorRangeDistanceFromTurretToTriggerEffect;   // 0x0304(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_308[0x8];                                      // 0x0308(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K33Power_Addon_14">();
	}
	static class UK33Power_Addon_14* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK33Power_Addon_14>();
	}
};
static_assert(alignof(UK33Power_Addon_14) == 0x000008, "Wrong alignment on UK33Power_Addon_14");
static_assert(sizeof(UK33Power_Addon_14) == 0x000310, "Wrong size on UK33Power_Addon_14");
static_assert(offsetof(UK33Power_Addon_14, _blindnessStatusEffect) == 0x0002F8, "Member 'UK33Power_Addon_14::_blindnessStatusEffect' has a wrong offset!");
static_assert(offsetof(UK33Power_Addon_14, _blindnessDuration) == 0x000300, "Member 'UK33Power_Addon_14::_blindnessDuration' has a wrong offset!");
static_assert(offsetof(UK33Power_Addon_14, _survivorRangeDistanceFromTurretToTriggerEffect) == 0x000304, "Member 'UK33Power_Addon_14::_survivorRangeDistanceFromTurretToTriggerEffect' has a wrong offset!");

// Class TheK33.K33Power_Addon_15
// 0x0058 (0x0340 - 0x02E8)
class UK33Power_Addon_15 final : public UItemAddon
{
public:
	uint8                                         Pad_2E8[0x50];                                     // 0x02E8(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _turretRange;                                      // 0x0338(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_33C[0x4];                                      // 0x033C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K33Power_Addon_15">();
	}
	static class UK33Power_Addon_15* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK33Power_Addon_15>();
	}
};
static_assert(alignof(UK33Power_Addon_15) == 0x000008, "Wrong alignment on UK33Power_Addon_15");
static_assert(sizeof(UK33Power_Addon_15) == 0x000340, "Wrong size on UK33Power_Addon_15");
static_assert(offsetof(UK33Power_Addon_15, _turretRange) == 0x000338, "Member 'UK33Power_Addon_15::_turretRange' has a wrong offset!");

// Class TheK33.K33Power_Addon_16
// 0x0040 (0x0338 - 0x02F8)
class UK33Power_Addon_16 final : public UOnEventBaseAddon
{
public:
	float                                         _activationLifetime;                               // 0x02F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _survivorRangeDistanceFromKillerToTriggerEffect;   // 0x02FC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_300[0x38];                                     // 0x0300(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_TriggerSurvivorScreamAndReveal(class ACamperPlayer* TargetSurvivor);
	void Multicast_TriggerSurvivorsScreamAndReveal(const TArray<class ACamperPlayer*>& TargetSurvivors);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K33Power_Addon_16">();
	}
	static class UK33Power_Addon_16* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK33Power_Addon_16>();
	}
};
static_assert(alignof(UK33Power_Addon_16) == 0x000008, "Wrong alignment on UK33Power_Addon_16");
static_assert(sizeof(UK33Power_Addon_16) == 0x000338, "Wrong size on UK33Power_Addon_16");
static_assert(offsetof(UK33Power_Addon_16, _activationLifetime) == 0x0002F8, "Member 'UK33Power_Addon_16::_activationLifetime' has a wrong offset!");
static_assert(offsetof(UK33Power_Addon_16, _survivorRangeDistanceFromKillerToTriggerEffect) == 0x0002FC, "Member 'UK33Power_Addon_16::_survivorRangeDistanceFromKillerToTriggerEffect' has a wrong offset!");

// Class TheK33.K33PushbackAnimInstance
// 0x00E0 (0x0430 - 0x0350)
class UK33PushbackAnimInstance final : public UAnimInstance
{
public:
	bool                                          IsActive;                                          // 0x0350(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsFPV;                                             // 0x0351(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETraceTypeQuery                               _traceTypeQuery;                                   // 0x0352(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _traceComplex;                                     // 0x0353(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _ignoreTouches;                                    // 0x0354(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_355[0x3];                                      // 0x0355(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _forwardCheckDistance;                             // 0x0358(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _backwardCheckDistance;                            // 0x035C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                _lineTraceStartOffset;                             // 0x0360(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ForwardHitDistance;                                // 0x0378(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BackwardHitDistance;                               // 0x037C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_380[0x80];                                     // 0x0380(0x0080)(Fixing Size After Last Property [ Dumper-7 ])
	class ACharacter*                             _character;                                        // 0x0400(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_408[0x28];                                     // 0x0408(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K33PushbackAnimInstance">();
	}
	static class UK33PushbackAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK33PushbackAnimInstance>();
	}
};
static_assert(alignof(UK33PushbackAnimInstance) == 0x000010, "Wrong alignment on UK33PushbackAnimInstance");
static_assert(sizeof(UK33PushbackAnimInstance) == 0x000430, "Wrong size on UK33PushbackAnimInstance");
static_assert(offsetof(UK33PushbackAnimInstance, IsActive) == 0x000350, "Member 'UK33PushbackAnimInstance::IsActive' has a wrong offset!");
static_assert(offsetof(UK33PushbackAnimInstance, IsFPV) == 0x000351, "Member 'UK33PushbackAnimInstance::IsFPV' has a wrong offset!");
static_assert(offsetof(UK33PushbackAnimInstance, _traceTypeQuery) == 0x000352, "Member 'UK33PushbackAnimInstance::_traceTypeQuery' has a wrong offset!");
static_assert(offsetof(UK33PushbackAnimInstance, _traceComplex) == 0x000353, "Member 'UK33PushbackAnimInstance::_traceComplex' has a wrong offset!");
static_assert(offsetof(UK33PushbackAnimInstance, _ignoreTouches) == 0x000354, "Member 'UK33PushbackAnimInstance::_ignoreTouches' has a wrong offset!");
static_assert(offsetof(UK33PushbackAnimInstance, _forwardCheckDistance) == 0x000358, "Member 'UK33PushbackAnimInstance::_forwardCheckDistance' has a wrong offset!");
static_assert(offsetof(UK33PushbackAnimInstance, _backwardCheckDistance) == 0x00035C, "Member 'UK33PushbackAnimInstance::_backwardCheckDistance' has a wrong offset!");
static_assert(offsetof(UK33PushbackAnimInstance, _lineTraceStartOffset) == 0x000360, "Member 'UK33PushbackAnimInstance::_lineTraceStartOffset' has a wrong offset!");
static_assert(offsetof(UK33PushbackAnimInstance, ForwardHitDistance) == 0x000378, "Member 'UK33PushbackAnimInstance::ForwardHitDistance' has a wrong offset!");
static_assert(offsetof(UK33PushbackAnimInstance, BackwardHitDistance) == 0x00037C, "Member 'UK33PushbackAnimInstance::BackwardHitDistance' has a wrong offset!");
static_assert(offsetof(UK33PushbackAnimInstance, _character) == 0x000400, "Member 'UK33PushbackAnimInstance::_character' has a wrong offset!");

// Class TheK33.K33TunnelBlock
// 0x0088 (0x0328 - 0x02A0)
class AK33TunnelBlock final : public AActor
{
public:
	class USceneComponent*                        _rootComponent;                                    // 0x02A0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UK33TunnelBlockCosmeticActorSpawner*    _cosmeticActorSpawner;                             // 0x02A8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AK33TunnelBlockCosmetic*                _tunnelCosmeticActor;                              // 0x02B0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B8[0x70];                                     // 0x02B8(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FVector GetEnterTunnelTeleportLocation() const;
	struct FVector GetExitTunnelInteractableSpawnLocation() const;
	struct FRotator GetExitTunnelInteractableSpawnRotation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K33TunnelBlock">();
	}
	static class AK33TunnelBlock* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK33TunnelBlock>();
	}
};
static_assert(alignof(AK33TunnelBlock) == 0x000008, "Wrong alignment on AK33TunnelBlock");
static_assert(sizeof(AK33TunnelBlock) == 0x000328, "Wrong size on AK33TunnelBlock");
static_assert(offsetof(AK33TunnelBlock, _rootComponent) == 0x0002A0, "Member 'AK33TunnelBlock::_rootComponent' has a wrong offset!");
static_assert(offsetof(AK33TunnelBlock, _cosmeticActorSpawner) == 0x0002A8, "Member 'AK33TunnelBlock::_cosmeticActorSpawner' has a wrong offset!");
static_assert(offsetof(AK33TunnelBlock, _tunnelCosmeticActor) == 0x0002B0, "Member 'AK33TunnelBlock::_tunnelCosmeticActor' has a wrong offset!");

// Class TheK33.K33QuadrupedComponent
// 0x0060 (0x0108 - 0x00A8)
class UK33QuadrupedComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTagStateBool                          _isInQuadrupedMode;                                // 0x00B0(0x0048)(Net, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F8[0x10];                                      // 0x00F8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K33QuadrupedComponent">();
	}
	static class UK33QuadrupedComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK33QuadrupedComponent>();
	}
};
static_assert(alignof(UK33QuadrupedComponent) == 0x000008, "Wrong alignment on UK33QuadrupedComponent");
static_assert(sizeof(UK33QuadrupedComponent) == 0x000108, "Wrong size on UK33QuadrupedComponent");
static_assert(offsetof(UK33QuadrupedComponent, _isInQuadrupedMode) == 0x0000B0, "Member 'UK33QuadrupedComponent::_isInQuadrupedMode' has a wrong offset!");

// Class TheK33.K33SelectControlStationInteraction
// 0x0000 (0x0780 - 0x0780)
class UK33SelectControlStationInteraction final : public UInteractionDefinition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K33SelectControlStationInteraction">();
	}
	static class UK33SelectControlStationInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK33SelectControlStationInteraction>();
	}
};
static_assert(alignof(UK33SelectControlStationInteraction) == 0x000010, "Wrong alignment on UK33SelectControlStationInteraction");
static_assert(sizeof(UK33SelectControlStationInteraction) == 0x000780, "Wrong size on UK33SelectControlStationInteraction");

// Class TheK33.K33SelectedControlStationLinkedActorOutlineUpdateStrategy
// 0x0050 (0x0140 - 0x00F0)
class UK33SelectedControlStationLinkedActorOutlineUpdateStrategy final : public UDefaultOutlineUpdateStrategy
{
public:
	struct FLinearColor                           _revealedColorForSelectedLinkedControlStation;     // 0x00F0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           _revealedColorForTargetedLinkedControlStation;     // 0x0100(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _exitProximityDistance;                            // 0x0110(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_138[0x8];                                      // 0x0138(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K33SelectedControlStationLinkedActorOutlineUpdateStrategy">();
	}
	static class UK33SelectedControlStationLinkedActorOutlineUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK33SelectedControlStationLinkedActorOutlineUpdateStrategy>();
	}
};
static_assert(alignof(UK33SelectedControlStationLinkedActorOutlineUpdateStrategy) == 0x000008, "Wrong alignment on UK33SelectedControlStationLinkedActorOutlineUpdateStrategy");
static_assert(sizeof(UK33SelectedControlStationLinkedActorOutlineUpdateStrategy) == 0x000140, "Wrong size on UK33SelectedControlStationLinkedActorOutlineUpdateStrategy");
static_assert(offsetof(UK33SelectedControlStationLinkedActorOutlineUpdateStrategy, _revealedColorForSelectedLinkedControlStation) == 0x0000F0, "Member 'UK33SelectedControlStationLinkedActorOutlineUpdateStrategy::_revealedColorForSelectedLinkedControlStation' has a wrong offset!");
static_assert(offsetof(UK33SelectedControlStationLinkedActorOutlineUpdateStrategy, _revealedColorForTargetedLinkedControlStation) == 0x000100, "Member 'UK33SelectedControlStationLinkedActorOutlineUpdateStrategy::_revealedColorForTargetedLinkedControlStation' has a wrong offset!");
static_assert(offsetof(UK33SelectedControlStationLinkedActorOutlineUpdateStrategy, _exitProximityDistance) == 0x000110, "Member 'UK33SelectedControlStationLinkedActorOutlineUpdateStrategy::_exitProximityDistance' has a wrong offset!");

// Class TheK33.K33SelectedControlStationOutlineFollower
// 0x0000 (0x0030 - 0x0030)
class IK33SelectedControlStationOutlineFollower final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K33SelectedControlStationOutlineFollower">();
	}
	static class IK33SelectedControlStationOutlineFollower* GetDefaultObj()
	{
		return GetDefaultObjImpl<IK33SelectedControlStationOutlineFollower>();
	}
};
static_assert(alignof(IK33SelectedControlStationOutlineFollower) == 0x000008, "Wrong alignment on IK33SelectedControlStationOutlineFollower");
static_assert(sizeof(IK33SelectedControlStationOutlineFollower) == 0x000030, "Wrong size on IK33SelectedControlStationOutlineFollower");

// Class TheK33.K33TunnelNavigationComponent
// 0x0108 (0x01B0 - 0x00A8)
class UK33TunnelNavigationComponent final : public UActorComponent
{
public:
	float                                         _dotProductDeltaValueForPathRecalculation;         // 0x00A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _minDistanceDeltaForPathRecalculation;             // 0x00AC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UK33TunnelPulsationComponent> _tunnelPulsationComponentClass;                    // 0x00B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UK33TunnelPulsationComponent*           _tunnelPulsationComponent;                         // 0x00B8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAimDirectionProvider*                  _aimDirectionProvider;                             // 0x00C0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C8[0xE8];                                      // 0x00C8(0x00E8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K33TunnelNavigationComponent">();
	}
	static class UK33TunnelNavigationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK33TunnelNavigationComponent>();
	}
};
static_assert(alignof(UK33TunnelNavigationComponent) == 0x000008, "Wrong alignment on UK33TunnelNavigationComponent");
static_assert(sizeof(UK33TunnelNavigationComponent) == 0x0001B0, "Wrong size on UK33TunnelNavigationComponent");
static_assert(offsetof(UK33TunnelNavigationComponent, _dotProductDeltaValueForPathRecalculation) == 0x0000A8, "Member 'UK33TunnelNavigationComponent::_dotProductDeltaValueForPathRecalculation' has a wrong offset!");
static_assert(offsetof(UK33TunnelNavigationComponent, _minDistanceDeltaForPathRecalculation) == 0x0000AC, "Member 'UK33TunnelNavigationComponent::_minDistanceDeltaForPathRecalculation' has a wrong offset!");
static_assert(offsetof(UK33TunnelNavigationComponent, _tunnelPulsationComponentClass) == 0x0000B0, "Member 'UK33TunnelNavigationComponent::_tunnelPulsationComponentClass' has a wrong offset!");
static_assert(offsetof(UK33TunnelNavigationComponent, _tunnelPulsationComponent) == 0x0000B8, "Member 'UK33TunnelNavigationComponent::_tunnelPulsationComponent' has a wrong offset!");
static_assert(offsetof(UK33TunnelNavigationComponent, _aimDirectionProvider) == 0x0000C0, "Member 'UK33TunnelNavigationComponent::_aimDirectionProvider' has a wrong offset!");

// Class TheK33.K33SpawnTurretInteraction
// 0x0000 (0x0780 - 0x0780)
class UK33SpawnTurretInteraction final : public UInteractionDefinition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K33SpawnTurretInteraction">();
	}
	static class UK33SpawnTurretInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK33SpawnTurretInteraction>();
	}
};
static_assert(alignof(UK33SpawnTurretInteraction) == 0x000010, "Wrong alignment on UK33SpawnTurretInteraction");
static_assert(sizeof(UK33SpawnTurretInteraction) == 0x000780, "Wrong size on UK33SpawnTurretInteraction");

// Class TheK33.K33SpecialModeComponent
// 0x01E8 (0x0290 - 0x00A8)
class UK33SpecialModeComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x10];                                      // 0x00A8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTagStateBool                          _isInSpecialMode;                                  // 0x00B8(0x0048)(Net, RepNotify, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _specialModeMaxCharge;                             // 0x0100(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _specialModeMaximumChargePercentOnPickUp;          // 0x0128(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _specialModeMovingInTunnelChargeRate;              // 0x0150(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _specialModeDechargeRatePerAttackingTurrets;       // 0x0178(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _terrorRadiusSizeInSpecialMode;                    // 0x01A0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FNonTunableStat                        _specialModeNormalChargeRate;                      // 0x01C8(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	EK33SpecialModeChargeState                    _chargeState;                                      // 0x0228(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_22C[0x64];                                     // 0x022C(0x0064)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnIntroCompleted();
	void OnPowerChargeChanged(const float CurrentChargePercent);
	void OnRep_ChargeState();
	void OnRep_IsInSpecialMode();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K33SpecialModeComponent">();
	}
	static class UK33SpecialModeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK33SpecialModeComponent>();
	}
};
static_assert(alignof(UK33SpecialModeComponent) == 0x000008, "Wrong alignment on UK33SpecialModeComponent");
static_assert(sizeof(UK33SpecialModeComponent) == 0x000290, "Wrong size on UK33SpecialModeComponent");
static_assert(offsetof(UK33SpecialModeComponent, _isInSpecialMode) == 0x0000B8, "Member 'UK33SpecialModeComponent::_isInSpecialMode' has a wrong offset!");
static_assert(offsetof(UK33SpecialModeComponent, _specialModeMaxCharge) == 0x000100, "Member 'UK33SpecialModeComponent::_specialModeMaxCharge' has a wrong offset!");
static_assert(offsetof(UK33SpecialModeComponent, _specialModeMaximumChargePercentOnPickUp) == 0x000128, "Member 'UK33SpecialModeComponent::_specialModeMaximumChargePercentOnPickUp' has a wrong offset!");
static_assert(offsetof(UK33SpecialModeComponent, _specialModeMovingInTunnelChargeRate) == 0x000150, "Member 'UK33SpecialModeComponent::_specialModeMovingInTunnelChargeRate' has a wrong offset!");
static_assert(offsetof(UK33SpecialModeComponent, _specialModeDechargeRatePerAttackingTurrets) == 0x000178, "Member 'UK33SpecialModeComponent::_specialModeDechargeRatePerAttackingTurrets' has a wrong offset!");
static_assert(offsetof(UK33SpecialModeComponent, _terrorRadiusSizeInSpecialMode) == 0x0001A0, "Member 'UK33SpecialModeComponent::_terrorRadiusSizeInSpecialMode' has a wrong offset!");
static_assert(offsetof(UK33SpecialModeComponent, _specialModeNormalChargeRate) == 0x0001C8, "Member 'UK33SpecialModeComponent::_specialModeNormalChargeRate' has a wrong offset!");
static_assert(offsetof(UK33SpecialModeComponent, _chargeState) == 0x000228, "Member 'UK33SpecialModeComponent::_chargeState' has a wrong offset!");

// Class TheK33.K33SurvivorCosmeticHelperActor
// 0x0090 (0x0398 - 0x0308)
class AK33SurvivorCosmeticHelperActor final : public ASurvivorCosmeticHelperActor
{
public:
	uint8                                         Pad_308[0x90];                                     // 0x0308(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_InitializeTurretPlacementVisualFeedback(const class FName& SocketName);
	void Cosmetic_OnTurretPlacementValidityChanged(const bool IsPlacementValid);
	void Cosmetic_OnTurretPlacementVisualFeedbackActivationChanged(const bool Activated, const bool IsPlacementValid);
	void Cosmetic_UpdateTurretLaserPlacement(const struct FVector& PlacementLocation, const struct FRotator& PlacementRotation);

	class AK33Turret* GetCarriedTurret() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K33SurvivorCosmeticHelperActor">();
	}
	static class AK33SurvivorCosmeticHelperActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK33SurvivorCosmeticHelperActor>();
	}
};
static_assert(alignof(AK33SurvivorCosmeticHelperActor) == 0x000008, "Wrong alignment on AK33SurvivorCosmeticHelperActor");
static_assert(sizeof(AK33SurvivorCosmeticHelperActor) == 0x000398, "Wrong size on AK33SurvivorCosmeticHelperActor");

// Class TheK33.K33SurvivorDetectedFromTunnelStatusEffect
// 0x00B8 (0x0438 - 0x0380)
class UK33SurvivorDetectedFromTunnelStatusEffect final : public UStatusEffect
{
public:
	struct FDBDTunableRowHandle                   _timeBetweenFootsteps;                             // 0x0380(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	EHudScreenIndicatorType                       _offscreenIndicatorType;                           // 0x03A8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3A9[0x7];                                      // 0x03A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _offscreenIndicatorMinVisibleDistance;             // 0x03B0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _offscreenIndicatorLifetime;                       // 0x03D8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_400[0x14];                                     // 0x0400(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _indicatorLerpMultiplierSpeed;                     // 0x0414(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _aboveKillerHeadRange;                             // 0x0418(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_41C[0x1C];                                     // 0x041C(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K33SurvivorDetectedFromTunnelStatusEffect">();
	}
	static class UK33SurvivorDetectedFromTunnelStatusEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK33SurvivorDetectedFromTunnelStatusEffect>();
	}
};
static_assert(alignof(UK33SurvivorDetectedFromTunnelStatusEffect) == 0x000008, "Wrong alignment on UK33SurvivorDetectedFromTunnelStatusEffect");
static_assert(sizeof(UK33SurvivorDetectedFromTunnelStatusEffect) == 0x000438, "Wrong size on UK33SurvivorDetectedFromTunnelStatusEffect");
static_assert(offsetof(UK33SurvivorDetectedFromTunnelStatusEffect, _timeBetweenFootsteps) == 0x000380, "Member 'UK33SurvivorDetectedFromTunnelStatusEffect::_timeBetweenFootsteps' has a wrong offset!");
static_assert(offsetof(UK33SurvivorDetectedFromTunnelStatusEffect, _offscreenIndicatorType) == 0x0003A8, "Member 'UK33SurvivorDetectedFromTunnelStatusEffect::_offscreenIndicatorType' has a wrong offset!");
static_assert(offsetof(UK33SurvivorDetectedFromTunnelStatusEffect, _offscreenIndicatorMinVisibleDistance) == 0x0003B0, "Member 'UK33SurvivorDetectedFromTunnelStatusEffect::_offscreenIndicatorMinVisibleDistance' has a wrong offset!");
static_assert(offsetof(UK33SurvivorDetectedFromTunnelStatusEffect, _offscreenIndicatorLifetime) == 0x0003D8, "Member 'UK33SurvivorDetectedFromTunnelStatusEffect::_offscreenIndicatorLifetime' has a wrong offset!");
static_assert(offsetof(UK33SurvivorDetectedFromTunnelStatusEffect, _indicatorLerpMultiplierSpeed) == 0x000414, "Member 'UK33SurvivorDetectedFromTunnelStatusEffect::_indicatorLerpMultiplierSpeed' has a wrong offset!");
static_assert(offsetof(UK33SurvivorDetectedFromTunnelStatusEffect, _aboveKillerHeadRange) == 0x000418, "Member 'UK33SurvivorDetectedFromTunnelStatusEffect::_aboveKillerHeadRange' has a wrong offset!");

// Class TheK33.K33TunnelPulsationComponent
// 0x0078 (0x0120 - 0x00A8)
class UK33TunnelPulsationComponent final : public UActorComponent
{
public:
	int32                                         _initialPulsePoolSize;                             // 0x00A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AK33TunnelPulse>            _tunnelPulseActorClass;                            // 0x00B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _pulseSpeed;                                       // 0x00B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _timeBetweenPulseWaves;                            // 0x00BC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         _numberOfPulsesPerWaves;                           // 0x00C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _timeBetweenPulsesInWave;                          // 0x00C4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _minDistanceToTriggerNextPulseWave;                // 0x00C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_CC[0x4];                                       // 0x00CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ULocalActorPoolComponent*               _pool;                                             // 0x00D0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D8[0x48];                                      // 0x00D8(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K33TunnelPulsationComponent">();
	}
	static class UK33TunnelPulsationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK33TunnelPulsationComponent>();
	}
};
static_assert(alignof(UK33TunnelPulsationComponent) == 0x000008, "Wrong alignment on UK33TunnelPulsationComponent");
static_assert(sizeof(UK33TunnelPulsationComponent) == 0x000120, "Wrong size on UK33TunnelPulsationComponent");
static_assert(offsetof(UK33TunnelPulsationComponent, _initialPulsePoolSize) == 0x0000A8, "Member 'UK33TunnelPulsationComponent::_initialPulsePoolSize' has a wrong offset!");
static_assert(offsetof(UK33TunnelPulsationComponent, _tunnelPulseActorClass) == 0x0000B0, "Member 'UK33TunnelPulsationComponent::_tunnelPulseActorClass' has a wrong offset!");
static_assert(offsetof(UK33TunnelPulsationComponent, _pulseSpeed) == 0x0000B8, "Member 'UK33TunnelPulsationComponent::_pulseSpeed' has a wrong offset!");
static_assert(offsetof(UK33TunnelPulsationComponent, _timeBetweenPulseWaves) == 0x0000BC, "Member 'UK33TunnelPulsationComponent::_timeBetweenPulseWaves' has a wrong offset!");
static_assert(offsetof(UK33TunnelPulsationComponent, _numberOfPulsesPerWaves) == 0x0000C0, "Member 'UK33TunnelPulsationComponent::_numberOfPulsesPerWaves' has a wrong offset!");
static_assert(offsetof(UK33TunnelPulsationComponent, _timeBetweenPulsesInWave) == 0x0000C4, "Member 'UK33TunnelPulsationComponent::_timeBetweenPulsesInWave' has a wrong offset!");
static_assert(offsetof(UK33TunnelPulsationComponent, _minDistanceToTriggerNextPulseWave) == 0x0000C8, "Member 'UK33TunnelPulsationComponent::_minDistanceToTriggerNextPulseWave' has a wrong offset!");
static_assert(offsetof(UK33TunnelPulsationComponent, _pool) == 0x0000D0, "Member 'UK33TunnelPulsationComponent::_pool' has a wrong offset!");

// Class TheK33.K33SurvivorDetectionComponent
// 0x01A0 (0x0248 - 0x00A8)
class UK33SurvivorDetectionComponent final : public UActorComponent
{
public:
	struct FTunableStat                           _detectionDistance;                                // 0x00A8(0x0080)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _survivorStatusEffect;                             // 0x0128(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_130[0x58];                                     // 0x0130(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class ACamperPlayer>>   _survivorsInRange;                                 // 0x0188(0x0010)(Net, ZeroConstructor, RepNotify, UObjectWrapper, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _bufferTimeBeforeActivatingSurvivorDetection;      // 0x0198(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1C0[0x88];                                     // 0x01C0(0x0088)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnSurvivorInRangeChanged(const bool InRange, class ACamperPlayer* Player);
	void OnRep_SurvivorsInRange();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K33SurvivorDetectionComponent">();
	}
	static class UK33SurvivorDetectionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK33SurvivorDetectionComponent>();
	}
};
static_assert(alignof(UK33SurvivorDetectionComponent) == 0x000008, "Wrong alignment on UK33SurvivorDetectionComponent");
static_assert(sizeof(UK33SurvivorDetectionComponent) == 0x000248, "Wrong size on UK33SurvivorDetectionComponent");
static_assert(offsetof(UK33SurvivorDetectionComponent, _detectionDistance) == 0x0000A8, "Member 'UK33SurvivorDetectionComponent::_detectionDistance' has a wrong offset!");
static_assert(offsetof(UK33SurvivorDetectionComponent, _survivorStatusEffect) == 0x000128, "Member 'UK33SurvivorDetectionComponent::_survivorStatusEffect' has a wrong offset!");
static_assert(offsetof(UK33SurvivorDetectionComponent, _survivorsInRange) == 0x000188, "Member 'UK33SurvivorDetectionComponent::_survivorsInRange' has a wrong offset!");
static_assert(offsetof(UK33SurvivorDetectionComponent, _bufferTimeBeforeActivatingSurvivorDetection) == 0x000198, "Member 'UK33SurvivorDetectionComponent::_bufferTimeBeforeActivatingSurvivorDetection' has a wrong offset!");

// Class TheK33.K33SurvivorTurretDestructionComponent
// 0x0010 (0x00B8 - 0x00A8)
class UK33SurvivorTurretDestructionComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x10];                                      // 0x00A8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K33SurvivorTurretDestructionComponent">();
	}
	static class UK33SurvivorTurretDestructionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK33SurvivorTurretDestructionComponent>();
	}
};
static_assert(alignof(UK33SurvivorTurretDestructionComponent) == 0x000008, "Wrong alignment on UK33SurvivorTurretDestructionComponent");
static_assert(sizeof(UK33SurvivorTurretDestructionComponent) == 0x0000B8, "Wrong size on UK33SurvivorTurretDestructionComponent");

// Class TheK33.K33TailAttack
// 0x0140 (0x0560 - 0x0420)
class UK33TailAttack final : public UPounceAttack
{
public:
	uint8                                         Pad_420[0x8];                                      // 0x0420(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _useGamepadEmulationForYaw;                        // 0x0428(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _yawPitchSpeedSmoothingTime;                       // 0x0450(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _yawSpeedResetSmoothingTime;                       // 0x0478(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _yawScale;                                         // 0x04A0(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _pitchScale;                                       // 0x04C8(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _yawPitchDelayTime;                                // 0x04F0(0x0028)(Edit, NativeAccessSpecifierPrivate)
	uint8                                         Pad_518[0x48];                                     // 0x0518(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K33TailAttack">();
	}
	static class UK33TailAttack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK33TailAttack>();
	}
};
static_assert(alignof(UK33TailAttack) == 0x000010, "Wrong alignment on UK33TailAttack");
static_assert(sizeof(UK33TailAttack) == 0x000560, "Wrong size on UK33TailAttack");
static_assert(offsetof(UK33TailAttack, _useGamepadEmulationForYaw) == 0x000428, "Member 'UK33TailAttack::_useGamepadEmulationForYaw' has a wrong offset!");
static_assert(offsetof(UK33TailAttack, _yawPitchSpeedSmoothingTime) == 0x000450, "Member 'UK33TailAttack::_yawPitchSpeedSmoothingTime' has a wrong offset!");
static_assert(offsetof(UK33TailAttack, _yawSpeedResetSmoothingTime) == 0x000478, "Member 'UK33TailAttack::_yawSpeedResetSmoothingTime' has a wrong offset!");
static_assert(offsetof(UK33TailAttack, _yawScale) == 0x0004A0, "Member 'UK33TailAttack::_yawScale' has a wrong offset!");
static_assert(offsetof(UK33TailAttack, _pitchScale) == 0x0004C8, "Member 'UK33TailAttack::_pitchScale' has a wrong offset!");
static_assert(offsetof(UK33TailAttack, _yawPitchDelayTime) == 0x0004F0, "Member 'UK33TailAttack::_yawPitchDelayTime' has a wrong offset!");

// Class TheK33.K33TunnelProceduralConnection
// 0x00D0 (0x0370 - 0x02A0)
class AK33TunnelProceduralConnection final : public AActor
{
public:
	uint8                                         Pad_2A0[0x8];                                      // 0x02A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USplineComponent*                       _splineComponent;                                  // 0x02A8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USceneComponent*                        _splineMeshContainer;                              // 0x02B0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UK33SelectedControlStationLinkedActorOutlineUpdateStrategy* _outlineStrategy;                                  // 0x02B8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDBDOutlineComponent*                   _outlineComponent;                                 // 0x02C0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticMesh*                            _staticMeshComponent;                              // 0x02C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterial*                              _staticMeshMaterial;                               // 0x02D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ESplineMeshAxis                               _splineMeshAxis;                                   // 0x02D8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D9[0x7];                                      // 0x02D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              _meshScaling;                                      // 0x02E0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USplineComponent*                       _splineMeshComponent;                              // 0x02F0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class USplineMeshComponent*>           _splineMeshes;                                     // 0x02F8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_308[0x68];                                     // 0x0308(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K33TunnelProceduralConnection">();
	}
	static class AK33TunnelProceduralConnection* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK33TunnelProceduralConnection>();
	}
};
static_assert(alignof(AK33TunnelProceduralConnection) == 0x000008, "Wrong alignment on AK33TunnelProceduralConnection");
static_assert(sizeof(AK33TunnelProceduralConnection) == 0x000370, "Wrong size on AK33TunnelProceduralConnection");
static_assert(offsetof(AK33TunnelProceduralConnection, _splineComponent) == 0x0002A8, "Member 'AK33TunnelProceduralConnection::_splineComponent' has a wrong offset!");
static_assert(offsetof(AK33TunnelProceduralConnection, _splineMeshContainer) == 0x0002B0, "Member 'AK33TunnelProceduralConnection::_splineMeshContainer' has a wrong offset!");
static_assert(offsetof(AK33TunnelProceduralConnection, _outlineStrategy) == 0x0002B8, "Member 'AK33TunnelProceduralConnection::_outlineStrategy' has a wrong offset!");
static_assert(offsetof(AK33TunnelProceduralConnection, _outlineComponent) == 0x0002C0, "Member 'AK33TunnelProceduralConnection::_outlineComponent' has a wrong offset!");
static_assert(offsetof(AK33TunnelProceduralConnection, _staticMeshComponent) == 0x0002C8, "Member 'AK33TunnelProceduralConnection::_staticMeshComponent' has a wrong offset!");
static_assert(offsetof(AK33TunnelProceduralConnection, _staticMeshMaterial) == 0x0002D0, "Member 'AK33TunnelProceduralConnection::_staticMeshMaterial' has a wrong offset!");
static_assert(offsetof(AK33TunnelProceduralConnection, _splineMeshAxis) == 0x0002D8, "Member 'AK33TunnelProceduralConnection::_splineMeshAxis' has a wrong offset!");
static_assert(offsetof(AK33TunnelProceduralConnection, _meshScaling) == 0x0002E0, "Member 'AK33TunnelProceduralConnection::_meshScaling' has a wrong offset!");
static_assert(offsetof(AK33TunnelProceduralConnection, _splineMeshComponent) == 0x0002F0, "Member 'AK33TunnelProceduralConnection::_splineMeshComponent' has a wrong offset!");
static_assert(offsetof(AK33TunnelProceduralConnection, _splineMeshes) == 0x0002F8, "Member 'AK33TunnelProceduralConnection::_splineMeshes' has a wrong offset!");

// Class TheK33.K33TailAttackOpenSubstate
// 0x0000 (0x0130 - 0x0130)
class UK33TailAttackOpenSubstate final : public UPounceAttackOpenSubstate
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K33TailAttackOpenSubstate">();
	}
	static class UK33TailAttackOpenSubstate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK33TailAttackOpenSubstate>();
	}
};
static_assert(alignof(UK33TailAttackOpenSubstate) == 0x000008, "Wrong alignment on UK33TailAttackOpenSubstate");
static_assert(sizeof(UK33TailAttackOpenSubstate) == 0x000130, "Wrong size on UK33TailAttackOpenSubstate");

// Class TheK33.K33TurretAttackableComponent
// 0x0000 (0x00A8 - 0x00A8)
class UK33TurretAttackableComponent final : public UAttackableComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K33TurretAttackableComponent">();
	}
	static class UK33TurretAttackableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK33TurretAttackableComponent>();
	}
};
static_assert(alignof(UK33TurretAttackableComponent) == 0x000008, "Wrong alignment on UK33TurretAttackableComponent");
static_assert(sizeof(UK33TurretAttackableComponent) == 0x0000A8, "Wrong size on UK33TurretAttackableComponent");

// Class TheK33.K33TailAttackHittingSubstate
// 0x0228 (0x03C8 - 0x01A0)
class UK33TailAttackHittingSubstate final : public UPounceAttackHittingSubstate
{
public:
	struct FDBDTunableRowHandle                   _useGamepadEmulationForYaw;                        // 0x01A0(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _yawSpeedResetSmoothingTime;                       // 0x01C8(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _attackSphereTraceRadius;                          // 0x01F0(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _tailAttackLength;                                 // 0x0218(0x0028)(Edit, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _tailMovementCurve;                                // 0x0240(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _tailAttackFromYOffset;                            // 0x0248(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _tailAttackStartHeight;                            // 0x0270(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _tailAttackEndHeight;                              // 0x0298(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _tailAttackEndPointInitialHeightOffset;            // 0x02C0(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _tailAttackEndPointEndHeightOffset;                // 0x02E8(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _maxSweepLength;                                   // 0x0310(0x0028)(Edit, NativeAccessSpecifierPrivate)
	float                                         _minDistanceForFarObstructionHit;                  // 0x0338(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_33C[0x8C];                                     // 0x033C(0x008C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K33TailAttackHittingSubstate">();
	}
	static class UK33TailAttackHittingSubstate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK33TailAttackHittingSubstate>();
	}
};
static_assert(alignof(UK33TailAttackHittingSubstate) == 0x000008, "Wrong alignment on UK33TailAttackHittingSubstate");
static_assert(sizeof(UK33TailAttackHittingSubstate) == 0x0003C8, "Wrong size on UK33TailAttackHittingSubstate");
static_assert(offsetof(UK33TailAttackHittingSubstate, _useGamepadEmulationForYaw) == 0x0001A0, "Member 'UK33TailAttackHittingSubstate::_useGamepadEmulationForYaw' has a wrong offset!");
static_assert(offsetof(UK33TailAttackHittingSubstate, _yawSpeedResetSmoothingTime) == 0x0001C8, "Member 'UK33TailAttackHittingSubstate::_yawSpeedResetSmoothingTime' has a wrong offset!");
static_assert(offsetof(UK33TailAttackHittingSubstate, _attackSphereTraceRadius) == 0x0001F0, "Member 'UK33TailAttackHittingSubstate::_attackSphereTraceRadius' has a wrong offset!");
static_assert(offsetof(UK33TailAttackHittingSubstate, _tailAttackLength) == 0x000218, "Member 'UK33TailAttackHittingSubstate::_tailAttackLength' has a wrong offset!");
static_assert(offsetof(UK33TailAttackHittingSubstate, _tailMovementCurve) == 0x000240, "Member 'UK33TailAttackHittingSubstate::_tailMovementCurve' has a wrong offset!");
static_assert(offsetof(UK33TailAttackHittingSubstate, _tailAttackFromYOffset) == 0x000248, "Member 'UK33TailAttackHittingSubstate::_tailAttackFromYOffset' has a wrong offset!");
static_assert(offsetof(UK33TailAttackHittingSubstate, _tailAttackStartHeight) == 0x000270, "Member 'UK33TailAttackHittingSubstate::_tailAttackStartHeight' has a wrong offset!");
static_assert(offsetof(UK33TailAttackHittingSubstate, _tailAttackEndHeight) == 0x000298, "Member 'UK33TailAttackHittingSubstate::_tailAttackEndHeight' has a wrong offset!");
static_assert(offsetof(UK33TailAttackHittingSubstate, _tailAttackEndPointInitialHeightOffset) == 0x0002C0, "Member 'UK33TailAttackHittingSubstate::_tailAttackEndPointInitialHeightOffset' has a wrong offset!");
static_assert(offsetof(UK33TailAttackHittingSubstate, _tailAttackEndPointEndHeightOffset) == 0x0002E8, "Member 'UK33TailAttackHittingSubstate::_tailAttackEndPointEndHeightOffset' has a wrong offset!");
static_assert(offsetof(UK33TailAttackHittingSubstate, _maxSweepLength) == 0x000310, "Member 'UK33TailAttackHittingSubstate::_maxSweepLength' has a wrong offset!");
static_assert(offsetof(UK33TailAttackHittingSubstate, _minDistanceForFarObstructionHit) == 0x000338, "Member 'UK33TailAttackHittingSubstate::_minDistanceForFarObstructionHit' has a wrong offset!");

// Class TheK33.K33TailAttackSuccessSubstate
// 0x0000 (0x0118 - 0x0118)
class UK33TailAttackSuccessSubstate final : public UPounceAttackSuccessSubstate
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K33TailAttackSuccessSubstate">();
	}
	static class UK33TailAttackSuccessSubstate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK33TailAttackSuccessSubstate>();
	}
};
static_assert(alignof(UK33TailAttackSuccessSubstate) == 0x000008, "Wrong alignment on UK33TailAttackSuccessSubstate");
static_assert(sizeof(UK33TailAttackSuccessSubstate) == 0x000118, "Wrong size on UK33TailAttackSuccessSubstate");

// Class TheK33.K33TailAttackMissSubstate
// 0x0000 (0x0120 - 0x0120)
class UK33TailAttackMissSubstate final : public UPounceAttackMissSubstate
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K33TailAttackMissSubstate">();
	}
	static class UK33TailAttackMissSubstate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK33TailAttackMissSubstate>();
	}
};
static_assert(alignof(UK33TailAttackMissSubstate) == 0x000008, "Wrong alignment on UK33TailAttackMissSubstate");
static_assert(sizeof(UK33TailAttackMissSubstate) == 0x000120, "Wrong size on UK33TailAttackMissSubstate");

// Class TheK33.K33TailAttackObstructSubstate
// 0x0000 (0x0128 - 0x0128)
class UK33TailAttackObstructSubstate final : public UPounceAttackObstructSubstate
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K33TailAttackObstructSubstate">();
	}
	static class UK33TailAttackObstructSubstate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK33TailAttackObstructSubstate>();
	}
};
static_assert(alignof(UK33TailAttackObstructSubstate) == 0x000008, "Wrong alignment on UK33TailAttackObstructSubstate");
static_assert(sizeof(UK33TailAttackObstructSubstate) == 0x000128, "Wrong size on UK33TailAttackObstructSubstate");

// Class TheK33.K33TunnelBlockCosmetic
// 0x0070 (0x0310 - 0x02A0)
class AK33TunnelBlockCosmetic final : public AActor
{
public:
	uint8                                         Pad_2A0[0x8];                                      // 0x02A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _hasTunnelExitTile;                                // 0x02A8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A9[0x7];                                      // 0x02A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USplineComponent*                       _splineComponent;                                  // 0x02B0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USceneComponent*                        _rootComponent;                                    // 0x02B8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class AK33TunnelProceduralConnection> _tunnelProceduralConnectionClass;                  // 0x02C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint32                                        _numberOfConnectionActors;                         // 0x02C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _initialConnectionOffsetFromCenter;                // 0x02CC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _endConnectionOffsetFromCenter;                    // 0x02D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _lengthBetweenSplinePoints;                        // 0x02D4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _rotationPerSplinePoint;                           // 0x02D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _firstSplinePointOffsetValue;                      // 0x02DC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _secondSplinePointOffsetValue;                     // 0x02E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2E4[0x4];                                      // 0x02E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AK33TunnelProceduralConnection*> _tunnelProceduralConnections;                      // 0x02E8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<TWeakObjectPtr<class USceneComponent>> _vfxPathLightsTransforms;                          // 0x02F8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_308[0x8];                                      // 0x0308(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_DisableTunnelVFXPathLight();
	void Cosmetic_EnableTunnelVFXPathLight(const struct FVector& Location, const struct FRotator& Rotation);
	void Cosmetic_OnTunnelBlockExitSelected(bool IsSelected);
	void Cosmetic_SetTunnelExitAsBlocked(bool IsBlocked);
	void Cosmetic_ShowTunnelBlockExit();

	struct FVector GetExitTunnelLocation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K33TunnelBlockCosmetic">();
	}
	static class AK33TunnelBlockCosmetic* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK33TunnelBlockCosmetic>();
	}
};
static_assert(alignof(AK33TunnelBlockCosmetic) == 0x000008, "Wrong alignment on AK33TunnelBlockCosmetic");
static_assert(sizeof(AK33TunnelBlockCosmetic) == 0x000310, "Wrong size on AK33TunnelBlockCosmetic");
static_assert(offsetof(AK33TunnelBlockCosmetic, _hasTunnelExitTile) == 0x0002A8, "Member 'AK33TunnelBlockCosmetic::_hasTunnelExitTile' has a wrong offset!");
static_assert(offsetof(AK33TunnelBlockCosmetic, _splineComponent) == 0x0002B0, "Member 'AK33TunnelBlockCosmetic::_splineComponent' has a wrong offset!");
static_assert(offsetof(AK33TunnelBlockCosmetic, _rootComponent) == 0x0002B8, "Member 'AK33TunnelBlockCosmetic::_rootComponent' has a wrong offset!");
static_assert(offsetof(AK33TunnelBlockCosmetic, _tunnelProceduralConnectionClass) == 0x0002C0, "Member 'AK33TunnelBlockCosmetic::_tunnelProceduralConnectionClass' has a wrong offset!");
static_assert(offsetof(AK33TunnelBlockCosmetic, _numberOfConnectionActors) == 0x0002C8, "Member 'AK33TunnelBlockCosmetic::_numberOfConnectionActors' has a wrong offset!");
static_assert(offsetof(AK33TunnelBlockCosmetic, _initialConnectionOffsetFromCenter) == 0x0002CC, "Member 'AK33TunnelBlockCosmetic::_initialConnectionOffsetFromCenter' has a wrong offset!");
static_assert(offsetof(AK33TunnelBlockCosmetic, _endConnectionOffsetFromCenter) == 0x0002D0, "Member 'AK33TunnelBlockCosmetic::_endConnectionOffsetFromCenter' has a wrong offset!");
static_assert(offsetof(AK33TunnelBlockCosmetic, _lengthBetweenSplinePoints) == 0x0002D4, "Member 'AK33TunnelBlockCosmetic::_lengthBetweenSplinePoints' has a wrong offset!");
static_assert(offsetof(AK33TunnelBlockCosmetic, _rotationPerSplinePoint) == 0x0002D8, "Member 'AK33TunnelBlockCosmetic::_rotationPerSplinePoint' has a wrong offset!");
static_assert(offsetof(AK33TunnelBlockCosmetic, _firstSplinePointOffsetValue) == 0x0002DC, "Member 'AK33TunnelBlockCosmetic::_firstSplinePointOffsetValue' has a wrong offset!");
static_assert(offsetof(AK33TunnelBlockCosmetic, _secondSplinePointOffsetValue) == 0x0002E0, "Member 'AK33TunnelBlockCosmetic::_secondSplinePointOffsetValue' has a wrong offset!");
static_assert(offsetof(AK33TunnelBlockCosmetic, _tunnelProceduralConnections) == 0x0002E8, "Member 'AK33TunnelBlockCosmetic::_tunnelProceduralConnections' has a wrong offset!");
static_assert(offsetof(AK33TunnelBlockCosmetic, _vfxPathLightsTransforms) == 0x0002F8, "Member 'AK33TunnelBlockCosmetic::_vfxPathLightsTransforms' has a wrong offset!");

// Class TheK33.K33TurretAudioVolumeAdjuster
// 0x00A0 (0x0148 - 0x00A8)
class UK33TurretAudioVolumeAdjuster final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x94];                                      // 0x00A8(0x0094)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _distanceToTrackTurrets;                           // 0x013C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_140[0x8];                                      // 0x0140(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K33TurretAudioVolumeAdjuster">();
	}
	static class UK33TurretAudioVolumeAdjuster* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK33TurretAudioVolumeAdjuster>();
	}
};
static_assert(alignof(UK33TurretAudioVolumeAdjuster) == 0x000008, "Wrong alignment on UK33TurretAudioVolumeAdjuster");
static_assert(sizeof(UK33TurretAudioVolumeAdjuster) == 0x000148, "Wrong size on UK33TurretAudioVolumeAdjuster");
static_assert(offsetof(UK33TurretAudioVolumeAdjuster, _distanceToTrackTurrets) == 0x00013C, "Member 'UK33TurretAudioVolumeAdjuster::_distanceToTrackTurrets' has a wrong offset!");

// Class TheK33.K33TurretBeingCollectedFromControlStationState
// 0x0000 (0x0050 - 0x0050)
class UK33TurretBeingCollectedFromControlStationState final : public UBaseReplicatedState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K33TurretBeingCollectedFromControlStationState">();
	}
	static class UK33TurretBeingCollectedFromControlStationState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK33TurretBeingCollectedFromControlStationState>();
	}
};
static_assert(alignof(UK33TurretBeingCollectedFromControlStationState) == 0x000008, "Wrong alignment on UK33TurretBeingCollectedFromControlStationState");
static_assert(sizeof(UK33TurretBeingCollectedFromControlStationState) == 0x000050, "Wrong size on UK33TurretBeingCollectedFromControlStationState");

// Class TheK33.K33TurretBeingDeployedState
// 0x0018 (0x0068 - 0x0050)
class UK33TurretBeingDeployedState final : public UBaseReplicatedState
{
public:
	uint8                                         Pad_50[0x18];                                      // 0x0050(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K33TurretBeingDeployedState">();
	}
	static class UK33TurretBeingDeployedState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK33TurretBeingDeployedState>();
	}
};
static_assert(alignof(UK33TurretBeingDeployedState) == 0x000008, "Wrong alignment on UK33TurretBeingDeployedState");
static_assert(sizeof(UK33TurretBeingDeployedState) == 0x000068, "Wrong size on UK33TurretBeingDeployedState");

// Class TheK33.K33TurretBeingRepairedState
// 0x0000 (0x0050 - 0x0050)
class UK33TurretBeingRepairedState final : public UBaseReplicatedState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K33TurretBeingRepairedState">();
	}
	static class UK33TurretBeingRepairedState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK33TurretBeingRepairedState>();
	}
};
static_assert(alignof(UK33TurretBeingRepairedState) == 0x000008, "Wrong alignment on UK33TurretBeingRepairedState");
static_assert(sizeof(UK33TurretBeingRepairedState) == 0x000050, "Wrong size on UK33TurretBeingRepairedState");

// Class TheK33.K33TurretBeingUndeployedState
// 0x0018 (0x0068 - 0x0050)
class UK33TurretBeingUndeployedState final : public UBaseReplicatedState
{
public:
	uint8                                         Pad_50[0x18];                                      // 0x0050(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K33TurretBeingUndeployedState">();
	}
	static class UK33TurretBeingUndeployedState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK33TurretBeingUndeployedState>();
	}
};
static_assert(alignof(UK33TurretBeingUndeployedState) == 0x000008, "Wrong alignment on UK33TurretBeingUndeployedState");
static_assert(sizeof(UK33TurretBeingUndeployedState) == 0x000068, "Wrong size on UK33TurretBeingUndeployedState");

// Class TheK33.K33TurretCarryableState
// 0x0028 (0x0078 - 0x0050)
class UK33TurretCarryableState final : public UBaseReplicatedState
{
public:
	uint8                                         Pad_50[0x28];                                      // 0x0050(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K33TurretCarryableState">();
	}
	static class UK33TurretCarryableState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK33TurretCarryableState>();
	}
};
static_assert(alignof(UK33TurretCarryableState) == 0x000008, "Wrong alignment on UK33TurretCarryableState");
static_assert(sizeof(UK33TurretCarryableState) == 0x000078, "Wrong size on UK33TurretCarryableState");

// Class TheK33.K33TurretCollisionsHandler
// 0x0020 (0x00C8 - 0x00A8)
class UK33TurretCollisionsHandler final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x20];                                      // 0x00A8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K33TurretCollisionsHandler">();
	}
	static class UK33TurretCollisionsHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK33TurretCollisionsHandler>();
	}
};
static_assert(alignof(UK33TurretCollisionsHandler) == 0x000008, "Wrong alignment on UK33TurretCollisionsHandler");
static_assert(sizeof(UK33TurretCollisionsHandler) == 0x0000C8, "Wrong size on UK33TurretCollisionsHandler");

// Class TheK33.K33TurretDamageComponent
// 0x0218 (0x02C0 - 0x00A8)
class UK33TurretDamageComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x30];                                      // 0x00A8(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _currentDamageAmount;                              // 0x00D8(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_DC[0x4];                                       // 0x00DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTagStateBool                          _isAttackedByTurret;                               // 0x00E0(0x0048)(Net, RepNotify, NativeAccessSpecifierPrivate)
	uint8                                         Pad_128[0x48];                                     // 0x0128(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UStatusEffect>              _stunnedAfterFullyDamagedEffect;                   // 0x0170(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _stunnedAfterFullyDamagedDuration;                 // 0x0178(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _maxDamageAmount;                                  // 0x01A0(0x0080)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _damageReductionRate;                              // 0x0220(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _damageRatePerTurretCurveFloat;                    // 0x0248(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _damageReductionDelayDuration;                     // 0x0250(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_278[0x48];                                     // 0x0278(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Multicast_ReceivedMaxDamage();
	void OnRep_CurrentDamageAmount();
	void OnRep_IsAttackedByTurret();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K33TurretDamageComponent">();
	}
	static class UK33TurretDamageComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK33TurretDamageComponent>();
	}
};
static_assert(alignof(UK33TurretDamageComponent) == 0x000008, "Wrong alignment on UK33TurretDamageComponent");
static_assert(sizeof(UK33TurretDamageComponent) == 0x0002C0, "Wrong size on UK33TurretDamageComponent");
static_assert(offsetof(UK33TurretDamageComponent, _currentDamageAmount) == 0x0000D8, "Member 'UK33TurretDamageComponent::_currentDamageAmount' has a wrong offset!");
static_assert(offsetof(UK33TurretDamageComponent, _isAttackedByTurret) == 0x0000E0, "Member 'UK33TurretDamageComponent::_isAttackedByTurret' has a wrong offset!");
static_assert(offsetof(UK33TurretDamageComponent, _stunnedAfterFullyDamagedEffect) == 0x000170, "Member 'UK33TurretDamageComponent::_stunnedAfterFullyDamagedEffect' has a wrong offset!");
static_assert(offsetof(UK33TurretDamageComponent, _stunnedAfterFullyDamagedDuration) == 0x000178, "Member 'UK33TurretDamageComponent::_stunnedAfterFullyDamagedDuration' has a wrong offset!");
static_assert(offsetof(UK33TurretDamageComponent, _maxDamageAmount) == 0x0001A0, "Member 'UK33TurretDamageComponent::_maxDamageAmount' has a wrong offset!");
static_assert(offsetof(UK33TurretDamageComponent, _damageReductionRate) == 0x000220, "Member 'UK33TurretDamageComponent::_damageReductionRate' has a wrong offset!");
static_assert(offsetof(UK33TurretDamageComponent, _damageRatePerTurretCurveFloat) == 0x000248, "Member 'UK33TurretDamageComponent::_damageRatePerTurretCurveFloat' has a wrong offset!");
static_assert(offsetof(UK33TurretDamageComponent, _damageReductionDelayDuration) == 0x000250, "Member 'UK33TurretDamageComponent::_damageReductionDelayDuration' has a wrong offset!");

// Class TheK33.K33TurretDangerPredictionComponent
// 0x0038 (0x0148 - 0x0110)
class UK33TurretDangerPredictionComponent final : public UDBDDangerPredictionComponent
{
public:
	float                                         MinimumLureDistanceFromKiller;                     // 0x0110(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdealDistanceBehindTurret;                         // 0x0114(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxPenaltyAtAngle;                                 // 0x0118(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11C[0x2C];                                     // 0x011C(0x002C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K33TurretDangerPredictionComponent">();
	}
	static class UK33TurretDangerPredictionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK33TurretDangerPredictionComponent>();
	}
};
static_assert(alignof(UK33TurretDangerPredictionComponent) == 0x000008, "Wrong alignment on UK33TurretDangerPredictionComponent");
static_assert(sizeof(UK33TurretDangerPredictionComponent) == 0x000148, "Wrong size on UK33TurretDangerPredictionComponent");
static_assert(offsetof(UK33TurretDangerPredictionComponent, MinimumLureDistanceFromKiller) == 0x000110, "Member 'UK33TurretDangerPredictionComponent::MinimumLureDistanceFromKiller' has a wrong offset!");
static_assert(offsetof(UK33TurretDangerPredictionComponent, IdealDistanceBehindTurret) == 0x000114, "Member 'UK33TurretDangerPredictionComponent::IdealDistanceBehindTurret' has a wrong offset!");
static_assert(offsetof(UK33TurretDangerPredictionComponent, MaxPenaltyAtAngle) == 0x000118, "Member 'UK33TurretDangerPredictionComponent::MaxPenaltyAtAngle' has a wrong offset!");

// Class TheK33.K33TurretDeployedState
// 0x0018 (0x0068 - 0x0050)
class UK33TurretDeployedState final : public UBaseReplicatedState
{
public:
	uint8                                         Pad_50[0x18];                                      // 0x0050(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K33TurretDeployedState">();
	}
	static class UK33TurretDeployedState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK33TurretDeployedState>();
	}
};
static_assert(alignof(UK33TurretDeployedState) == 0x000008, "Wrong alignment on UK33TurretDeployedState");
static_assert(sizeof(UK33TurretDeployedState) == 0x000068, "Wrong size on UK33TurretDeployedState");

// Class TheK33.K33TurretDestroyedState
// 0x0118 (0x0168 - 0x0050)
class UK33TurretDestroyedState final : public UBaseReplicatedState
{
public:
	struct FTunableStat                           _destroyedDuration;                                // 0x0050(0x0080)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	float                                         _timeBeforeDisappearance;                          // 0x00D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D4[0x94];                                      // 0x00D4(0x0094)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K33TurretDestroyedState">();
	}
	static class UK33TurretDestroyedState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK33TurretDestroyedState>();
	}
};
static_assert(alignof(UK33TurretDestroyedState) == 0x000008, "Wrong alignment on UK33TurretDestroyedState");
static_assert(sizeof(UK33TurretDestroyedState) == 0x000168, "Wrong size on UK33TurretDestroyedState");
static_assert(offsetof(UK33TurretDestroyedState, _destroyedDuration) == 0x000050, "Member 'UK33TurretDestroyedState::_destroyedDuration' has a wrong offset!");
static_assert(offsetof(UK33TurretDestroyedState, _timeBeforeDisappearance) == 0x0000D0, "Member 'UK33TurretDestroyedState::_timeBeforeDisappearance' has a wrong offset!");

// Class TheK33.K33TurretDestructionComponent
// 0x00F0 (0x0198 - 0x00A8)
class UK33TurretDestructionComponent final : public UActorComponent
{
public:
	struct FDBDTunableRowHandle                   _autoDestroyTime;                                  // 0x00A8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _autoDestroyPauseSurvivorRange;                    // 0x00D0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F8[0xA0];                                      // 0x00F8(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetTurretDestructionDisappearanceDelay() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K33TurretDestructionComponent">();
	}
	static class UK33TurretDestructionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK33TurretDestructionComponent>();
	}
};
static_assert(alignof(UK33TurretDestructionComponent) == 0x000008, "Wrong alignment on UK33TurretDestructionComponent");
static_assert(sizeof(UK33TurretDestructionComponent) == 0x000198, "Wrong size on UK33TurretDestructionComponent");
static_assert(offsetof(UK33TurretDestructionComponent, _autoDestroyTime) == 0x0000A8, "Member 'UK33TurretDestructionComponent::_autoDestroyTime' has a wrong offset!");
static_assert(offsetof(UK33TurretDestructionComponent, _autoDestroyPauseSurvivorRange) == 0x0000D0, "Member 'UK33TurretDestructionComponent::_autoDestroyPauseSurvivorRange' has a wrong offset!");

// Class TheK33.K33TurretInPoolState
// 0x0018 (0x0068 - 0x0050)
class UK33TurretInPoolState final : public UBaseReplicatedState
{
public:
	uint8                                         Pad_50[0x18];                                      // 0x0050(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K33TurretInPoolState">();
	}
	static class UK33TurretInPoolState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK33TurretInPoolState>();
	}
};
static_assert(alignof(UK33TurretInPoolState) == 0x000008, "Wrong alignment on UK33TurretInPoolState");
static_assert(sizeof(UK33TurretInPoolState) == 0x000068, "Wrong size on UK33TurretInPoolState");

// Class TheK33.K33TurretKillerAttackComponent
// 0x0238 (0x02E0 - 0x00A8)
class UK33TurretKillerAttackComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x18];                                      // 0x00A8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _isAttacking;                                      // 0x00C0(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C1[0xDF];                                      // 0x00C1(0x00DF)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRaycastProperties>             _bipedRaycastProperties;                           // 0x01A0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TArray<struct FRaycastProperties>             _quadrupedRaycastProperties;                       // 0x01B0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _killerDetectionRadius;                            // 0x01C0(0x0080)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FActorPairQueryHeightRange             _killerDetectionHeightRange;                       // 0x0240(0x0008)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	float                                         _sphereTraceRadius;                                // 0x0248(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_24C[0x4];                                      // 0x024C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  _stateTagsPreventingKillerDetection;               // 0x0250(0x0020)(Edit, NativeAccessSpecifierPrivate)
	uint8                                         Pad_270[0x70];                                     // 0x0270(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K33TurretKillerAttackComponent">();
	}
	static class UK33TurretKillerAttackComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK33TurretKillerAttackComponent>();
	}
};
static_assert(alignof(UK33TurretKillerAttackComponent) == 0x000008, "Wrong alignment on UK33TurretKillerAttackComponent");
static_assert(sizeof(UK33TurretKillerAttackComponent) == 0x0002E0, "Wrong size on UK33TurretKillerAttackComponent");
static_assert(offsetof(UK33TurretKillerAttackComponent, _isAttacking) == 0x0000C0, "Member 'UK33TurretKillerAttackComponent::_isAttacking' has a wrong offset!");
static_assert(offsetof(UK33TurretKillerAttackComponent, _bipedRaycastProperties) == 0x0001A0, "Member 'UK33TurretKillerAttackComponent::_bipedRaycastProperties' has a wrong offset!");
static_assert(offsetof(UK33TurretKillerAttackComponent, _quadrupedRaycastProperties) == 0x0001B0, "Member 'UK33TurretKillerAttackComponent::_quadrupedRaycastProperties' has a wrong offset!");
static_assert(offsetof(UK33TurretKillerAttackComponent, _killerDetectionRadius) == 0x0001C0, "Member 'UK33TurretKillerAttackComponent::_killerDetectionRadius' has a wrong offset!");
static_assert(offsetof(UK33TurretKillerAttackComponent, _killerDetectionHeightRange) == 0x000240, "Member 'UK33TurretKillerAttackComponent::_killerDetectionHeightRange' has a wrong offset!");
static_assert(offsetof(UK33TurretKillerAttackComponent, _sphereTraceRadius) == 0x000248, "Member 'UK33TurretKillerAttackComponent::_sphereTraceRadius' has a wrong offset!");
static_assert(offsetof(UK33TurretKillerAttackComponent, _stateTagsPreventingKillerDetection) == 0x000250, "Member 'UK33TurretKillerAttackComponent::_stateTagsPreventingKillerDetection' has a wrong offset!");

// Class TheK33.K33TurretLaserComponent
// 0x0020 (0x00C8 - 0x00A8)
class UK33TurretLaserComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x20];                                      // 0x00A8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnLocallyObservedPlayerChanged();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K33TurretLaserComponent">();
	}
	static class UK33TurretLaserComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK33TurretLaserComponent>();
	}
};
static_assert(alignof(UK33TurretLaserComponent) == 0x000008, "Wrong alignment on UK33TurretLaserComponent");
static_assert(sizeof(UK33TurretLaserComponent) == 0x0000C8, "Wrong size on UK33TurretLaserComponent");

// Class TheK33.K33TurretMalfunctionComponent
// 0x0108 (0x01B0 - 0x00A8)
class UK33TurretMalfunctionComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x60];                                      // 0x00A8(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTunableStat                           _malfunctionDuration;                              // 0x0108(0x0080)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_188[0x28];                                     // 0x0188(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K33TurretMalfunctionComponent">();
	}
	static class UK33TurretMalfunctionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK33TurretMalfunctionComponent>();
	}
};
static_assert(alignof(UK33TurretMalfunctionComponent) == 0x000008, "Wrong alignment on UK33TurretMalfunctionComponent");
static_assert(sizeof(UK33TurretMalfunctionComponent) == 0x0001B0, "Wrong size on UK33TurretMalfunctionComponent");
static_assert(offsetof(UK33TurretMalfunctionComponent, _malfunctionDuration) == 0x000108, "Member 'UK33TurretMalfunctionComponent::_malfunctionDuration' has a wrong offset!");

// Class TheK33.K33TurretMalfunctioningState
// 0x0030 (0x0080 - 0x0050)
class UK33TurretMalfunctioningState final : public UBaseReplicatedState
{
public:
	uint8                                         Pad_50[0x30];                                      // 0x0050(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K33TurretMalfunctioningState">();
	}
	static class UK33TurretMalfunctioningState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK33TurretMalfunctioningState>();
	}
};
static_assert(alignof(UK33TurretMalfunctioningState) == 0x000008, "Wrong alignment on UK33TurretMalfunctioningState");
static_assert(sizeof(UK33TurretMalfunctioningState) == 0x000080, "Wrong size on UK33TurretMalfunctioningState");

// Class TheK33.K33TurretMotionTrackerComponent
// 0x0060 (0x0108 - 0x00A8)
class UK33TurretMotionTrackerComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            _secondsBetweenBipSoundPerKillerDistanceCurve;     // 0x00B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B8[0x28];                                      // 0x00B8(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _motionTrackerMaxDetectionRange;                   // 0x00E0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K33TurretMotionTrackerComponent">();
	}
	static class UK33TurretMotionTrackerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK33TurretMotionTrackerComponent>();
	}
};
static_assert(alignof(UK33TurretMotionTrackerComponent) == 0x000008, "Wrong alignment on UK33TurretMotionTrackerComponent");
static_assert(sizeof(UK33TurretMotionTrackerComponent) == 0x000108, "Wrong size on UK33TurretMotionTrackerComponent");
static_assert(offsetof(UK33TurretMotionTrackerComponent, _secondsBetweenBipSoundPerKillerDistanceCurve) == 0x0000B0, "Member 'UK33TurretMotionTrackerComponent::_secondsBetweenBipSoundPerKillerDistanceCurve' has a wrong offset!");
static_assert(offsetof(UK33TurretMotionTrackerComponent, _motionTrackerMaxDetectionRange) == 0x0000E0, "Member 'UK33TurretMotionTrackerComponent::_motionTrackerMaxDetectionRange' has a wrong offset!");

// Class TheK33.K33TurretOutlineUpdateStrategy
// 0x0038 (0x0180 - 0x0148)
class UK33TurretOutlineUpdateStrategy final : public USourceBasedOutlineUpdateStrategy
{
public:
	uint8                                         Pad_148[0x14];                                     // 0x0148(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           _outlineColor;                                     // 0x015C(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_16C[0x14];                                     // 0x016C(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K33TurretOutlineUpdateStrategy">();
	}
	static class UK33TurretOutlineUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK33TurretOutlineUpdateStrategy>();
	}
};
static_assert(alignof(UK33TurretOutlineUpdateStrategy) == 0x000008, "Wrong alignment on UK33TurretOutlineUpdateStrategy");
static_assert(sizeof(UK33TurretOutlineUpdateStrategy) == 0x000180, "Wrong size on UK33TurretOutlineUpdateStrategy");
static_assert(offsetof(UK33TurretOutlineUpdateStrategy, _outlineColor) == 0x00015C, "Member 'UK33TurretOutlineUpdateStrategy::_outlineColor' has a wrong offset!");

// Class TheK33.K33TurretOverheatComponent
// 0x00A8 (0x0150 - 0x00A8)
class UK33TurretOverheatComponent final : public UActorComponent
{
public:
	float                                         _currentHeatAmount;                                // 0x00A8(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _turretHeatAccumulationRate;                       // 0x00B0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _turretHeatDissipationRate;                        // 0x00D8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_100[0x50];                                     // 0x0100(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_CurrentHeatAmount();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K33TurretOverheatComponent">();
	}
	static class UK33TurretOverheatComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK33TurretOverheatComponent>();
	}
};
static_assert(alignof(UK33TurretOverheatComponent) == 0x000008, "Wrong alignment on UK33TurretOverheatComponent");
static_assert(sizeof(UK33TurretOverheatComponent) == 0x000150, "Wrong size on UK33TurretOverheatComponent");
static_assert(offsetof(UK33TurretOverheatComponent, _currentHeatAmount) == 0x0000A8, "Member 'UK33TurretOverheatComponent::_currentHeatAmount' has a wrong offset!");
static_assert(offsetof(UK33TurretOverheatComponent, _turretHeatAccumulationRate) == 0x0000B0, "Member 'UK33TurretOverheatComponent::_turretHeatAccumulationRate' has a wrong offset!");
static_assert(offsetof(UK33TurretOverheatComponent, _turretHeatDissipationRate) == 0x0000D8, "Member 'UK33TurretOverheatComponent::_turretHeatDissipationRate' has a wrong offset!");

// Class TheK33.K33TurretOverheatState
// 0x0018 (0x0068 - 0x0050)
class UK33TurretOverheatState final : public UBaseReplicatedState
{
public:
	uint8                                         Pad_50[0x18];                                      // 0x0050(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K33TurretOverheatState">();
	}
	static class UK33TurretOverheatState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK33TurretOverheatState>();
	}
};
static_assert(alignof(UK33TurretOverheatState) == 0x000008, "Wrong alignment on UK33TurretOverheatState");
static_assert(sizeof(UK33TurretOverheatState) == 0x000068, "Wrong size on UK33TurretOverheatState");

// Class TheK33.K33TurretPlacementValidationStrategy
// 0x0038 (0x0130 - 0x00F8)
class UK33TurretPlacementValidationStrategy final : public UDefaultObjectPlacementValidationStrategy
{
public:
	struct FVector                                _navmeshProjectionBoxExtent;                       // 0x00F8(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                _navmeshProjectionBoxExtentForSnapping;            // 0x0110(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_128[0x8];                                      // 0x0128(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K33TurretPlacementValidationStrategy">();
	}
	static class UK33TurretPlacementValidationStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK33TurretPlacementValidationStrategy>();
	}
};
static_assert(alignof(UK33TurretPlacementValidationStrategy) == 0x000008, "Wrong alignment on UK33TurretPlacementValidationStrategy");
static_assert(sizeof(UK33TurretPlacementValidationStrategy) == 0x000130, "Wrong size on UK33TurretPlacementValidationStrategy");
static_assert(offsetof(UK33TurretPlacementValidationStrategy, _navmeshProjectionBoxExtent) == 0x0000F8, "Member 'UK33TurretPlacementValidationStrategy::_navmeshProjectionBoxExtent' has a wrong offset!");
static_assert(offsetof(UK33TurretPlacementValidationStrategy, _navmeshProjectionBoxExtentForSnapping) == 0x000110, "Member 'UK33TurretPlacementValidationStrategy::_navmeshProjectionBoxExtentForSnapping' has a wrong offset!");

// Class TheK33.K33TurretPlacer
// 0x00A0 (0x03D0 - 0x0330)
class UK33TurretPlacer final : public UObjectPlacerComponent
{
public:
	uint8                                         Pad_330[0x38];                                     // 0x0330(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UStaticMeshComponent>       _turretVisualPlacementStaticMeshComponentClass;    // 0x0368(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _replicatedIsPlacementValid;                       // 0x0370(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_371[0x7];                                      // 0x0371(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                _replicatedPlacementLocation;                      // 0x0378(0x0018)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_390[0x20];                                     // 0x0390(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   _turretStaticMesh;                                 // 0x03B0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FVector>                        _otherTurretsDropOffLocations;                     // 0x03B8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	float                                         _turretMeshLerpSpeed;                              // 0x03C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3CC[0x4];                                      // 0x03CC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_ReplicatedIsPlacementValid();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K33TurretPlacer">();
	}
	static class UK33TurretPlacer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK33TurretPlacer>();
	}
};
static_assert(alignof(UK33TurretPlacer) == 0x000010, "Wrong alignment on UK33TurretPlacer");
static_assert(sizeof(UK33TurretPlacer) == 0x0003D0, "Wrong size on UK33TurretPlacer");
static_assert(offsetof(UK33TurretPlacer, _turretVisualPlacementStaticMeshComponentClass) == 0x000368, "Member 'UK33TurretPlacer::_turretVisualPlacementStaticMeshComponentClass' has a wrong offset!");
static_assert(offsetof(UK33TurretPlacer, _replicatedIsPlacementValid) == 0x000370, "Member 'UK33TurretPlacer::_replicatedIsPlacementValid' has a wrong offset!");
static_assert(offsetof(UK33TurretPlacer, _replicatedPlacementLocation) == 0x000378, "Member 'UK33TurretPlacer::_replicatedPlacementLocation' has a wrong offset!");
static_assert(offsetof(UK33TurretPlacer, _turretStaticMesh) == 0x0003B0, "Member 'UK33TurretPlacer::_turretStaticMesh' has a wrong offset!");
static_assert(offsetof(UK33TurretPlacer, _otherTurretsDropOffLocations) == 0x0003B8, "Member 'UK33TurretPlacer::_otherTurretsDropOffLocations' has a wrong offset!");
static_assert(offsetof(UK33TurretPlacer, _turretMeshLerpSpeed) == 0x0003C8, "Member 'UK33TurretPlacer::_turretMeshLerpSpeed' has a wrong offset!");

// Class TheK33.K33TurretRepairInteraction
// 0x0030 (0x0950 - 0x0920)
class UK33TurretRepairInteraction final : public UBasicChargeableInteraction
{
public:
	uint8                                         Pad_920[0x30];                                     // 0x0920(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnChargeApplied(float IndividualChargeAmount, float TotalChargeAmount, class AActor* ChargeInstigator, bool WasCoop, float DeltaTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K33TurretRepairInteraction">();
	}
	static class UK33TurretRepairInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK33TurretRepairInteraction>();
	}
};
static_assert(alignof(UK33TurretRepairInteraction) == 0x000010, "Wrong alignment on UK33TurretRepairInteraction");
static_assert(sizeof(UK33TurretRepairInteraction) == 0x000950, "Wrong size on UK33TurretRepairInteraction");

// Class TheK33.K33TurretSpawnedOnControlStationState
// 0x0028 (0x0078 - 0x0050)
class UK33TurretSpawnedOnControlStationState final : public UBaseReplicatedState
{
public:
	uint8                                         Pad_50[0x28];                                      // 0x0050(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K33TurretSpawnedOnControlStationState">();
	}
	static class UK33TurretSpawnedOnControlStationState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK33TurretSpawnedOnControlStationState>();
	}
};
static_assert(alignof(UK33TurretSpawnedOnControlStationState) == 0x000008, "Wrong alignment on UK33TurretSpawnedOnControlStationState");
static_assert(sizeof(UK33TurretSpawnedOnControlStationState) == 0x000078, "Wrong size on UK33TurretSpawnedOnControlStationState");

// Class TheK33.K33TurretSpawningState
// 0x0018 (0x0068 - 0x0050)
class UK33TurretSpawningState final : public UBaseReplicatedState
{
public:
	uint8                                         Pad_50[0x18];                                      // 0x0050(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K33TurretSpawningState">();
	}
	static class UK33TurretSpawningState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK33TurretSpawningState>();
	}
};
static_assert(alignof(UK33TurretSpawningState) == 0x000008, "Wrong alignment on UK33TurretSpawningState");
static_assert(sizeof(UK33TurretSpawningState) == 0x000068, "Wrong size on UK33TurretSpawningState");

// Class TheK33.K33UndeployTurretInteraction
// 0x00C0 (0x09E0 - 0x0920)
class UK33UndeployTurretInteraction final : public UBasicChargeableInteraction
{
public:
	uint8                                         Pad_920[0x40];                                     // 0x0920(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAnimationMontageDescriptor            _cancelMontage;                                    // 0x0960(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FAnimationMontageDescriptor            _interruptedMontage;                               // 0x0980(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	float                                         _cancelUndeployDuration;                           // 0x09A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_9A4[0x3C];                                     // 0x09A4(0x003C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K33UndeployTurretInteraction">();
	}
	static class UK33UndeployTurretInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK33UndeployTurretInteraction>();
	}
};
static_assert(alignof(UK33UndeployTurretInteraction) == 0x000010, "Wrong alignment on UK33UndeployTurretInteraction");
static_assert(sizeof(UK33UndeployTurretInteraction) == 0x0009E0, "Wrong size on UK33UndeployTurretInteraction");
static_assert(offsetof(UK33UndeployTurretInteraction, _cancelMontage) == 0x000960, "Member 'UK33UndeployTurretInteraction::_cancelMontage' has a wrong offset!");
static_assert(offsetof(UK33UndeployTurretInteraction, _interruptedMontage) == 0x000980, "Member 'UK33UndeployTurretInteraction::_interruptedMontage' has a wrong offset!");
static_assert(offsetof(UK33UndeployTurretInteraction, _cancelUndeployDuration) == 0x0009A0, "Member 'UK33UndeployTurretInteraction::_cancelUndeployDuration' has a wrong offset!");

// Class TheK33.K33Utilities
// 0x0000 (0x0030 - 0x0030)
class UK33Utilities final : public UBlueprintFunctionLibrary
{
public:
	static int32 GetAvailableTurretsCountInPool(const class UObject* WorldContextObject);
	static class AK33Husk* GetK33Husk(const class UObject* WorldContextObject);
	static class AK33Power* GetK33Power(const class UObject* WorldContextObject);
	static class ULocalActorPoolComponent* GetK33VFXFeetPool(const class UObject* WorldContextObject);
	static class UK33SpecialModeComponent* GetSpecialModeComponent(const class UObject* WorldContextObject);
	static class UAuthoritativeActorPoolComponent* GetTurretsPool(const class UObject* WorldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K33Utilities">();
	}
	static class UK33Utilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK33Utilities>();
	}
};
static_assert(alignof(UK33Utilities) == 0x000008, "Wrong alignment on UK33Utilities");
static_assert(sizeof(UK33Utilities) == 0x000030, "Wrong size on UK33Utilities");

// Class TheK33.MapObjectsCheatComponent
// 0x0018 (0x00C0 - 0x00A8)
class UMapObjectsCheatComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x18];                                      // 0x00A8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DBD_ShowFatherKey(bool Enable);
	void DBD_ShowQuesita(bool Enable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapObjectsCheatComponent">();
	}
	static class UMapObjectsCheatComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapObjectsCheatComponent>();
	}
};
static_assert(alignof(UMapObjectsCheatComponent) == 0x000008, "Wrong alignment on UMapObjectsCheatComponent");
static_assert(sizeof(UMapObjectsCheatComponent) == 0x0000C0, "Wrong size on UMapObjectsCheatComponent");

// Class TheK33.QuesitaClosetHideEnterInteraction
// 0x0020 (0x07F0 - 0x07D0)
class UQuesitaClosetHideEnterInteraction final : public UClosetHideEnterInteraction
{
public:
	TArray<struct FQuesitaPropStruct>             _propInfos;                                        // 0x07D0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<class AActor*>                         _props;                                            // 0x07E0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"QuesitaClosetHideEnterInteraction">();
	}
	static class UQuesitaClosetHideEnterInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UQuesitaClosetHideEnterInteraction>();
	}
};
static_assert(alignof(UQuesitaClosetHideEnterInteraction) == 0x000010, "Wrong alignment on UQuesitaClosetHideEnterInteraction");
static_assert(sizeof(UQuesitaClosetHideEnterInteraction) == 0x0007F0, "Wrong size on UQuesitaClosetHideEnterInteraction");
static_assert(offsetof(UQuesitaClosetHideEnterInteraction, _propInfos) == 0x0007D0, "Member 'UQuesitaClosetHideEnterInteraction::_propInfos' has a wrong offset!");
static_assert(offsetof(UQuesitaClosetHideEnterInteraction, _props) == 0x0007E0, "Member 'UQuesitaClosetHideEnterInteraction::_props' has a wrong offset!");

// Class TheK33.QuesitaManagerComponent
// 0x0040 (0x00E8 - 0x00A8)
class UQuesitaManagerComponent final : public UMapSpecificGameStateComponent
{
public:
	TSubclassOf<class UQuesitaClosetHideEnterInteraction> _quesitaLockerInteraction;                         // 0x00A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _globalJumpScareChanceIncrease;                    // 0x00B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _globalJumpScareChanceInitialValue;                // 0x00B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkComponent*                           _akQuesitaComponent;                               // 0x00B8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UQuesitaClosetHideEnterInteraction*     _interaction;                                      // 0x00C0(0x0008)(ExportObject, Net, ZeroConstructor, InstancedReference, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ALocker*                                _locker;                                           // 0x00C8(0x0008)(Net, ZeroConstructor, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _shouldImplementQuesitaInteraction;                // 0x00D0(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D1[0x17];                                      // 0x00D1(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnLevelReadyToPlay();
	void Authority_OnLockerInteractorChanged(bool IsLocked);
	void Authority_OnQuesitaInteractionDone();
	void OnRep_QuesitaInteraction();
	void OnRep_QuesitaLocker(class ALocker* LastLocker);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"QuesitaManagerComponent">();
	}
	static class UQuesitaManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UQuesitaManagerComponent>();
	}
};
static_assert(alignof(UQuesitaManagerComponent) == 0x000008, "Wrong alignment on UQuesitaManagerComponent");
static_assert(sizeof(UQuesitaManagerComponent) == 0x0000E8, "Wrong size on UQuesitaManagerComponent");
static_assert(offsetof(UQuesitaManagerComponent, _quesitaLockerInteraction) == 0x0000A8, "Member 'UQuesitaManagerComponent::_quesitaLockerInteraction' has a wrong offset!");
static_assert(offsetof(UQuesitaManagerComponent, _globalJumpScareChanceIncrease) == 0x0000B0, "Member 'UQuesitaManagerComponent::_globalJumpScareChanceIncrease' has a wrong offset!");
static_assert(offsetof(UQuesitaManagerComponent, _globalJumpScareChanceInitialValue) == 0x0000B4, "Member 'UQuesitaManagerComponent::_globalJumpScareChanceInitialValue' has a wrong offset!");
static_assert(offsetof(UQuesitaManagerComponent, _akQuesitaComponent) == 0x0000B8, "Member 'UQuesitaManagerComponent::_akQuesitaComponent' has a wrong offset!");
static_assert(offsetof(UQuesitaManagerComponent, _interaction) == 0x0000C0, "Member 'UQuesitaManagerComponent::_interaction' has a wrong offset!");
static_assert(offsetof(UQuesitaManagerComponent, _locker) == 0x0000C8, "Member 'UQuesitaManagerComponent::_locker' has a wrong offset!");
static_assert(offsetof(UQuesitaManagerComponent, _shouldImplementQuesitaInteraction) == 0x0000D0, "Member 'UQuesitaManagerComponent::_shouldImplementQuesitaInteraction' has a wrong offset!");

// Class TheK33.TurretNavMesh
// 0x0000 (0x05D8 - 0x05D8)
class ATurretNavMesh final : public ARecastNavMesh
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TurretNavMesh">();
	}
	static class ATurretNavMesh* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATurretNavMesh>();
	}
};
static_assert(alignof(ATurretNavMesh) == 0x000008, "Wrong alignment on ATurretNavMesh");
static_assert(sizeof(ATurretNavMesh) == 0x0005D8, "Wrong size on ATurretNavMesh");

// Class TheK33.WormholeFatherDeadBody
// 0x0038 (0x03E0 - 0x03A8)
class AWormholeFatherDeadBody final : public AInteractable
{
public:
	class UStaticMeshComponent*                   _wrmFatherDeadBodyStaticMesh;                      // 0x03A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoClear, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        _wrmFatherKeyCardAttachment;                       // 0x03B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AWormholeFatherKeyCard>     _wrmFatherEasterEggKeyCardStaticClass;             // 0x03B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxPlayerOverlapComponent*             _wrmFatherKeyCardInteractableZone;                 // 0x03C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractor*                            _wrmKeyCardFirstCollectionInteractor;              // 0x03C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCollectFatherKeyCardInteraction*       _fatherKeyCardCollectionInteraction;               // 0x03D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 _wrmFatherEasterEggSpawnedKeyCard;                 // 0x03D8(0x0008)(Net, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WormholeFatherDeadBody">();
	}
	static class AWormholeFatherDeadBody* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWormholeFatherDeadBody>();
	}
};
static_assert(alignof(AWormholeFatherDeadBody) == 0x000008, "Wrong alignment on AWormholeFatherDeadBody");
static_assert(sizeof(AWormholeFatherDeadBody) == 0x0003E0, "Wrong size on AWormholeFatherDeadBody");
static_assert(offsetof(AWormholeFatherDeadBody, _wrmFatherDeadBodyStaticMesh) == 0x0003A8, "Member 'AWormholeFatherDeadBody::_wrmFatherDeadBodyStaticMesh' has a wrong offset!");
static_assert(offsetof(AWormholeFatherDeadBody, _wrmFatherKeyCardAttachment) == 0x0003B0, "Member 'AWormholeFatherDeadBody::_wrmFatherKeyCardAttachment' has a wrong offset!");
static_assert(offsetof(AWormholeFatherDeadBody, _wrmFatherEasterEggKeyCardStaticClass) == 0x0003B8, "Member 'AWormholeFatherDeadBody::_wrmFatherEasterEggKeyCardStaticClass' has a wrong offset!");
static_assert(offsetof(AWormholeFatherDeadBody, _wrmFatherKeyCardInteractableZone) == 0x0003C0, "Member 'AWormholeFatherDeadBody::_wrmFatherKeyCardInteractableZone' has a wrong offset!");
static_assert(offsetof(AWormholeFatherDeadBody, _wrmKeyCardFirstCollectionInteractor) == 0x0003C8, "Member 'AWormholeFatherDeadBody::_wrmKeyCardFirstCollectionInteractor' has a wrong offset!");
static_assert(offsetof(AWormholeFatherDeadBody, _fatherKeyCardCollectionInteraction) == 0x0003D0, "Member 'AWormholeFatherDeadBody::_fatherKeyCardCollectionInteraction' has a wrong offset!");
static_assert(offsetof(AWormholeFatherDeadBody, _wrmFatherEasterEggSpawnedKeyCard) == 0x0003D8, "Member 'AWormholeFatherDeadBody::_wrmFatherEasterEggSpawnedKeyCard' has a wrong offset!");

// Class TheK33.WormholeFatherDoorAnimInstance
// 0x0010 (0x0360 - 0x0350)
class UWormholeFatherDoorAnimInstance final : public UAnimInstance
{
public:
	bool                                          _isOpened;                                         // 0x0350(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_351[0xF];                                      // 0x0351(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnStateChanged(bool HasBeenHacked);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WormholeFatherDoorAnimInstance">();
	}
	static class UWormholeFatherDoorAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWormholeFatherDoorAnimInstance>();
	}
};
static_assert(alignof(UWormholeFatherDoorAnimInstance) == 0x000010, "Wrong alignment on UWormholeFatherDoorAnimInstance");
static_assert(sizeof(UWormholeFatherDoorAnimInstance) == 0x000360, "Wrong size on UWormholeFatherDoorAnimInstance");
static_assert(offsetof(UWormholeFatherDoorAnimInstance, _isOpened) == 0x000350, "Member 'UWormholeFatherDoorAnimInstance::_isOpened' has a wrong offset!");

// Class TheK33.WormholeFatherHackableActor
// 0x0038 (0x02D8 - 0x02A0)
class AWormholeFatherHackableActor final : public AActor
{
public:
	struct FGameplayTagContainer                  _hackedGameEvents;                                 // 0x02A0(0x0020)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UWormholeFatherHackingComponent*        _hackingComponent;                                 // 0x02C0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C8[0x10];                                     // 0x02C8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnHackedEvent(const struct FGameplayTag& GameEvent, const struct FGameEventData& GameEventData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WormholeFatherHackableActor">();
	}
	static class AWormholeFatherHackableActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWormholeFatherHackableActor>();
	}
};
static_assert(alignof(AWormholeFatherHackableActor) == 0x000008, "Wrong alignment on AWormholeFatherHackableActor");
static_assert(sizeof(AWormholeFatherHackableActor) == 0x0002D8, "Wrong size on AWormholeFatherHackableActor");
static_assert(offsetof(AWormholeFatherHackableActor, _hackedGameEvents) == 0x0002A0, "Member 'AWormholeFatherHackableActor::_hackedGameEvents' has a wrong offset!");
static_assert(offsetof(AWormholeFatherHackableActor, _hackingComponent) == 0x0002C0, "Member 'AWormholeFatherHackableActor::_hackingComponent' has a wrong offset!");

// Class TheK33.WormholeFatherHackingComponent
// 0x0030 (0x00D8 - 0x00A8)
class UWormholeFatherHackingComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x18];                                      // 0x00A8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             Cosmetic_OnHasBeenHackedChanged;                   // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          _hasBeenHacked;                                    // 0x00D0(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D1[0x7];                                       // 0x00D1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnWrmFatherHackedStateChangedDelegate__DelegateSignature(bool HasBeenHacked);
	void SetHasBeenHacked(const bool HasBeenHacked);

	bool HasBeenHacked() const;
	void OnRep_HasBeenHacked() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WormholeFatherHackingComponent">();
	}
	static class UWormholeFatherHackingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWormholeFatherHackingComponent>();
	}
};
static_assert(alignof(UWormholeFatherHackingComponent) == 0x000008, "Wrong alignment on UWormholeFatherHackingComponent");
static_assert(sizeof(UWormholeFatherHackingComponent) == 0x0000D8, "Wrong size on UWormholeFatherHackingComponent");
static_assert(offsetof(UWormholeFatherHackingComponent, Cosmetic_OnHasBeenHackedChanged) == 0x0000C0, "Member 'UWormholeFatherHackingComponent::Cosmetic_OnHasBeenHackedChanged' has a wrong offset!");
static_assert(offsetof(UWormholeFatherHackingComponent, _hasBeenHacked) == 0x0000D0, "Member 'UWormholeFatherHackingComponent::_hasBeenHacked' has a wrong offset!");

// Class TheK33.WormholeFatherKeyCard
// 0x0018 (0x05B0 - 0x0598)
class AWormholeFatherKeyCard final : public ABaseCamperCollectable
{
public:
	EFatherKeyCardState                           _keyCardState;                                     // 0x0598(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_599[0x17];                                     // 0x0599(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_OnKeyCardCollected();
	void Cosmetic_OnKeyCardDropped();
	void OnRep_KeyCardState();

	void ApplyInitialTag(class ADBDPlayer* Character) const;
	EFatherKeyCardState GetKeyCardState() const;
	void RemoveInitialTag(class ADBDPlayer* Character) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WormholeFatherKeyCard">();
	}
	static class AWormholeFatherKeyCard* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWormholeFatherKeyCard>();
	}
};
static_assert(alignof(AWormholeFatherKeyCard) == 0x000008, "Wrong alignment on AWormholeFatherKeyCard");
static_assert(sizeof(AWormholeFatherKeyCard) == 0x0005B0, "Wrong size on AWormholeFatherKeyCard");
static_assert(offsetof(AWormholeFatherKeyCard, _keyCardState) == 0x000598, "Member 'AWormholeFatherKeyCard::_keyCardState' has a wrong offset!");

// Class TheK33.WormholeFatherKeyCardOutlineUpdateStrategy
// 0x0000 (0x0100 - 0x0100)
class UWormholeFatherKeyCardOutlineUpdateStrategy final : public USurvivorCollectableOutlineUpdateStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WormholeFatherKeyCardOutlineUpdateStrategy">();
	}
	static class UWormholeFatherKeyCardOutlineUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWormholeFatherKeyCardOutlineUpdateStrategy>();
	}
};
static_assert(alignof(UWormholeFatherKeyCardOutlineUpdateStrategy) == 0x000008, "Wrong alignment on UWormholeFatherKeyCardOutlineUpdateStrategy");
static_assert(sizeof(UWormholeFatherKeyCardOutlineUpdateStrategy) == 0x000100, "Wrong size on UWormholeFatherKeyCardOutlineUpdateStrategy");

// Class TheK33.WormholeFatherRoomZoneOverlap
// 0x0028 (0x02C8 - 0x02A0)
class AWormholeFatherRoomZoneOverlap final : public AActor
{
public:
	class USpherePlayerOverlapComponent*          _wormholeFatherRoomZone;                           // 0x02A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A8[0x20];                                     // 0x02A8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnOverlapEnter(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnOverlapExit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WormholeFatherRoomZoneOverlap">();
	}
	static class AWormholeFatherRoomZoneOverlap* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWormholeFatherRoomZoneOverlap>();
	}
};
static_assert(alignof(AWormholeFatherRoomZoneOverlap) == 0x000008, "Wrong alignment on AWormholeFatherRoomZoneOverlap");
static_assert(sizeof(AWormholeFatherRoomZoneOverlap) == 0x0002C8, "Wrong size on AWormholeFatherRoomZoneOverlap");
static_assert(offsetof(AWormholeFatherRoomZoneOverlap, _wormholeFatherRoomZone) == 0x0002A0, "Member 'AWormholeFatherRoomZoneOverlap::_wormholeFatherRoomZone' has a wrong offset!");

// Class TheK33.WormholeFatherTerminal
// 0x0008 (0x03B0 - 0x03A8)
class AWormholeFatherTerminal final : public AInteractable
{
public:
	class USceneComponent*                        _wormholeKeyCardAttachment;                        // 0x03A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WormholeFatherTerminal">();
	}
	static class AWormholeFatherTerminal* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWormholeFatherTerminal>();
	}
};
static_assert(alignof(AWormholeFatherTerminal) == 0x000008, "Wrong alignment on AWormholeFatherTerminal");
static_assert(sizeof(AWormholeFatherTerminal) == 0x0003B0, "Wrong size on AWormholeFatherTerminal");
static_assert(offsetof(AWormholeFatherTerminal, _wormholeKeyCardAttachment) == 0x0003A8, "Member 'AWormholeFatherTerminal::_wormholeKeyCardAttachment' has a wrong offset!");

}

