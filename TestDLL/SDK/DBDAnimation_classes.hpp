#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: DBDAnimation

#include "Basic.hpp"

#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "AnimationUtilities_structs.hpp"
#include "AnimationUtilities_classes.hpp"
#include "DeadByDaylight_structs.hpp"
#include "DeadByDaylight_classes.hpp"
#include "GameplayTags_structs.hpp"
#include "Activation_structs.hpp"
#include "DBDSharedTypes_structs.hpp"
#include "DBDAnimation_structs.hpp"
#include "GameplayTagUtilities_structs.hpp"


namespace SDK
{

// Class DBDAnimation.CrowAnimInstance
// 0x0010 (0x0360 - 0x0350)
class UCrowAnimInstance : public UAnimInstance
{
public:
	bool                                          _shouldTakeOff;                                    // 0x0350(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_351[0x7];                                      // 0x0351(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UWorldRunawayMeshComponent*             _crow;                                             // 0x0358(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrowAnimInstance">();
	}
	static class UCrowAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrowAnimInstance>();
	}
};
static_assert(alignof(UCrowAnimInstance) == 0x000010, "Wrong alignment on UCrowAnimInstance");
static_assert(sizeof(UCrowAnimInstance) == 0x000360, "Wrong size on UCrowAnimInstance");
static_assert(offsetof(UCrowAnimInstance, _shouldTakeOff) == 0x000350, "Member 'UCrowAnimInstance::_shouldTakeOff' has a wrong offset!");
static_assert(offsetof(UCrowAnimInstance, _crow) == 0x000358, "Member 'UCrowAnimInstance::_crow' has a wrong offset!");

// Class DBDAnimation.DBDBaseAnimInstance
// 0x0030 (0x0380 - 0x0350)
class UDBDBaseAnimInstance : public UAnimInstance
{
public:
	class UAnimEffectBlackBoard*                  _animEffectBlackBoard;                             // 0x0350(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimEffectHandler*                     _animEffectHandlerForSFX;                          // 0x0358(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimEffectHandler*                     _animEffectHandlerForVFX;                          // 0x0360(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UAnimEffectHandler>         _animEffectHandlerClassForSFX;                     // 0x0368(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UAnimEffectHandler>         _animEffectHandlerClassForVFX;                     // 0x0370(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_378[0x8];                                      // 0x0378(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool HasBeenNotified(const class FName AnimNotify) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDBaseAnimInstance">();
	}
	static class UDBDBaseAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDBaseAnimInstance>();
	}
};
static_assert(alignof(UDBDBaseAnimInstance) == 0x000010, "Wrong alignment on UDBDBaseAnimInstance");
static_assert(sizeof(UDBDBaseAnimInstance) == 0x000380, "Wrong size on UDBDBaseAnimInstance");
static_assert(offsetof(UDBDBaseAnimInstance, _animEffectBlackBoard) == 0x000350, "Member 'UDBDBaseAnimInstance::_animEffectBlackBoard' has a wrong offset!");
static_assert(offsetof(UDBDBaseAnimInstance, _animEffectHandlerForSFX) == 0x000358, "Member 'UDBDBaseAnimInstance::_animEffectHandlerForSFX' has a wrong offset!");
static_assert(offsetof(UDBDBaseAnimInstance, _animEffectHandlerForVFX) == 0x000360, "Member 'UDBDBaseAnimInstance::_animEffectHandlerForVFX' has a wrong offset!");
static_assert(offsetof(UDBDBaseAnimInstance, _animEffectHandlerClassForSFX) == 0x000368, "Member 'UDBDBaseAnimInstance::_animEffectHandlerClassForSFX' has a wrong offset!");
static_assert(offsetof(UDBDBaseAnimInstance, _animEffectHandlerClassForVFX) == 0x000370, "Member 'UDBDBaseAnimInstance::_animEffectHandlerClassForVFX' has a wrong offset!");

// Class DBDAnimation.PlayerAnimInstance
// 0x0260 (0x05E0 - 0x0380)
#pragma pack(push, 0x1)
class alignas(0x10) UPlayerAnimInstance : public UDBDBaseAnimInstance
{
public:
	uint8                                         Pad_380[0x20];                                     // 0x0380(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class ADBDPlayer*                             _owningPlayer;                                     // 0x03A0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FTaggedAnimCollection>          _taggedAnimCollections;                            // 0x03A8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<struct FGameplayTag, class UAnimSequence*> _animations;                                       // 0x03B8(0x0050)(BlueprintVisible, BlueprintReadOnly, Transient, Protected, NativeAccessSpecifierProtected)
	TMap<struct FGameplayTag, class UBlendSpace*> _blendspaces;                                      // 0x0408(0x0050)(BlueprintVisible, BlueprintReadOnly, Transient, Protected, NativeAccessSpecifierProtected)
	TMap<struct FGameplayTag, class UAimOffsetBlendSpace*> _aimoffsets;                                       // 0x0458(0x0050)(BlueprintVisible, BlueprintReadOnly, Transient, Protected, NativeAccessSpecifierProtected)
	TMap<struct FGameplayTag, class UBlendSpace1D*> _blendspaces1d;                                    // 0x04A8(0x0050)(BlueprintVisible, BlueprintReadOnly, Transient, Protected, NativeAccessSpecifierProtected)
	TMap<struct FGameplayTag, class UAimOffsetBlendSpace1D*> _aimoffsets1d;                                     // 0x04F8(0x0050)(BlueprintVisible, BlueprintReadOnly, Transient, Protected, NativeAccessSpecifierProtected)
	TMap<struct FGameplayTag, struct FAnimSequenceSelector> _selectors;                                        // 0x0548(0x0050)(BlueprintVisible, BlueprintReadOnly, Transient, Protected, NativeAccessSpecifierProtected)
	bool                                          _isInParadise;                                     // 0x0598(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isIntroCompleted;                                 // 0x0599(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isLevelReadyToPlay;                               // 0x059A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_59B[0x5];                                      // 0x059B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FActivationDefinition                  _activationDefinition;                             // 0x05A0(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_5C8[0x10];                                     // 0x05C8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnIntroCompleted();
	void OnLevelReadyToPlay();
	void UnlinkAnimationLayerByGroup(const struct FGameplayTag& LayerGroup);

	const class ADBDPlayer* GetOwningPlayer() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerAnimInstance">();
	}
	static class UPlayerAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerAnimInstance>();
	}
};
#pragma pack(pop)
static_assert(alignof(UPlayerAnimInstance) == 0x000010, "Wrong alignment on UPlayerAnimInstance");
static_assert(sizeof(UPlayerAnimInstance) == 0x0005E0, "Wrong size on UPlayerAnimInstance");
static_assert(offsetof(UPlayerAnimInstance, _owningPlayer) == 0x0003A0, "Member 'UPlayerAnimInstance::_owningPlayer' has a wrong offset!");
static_assert(offsetof(UPlayerAnimInstance, _taggedAnimCollections) == 0x0003A8, "Member 'UPlayerAnimInstance::_taggedAnimCollections' has a wrong offset!");
static_assert(offsetof(UPlayerAnimInstance, _animations) == 0x0003B8, "Member 'UPlayerAnimInstance::_animations' has a wrong offset!");
static_assert(offsetof(UPlayerAnimInstance, _blendspaces) == 0x000408, "Member 'UPlayerAnimInstance::_blendspaces' has a wrong offset!");
static_assert(offsetof(UPlayerAnimInstance, _aimoffsets) == 0x000458, "Member 'UPlayerAnimInstance::_aimoffsets' has a wrong offset!");
static_assert(offsetof(UPlayerAnimInstance, _blendspaces1d) == 0x0004A8, "Member 'UPlayerAnimInstance::_blendspaces1d' has a wrong offset!");
static_assert(offsetof(UPlayerAnimInstance, _aimoffsets1d) == 0x0004F8, "Member 'UPlayerAnimInstance::_aimoffsets1d' has a wrong offset!");
static_assert(offsetof(UPlayerAnimInstance, _selectors) == 0x000548, "Member 'UPlayerAnimInstance::_selectors' has a wrong offset!");
static_assert(offsetof(UPlayerAnimInstance, _isInParadise) == 0x000598, "Member 'UPlayerAnimInstance::_isInParadise' has a wrong offset!");
static_assert(offsetof(UPlayerAnimInstance, _isIntroCompleted) == 0x000599, "Member 'UPlayerAnimInstance::_isIntroCompleted' has a wrong offset!");
static_assert(offsetof(UPlayerAnimInstance, _isLevelReadyToPlay) == 0x00059A, "Member 'UPlayerAnimInstance::_isLevelReadyToPlay' has a wrong offset!");
static_assert(offsetof(UPlayerAnimInstance, _activationDefinition) == 0x0005A0, "Member 'UPlayerAnimInstance::_activationDefinition' has a wrong offset!");

// Class DBDAnimation.BasePlayerAttackSubAnimInstance
// 0x00D0 (0x06B0 - 0x05E0)
#pragma pack(push, 0x1)
class alignas(0x10) UBasePlayerAttackSubAnimInstance : public UPlayerAnimInstance
{
public:
	EAttackSubstate                               _attackState;                                      // 0x05D8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5D9[0x3];                                      // 0x05D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _direction;                                        // 0x05DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _strafeAngle;                                      // 0x05E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isStrafe;                                         // 0x05E4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5E5[0x3];                                      // 0x05E5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _attackInPlayRate;                                 // 0x05E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5EC[0x4];                                      // 0x05EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAnimSequenceSelector                  _attackIn;                                         // 0x05F0(0x0018)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	float                                         _attackSwingPlayRate;                              // 0x0608(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_60C[0x4];                                      // 0x060C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAnimSequenceSelector                  _attackSwing;                                      // 0x0610(0x0018)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	float                                         _attackMissPlayRate;                               // 0x0628(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_62C[0x4];                                      // 0x062C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAnimSequenceSelector                  _attackMiss;                                       // 0x0630(0x0018)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	float                                         _attackHitPlayRate;                                // 0x0648(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_64C[0x4];                                      // 0x064C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAnimSequenceSelector                  _attackHit;                                        // 0x0650(0x0018)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	float                                         _attackBounceOfWallPlayRate;                       // 0x0668(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_66C[0x4];                                      // 0x066C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAnimSequenceSelector                  _attackBounceOfWall;                               // 0x0670(0x0018)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_688[0x18];                                     // 0x0688(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _firstPersonView;                                  // 0x06A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6A1[0x7];                                      // 0x06A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BasePlayerAttackSubAnimInstance">();
	}
	static class UBasePlayerAttackSubAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBasePlayerAttackSubAnimInstance>();
	}
};
#pragma pack(pop)
static_assert(alignof(UBasePlayerAttackSubAnimInstance) == 0x000010, "Wrong alignment on UBasePlayerAttackSubAnimInstance");
static_assert(sizeof(UBasePlayerAttackSubAnimInstance) == 0x0006B0, "Wrong size on UBasePlayerAttackSubAnimInstance");
static_assert(offsetof(UBasePlayerAttackSubAnimInstance, _attackState) == 0x0005D8, "Member 'UBasePlayerAttackSubAnimInstance::_attackState' has a wrong offset!");
static_assert(offsetof(UBasePlayerAttackSubAnimInstance, _direction) == 0x0005DC, "Member 'UBasePlayerAttackSubAnimInstance::_direction' has a wrong offset!");
static_assert(offsetof(UBasePlayerAttackSubAnimInstance, _strafeAngle) == 0x0005E0, "Member 'UBasePlayerAttackSubAnimInstance::_strafeAngle' has a wrong offset!");
static_assert(offsetof(UBasePlayerAttackSubAnimInstance, _isStrafe) == 0x0005E4, "Member 'UBasePlayerAttackSubAnimInstance::_isStrafe' has a wrong offset!");
static_assert(offsetof(UBasePlayerAttackSubAnimInstance, _attackInPlayRate) == 0x0005E8, "Member 'UBasePlayerAttackSubAnimInstance::_attackInPlayRate' has a wrong offset!");
static_assert(offsetof(UBasePlayerAttackSubAnimInstance, _attackIn) == 0x0005F0, "Member 'UBasePlayerAttackSubAnimInstance::_attackIn' has a wrong offset!");
static_assert(offsetof(UBasePlayerAttackSubAnimInstance, _attackSwingPlayRate) == 0x000608, "Member 'UBasePlayerAttackSubAnimInstance::_attackSwingPlayRate' has a wrong offset!");
static_assert(offsetof(UBasePlayerAttackSubAnimInstance, _attackSwing) == 0x000610, "Member 'UBasePlayerAttackSubAnimInstance::_attackSwing' has a wrong offset!");
static_assert(offsetof(UBasePlayerAttackSubAnimInstance, _attackMissPlayRate) == 0x000628, "Member 'UBasePlayerAttackSubAnimInstance::_attackMissPlayRate' has a wrong offset!");
static_assert(offsetof(UBasePlayerAttackSubAnimInstance, _attackMiss) == 0x000630, "Member 'UBasePlayerAttackSubAnimInstance::_attackMiss' has a wrong offset!");
static_assert(offsetof(UBasePlayerAttackSubAnimInstance, _attackHitPlayRate) == 0x000648, "Member 'UBasePlayerAttackSubAnimInstance::_attackHitPlayRate' has a wrong offset!");
static_assert(offsetof(UBasePlayerAttackSubAnimInstance, _attackHit) == 0x000650, "Member 'UBasePlayerAttackSubAnimInstance::_attackHit' has a wrong offset!");
static_assert(offsetof(UBasePlayerAttackSubAnimInstance, _attackBounceOfWallPlayRate) == 0x000668, "Member 'UBasePlayerAttackSubAnimInstance::_attackBounceOfWallPlayRate' has a wrong offset!");
static_assert(offsetof(UBasePlayerAttackSubAnimInstance, _attackBounceOfWall) == 0x000670, "Member 'UBasePlayerAttackSubAnimInstance::_attackBounceOfWall' has a wrong offset!");
static_assert(offsetof(UBasePlayerAttackSubAnimInstance, _firstPersonView) == 0x0006A0, "Member 'UBasePlayerAttackSubAnimInstance::_firstPersonView' has a wrong offset!");

// Class DBDAnimation.BaseKillerAnimInstance
// 0x0010 (0x05F0 - 0x05E0)
class UBaseKillerAnimInstance : public UPlayerAnimInstance
{
public:
	class ASlasherPlayer*                         _owningKiller;                                     // 0x05D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _firstPersonView;                                  // 0x05E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5E1[0xF];                                      // 0x05E1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DBD_ForceAnimPOV(const int32 AnimPOV);

	const class ASlasherPlayer* GetOwningKiller() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseKillerAnimInstance">();
	}
	static class UBaseKillerAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseKillerAnimInstance>();
	}
};
static_assert(alignof(UBaseKillerAnimInstance) == 0x000010, "Wrong alignment on UBaseKillerAnimInstance");
static_assert(sizeof(UBaseKillerAnimInstance) == 0x0005F0, "Wrong size on UBaseKillerAnimInstance");
static_assert(offsetof(UBaseKillerAnimInstance, _owningKiller) == 0x0005D8, "Member 'UBaseKillerAnimInstance::_owningKiller' has a wrong offset!");
static_assert(offsetof(UBaseKillerAnimInstance, _firstPersonView) == 0x0005E0, "Member 'UBaseKillerAnimInstance::_firstPersonView' has a wrong offset!");

// Class DBDAnimation.SurvivorAimableArmSensor
// 0x0040 (0x0168 - 0x0128)
class USurvivorAimableArmSensor final : public UArmIKSensorComponent
{
public:
	uint8                                         Pad_128[0x18];                                     // 0x0128(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class ACollectable*                           _aimableCollectable;                               // 0x0140(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAimableComponent*                      _aimable;                                          // 0x0148(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_150[0x18];                                     // 0x0150(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SurvivorAimableArmSensor">();
	}
	static class USurvivorAimableArmSensor* GetDefaultObj()
	{
		return GetDefaultObjImpl<USurvivorAimableArmSensor>();
	}
};
static_assert(alignof(USurvivorAimableArmSensor) == 0x000008, "Wrong alignment on USurvivorAimableArmSensor");
static_assert(sizeof(USurvivorAimableArmSensor) == 0x000168, "Wrong size on USurvivorAimableArmSensor");
static_assert(offsetof(USurvivorAimableArmSensor, _aimableCollectable) == 0x000140, "Member 'USurvivorAimableArmSensor::_aimableCollectable' has a wrong offset!");
static_assert(offsetof(USurvivorAimableArmSensor, _aimable) == 0x000148, "Member 'USurvivorAimableArmSensor::_aimable' has a wrong offset!");

// Class DBDAnimation.BaseSurvivorAnimInstance
// 0x0000 (0x05E0 - 0x05E0)
class UBaseSurvivorAnimInstance : public UPlayerAnimInstance
{
public:
	class ACamperPlayer*                          _owningSurvivor;                                   // 0x05D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	const class ACamperPlayer* GetOwningSurvivor() const;
	bool IsPlayingMontageByName(class FName MontageID) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseSurvivorAnimInstance">();
	}
	static class UBaseSurvivorAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseSurvivorAnimInstance>();
	}
};
static_assert(alignof(UBaseSurvivorAnimInstance) == 0x000010, "Wrong alignment on UBaseSurvivorAnimInstance");
static_assert(sizeof(UBaseSurvivorAnimInstance) == 0x0005E0, "Wrong size on UBaseSurvivorAnimInstance");
static_assert(offsetof(UBaseSurvivorAnimInstance, _owningSurvivor) == 0x0005D8, "Member 'UBaseSurvivorAnimInstance::_owningSurvivor' has a wrong offset!");

// Class DBDAnimation.BaseMenuAnimInstance
// 0x0010 (0x0390 - 0x0380)
#pragma pack(push, 0x1)
class alignas(0x10) UBaseMenuAnimInstance : public UDBDBaseAnimInstance
{
public:
	uint8                                         Pad_380[0x8];                                      // 0x0380(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCustomizationChanged(const TArray<class FName>& CustomizationArray);

	EGameFlowStep GetCurrentMenu() const;
	class ADBDMenuPlayer* GetOwningMenuPlayer() const;
	bool IsInArchiveRift() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseMenuAnimInstance">();
	}
	static class UBaseMenuAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseMenuAnimInstance>();
	}
};
#pragma pack(pop)
static_assert(alignof(UBaseMenuAnimInstance) == 0x000010, "Wrong alignment on UBaseMenuAnimInstance");
static_assert(sizeof(UBaseMenuAnimInstance) == 0x000390, "Wrong size on UBaseMenuAnimInstance");

// Class DBDAnimation.DynamicAccessoryAnimInstance
// 0x0010 (0x0360 - 0x0350)
class UDynamicAccessoryAnimInstance : public UAnimInstance
{
public:
	bool                                          _isInMenu;                                         // 0x0350(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isInGame;                                         // 0x0351(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isInSnapshotTool;                                 // 0x0352(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isPoseableHusk;                                   // 0x0353(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class USkeletalMeshComponent>  _masterMesh;                                       // 0x0354(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_35C[0x4];                                      // 0x035C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicAccessoryAnimInstance">();
	}
	static class UDynamicAccessoryAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDynamicAccessoryAnimInstance>();
	}
};
static_assert(alignof(UDynamicAccessoryAnimInstance) == 0x000010, "Wrong alignment on UDynamicAccessoryAnimInstance");
static_assert(sizeof(UDynamicAccessoryAnimInstance) == 0x000360, "Wrong size on UDynamicAccessoryAnimInstance");
static_assert(offsetof(UDynamicAccessoryAnimInstance, _isInMenu) == 0x000350, "Member 'UDynamicAccessoryAnimInstance::_isInMenu' has a wrong offset!");
static_assert(offsetof(UDynamicAccessoryAnimInstance, _isInGame) == 0x000351, "Member 'UDynamicAccessoryAnimInstance::_isInGame' has a wrong offset!");
static_assert(offsetof(UDynamicAccessoryAnimInstance, _isInSnapshotTool) == 0x000352, "Member 'UDynamicAccessoryAnimInstance::_isInSnapshotTool' has a wrong offset!");
static_assert(offsetof(UDynamicAccessoryAnimInstance, _isPoseableHusk) == 0x000353, "Member 'UDynamicAccessoryAnimInstance::_isPoseableHusk' has a wrong offset!");
static_assert(offsetof(UDynamicAccessoryAnimInstance, _masterMesh) == 0x000354, "Member 'UDynamicAccessoryAnimInstance::_masterMesh' has a wrong offset!");

// Class DBDAnimation.SabotageSurvivorSubAnimInstance
// 0x00C0 (0x06A0 - 0x05E0)
class USabotageSurvivorSubAnimInstance : public UBaseSurvivorAnimInstance
{
public:
	uint8                                         Pad_5E0[0x38];                                     // 0x05E0(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _isSabotaging;                                     // 0x0618(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _hasSkillCheckFailed;                              // 0x0619(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_61A[0x2];                                      // 0x061A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           _sabotageTag;                                      // 0x061C(0x000C)(Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _minRelevantAnimTimeRemaining;                     // 0x0628(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _asSabotageInTag;                                  // 0x062C(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _asSabotageLoopTag;                                // 0x0638(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _asSabotageFailTag;                                // 0x0644(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _asSabotageIn;                                     // 0x0650(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _asSabotageLoop;                                   // 0x0658(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _asSabotageFail;                                   // 0x0660(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _notSabotagingAndNotHasSkillCheckFailed;           // 0x0668(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _sabotageInToSabotageRule;                         // 0x0669(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _sabotageFailToBaseRule;                           // 0x066A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _sabotageFailToSabotageInRule;                     // 0x066B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_66C[0x34];                                     // 0x066C(0x0034)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SabotageSurvivorSubAnimInstance">();
	}
	static class USabotageSurvivorSubAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USabotageSurvivorSubAnimInstance>();
	}
};
static_assert(alignof(USabotageSurvivorSubAnimInstance) == 0x000010, "Wrong alignment on USabotageSurvivorSubAnimInstance");
static_assert(sizeof(USabotageSurvivorSubAnimInstance) == 0x0006A0, "Wrong size on USabotageSurvivorSubAnimInstance");
static_assert(offsetof(USabotageSurvivorSubAnimInstance, _isSabotaging) == 0x000618, "Member 'USabotageSurvivorSubAnimInstance::_isSabotaging' has a wrong offset!");
static_assert(offsetof(USabotageSurvivorSubAnimInstance, _hasSkillCheckFailed) == 0x000619, "Member 'USabotageSurvivorSubAnimInstance::_hasSkillCheckFailed' has a wrong offset!");
static_assert(offsetof(USabotageSurvivorSubAnimInstance, _sabotageTag) == 0x00061C, "Member 'USabotageSurvivorSubAnimInstance::_sabotageTag' has a wrong offset!");
static_assert(offsetof(USabotageSurvivorSubAnimInstance, _minRelevantAnimTimeRemaining) == 0x000628, "Member 'USabotageSurvivorSubAnimInstance::_minRelevantAnimTimeRemaining' has a wrong offset!");
static_assert(offsetof(USabotageSurvivorSubAnimInstance, _asSabotageInTag) == 0x00062C, "Member 'USabotageSurvivorSubAnimInstance::_asSabotageInTag' has a wrong offset!");
static_assert(offsetof(USabotageSurvivorSubAnimInstance, _asSabotageLoopTag) == 0x000638, "Member 'USabotageSurvivorSubAnimInstance::_asSabotageLoopTag' has a wrong offset!");
static_assert(offsetof(USabotageSurvivorSubAnimInstance, _asSabotageFailTag) == 0x000644, "Member 'USabotageSurvivorSubAnimInstance::_asSabotageFailTag' has a wrong offset!");
static_assert(offsetof(USabotageSurvivorSubAnimInstance, _asSabotageIn) == 0x000650, "Member 'USabotageSurvivorSubAnimInstance::_asSabotageIn' has a wrong offset!");
static_assert(offsetof(USabotageSurvivorSubAnimInstance, _asSabotageLoop) == 0x000658, "Member 'USabotageSurvivorSubAnimInstance::_asSabotageLoop' has a wrong offset!");
static_assert(offsetof(USabotageSurvivorSubAnimInstance, _asSabotageFail) == 0x000660, "Member 'USabotageSurvivorSubAnimInstance::_asSabotageFail' has a wrong offset!");
static_assert(offsetof(USabotageSurvivorSubAnimInstance, _notSabotagingAndNotHasSkillCheckFailed) == 0x000668, "Member 'USabotageSurvivorSubAnimInstance::_notSabotagingAndNotHasSkillCheckFailed' has a wrong offset!");
static_assert(offsetof(USabotageSurvivorSubAnimInstance, _sabotageInToSabotageRule) == 0x000669, "Member 'USabotageSurvivorSubAnimInstance::_sabotageInToSabotageRule' has a wrong offset!");
static_assert(offsetof(USabotageSurvivorSubAnimInstance, _sabotageFailToBaseRule) == 0x00066A, "Member 'USabotageSurvivorSubAnimInstance::_sabotageFailToBaseRule' has a wrong offset!");
static_assert(offsetof(USabotageSurvivorSubAnimInstance, _sabotageFailToSabotageInRule) == 0x00066B, "Member 'USabotageSurvivorSubAnimInstance::_sabotageFailToSabotageInRule' has a wrong offset!");

// Class DBDAnimation.BaseKillerAttackSubAnimInstance
// 0x0000 (0x06B0 - 0x06B0)
class UBaseKillerAttackSubAnimInstance : public UBasePlayerAttackSubAnimInstance
{
public:
	class ASlasherPlayer*                         _owningKiller;                                     // 0x06A8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	const class ASlasherPlayer* GetOwningKiller() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseKillerAttackSubAnimInstance">();
	}
	static class UBaseKillerAttackSubAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseKillerAttackSubAnimInstance>();
	}
};
static_assert(alignof(UBaseKillerAttackSubAnimInstance) == 0x000010, "Wrong alignment on UBaseKillerAttackSubAnimInstance");
static_assert(sizeof(UBaseKillerAttackSubAnimInstance) == 0x0006B0, "Wrong size on UBaseKillerAttackSubAnimInstance");
static_assert(offsetof(UBaseKillerAttackSubAnimInstance, _owningKiller) == 0x0006A8, "Member 'UBaseKillerAttackSubAnimInstance::_owningKiller' has a wrong offset!");

// Class DBDAnimation.KillerSpecificSurvivorAnimationPicker
// 0x0018 (0x00C0 - 0x00A8)
class UKillerSpecificSurvivorAnimationPicker final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UAnimInstance>              _killerSpecificAnimInstanceClass;                  // 0x00B0(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             _killerSpecificSurvivorAnimationDB;                // 0x00B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerSpecificSurvivorAnimationPicker">();
	}
	static class UKillerSpecificSurvivorAnimationPicker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillerSpecificSurvivorAnimationPicker>();
	}
};
static_assert(alignof(UKillerSpecificSurvivorAnimationPicker) == 0x000008, "Wrong alignment on UKillerSpecificSurvivorAnimationPicker");
static_assert(sizeof(UKillerSpecificSurvivorAnimationPicker) == 0x0000C0, "Wrong size on UKillerSpecificSurvivorAnimationPicker");
static_assert(offsetof(UKillerSpecificSurvivorAnimationPicker, _killerSpecificAnimInstanceClass) == 0x0000B0, "Member 'UKillerSpecificSurvivorAnimationPicker::_killerSpecificAnimInstanceClass' has a wrong offset!");
static_assert(offsetof(UKillerSpecificSurvivorAnimationPicker, _killerSpecificSurvivorAnimationDB) == 0x0000B8, "Member 'UKillerSpecificSurvivorAnimationPicker::_killerSpecificSurvivorAnimationDB' has a wrong offset!");

// Class DBDAnimation.KillerAnimInstance
// 0x0130 (0x0720 - 0x05F0)
class UKillerAnimInstance : public UBaseKillerAnimInstance
{
public:
	struct FVector                                _leftHandIKLocationFPV;                            // 0x05F0(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                _rightHandIKLocationFPV;                           // 0x0608(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isAnyMontagePlaying;                              // 0x0620(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isCarrying;                                       // 0x0621(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_622[0x6];                                      // 0x0622(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                _firstPersonCarryOffset;                           // 0x0628(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                _firstPersonCarryOffsetLookingDown;                // 0x0640(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isInAir;                                          // 0x0658(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isSpectator;                                      // 0x0659(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isIdle;                                           // 0x065A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_65B[0x1];                                      // 0x065B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _animDirection;                                    // 0x065C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _animSpeed;                                        // 0x0660(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _animPitch;                                        // 0x0664(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _animYaw;                                          // 0x0668(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _pelvisHeight;                                     // 0x066C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _idleTime;                                         // 0x0670(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _directionSwitch;                                  // 0x0674(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isAttacking;                                      // 0x0678(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isPlayingAnyMontage;                              // 0x0679(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isKilling;                                        // 0x067A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_67B[0x1];                                      // 0x067B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _minAnimPitchAngle;                                // 0x067C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _maxAnimPitchAngle;                                // 0x0680(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_684[0x4];                                      // 0x0684(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                _leftClearFrontSpaceVector;                        // 0x0688(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                _rightClearFrontSpaceVector;                       // 0x06A0(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                _velocity;                                         // 0x06B8(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                _rightFootEffectorLocation;                        // 0x06D0(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                _leftFootEffectorLocation;                         // 0x06E8(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EInteractionAnimation                         _interactionType;                                  // 0x0700(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_701[0x7];                                      // 0x0701(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UArmIKSensorComponent*                  _armIKSensorComponent;                             // 0x0708(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAttackSubstate                               _attackState;                                      // 0x0710(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_711[0x3];                                      // 0x0711(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _forwardVelocity;                                  // 0x0714(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _lateralVelocity;                                  // 0x0718(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_71C[0x4];                                      // 0x071C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class FName GetWeaponCustomizationId() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerAnimInstance">();
	}
	static class UKillerAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillerAnimInstance>();
	}
};
static_assert(alignof(UKillerAnimInstance) == 0x000010, "Wrong alignment on UKillerAnimInstance");
static_assert(sizeof(UKillerAnimInstance) == 0x000720, "Wrong size on UKillerAnimInstance");
static_assert(offsetof(UKillerAnimInstance, _leftHandIKLocationFPV) == 0x0005F0, "Member 'UKillerAnimInstance::_leftHandIKLocationFPV' has a wrong offset!");
static_assert(offsetof(UKillerAnimInstance, _rightHandIKLocationFPV) == 0x000608, "Member 'UKillerAnimInstance::_rightHandIKLocationFPV' has a wrong offset!");
static_assert(offsetof(UKillerAnimInstance, _isAnyMontagePlaying) == 0x000620, "Member 'UKillerAnimInstance::_isAnyMontagePlaying' has a wrong offset!");
static_assert(offsetof(UKillerAnimInstance, _isCarrying) == 0x000621, "Member 'UKillerAnimInstance::_isCarrying' has a wrong offset!");
static_assert(offsetof(UKillerAnimInstance, _firstPersonCarryOffset) == 0x000628, "Member 'UKillerAnimInstance::_firstPersonCarryOffset' has a wrong offset!");
static_assert(offsetof(UKillerAnimInstance, _firstPersonCarryOffsetLookingDown) == 0x000640, "Member 'UKillerAnimInstance::_firstPersonCarryOffsetLookingDown' has a wrong offset!");
static_assert(offsetof(UKillerAnimInstance, _isInAir) == 0x000658, "Member 'UKillerAnimInstance::_isInAir' has a wrong offset!");
static_assert(offsetof(UKillerAnimInstance, _isSpectator) == 0x000659, "Member 'UKillerAnimInstance::_isSpectator' has a wrong offset!");
static_assert(offsetof(UKillerAnimInstance, _isIdle) == 0x00065A, "Member 'UKillerAnimInstance::_isIdle' has a wrong offset!");
static_assert(offsetof(UKillerAnimInstance, _animDirection) == 0x00065C, "Member 'UKillerAnimInstance::_animDirection' has a wrong offset!");
static_assert(offsetof(UKillerAnimInstance, _animSpeed) == 0x000660, "Member 'UKillerAnimInstance::_animSpeed' has a wrong offset!");
static_assert(offsetof(UKillerAnimInstance, _animPitch) == 0x000664, "Member 'UKillerAnimInstance::_animPitch' has a wrong offset!");
static_assert(offsetof(UKillerAnimInstance, _animYaw) == 0x000668, "Member 'UKillerAnimInstance::_animYaw' has a wrong offset!");
static_assert(offsetof(UKillerAnimInstance, _pelvisHeight) == 0x00066C, "Member 'UKillerAnimInstance::_pelvisHeight' has a wrong offset!");
static_assert(offsetof(UKillerAnimInstance, _idleTime) == 0x000670, "Member 'UKillerAnimInstance::_idleTime' has a wrong offset!");
static_assert(offsetof(UKillerAnimInstance, _directionSwitch) == 0x000674, "Member 'UKillerAnimInstance::_directionSwitch' has a wrong offset!");
static_assert(offsetof(UKillerAnimInstance, _isAttacking) == 0x000678, "Member 'UKillerAnimInstance::_isAttacking' has a wrong offset!");
static_assert(offsetof(UKillerAnimInstance, _isPlayingAnyMontage) == 0x000679, "Member 'UKillerAnimInstance::_isPlayingAnyMontage' has a wrong offset!");
static_assert(offsetof(UKillerAnimInstance, _isKilling) == 0x00067A, "Member 'UKillerAnimInstance::_isKilling' has a wrong offset!");
static_assert(offsetof(UKillerAnimInstance, _minAnimPitchAngle) == 0x00067C, "Member 'UKillerAnimInstance::_minAnimPitchAngle' has a wrong offset!");
static_assert(offsetof(UKillerAnimInstance, _maxAnimPitchAngle) == 0x000680, "Member 'UKillerAnimInstance::_maxAnimPitchAngle' has a wrong offset!");
static_assert(offsetof(UKillerAnimInstance, _leftClearFrontSpaceVector) == 0x000688, "Member 'UKillerAnimInstance::_leftClearFrontSpaceVector' has a wrong offset!");
static_assert(offsetof(UKillerAnimInstance, _rightClearFrontSpaceVector) == 0x0006A0, "Member 'UKillerAnimInstance::_rightClearFrontSpaceVector' has a wrong offset!");
static_assert(offsetof(UKillerAnimInstance, _velocity) == 0x0006B8, "Member 'UKillerAnimInstance::_velocity' has a wrong offset!");
static_assert(offsetof(UKillerAnimInstance, _rightFootEffectorLocation) == 0x0006D0, "Member 'UKillerAnimInstance::_rightFootEffectorLocation' has a wrong offset!");
static_assert(offsetof(UKillerAnimInstance, _leftFootEffectorLocation) == 0x0006E8, "Member 'UKillerAnimInstance::_leftFootEffectorLocation' has a wrong offset!");
static_assert(offsetof(UKillerAnimInstance, _interactionType) == 0x000700, "Member 'UKillerAnimInstance::_interactionType' has a wrong offset!");
static_assert(offsetof(UKillerAnimInstance, _armIKSensorComponent) == 0x000708, "Member 'UKillerAnimInstance::_armIKSensorComponent' has a wrong offset!");
static_assert(offsetof(UKillerAnimInstance, _attackState) == 0x000710, "Member 'UKillerAnimInstance::_attackState' has a wrong offset!");
static_assert(offsetof(UKillerAnimInstance, _forwardVelocity) == 0x000714, "Member 'UKillerAnimInstance::_forwardVelocity' has a wrong offset!");
static_assert(offsetof(UKillerAnimInstance, _lateralVelocity) == 0x000718, "Member 'UKillerAnimInstance::_lateralVelocity' has a wrong offset!");

// Class DBDAnimation.ClosetIdleSurvivorSubAnimInstance
// 0x0020 (0x0600 - 0x05E0)
class UClosetIdleSurvivorSubAnimInstance : public UBaseSurvivorAnimInstance
{
public:
	EInteractionAnimation                         _interactionType;                                  // 0x05E0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isInsideCloset;                                   // 0x05E1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5E2[0x2];                                      // 0x05E2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           _asClosetIdleTag;                                  // 0x05E4(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _asClosetIdle;                                     // 0x05F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _closetIdleToBaseRule;                             // 0x05F8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5F9[0x7];                                      // 0x05F9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClosetIdleSurvivorSubAnimInstance">();
	}
	static class UClosetIdleSurvivorSubAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UClosetIdleSurvivorSubAnimInstance>();
	}
};
static_assert(alignof(UClosetIdleSurvivorSubAnimInstance) == 0x000010, "Wrong alignment on UClosetIdleSurvivorSubAnimInstance");
static_assert(sizeof(UClosetIdleSurvivorSubAnimInstance) == 0x000600, "Wrong size on UClosetIdleSurvivorSubAnimInstance");
static_assert(offsetof(UClosetIdleSurvivorSubAnimInstance, _interactionType) == 0x0005E0, "Member 'UClosetIdleSurvivorSubAnimInstance::_interactionType' has a wrong offset!");
static_assert(offsetof(UClosetIdleSurvivorSubAnimInstance, _isInsideCloset) == 0x0005E1, "Member 'UClosetIdleSurvivorSubAnimInstance::_isInsideCloset' has a wrong offset!");
static_assert(offsetof(UClosetIdleSurvivorSubAnimInstance, _asClosetIdleTag) == 0x0005E4, "Member 'UClosetIdleSurvivorSubAnimInstance::_asClosetIdleTag' has a wrong offset!");
static_assert(offsetof(UClosetIdleSurvivorSubAnimInstance, _asClosetIdle) == 0x0005F0, "Member 'UClosetIdleSurvivorSubAnimInstance::_asClosetIdle' has a wrong offset!");
static_assert(offsetof(UClosetIdleSurvivorSubAnimInstance, _closetIdleToBaseRule) == 0x0005F8, "Member 'UClosetIdleSurvivorSubAnimInstance::_closetIdleToBaseRule' has a wrong offset!");

// Class DBDAnimation.KillerAttackSubAnimInstance
// 0x0010 (0x06C0 - 0x06B0)
#pragma pack(push, 0x1)
class alignas(0x10) UKillerAttackSubAnimInstance : public UBaseKillerAttackSubAnimInstance
{
public:
	bool                                          _isCarrying;                                       // 0x06B0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isActive;                                         // 0x06B1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6B2[0x6];                                      // 0x06B2(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerAttackSubAnimInstance">();
	}
	static class UKillerAttackSubAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillerAttackSubAnimInstance>();
	}
};
#pragma pack(pop)
static_assert(alignof(UKillerAttackSubAnimInstance) == 0x000010, "Wrong alignment on UKillerAttackSubAnimInstance");
static_assert(sizeof(UKillerAttackSubAnimInstance) == 0x0006C0, "Wrong size on UKillerAttackSubAnimInstance");
static_assert(offsetof(UKillerAttackSubAnimInstance, _isCarrying) == 0x0006B0, "Member 'UKillerAttackSubAnimInstance::_isCarrying' has a wrong offset!");
static_assert(offsetof(UKillerAttackSubAnimInstance, _isActive) == 0x0006B1, "Member 'UKillerAttackSubAnimInstance::_isActive' has a wrong offset!");

// Class DBDAnimation.ArmIKSurvivorSubAnimInstance
// 0x00A0 (0x0680 - 0x05E0)
class UArmIKSurvivorSubAnimInstance final : public UBaseSurvivorAnimInstance
{
public:
	struct FRotator                               _rightWristUpRotation;                             // 0x05E0(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FRotator                               _leftWristUpRotation;                              // 0x05F8(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FFloatRange                            _localWristYawRange;                               // 0x0610(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FFloatRange                            _localWristPitchRange;                             // 0x0620(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _armInterpolationSpeed;                            // 0x0630(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _handInterpolationSpeed;                           // 0x0634(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _alphaLerpTime;                                    // 0x0638(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _reachPadding;                                     // 0x063C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _rightArmIKAlpha;                                  // 0x0640(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _leftArmIKAlpha;                                   // 0x0644(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EArmIkMode                                    _armIkMode;                                        // 0x0648(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_649[0x7];                                      // 0x0649(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UArmDetectionFanComponent*              _rightDetectionFan;                                // 0x0650(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UArmDetectionFanComponent*              _leftDetectionFan;                                 // 0x0658(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USkeletalMeshComponent*                 _meshComponent;                                    // 0x0660(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_668[0x18];                                     // 0x0668(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ChangeMode(const EArmIkMode NewMode);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArmIKSurvivorSubAnimInstance">();
	}
	static class UArmIKSurvivorSubAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UArmIKSurvivorSubAnimInstance>();
	}
};
static_assert(alignof(UArmIKSurvivorSubAnimInstance) == 0x000010, "Wrong alignment on UArmIKSurvivorSubAnimInstance");
static_assert(sizeof(UArmIKSurvivorSubAnimInstance) == 0x000680, "Wrong size on UArmIKSurvivorSubAnimInstance");
static_assert(offsetof(UArmIKSurvivorSubAnimInstance, _rightWristUpRotation) == 0x0005E0, "Member 'UArmIKSurvivorSubAnimInstance::_rightWristUpRotation' has a wrong offset!");
static_assert(offsetof(UArmIKSurvivorSubAnimInstance, _leftWristUpRotation) == 0x0005F8, "Member 'UArmIKSurvivorSubAnimInstance::_leftWristUpRotation' has a wrong offset!");
static_assert(offsetof(UArmIKSurvivorSubAnimInstance, _localWristYawRange) == 0x000610, "Member 'UArmIKSurvivorSubAnimInstance::_localWristYawRange' has a wrong offset!");
static_assert(offsetof(UArmIKSurvivorSubAnimInstance, _localWristPitchRange) == 0x000620, "Member 'UArmIKSurvivorSubAnimInstance::_localWristPitchRange' has a wrong offset!");
static_assert(offsetof(UArmIKSurvivorSubAnimInstance, _armInterpolationSpeed) == 0x000630, "Member 'UArmIKSurvivorSubAnimInstance::_armInterpolationSpeed' has a wrong offset!");
static_assert(offsetof(UArmIKSurvivorSubAnimInstance, _handInterpolationSpeed) == 0x000634, "Member 'UArmIKSurvivorSubAnimInstance::_handInterpolationSpeed' has a wrong offset!");
static_assert(offsetof(UArmIKSurvivorSubAnimInstance, _alphaLerpTime) == 0x000638, "Member 'UArmIKSurvivorSubAnimInstance::_alphaLerpTime' has a wrong offset!");
static_assert(offsetof(UArmIKSurvivorSubAnimInstance, _reachPadding) == 0x00063C, "Member 'UArmIKSurvivorSubAnimInstance::_reachPadding' has a wrong offset!");
static_assert(offsetof(UArmIKSurvivorSubAnimInstance, _rightArmIKAlpha) == 0x000640, "Member 'UArmIKSurvivorSubAnimInstance::_rightArmIKAlpha' has a wrong offset!");
static_assert(offsetof(UArmIKSurvivorSubAnimInstance, _leftArmIKAlpha) == 0x000644, "Member 'UArmIKSurvivorSubAnimInstance::_leftArmIKAlpha' has a wrong offset!");
static_assert(offsetof(UArmIKSurvivorSubAnimInstance, _armIkMode) == 0x000648, "Member 'UArmIKSurvivorSubAnimInstance::_armIkMode' has a wrong offset!");
static_assert(offsetof(UArmIKSurvivorSubAnimInstance, _rightDetectionFan) == 0x000650, "Member 'UArmIKSurvivorSubAnimInstance::_rightDetectionFan' has a wrong offset!");
static_assert(offsetof(UArmIKSurvivorSubAnimInstance, _leftDetectionFan) == 0x000658, "Member 'UArmIKSurvivorSubAnimInstance::_leftDetectionFan' has a wrong offset!");
static_assert(offsetof(UArmIKSurvivorSubAnimInstance, _meshComponent) == 0x000660, "Member 'UArmIKSurvivorSubAnimInstance::_meshComponent' has a wrong offset!");

// Class DBDAnimation.BaseKillerWeaponAnimInstance
// 0x00C0 (0x0410 - 0x0350)
#pragma pack(push, 0x1)
class alignas(0x10) UBaseKillerWeaponAnimInstance : public UAnimInstance
{
public:
	EAttackSubstate                               _attackState;                                      // 0x0350(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isCarrying;                                       // 0x0351(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isActive;                                         // 0x0352(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_353[0x1];                                      // 0x0353(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _attackInPlayRate;                                 // 0x0354(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FAnimSequenceSelector                  _attackIn;                                         // 0x0358(0x0018)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	float                                         _attackSwingPlayRate;                              // 0x0370(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_374[0x4];                                      // 0x0374(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAnimSequenceSelector                  _attackSwing;                                      // 0x0378(0x0018)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	float                                         _attackMissPlayRate;                               // 0x0390(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_394[0x4];                                      // 0x0394(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAnimSequenceSelector                  _attackMiss;                                       // 0x0398(0x0018)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	float                                         _attackHitPlayRate;                                // 0x03B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B4[0x4];                                      // 0x03B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAnimSequenceSelector                  _attackHit;                                        // 0x03B8(0x0018)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	float                                         _attackBounceOfWallPlayRate;                       // 0x03D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3D4[0x4];                                      // 0x03D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAnimSequenceSelector                  _attackBounceOfWall;                               // 0x03D8(0x0018)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_3F0[0x14];                                     // 0x03F0(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _firstPersonView;                                  // 0x0404(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_405[0x3];                                      // 0x0405(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseKillerWeaponAnimInstance">();
	}
	static class UBaseKillerWeaponAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseKillerWeaponAnimInstance>();
	}
};
#pragma pack(pop)
static_assert(alignof(UBaseKillerWeaponAnimInstance) == 0x000010, "Wrong alignment on UBaseKillerWeaponAnimInstance");
static_assert(sizeof(UBaseKillerWeaponAnimInstance) == 0x000410, "Wrong size on UBaseKillerWeaponAnimInstance");
static_assert(offsetof(UBaseKillerWeaponAnimInstance, _attackState) == 0x000350, "Member 'UBaseKillerWeaponAnimInstance::_attackState' has a wrong offset!");
static_assert(offsetof(UBaseKillerWeaponAnimInstance, _isCarrying) == 0x000351, "Member 'UBaseKillerWeaponAnimInstance::_isCarrying' has a wrong offset!");
static_assert(offsetof(UBaseKillerWeaponAnimInstance, _isActive) == 0x000352, "Member 'UBaseKillerWeaponAnimInstance::_isActive' has a wrong offset!");
static_assert(offsetof(UBaseKillerWeaponAnimInstance, _attackInPlayRate) == 0x000354, "Member 'UBaseKillerWeaponAnimInstance::_attackInPlayRate' has a wrong offset!");
static_assert(offsetof(UBaseKillerWeaponAnimInstance, _attackIn) == 0x000358, "Member 'UBaseKillerWeaponAnimInstance::_attackIn' has a wrong offset!");
static_assert(offsetof(UBaseKillerWeaponAnimInstance, _attackSwingPlayRate) == 0x000370, "Member 'UBaseKillerWeaponAnimInstance::_attackSwingPlayRate' has a wrong offset!");
static_assert(offsetof(UBaseKillerWeaponAnimInstance, _attackSwing) == 0x000378, "Member 'UBaseKillerWeaponAnimInstance::_attackSwing' has a wrong offset!");
static_assert(offsetof(UBaseKillerWeaponAnimInstance, _attackMissPlayRate) == 0x000390, "Member 'UBaseKillerWeaponAnimInstance::_attackMissPlayRate' has a wrong offset!");
static_assert(offsetof(UBaseKillerWeaponAnimInstance, _attackMiss) == 0x000398, "Member 'UBaseKillerWeaponAnimInstance::_attackMiss' has a wrong offset!");
static_assert(offsetof(UBaseKillerWeaponAnimInstance, _attackHitPlayRate) == 0x0003B0, "Member 'UBaseKillerWeaponAnimInstance::_attackHitPlayRate' has a wrong offset!");
static_assert(offsetof(UBaseKillerWeaponAnimInstance, _attackHit) == 0x0003B8, "Member 'UBaseKillerWeaponAnimInstance::_attackHit' has a wrong offset!");
static_assert(offsetof(UBaseKillerWeaponAnimInstance, _attackBounceOfWallPlayRate) == 0x0003D0, "Member 'UBaseKillerWeaponAnimInstance::_attackBounceOfWallPlayRate' has a wrong offset!");
static_assert(offsetof(UBaseKillerWeaponAnimInstance, _attackBounceOfWall) == 0x0003D8, "Member 'UBaseKillerWeaponAnimInstance::_attackBounceOfWall' has a wrong offset!");
static_assert(offsetof(UBaseKillerWeaponAnimInstance, _firstPersonView) == 0x000404, "Member 'UBaseKillerWeaponAnimInstance::_firstPersonView' has a wrong offset!");

// Class DBDAnimation.SurvivorDynamicAccessoryAnimInstance
// 0x0040 (0x03A0 - 0x0360)
#pragma pack(push, 0x1)
class alignas(0x10) USurvivorDynamicAccessoryAnimInstance : public UDynamicAccessoryAnimInstance
{
public:
	bool                                          _isMale;                                           // 0x0360(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isBeingMoried;                                    // 0x0361(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isDeadOrInParadise;                               // 0x0362(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isMoving;                                         // 0x0363(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isRunning;                                        // 0x0364(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isCrawling;                                       // 0x0365(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isRetrievingItem;                                 // 0x0366(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isInAir;                                          // 0x0367(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isHealing;                                        // 0x0368(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isBeingMended;                                    // 0x0369(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isBeingHooked;                                    // 0x036A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isBeingHealed;                                    // 0x036B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isCleansingTotem;                                 // 0x036C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isOwnerUsingGesture;                              // 0x036D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isOwnerEscapingWithHatch;                         // 0x036E(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isInteractingWithLocker;                          // 0x036F(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isInteractingWithChest;                           // 0x0370(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isOwnerCrouching;                                 // 0x0371(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isOwnerInjured;                                   // 0x0372(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isOwnerKO;                                        // 0x0373(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isOwnerInLocker;                                  // 0x0374(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isOwnerExitingLocker;                             // 0x0375(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isOwnerBeingCarried;                              // 0x0376(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isOwnerVaulting;                                  // 0x0377(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isOwnerDroppingAPallet;                           // 0x0378(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isOwnerReparingAGenerator;                        // 0x0379(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isOwnerBeingPulledFromLocker;                     // 0x037A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isOwnerDisconnected;                              // 0x037B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_37C[0x1C];                                     // 0x037C(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SurvivorDynamicAccessoryAnimInstance">();
	}
	static class USurvivorDynamicAccessoryAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USurvivorDynamicAccessoryAnimInstance>();
	}
};
#pragma pack(pop)
static_assert(alignof(USurvivorDynamicAccessoryAnimInstance) == 0x000010, "Wrong alignment on USurvivorDynamicAccessoryAnimInstance");
static_assert(sizeof(USurvivorDynamicAccessoryAnimInstance) == 0x0003A0, "Wrong size on USurvivorDynamicAccessoryAnimInstance");
static_assert(offsetof(USurvivorDynamicAccessoryAnimInstance, _isMale) == 0x000360, "Member 'USurvivorDynamicAccessoryAnimInstance::_isMale' has a wrong offset!");
static_assert(offsetof(USurvivorDynamicAccessoryAnimInstance, _isBeingMoried) == 0x000361, "Member 'USurvivorDynamicAccessoryAnimInstance::_isBeingMoried' has a wrong offset!");
static_assert(offsetof(USurvivorDynamicAccessoryAnimInstance, _isDeadOrInParadise) == 0x000362, "Member 'USurvivorDynamicAccessoryAnimInstance::_isDeadOrInParadise' has a wrong offset!");
static_assert(offsetof(USurvivorDynamicAccessoryAnimInstance, _isMoving) == 0x000363, "Member 'USurvivorDynamicAccessoryAnimInstance::_isMoving' has a wrong offset!");
static_assert(offsetof(USurvivorDynamicAccessoryAnimInstance, _isRunning) == 0x000364, "Member 'USurvivorDynamicAccessoryAnimInstance::_isRunning' has a wrong offset!");
static_assert(offsetof(USurvivorDynamicAccessoryAnimInstance, _isCrawling) == 0x000365, "Member 'USurvivorDynamicAccessoryAnimInstance::_isCrawling' has a wrong offset!");
static_assert(offsetof(USurvivorDynamicAccessoryAnimInstance, _isRetrievingItem) == 0x000366, "Member 'USurvivorDynamicAccessoryAnimInstance::_isRetrievingItem' has a wrong offset!");
static_assert(offsetof(USurvivorDynamicAccessoryAnimInstance, _isInAir) == 0x000367, "Member 'USurvivorDynamicAccessoryAnimInstance::_isInAir' has a wrong offset!");
static_assert(offsetof(USurvivorDynamicAccessoryAnimInstance, _isHealing) == 0x000368, "Member 'USurvivorDynamicAccessoryAnimInstance::_isHealing' has a wrong offset!");
static_assert(offsetof(USurvivorDynamicAccessoryAnimInstance, _isBeingMended) == 0x000369, "Member 'USurvivorDynamicAccessoryAnimInstance::_isBeingMended' has a wrong offset!");
static_assert(offsetof(USurvivorDynamicAccessoryAnimInstance, _isBeingHooked) == 0x00036A, "Member 'USurvivorDynamicAccessoryAnimInstance::_isBeingHooked' has a wrong offset!");
static_assert(offsetof(USurvivorDynamicAccessoryAnimInstance, _isBeingHealed) == 0x00036B, "Member 'USurvivorDynamicAccessoryAnimInstance::_isBeingHealed' has a wrong offset!");
static_assert(offsetof(USurvivorDynamicAccessoryAnimInstance, _isCleansingTotem) == 0x00036C, "Member 'USurvivorDynamicAccessoryAnimInstance::_isCleansingTotem' has a wrong offset!");
static_assert(offsetof(USurvivorDynamicAccessoryAnimInstance, _isOwnerUsingGesture) == 0x00036D, "Member 'USurvivorDynamicAccessoryAnimInstance::_isOwnerUsingGesture' has a wrong offset!");
static_assert(offsetof(USurvivorDynamicAccessoryAnimInstance, _isOwnerEscapingWithHatch) == 0x00036E, "Member 'USurvivorDynamicAccessoryAnimInstance::_isOwnerEscapingWithHatch' has a wrong offset!");
static_assert(offsetof(USurvivorDynamicAccessoryAnimInstance, _isInteractingWithLocker) == 0x00036F, "Member 'USurvivorDynamicAccessoryAnimInstance::_isInteractingWithLocker' has a wrong offset!");
static_assert(offsetof(USurvivorDynamicAccessoryAnimInstance, _isInteractingWithChest) == 0x000370, "Member 'USurvivorDynamicAccessoryAnimInstance::_isInteractingWithChest' has a wrong offset!");
static_assert(offsetof(USurvivorDynamicAccessoryAnimInstance, _isOwnerCrouching) == 0x000371, "Member 'USurvivorDynamicAccessoryAnimInstance::_isOwnerCrouching' has a wrong offset!");
static_assert(offsetof(USurvivorDynamicAccessoryAnimInstance, _isOwnerInjured) == 0x000372, "Member 'USurvivorDynamicAccessoryAnimInstance::_isOwnerInjured' has a wrong offset!");
static_assert(offsetof(USurvivorDynamicAccessoryAnimInstance, _isOwnerKO) == 0x000373, "Member 'USurvivorDynamicAccessoryAnimInstance::_isOwnerKO' has a wrong offset!");
static_assert(offsetof(USurvivorDynamicAccessoryAnimInstance, _isOwnerInLocker) == 0x000374, "Member 'USurvivorDynamicAccessoryAnimInstance::_isOwnerInLocker' has a wrong offset!");
static_assert(offsetof(USurvivorDynamicAccessoryAnimInstance, _isOwnerExitingLocker) == 0x000375, "Member 'USurvivorDynamicAccessoryAnimInstance::_isOwnerExitingLocker' has a wrong offset!");
static_assert(offsetof(USurvivorDynamicAccessoryAnimInstance, _isOwnerBeingCarried) == 0x000376, "Member 'USurvivorDynamicAccessoryAnimInstance::_isOwnerBeingCarried' has a wrong offset!");
static_assert(offsetof(USurvivorDynamicAccessoryAnimInstance, _isOwnerVaulting) == 0x000377, "Member 'USurvivorDynamicAccessoryAnimInstance::_isOwnerVaulting' has a wrong offset!");
static_assert(offsetof(USurvivorDynamicAccessoryAnimInstance, _isOwnerDroppingAPallet) == 0x000378, "Member 'USurvivorDynamicAccessoryAnimInstance::_isOwnerDroppingAPallet' has a wrong offset!");
static_assert(offsetof(USurvivorDynamicAccessoryAnimInstance, _isOwnerReparingAGenerator) == 0x000379, "Member 'USurvivorDynamicAccessoryAnimInstance::_isOwnerReparingAGenerator' has a wrong offset!");
static_assert(offsetof(USurvivorDynamicAccessoryAnimInstance, _isOwnerBeingPulledFromLocker) == 0x00037A, "Member 'USurvivorDynamicAccessoryAnimInstance::_isOwnerBeingPulledFromLocker' has a wrong offset!");
static_assert(offsetof(USurvivorDynamicAccessoryAnimInstance, _isOwnerDisconnected) == 0x00037B, "Member 'USurvivorDynamicAccessoryAnimInstance::_isOwnerDisconnected' has a wrong offset!");

// Class DBDAnimation.AimOffsetSurvivorSubAnimInstance
// 0x0060 (0x0640 - 0x05E0)
class UAimOffsetSurvivorSubAnimInstance final : public UBaseSurvivorAnimInstance
{
public:
	float                                         _pitch;                                            // 0x05E0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _yaw;                                              // 0x05E4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _yawInterpolated;                                  // 0x05E8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _allowLookAt;                                      // 0x05EC(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isUsingAimItem;                                   // 0x05ED(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isInjured;                                        // 0x05EE(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isCrawling;                                       // 0x05EF(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isIdle;                                           // 0x05F0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isDrasticYawChangeDetected;                       // 0x05F1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5F2[0x2];                                      // 0x05F2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _yawInterpolationSpeed;                            // 0x05F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _yawDeadzoneStart;                                 // 0x05F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _yawClampValue;                                    // 0x05FC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _yawDrasticChangeUpperLimit;                       // 0x0600(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _yawDrasticChangeLowerLimit;                       // 0x0604(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _yawDrasticChangeInterpolationSpeed;               // 0x0608(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_60C[0x4];                                      // 0x060C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            _yawInterpolateEaseIn;                             // 0x0610(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            _yawInterpolateEaseOut;                            // 0x0618(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _yawInterpolationEaseInLength;                     // 0x0620(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _yawInterpolationEaseOutDistance;                  // 0x0624(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isYawInDeadZone;                                  // 0x0628(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_629[0x3];                                      // 0x0629(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _currentTargetYaw;                                 // 0x062C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _yawAcceleration;                                  // 0x0630(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _yawAccelerationTime;                              // 0x0634(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_638[0x8];                                      // 0x0638(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AimOffsetSurvivorSubAnimInstance">();
	}
	static class UAimOffsetSurvivorSubAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAimOffsetSurvivorSubAnimInstance>();
	}
};
static_assert(alignof(UAimOffsetSurvivorSubAnimInstance) == 0x000010, "Wrong alignment on UAimOffsetSurvivorSubAnimInstance");
static_assert(sizeof(UAimOffsetSurvivorSubAnimInstance) == 0x000640, "Wrong size on UAimOffsetSurvivorSubAnimInstance");
static_assert(offsetof(UAimOffsetSurvivorSubAnimInstance, _pitch) == 0x0005E0, "Member 'UAimOffsetSurvivorSubAnimInstance::_pitch' has a wrong offset!");
static_assert(offsetof(UAimOffsetSurvivorSubAnimInstance, _yaw) == 0x0005E4, "Member 'UAimOffsetSurvivorSubAnimInstance::_yaw' has a wrong offset!");
static_assert(offsetof(UAimOffsetSurvivorSubAnimInstance, _yawInterpolated) == 0x0005E8, "Member 'UAimOffsetSurvivorSubAnimInstance::_yawInterpolated' has a wrong offset!");
static_assert(offsetof(UAimOffsetSurvivorSubAnimInstance, _allowLookAt) == 0x0005EC, "Member 'UAimOffsetSurvivorSubAnimInstance::_allowLookAt' has a wrong offset!");
static_assert(offsetof(UAimOffsetSurvivorSubAnimInstance, _isUsingAimItem) == 0x0005ED, "Member 'UAimOffsetSurvivorSubAnimInstance::_isUsingAimItem' has a wrong offset!");
static_assert(offsetof(UAimOffsetSurvivorSubAnimInstance, _isInjured) == 0x0005EE, "Member 'UAimOffsetSurvivorSubAnimInstance::_isInjured' has a wrong offset!");
static_assert(offsetof(UAimOffsetSurvivorSubAnimInstance, _isCrawling) == 0x0005EF, "Member 'UAimOffsetSurvivorSubAnimInstance::_isCrawling' has a wrong offset!");
static_assert(offsetof(UAimOffsetSurvivorSubAnimInstance, _isIdle) == 0x0005F0, "Member 'UAimOffsetSurvivorSubAnimInstance::_isIdle' has a wrong offset!");
static_assert(offsetof(UAimOffsetSurvivorSubAnimInstance, _isDrasticYawChangeDetected) == 0x0005F1, "Member 'UAimOffsetSurvivorSubAnimInstance::_isDrasticYawChangeDetected' has a wrong offset!");
static_assert(offsetof(UAimOffsetSurvivorSubAnimInstance, _yawInterpolationSpeed) == 0x0005F4, "Member 'UAimOffsetSurvivorSubAnimInstance::_yawInterpolationSpeed' has a wrong offset!");
static_assert(offsetof(UAimOffsetSurvivorSubAnimInstance, _yawDeadzoneStart) == 0x0005F8, "Member 'UAimOffsetSurvivorSubAnimInstance::_yawDeadzoneStart' has a wrong offset!");
static_assert(offsetof(UAimOffsetSurvivorSubAnimInstance, _yawClampValue) == 0x0005FC, "Member 'UAimOffsetSurvivorSubAnimInstance::_yawClampValue' has a wrong offset!");
static_assert(offsetof(UAimOffsetSurvivorSubAnimInstance, _yawDrasticChangeUpperLimit) == 0x000600, "Member 'UAimOffsetSurvivorSubAnimInstance::_yawDrasticChangeUpperLimit' has a wrong offset!");
static_assert(offsetof(UAimOffsetSurvivorSubAnimInstance, _yawDrasticChangeLowerLimit) == 0x000604, "Member 'UAimOffsetSurvivorSubAnimInstance::_yawDrasticChangeLowerLimit' has a wrong offset!");
static_assert(offsetof(UAimOffsetSurvivorSubAnimInstance, _yawDrasticChangeInterpolationSpeed) == 0x000608, "Member 'UAimOffsetSurvivorSubAnimInstance::_yawDrasticChangeInterpolationSpeed' has a wrong offset!");
static_assert(offsetof(UAimOffsetSurvivorSubAnimInstance, _yawInterpolateEaseIn) == 0x000610, "Member 'UAimOffsetSurvivorSubAnimInstance::_yawInterpolateEaseIn' has a wrong offset!");
static_assert(offsetof(UAimOffsetSurvivorSubAnimInstance, _yawInterpolateEaseOut) == 0x000618, "Member 'UAimOffsetSurvivorSubAnimInstance::_yawInterpolateEaseOut' has a wrong offset!");
static_assert(offsetof(UAimOffsetSurvivorSubAnimInstance, _yawInterpolationEaseInLength) == 0x000620, "Member 'UAimOffsetSurvivorSubAnimInstance::_yawInterpolationEaseInLength' has a wrong offset!");
static_assert(offsetof(UAimOffsetSurvivorSubAnimInstance, _yawInterpolationEaseOutDistance) == 0x000624, "Member 'UAimOffsetSurvivorSubAnimInstance::_yawInterpolationEaseOutDistance' has a wrong offset!");
static_assert(offsetof(UAimOffsetSurvivorSubAnimInstance, _isYawInDeadZone) == 0x000628, "Member 'UAimOffsetSurvivorSubAnimInstance::_isYawInDeadZone' has a wrong offset!");
static_assert(offsetof(UAimOffsetSurvivorSubAnimInstance, _currentTargetYaw) == 0x00062C, "Member 'UAimOffsetSurvivorSubAnimInstance::_currentTargetYaw' has a wrong offset!");
static_assert(offsetof(UAimOffsetSurvivorSubAnimInstance, _yawAcceleration) == 0x000630, "Member 'UAimOffsetSurvivorSubAnimInstance::_yawAcceleration' has a wrong offset!");
static_assert(offsetof(UAimOffsetSurvivorSubAnimInstance, _yawAccelerationTime) == 0x000634, "Member 'UAimOffsetSurvivorSubAnimInstance::_yawAccelerationTime' has a wrong offset!");

// Class DBDAnimation.AnyPlayerInRangeAnimInstance
// 0x0010 (0x0360 - 0x0350)
class UAnyPlayerInRangeAnimInstance final : public UAnimInstance
{
public:
	bool                                          _isAnyPlayerInNearbyRange;                         // 0x0350(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_351[0x3];                                      // 0x0351(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _nearbyRangeCm;                                    // 0x0354(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_358[0x8];                                      // 0x0358(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnyPlayerInRangeAnimInstance">();
	}
	static class UAnyPlayerInRangeAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnyPlayerInRangeAnimInstance>();
	}
};
static_assert(alignof(UAnyPlayerInRangeAnimInstance) == 0x000010, "Wrong alignment on UAnyPlayerInRangeAnimInstance");
static_assert(sizeof(UAnyPlayerInRangeAnimInstance) == 0x000360, "Wrong size on UAnyPlayerInRangeAnimInstance");
static_assert(offsetof(UAnyPlayerInRangeAnimInstance, _isAnyPlayerInNearbyRange) == 0x000350, "Member 'UAnyPlayerInRangeAnimInstance::_isAnyPlayerInNearbyRange' has a wrong offset!");
static_assert(offsetof(UAnyPlayerInRangeAnimInstance, _nearbyRangeCm) == 0x000354, "Member 'UAnyPlayerInRangeAnimInstance::_nearbyRangeCm' has a wrong offset!");

// Class DBDAnimation.ArmOverrideSurvivorSubAnimInstance
// 0x0130 (0x0710 - 0x05E0)
class UArmOverrideSurvivorSubAnimInstance : public UBaseSurvivorAnimInstance
{
public:
	bool                                          _isCrawling;                                       // 0x05E0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _holdingItem;                                      // 0x05E1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5E2[0x2];                                      // 0x05E2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _speed;                                            // 0x05E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _fireCracker;                                      // 0x05E8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _smallItem;                                        // 0x05E9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _useAimItem;                                       // 0x05EA(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _holdAimItem;                                      // 0x05EB(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isCrouched;                                       // 0x05EC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isFrightScream;                                   // 0x05ED(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isHoldingFlashbang;                               // 0x05EE(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isInjured;                                        // 0x05EF(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isHoldingVaccine;                                 // 0x05F0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _disableArmOverride;                               // 0x05F1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isHoldingMirror;                                  // 0x05F2(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isHoldingLamentBox;                               // 0x05F3(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isHoldingSprayObject;                             // 0x05F4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isHoldingVHS;                                     // 0x05F5(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isHoldingWormholeFatherKeyCard;                   // 0x05F6(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isHoldingLantern;                                 // 0x05F7(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _bsItemArmOverrideTag;                             // 0x05F8(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _asKeyHandOverrideTag;                             // 0x0604(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _asFlashlightHandOverrideTag;                      // 0x0610(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _asFirecrackerHandOverrideTag;                     // 0x061C(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _asFlashlightHandOverrideAimTag;                   // 0x0628(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _asPocketMirrorHandOverrideTag;                    // 0x0634(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _asSyringeHandOverrideTag;                         // 0x0640(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _asFlashbangHandOverrideTag;                       // 0x064C(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _asLamentBoxHandOverrideTag;                       // 0x0658(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _asStabilizingSprayOverrideTag;                    // 0x0664(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _asKeyCardHandOverrideTag;                         // 0x0670(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _asVhsHandOverrideTag;                             // 0x067C(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _asIdleArmOverrideTag;                             // 0x0688(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _asCrawlArmOverrideTag;                            // 0x0694(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _asKeyHandOverride;                                // 0x06A0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _asFlashlightHandOverride;                         // 0x06A8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _asFirecrackerHandOverride;                        // 0x06B0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _asFlashlightHandOverrideAim;                      // 0x06B8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _asPocketMirrorHandOverride;                       // 0x06C0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _asSyringeHandOverride;                            // 0x06C8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _asFlashBangHandOverride;                          // 0x06D0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _asLamentBoxHandOverride;                          // 0x06D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _asStabilizingSprayOverride;                       // 0x06E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _asKeyCardHandOverride;                            // 0x06E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _asVhsHandOverride;                                // 0x06F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _asIdleArmOverride;                                // 0x06F8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _asCrawlArmOverride;                               // 0x0700(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _injuredNotUsingAimItem;                           // 0x0708(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _baseToConduitRule;                                // 0x070C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _conduitToBaseRule;                                // 0x070D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_70E[0x2];                                      // 0x070E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArmOverrideSurvivorSubAnimInstance">();
	}
	static class UArmOverrideSurvivorSubAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UArmOverrideSurvivorSubAnimInstance>();
	}
};
static_assert(alignof(UArmOverrideSurvivorSubAnimInstance) == 0x000010, "Wrong alignment on UArmOverrideSurvivorSubAnimInstance");
static_assert(sizeof(UArmOverrideSurvivorSubAnimInstance) == 0x000710, "Wrong size on UArmOverrideSurvivorSubAnimInstance");
static_assert(offsetof(UArmOverrideSurvivorSubAnimInstance, _isCrawling) == 0x0005E0, "Member 'UArmOverrideSurvivorSubAnimInstance::_isCrawling' has a wrong offset!");
static_assert(offsetof(UArmOverrideSurvivorSubAnimInstance, _holdingItem) == 0x0005E1, "Member 'UArmOverrideSurvivorSubAnimInstance::_holdingItem' has a wrong offset!");
static_assert(offsetof(UArmOverrideSurvivorSubAnimInstance, _speed) == 0x0005E4, "Member 'UArmOverrideSurvivorSubAnimInstance::_speed' has a wrong offset!");
static_assert(offsetof(UArmOverrideSurvivorSubAnimInstance, _fireCracker) == 0x0005E8, "Member 'UArmOverrideSurvivorSubAnimInstance::_fireCracker' has a wrong offset!");
static_assert(offsetof(UArmOverrideSurvivorSubAnimInstance, _smallItem) == 0x0005E9, "Member 'UArmOverrideSurvivorSubAnimInstance::_smallItem' has a wrong offset!");
static_assert(offsetof(UArmOverrideSurvivorSubAnimInstance, _useAimItem) == 0x0005EA, "Member 'UArmOverrideSurvivorSubAnimInstance::_useAimItem' has a wrong offset!");
static_assert(offsetof(UArmOverrideSurvivorSubAnimInstance, _holdAimItem) == 0x0005EB, "Member 'UArmOverrideSurvivorSubAnimInstance::_holdAimItem' has a wrong offset!");
static_assert(offsetof(UArmOverrideSurvivorSubAnimInstance, _isCrouched) == 0x0005EC, "Member 'UArmOverrideSurvivorSubAnimInstance::_isCrouched' has a wrong offset!");
static_assert(offsetof(UArmOverrideSurvivorSubAnimInstance, _isFrightScream) == 0x0005ED, "Member 'UArmOverrideSurvivorSubAnimInstance::_isFrightScream' has a wrong offset!");
static_assert(offsetof(UArmOverrideSurvivorSubAnimInstance, _isHoldingFlashbang) == 0x0005EE, "Member 'UArmOverrideSurvivorSubAnimInstance::_isHoldingFlashbang' has a wrong offset!");
static_assert(offsetof(UArmOverrideSurvivorSubAnimInstance, _isInjured) == 0x0005EF, "Member 'UArmOverrideSurvivorSubAnimInstance::_isInjured' has a wrong offset!");
static_assert(offsetof(UArmOverrideSurvivorSubAnimInstance, _isHoldingVaccine) == 0x0005F0, "Member 'UArmOverrideSurvivorSubAnimInstance::_isHoldingVaccine' has a wrong offset!");
static_assert(offsetof(UArmOverrideSurvivorSubAnimInstance, _disableArmOverride) == 0x0005F1, "Member 'UArmOverrideSurvivorSubAnimInstance::_disableArmOverride' has a wrong offset!");
static_assert(offsetof(UArmOverrideSurvivorSubAnimInstance, _isHoldingMirror) == 0x0005F2, "Member 'UArmOverrideSurvivorSubAnimInstance::_isHoldingMirror' has a wrong offset!");
static_assert(offsetof(UArmOverrideSurvivorSubAnimInstance, _isHoldingLamentBox) == 0x0005F3, "Member 'UArmOverrideSurvivorSubAnimInstance::_isHoldingLamentBox' has a wrong offset!");
static_assert(offsetof(UArmOverrideSurvivorSubAnimInstance, _isHoldingSprayObject) == 0x0005F4, "Member 'UArmOverrideSurvivorSubAnimInstance::_isHoldingSprayObject' has a wrong offset!");
static_assert(offsetof(UArmOverrideSurvivorSubAnimInstance, _isHoldingVHS) == 0x0005F5, "Member 'UArmOverrideSurvivorSubAnimInstance::_isHoldingVHS' has a wrong offset!");
static_assert(offsetof(UArmOverrideSurvivorSubAnimInstance, _isHoldingWormholeFatherKeyCard) == 0x0005F6, "Member 'UArmOverrideSurvivorSubAnimInstance::_isHoldingWormholeFatherKeyCard' has a wrong offset!");
static_assert(offsetof(UArmOverrideSurvivorSubAnimInstance, _isHoldingLantern) == 0x0005F7, "Member 'UArmOverrideSurvivorSubAnimInstance::_isHoldingLantern' has a wrong offset!");
static_assert(offsetof(UArmOverrideSurvivorSubAnimInstance, _bsItemArmOverrideTag) == 0x0005F8, "Member 'UArmOverrideSurvivorSubAnimInstance::_bsItemArmOverrideTag' has a wrong offset!");
static_assert(offsetof(UArmOverrideSurvivorSubAnimInstance, _asKeyHandOverrideTag) == 0x000604, "Member 'UArmOverrideSurvivorSubAnimInstance::_asKeyHandOverrideTag' has a wrong offset!");
static_assert(offsetof(UArmOverrideSurvivorSubAnimInstance, _asFlashlightHandOverrideTag) == 0x000610, "Member 'UArmOverrideSurvivorSubAnimInstance::_asFlashlightHandOverrideTag' has a wrong offset!");
static_assert(offsetof(UArmOverrideSurvivorSubAnimInstance, _asFirecrackerHandOverrideTag) == 0x00061C, "Member 'UArmOverrideSurvivorSubAnimInstance::_asFirecrackerHandOverrideTag' has a wrong offset!");
static_assert(offsetof(UArmOverrideSurvivorSubAnimInstance, _asFlashlightHandOverrideAimTag) == 0x000628, "Member 'UArmOverrideSurvivorSubAnimInstance::_asFlashlightHandOverrideAimTag' has a wrong offset!");
static_assert(offsetof(UArmOverrideSurvivorSubAnimInstance, _asPocketMirrorHandOverrideTag) == 0x000634, "Member 'UArmOverrideSurvivorSubAnimInstance::_asPocketMirrorHandOverrideTag' has a wrong offset!");
static_assert(offsetof(UArmOverrideSurvivorSubAnimInstance, _asSyringeHandOverrideTag) == 0x000640, "Member 'UArmOverrideSurvivorSubAnimInstance::_asSyringeHandOverrideTag' has a wrong offset!");
static_assert(offsetof(UArmOverrideSurvivorSubAnimInstance, _asFlashbangHandOverrideTag) == 0x00064C, "Member 'UArmOverrideSurvivorSubAnimInstance::_asFlashbangHandOverrideTag' has a wrong offset!");
static_assert(offsetof(UArmOverrideSurvivorSubAnimInstance, _asLamentBoxHandOverrideTag) == 0x000658, "Member 'UArmOverrideSurvivorSubAnimInstance::_asLamentBoxHandOverrideTag' has a wrong offset!");
static_assert(offsetof(UArmOverrideSurvivorSubAnimInstance, _asStabilizingSprayOverrideTag) == 0x000664, "Member 'UArmOverrideSurvivorSubAnimInstance::_asStabilizingSprayOverrideTag' has a wrong offset!");
static_assert(offsetof(UArmOverrideSurvivorSubAnimInstance, _asKeyCardHandOverrideTag) == 0x000670, "Member 'UArmOverrideSurvivorSubAnimInstance::_asKeyCardHandOverrideTag' has a wrong offset!");
static_assert(offsetof(UArmOverrideSurvivorSubAnimInstance, _asVhsHandOverrideTag) == 0x00067C, "Member 'UArmOverrideSurvivorSubAnimInstance::_asVhsHandOverrideTag' has a wrong offset!");
static_assert(offsetof(UArmOverrideSurvivorSubAnimInstance, _asIdleArmOverrideTag) == 0x000688, "Member 'UArmOverrideSurvivorSubAnimInstance::_asIdleArmOverrideTag' has a wrong offset!");
static_assert(offsetof(UArmOverrideSurvivorSubAnimInstance, _asCrawlArmOverrideTag) == 0x000694, "Member 'UArmOverrideSurvivorSubAnimInstance::_asCrawlArmOverrideTag' has a wrong offset!");
static_assert(offsetof(UArmOverrideSurvivorSubAnimInstance, _asKeyHandOverride) == 0x0006A0, "Member 'UArmOverrideSurvivorSubAnimInstance::_asKeyHandOverride' has a wrong offset!");
static_assert(offsetof(UArmOverrideSurvivorSubAnimInstance, _asFlashlightHandOverride) == 0x0006A8, "Member 'UArmOverrideSurvivorSubAnimInstance::_asFlashlightHandOverride' has a wrong offset!");
static_assert(offsetof(UArmOverrideSurvivorSubAnimInstance, _asFirecrackerHandOverride) == 0x0006B0, "Member 'UArmOverrideSurvivorSubAnimInstance::_asFirecrackerHandOverride' has a wrong offset!");
static_assert(offsetof(UArmOverrideSurvivorSubAnimInstance, _asFlashlightHandOverrideAim) == 0x0006B8, "Member 'UArmOverrideSurvivorSubAnimInstance::_asFlashlightHandOverrideAim' has a wrong offset!");
static_assert(offsetof(UArmOverrideSurvivorSubAnimInstance, _asPocketMirrorHandOverride) == 0x0006C0, "Member 'UArmOverrideSurvivorSubAnimInstance::_asPocketMirrorHandOverride' has a wrong offset!");
static_assert(offsetof(UArmOverrideSurvivorSubAnimInstance, _asSyringeHandOverride) == 0x0006C8, "Member 'UArmOverrideSurvivorSubAnimInstance::_asSyringeHandOverride' has a wrong offset!");
static_assert(offsetof(UArmOverrideSurvivorSubAnimInstance, _asFlashBangHandOverride) == 0x0006D0, "Member 'UArmOverrideSurvivorSubAnimInstance::_asFlashBangHandOverride' has a wrong offset!");
static_assert(offsetof(UArmOverrideSurvivorSubAnimInstance, _asLamentBoxHandOverride) == 0x0006D8, "Member 'UArmOverrideSurvivorSubAnimInstance::_asLamentBoxHandOverride' has a wrong offset!");
static_assert(offsetof(UArmOverrideSurvivorSubAnimInstance, _asStabilizingSprayOverride) == 0x0006E0, "Member 'UArmOverrideSurvivorSubAnimInstance::_asStabilizingSprayOverride' has a wrong offset!");
static_assert(offsetof(UArmOverrideSurvivorSubAnimInstance, _asKeyCardHandOverride) == 0x0006E8, "Member 'UArmOverrideSurvivorSubAnimInstance::_asKeyCardHandOverride' has a wrong offset!");
static_assert(offsetof(UArmOverrideSurvivorSubAnimInstance, _asVhsHandOverride) == 0x0006F0, "Member 'UArmOverrideSurvivorSubAnimInstance::_asVhsHandOverride' has a wrong offset!");
static_assert(offsetof(UArmOverrideSurvivorSubAnimInstance, _asIdleArmOverride) == 0x0006F8, "Member 'UArmOverrideSurvivorSubAnimInstance::_asIdleArmOverride' has a wrong offset!");
static_assert(offsetof(UArmOverrideSurvivorSubAnimInstance, _asCrawlArmOverride) == 0x000700, "Member 'UArmOverrideSurvivorSubAnimInstance::_asCrawlArmOverride' has a wrong offset!");
static_assert(offsetof(UArmOverrideSurvivorSubAnimInstance, _injuredNotUsingAimItem) == 0x000708, "Member 'UArmOverrideSurvivorSubAnimInstance::_injuredNotUsingAimItem' has a wrong offset!");
static_assert(offsetof(UArmOverrideSurvivorSubAnimInstance, _baseToConduitRule) == 0x00070C, "Member 'UArmOverrideSurvivorSubAnimInstance::_baseToConduitRule' has a wrong offset!");
static_assert(offsetof(UArmOverrideSurvivorSubAnimInstance, _conduitToBaseRule) == 0x00070D, "Member 'UArmOverrideSurvivorSubAnimInstance::_conduitToBaseRule' has a wrong offset!");

// Class DBDAnimation.BasePowerSubAnimInstance
// 0x0010 (0x0600 - 0x05F0)
class UBasePowerSubAnimInstance final : public UBaseKillerAnimInstance
{
public:
	bool                                          _isUsingPower;                                     // 0x05F0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5F1[0xF];                                      // 0x05F1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BasePowerSubAnimInstance">();
	}
	static class UBasePowerSubAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBasePowerSubAnimInstance>();
	}
};
static_assert(alignof(UBasePowerSubAnimInstance) == 0x000010, "Wrong alignment on UBasePowerSubAnimInstance");
static_assert(sizeof(UBasePowerSubAnimInstance) == 0x000600, "Wrong size on UBasePowerSubAnimInstance");
static_assert(offsetof(UBasePowerSubAnimInstance, _isUsingPower) == 0x0005F0, "Member 'UBasePowerSubAnimInstance::_isUsingPower' has a wrong offset!");

// Class DBDAnimation.BipedIKSubAnimInstance
// 0x0390 (0x0710 - 0x0380)
class UBipedIKSubAnimInstance final : public UDBDBaseAnimInstance
{
public:
	bool                                          _enableIK;                                         // 0x0380(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isIdle;                                           // 0x0381(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETraceTypeQuery                               _traceTypeQuery;                                   // 0x0382(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _traceComplex;                                     // 0x0383(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _ignoreTouches;                                    // 0x0384(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_385[0x3];                                      // 0x0385(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   _noGroundTag;                                      // 0x0388(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _footIkSpeed;                                      // 0x0394(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _pelvisIkSpeed;                                    // 0x0398(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _maxExtensionLeftFoot;                             // 0x039C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _maxExtensionRightFoot;                            // 0x03A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _footIkSpeedMovingHF2;                             // 0x03A4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _footIkSpeedIdleHF2;                               // 0x03A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _ikBlendSpeedHF2;                                  // 0x03AC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _footIkRotationSpeed;                              // 0x03B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _pelvisIkSpeedHF2;                                 // 0x03B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _maxIKTargetDistance;                              // 0x03B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _pelvisPositionOffsetMin;                          // 0x03BC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _pelvisPositionOffsetMax;                          // 0x03C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _pelvisPositionOffsetMinHF2;                       // 0x03C4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _pelvisPositionOffsetMaxHF2;                       // 0x03C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _pelvisPositionOffsetMinIdleHF2;                   // 0x03CC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _pelvisPositionOffsetMaxIdleHF2;                   // 0x03D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _frontFeetLineTraceStartOffset;                    // 0x03D4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _frontFeetLineTraceEndOffset;                      // 0x03D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _backFeetLineTraceStartOffset;                     // 0x03DC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _backFeetLineTraceEndOffset;                       // 0x03E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _minDistanceFromCapsuleIdle;                       // 0x03E4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _maxDistanceFromCapsuleIdle;                       // 0x03E8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _minDistanceFromCapsuleMoving;                     // 0x03EC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _maxDistanceFromCapsuleMoving;                     // 0x03F0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _pelvisSocketName;                                 // 0x03F4(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _leftBackFootSocketName;                           // 0x0400(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _rightBackFootSocketName;                          // 0x040C(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _leftBackFootBoneName;                             // 0x0418(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _rightBackFootBoneName;                            // 0x0424(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _leftBackFootRootBoneName;                         // 0x0430(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _rightBackFootRootBoneName;                        // 0x043C(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                _pelvisPositionOffset;                             // 0x0448(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                _leftBackFootLocation;                             // 0x0460(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                _rightBackFootLocation;                            // 0x0478(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTransform                             _leftBackFootTransform;                            // 0x0490(0x0060)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTransform                             _rightBackFootTransform;                           // 0x04F0(0x0060)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               _leftBackFootRotation;                             // 0x0550(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FRotator                               _rightBackFootRotation;                            // 0x0568(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 _skeletalMeshComponent;                            // 0x0580(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWorld*                                 _world;                                            // 0x0588(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_590[0x180];                                    // 0x0590(0x0180)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BipedIKSubAnimInstance">();
	}
	static class UBipedIKSubAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBipedIKSubAnimInstance>();
	}
};
static_assert(alignof(UBipedIKSubAnimInstance) == 0x000010, "Wrong alignment on UBipedIKSubAnimInstance");
static_assert(sizeof(UBipedIKSubAnimInstance) == 0x000710, "Wrong size on UBipedIKSubAnimInstance");
static_assert(offsetof(UBipedIKSubAnimInstance, _enableIK) == 0x000380, "Member 'UBipedIKSubAnimInstance::_enableIK' has a wrong offset!");
static_assert(offsetof(UBipedIKSubAnimInstance, _isIdle) == 0x000381, "Member 'UBipedIKSubAnimInstance::_isIdle' has a wrong offset!");
static_assert(offsetof(UBipedIKSubAnimInstance, _traceTypeQuery) == 0x000382, "Member 'UBipedIKSubAnimInstance::_traceTypeQuery' has a wrong offset!");
static_assert(offsetof(UBipedIKSubAnimInstance, _traceComplex) == 0x000383, "Member 'UBipedIKSubAnimInstance::_traceComplex' has a wrong offset!");
static_assert(offsetof(UBipedIKSubAnimInstance, _ignoreTouches) == 0x000384, "Member 'UBipedIKSubAnimInstance::_ignoreTouches' has a wrong offset!");
static_assert(offsetof(UBipedIKSubAnimInstance, _noGroundTag) == 0x000388, "Member 'UBipedIKSubAnimInstance::_noGroundTag' has a wrong offset!");
static_assert(offsetof(UBipedIKSubAnimInstance, _footIkSpeed) == 0x000394, "Member 'UBipedIKSubAnimInstance::_footIkSpeed' has a wrong offset!");
static_assert(offsetof(UBipedIKSubAnimInstance, _pelvisIkSpeed) == 0x000398, "Member 'UBipedIKSubAnimInstance::_pelvisIkSpeed' has a wrong offset!");
static_assert(offsetof(UBipedIKSubAnimInstance, _maxExtensionLeftFoot) == 0x00039C, "Member 'UBipedIKSubAnimInstance::_maxExtensionLeftFoot' has a wrong offset!");
static_assert(offsetof(UBipedIKSubAnimInstance, _maxExtensionRightFoot) == 0x0003A0, "Member 'UBipedIKSubAnimInstance::_maxExtensionRightFoot' has a wrong offset!");
static_assert(offsetof(UBipedIKSubAnimInstance, _footIkSpeedMovingHF2) == 0x0003A4, "Member 'UBipedIKSubAnimInstance::_footIkSpeedMovingHF2' has a wrong offset!");
static_assert(offsetof(UBipedIKSubAnimInstance, _footIkSpeedIdleHF2) == 0x0003A8, "Member 'UBipedIKSubAnimInstance::_footIkSpeedIdleHF2' has a wrong offset!");
static_assert(offsetof(UBipedIKSubAnimInstance, _ikBlendSpeedHF2) == 0x0003AC, "Member 'UBipedIKSubAnimInstance::_ikBlendSpeedHF2' has a wrong offset!");
static_assert(offsetof(UBipedIKSubAnimInstance, _footIkRotationSpeed) == 0x0003B0, "Member 'UBipedIKSubAnimInstance::_footIkRotationSpeed' has a wrong offset!");
static_assert(offsetof(UBipedIKSubAnimInstance, _pelvisIkSpeedHF2) == 0x0003B4, "Member 'UBipedIKSubAnimInstance::_pelvisIkSpeedHF2' has a wrong offset!");
static_assert(offsetof(UBipedIKSubAnimInstance, _maxIKTargetDistance) == 0x0003B8, "Member 'UBipedIKSubAnimInstance::_maxIKTargetDistance' has a wrong offset!");
static_assert(offsetof(UBipedIKSubAnimInstance, _pelvisPositionOffsetMin) == 0x0003BC, "Member 'UBipedIKSubAnimInstance::_pelvisPositionOffsetMin' has a wrong offset!");
static_assert(offsetof(UBipedIKSubAnimInstance, _pelvisPositionOffsetMax) == 0x0003C0, "Member 'UBipedIKSubAnimInstance::_pelvisPositionOffsetMax' has a wrong offset!");
static_assert(offsetof(UBipedIKSubAnimInstance, _pelvisPositionOffsetMinHF2) == 0x0003C4, "Member 'UBipedIKSubAnimInstance::_pelvisPositionOffsetMinHF2' has a wrong offset!");
static_assert(offsetof(UBipedIKSubAnimInstance, _pelvisPositionOffsetMaxHF2) == 0x0003C8, "Member 'UBipedIKSubAnimInstance::_pelvisPositionOffsetMaxHF2' has a wrong offset!");
static_assert(offsetof(UBipedIKSubAnimInstance, _pelvisPositionOffsetMinIdleHF2) == 0x0003CC, "Member 'UBipedIKSubAnimInstance::_pelvisPositionOffsetMinIdleHF2' has a wrong offset!");
static_assert(offsetof(UBipedIKSubAnimInstance, _pelvisPositionOffsetMaxIdleHF2) == 0x0003D0, "Member 'UBipedIKSubAnimInstance::_pelvisPositionOffsetMaxIdleHF2' has a wrong offset!");
static_assert(offsetof(UBipedIKSubAnimInstance, _frontFeetLineTraceStartOffset) == 0x0003D4, "Member 'UBipedIKSubAnimInstance::_frontFeetLineTraceStartOffset' has a wrong offset!");
static_assert(offsetof(UBipedIKSubAnimInstance, _frontFeetLineTraceEndOffset) == 0x0003D8, "Member 'UBipedIKSubAnimInstance::_frontFeetLineTraceEndOffset' has a wrong offset!");
static_assert(offsetof(UBipedIKSubAnimInstance, _backFeetLineTraceStartOffset) == 0x0003DC, "Member 'UBipedIKSubAnimInstance::_backFeetLineTraceStartOffset' has a wrong offset!");
static_assert(offsetof(UBipedIKSubAnimInstance, _backFeetLineTraceEndOffset) == 0x0003E0, "Member 'UBipedIKSubAnimInstance::_backFeetLineTraceEndOffset' has a wrong offset!");
static_assert(offsetof(UBipedIKSubAnimInstance, _minDistanceFromCapsuleIdle) == 0x0003E4, "Member 'UBipedIKSubAnimInstance::_minDistanceFromCapsuleIdle' has a wrong offset!");
static_assert(offsetof(UBipedIKSubAnimInstance, _maxDistanceFromCapsuleIdle) == 0x0003E8, "Member 'UBipedIKSubAnimInstance::_maxDistanceFromCapsuleIdle' has a wrong offset!");
static_assert(offsetof(UBipedIKSubAnimInstance, _minDistanceFromCapsuleMoving) == 0x0003EC, "Member 'UBipedIKSubAnimInstance::_minDistanceFromCapsuleMoving' has a wrong offset!");
static_assert(offsetof(UBipedIKSubAnimInstance, _maxDistanceFromCapsuleMoving) == 0x0003F0, "Member 'UBipedIKSubAnimInstance::_maxDistanceFromCapsuleMoving' has a wrong offset!");
static_assert(offsetof(UBipedIKSubAnimInstance, _pelvisSocketName) == 0x0003F4, "Member 'UBipedIKSubAnimInstance::_pelvisSocketName' has a wrong offset!");
static_assert(offsetof(UBipedIKSubAnimInstance, _leftBackFootSocketName) == 0x000400, "Member 'UBipedIKSubAnimInstance::_leftBackFootSocketName' has a wrong offset!");
static_assert(offsetof(UBipedIKSubAnimInstance, _rightBackFootSocketName) == 0x00040C, "Member 'UBipedIKSubAnimInstance::_rightBackFootSocketName' has a wrong offset!");
static_assert(offsetof(UBipedIKSubAnimInstance, _leftBackFootBoneName) == 0x000418, "Member 'UBipedIKSubAnimInstance::_leftBackFootBoneName' has a wrong offset!");
static_assert(offsetof(UBipedIKSubAnimInstance, _rightBackFootBoneName) == 0x000424, "Member 'UBipedIKSubAnimInstance::_rightBackFootBoneName' has a wrong offset!");
static_assert(offsetof(UBipedIKSubAnimInstance, _leftBackFootRootBoneName) == 0x000430, "Member 'UBipedIKSubAnimInstance::_leftBackFootRootBoneName' has a wrong offset!");
static_assert(offsetof(UBipedIKSubAnimInstance, _rightBackFootRootBoneName) == 0x00043C, "Member 'UBipedIKSubAnimInstance::_rightBackFootRootBoneName' has a wrong offset!");
static_assert(offsetof(UBipedIKSubAnimInstance, _pelvisPositionOffset) == 0x000448, "Member 'UBipedIKSubAnimInstance::_pelvisPositionOffset' has a wrong offset!");
static_assert(offsetof(UBipedIKSubAnimInstance, _leftBackFootLocation) == 0x000460, "Member 'UBipedIKSubAnimInstance::_leftBackFootLocation' has a wrong offset!");
static_assert(offsetof(UBipedIKSubAnimInstance, _rightBackFootLocation) == 0x000478, "Member 'UBipedIKSubAnimInstance::_rightBackFootLocation' has a wrong offset!");
static_assert(offsetof(UBipedIKSubAnimInstance, _leftBackFootTransform) == 0x000490, "Member 'UBipedIKSubAnimInstance::_leftBackFootTransform' has a wrong offset!");
static_assert(offsetof(UBipedIKSubAnimInstance, _rightBackFootTransform) == 0x0004F0, "Member 'UBipedIKSubAnimInstance::_rightBackFootTransform' has a wrong offset!");
static_assert(offsetof(UBipedIKSubAnimInstance, _leftBackFootRotation) == 0x000550, "Member 'UBipedIKSubAnimInstance::_leftBackFootRotation' has a wrong offset!");
static_assert(offsetof(UBipedIKSubAnimInstance, _rightBackFootRotation) == 0x000568, "Member 'UBipedIKSubAnimInstance::_rightBackFootRotation' has a wrong offset!");
static_assert(offsetof(UBipedIKSubAnimInstance, _skeletalMeshComponent) == 0x000580, "Member 'UBipedIKSubAnimInstance::_skeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(UBipedIKSubAnimInstance, _world) == 0x000588, "Member 'UBipedIKSubAnimInstance::_world' has a wrong offset!");

// Class DBDAnimation.BreathingSurvivorSubAnimInstance
// 0x0030 (0x0610 - 0x05E0)
class UBreathingSurvivorSubAnimInstance : public UBaseSurvivorAnimInstance
{
public:
	bool                                          _isDead;                                           // 0x05E0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isCrawling;                                       // 0x05E1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5E2[0x2];                                      // 0x05E2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           _asBreathingTag;                                   // 0x05E4(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _asBreathingCrawlingTag;                           // 0x05F0(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5FC[0x4];                                      // 0x05FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          _asBreathing;                                      // 0x0600(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _asBreathingCrawling;                              // 0x0608(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BreathingSurvivorSubAnimInstance">();
	}
	static class UBreathingSurvivorSubAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBreathingSurvivorSubAnimInstance>();
	}
};
static_assert(alignof(UBreathingSurvivorSubAnimInstance) == 0x000010, "Wrong alignment on UBreathingSurvivorSubAnimInstance");
static_assert(sizeof(UBreathingSurvivorSubAnimInstance) == 0x000610, "Wrong size on UBreathingSurvivorSubAnimInstance");
static_assert(offsetof(UBreathingSurvivorSubAnimInstance, _isDead) == 0x0005E0, "Member 'UBreathingSurvivorSubAnimInstance::_isDead' has a wrong offset!");
static_assert(offsetof(UBreathingSurvivorSubAnimInstance, _isCrawling) == 0x0005E1, "Member 'UBreathingSurvivorSubAnimInstance::_isCrawling' has a wrong offset!");
static_assert(offsetof(UBreathingSurvivorSubAnimInstance, _asBreathingTag) == 0x0005E4, "Member 'UBreathingSurvivorSubAnimInstance::_asBreathingTag' has a wrong offset!");
static_assert(offsetof(UBreathingSurvivorSubAnimInstance, _asBreathingCrawlingTag) == 0x0005F0, "Member 'UBreathingSurvivorSubAnimInstance::_asBreathingCrawlingTag' has a wrong offset!");
static_assert(offsetof(UBreathingSurvivorSubAnimInstance, _asBreathing) == 0x000600, "Member 'UBreathingSurvivorSubAnimInstance::_asBreathing' has a wrong offset!");
static_assert(offsetof(UBreathingSurvivorSubAnimInstance, _asBreathingCrawling) == 0x000608, "Member 'UBreathingSurvivorSubAnimInstance::_asBreathingCrawling' has a wrong offset!");

// Class DBDAnimation.CharacterAnimationLayerManager
// 0x00C8 (0x0170 - 0x00A8)
class UCharacterAnimationLayerManager : public UActorComponent
{
public:
	class UDataTable*                             _animationLayerDB;                                 // 0x00A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B0[0xC0];                                      // 0x00B0(0x00C0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void UnlinkAnimationLayerByGroup(const struct FGameplayTag& Group);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterAnimationLayerManager">();
	}
	static class UCharacterAnimationLayerManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterAnimationLayerManager>();
	}
};
static_assert(alignof(UCharacterAnimationLayerManager) == 0x000008, "Wrong alignment on UCharacterAnimationLayerManager");
static_assert(sizeof(UCharacterAnimationLayerManager) == 0x000170, "Wrong size on UCharacterAnimationLayerManager");
static_assert(offsetof(UCharacterAnimationLayerManager, _animationLayerDB) == 0x0000A8, "Member 'UCharacterAnimationLayerManager::_animationLayerDB' has a wrong offset!");

// Class DBDAnimation.ChestAnimInstance
// 0x0010 (0x0370 - 0x0360)
class UChestAnimInstance : public USleepingAnimInstance
{
public:
	bool                                          _isOpen;                                           // 0x0360(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isBeingPriedOpen;                                 // 0x0361(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_362[0xE];                                      // 0x0362(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnBeingPriedOpenStarted(class ADBDPlayer* Player);
	void OnBeingPriedOpenStopped();
	void OnIsOpenedChanged(const bool IsOpened);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChestAnimInstance">();
	}
	static class UChestAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChestAnimInstance>();
	}
};
static_assert(alignof(UChestAnimInstance) == 0x000010, "Wrong alignment on UChestAnimInstance");
static_assert(sizeof(UChestAnimInstance) == 0x000370, "Wrong size on UChestAnimInstance");
static_assert(offsetof(UChestAnimInstance, _isOpen) == 0x000360, "Member 'UChestAnimInstance::_isOpen' has a wrong offset!");
static_assert(offsetof(UChestAnimInstance, _isBeingPriedOpen) == 0x000361, "Member 'UChestAnimInstance::_isBeingPriedOpen' has a wrong offset!");

// Class DBDAnimation.CrownSubAnimInstance
// 0x0070 (0x0650 - 0x05E0)
class UCrownSubAnimInstance : public UBaseSurvivorAnimInstance
{
public:
	bool                                          _isInjured;                                        // 0x05E0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EInteractionAnimation                         _interactionType;                                  // 0x05E1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5E2[0x2];                                      // 0x05E2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _interactionDuration;                              // 0x05E4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _interactionPlayrate;                              // 0x05E8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _takeCrownTag;                                     // 0x05EC(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _takeCrownInjuredTag;                              // 0x05F8(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _takeGlyphTag;                                     // 0x0604(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _takeGlyphInjuredTag;                              // 0x0610(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_61C[0x4];                                      // 0x061C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          _takeCrownAS;                                      // 0x0620(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _takeCrownInjuredAS;                               // 0x0628(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _takeGlyphAS;                                      // 0x0630(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _takeGlyphInjuredAS;                               // 0x0638(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _unstableRiftInteractionToBaseRule;                // 0x0640(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _baseToGlyphRule;                                  // 0x0641(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _baseToUnstableRiftInteractionRule;                // 0x0642(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _baseToCrownInteractionRule;                       // 0x0643(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _crownInteractionToBaseRule;                       // 0x0644(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _glyphToBaseRule;                                  // 0x0645(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_646[0xA];                                      // 0x0646(0x000A)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrownSubAnimInstance">();
	}
	static class UCrownSubAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrownSubAnimInstance>();
	}
};
static_assert(alignof(UCrownSubAnimInstance) == 0x000010, "Wrong alignment on UCrownSubAnimInstance");
static_assert(sizeof(UCrownSubAnimInstance) == 0x000650, "Wrong size on UCrownSubAnimInstance");
static_assert(offsetof(UCrownSubAnimInstance, _isInjured) == 0x0005E0, "Member 'UCrownSubAnimInstance::_isInjured' has a wrong offset!");
static_assert(offsetof(UCrownSubAnimInstance, _interactionType) == 0x0005E1, "Member 'UCrownSubAnimInstance::_interactionType' has a wrong offset!");
static_assert(offsetof(UCrownSubAnimInstance, _interactionDuration) == 0x0005E4, "Member 'UCrownSubAnimInstance::_interactionDuration' has a wrong offset!");
static_assert(offsetof(UCrownSubAnimInstance, _interactionPlayrate) == 0x0005E8, "Member 'UCrownSubAnimInstance::_interactionPlayrate' has a wrong offset!");
static_assert(offsetof(UCrownSubAnimInstance, _takeCrownTag) == 0x0005EC, "Member 'UCrownSubAnimInstance::_takeCrownTag' has a wrong offset!");
static_assert(offsetof(UCrownSubAnimInstance, _takeCrownInjuredTag) == 0x0005F8, "Member 'UCrownSubAnimInstance::_takeCrownInjuredTag' has a wrong offset!");
static_assert(offsetof(UCrownSubAnimInstance, _takeGlyphTag) == 0x000604, "Member 'UCrownSubAnimInstance::_takeGlyphTag' has a wrong offset!");
static_assert(offsetof(UCrownSubAnimInstance, _takeGlyphInjuredTag) == 0x000610, "Member 'UCrownSubAnimInstance::_takeGlyphInjuredTag' has a wrong offset!");
static_assert(offsetof(UCrownSubAnimInstance, _takeCrownAS) == 0x000620, "Member 'UCrownSubAnimInstance::_takeCrownAS' has a wrong offset!");
static_assert(offsetof(UCrownSubAnimInstance, _takeCrownInjuredAS) == 0x000628, "Member 'UCrownSubAnimInstance::_takeCrownInjuredAS' has a wrong offset!");
static_assert(offsetof(UCrownSubAnimInstance, _takeGlyphAS) == 0x000630, "Member 'UCrownSubAnimInstance::_takeGlyphAS' has a wrong offset!");
static_assert(offsetof(UCrownSubAnimInstance, _takeGlyphInjuredAS) == 0x000638, "Member 'UCrownSubAnimInstance::_takeGlyphInjuredAS' has a wrong offset!");
static_assert(offsetof(UCrownSubAnimInstance, _unstableRiftInteractionToBaseRule) == 0x000640, "Member 'UCrownSubAnimInstance::_unstableRiftInteractionToBaseRule' has a wrong offset!");
static_assert(offsetof(UCrownSubAnimInstance, _baseToGlyphRule) == 0x000641, "Member 'UCrownSubAnimInstance::_baseToGlyphRule' has a wrong offset!");
static_assert(offsetof(UCrownSubAnimInstance, _baseToUnstableRiftInteractionRule) == 0x000642, "Member 'UCrownSubAnimInstance::_baseToUnstableRiftInteractionRule' has a wrong offset!");
static_assert(offsetof(UCrownSubAnimInstance, _baseToCrownInteractionRule) == 0x000643, "Member 'UCrownSubAnimInstance::_baseToCrownInteractionRule' has a wrong offset!");
static_assert(offsetof(UCrownSubAnimInstance, _crownInteractionToBaseRule) == 0x000644, "Member 'UCrownSubAnimInstance::_crownInteractionToBaseRule' has a wrong offset!");
static_assert(offsetof(UCrownSubAnimInstance, _glyphToBaseRule) == 0x000645, "Member 'UCrownSubAnimInstance::_glyphToBaseRule' has a wrong offset!");

// Class DBDAnimation.CustomizationAnimationSelector
// 0x0068 (0x0098 - 0x0030)
class UCustomizationAnimationSelector final : public UObject
{
public:
	uint8                                         Pad_30[0x18];                                      // 0x0030(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             _customizationAnimationMappings;                   // 0x0048(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_50[0x38];                                      // 0x0050(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	class UCustomizedSkeletalMesh*                _customizedSkeletalMesh;                           // 0x0088(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_90[0x8];                                       // 0x0090(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomizationAnimationSelector">();
	}
	static class UCustomizationAnimationSelector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomizationAnimationSelector>();
	}
};
static_assert(alignof(UCustomizationAnimationSelector) == 0x000008, "Wrong alignment on UCustomizationAnimationSelector");
static_assert(sizeof(UCustomizationAnimationSelector) == 0x000098, "Wrong size on UCustomizationAnimationSelector");
static_assert(offsetof(UCustomizationAnimationSelector, _customizationAnimationMappings) == 0x000048, "Member 'UCustomizationAnimationSelector::_customizationAnimationMappings' has a wrong offset!");
static_assert(offsetof(UCustomizationAnimationSelector, _customizedSkeletalMesh) == 0x000088, "Member 'UCustomizationAnimationSelector::_customizedSkeletalMesh' has a wrong offset!");

// Class DBDAnimation.DynamicSurvivorSubAnimInstance
// 0x0030 (0x0610 - 0x05E0)
class UDynamicSurvivorSubAnimInstance : public UBaseSurvivorAnimInstance
{
public:
	bool                                          _dynamics;                                         // 0x05E0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isKate;                                           // 0x05E1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isJane;                                           // 0x05E2(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isCrouched;                                       // 0x05E3(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isInjured;                                        // 0x05E4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isJohn;                                           // 0x05E5(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isSteve;                                          // 0x05E6(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isS26;                                            // 0x05E7(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isS2602;                                          // 0x05E8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isS27;                                            // 0x05E9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isS2702;                                          // 0x05EA(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5EB[0x1];                                      // 0x05EB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _notCrouchedSpringStiffness;                       // 0x05EC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _crouchedSpringStiffness;                          // 0x05F0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _injuredSpringStiffness;                           // 0x05F4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _uninjuredSpringStiffness;                         // 0x05F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _notCrouchedFloat;                                 // 0x05FC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _isInjuredFloat;                                   // 0x0600(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_604[0xC];                                      // 0x0604(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicSurvivorSubAnimInstance">();
	}
	static class UDynamicSurvivorSubAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDynamicSurvivorSubAnimInstance>();
	}
};
static_assert(alignof(UDynamicSurvivorSubAnimInstance) == 0x000010, "Wrong alignment on UDynamicSurvivorSubAnimInstance");
static_assert(sizeof(UDynamicSurvivorSubAnimInstance) == 0x000610, "Wrong size on UDynamicSurvivorSubAnimInstance");
static_assert(offsetof(UDynamicSurvivorSubAnimInstance, _dynamics) == 0x0005E0, "Member 'UDynamicSurvivorSubAnimInstance::_dynamics' has a wrong offset!");
static_assert(offsetof(UDynamicSurvivorSubAnimInstance, _isKate) == 0x0005E1, "Member 'UDynamicSurvivorSubAnimInstance::_isKate' has a wrong offset!");
static_assert(offsetof(UDynamicSurvivorSubAnimInstance, _isJane) == 0x0005E2, "Member 'UDynamicSurvivorSubAnimInstance::_isJane' has a wrong offset!");
static_assert(offsetof(UDynamicSurvivorSubAnimInstance, _isCrouched) == 0x0005E3, "Member 'UDynamicSurvivorSubAnimInstance::_isCrouched' has a wrong offset!");
static_assert(offsetof(UDynamicSurvivorSubAnimInstance, _isInjured) == 0x0005E4, "Member 'UDynamicSurvivorSubAnimInstance::_isInjured' has a wrong offset!");
static_assert(offsetof(UDynamicSurvivorSubAnimInstance, _isJohn) == 0x0005E5, "Member 'UDynamicSurvivorSubAnimInstance::_isJohn' has a wrong offset!");
static_assert(offsetof(UDynamicSurvivorSubAnimInstance, _isSteve) == 0x0005E6, "Member 'UDynamicSurvivorSubAnimInstance::_isSteve' has a wrong offset!");
static_assert(offsetof(UDynamicSurvivorSubAnimInstance, _isS26) == 0x0005E7, "Member 'UDynamicSurvivorSubAnimInstance::_isS26' has a wrong offset!");
static_assert(offsetof(UDynamicSurvivorSubAnimInstance, _isS2602) == 0x0005E8, "Member 'UDynamicSurvivorSubAnimInstance::_isS2602' has a wrong offset!");
static_assert(offsetof(UDynamicSurvivorSubAnimInstance, _isS27) == 0x0005E9, "Member 'UDynamicSurvivorSubAnimInstance::_isS27' has a wrong offset!");
static_assert(offsetof(UDynamicSurvivorSubAnimInstance, _isS2702) == 0x0005EA, "Member 'UDynamicSurvivorSubAnimInstance::_isS2702' has a wrong offset!");
static_assert(offsetof(UDynamicSurvivorSubAnimInstance, _notCrouchedSpringStiffness) == 0x0005EC, "Member 'UDynamicSurvivorSubAnimInstance::_notCrouchedSpringStiffness' has a wrong offset!");
static_assert(offsetof(UDynamicSurvivorSubAnimInstance, _crouchedSpringStiffness) == 0x0005F0, "Member 'UDynamicSurvivorSubAnimInstance::_crouchedSpringStiffness' has a wrong offset!");
static_assert(offsetof(UDynamicSurvivorSubAnimInstance, _injuredSpringStiffness) == 0x0005F4, "Member 'UDynamicSurvivorSubAnimInstance::_injuredSpringStiffness' has a wrong offset!");
static_assert(offsetof(UDynamicSurvivorSubAnimInstance, _uninjuredSpringStiffness) == 0x0005F8, "Member 'UDynamicSurvivorSubAnimInstance::_uninjuredSpringStiffness' has a wrong offset!");
static_assert(offsetof(UDynamicSurvivorSubAnimInstance, _notCrouchedFloat) == 0x0005FC, "Member 'UDynamicSurvivorSubAnimInstance::_notCrouchedFloat' has a wrong offset!");
static_assert(offsetof(UDynamicSurvivorSubAnimInstance, _isInjuredFloat) == 0x000600, "Member 'UDynamicSurvivorSubAnimInstance::_isInjuredFloat' has a wrong offset!");

// Class DBDAnimation.EntityAnimInstance
// 0x0010 (0x0360 - 0x0350)
class UEntityAnimInstance : public UAnimInstance
{
public:
	bool                                          _isStruggling;                                     // 0x0350(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_351[0x3];                                      // 0x0351(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _strugglePercent;                                  // 0x0354(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_358[0x8];                                      // 0x0358(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EntityAnimInstance">();
	}
	static class UEntityAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEntityAnimInstance>();
	}
};
static_assert(alignof(UEntityAnimInstance) == 0x000010, "Wrong alignment on UEntityAnimInstance");
static_assert(sizeof(UEntityAnimInstance) == 0x000360, "Wrong size on UEntityAnimInstance");
static_assert(offsetof(UEntityAnimInstance, _isStruggling) == 0x000350, "Member 'UEntityAnimInstance::_isStruggling' has a wrong offset!");
static_assert(offsetof(UEntityAnimInstance, _strugglePercent) == 0x000354, "Member 'UEntityAnimInstance::_strugglePercent' has a wrong offset!");

// Class DBDAnimation.ExitDoorActivationSurvivorSubAnimInstance
// 0x0060 (0x0640 - 0x05E0)
class UExitDoorActivationSurvivorSubAnimInstance : public UBaseSurvivorAnimInstance
{
public:
	bool                                          _isInteractingWithSwitch;                          // 0x05E0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5E1[0x7];                                      // 0x05E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                _snapPosition;                                     // 0x05E8(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _openEscapeTag;                                    // 0x0600(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _resetSteamPipesTag;                               // 0x060C(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _asExitDoorActivationInTag;                        // 0x0618(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _asExitDoorActivationLoopTag;                      // 0x0624(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _asExitDoorActivationIn;                           // 0x0630(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _asExitDoorActivationLoop;                         // 0x0638(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExitDoorActivationSurvivorSubAnimInstance">();
	}
	static class UExitDoorActivationSurvivorSubAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UExitDoorActivationSurvivorSubAnimInstance>();
	}
};
static_assert(alignof(UExitDoorActivationSurvivorSubAnimInstance) == 0x000010, "Wrong alignment on UExitDoorActivationSurvivorSubAnimInstance");
static_assert(sizeof(UExitDoorActivationSurvivorSubAnimInstance) == 0x000640, "Wrong size on UExitDoorActivationSurvivorSubAnimInstance");
static_assert(offsetof(UExitDoorActivationSurvivorSubAnimInstance, _isInteractingWithSwitch) == 0x0005E0, "Member 'UExitDoorActivationSurvivorSubAnimInstance::_isInteractingWithSwitch' has a wrong offset!");
static_assert(offsetof(UExitDoorActivationSurvivorSubAnimInstance, _snapPosition) == 0x0005E8, "Member 'UExitDoorActivationSurvivorSubAnimInstance::_snapPosition' has a wrong offset!");
static_assert(offsetof(UExitDoorActivationSurvivorSubAnimInstance, _openEscapeTag) == 0x000600, "Member 'UExitDoorActivationSurvivorSubAnimInstance::_openEscapeTag' has a wrong offset!");
static_assert(offsetof(UExitDoorActivationSurvivorSubAnimInstance, _resetSteamPipesTag) == 0x00060C, "Member 'UExitDoorActivationSurvivorSubAnimInstance::_resetSteamPipesTag' has a wrong offset!");
static_assert(offsetof(UExitDoorActivationSurvivorSubAnimInstance, _asExitDoorActivationInTag) == 0x000618, "Member 'UExitDoorActivationSurvivorSubAnimInstance::_asExitDoorActivationInTag' has a wrong offset!");
static_assert(offsetof(UExitDoorActivationSurvivorSubAnimInstance, _asExitDoorActivationLoopTag) == 0x000624, "Member 'UExitDoorActivationSurvivorSubAnimInstance::_asExitDoorActivationLoopTag' has a wrong offset!");
static_assert(offsetof(UExitDoorActivationSurvivorSubAnimInstance, _asExitDoorActivationIn) == 0x000630, "Member 'UExitDoorActivationSurvivorSubAnimInstance::_asExitDoorActivationIn' has a wrong offset!");
static_assert(offsetof(UExitDoorActivationSurvivorSubAnimInstance, _asExitDoorActivationLoop) == 0x000638, "Member 'UExitDoorActivationSurvivorSubAnimInstance::_asExitDoorActivationLoop' has a wrong offset!");

// Class DBDAnimation.FaceCorrectionSurvivorSubAnimInstance
// 0x0010 (0x05F0 - 0x05E0)
class UFaceCorrectionSurvivorSubAnimInstance final : public UBaseSurvivorAnimInstance
{
public:
	bool                                          _isIdle;                                           // 0x05E0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isFreddyMori;                                     // 0x05E1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isInCloset;                                       // 0x05E2(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isEdgeCase;                                       // 0x05E3(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isInjured;                                        // 0x05E4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isHealingOthers;                                  // 0x05E5(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isCrouched;                                       // 0x05E6(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5E7[0x9];                                      // 0x05E7(0x0009)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FaceCorrectionSurvivorSubAnimInstance">();
	}
	static class UFaceCorrectionSurvivorSubAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFaceCorrectionSurvivorSubAnimInstance>();
	}
};
static_assert(alignof(UFaceCorrectionSurvivorSubAnimInstance) == 0x000010, "Wrong alignment on UFaceCorrectionSurvivorSubAnimInstance");
static_assert(sizeof(UFaceCorrectionSurvivorSubAnimInstance) == 0x0005F0, "Wrong size on UFaceCorrectionSurvivorSubAnimInstance");
static_assert(offsetof(UFaceCorrectionSurvivorSubAnimInstance, _isIdle) == 0x0005E0, "Member 'UFaceCorrectionSurvivorSubAnimInstance::_isIdle' has a wrong offset!");
static_assert(offsetof(UFaceCorrectionSurvivorSubAnimInstance, _isFreddyMori) == 0x0005E1, "Member 'UFaceCorrectionSurvivorSubAnimInstance::_isFreddyMori' has a wrong offset!");
static_assert(offsetof(UFaceCorrectionSurvivorSubAnimInstance, _isInCloset) == 0x0005E2, "Member 'UFaceCorrectionSurvivorSubAnimInstance::_isInCloset' has a wrong offset!");
static_assert(offsetof(UFaceCorrectionSurvivorSubAnimInstance, _isEdgeCase) == 0x0005E3, "Member 'UFaceCorrectionSurvivorSubAnimInstance::_isEdgeCase' has a wrong offset!");
static_assert(offsetof(UFaceCorrectionSurvivorSubAnimInstance, _isInjured) == 0x0005E4, "Member 'UFaceCorrectionSurvivorSubAnimInstance::_isInjured' has a wrong offset!");
static_assert(offsetof(UFaceCorrectionSurvivorSubAnimInstance, _isHealingOthers) == 0x0005E5, "Member 'UFaceCorrectionSurvivorSubAnimInstance::_isHealingOthers' has a wrong offset!");
static_assert(offsetof(UFaceCorrectionSurvivorSubAnimInstance, _isCrouched) == 0x0005E6, "Member 'UFaceCorrectionSurvivorSubAnimInstance::_isCrouched' has a wrong offset!");

// Class DBDAnimation.FallSurvivorSubAnimInstance
// 0x00F0 (0x06D0 - 0x05E0)
class UFallSurvivorSubAnimInstance : public UBaseSurvivorAnimInstance
{
public:
	float                                         _dropStaggerTimeLeft;                              // 0x05E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _maxSpeed;                                         // 0x05E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _speed;                                            // 0x05E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _inAir;                                            // 0x05EC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isCrawling;                                       // 0x05ED(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5EE[0x2];                                      // 0x05EE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           _asCrawlToFallTag;                                 // 0x05F0(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _asFallToCrawlTag;                                 // 0x05FC(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _asFallHardLoopTag;                                // 0x0608(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _asFallHardInTag;                                  // 0x0614(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _asFallTag;                                        // 0x0620(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _asWalkToFallTag;                                  // 0x062C(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _bsHardLandOutTag;                                 // 0x0638(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _bsLandTag;                                        // 0x0644(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _asCrawlToFall;                                    // 0x0650(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _asFallToCrawl;                                    // 0x0658(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _asFallHardLoop;                                   // 0x0660(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _asFallHardIn;                                     // 0x0668(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _asFall;                                           // 0x0670(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _asWalkToFall;                                     // 0x0678(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBlendSpace1D*                          _bsHardLandOut;                                    // 0x0680(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBlendSpace1D*                          _bsLand;                                           // 0x0688(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _walkToFallToFallToLandRule;                       // 0x0690(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _walkToFallToLandSoftRule;                         // 0x0691(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _fallToFallToLandRule;                             // 0x0692(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _fallToLandSoftRule;                               // 0x0693(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _landSoftToBaseRule;                               // 0x0694(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _fallToLandToLandHardOutRule;                      // 0x0695(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _landHardToLandHardOutRule;                        // 0x0696(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _landHardOutToBaseRule;                            // 0x0697(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_698[0x38];                                     // 0x0698(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FallSurvivorSubAnimInstance">();
	}
	static class UFallSurvivorSubAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFallSurvivorSubAnimInstance>();
	}
};
static_assert(alignof(UFallSurvivorSubAnimInstance) == 0x000010, "Wrong alignment on UFallSurvivorSubAnimInstance");
static_assert(sizeof(UFallSurvivorSubAnimInstance) == 0x0006D0, "Wrong size on UFallSurvivorSubAnimInstance");
static_assert(offsetof(UFallSurvivorSubAnimInstance, _dropStaggerTimeLeft) == 0x0005E0, "Member 'UFallSurvivorSubAnimInstance::_dropStaggerTimeLeft' has a wrong offset!");
static_assert(offsetof(UFallSurvivorSubAnimInstance, _maxSpeed) == 0x0005E4, "Member 'UFallSurvivorSubAnimInstance::_maxSpeed' has a wrong offset!");
static_assert(offsetof(UFallSurvivorSubAnimInstance, _speed) == 0x0005E8, "Member 'UFallSurvivorSubAnimInstance::_speed' has a wrong offset!");
static_assert(offsetof(UFallSurvivorSubAnimInstance, _inAir) == 0x0005EC, "Member 'UFallSurvivorSubAnimInstance::_inAir' has a wrong offset!");
static_assert(offsetof(UFallSurvivorSubAnimInstance, _isCrawling) == 0x0005ED, "Member 'UFallSurvivorSubAnimInstance::_isCrawling' has a wrong offset!");
static_assert(offsetof(UFallSurvivorSubAnimInstance, _asCrawlToFallTag) == 0x0005F0, "Member 'UFallSurvivorSubAnimInstance::_asCrawlToFallTag' has a wrong offset!");
static_assert(offsetof(UFallSurvivorSubAnimInstance, _asFallToCrawlTag) == 0x0005FC, "Member 'UFallSurvivorSubAnimInstance::_asFallToCrawlTag' has a wrong offset!");
static_assert(offsetof(UFallSurvivorSubAnimInstance, _asFallHardLoopTag) == 0x000608, "Member 'UFallSurvivorSubAnimInstance::_asFallHardLoopTag' has a wrong offset!");
static_assert(offsetof(UFallSurvivorSubAnimInstance, _asFallHardInTag) == 0x000614, "Member 'UFallSurvivorSubAnimInstance::_asFallHardInTag' has a wrong offset!");
static_assert(offsetof(UFallSurvivorSubAnimInstance, _asFallTag) == 0x000620, "Member 'UFallSurvivorSubAnimInstance::_asFallTag' has a wrong offset!");
static_assert(offsetof(UFallSurvivorSubAnimInstance, _asWalkToFallTag) == 0x00062C, "Member 'UFallSurvivorSubAnimInstance::_asWalkToFallTag' has a wrong offset!");
static_assert(offsetof(UFallSurvivorSubAnimInstance, _bsHardLandOutTag) == 0x000638, "Member 'UFallSurvivorSubAnimInstance::_bsHardLandOutTag' has a wrong offset!");
static_assert(offsetof(UFallSurvivorSubAnimInstance, _bsLandTag) == 0x000644, "Member 'UFallSurvivorSubAnimInstance::_bsLandTag' has a wrong offset!");
static_assert(offsetof(UFallSurvivorSubAnimInstance, _asCrawlToFall) == 0x000650, "Member 'UFallSurvivorSubAnimInstance::_asCrawlToFall' has a wrong offset!");
static_assert(offsetof(UFallSurvivorSubAnimInstance, _asFallToCrawl) == 0x000658, "Member 'UFallSurvivorSubAnimInstance::_asFallToCrawl' has a wrong offset!");
static_assert(offsetof(UFallSurvivorSubAnimInstance, _asFallHardLoop) == 0x000660, "Member 'UFallSurvivorSubAnimInstance::_asFallHardLoop' has a wrong offset!");
static_assert(offsetof(UFallSurvivorSubAnimInstance, _asFallHardIn) == 0x000668, "Member 'UFallSurvivorSubAnimInstance::_asFallHardIn' has a wrong offset!");
static_assert(offsetof(UFallSurvivorSubAnimInstance, _asFall) == 0x000670, "Member 'UFallSurvivorSubAnimInstance::_asFall' has a wrong offset!");
static_assert(offsetof(UFallSurvivorSubAnimInstance, _asWalkToFall) == 0x000678, "Member 'UFallSurvivorSubAnimInstance::_asWalkToFall' has a wrong offset!");
static_assert(offsetof(UFallSurvivorSubAnimInstance, _bsHardLandOut) == 0x000680, "Member 'UFallSurvivorSubAnimInstance::_bsHardLandOut' has a wrong offset!");
static_assert(offsetof(UFallSurvivorSubAnimInstance, _bsLand) == 0x000688, "Member 'UFallSurvivorSubAnimInstance::_bsLand' has a wrong offset!");
static_assert(offsetof(UFallSurvivorSubAnimInstance, _walkToFallToFallToLandRule) == 0x000690, "Member 'UFallSurvivorSubAnimInstance::_walkToFallToFallToLandRule' has a wrong offset!");
static_assert(offsetof(UFallSurvivorSubAnimInstance, _walkToFallToLandSoftRule) == 0x000691, "Member 'UFallSurvivorSubAnimInstance::_walkToFallToLandSoftRule' has a wrong offset!");
static_assert(offsetof(UFallSurvivorSubAnimInstance, _fallToFallToLandRule) == 0x000692, "Member 'UFallSurvivorSubAnimInstance::_fallToFallToLandRule' has a wrong offset!");
static_assert(offsetof(UFallSurvivorSubAnimInstance, _fallToLandSoftRule) == 0x000693, "Member 'UFallSurvivorSubAnimInstance::_fallToLandSoftRule' has a wrong offset!");
static_assert(offsetof(UFallSurvivorSubAnimInstance, _landSoftToBaseRule) == 0x000694, "Member 'UFallSurvivorSubAnimInstance::_landSoftToBaseRule' has a wrong offset!");
static_assert(offsetof(UFallSurvivorSubAnimInstance, _fallToLandToLandHardOutRule) == 0x000695, "Member 'UFallSurvivorSubAnimInstance::_fallToLandToLandHardOutRule' has a wrong offset!");
static_assert(offsetof(UFallSurvivorSubAnimInstance, _landHardToLandHardOutRule) == 0x000696, "Member 'UFallSurvivorSubAnimInstance::_landHardToLandHardOutRule' has a wrong offset!");
static_assert(offsetof(UFallSurvivorSubAnimInstance, _landHardOutToBaseRule) == 0x000697, "Member 'UFallSurvivorSubAnimInstance::_landHardOutToBaseRule' has a wrong offset!");

// Class DBDAnimation.FireCrackerSurvivorSubAnimInstance
// 0x0050 (0x0630 - 0x05E0)
class UFireCrackerSurvivorSubAnimInstance : public UBaseSurvivorAnimInstance
{
public:
	bool                                          _idle;                                             // 0x05E0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EInteractionAnimation                         _interactionType;                                  // 0x05E1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5E2[0x2];                                      // 0x05E2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           _activeTag;                                        // 0x05E4(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _asFireCrackerDropTag;                             // 0x05F0(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5FC[0x4];                                      // 0x05FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          _asFireCrackerDrop;                                // 0x0600(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _fireCrackerToBaseRule;                            // 0x0608(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _baseToFireCrackerRule;                            // 0x0609(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_60A[0x26];                                     // 0x060A(0x0026)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void RemovedTags();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FireCrackerSurvivorSubAnimInstance">();
	}
	static class UFireCrackerSurvivorSubAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFireCrackerSurvivorSubAnimInstance>();
	}
};
static_assert(alignof(UFireCrackerSurvivorSubAnimInstance) == 0x000010, "Wrong alignment on UFireCrackerSurvivorSubAnimInstance");
static_assert(sizeof(UFireCrackerSurvivorSubAnimInstance) == 0x000630, "Wrong size on UFireCrackerSurvivorSubAnimInstance");
static_assert(offsetof(UFireCrackerSurvivorSubAnimInstance, _idle) == 0x0005E0, "Member 'UFireCrackerSurvivorSubAnimInstance::_idle' has a wrong offset!");
static_assert(offsetof(UFireCrackerSurvivorSubAnimInstance, _interactionType) == 0x0005E1, "Member 'UFireCrackerSurvivorSubAnimInstance::_interactionType' has a wrong offset!");
static_assert(offsetof(UFireCrackerSurvivorSubAnimInstance, _activeTag) == 0x0005E4, "Member 'UFireCrackerSurvivorSubAnimInstance::_activeTag' has a wrong offset!");
static_assert(offsetof(UFireCrackerSurvivorSubAnimInstance, _asFireCrackerDropTag) == 0x0005F0, "Member 'UFireCrackerSurvivorSubAnimInstance::_asFireCrackerDropTag' has a wrong offset!");
static_assert(offsetof(UFireCrackerSurvivorSubAnimInstance, _asFireCrackerDrop) == 0x000600, "Member 'UFireCrackerSurvivorSubAnimInstance::_asFireCrackerDrop' has a wrong offset!");
static_assert(offsetof(UFireCrackerSurvivorSubAnimInstance, _fireCrackerToBaseRule) == 0x000608, "Member 'UFireCrackerSurvivorSubAnimInstance::_fireCrackerToBaseRule' has a wrong offset!");
static_assert(offsetof(UFireCrackerSurvivorSubAnimInstance, _baseToFireCrackerRule) == 0x000609, "Member 'UFireCrackerSurvivorSubAnimInstance::_baseToFireCrackerRule' has a wrong offset!");

// Class DBDAnimation.SurvivorAimableSubAnimInstance
// 0x0040 (0x0620 - 0x05E0)
class USurvivorAimableSubAnimInstance : public UBaseSurvivorAnimInstance
{
public:
	float                                         _pitch;                                            // 0x05E0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isHoldingAimItem;                                 // 0x05E4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isAiming;                                         // 0x05E5(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5E6[0x2];                                      // 0x05E6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _isAimingAlpha;                                    // 0x05E8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5EC[0x4];                                      // 0x05EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                _aimPoint;                                         // 0x05F0(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _shoulderToCollisionDistance;                      // 0x0608(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_60C[0x14];                                     // 0x060C(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SurvivorAimableSubAnimInstance">();
	}
	static class USurvivorAimableSubAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USurvivorAimableSubAnimInstance>();
	}
};
static_assert(alignof(USurvivorAimableSubAnimInstance) == 0x000010, "Wrong alignment on USurvivorAimableSubAnimInstance");
static_assert(sizeof(USurvivorAimableSubAnimInstance) == 0x000620, "Wrong size on USurvivorAimableSubAnimInstance");
static_assert(offsetof(USurvivorAimableSubAnimInstance, _pitch) == 0x0005E0, "Member 'USurvivorAimableSubAnimInstance::_pitch' has a wrong offset!");
static_assert(offsetof(USurvivorAimableSubAnimInstance, _isHoldingAimItem) == 0x0005E4, "Member 'USurvivorAimableSubAnimInstance::_isHoldingAimItem' has a wrong offset!");
static_assert(offsetof(USurvivorAimableSubAnimInstance, _isAiming) == 0x0005E5, "Member 'USurvivorAimableSubAnimInstance::_isAiming' has a wrong offset!");
static_assert(offsetof(USurvivorAimableSubAnimInstance, _isAimingAlpha) == 0x0005E8, "Member 'USurvivorAimableSubAnimInstance::_isAimingAlpha' has a wrong offset!");
static_assert(offsetof(USurvivorAimableSubAnimInstance, _aimPoint) == 0x0005F0, "Member 'USurvivorAimableSubAnimInstance::_aimPoint' has a wrong offset!");
static_assert(offsetof(USurvivorAimableSubAnimInstance, _shoulderToCollisionDistance) == 0x000608, "Member 'USurvivorAimableSubAnimInstance::_shoulderToCollisionDistance' has a wrong offset!");

// Class DBDAnimation.FlashlightSurvivorSubAnimInstance
// 0x0040 (0x0660 - 0x0620)
class UFlashlightSurvivorSubAnimInstance : public USurvivorAimableSubAnimInstance
{
public:
	bool                                          _isInjured;                                        // 0x0620(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isCrouching;                                      // 0x0621(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_622[0x2];                                      // 0x0622(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           _asFlashlightStandPoseTag;                         // 0x0624(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _bsFlashlightAimOffsetTag;                         // 0x0630(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_63C[0x4];                                      // 0x063C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          _asFlashlightStandPose;                            // 0x0640(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAimOffsetBlendSpace1D*                 _bsFlashlightAimOffset;                            // 0x0648(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _baseStateToFlashlightAimStateRule;                // 0x0650(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _baseStateToFlashlightHoldStateRule;               // 0x0651(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_652[0xE];                                      // 0x0652(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlashlightSurvivorSubAnimInstance">();
	}
	static class UFlashlightSurvivorSubAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlashlightSurvivorSubAnimInstance>();
	}
};
static_assert(alignof(UFlashlightSurvivorSubAnimInstance) == 0x000010, "Wrong alignment on UFlashlightSurvivorSubAnimInstance");
static_assert(sizeof(UFlashlightSurvivorSubAnimInstance) == 0x000660, "Wrong size on UFlashlightSurvivorSubAnimInstance");
static_assert(offsetof(UFlashlightSurvivorSubAnimInstance, _isInjured) == 0x000620, "Member 'UFlashlightSurvivorSubAnimInstance::_isInjured' has a wrong offset!");
static_assert(offsetof(UFlashlightSurvivorSubAnimInstance, _isCrouching) == 0x000621, "Member 'UFlashlightSurvivorSubAnimInstance::_isCrouching' has a wrong offset!");
static_assert(offsetof(UFlashlightSurvivorSubAnimInstance, _asFlashlightStandPoseTag) == 0x000624, "Member 'UFlashlightSurvivorSubAnimInstance::_asFlashlightStandPoseTag' has a wrong offset!");
static_assert(offsetof(UFlashlightSurvivorSubAnimInstance, _bsFlashlightAimOffsetTag) == 0x000630, "Member 'UFlashlightSurvivorSubAnimInstance::_bsFlashlightAimOffsetTag' has a wrong offset!");
static_assert(offsetof(UFlashlightSurvivorSubAnimInstance, _asFlashlightStandPose) == 0x000640, "Member 'UFlashlightSurvivorSubAnimInstance::_asFlashlightStandPose' has a wrong offset!");
static_assert(offsetof(UFlashlightSurvivorSubAnimInstance, _bsFlashlightAimOffset) == 0x000648, "Member 'UFlashlightSurvivorSubAnimInstance::_bsFlashlightAimOffset' has a wrong offset!");
static_assert(offsetof(UFlashlightSurvivorSubAnimInstance, _baseStateToFlashlightAimStateRule) == 0x000650, "Member 'UFlashlightSurvivorSubAnimInstance::_baseStateToFlashlightAimStateRule' has a wrong offset!");
static_assert(offsetof(UFlashlightSurvivorSubAnimInstance, _baseStateToFlashlightHoldStateRule) == 0x000651, "Member 'UFlashlightSurvivorSubAnimInstance::_baseStateToFlashlightHoldStateRule' has a wrong offset!");

// Class DBDAnimation.GeneratorAnimInstance
// 0x0010 (0x0370 - 0x0360)
class UGeneratorAnimInstance : public USleepingAnimInstance
{
public:
	class AGenerator*                             _owningGenerator;                                  // 0x0360(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _rushFailed;                                       // 0x0368(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isActivated;                                      // 0x0369(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_36A[0x2];                                      // 0x036A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _percentComplete;                                  // 0x036C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetSkillCheckSuccess(bool Success);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GeneratorAnimInstance">();
	}
	static class UGeneratorAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGeneratorAnimInstance>();
	}
};
static_assert(alignof(UGeneratorAnimInstance) == 0x000010, "Wrong alignment on UGeneratorAnimInstance");
static_assert(sizeof(UGeneratorAnimInstance) == 0x000370, "Wrong size on UGeneratorAnimInstance");
static_assert(offsetof(UGeneratorAnimInstance, _owningGenerator) == 0x000360, "Member 'UGeneratorAnimInstance::_owningGenerator' has a wrong offset!");
static_assert(offsetof(UGeneratorAnimInstance, _rushFailed) == 0x000368, "Member 'UGeneratorAnimInstance::_rushFailed' has a wrong offset!");
static_assert(offsetof(UGeneratorAnimInstance, _isActivated) == 0x000369, "Member 'UGeneratorAnimInstance::_isActivated' has a wrong offset!");
static_assert(offsetof(UGeneratorAnimInstance, _percentComplete) == 0x00036C, "Member 'UGeneratorAnimInstance::_percentComplete' has a wrong offset!");

// Class DBDAnimation.HatchAnimInstance
// 0x0010 (0x0370 - 0x0360)
class UHatchAnimInstance : public USleepingAnimInstance
{
public:
	bool                                          _isOpen;                                           // 0x0360(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_361[0xF];                                      // 0x0361(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HatchAnimInstance">();
	}
	static class UHatchAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHatchAnimInstance>();
	}
};
static_assert(alignof(UHatchAnimInstance) == 0x000010, "Wrong alignment on UHatchAnimInstance");
static_assert(sizeof(UHatchAnimInstance) == 0x000370, "Wrong size on UHatchAnimInstance");
static_assert(offsetof(UHatchAnimInstance, _isOpen) == 0x000360, "Member 'UHatchAnimInstance::_isOpen' has a wrong offset!");

// Class DBDAnimation.HealSurvivorSubAnimInstance
// 0x01E0 (0x07C0 - 0x05E0)
class UHealSurvivorSubAnimInstance : public UBaseSurvivorAnimInstance
{
public:
	uint8                                         Pad_5E0[0x38];                                     // 0x05E0(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _isIdle;                                           // 0x0618(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isHealingACrawlingTarget;                         // 0x0619(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isHealingOtherNoMedkit;                           // 0x061A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isHealingOtherMedkit;                             // 0x061B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isHealingSelfNoMedkit;                            // 0x061C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isHealingSelfMedkit;                              // 0x061D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isWakingUpOther;                                  // 0x061E(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isBeingHealed;                                    // 0x061F(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isBeingMended;                                    // 0x0620(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isMendingOther;                                   // 0x0621(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _hasSkillCheckFailed;                              // 0x0622(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isCrawling;                                       // 0x0623(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _hasHealerSkillCheckFailed;                        // 0x0624(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_625[0x3];                                      // 0x0625(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           _healOtherTag;                                     // 0x0628(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _healOtherMedKitTag;                               // 0x0634(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _healSelfNoMedKitTag;                              // 0x0640(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _healSelfWithMedKitTag;                            // 0x064C(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _wakingUpOtherTag;                                 // 0x0658(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _mendingOtherTag;                                  // 0x0664(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _beingHealedTag;                                   // 0x0670(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _beingMendedTag;                                   // 0x067C(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _asHealingSelfTag;                                 // 0x0688(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _asHealSelfFailTag;                                // 0x0694(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _asHealSurvivorTag;                                // 0x06A0(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _asWakeTag;                                        // 0x06AC(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _asHealSurvivorFailTag;                            // 0x06B8(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _asBeingMendedTag;                                 // 0x06C4(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _asBeingHealTag;                                   // 0x06D0(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _asHealingCrawlingCamperTag;                       // 0x06DC(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _asHealingCrawlingCamperFailTag;                   // 0x06E8(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _asBeingHealedCrawlBeingHealedTag;                 // 0x06F4(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _asBeingHealedFailedTag;                           // 0x0700(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_70C[0x4];                                      // 0x070C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          _asHealingSelf;                                    // 0x0710(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _asHealSelfFail;                                   // 0x0718(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _asHealSurvivor;                                   // 0x0720(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _asWake;                                           // 0x0728(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _asHealSurvivorFail;                               // 0x0730(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _asBeingMended;                                    // 0x0738(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _asBeingHeal;                                      // 0x0740(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _asHealingCrawlingSurvivor;                        // 0x0748(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _asHealingCrawlingSurvivorFail;                    // 0x0750(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _asBeingHealedCrawlBeingHealed;                    // 0x0758(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _asBeingHealedFailed;                              // 0x0760(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _healBaseToHealSelfRule;                           // 0x0768(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _healBaseToConduitToBeingHealRule;                 // 0x0769(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _healBaseToHealOtherRule;                          // 0x076A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _healSelfToHealBaseRule;                           // 0x076B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _healSelfSkillCheckResponseToHealSelfRule;         // 0x076C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _beingHealSkillCheckResponseToBeingHealedRule;     // 0x076D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _healOtherToHealBaseRule;                          // 0x076E(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _healOtherSkillCheckResponseToHealOtherRule;       // 0x076F(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _notBeingHealedRule;                               // 0x0770(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_771[0x4F];                                     // 0x0771(0x004F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnHealerSkillCheckResponseAesthetic(bool Success, class ADBDPlayer* Healer);
	void ResetHealerSkillCheckFailed();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HealSurvivorSubAnimInstance">();
	}
	static class UHealSurvivorSubAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHealSurvivorSubAnimInstance>();
	}
};
static_assert(alignof(UHealSurvivorSubAnimInstance) == 0x000010, "Wrong alignment on UHealSurvivorSubAnimInstance");
static_assert(sizeof(UHealSurvivorSubAnimInstance) == 0x0007C0, "Wrong size on UHealSurvivorSubAnimInstance");
static_assert(offsetof(UHealSurvivorSubAnimInstance, _isIdle) == 0x000618, "Member 'UHealSurvivorSubAnimInstance::_isIdle' has a wrong offset!");
static_assert(offsetof(UHealSurvivorSubAnimInstance, _isHealingACrawlingTarget) == 0x000619, "Member 'UHealSurvivorSubAnimInstance::_isHealingACrawlingTarget' has a wrong offset!");
static_assert(offsetof(UHealSurvivorSubAnimInstance, _isHealingOtherNoMedkit) == 0x00061A, "Member 'UHealSurvivorSubAnimInstance::_isHealingOtherNoMedkit' has a wrong offset!");
static_assert(offsetof(UHealSurvivorSubAnimInstance, _isHealingOtherMedkit) == 0x00061B, "Member 'UHealSurvivorSubAnimInstance::_isHealingOtherMedkit' has a wrong offset!");
static_assert(offsetof(UHealSurvivorSubAnimInstance, _isHealingSelfNoMedkit) == 0x00061C, "Member 'UHealSurvivorSubAnimInstance::_isHealingSelfNoMedkit' has a wrong offset!");
static_assert(offsetof(UHealSurvivorSubAnimInstance, _isHealingSelfMedkit) == 0x00061D, "Member 'UHealSurvivorSubAnimInstance::_isHealingSelfMedkit' has a wrong offset!");
static_assert(offsetof(UHealSurvivorSubAnimInstance, _isWakingUpOther) == 0x00061E, "Member 'UHealSurvivorSubAnimInstance::_isWakingUpOther' has a wrong offset!");
static_assert(offsetof(UHealSurvivorSubAnimInstance, _isBeingHealed) == 0x00061F, "Member 'UHealSurvivorSubAnimInstance::_isBeingHealed' has a wrong offset!");
static_assert(offsetof(UHealSurvivorSubAnimInstance, _isBeingMended) == 0x000620, "Member 'UHealSurvivorSubAnimInstance::_isBeingMended' has a wrong offset!");
static_assert(offsetof(UHealSurvivorSubAnimInstance, _isMendingOther) == 0x000621, "Member 'UHealSurvivorSubAnimInstance::_isMendingOther' has a wrong offset!");
static_assert(offsetof(UHealSurvivorSubAnimInstance, _hasSkillCheckFailed) == 0x000622, "Member 'UHealSurvivorSubAnimInstance::_hasSkillCheckFailed' has a wrong offset!");
static_assert(offsetof(UHealSurvivorSubAnimInstance, _isCrawling) == 0x000623, "Member 'UHealSurvivorSubAnimInstance::_isCrawling' has a wrong offset!");
static_assert(offsetof(UHealSurvivorSubAnimInstance, _hasHealerSkillCheckFailed) == 0x000624, "Member 'UHealSurvivorSubAnimInstance::_hasHealerSkillCheckFailed' has a wrong offset!");
static_assert(offsetof(UHealSurvivorSubAnimInstance, _healOtherTag) == 0x000628, "Member 'UHealSurvivorSubAnimInstance::_healOtherTag' has a wrong offset!");
static_assert(offsetof(UHealSurvivorSubAnimInstance, _healOtherMedKitTag) == 0x000634, "Member 'UHealSurvivorSubAnimInstance::_healOtherMedKitTag' has a wrong offset!");
static_assert(offsetof(UHealSurvivorSubAnimInstance, _healSelfNoMedKitTag) == 0x000640, "Member 'UHealSurvivorSubAnimInstance::_healSelfNoMedKitTag' has a wrong offset!");
static_assert(offsetof(UHealSurvivorSubAnimInstance, _healSelfWithMedKitTag) == 0x00064C, "Member 'UHealSurvivorSubAnimInstance::_healSelfWithMedKitTag' has a wrong offset!");
static_assert(offsetof(UHealSurvivorSubAnimInstance, _wakingUpOtherTag) == 0x000658, "Member 'UHealSurvivorSubAnimInstance::_wakingUpOtherTag' has a wrong offset!");
static_assert(offsetof(UHealSurvivorSubAnimInstance, _mendingOtherTag) == 0x000664, "Member 'UHealSurvivorSubAnimInstance::_mendingOtherTag' has a wrong offset!");
static_assert(offsetof(UHealSurvivorSubAnimInstance, _beingHealedTag) == 0x000670, "Member 'UHealSurvivorSubAnimInstance::_beingHealedTag' has a wrong offset!");
static_assert(offsetof(UHealSurvivorSubAnimInstance, _beingMendedTag) == 0x00067C, "Member 'UHealSurvivorSubAnimInstance::_beingMendedTag' has a wrong offset!");
static_assert(offsetof(UHealSurvivorSubAnimInstance, _asHealingSelfTag) == 0x000688, "Member 'UHealSurvivorSubAnimInstance::_asHealingSelfTag' has a wrong offset!");
static_assert(offsetof(UHealSurvivorSubAnimInstance, _asHealSelfFailTag) == 0x000694, "Member 'UHealSurvivorSubAnimInstance::_asHealSelfFailTag' has a wrong offset!");
static_assert(offsetof(UHealSurvivorSubAnimInstance, _asHealSurvivorTag) == 0x0006A0, "Member 'UHealSurvivorSubAnimInstance::_asHealSurvivorTag' has a wrong offset!");
static_assert(offsetof(UHealSurvivorSubAnimInstance, _asWakeTag) == 0x0006AC, "Member 'UHealSurvivorSubAnimInstance::_asWakeTag' has a wrong offset!");
static_assert(offsetof(UHealSurvivorSubAnimInstance, _asHealSurvivorFailTag) == 0x0006B8, "Member 'UHealSurvivorSubAnimInstance::_asHealSurvivorFailTag' has a wrong offset!");
static_assert(offsetof(UHealSurvivorSubAnimInstance, _asBeingMendedTag) == 0x0006C4, "Member 'UHealSurvivorSubAnimInstance::_asBeingMendedTag' has a wrong offset!");
static_assert(offsetof(UHealSurvivorSubAnimInstance, _asBeingHealTag) == 0x0006D0, "Member 'UHealSurvivorSubAnimInstance::_asBeingHealTag' has a wrong offset!");
static_assert(offsetof(UHealSurvivorSubAnimInstance, _asHealingCrawlingCamperTag) == 0x0006DC, "Member 'UHealSurvivorSubAnimInstance::_asHealingCrawlingCamperTag' has a wrong offset!");
static_assert(offsetof(UHealSurvivorSubAnimInstance, _asHealingCrawlingCamperFailTag) == 0x0006E8, "Member 'UHealSurvivorSubAnimInstance::_asHealingCrawlingCamperFailTag' has a wrong offset!");
static_assert(offsetof(UHealSurvivorSubAnimInstance, _asBeingHealedCrawlBeingHealedTag) == 0x0006F4, "Member 'UHealSurvivorSubAnimInstance::_asBeingHealedCrawlBeingHealedTag' has a wrong offset!");
static_assert(offsetof(UHealSurvivorSubAnimInstance, _asBeingHealedFailedTag) == 0x000700, "Member 'UHealSurvivorSubAnimInstance::_asBeingHealedFailedTag' has a wrong offset!");
static_assert(offsetof(UHealSurvivorSubAnimInstance, _asHealingSelf) == 0x000710, "Member 'UHealSurvivorSubAnimInstance::_asHealingSelf' has a wrong offset!");
static_assert(offsetof(UHealSurvivorSubAnimInstance, _asHealSelfFail) == 0x000718, "Member 'UHealSurvivorSubAnimInstance::_asHealSelfFail' has a wrong offset!");
static_assert(offsetof(UHealSurvivorSubAnimInstance, _asHealSurvivor) == 0x000720, "Member 'UHealSurvivorSubAnimInstance::_asHealSurvivor' has a wrong offset!");
static_assert(offsetof(UHealSurvivorSubAnimInstance, _asWake) == 0x000728, "Member 'UHealSurvivorSubAnimInstance::_asWake' has a wrong offset!");
static_assert(offsetof(UHealSurvivorSubAnimInstance, _asHealSurvivorFail) == 0x000730, "Member 'UHealSurvivorSubAnimInstance::_asHealSurvivorFail' has a wrong offset!");
static_assert(offsetof(UHealSurvivorSubAnimInstance, _asBeingMended) == 0x000738, "Member 'UHealSurvivorSubAnimInstance::_asBeingMended' has a wrong offset!");
static_assert(offsetof(UHealSurvivorSubAnimInstance, _asBeingHeal) == 0x000740, "Member 'UHealSurvivorSubAnimInstance::_asBeingHeal' has a wrong offset!");
static_assert(offsetof(UHealSurvivorSubAnimInstance, _asHealingCrawlingSurvivor) == 0x000748, "Member 'UHealSurvivorSubAnimInstance::_asHealingCrawlingSurvivor' has a wrong offset!");
static_assert(offsetof(UHealSurvivorSubAnimInstance, _asHealingCrawlingSurvivorFail) == 0x000750, "Member 'UHealSurvivorSubAnimInstance::_asHealingCrawlingSurvivorFail' has a wrong offset!");
static_assert(offsetof(UHealSurvivorSubAnimInstance, _asBeingHealedCrawlBeingHealed) == 0x000758, "Member 'UHealSurvivorSubAnimInstance::_asBeingHealedCrawlBeingHealed' has a wrong offset!");
static_assert(offsetof(UHealSurvivorSubAnimInstance, _asBeingHealedFailed) == 0x000760, "Member 'UHealSurvivorSubAnimInstance::_asBeingHealedFailed' has a wrong offset!");
static_assert(offsetof(UHealSurvivorSubAnimInstance, _healBaseToHealSelfRule) == 0x000768, "Member 'UHealSurvivorSubAnimInstance::_healBaseToHealSelfRule' has a wrong offset!");
static_assert(offsetof(UHealSurvivorSubAnimInstance, _healBaseToConduitToBeingHealRule) == 0x000769, "Member 'UHealSurvivorSubAnimInstance::_healBaseToConduitToBeingHealRule' has a wrong offset!");
static_assert(offsetof(UHealSurvivorSubAnimInstance, _healBaseToHealOtherRule) == 0x00076A, "Member 'UHealSurvivorSubAnimInstance::_healBaseToHealOtherRule' has a wrong offset!");
static_assert(offsetof(UHealSurvivorSubAnimInstance, _healSelfToHealBaseRule) == 0x00076B, "Member 'UHealSurvivorSubAnimInstance::_healSelfToHealBaseRule' has a wrong offset!");
static_assert(offsetof(UHealSurvivorSubAnimInstance, _healSelfSkillCheckResponseToHealSelfRule) == 0x00076C, "Member 'UHealSurvivorSubAnimInstance::_healSelfSkillCheckResponseToHealSelfRule' has a wrong offset!");
static_assert(offsetof(UHealSurvivorSubAnimInstance, _beingHealSkillCheckResponseToBeingHealedRule) == 0x00076D, "Member 'UHealSurvivorSubAnimInstance::_beingHealSkillCheckResponseToBeingHealedRule' has a wrong offset!");
static_assert(offsetof(UHealSurvivorSubAnimInstance, _healOtherToHealBaseRule) == 0x00076E, "Member 'UHealSurvivorSubAnimInstance::_healOtherToHealBaseRule' has a wrong offset!");
static_assert(offsetof(UHealSurvivorSubAnimInstance, _healOtherSkillCheckResponseToHealOtherRule) == 0x00076F, "Member 'UHealSurvivorSubAnimInstance::_healOtherSkillCheckResponseToHealOtherRule' has a wrong offset!");
static_assert(offsetof(UHealSurvivorSubAnimInstance, _notBeingHealedRule) == 0x000770, "Member 'UHealSurvivorSubAnimInstance::_notBeingHealedRule' has a wrong offset!");

// Class DBDAnimation.HookSurvivorSubAnimInstance
// 0x0070 (0x0650 - 0x05E0)
class UHookSurvivorSubAnimInstance : public UBaseSurvivorAnimInstance
{
public:
	bool                                          _isDead;                                           // 0x05E0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isHooked;                                         // 0x05E1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isSacrificeStruggling;                            // 0x05E2(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5E3[0x1];                                      // 0x05E3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _sacrificeStrugglePercent;                         // 0x05E4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _struggleThreshold;                                // 0x05E8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _asHookIdleTag;                                    // 0x05EC(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _bsSacrificeStruggleTag;                           // 0x05F8(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _asSpiderStruggleTag;                              // 0x0604(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _asHookedDeathTag;                                 // 0x0610(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_61C[0x4];                                      // 0x061C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          _asHookIdle;                                       // 0x0620(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBlendSpace*                            _bsSacrificeStruggle;                              // 0x0628(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _asSpiderStruggle;                                 // 0x0630(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _asHookedDeath;                                    // 0x0638(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _closetIdleToBaseRule;                             // 0x0640(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_641[0xF];                                      // 0x0641(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HookSurvivorSubAnimInstance">();
	}
	static class UHookSurvivorSubAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHookSurvivorSubAnimInstance>();
	}
};
static_assert(alignof(UHookSurvivorSubAnimInstance) == 0x000010, "Wrong alignment on UHookSurvivorSubAnimInstance");
static_assert(sizeof(UHookSurvivorSubAnimInstance) == 0x000650, "Wrong size on UHookSurvivorSubAnimInstance");
static_assert(offsetof(UHookSurvivorSubAnimInstance, _isDead) == 0x0005E0, "Member 'UHookSurvivorSubAnimInstance::_isDead' has a wrong offset!");
static_assert(offsetof(UHookSurvivorSubAnimInstance, _isHooked) == 0x0005E1, "Member 'UHookSurvivorSubAnimInstance::_isHooked' has a wrong offset!");
static_assert(offsetof(UHookSurvivorSubAnimInstance, _isSacrificeStruggling) == 0x0005E2, "Member 'UHookSurvivorSubAnimInstance::_isSacrificeStruggling' has a wrong offset!");
static_assert(offsetof(UHookSurvivorSubAnimInstance, _sacrificeStrugglePercent) == 0x0005E4, "Member 'UHookSurvivorSubAnimInstance::_sacrificeStrugglePercent' has a wrong offset!");
static_assert(offsetof(UHookSurvivorSubAnimInstance, _struggleThreshold) == 0x0005E8, "Member 'UHookSurvivorSubAnimInstance::_struggleThreshold' has a wrong offset!");
static_assert(offsetof(UHookSurvivorSubAnimInstance, _asHookIdleTag) == 0x0005EC, "Member 'UHookSurvivorSubAnimInstance::_asHookIdleTag' has a wrong offset!");
static_assert(offsetof(UHookSurvivorSubAnimInstance, _bsSacrificeStruggleTag) == 0x0005F8, "Member 'UHookSurvivorSubAnimInstance::_bsSacrificeStruggleTag' has a wrong offset!");
static_assert(offsetof(UHookSurvivorSubAnimInstance, _asSpiderStruggleTag) == 0x000604, "Member 'UHookSurvivorSubAnimInstance::_asSpiderStruggleTag' has a wrong offset!");
static_assert(offsetof(UHookSurvivorSubAnimInstance, _asHookedDeathTag) == 0x000610, "Member 'UHookSurvivorSubAnimInstance::_asHookedDeathTag' has a wrong offset!");
static_assert(offsetof(UHookSurvivorSubAnimInstance, _asHookIdle) == 0x000620, "Member 'UHookSurvivorSubAnimInstance::_asHookIdle' has a wrong offset!");
static_assert(offsetof(UHookSurvivorSubAnimInstance, _bsSacrificeStruggle) == 0x000628, "Member 'UHookSurvivorSubAnimInstance::_bsSacrificeStruggle' has a wrong offset!");
static_assert(offsetof(UHookSurvivorSubAnimInstance, _asSpiderStruggle) == 0x000630, "Member 'UHookSurvivorSubAnimInstance::_asSpiderStruggle' has a wrong offset!");
static_assert(offsetof(UHookSurvivorSubAnimInstance, _asHookedDeath) == 0x000638, "Member 'UHookSurvivorSubAnimInstance::_asHookedDeath' has a wrong offset!");
static_assert(offsetof(UHookSurvivorSubAnimInstance, _closetIdleToBaseRule) == 0x000640, "Member 'UHookSurvivorSubAnimInstance::_closetIdleToBaseRule' has a wrong offset!");

// Class DBDAnimation.KillerDynamicAccessoryAnimInstance
// 0x0010 (0x0370 - 0x0360)
class UKillerDynamicAccessoryAnimInstance final : public UDynamicAccessoryAnimInstance
{
public:
	bool                                          _isKillingSurvivorWithMori;                        // 0x0360(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isInMoriCutscene;                                 // 0x0361(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_362[0xE];                                      // 0x0362(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerDynamicAccessoryAnimInstance">();
	}
	static class UKillerDynamicAccessoryAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillerDynamicAccessoryAnimInstance>();
	}
};
static_assert(alignof(UKillerDynamicAccessoryAnimInstance) == 0x000010, "Wrong alignment on UKillerDynamicAccessoryAnimInstance");
static_assert(sizeof(UKillerDynamicAccessoryAnimInstance) == 0x000370, "Wrong size on UKillerDynamicAccessoryAnimInstance");
static_assert(offsetof(UKillerDynamicAccessoryAnimInstance, _isKillingSurvivorWithMori) == 0x000360, "Member 'UKillerDynamicAccessoryAnimInstance::_isKillingSurvivorWithMori' has a wrong offset!");
static_assert(offsetof(UKillerDynamicAccessoryAnimInstance, _isInMoriCutscene) == 0x000361, "Member 'UKillerDynamicAccessoryAnimInstance::_isInMoriCutscene' has a wrong offset!");

// Class DBDAnimation.KillerLocomotionSubAnimInstance
// 0x00D0 (0x06C0 - 0x05F0)
class UKillerLocomotionSubAnimInstance : public UBaseKillerAnimInstance
{
public:
	class UAnimSequence*                          _landLightTPV;                                     // 0x05F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _landLightFPV;                                     // 0x05F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBlendSpace1D*                          _BSLandTPV;                                        // 0x0600(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBlendSpace1D*                          _BSLandFPV;                                        // 0x0608(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _walkToFallTPV;                                    // 0x0610(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _walkToFallFPV;                                    // 0x0618(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _carryIdleTPV;                                     // 0x0620(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _carryIdleFPV;                                     // 0x0628(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _fallingTPV;                                       // 0x0630(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _fallingFPV;                                       // 0x0638(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _landLight;                                        // 0x0640(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBlendSpace1D*                          _bsLand;                                           // 0x0648(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _walkToFall;                                       // 0x0650(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _carryIdle;                                        // 0x0658(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _falling;                                          // 0x0660(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isVaultingToFall;                                 // 0x0668(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EIntroState                                   _introState;                                       // 0x0669(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_66A[0x6];                                      // 0x066A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTagStateBool                          _isVaultingToFallState;                            // 0x0670(0x0048)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6B8[0x8];                                      // 0x06B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerLocomotionSubAnimInstance">();
	}
	static class UKillerLocomotionSubAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillerLocomotionSubAnimInstance>();
	}
};
static_assert(alignof(UKillerLocomotionSubAnimInstance) == 0x000010, "Wrong alignment on UKillerLocomotionSubAnimInstance");
static_assert(sizeof(UKillerLocomotionSubAnimInstance) == 0x0006C0, "Wrong size on UKillerLocomotionSubAnimInstance");
static_assert(offsetof(UKillerLocomotionSubAnimInstance, _landLightTPV) == 0x0005F0, "Member 'UKillerLocomotionSubAnimInstance::_landLightTPV' has a wrong offset!");
static_assert(offsetof(UKillerLocomotionSubAnimInstance, _landLightFPV) == 0x0005F8, "Member 'UKillerLocomotionSubAnimInstance::_landLightFPV' has a wrong offset!");
static_assert(offsetof(UKillerLocomotionSubAnimInstance, _BSLandTPV) == 0x000600, "Member 'UKillerLocomotionSubAnimInstance::_BSLandTPV' has a wrong offset!");
static_assert(offsetof(UKillerLocomotionSubAnimInstance, _BSLandFPV) == 0x000608, "Member 'UKillerLocomotionSubAnimInstance::_BSLandFPV' has a wrong offset!");
static_assert(offsetof(UKillerLocomotionSubAnimInstance, _walkToFallTPV) == 0x000610, "Member 'UKillerLocomotionSubAnimInstance::_walkToFallTPV' has a wrong offset!");
static_assert(offsetof(UKillerLocomotionSubAnimInstance, _walkToFallFPV) == 0x000618, "Member 'UKillerLocomotionSubAnimInstance::_walkToFallFPV' has a wrong offset!");
static_assert(offsetof(UKillerLocomotionSubAnimInstance, _carryIdleTPV) == 0x000620, "Member 'UKillerLocomotionSubAnimInstance::_carryIdleTPV' has a wrong offset!");
static_assert(offsetof(UKillerLocomotionSubAnimInstance, _carryIdleFPV) == 0x000628, "Member 'UKillerLocomotionSubAnimInstance::_carryIdleFPV' has a wrong offset!");
static_assert(offsetof(UKillerLocomotionSubAnimInstance, _fallingTPV) == 0x000630, "Member 'UKillerLocomotionSubAnimInstance::_fallingTPV' has a wrong offset!");
static_assert(offsetof(UKillerLocomotionSubAnimInstance, _fallingFPV) == 0x000638, "Member 'UKillerLocomotionSubAnimInstance::_fallingFPV' has a wrong offset!");
static_assert(offsetof(UKillerLocomotionSubAnimInstance, _landLight) == 0x000640, "Member 'UKillerLocomotionSubAnimInstance::_landLight' has a wrong offset!");
static_assert(offsetof(UKillerLocomotionSubAnimInstance, _bsLand) == 0x000648, "Member 'UKillerLocomotionSubAnimInstance::_bsLand' has a wrong offset!");
static_assert(offsetof(UKillerLocomotionSubAnimInstance, _walkToFall) == 0x000650, "Member 'UKillerLocomotionSubAnimInstance::_walkToFall' has a wrong offset!");
static_assert(offsetof(UKillerLocomotionSubAnimInstance, _carryIdle) == 0x000658, "Member 'UKillerLocomotionSubAnimInstance::_carryIdle' has a wrong offset!");
static_assert(offsetof(UKillerLocomotionSubAnimInstance, _falling) == 0x000660, "Member 'UKillerLocomotionSubAnimInstance::_falling' has a wrong offset!");
static_assert(offsetof(UKillerLocomotionSubAnimInstance, _isVaultingToFall) == 0x000668, "Member 'UKillerLocomotionSubAnimInstance::_isVaultingToFall' has a wrong offset!");
static_assert(offsetof(UKillerLocomotionSubAnimInstance, _introState) == 0x000669, "Member 'UKillerLocomotionSubAnimInstance::_introState' has a wrong offset!");
static_assert(offsetof(UKillerLocomotionSubAnimInstance, _isVaultingToFallState) == 0x000670, "Member 'UKillerLocomotionSubAnimInstance::_isVaultingToFallState' has a wrong offset!");

// Class DBDAnimation.LegIKSurvivorSubAnimInstance
// 0x0180 (0x0760 - 0x05E0)
class ULegIKSurvivorSubAnimInstance final : public UBaseSurvivorAnimInstance
{
public:
	struct FVector                                _leftFootOffset;                                   // 0x05E0(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                _rightFootOffset;                                  // 0x05F8(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                _pelvisOffset;                                     // 0x0610(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isIdle;                                           // 0x0628(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isCrouched;                                       // 0x0629(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_62A[0x6];                                      // 0x062A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               _rightFootDeltaRotator;                            // 0x0630(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FRotator                               _leftFootDeltaRotator;                             // 0x0648(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class UAnimCollection*                        AnimCollection;                                    // 0x0660(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   _floorJoint;                                       // 0x0668(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _pelvisOffsetTreshold;                             // 0x0674(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FFloatRange                            _pelvisOffsetRange;                                // 0x0678(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FFloatRange                            _pelvisOffsetRangeCrouched;                        // 0x0688(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _pelvisOffsetInterpolationSpeed;                   // 0x0698(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FFloatRange                            _footOffsetRange;                                  // 0x069C(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FFloatRange                            _footOffsetRangeCrouched;                          // 0x06AC(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _footOffsetInterpolationSpeed;                     // 0x06BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FFloatRange                            _footPitchDeltaRange;                              // 0x06C0(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBaseGroundDetectorComponent*           _leftFootGroundDetector;                           // 0x06D0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBaseGroundDetectorComponent*           _rightFootGroundDetector;                          // 0x06D8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaxLocalHeightForPlanting;                         // 0x06E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6E4[0x6C];                                     // 0x06E4(0x006C)(Fixing Size After Last Property [ Dumper-7 ])
	class ULocomotionPredictor*                   _locomotionPredictor;                              // 0x0750(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_758[0x8];                                      // 0x0758(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LegIKSurvivorSubAnimInstance">();
	}
	static class ULegIKSurvivorSubAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULegIKSurvivorSubAnimInstance>();
	}
};
static_assert(alignof(ULegIKSurvivorSubAnimInstance) == 0x000010, "Wrong alignment on ULegIKSurvivorSubAnimInstance");
static_assert(sizeof(ULegIKSurvivorSubAnimInstance) == 0x000760, "Wrong size on ULegIKSurvivorSubAnimInstance");
static_assert(offsetof(ULegIKSurvivorSubAnimInstance, _leftFootOffset) == 0x0005E0, "Member 'ULegIKSurvivorSubAnimInstance::_leftFootOffset' has a wrong offset!");
static_assert(offsetof(ULegIKSurvivorSubAnimInstance, _rightFootOffset) == 0x0005F8, "Member 'ULegIKSurvivorSubAnimInstance::_rightFootOffset' has a wrong offset!");
static_assert(offsetof(ULegIKSurvivorSubAnimInstance, _pelvisOffset) == 0x000610, "Member 'ULegIKSurvivorSubAnimInstance::_pelvisOffset' has a wrong offset!");
static_assert(offsetof(ULegIKSurvivorSubAnimInstance, _isIdle) == 0x000628, "Member 'ULegIKSurvivorSubAnimInstance::_isIdle' has a wrong offset!");
static_assert(offsetof(ULegIKSurvivorSubAnimInstance, _isCrouched) == 0x000629, "Member 'ULegIKSurvivorSubAnimInstance::_isCrouched' has a wrong offset!");
static_assert(offsetof(ULegIKSurvivorSubAnimInstance, _rightFootDeltaRotator) == 0x000630, "Member 'ULegIKSurvivorSubAnimInstance::_rightFootDeltaRotator' has a wrong offset!");
static_assert(offsetof(ULegIKSurvivorSubAnimInstance, _leftFootDeltaRotator) == 0x000648, "Member 'ULegIKSurvivorSubAnimInstance::_leftFootDeltaRotator' has a wrong offset!");
static_assert(offsetof(ULegIKSurvivorSubAnimInstance, AnimCollection) == 0x000660, "Member 'ULegIKSurvivorSubAnimInstance::AnimCollection' has a wrong offset!");
static_assert(offsetof(ULegIKSurvivorSubAnimInstance, _floorJoint) == 0x000668, "Member 'ULegIKSurvivorSubAnimInstance::_floorJoint' has a wrong offset!");
static_assert(offsetof(ULegIKSurvivorSubAnimInstance, _pelvisOffsetTreshold) == 0x000674, "Member 'ULegIKSurvivorSubAnimInstance::_pelvisOffsetTreshold' has a wrong offset!");
static_assert(offsetof(ULegIKSurvivorSubAnimInstance, _pelvisOffsetRange) == 0x000678, "Member 'ULegIKSurvivorSubAnimInstance::_pelvisOffsetRange' has a wrong offset!");
static_assert(offsetof(ULegIKSurvivorSubAnimInstance, _pelvisOffsetRangeCrouched) == 0x000688, "Member 'ULegIKSurvivorSubAnimInstance::_pelvisOffsetRangeCrouched' has a wrong offset!");
static_assert(offsetof(ULegIKSurvivorSubAnimInstance, _pelvisOffsetInterpolationSpeed) == 0x000698, "Member 'ULegIKSurvivorSubAnimInstance::_pelvisOffsetInterpolationSpeed' has a wrong offset!");
static_assert(offsetof(ULegIKSurvivorSubAnimInstance, _footOffsetRange) == 0x00069C, "Member 'ULegIKSurvivorSubAnimInstance::_footOffsetRange' has a wrong offset!");
static_assert(offsetof(ULegIKSurvivorSubAnimInstance, _footOffsetRangeCrouched) == 0x0006AC, "Member 'ULegIKSurvivorSubAnimInstance::_footOffsetRangeCrouched' has a wrong offset!");
static_assert(offsetof(ULegIKSurvivorSubAnimInstance, _footOffsetInterpolationSpeed) == 0x0006BC, "Member 'ULegIKSurvivorSubAnimInstance::_footOffsetInterpolationSpeed' has a wrong offset!");
static_assert(offsetof(ULegIKSurvivorSubAnimInstance, _footPitchDeltaRange) == 0x0006C0, "Member 'ULegIKSurvivorSubAnimInstance::_footPitchDeltaRange' has a wrong offset!");
static_assert(offsetof(ULegIKSurvivorSubAnimInstance, _leftFootGroundDetector) == 0x0006D0, "Member 'ULegIKSurvivorSubAnimInstance::_leftFootGroundDetector' has a wrong offset!");
static_assert(offsetof(ULegIKSurvivorSubAnimInstance, _rightFootGroundDetector) == 0x0006D8, "Member 'ULegIKSurvivorSubAnimInstance::_rightFootGroundDetector' has a wrong offset!");
static_assert(offsetof(ULegIKSurvivorSubAnimInstance, MaxLocalHeightForPlanting) == 0x0006E0, "Member 'ULegIKSurvivorSubAnimInstance::MaxLocalHeightForPlanting' has a wrong offset!");
static_assert(offsetof(ULegIKSurvivorSubAnimInstance, _locomotionPredictor) == 0x000750, "Member 'ULegIKSurvivorSubAnimInstance::_locomotionPredictor' has a wrong offset!");

// Class DBDAnimation.LocomotionPredictor
// 0x0050 (0x0080 - 0x0030)
class ULocomotionPredictor final : public UObject
{
public:
	TMap<class UAnimSequence*, struct FFootBoneData> _animFootData;                                     // 0x0030(0x0050)(Transient, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LocomotionPredictor">();
	}
	static class ULocomotionPredictor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULocomotionPredictor>();
	}
};
static_assert(alignof(ULocomotionPredictor) == 0x000008, "Wrong alignment on ULocomotionPredictor");
static_assert(sizeof(ULocomotionPredictor) == 0x000080, "Wrong size on ULocomotionPredictor");
static_assert(offsetof(ULocomotionPredictor, _animFootData) == 0x000030, "Member 'ULocomotionPredictor::_animFootData' has a wrong offset!");

// Class DBDAnimation.LocomotionSurvivorSubAnimInstance
// 0x0390 (0x0970 - 0x05E0)
class ULocomotionSurvivorSubAnimInstance : public UBaseSurvivorAnimInstance
{
public:
	struct FGameplayTag                           _recoveringInteractionTag;                         // 0x05E0(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _allowNavigationWhileRecoverTag;                   // 0x05EC(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _modifyLocomotionScaleTag;                         // 0x05F8(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _aimOffsetYawInterpolationSpeed;                   // 0x0604(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _aimOffsetYawDeadzoneStart;                        // 0x0608(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _aimOffsetYawDrasticChangeUpperLimit;              // 0x060C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _aimOffsetYawDrasticChangeLowerLimit;              // 0x0610(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _aimOffsetYawDrasticChangeInterpolationSpeed;      // 0x0614(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            _aimOffsetYawInterpolateEaseIn;                    // 0x0618(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            _aimOffsetYawInterpolateEaseOut;                   // 0x0620(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _aimOffsetYawInterpolationEaseInLength;            // 0x0628(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _aimOffsetYawInterpolationEaseOutDistance;         // 0x062C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _isPlayerInPerkInteractionToFloat;                 // 0x0630(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isCrawlRecover;                                   // 0x0634(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_635[0x3];                                      // 0x0635(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _explicitTimeLookAtStand;                          // 0x0638(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _lookAtAlpha;                                      // 0x063C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _strafingDirection;                                // 0x0640(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _strafingSpeed;                                    // 0x0644(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _strafingSpeedDefaultValue;                        // 0x0648(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _locomotionPlayrate;                               // 0x064C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _locomotionPlayrateDefaultValue;                   // 0x0650(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _locomotionStartPosition;                          // 0x0654(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isUsingHeavyCarry;                                // 0x0658(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isUsingLightCarry;                                // 0x0659(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isHealthy;                                        // 0x065A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_65B[0x1];                                      // 0x065B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           _bsLocomotionStandFlag;                            // 0x065C(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _aoLookAtStandLocoTag;                             // 0x0668(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _bsBankingTag;                                     // 0x0674(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _bsCrouchWalkTag;                                  // 0x0680(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _bsLookAtCrouchTag;                                // 0x068C(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _asFlashlightStandTag;                             // 0x0698(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _asStandIdleTag;                                   // 0x06A4(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _asLookAtStandDownTag;                             // 0x06B0(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _asLookAtStandFrontTag;                            // 0x06BC(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _asLookAtStandUpTag;                               // 0x06C8(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _asStandQuickLeftToRightTag;                       // 0x06D4(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _asStandQuickRightToLeftTag;                       // 0x06E0(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _asCarryIdleLightTag;                              // 0x06EC(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _asCarryIdleHeavyTag;                              // 0x06F8(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _asCarryIdleWITag;                                 // 0x0704(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _asCarryIdleTTTag;                                 // 0x0710(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _bsCrawlToStandTag;                                // 0x071C(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _asDeepWoundTag;                                   // 0x0728(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _asCrawlRecoverTag;                                // 0x0734(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _asCrawlTag;                                       // 0x0740(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _aoCrawlTag;                                       // 0x074C(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _asCrawlToDeadTag;                                 // 0x0758(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _asDeadTag;                                        // 0x0764(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _carryIdleLightNeckTag;                            // 0x0770(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_77C[0x4];                                      // 0x077C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBlendSpace*                            _bsLocomotionStand;                                // 0x0780(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAimOffsetBlendSpace*                   _aoLookAtStandLoco;                                // 0x0788(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBlendSpace1D*                          _bsBanking;                                        // 0x0790(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBlendSpace*                            _bsCrouchWalk;                                     // 0x0798(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAimOffsetBlendSpace1D*                 _bsLookAtCrouch;                                   // 0x07A0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _asFlashlightStand;                                // 0x07A8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _asStandIdle;                                      // 0x07B0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _asLookAtStandDown;                                // 0x07B8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _asLookAtStandFront;                               // 0x07C0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _asLookAtStandUp;                                  // 0x07C8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _asStandQuickLeftToRight;                          // 0x07D0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _asStandQuickRightToLeft;                          // 0x07D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _asCarryIdleLight;                                 // 0x07E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _asCarryIdleHeavy;                                 // 0x07E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _asCarryIdleWI;                                    // 0x07F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _asCarryIdleTT;                                    // 0x07F8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBlendSpace1D*                          _bsCrawlToStand;                                   // 0x0800(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _asDeepWound;                                      // 0x0808(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _asCrawlRecover;                                   // 0x0810(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _asCrawl;                                          // 0x0818(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAimOffsetBlendSpace1D*                 _aoCrawl;                                          // 0x0820(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _asCrawlToDead;                                    // 0x0828(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _asDead;                                           // 0x0830(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _carryIdleLightNeckAnimation;                      // 0x0838(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isRecoveringWhileCrawling;                        // 0x0840(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isTenacityPerkActive;                             // 0x0841(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_842[0x2];                                      // 0x0842(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _wasMovingResetTime;                               // 0x0844(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isIdle;                                           // 0x0848(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _shouldPlayLowerCarryAnimation;                    // 0x0849(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isRunning;                                        // 0x084A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isCrouching;                                      // 0x084B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isCrawling;                                       // 0x084C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isDead;                                           // 0x084D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_84E[0x2];                                      // 0x084E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _walkAnimSpeed;                                    // 0x0850(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _walkAnimStartOffset;                              // 0x0854(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _walkAnimPlayRateMultiplier;                       // 0x0858(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _wasLastDamageSourceDeepWounds;                    // 0x085C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_85D[0x1];                                      // 0x085D(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _isStrafing;                                       // 0x085E(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isUsingDeadHard;                                  // 0x085F(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _direction;                                        // 0x0860(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isUsingAimItem;                                   // 0x0864(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_865[0x3];                                      // 0x0865(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _aimOffsetPitch;                                   // 0x0868(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _aimOffsetYaw;                                     // 0x086C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isAimOffsetYawInDeadZone;                         // 0x0870(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isBeingCarried;                                   // 0x0871(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_872[0x2];                                      // 0x0872(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _crawlingDirectionWhileMoving;                     // 0x0874(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _crawlMovingJustStopped;                           // 0x0878(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isImmobilized;                                    // 0x0879(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _canUseLookAtRule;                                 // 0x087A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _cannotUseLookAtRule;                              // 0x087B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _lookAtStandIdleToQuickLeftToRightRule;            // 0x087C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _lookAtStandIdleToQuickRightToLeftRule;            // 0x087D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _mainConduitToDeadRule;                            // 0x087E(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _mainConduitToCrawlRule;                           // 0x087F(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _mainConduitToDeepWoundToCrawlRule;                // 0x0880(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _mainConduitToConduitToLocomotionRule;             // 0x0881(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _conduitToLocomotionToCrouchRule;                  // 0x0882(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _conduitToLocomotionToWalkRunRule;                 // 0x0883(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _conduitToLocomotionToStandIdle;                   // 0x0884(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_885[0x3];                                      // 0x0885(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _lookAtAlphaBlendMultiDown;                        // 0x0888(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _lookAtAlphaBlendMultiCenter;                      // 0x088C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _lookAtAlphaBlendMultiUp;                          // 0x0890(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isDrasticAimOffsetYawChangeDetected;              // 0x0894(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _lightOnNeckWhenCarried;                           // 0x0895(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_896[0x2];                                      // 0x0896(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _aimOffsetYawInterpolated;                         // 0x0898(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _aimOffsetYawClampValue;                           // 0x089C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _maxParadiseWalkCycleOffSet;                       // 0x08A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8A4[0x4];                                      // 0x08A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _minParadiseWalkPlayRateMultiplier;                // 0x08A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8AC[0x4];                                      // 0x08AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameplayTag>                   _lowerCarryAnimationPresenceTags;                  // 0x08B0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  _lightOnNeckWhenCarriedPresenceTag;                // 0x08C0(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FVector2D                              _lookAtNormalizationVector;                        // 0x08E0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              _lookAtMiddleToDownVector;                         // 0x08F0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              _lookAtMiddleToUpVector;                           // 0x0900(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_910[0x60];                                     // 0x0910(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LocomotionSurvivorSubAnimInstance">();
	}
	static class ULocomotionSurvivorSubAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULocomotionSurvivorSubAnimInstance>();
	}
};
static_assert(alignof(ULocomotionSurvivorSubAnimInstance) == 0x000010, "Wrong alignment on ULocomotionSurvivorSubAnimInstance");
static_assert(sizeof(ULocomotionSurvivorSubAnimInstance) == 0x000970, "Wrong size on ULocomotionSurvivorSubAnimInstance");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _recoveringInteractionTag) == 0x0005E0, "Member 'ULocomotionSurvivorSubAnimInstance::_recoveringInteractionTag' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _allowNavigationWhileRecoverTag) == 0x0005EC, "Member 'ULocomotionSurvivorSubAnimInstance::_allowNavigationWhileRecoverTag' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _modifyLocomotionScaleTag) == 0x0005F8, "Member 'ULocomotionSurvivorSubAnimInstance::_modifyLocomotionScaleTag' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _aimOffsetYawInterpolationSpeed) == 0x000604, "Member 'ULocomotionSurvivorSubAnimInstance::_aimOffsetYawInterpolationSpeed' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _aimOffsetYawDeadzoneStart) == 0x000608, "Member 'ULocomotionSurvivorSubAnimInstance::_aimOffsetYawDeadzoneStart' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _aimOffsetYawDrasticChangeUpperLimit) == 0x00060C, "Member 'ULocomotionSurvivorSubAnimInstance::_aimOffsetYawDrasticChangeUpperLimit' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _aimOffsetYawDrasticChangeLowerLimit) == 0x000610, "Member 'ULocomotionSurvivorSubAnimInstance::_aimOffsetYawDrasticChangeLowerLimit' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _aimOffsetYawDrasticChangeInterpolationSpeed) == 0x000614, "Member 'ULocomotionSurvivorSubAnimInstance::_aimOffsetYawDrasticChangeInterpolationSpeed' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _aimOffsetYawInterpolateEaseIn) == 0x000618, "Member 'ULocomotionSurvivorSubAnimInstance::_aimOffsetYawInterpolateEaseIn' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _aimOffsetYawInterpolateEaseOut) == 0x000620, "Member 'ULocomotionSurvivorSubAnimInstance::_aimOffsetYawInterpolateEaseOut' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _aimOffsetYawInterpolationEaseInLength) == 0x000628, "Member 'ULocomotionSurvivorSubAnimInstance::_aimOffsetYawInterpolationEaseInLength' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _aimOffsetYawInterpolationEaseOutDistance) == 0x00062C, "Member 'ULocomotionSurvivorSubAnimInstance::_aimOffsetYawInterpolationEaseOutDistance' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _isPlayerInPerkInteractionToFloat) == 0x000630, "Member 'ULocomotionSurvivorSubAnimInstance::_isPlayerInPerkInteractionToFloat' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _isCrawlRecover) == 0x000634, "Member 'ULocomotionSurvivorSubAnimInstance::_isCrawlRecover' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _explicitTimeLookAtStand) == 0x000638, "Member 'ULocomotionSurvivorSubAnimInstance::_explicitTimeLookAtStand' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _lookAtAlpha) == 0x00063C, "Member 'ULocomotionSurvivorSubAnimInstance::_lookAtAlpha' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _strafingDirection) == 0x000640, "Member 'ULocomotionSurvivorSubAnimInstance::_strafingDirection' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _strafingSpeed) == 0x000644, "Member 'ULocomotionSurvivorSubAnimInstance::_strafingSpeed' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _strafingSpeedDefaultValue) == 0x000648, "Member 'ULocomotionSurvivorSubAnimInstance::_strafingSpeedDefaultValue' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _locomotionPlayrate) == 0x00064C, "Member 'ULocomotionSurvivorSubAnimInstance::_locomotionPlayrate' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _locomotionPlayrateDefaultValue) == 0x000650, "Member 'ULocomotionSurvivorSubAnimInstance::_locomotionPlayrateDefaultValue' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _locomotionStartPosition) == 0x000654, "Member 'ULocomotionSurvivorSubAnimInstance::_locomotionStartPosition' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _isUsingHeavyCarry) == 0x000658, "Member 'ULocomotionSurvivorSubAnimInstance::_isUsingHeavyCarry' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _isUsingLightCarry) == 0x000659, "Member 'ULocomotionSurvivorSubAnimInstance::_isUsingLightCarry' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _isHealthy) == 0x00065A, "Member 'ULocomotionSurvivorSubAnimInstance::_isHealthy' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _bsLocomotionStandFlag) == 0x00065C, "Member 'ULocomotionSurvivorSubAnimInstance::_bsLocomotionStandFlag' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _aoLookAtStandLocoTag) == 0x000668, "Member 'ULocomotionSurvivorSubAnimInstance::_aoLookAtStandLocoTag' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _bsBankingTag) == 0x000674, "Member 'ULocomotionSurvivorSubAnimInstance::_bsBankingTag' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _bsCrouchWalkTag) == 0x000680, "Member 'ULocomotionSurvivorSubAnimInstance::_bsCrouchWalkTag' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _bsLookAtCrouchTag) == 0x00068C, "Member 'ULocomotionSurvivorSubAnimInstance::_bsLookAtCrouchTag' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _asFlashlightStandTag) == 0x000698, "Member 'ULocomotionSurvivorSubAnimInstance::_asFlashlightStandTag' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _asStandIdleTag) == 0x0006A4, "Member 'ULocomotionSurvivorSubAnimInstance::_asStandIdleTag' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _asLookAtStandDownTag) == 0x0006B0, "Member 'ULocomotionSurvivorSubAnimInstance::_asLookAtStandDownTag' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _asLookAtStandFrontTag) == 0x0006BC, "Member 'ULocomotionSurvivorSubAnimInstance::_asLookAtStandFrontTag' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _asLookAtStandUpTag) == 0x0006C8, "Member 'ULocomotionSurvivorSubAnimInstance::_asLookAtStandUpTag' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _asStandQuickLeftToRightTag) == 0x0006D4, "Member 'ULocomotionSurvivorSubAnimInstance::_asStandQuickLeftToRightTag' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _asStandQuickRightToLeftTag) == 0x0006E0, "Member 'ULocomotionSurvivorSubAnimInstance::_asStandQuickRightToLeftTag' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _asCarryIdleLightTag) == 0x0006EC, "Member 'ULocomotionSurvivorSubAnimInstance::_asCarryIdleLightTag' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _asCarryIdleHeavyTag) == 0x0006F8, "Member 'ULocomotionSurvivorSubAnimInstance::_asCarryIdleHeavyTag' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _asCarryIdleWITag) == 0x000704, "Member 'ULocomotionSurvivorSubAnimInstance::_asCarryIdleWITag' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _asCarryIdleTTTag) == 0x000710, "Member 'ULocomotionSurvivorSubAnimInstance::_asCarryIdleTTTag' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _bsCrawlToStandTag) == 0x00071C, "Member 'ULocomotionSurvivorSubAnimInstance::_bsCrawlToStandTag' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _asDeepWoundTag) == 0x000728, "Member 'ULocomotionSurvivorSubAnimInstance::_asDeepWoundTag' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _asCrawlRecoverTag) == 0x000734, "Member 'ULocomotionSurvivorSubAnimInstance::_asCrawlRecoverTag' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _asCrawlTag) == 0x000740, "Member 'ULocomotionSurvivorSubAnimInstance::_asCrawlTag' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _aoCrawlTag) == 0x00074C, "Member 'ULocomotionSurvivorSubAnimInstance::_aoCrawlTag' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _asCrawlToDeadTag) == 0x000758, "Member 'ULocomotionSurvivorSubAnimInstance::_asCrawlToDeadTag' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _asDeadTag) == 0x000764, "Member 'ULocomotionSurvivorSubAnimInstance::_asDeadTag' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _carryIdleLightNeckTag) == 0x000770, "Member 'ULocomotionSurvivorSubAnimInstance::_carryIdleLightNeckTag' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _bsLocomotionStand) == 0x000780, "Member 'ULocomotionSurvivorSubAnimInstance::_bsLocomotionStand' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _aoLookAtStandLoco) == 0x000788, "Member 'ULocomotionSurvivorSubAnimInstance::_aoLookAtStandLoco' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _bsBanking) == 0x000790, "Member 'ULocomotionSurvivorSubAnimInstance::_bsBanking' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _bsCrouchWalk) == 0x000798, "Member 'ULocomotionSurvivorSubAnimInstance::_bsCrouchWalk' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _bsLookAtCrouch) == 0x0007A0, "Member 'ULocomotionSurvivorSubAnimInstance::_bsLookAtCrouch' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _asFlashlightStand) == 0x0007A8, "Member 'ULocomotionSurvivorSubAnimInstance::_asFlashlightStand' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _asStandIdle) == 0x0007B0, "Member 'ULocomotionSurvivorSubAnimInstance::_asStandIdle' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _asLookAtStandDown) == 0x0007B8, "Member 'ULocomotionSurvivorSubAnimInstance::_asLookAtStandDown' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _asLookAtStandFront) == 0x0007C0, "Member 'ULocomotionSurvivorSubAnimInstance::_asLookAtStandFront' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _asLookAtStandUp) == 0x0007C8, "Member 'ULocomotionSurvivorSubAnimInstance::_asLookAtStandUp' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _asStandQuickLeftToRight) == 0x0007D0, "Member 'ULocomotionSurvivorSubAnimInstance::_asStandQuickLeftToRight' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _asStandQuickRightToLeft) == 0x0007D8, "Member 'ULocomotionSurvivorSubAnimInstance::_asStandQuickRightToLeft' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _asCarryIdleLight) == 0x0007E0, "Member 'ULocomotionSurvivorSubAnimInstance::_asCarryIdleLight' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _asCarryIdleHeavy) == 0x0007E8, "Member 'ULocomotionSurvivorSubAnimInstance::_asCarryIdleHeavy' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _asCarryIdleWI) == 0x0007F0, "Member 'ULocomotionSurvivorSubAnimInstance::_asCarryIdleWI' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _asCarryIdleTT) == 0x0007F8, "Member 'ULocomotionSurvivorSubAnimInstance::_asCarryIdleTT' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _bsCrawlToStand) == 0x000800, "Member 'ULocomotionSurvivorSubAnimInstance::_bsCrawlToStand' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _asDeepWound) == 0x000808, "Member 'ULocomotionSurvivorSubAnimInstance::_asDeepWound' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _asCrawlRecover) == 0x000810, "Member 'ULocomotionSurvivorSubAnimInstance::_asCrawlRecover' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _asCrawl) == 0x000818, "Member 'ULocomotionSurvivorSubAnimInstance::_asCrawl' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _aoCrawl) == 0x000820, "Member 'ULocomotionSurvivorSubAnimInstance::_aoCrawl' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _asCrawlToDead) == 0x000828, "Member 'ULocomotionSurvivorSubAnimInstance::_asCrawlToDead' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _asDead) == 0x000830, "Member 'ULocomotionSurvivorSubAnimInstance::_asDead' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _carryIdleLightNeckAnimation) == 0x000838, "Member 'ULocomotionSurvivorSubAnimInstance::_carryIdleLightNeckAnimation' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _isRecoveringWhileCrawling) == 0x000840, "Member 'ULocomotionSurvivorSubAnimInstance::_isRecoveringWhileCrawling' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _isTenacityPerkActive) == 0x000841, "Member 'ULocomotionSurvivorSubAnimInstance::_isTenacityPerkActive' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _wasMovingResetTime) == 0x000844, "Member 'ULocomotionSurvivorSubAnimInstance::_wasMovingResetTime' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _isIdle) == 0x000848, "Member 'ULocomotionSurvivorSubAnimInstance::_isIdle' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _shouldPlayLowerCarryAnimation) == 0x000849, "Member 'ULocomotionSurvivorSubAnimInstance::_shouldPlayLowerCarryAnimation' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _isRunning) == 0x00084A, "Member 'ULocomotionSurvivorSubAnimInstance::_isRunning' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _isCrouching) == 0x00084B, "Member 'ULocomotionSurvivorSubAnimInstance::_isCrouching' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _isCrawling) == 0x00084C, "Member 'ULocomotionSurvivorSubAnimInstance::_isCrawling' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _isDead) == 0x00084D, "Member 'ULocomotionSurvivorSubAnimInstance::_isDead' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _walkAnimSpeed) == 0x000850, "Member 'ULocomotionSurvivorSubAnimInstance::_walkAnimSpeed' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _walkAnimStartOffset) == 0x000854, "Member 'ULocomotionSurvivorSubAnimInstance::_walkAnimStartOffset' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _walkAnimPlayRateMultiplier) == 0x000858, "Member 'ULocomotionSurvivorSubAnimInstance::_walkAnimPlayRateMultiplier' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _wasLastDamageSourceDeepWounds) == 0x00085C, "Member 'ULocomotionSurvivorSubAnimInstance::_wasLastDamageSourceDeepWounds' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _isStrafing) == 0x00085E, "Member 'ULocomotionSurvivorSubAnimInstance::_isStrafing' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _isUsingDeadHard) == 0x00085F, "Member 'ULocomotionSurvivorSubAnimInstance::_isUsingDeadHard' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _direction) == 0x000860, "Member 'ULocomotionSurvivorSubAnimInstance::_direction' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _isUsingAimItem) == 0x000864, "Member 'ULocomotionSurvivorSubAnimInstance::_isUsingAimItem' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _aimOffsetPitch) == 0x000868, "Member 'ULocomotionSurvivorSubAnimInstance::_aimOffsetPitch' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _aimOffsetYaw) == 0x00086C, "Member 'ULocomotionSurvivorSubAnimInstance::_aimOffsetYaw' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _isAimOffsetYawInDeadZone) == 0x000870, "Member 'ULocomotionSurvivorSubAnimInstance::_isAimOffsetYawInDeadZone' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _isBeingCarried) == 0x000871, "Member 'ULocomotionSurvivorSubAnimInstance::_isBeingCarried' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _crawlingDirectionWhileMoving) == 0x000874, "Member 'ULocomotionSurvivorSubAnimInstance::_crawlingDirectionWhileMoving' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _crawlMovingJustStopped) == 0x000878, "Member 'ULocomotionSurvivorSubAnimInstance::_crawlMovingJustStopped' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _isImmobilized) == 0x000879, "Member 'ULocomotionSurvivorSubAnimInstance::_isImmobilized' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _canUseLookAtRule) == 0x00087A, "Member 'ULocomotionSurvivorSubAnimInstance::_canUseLookAtRule' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _cannotUseLookAtRule) == 0x00087B, "Member 'ULocomotionSurvivorSubAnimInstance::_cannotUseLookAtRule' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _lookAtStandIdleToQuickLeftToRightRule) == 0x00087C, "Member 'ULocomotionSurvivorSubAnimInstance::_lookAtStandIdleToQuickLeftToRightRule' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _lookAtStandIdleToQuickRightToLeftRule) == 0x00087D, "Member 'ULocomotionSurvivorSubAnimInstance::_lookAtStandIdleToQuickRightToLeftRule' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _mainConduitToDeadRule) == 0x00087E, "Member 'ULocomotionSurvivorSubAnimInstance::_mainConduitToDeadRule' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _mainConduitToCrawlRule) == 0x00087F, "Member 'ULocomotionSurvivorSubAnimInstance::_mainConduitToCrawlRule' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _mainConduitToDeepWoundToCrawlRule) == 0x000880, "Member 'ULocomotionSurvivorSubAnimInstance::_mainConduitToDeepWoundToCrawlRule' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _mainConduitToConduitToLocomotionRule) == 0x000881, "Member 'ULocomotionSurvivorSubAnimInstance::_mainConduitToConduitToLocomotionRule' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _conduitToLocomotionToCrouchRule) == 0x000882, "Member 'ULocomotionSurvivorSubAnimInstance::_conduitToLocomotionToCrouchRule' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _conduitToLocomotionToWalkRunRule) == 0x000883, "Member 'ULocomotionSurvivorSubAnimInstance::_conduitToLocomotionToWalkRunRule' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _conduitToLocomotionToStandIdle) == 0x000884, "Member 'ULocomotionSurvivorSubAnimInstance::_conduitToLocomotionToStandIdle' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _lookAtAlphaBlendMultiDown) == 0x000888, "Member 'ULocomotionSurvivorSubAnimInstance::_lookAtAlphaBlendMultiDown' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _lookAtAlphaBlendMultiCenter) == 0x00088C, "Member 'ULocomotionSurvivorSubAnimInstance::_lookAtAlphaBlendMultiCenter' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _lookAtAlphaBlendMultiUp) == 0x000890, "Member 'ULocomotionSurvivorSubAnimInstance::_lookAtAlphaBlendMultiUp' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _isDrasticAimOffsetYawChangeDetected) == 0x000894, "Member 'ULocomotionSurvivorSubAnimInstance::_isDrasticAimOffsetYawChangeDetected' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _lightOnNeckWhenCarried) == 0x000895, "Member 'ULocomotionSurvivorSubAnimInstance::_lightOnNeckWhenCarried' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _aimOffsetYawInterpolated) == 0x000898, "Member 'ULocomotionSurvivorSubAnimInstance::_aimOffsetYawInterpolated' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _aimOffsetYawClampValue) == 0x00089C, "Member 'ULocomotionSurvivorSubAnimInstance::_aimOffsetYawClampValue' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _maxParadiseWalkCycleOffSet) == 0x0008A0, "Member 'ULocomotionSurvivorSubAnimInstance::_maxParadiseWalkCycleOffSet' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _minParadiseWalkPlayRateMultiplier) == 0x0008A8, "Member 'ULocomotionSurvivorSubAnimInstance::_minParadiseWalkPlayRateMultiplier' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _lowerCarryAnimationPresenceTags) == 0x0008B0, "Member 'ULocomotionSurvivorSubAnimInstance::_lowerCarryAnimationPresenceTags' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _lightOnNeckWhenCarriedPresenceTag) == 0x0008C0, "Member 'ULocomotionSurvivorSubAnimInstance::_lightOnNeckWhenCarriedPresenceTag' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _lookAtNormalizationVector) == 0x0008E0, "Member 'ULocomotionSurvivorSubAnimInstance::_lookAtNormalizationVector' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _lookAtMiddleToDownVector) == 0x0008F0, "Member 'ULocomotionSurvivorSubAnimInstance::_lookAtMiddleToDownVector' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _lookAtMiddleToUpVector) == 0x000900, "Member 'ULocomotionSurvivorSubAnimInstance::_lookAtMiddleToUpVector' has a wrong offset!");

// Class DBDAnimation.LookAtKillerSubAnimInstance
// 0x0070 (0x03C0 - 0x0350)
class ULookAtKillerSubAnimInstance : public UAnimInstance
{
public:
	class ADBDPlayer*                             _owningPawn;                                       // 0x0350(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ASlasherPlayer*                         _owningKiller;                                     // 0x0358(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _enableDynamics;                                   // 0x0360(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_361[0x3];                                      // 0x0361(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _dynamicsAlpha;                                    // 0x0364(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _shouldApplyDynamics;                              // 0x0368(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_369[0x3];                                      // 0x0369(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _blendTime;                                        // 0x036C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _animYaw;                                          // 0x0370(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _enableTurnInPlace;                                // 0x0374(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _shouldResetLookAtOnAnyMontagePlay;                // 0x0375(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _shouldResetLookAtOnAnyInteraction;                // 0x0376(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _shouldTurnLeft;                                   // 0x0377(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _shouldTurnRight;                                  // 0x0378(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_379[0x3];                                      // 0x0379(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _turnInPlaceThresholdAngle;                        // 0x037C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _idleNeutralRotationYaw;                           // 0x0380(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isIdle;                                           // 0x0384(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_385[0x1B];                                     // 0x0385(0x001B)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 _skeletalMeshComponent;                            // 0x03A0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3A8[0x18];                                     // 0x03A8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetBlendDuration() const;
	bool IsLookAtAllowed() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LookAtKillerSubAnimInstance">();
	}
	static class ULookAtKillerSubAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULookAtKillerSubAnimInstance>();
	}
};
static_assert(alignof(ULookAtKillerSubAnimInstance) == 0x000010, "Wrong alignment on ULookAtKillerSubAnimInstance");
static_assert(sizeof(ULookAtKillerSubAnimInstance) == 0x0003C0, "Wrong size on ULookAtKillerSubAnimInstance");
static_assert(offsetof(ULookAtKillerSubAnimInstance, _owningPawn) == 0x000350, "Member 'ULookAtKillerSubAnimInstance::_owningPawn' has a wrong offset!");
static_assert(offsetof(ULookAtKillerSubAnimInstance, _owningKiller) == 0x000358, "Member 'ULookAtKillerSubAnimInstance::_owningKiller' has a wrong offset!");
static_assert(offsetof(ULookAtKillerSubAnimInstance, _enableDynamics) == 0x000360, "Member 'ULookAtKillerSubAnimInstance::_enableDynamics' has a wrong offset!");
static_assert(offsetof(ULookAtKillerSubAnimInstance, _dynamicsAlpha) == 0x000364, "Member 'ULookAtKillerSubAnimInstance::_dynamicsAlpha' has a wrong offset!");
static_assert(offsetof(ULookAtKillerSubAnimInstance, _shouldApplyDynamics) == 0x000368, "Member 'ULookAtKillerSubAnimInstance::_shouldApplyDynamics' has a wrong offset!");
static_assert(offsetof(ULookAtKillerSubAnimInstance, _blendTime) == 0x00036C, "Member 'ULookAtKillerSubAnimInstance::_blendTime' has a wrong offset!");
static_assert(offsetof(ULookAtKillerSubAnimInstance, _animYaw) == 0x000370, "Member 'ULookAtKillerSubAnimInstance::_animYaw' has a wrong offset!");
static_assert(offsetof(ULookAtKillerSubAnimInstance, _enableTurnInPlace) == 0x000374, "Member 'ULookAtKillerSubAnimInstance::_enableTurnInPlace' has a wrong offset!");
static_assert(offsetof(ULookAtKillerSubAnimInstance, _shouldResetLookAtOnAnyMontagePlay) == 0x000375, "Member 'ULookAtKillerSubAnimInstance::_shouldResetLookAtOnAnyMontagePlay' has a wrong offset!");
static_assert(offsetof(ULookAtKillerSubAnimInstance, _shouldResetLookAtOnAnyInteraction) == 0x000376, "Member 'ULookAtKillerSubAnimInstance::_shouldResetLookAtOnAnyInteraction' has a wrong offset!");
static_assert(offsetof(ULookAtKillerSubAnimInstance, _shouldTurnLeft) == 0x000377, "Member 'ULookAtKillerSubAnimInstance::_shouldTurnLeft' has a wrong offset!");
static_assert(offsetof(ULookAtKillerSubAnimInstance, _shouldTurnRight) == 0x000378, "Member 'ULookAtKillerSubAnimInstance::_shouldTurnRight' has a wrong offset!");
static_assert(offsetof(ULookAtKillerSubAnimInstance, _turnInPlaceThresholdAngle) == 0x00037C, "Member 'ULookAtKillerSubAnimInstance::_turnInPlaceThresholdAngle' has a wrong offset!");
static_assert(offsetof(ULookAtKillerSubAnimInstance, _idleNeutralRotationYaw) == 0x000380, "Member 'ULookAtKillerSubAnimInstance::_idleNeutralRotationYaw' has a wrong offset!");
static_assert(offsetof(ULookAtKillerSubAnimInstance, _isIdle) == 0x000384, "Member 'ULookAtKillerSubAnimInstance::_isIdle' has a wrong offset!");
static_assert(offsetof(ULookAtKillerSubAnimInstance, _skeletalMeshComponent) == 0x0003A0, "Member 'ULookAtKillerSubAnimInstance::_skeletalMeshComponent' has a wrong offset!");

// Class DBDAnimation.LookAtTargetKillerSubAnimInstance
// 0x01C0 (0x07B0 - 0x05F0)
class ULookAtTargetKillerSubAnimInstance final : public UBaseKillerAnimInstance
{
public:
	float                                         _maxDistanceForTargetDetection;                    // 0x05F0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _headSocket;                                       // 0x05F4(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _rootSocket;                                       // 0x0600(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _preferredMinLookAtTime;                           // 0x060C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _distanceScoreFactor;                              // 0x0610(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _angleScoreFactor;                                 // 0x0614(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _sameTargetScoreFactor;                            // 0x0618(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _yawToTarget;                                      // 0x061C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _pitchToTarget;                                    // 0x0620(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _hasVisibleTarget;                                 // 0x0624(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_625[0x18B];                                    // 0x0625(0x018B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnChaseEnded(class ADBDPlayer* Target, float ChaseTime);
	void OnChaseStarted(class ADBDPlayer* Target);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LookAtTargetKillerSubAnimInstance">();
	}
	static class ULookAtTargetKillerSubAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULookAtTargetKillerSubAnimInstance>();
	}
};
static_assert(alignof(ULookAtTargetKillerSubAnimInstance) == 0x000010, "Wrong alignment on ULookAtTargetKillerSubAnimInstance");
static_assert(sizeof(ULookAtTargetKillerSubAnimInstance) == 0x0007B0, "Wrong size on ULookAtTargetKillerSubAnimInstance");
static_assert(offsetof(ULookAtTargetKillerSubAnimInstance, _maxDistanceForTargetDetection) == 0x0005F0, "Member 'ULookAtTargetKillerSubAnimInstance::_maxDistanceForTargetDetection' has a wrong offset!");
static_assert(offsetof(ULookAtTargetKillerSubAnimInstance, _headSocket) == 0x0005F4, "Member 'ULookAtTargetKillerSubAnimInstance::_headSocket' has a wrong offset!");
static_assert(offsetof(ULookAtTargetKillerSubAnimInstance, _rootSocket) == 0x000600, "Member 'ULookAtTargetKillerSubAnimInstance::_rootSocket' has a wrong offset!");
static_assert(offsetof(ULookAtTargetKillerSubAnimInstance, _preferredMinLookAtTime) == 0x00060C, "Member 'ULookAtTargetKillerSubAnimInstance::_preferredMinLookAtTime' has a wrong offset!");
static_assert(offsetof(ULookAtTargetKillerSubAnimInstance, _distanceScoreFactor) == 0x000610, "Member 'ULookAtTargetKillerSubAnimInstance::_distanceScoreFactor' has a wrong offset!");
static_assert(offsetof(ULookAtTargetKillerSubAnimInstance, _angleScoreFactor) == 0x000614, "Member 'ULookAtTargetKillerSubAnimInstance::_angleScoreFactor' has a wrong offset!");
static_assert(offsetof(ULookAtTargetKillerSubAnimInstance, _sameTargetScoreFactor) == 0x000618, "Member 'ULookAtTargetKillerSubAnimInstance::_sameTargetScoreFactor' has a wrong offset!");
static_assert(offsetof(ULookAtTargetKillerSubAnimInstance, _yawToTarget) == 0x00061C, "Member 'ULookAtTargetKillerSubAnimInstance::_yawToTarget' has a wrong offset!");
static_assert(offsetof(ULookAtTargetKillerSubAnimInstance, _pitchToTarget) == 0x000620, "Member 'ULookAtTargetKillerSubAnimInstance::_pitchToTarget' has a wrong offset!");
static_assert(offsetof(ULookAtTargetKillerSubAnimInstance, _hasVisibleTarget) == 0x000624, "Member 'ULookAtTargetKillerSubAnimInstance::_hasVisibleTarget' has a wrong offset!");

// Class DBDAnimation.LookAtThreatSurvivorSubAnimInstance
// 0x0160 (0x0740 - 0x05E0)
class ULookAtThreatSurvivorSubAnimInstance final : public UBaseSurvivorAnimInstance
{
public:
	float                                         _maxDistanceForThreatDetection;                    // 0x05E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _headSocket;                                       // 0x05E4(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _rootSocket;                                       // 0x05F0(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _yawToThreat;                                      // 0x05FC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _pitchToThreat;                                    // 0x0600(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isVisibleThreat;                                  // 0x0604(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_605[0x13B];                                    // 0x0605(0x013B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LookAtThreatSurvivorSubAnimInstance">();
	}
	static class ULookAtThreatSurvivorSubAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULookAtThreatSurvivorSubAnimInstance>();
	}
};
static_assert(alignof(ULookAtThreatSurvivorSubAnimInstance) == 0x000010, "Wrong alignment on ULookAtThreatSurvivorSubAnimInstance");
static_assert(sizeof(ULookAtThreatSurvivorSubAnimInstance) == 0x000740, "Wrong size on ULookAtThreatSurvivorSubAnimInstance");
static_assert(offsetof(ULookAtThreatSurvivorSubAnimInstance, _maxDistanceForThreatDetection) == 0x0005E0, "Member 'ULookAtThreatSurvivorSubAnimInstance::_maxDistanceForThreatDetection' has a wrong offset!");
static_assert(offsetof(ULookAtThreatSurvivorSubAnimInstance, _headSocket) == 0x0005E4, "Member 'ULookAtThreatSurvivorSubAnimInstance::_headSocket' has a wrong offset!");
static_assert(offsetof(ULookAtThreatSurvivorSubAnimInstance, _rootSocket) == 0x0005F0, "Member 'ULookAtThreatSurvivorSubAnimInstance::_rootSocket' has a wrong offset!");
static_assert(offsetof(ULookAtThreatSurvivorSubAnimInstance, _yawToThreat) == 0x0005FC, "Member 'ULookAtThreatSurvivorSubAnimInstance::_yawToThreat' has a wrong offset!");
static_assert(offsetof(ULookAtThreatSurvivorSubAnimInstance, _pitchToThreat) == 0x000600, "Member 'ULookAtThreatSurvivorSubAnimInstance::_pitchToThreat' has a wrong offset!");
static_assert(offsetof(ULookAtThreatSurvivorSubAnimInstance, _isVisibleThreat) == 0x000604, "Member 'ULookAtThreatSurvivorSubAnimInstance::_isVisibleThreat' has a wrong offset!");

// Class DBDAnimation.MeshRotationCorrectionSubAnimInstance
// 0x0040 (0x0620 - 0x05E0)
class UMeshRotationCorrectionSubAnimInstance : public UBaseSurvivorAnimInstance
{
public:
	float                                         _rotationInterpSpeed;                              // 0x05E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5E4[0x4];                                      // 0x05E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               _toSlopeRotation;                                  // 0x05E8(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class UCharacterMovementComponent*            _movementComponent;                                // 0x0600(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_608[0x18];                                     // 0x0608(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MeshRotationCorrectionSubAnimInstance">();
	}
	static class UMeshRotationCorrectionSubAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMeshRotationCorrectionSubAnimInstance>();
	}
};
static_assert(alignof(UMeshRotationCorrectionSubAnimInstance) == 0x000010, "Wrong alignment on UMeshRotationCorrectionSubAnimInstance");
static_assert(sizeof(UMeshRotationCorrectionSubAnimInstance) == 0x000620, "Wrong size on UMeshRotationCorrectionSubAnimInstance");
static_assert(offsetof(UMeshRotationCorrectionSubAnimInstance, _rotationInterpSpeed) == 0x0005E0, "Member 'UMeshRotationCorrectionSubAnimInstance::_rotationInterpSpeed' has a wrong offset!");
static_assert(offsetof(UMeshRotationCorrectionSubAnimInstance, _toSlopeRotation) == 0x0005E8, "Member 'UMeshRotationCorrectionSubAnimInstance::_toSlopeRotation' has a wrong offset!");
static_assert(offsetof(UMeshRotationCorrectionSubAnimInstance, _movementComponent) == 0x000600, "Member 'UMeshRotationCorrectionSubAnimInstance::_movementComponent' has a wrong offset!");

// Class DBDAnimation.OnPlayerOverlapAnimInstance
// 0x00B0 (0x0430 - 0x0380)
class UOnPlayerOverlapAnimInstance final : public UDBDBaseAnimInstance
{
public:
	bool                                          _isPlayerWithinTriggerArea;                        // 0x0380(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _isInCooldown;                                     // 0x0381(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_382[0x1E];                                     // 0x0382(0x001E)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<TWeakObjectPtr<class ADBDPlayer>>        _overlappingPlayers;                               // 0x03A0(0x0050)(Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	float                                         _cooldownDuration;                                 // 0x03F0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3F4[0x3C];                                     // 0x03F4(0x003C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnActivePhaseDone();
	void OnCollisionOverlapBegin(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnCollisionOverlapEnd(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnPlayerOverlapAnimInstance">();
	}
	static class UOnPlayerOverlapAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOnPlayerOverlapAnimInstance>();
	}
};
static_assert(alignof(UOnPlayerOverlapAnimInstance) == 0x000010, "Wrong alignment on UOnPlayerOverlapAnimInstance");
static_assert(sizeof(UOnPlayerOverlapAnimInstance) == 0x000430, "Wrong size on UOnPlayerOverlapAnimInstance");
static_assert(offsetof(UOnPlayerOverlapAnimInstance, _isPlayerWithinTriggerArea) == 0x000380, "Member 'UOnPlayerOverlapAnimInstance::_isPlayerWithinTriggerArea' has a wrong offset!");
static_assert(offsetof(UOnPlayerOverlapAnimInstance, _isInCooldown) == 0x000381, "Member 'UOnPlayerOverlapAnimInstance::_isInCooldown' has a wrong offset!");
static_assert(offsetof(UOnPlayerOverlapAnimInstance, _overlappingPlayers) == 0x0003A0, "Member 'UOnPlayerOverlapAnimInstance::_overlappingPlayers' has a wrong offset!");
static_assert(offsetof(UOnPlayerOverlapAnimInstance, _cooldownDuration) == 0x0003F0, "Member 'UOnPlayerOverlapAnimInstance::_cooldownDuration' has a wrong offset!");

// Class DBDAnimation.OpenChestSurvivorSubAnimInstance
// 0x0120 (0x0700 - 0x05E0)
class UOpenChestSurvivorSubAnimInstance : public UBaseSurvivorAnimInstance
{
public:
	struct FGameplayTagContainer                  _searchChestTags;                                  // 0x05E0(0x0020)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	bool                                          _isIdle;                                           // 0x0600(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isInteractingWithChest;                           // 0x0601(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_602[0x2];                                      // 0x0602(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           _interactionPhase;                                 // 0x0604(0x000C)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isInteractingWithOpenChest;                       // 0x0610(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_611[0x7];                                      // 0x0611(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                _snapPosition;                                     // 0x0618(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _minRelevantAnimTimeRemaining;                     // 0x0630(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _asChestInTag;                                     // 0x0634(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _asChestLoopTag;                                   // 0x0640(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _asChestOutTag;                                    // 0x064C(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _asChestWhileOpenInTag;                            // 0x0658(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _asChestWhileOpenLoopTag;                          // 0x0664(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _asChestWhileOpenOutTag;                           // 0x0670(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_67C[0x4];                                      // 0x067C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          _asChestIn;                                        // 0x0680(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _asChestLoop;                                      // 0x0688(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _asChestOut;                                       // 0x0690(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _asChestWhileOpenIn;                               // 0x0698(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _asChestWhileOpenLoop;                             // 0x06A0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _asChestWhileOpenOut;                              // 0x06A8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _interactionPhaseEnter;                            // 0x06B0(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _outToInRule;                                      // 0x06BC(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _inSearchToLoopSearchRule;                         // 0x06BD(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _chestOutToBaseRule;                               // 0x06BE(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6BF[0x41];                                     // 0x06BF(0x0041)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OpenChestSurvivorSubAnimInstance">();
	}
	static class UOpenChestSurvivorSubAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOpenChestSurvivorSubAnimInstance>();
	}
};
static_assert(alignof(UOpenChestSurvivorSubAnimInstance) == 0x000010, "Wrong alignment on UOpenChestSurvivorSubAnimInstance");
static_assert(sizeof(UOpenChestSurvivorSubAnimInstance) == 0x000700, "Wrong size on UOpenChestSurvivorSubAnimInstance");
static_assert(offsetof(UOpenChestSurvivorSubAnimInstance, _searchChestTags) == 0x0005E0, "Member 'UOpenChestSurvivorSubAnimInstance::_searchChestTags' has a wrong offset!");
static_assert(offsetof(UOpenChestSurvivorSubAnimInstance, _isIdle) == 0x000600, "Member 'UOpenChestSurvivorSubAnimInstance::_isIdle' has a wrong offset!");
static_assert(offsetof(UOpenChestSurvivorSubAnimInstance, _isInteractingWithChest) == 0x000601, "Member 'UOpenChestSurvivorSubAnimInstance::_isInteractingWithChest' has a wrong offset!");
static_assert(offsetof(UOpenChestSurvivorSubAnimInstance, _interactionPhase) == 0x000604, "Member 'UOpenChestSurvivorSubAnimInstance::_interactionPhase' has a wrong offset!");
static_assert(offsetof(UOpenChestSurvivorSubAnimInstance, _isInteractingWithOpenChest) == 0x000610, "Member 'UOpenChestSurvivorSubAnimInstance::_isInteractingWithOpenChest' has a wrong offset!");
static_assert(offsetof(UOpenChestSurvivorSubAnimInstance, _snapPosition) == 0x000618, "Member 'UOpenChestSurvivorSubAnimInstance::_snapPosition' has a wrong offset!");
static_assert(offsetof(UOpenChestSurvivorSubAnimInstance, _minRelevantAnimTimeRemaining) == 0x000630, "Member 'UOpenChestSurvivorSubAnimInstance::_minRelevantAnimTimeRemaining' has a wrong offset!");
static_assert(offsetof(UOpenChestSurvivorSubAnimInstance, _asChestInTag) == 0x000634, "Member 'UOpenChestSurvivorSubAnimInstance::_asChestInTag' has a wrong offset!");
static_assert(offsetof(UOpenChestSurvivorSubAnimInstance, _asChestLoopTag) == 0x000640, "Member 'UOpenChestSurvivorSubAnimInstance::_asChestLoopTag' has a wrong offset!");
static_assert(offsetof(UOpenChestSurvivorSubAnimInstance, _asChestOutTag) == 0x00064C, "Member 'UOpenChestSurvivorSubAnimInstance::_asChestOutTag' has a wrong offset!");
static_assert(offsetof(UOpenChestSurvivorSubAnimInstance, _asChestWhileOpenInTag) == 0x000658, "Member 'UOpenChestSurvivorSubAnimInstance::_asChestWhileOpenInTag' has a wrong offset!");
static_assert(offsetof(UOpenChestSurvivorSubAnimInstance, _asChestWhileOpenLoopTag) == 0x000664, "Member 'UOpenChestSurvivorSubAnimInstance::_asChestWhileOpenLoopTag' has a wrong offset!");
static_assert(offsetof(UOpenChestSurvivorSubAnimInstance, _asChestWhileOpenOutTag) == 0x000670, "Member 'UOpenChestSurvivorSubAnimInstance::_asChestWhileOpenOutTag' has a wrong offset!");
static_assert(offsetof(UOpenChestSurvivorSubAnimInstance, _asChestIn) == 0x000680, "Member 'UOpenChestSurvivorSubAnimInstance::_asChestIn' has a wrong offset!");
static_assert(offsetof(UOpenChestSurvivorSubAnimInstance, _asChestLoop) == 0x000688, "Member 'UOpenChestSurvivorSubAnimInstance::_asChestLoop' has a wrong offset!");
static_assert(offsetof(UOpenChestSurvivorSubAnimInstance, _asChestOut) == 0x000690, "Member 'UOpenChestSurvivorSubAnimInstance::_asChestOut' has a wrong offset!");
static_assert(offsetof(UOpenChestSurvivorSubAnimInstance, _asChestWhileOpenIn) == 0x000698, "Member 'UOpenChestSurvivorSubAnimInstance::_asChestWhileOpenIn' has a wrong offset!");
static_assert(offsetof(UOpenChestSurvivorSubAnimInstance, _asChestWhileOpenLoop) == 0x0006A0, "Member 'UOpenChestSurvivorSubAnimInstance::_asChestWhileOpenLoop' has a wrong offset!");
static_assert(offsetof(UOpenChestSurvivorSubAnimInstance, _asChestWhileOpenOut) == 0x0006A8, "Member 'UOpenChestSurvivorSubAnimInstance::_asChestWhileOpenOut' has a wrong offset!");
static_assert(offsetof(UOpenChestSurvivorSubAnimInstance, _interactionPhaseEnter) == 0x0006B0, "Member 'UOpenChestSurvivorSubAnimInstance::_interactionPhaseEnter' has a wrong offset!");
static_assert(offsetof(UOpenChestSurvivorSubAnimInstance, _outToInRule) == 0x0006BC, "Member 'UOpenChestSurvivorSubAnimInstance::_outToInRule' has a wrong offset!");
static_assert(offsetof(UOpenChestSurvivorSubAnimInstance, _inSearchToLoopSearchRule) == 0x0006BD, "Member 'UOpenChestSurvivorSubAnimInstance::_inSearchToLoopSearchRule' has a wrong offset!");
static_assert(offsetof(UOpenChestSurvivorSubAnimInstance, _chestOutToBaseRule) == 0x0006BE, "Member 'UOpenChestSurvivorSubAnimInstance::_chestOutToBaseRule' has a wrong offset!");

// Class DBDAnimation.PalletAnimInstance
// 0x0030 (0x0390 - 0x0360)
class UPalletAnimInstance : public USleepingAnimInstance
{
public:
	bool                                          _isPulledDown;                                     // 0x0360(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isDestroyed;                                      // 0x0361(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isBeingPulledUp;                                  // 0x0362(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isBeingDestroyed;                                 // 0x0363(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isBeingRepaired;                                  // 0x0364(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_365[0x3];                                      // 0x0365(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _isBeingDestroyedPlayRate;                         // 0x0368(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_36C[0x4];                                      // 0x036C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAnimSequenceSelector                  _destroyPalletAnim;                                // 0x0370(0x0018)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_388[0x8];                                      // 0x0388(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnBeingDestroyedStarted(class ADBDPlayer* Player);
	void OnBeingDestroyedStopped();
	void OnBeingPulledUpStarted(class ADBDPlayer* Player);
	void OnBeingPulledUpStopped();
	void OnBeingRepairedStarted(class ADBDPlayer* Player);
	void OnBeingRepairedStopped();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalletAnimInstance">();
	}
	static class UPalletAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalletAnimInstance>();
	}
};
static_assert(alignof(UPalletAnimInstance) == 0x000010, "Wrong alignment on UPalletAnimInstance");
static_assert(sizeof(UPalletAnimInstance) == 0x000390, "Wrong size on UPalletAnimInstance");
static_assert(offsetof(UPalletAnimInstance, _isPulledDown) == 0x000360, "Member 'UPalletAnimInstance::_isPulledDown' has a wrong offset!");
static_assert(offsetof(UPalletAnimInstance, _isDestroyed) == 0x000361, "Member 'UPalletAnimInstance::_isDestroyed' has a wrong offset!");
static_assert(offsetof(UPalletAnimInstance, _isBeingPulledUp) == 0x000362, "Member 'UPalletAnimInstance::_isBeingPulledUp' has a wrong offset!");
static_assert(offsetof(UPalletAnimInstance, _isBeingDestroyed) == 0x000363, "Member 'UPalletAnimInstance::_isBeingDestroyed' has a wrong offset!");
static_assert(offsetof(UPalletAnimInstance, _isBeingRepaired) == 0x000364, "Member 'UPalletAnimInstance::_isBeingRepaired' has a wrong offset!");
static_assert(offsetof(UPalletAnimInstance, _isBeingDestroyedPlayRate) == 0x000368, "Member 'UPalletAnimInstance::_isBeingDestroyedPlayRate' has a wrong offset!");
static_assert(offsetof(UPalletAnimInstance, _destroyPalletAnim) == 0x000370, "Member 'UPalletAnimInstance::_destroyPalletAnim' has a wrong offset!");

// Class DBDAnimation.PlayerAnimationLayerManager
// 0x0050 (0x01C0 - 0x0170)
class UPlayerAnimationLayerManager final : public UCharacterAnimationLayerManager
{
public:
	TSet<class UAnimCollection*>                  _animLayerGroupToAnimCollectionSet;                // 0x0170(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerAnimationLayerManager">();
	}
	static class UPlayerAnimationLayerManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerAnimationLayerManager>();
	}
};
static_assert(alignof(UPlayerAnimationLayerManager) == 0x000008, "Wrong alignment on UPlayerAnimationLayerManager");
static_assert(sizeof(UPlayerAnimationLayerManager) == 0x0001C0, "Wrong size on UPlayerAnimationLayerManager");
static_assert(offsetof(UPlayerAnimationLayerManager, _animLayerGroupToAnimCollectionSet) == 0x000170, "Member 'UPlayerAnimationLayerManager::_animLayerGroupToAnimCollectionSet' has a wrong offset!");

// Class DBDAnimation.QuadrupedIKCRSubAnimInstance
// 0x0920 (0x0CA0 - 0x0380)
class UQuadrupedIKCRSubAnimInstance final : public UDBDBaseAnimInstance
{
public:
	bool                                          _enableIK;                                         // 0x0380(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _adjustCamera;                                     // 0x0381(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _firstPersonView;                                  // 0x0382(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_383[0x5];                                      // 0x0383(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                _meshScale;                                        // 0x0388(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETraceTypeQuery                               _traceTypeQuery;                                   // 0x03A0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _traceComplex;                                     // 0x03A1(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _ignoreTouches;                                    // 0x03A2(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A3[0x1];                                      // 0x03A3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   _noGroundTag;                                      // 0x03A4(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _frontFeetLineTraceStartOffset;                    // 0x03B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _frontFeetLineTraceEndOffset;                      // 0x03B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _backFeetLineTraceStartOffset;                     // 0x03B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _backFeetLineTraceEndOffset;                       // 0x03BC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _footIkSpeed;                                      // 0x03C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _pelvisIkSpeed;                                    // 0x03C4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _pelvisIkSpeedFPV;                                 // 0x03C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _leftFrontFootBoneName;                            // 0x03CC(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _rightFrontFootBoneName;                           // 0x03D8(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _leftBackFootBoneName;                             // 0x03E4(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _rightBackFootBoneName;                            // 0x03F0(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _charSocketName;                                   // 0x03FC(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _pelvisSocketName;                                 // 0x0408(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _cameraSocketName;                                 // 0x0414(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _leftFrontFootSocketName;                          // 0x0420(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _rightFrontFootSocketName;                         // 0x042C(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _leftBackFootSocketName;                           // 0x0438(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _rightBackFootSocketName;                          // 0x0444(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _leftFrontFootPoleSocketName;                      // 0x0450(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _leftFrontFootPole2SocketName;                     // 0x045C(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _rightFrontFootPoleSocketName;                     // 0x0468(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _rightFrontFootPole2SocketName;                    // 0x0474(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _leftBackFootPoleSocketName;                       // 0x0480(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _leftBackFootPole2SocketName;                      // 0x048C(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _rightBackFootPoleSocketName;                      // 0x0498(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _rightBackFootPole2SocketName;                     // 0x04A4(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _pelvisRotationMinOffset;                          // 0x04B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _pelvisRotationMaxOffset;                          // 0x04B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _pelvisPositionOffsetMin;                          // 0x04B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _pelvisPositionOffsetMax;                          // 0x04BC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _pelvisPositionOffsetMinFPV;                       // 0x04C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _pelvisPositionOffsetMaxFPV;                       // 0x04C4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _minDistanceFromCapsuleFrontFeetIdle;              // 0x04C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _maxDistanceFromCapsuleFrontFeetIdle;              // 0x04CC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _minDistanceFromCapsuleBackFeetIdle;               // 0x04D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _maxDistanceFromCapsuleBackFeetIdle;               // 0x04D4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _minDistanceFromCapsuleFrontFeetMoving;            // 0x04D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _maxDistanceFromCapsuleFrontFeetMoving;            // 0x04DC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _minDistanceFromCapsuleBackFeetMoving;             // 0x04E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _maxDistanceFromCapsuleBackFeetMoving;             // 0x04E4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FName>                           _leftFrontLimbChain;                               // 0x04E8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         _leftFrontFootMaxExtensionPercentage;              // 0x04F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4FC[0x4];                                      // 0x04FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           _rightFrontLimbChain;                              // 0x0500(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         _rightFrontFootMaxExtensionPercentage;             // 0x0510(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_514[0x4];                                      // 0x0514(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           _leftBackLimbChain;                                // 0x0518(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         _leftBackFootMaxExtensionPercentage;               // 0x0528(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_52C[0x4];                                      // 0x052C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           _rightBackLimbChain;                               // 0x0530(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         _rightBackFootMaxExtensionPercentage;              // 0x0540(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _leftFrontFootUngroundedTolerance;                 // 0x0544(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _rightFrontFootUngroundedTolerance;                // 0x0548(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _leftBackFootUngroundedTolerance;                  // 0x054C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _rightBackFootUngroundedTolerance;                 // 0x0550(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _frontFeetUpDisplacement;                          // 0x0554(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _frontFeetDownDisplacement;                        // 0x0558(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _backFeetUpDisplacement;                           // 0x055C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _backFeetDownDisplacement;                         // 0x0560(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_564[0x4];                                      // 0x0564(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                _pelvisPositionOffset;                             // 0x0568(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               _worldPitch;                                       // 0x0580(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FRotator                               _cameraRotationOffset;                             // 0x0598(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FVector                                _cameraPositionOffset;                             // 0x05B0(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                _leftFrontFootLocation;                            // 0x05C8(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                _leftFrontFootPole1Location;                       // 0x05E0(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                _leftFrontFootPole2Location;                       // 0x05F8(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                _leftBackFootPole1Location;                        // 0x0610(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                _leftBackFootPole2Location;                        // 0x0628(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                _rightFrontFootLocation;                           // 0x0640(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                _rightFrontFootPole1Location;                      // 0x0658(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                _rightFrontFootPole2Location;                      // 0x0670(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                _rightBackFootPole1Location;                       // 0x0688(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                _rightBackFootPole2Location;                       // 0x06A0(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                _leftBackFootLocation;                             // 0x06B8(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                _rightBackFootLocation;                            // 0x06D0(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6E8[0x8];                                      // 0x06E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             _leftFrontFootTransform;                           // 0x06F0(0x0060)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTransform                             _rightFrontFootTransform;                          // 0x0750(0x0060)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTransform                             _leftBackFootTransform;                            // 0x07B0(0x0060)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTransform                             _rightBackFootTransform;                           // 0x0810(0x0060)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               _leftFrontFootRotation;                            // 0x0870(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FRotator                               _rightFrontFootRotation;                           // 0x0888(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FRotator                               _leftBackFootRotation;                             // 0x08A0(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FRotator                               _rightBackFootRotation;                            // 0x08B8(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 _skeletalMeshComponent;                            // 0x08D0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWorld*                                 _world;                                            // 0x08D8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8E0[0x3C0];                                    // 0x08E0(0x03C0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"QuadrupedIKCRSubAnimInstance">();
	}
	static class UQuadrupedIKCRSubAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UQuadrupedIKCRSubAnimInstance>();
	}
};
static_assert(alignof(UQuadrupedIKCRSubAnimInstance) == 0x000010, "Wrong alignment on UQuadrupedIKCRSubAnimInstance");
static_assert(sizeof(UQuadrupedIKCRSubAnimInstance) == 0x000CA0, "Wrong size on UQuadrupedIKCRSubAnimInstance");
static_assert(offsetof(UQuadrupedIKCRSubAnimInstance, _enableIK) == 0x000380, "Member 'UQuadrupedIKCRSubAnimInstance::_enableIK' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKCRSubAnimInstance, _adjustCamera) == 0x000381, "Member 'UQuadrupedIKCRSubAnimInstance::_adjustCamera' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKCRSubAnimInstance, _firstPersonView) == 0x000382, "Member 'UQuadrupedIKCRSubAnimInstance::_firstPersonView' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKCRSubAnimInstance, _meshScale) == 0x000388, "Member 'UQuadrupedIKCRSubAnimInstance::_meshScale' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKCRSubAnimInstance, _traceTypeQuery) == 0x0003A0, "Member 'UQuadrupedIKCRSubAnimInstance::_traceTypeQuery' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKCRSubAnimInstance, _traceComplex) == 0x0003A1, "Member 'UQuadrupedIKCRSubAnimInstance::_traceComplex' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKCRSubAnimInstance, _ignoreTouches) == 0x0003A2, "Member 'UQuadrupedIKCRSubAnimInstance::_ignoreTouches' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKCRSubAnimInstance, _noGroundTag) == 0x0003A4, "Member 'UQuadrupedIKCRSubAnimInstance::_noGroundTag' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKCRSubAnimInstance, _frontFeetLineTraceStartOffset) == 0x0003B0, "Member 'UQuadrupedIKCRSubAnimInstance::_frontFeetLineTraceStartOffset' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKCRSubAnimInstance, _frontFeetLineTraceEndOffset) == 0x0003B4, "Member 'UQuadrupedIKCRSubAnimInstance::_frontFeetLineTraceEndOffset' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKCRSubAnimInstance, _backFeetLineTraceStartOffset) == 0x0003B8, "Member 'UQuadrupedIKCRSubAnimInstance::_backFeetLineTraceStartOffset' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKCRSubAnimInstance, _backFeetLineTraceEndOffset) == 0x0003BC, "Member 'UQuadrupedIKCRSubAnimInstance::_backFeetLineTraceEndOffset' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKCRSubAnimInstance, _footIkSpeed) == 0x0003C0, "Member 'UQuadrupedIKCRSubAnimInstance::_footIkSpeed' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKCRSubAnimInstance, _pelvisIkSpeed) == 0x0003C4, "Member 'UQuadrupedIKCRSubAnimInstance::_pelvisIkSpeed' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKCRSubAnimInstance, _pelvisIkSpeedFPV) == 0x0003C8, "Member 'UQuadrupedIKCRSubAnimInstance::_pelvisIkSpeedFPV' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKCRSubAnimInstance, _leftFrontFootBoneName) == 0x0003CC, "Member 'UQuadrupedIKCRSubAnimInstance::_leftFrontFootBoneName' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKCRSubAnimInstance, _rightFrontFootBoneName) == 0x0003D8, "Member 'UQuadrupedIKCRSubAnimInstance::_rightFrontFootBoneName' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKCRSubAnimInstance, _leftBackFootBoneName) == 0x0003E4, "Member 'UQuadrupedIKCRSubAnimInstance::_leftBackFootBoneName' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKCRSubAnimInstance, _rightBackFootBoneName) == 0x0003F0, "Member 'UQuadrupedIKCRSubAnimInstance::_rightBackFootBoneName' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKCRSubAnimInstance, _charSocketName) == 0x0003FC, "Member 'UQuadrupedIKCRSubAnimInstance::_charSocketName' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKCRSubAnimInstance, _pelvisSocketName) == 0x000408, "Member 'UQuadrupedIKCRSubAnimInstance::_pelvisSocketName' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKCRSubAnimInstance, _cameraSocketName) == 0x000414, "Member 'UQuadrupedIKCRSubAnimInstance::_cameraSocketName' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKCRSubAnimInstance, _leftFrontFootSocketName) == 0x000420, "Member 'UQuadrupedIKCRSubAnimInstance::_leftFrontFootSocketName' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKCRSubAnimInstance, _rightFrontFootSocketName) == 0x00042C, "Member 'UQuadrupedIKCRSubAnimInstance::_rightFrontFootSocketName' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKCRSubAnimInstance, _leftBackFootSocketName) == 0x000438, "Member 'UQuadrupedIKCRSubAnimInstance::_leftBackFootSocketName' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKCRSubAnimInstance, _rightBackFootSocketName) == 0x000444, "Member 'UQuadrupedIKCRSubAnimInstance::_rightBackFootSocketName' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKCRSubAnimInstance, _leftFrontFootPoleSocketName) == 0x000450, "Member 'UQuadrupedIKCRSubAnimInstance::_leftFrontFootPoleSocketName' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKCRSubAnimInstance, _leftFrontFootPole2SocketName) == 0x00045C, "Member 'UQuadrupedIKCRSubAnimInstance::_leftFrontFootPole2SocketName' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKCRSubAnimInstance, _rightFrontFootPoleSocketName) == 0x000468, "Member 'UQuadrupedIKCRSubAnimInstance::_rightFrontFootPoleSocketName' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKCRSubAnimInstance, _rightFrontFootPole2SocketName) == 0x000474, "Member 'UQuadrupedIKCRSubAnimInstance::_rightFrontFootPole2SocketName' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKCRSubAnimInstance, _leftBackFootPoleSocketName) == 0x000480, "Member 'UQuadrupedIKCRSubAnimInstance::_leftBackFootPoleSocketName' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKCRSubAnimInstance, _leftBackFootPole2SocketName) == 0x00048C, "Member 'UQuadrupedIKCRSubAnimInstance::_leftBackFootPole2SocketName' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKCRSubAnimInstance, _rightBackFootPoleSocketName) == 0x000498, "Member 'UQuadrupedIKCRSubAnimInstance::_rightBackFootPoleSocketName' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKCRSubAnimInstance, _rightBackFootPole2SocketName) == 0x0004A4, "Member 'UQuadrupedIKCRSubAnimInstance::_rightBackFootPole2SocketName' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKCRSubAnimInstance, _pelvisRotationMinOffset) == 0x0004B0, "Member 'UQuadrupedIKCRSubAnimInstance::_pelvisRotationMinOffset' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKCRSubAnimInstance, _pelvisRotationMaxOffset) == 0x0004B4, "Member 'UQuadrupedIKCRSubAnimInstance::_pelvisRotationMaxOffset' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKCRSubAnimInstance, _pelvisPositionOffsetMin) == 0x0004B8, "Member 'UQuadrupedIKCRSubAnimInstance::_pelvisPositionOffsetMin' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKCRSubAnimInstance, _pelvisPositionOffsetMax) == 0x0004BC, "Member 'UQuadrupedIKCRSubAnimInstance::_pelvisPositionOffsetMax' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKCRSubAnimInstance, _pelvisPositionOffsetMinFPV) == 0x0004C0, "Member 'UQuadrupedIKCRSubAnimInstance::_pelvisPositionOffsetMinFPV' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKCRSubAnimInstance, _pelvisPositionOffsetMaxFPV) == 0x0004C4, "Member 'UQuadrupedIKCRSubAnimInstance::_pelvisPositionOffsetMaxFPV' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKCRSubAnimInstance, _minDistanceFromCapsuleFrontFeetIdle) == 0x0004C8, "Member 'UQuadrupedIKCRSubAnimInstance::_minDistanceFromCapsuleFrontFeetIdle' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKCRSubAnimInstance, _maxDistanceFromCapsuleFrontFeetIdle) == 0x0004CC, "Member 'UQuadrupedIKCRSubAnimInstance::_maxDistanceFromCapsuleFrontFeetIdle' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKCRSubAnimInstance, _minDistanceFromCapsuleBackFeetIdle) == 0x0004D0, "Member 'UQuadrupedIKCRSubAnimInstance::_minDistanceFromCapsuleBackFeetIdle' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKCRSubAnimInstance, _maxDistanceFromCapsuleBackFeetIdle) == 0x0004D4, "Member 'UQuadrupedIKCRSubAnimInstance::_maxDistanceFromCapsuleBackFeetIdle' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKCRSubAnimInstance, _minDistanceFromCapsuleFrontFeetMoving) == 0x0004D8, "Member 'UQuadrupedIKCRSubAnimInstance::_minDistanceFromCapsuleFrontFeetMoving' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKCRSubAnimInstance, _maxDistanceFromCapsuleFrontFeetMoving) == 0x0004DC, "Member 'UQuadrupedIKCRSubAnimInstance::_maxDistanceFromCapsuleFrontFeetMoving' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKCRSubAnimInstance, _minDistanceFromCapsuleBackFeetMoving) == 0x0004E0, "Member 'UQuadrupedIKCRSubAnimInstance::_minDistanceFromCapsuleBackFeetMoving' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKCRSubAnimInstance, _maxDistanceFromCapsuleBackFeetMoving) == 0x0004E4, "Member 'UQuadrupedIKCRSubAnimInstance::_maxDistanceFromCapsuleBackFeetMoving' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKCRSubAnimInstance, _leftFrontLimbChain) == 0x0004E8, "Member 'UQuadrupedIKCRSubAnimInstance::_leftFrontLimbChain' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKCRSubAnimInstance, _leftFrontFootMaxExtensionPercentage) == 0x0004F8, "Member 'UQuadrupedIKCRSubAnimInstance::_leftFrontFootMaxExtensionPercentage' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKCRSubAnimInstance, _rightFrontLimbChain) == 0x000500, "Member 'UQuadrupedIKCRSubAnimInstance::_rightFrontLimbChain' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKCRSubAnimInstance, _rightFrontFootMaxExtensionPercentage) == 0x000510, "Member 'UQuadrupedIKCRSubAnimInstance::_rightFrontFootMaxExtensionPercentage' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKCRSubAnimInstance, _leftBackLimbChain) == 0x000518, "Member 'UQuadrupedIKCRSubAnimInstance::_leftBackLimbChain' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKCRSubAnimInstance, _leftBackFootMaxExtensionPercentage) == 0x000528, "Member 'UQuadrupedIKCRSubAnimInstance::_leftBackFootMaxExtensionPercentage' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKCRSubAnimInstance, _rightBackLimbChain) == 0x000530, "Member 'UQuadrupedIKCRSubAnimInstance::_rightBackLimbChain' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKCRSubAnimInstance, _rightBackFootMaxExtensionPercentage) == 0x000540, "Member 'UQuadrupedIKCRSubAnimInstance::_rightBackFootMaxExtensionPercentage' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKCRSubAnimInstance, _leftFrontFootUngroundedTolerance) == 0x000544, "Member 'UQuadrupedIKCRSubAnimInstance::_leftFrontFootUngroundedTolerance' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKCRSubAnimInstance, _rightFrontFootUngroundedTolerance) == 0x000548, "Member 'UQuadrupedIKCRSubAnimInstance::_rightFrontFootUngroundedTolerance' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKCRSubAnimInstance, _leftBackFootUngroundedTolerance) == 0x00054C, "Member 'UQuadrupedIKCRSubAnimInstance::_leftBackFootUngroundedTolerance' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKCRSubAnimInstance, _rightBackFootUngroundedTolerance) == 0x000550, "Member 'UQuadrupedIKCRSubAnimInstance::_rightBackFootUngroundedTolerance' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKCRSubAnimInstance, _frontFeetUpDisplacement) == 0x000554, "Member 'UQuadrupedIKCRSubAnimInstance::_frontFeetUpDisplacement' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKCRSubAnimInstance, _frontFeetDownDisplacement) == 0x000558, "Member 'UQuadrupedIKCRSubAnimInstance::_frontFeetDownDisplacement' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKCRSubAnimInstance, _backFeetUpDisplacement) == 0x00055C, "Member 'UQuadrupedIKCRSubAnimInstance::_backFeetUpDisplacement' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKCRSubAnimInstance, _backFeetDownDisplacement) == 0x000560, "Member 'UQuadrupedIKCRSubAnimInstance::_backFeetDownDisplacement' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKCRSubAnimInstance, _pelvisPositionOffset) == 0x000568, "Member 'UQuadrupedIKCRSubAnimInstance::_pelvisPositionOffset' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKCRSubAnimInstance, _worldPitch) == 0x000580, "Member 'UQuadrupedIKCRSubAnimInstance::_worldPitch' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKCRSubAnimInstance, _cameraRotationOffset) == 0x000598, "Member 'UQuadrupedIKCRSubAnimInstance::_cameraRotationOffset' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKCRSubAnimInstance, _cameraPositionOffset) == 0x0005B0, "Member 'UQuadrupedIKCRSubAnimInstance::_cameraPositionOffset' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKCRSubAnimInstance, _leftFrontFootLocation) == 0x0005C8, "Member 'UQuadrupedIKCRSubAnimInstance::_leftFrontFootLocation' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKCRSubAnimInstance, _leftFrontFootPole1Location) == 0x0005E0, "Member 'UQuadrupedIKCRSubAnimInstance::_leftFrontFootPole1Location' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKCRSubAnimInstance, _leftFrontFootPole2Location) == 0x0005F8, "Member 'UQuadrupedIKCRSubAnimInstance::_leftFrontFootPole2Location' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKCRSubAnimInstance, _leftBackFootPole1Location) == 0x000610, "Member 'UQuadrupedIKCRSubAnimInstance::_leftBackFootPole1Location' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKCRSubAnimInstance, _leftBackFootPole2Location) == 0x000628, "Member 'UQuadrupedIKCRSubAnimInstance::_leftBackFootPole2Location' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKCRSubAnimInstance, _rightFrontFootLocation) == 0x000640, "Member 'UQuadrupedIKCRSubAnimInstance::_rightFrontFootLocation' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKCRSubAnimInstance, _rightFrontFootPole1Location) == 0x000658, "Member 'UQuadrupedIKCRSubAnimInstance::_rightFrontFootPole1Location' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKCRSubAnimInstance, _rightFrontFootPole2Location) == 0x000670, "Member 'UQuadrupedIKCRSubAnimInstance::_rightFrontFootPole2Location' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKCRSubAnimInstance, _rightBackFootPole1Location) == 0x000688, "Member 'UQuadrupedIKCRSubAnimInstance::_rightBackFootPole1Location' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKCRSubAnimInstance, _rightBackFootPole2Location) == 0x0006A0, "Member 'UQuadrupedIKCRSubAnimInstance::_rightBackFootPole2Location' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKCRSubAnimInstance, _leftBackFootLocation) == 0x0006B8, "Member 'UQuadrupedIKCRSubAnimInstance::_leftBackFootLocation' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKCRSubAnimInstance, _rightBackFootLocation) == 0x0006D0, "Member 'UQuadrupedIKCRSubAnimInstance::_rightBackFootLocation' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKCRSubAnimInstance, _leftFrontFootTransform) == 0x0006F0, "Member 'UQuadrupedIKCRSubAnimInstance::_leftFrontFootTransform' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKCRSubAnimInstance, _rightFrontFootTransform) == 0x000750, "Member 'UQuadrupedIKCRSubAnimInstance::_rightFrontFootTransform' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKCRSubAnimInstance, _leftBackFootTransform) == 0x0007B0, "Member 'UQuadrupedIKCRSubAnimInstance::_leftBackFootTransform' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKCRSubAnimInstance, _rightBackFootTransform) == 0x000810, "Member 'UQuadrupedIKCRSubAnimInstance::_rightBackFootTransform' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKCRSubAnimInstance, _leftFrontFootRotation) == 0x000870, "Member 'UQuadrupedIKCRSubAnimInstance::_leftFrontFootRotation' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKCRSubAnimInstance, _rightFrontFootRotation) == 0x000888, "Member 'UQuadrupedIKCRSubAnimInstance::_rightFrontFootRotation' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKCRSubAnimInstance, _leftBackFootRotation) == 0x0008A0, "Member 'UQuadrupedIKCRSubAnimInstance::_leftBackFootRotation' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKCRSubAnimInstance, _rightBackFootRotation) == 0x0008B8, "Member 'UQuadrupedIKCRSubAnimInstance::_rightBackFootRotation' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKCRSubAnimInstance, _skeletalMeshComponent) == 0x0008D0, "Member 'UQuadrupedIKCRSubAnimInstance::_skeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKCRSubAnimInstance, _world) == 0x0008D8, "Member 'UQuadrupedIKCRSubAnimInstance::_world' has a wrong offset!");

// Class DBDAnimation.QuadrupedIKSubAnimInstance
// 0x0640 (0x09C0 - 0x0380)
class UQuadrupedIKSubAnimInstance final : public UDBDBaseAnimInstance
{
public:
	bool                                          _enableIK;                                         // 0x0380(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETraceTypeQuery                               _traceTypeQuery;                                   // 0x0381(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _traceComplex;                                     // 0x0382(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _ignoreTouches;                                    // 0x0383(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _noGroundTag;                                      // 0x0384(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _adjustCamera;                                     // 0x0390(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _adjustTail;                                       // 0x0391(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _firstPersonView;                                  // 0x0392(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_393[0x1];                                      // 0x0393(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _footIkSpeed;                                      // 0x0394(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _pelvisIkSpeed;                                    // 0x0398(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _pelvisIkSpeedFPV;                                 // 0x039C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _maxIKTargetDistance;                              // 0x03A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _maxBoneDistanceFromTargetMoving;                  // 0x03A4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _maxBoneDistanceFromTargetIdle;                    // 0x03A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _minDistanceFromCapsuleFrontFeetIdle;              // 0x03AC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _maxDistanceFromCapsuleFrontFeetIdle;              // 0x03B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _minDistanceFromCapsuleBackFeetIdle;               // 0x03B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _maxDistanceFromCapsuleBackFeetIdle;               // 0x03B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _minDistanceFromCapsuleFrontFeetMoving;            // 0x03BC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _maxDistanceFromCapsuleFrontFeetMoving;            // 0x03C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _minDistanceFromCapsuleBackFeetMoving;             // 0x03C4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _maxDistanceFromCapsuleBackFeetMoving;             // 0x03C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _maxIKTargetDistanceFromPose;                      // 0x03CC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _pelvisRotationMinOffset;                          // 0x03D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _pelvisRotationMaxOffset;                          // 0x03D4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _pelvisPositionOffsetMin;                          // 0x03D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _pelvisPositionOffsetMax;                          // 0x03DC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _pelvisPositionOffsetMinFPV;                       // 0x03E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _pelvisPositionOffsetMaxFPV;                       // 0x03E4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _frontFeetLineTraceStartOffset;                    // 0x03E8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _frontFeetLineTraceEndOffset;                      // 0x03EC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _backFeetLineTraceStartOffset;                     // 0x03F0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _backFeetLineTraceEndOffset;                       // 0x03F4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _frontFeetUpDisplacement;                          // 0x03F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _frontFeetDownDisplacement;                        // 0x03FC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _backFeetUpDisplacement;                           // 0x0400(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _backFeetDownDisplacement;                         // 0x0404(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _footDistance;                                     // 0x0408(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _isMovingTolerance;                                // 0x040C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _ungroundedFeetDistance;                           // 0x0410(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _pelvisSocketName;                                 // 0x0414(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _cameraSocketName;                                 // 0x0420(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _tailSocketName;                                   // 0x042C(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _leftFrontFootSocketName;                          // 0x0438(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _leftFrontFootPoleSocketName;                      // 0x0444(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _rightFrontFootSocketName;                         // 0x0450(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _rightFrontFootPoleSocketName;                     // 0x045C(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _leftBackFootSocketName;                           // 0x0468(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _rightBackFootSocketName;                          // 0x0474(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _leftFrontFootBoneName;                            // 0x0480(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _rightFrontFootBoneName;                           // 0x048C(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _leftBackFootBoneName;                             // 0x0498(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _rightBackFootBoneName;                            // 0x04A4(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _leftFrontFootRootSocketName;                      // 0x04B0(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _rightFrontFootRootSocketName;                     // 0x04BC(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _leftBackFootRootSocketName;                       // 0x04C8(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _rightBackFootRootSocketName;                      // 0x04D4(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _leftFrontFootMaxExtension;                        // 0x04E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _rightFrontFootMaxExtension;                       // 0x04E4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _leftBackFootMaxExtension;                         // 0x04E8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _rightBackFootMaxExtension;                        // 0x04EC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _leftFrontFootUngroundedTolerance;                 // 0x04F0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _rightFrontFootUngroundedTolerance;                // 0x04F4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _leftBackFootUngroundedTolerance;                  // 0x04F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _rightBackFootUngroundedTolerance;                 // 0x04FC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                _pelvisPositionOffset;                             // 0x0500(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               _worldPitch;                                       // 0x0518(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FRotator                               _cameraRotationOffset;                             // 0x0530(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FVector                                _cameraPositionOffset;                             // 0x0548(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               _tailRotationOffset;                               // 0x0560(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FVector                                _tailPositionOffset;                               // 0x0578(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                _leftFrontFootLocation;                            // 0x0590(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                _leftFrontFootPoleLocation;                        // 0x05A8(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                _leftFrontFootPoleCurrentLocation;                 // 0x05C0(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                _rightFrontFootPoleCurrentLocation;                // 0x05D8(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                _rightFrontFootLocation;                           // 0x05F0(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                _rightFrontFootPoleLocation;                       // 0x0608(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                _leftBackFootLocation;                             // 0x0620(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                _rightBackFootLocation;                            // 0x0638(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTransform                             _leftBackFootTransform;                            // 0x0650(0x0060)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTransform                             _rightBackFootTransform;                           // 0x06B0(0x0060)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               _leftFrontFootRotation;                            // 0x0710(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FRotator                               _rightFrontFootRotation;                           // 0x0728(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FRotator                               _leftBackFootRotation;                             // 0x0740(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FRotator                               _rightBackFootRotation;                            // 0x0758(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 _skeletalMeshComponent;                            // 0x0770(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWorld*                                 _world;                                            // 0x0778(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_780[0x240];                                    // 0x0780(0x0240)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"QuadrupedIKSubAnimInstance">();
	}
	static class UQuadrupedIKSubAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UQuadrupedIKSubAnimInstance>();
	}
};
static_assert(alignof(UQuadrupedIKSubAnimInstance) == 0x000010, "Wrong alignment on UQuadrupedIKSubAnimInstance");
static_assert(sizeof(UQuadrupedIKSubAnimInstance) == 0x0009C0, "Wrong size on UQuadrupedIKSubAnimInstance");
static_assert(offsetof(UQuadrupedIKSubAnimInstance, _enableIK) == 0x000380, "Member 'UQuadrupedIKSubAnimInstance::_enableIK' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKSubAnimInstance, _traceTypeQuery) == 0x000381, "Member 'UQuadrupedIKSubAnimInstance::_traceTypeQuery' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKSubAnimInstance, _traceComplex) == 0x000382, "Member 'UQuadrupedIKSubAnimInstance::_traceComplex' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKSubAnimInstance, _ignoreTouches) == 0x000383, "Member 'UQuadrupedIKSubAnimInstance::_ignoreTouches' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKSubAnimInstance, _noGroundTag) == 0x000384, "Member 'UQuadrupedIKSubAnimInstance::_noGroundTag' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKSubAnimInstance, _adjustCamera) == 0x000390, "Member 'UQuadrupedIKSubAnimInstance::_adjustCamera' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKSubAnimInstance, _adjustTail) == 0x000391, "Member 'UQuadrupedIKSubAnimInstance::_adjustTail' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKSubAnimInstance, _firstPersonView) == 0x000392, "Member 'UQuadrupedIKSubAnimInstance::_firstPersonView' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKSubAnimInstance, _footIkSpeed) == 0x000394, "Member 'UQuadrupedIKSubAnimInstance::_footIkSpeed' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKSubAnimInstance, _pelvisIkSpeed) == 0x000398, "Member 'UQuadrupedIKSubAnimInstance::_pelvisIkSpeed' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKSubAnimInstance, _pelvisIkSpeedFPV) == 0x00039C, "Member 'UQuadrupedIKSubAnimInstance::_pelvisIkSpeedFPV' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKSubAnimInstance, _maxIKTargetDistance) == 0x0003A0, "Member 'UQuadrupedIKSubAnimInstance::_maxIKTargetDistance' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKSubAnimInstance, _maxBoneDistanceFromTargetMoving) == 0x0003A4, "Member 'UQuadrupedIKSubAnimInstance::_maxBoneDistanceFromTargetMoving' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKSubAnimInstance, _maxBoneDistanceFromTargetIdle) == 0x0003A8, "Member 'UQuadrupedIKSubAnimInstance::_maxBoneDistanceFromTargetIdle' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKSubAnimInstance, _minDistanceFromCapsuleFrontFeetIdle) == 0x0003AC, "Member 'UQuadrupedIKSubAnimInstance::_minDistanceFromCapsuleFrontFeetIdle' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKSubAnimInstance, _maxDistanceFromCapsuleFrontFeetIdle) == 0x0003B0, "Member 'UQuadrupedIKSubAnimInstance::_maxDistanceFromCapsuleFrontFeetIdle' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKSubAnimInstance, _minDistanceFromCapsuleBackFeetIdle) == 0x0003B4, "Member 'UQuadrupedIKSubAnimInstance::_minDistanceFromCapsuleBackFeetIdle' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKSubAnimInstance, _maxDistanceFromCapsuleBackFeetIdle) == 0x0003B8, "Member 'UQuadrupedIKSubAnimInstance::_maxDistanceFromCapsuleBackFeetIdle' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKSubAnimInstance, _minDistanceFromCapsuleFrontFeetMoving) == 0x0003BC, "Member 'UQuadrupedIKSubAnimInstance::_minDistanceFromCapsuleFrontFeetMoving' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKSubAnimInstance, _maxDistanceFromCapsuleFrontFeetMoving) == 0x0003C0, "Member 'UQuadrupedIKSubAnimInstance::_maxDistanceFromCapsuleFrontFeetMoving' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKSubAnimInstance, _minDistanceFromCapsuleBackFeetMoving) == 0x0003C4, "Member 'UQuadrupedIKSubAnimInstance::_minDistanceFromCapsuleBackFeetMoving' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKSubAnimInstance, _maxDistanceFromCapsuleBackFeetMoving) == 0x0003C8, "Member 'UQuadrupedIKSubAnimInstance::_maxDistanceFromCapsuleBackFeetMoving' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKSubAnimInstance, _maxIKTargetDistanceFromPose) == 0x0003CC, "Member 'UQuadrupedIKSubAnimInstance::_maxIKTargetDistanceFromPose' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKSubAnimInstance, _pelvisRotationMinOffset) == 0x0003D0, "Member 'UQuadrupedIKSubAnimInstance::_pelvisRotationMinOffset' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKSubAnimInstance, _pelvisRotationMaxOffset) == 0x0003D4, "Member 'UQuadrupedIKSubAnimInstance::_pelvisRotationMaxOffset' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKSubAnimInstance, _pelvisPositionOffsetMin) == 0x0003D8, "Member 'UQuadrupedIKSubAnimInstance::_pelvisPositionOffsetMin' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKSubAnimInstance, _pelvisPositionOffsetMax) == 0x0003DC, "Member 'UQuadrupedIKSubAnimInstance::_pelvisPositionOffsetMax' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKSubAnimInstance, _pelvisPositionOffsetMinFPV) == 0x0003E0, "Member 'UQuadrupedIKSubAnimInstance::_pelvisPositionOffsetMinFPV' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKSubAnimInstance, _pelvisPositionOffsetMaxFPV) == 0x0003E4, "Member 'UQuadrupedIKSubAnimInstance::_pelvisPositionOffsetMaxFPV' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKSubAnimInstance, _frontFeetLineTraceStartOffset) == 0x0003E8, "Member 'UQuadrupedIKSubAnimInstance::_frontFeetLineTraceStartOffset' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKSubAnimInstance, _frontFeetLineTraceEndOffset) == 0x0003EC, "Member 'UQuadrupedIKSubAnimInstance::_frontFeetLineTraceEndOffset' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKSubAnimInstance, _backFeetLineTraceStartOffset) == 0x0003F0, "Member 'UQuadrupedIKSubAnimInstance::_backFeetLineTraceStartOffset' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKSubAnimInstance, _backFeetLineTraceEndOffset) == 0x0003F4, "Member 'UQuadrupedIKSubAnimInstance::_backFeetLineTraceEndOffset' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKSubAnimInstance, _frontFeetUpDisplacement) == 0x0003F8, "Member 'UQuadrupedIKSubAnimInstance::_frontFeetUpDisplacement' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKSubAnimInstance, _frontFeetDownDisplacement) == 0x0003FC, "Member 'UQuadrupedIKSubAnimInstance::_frontFeetDownDisplacement' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKSubAnimInstance, _backFeetUpDisplacement) == 0x000400, "Member 'UQuadrupedIKSubAnimInstance::_backFeetUpDisplacement' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKSubAnimInstance, _backFeetDownDisplacement) == 0x000404, "Member 'UQuadrupedIKSubAnimInstance::_backFeetDownDisplacement' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKSubAnimInstance, _footDistance) == 0x000408, "Member 'UQuadrupedIKSubAnimInstance::_footDistance' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKSubAnimInstance, _isMovingTolerance) == 0x00040C, "Member 'UQuadrupedIKSubAnimInstance::_isMovingTolerance' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKSubAnimInstance, _ungroundedFeetDistance) == 0x000410, "Member 'UQuadrupedIKSubAnimInstance::_ungroundedFeetDistance' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKSubAnimInstance, _pelvisSocketName) == 0x000414, "Member 'UQuadrupedIKSubAnimInstance::_pelvisSocketName' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKSubAnimInstance, _cameraSocketName) == 0x000420, "Member 'UQuadrupedIKSubAnimInstance::_cameraSocketName' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKSubAnimInstance, _tailSocketName) == 0x00042C, "Member 'UQuadrupedIKSubAnimInstance::_tailSocketName' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKSubAnimInstance, _leftFrontFootSocketName) == 0x000438, "Member 'UQuadrupedIKSubAnimInstance::_leftFrontFootSocketName' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKSubAnimInstance, _leftFrontFootPoleSocketName) == 0x000444, "Member 'UQuadrupedIKSubAnimInstance::_leftFrontFootPoleSocketName' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKSubAnimInstance, _rightFrontFootSocketName) == 0x000450, "Member 'UQuadrupedIKSubAnimInstance::_rightFrontFootSocketName' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKSubAnimInstance, _rightFrontFootPoleSocketName) == 0x00045C, "Member 'UQuadrupedIKSubAnimInstance::_rightFrontFootPoleSocketName' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKSubAnimInstance, _leftBackFootSocketName) == 0x000468, "Member 'UQuadrupedIKSubAnimInstance::_leftBackFootSocketName' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKSubAnimInstance, _rightBackFootSocketName) == 0x000474, "Member 'UQuadrupedIKSubAnimInstance::_rightBackFootSocketName' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKSubAnimInstance, _leftFrontFootBoneName) == 0x000480, "Member 'UQuadrupedIKSubAnimInstance::_leftFrontFootBoneName' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKSubAnimInstance, _rightFrontFootBoneName) == 0x00048C, "Member 'UQuadrupedIKSubAnimInstance::_rightFrontFootBoneName' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKSubAnimInstance, _leftBackFootBoneName) == 0x000498, "Member 'UQuadrupedIKSubAnimInstance::_leftBackFootBoneName' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKSubAnimInstance, _rightBackFootBoneName) == 0x0004A4, "Member 'UQuadrupedIKSubAnimInstance::_rightBackFootBoneName' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKSubAnimInstance, _leftFrontFootRootSocketName) == 0x0004B0, "Member 'UQuadrupedIKSubAnimInstance::_leftFrontFootRootSocketName' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKSubAnimInstance, _rightFrontFootRootSocketName) == 0x0004BC, "Member 'UQuadrupedIKSubAnimInstance::_rightFrontFootRootSocketName' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKSubAnimInstance, _leftBackFootRootSocketName) == 0x0004C8, "Member 'UQuadrupedIKSubAnimInstance::_leftBackFootRootSocketName' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKSubAnimInstance, _rightBackFootRootSocketName) == 0x0004D4, "Member 'UQuadrupedIKSubAnimInstance::_rightBackFootRootSocketName' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKSubAnimInstance, _leftFrontFootMaxExtension) == 0x0004E0, "Member 'UQuadrupedIKSubAnimInstance::_leftFrontFootMaxExtension' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKSubAnimInstance, _rightFrontFootMaxExtension) == 0x0004E4, "Member 'UQuadrupedIKSubAnimInstance::_rightFrontFootMaxExtension' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKSubAnimInstance, _leftBackFootMaxExtension) == 0x0004E8, "Member 'UQuadrupedIKSubAnimInstance::_leftBackFootMaxExtension' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKSubAnimInstance, _rightBackFootMaxExtension) == 0x0004EC, "Member 'UQuadrupedIKSubAnimInstance::_rightBackFootMaxExtension' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKSubAnimInstance, _leftFrontFootUngroundedTolerance) == 0x0004F0, "Member 'UQuadrupedIKSubAnimInstance::_leftFrontFootUngroundedTolerance' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKSubAnimInstance, _rightFrontFootUngroundedTolerance) == 0x0004F4, "Member 'UQuadrupedIKSubAnimInstance::_rightFrontFootUngroundedTolerance' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKSubAnimInstance, _leftBackFootUngroundedTolerance) == 0x0004F8, "Member 'UQuadrupedIKSubAnimInstance::_leftBackFootUngroundedTolerance' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKSubAnimInstance, _rightBackFootUngroundedTolerance) == 0x0004FC, "Member 'UQuadrupedIKSubAnimInstance::_rightBackFootUngroundedTolerance' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKSubAnimInstance, _pelvisPositionOffset) == 0x000500, "Member 'UQuadrupedIKSubAnimInstance::_pelvisPositionOffset' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKSubAnimInstance, _worldPitch) == 0x000518, "Member 'UQuadrupedIKSubAnimInstance::_worldPitch' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKSubAnimInstance, _cameraRotationOffset) == 0x000530, "Member 'UQuadrupedIKSubAnimInstance::_cameraRotationOffset' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKSubAnimInstance, _cameraPositionOffset) == 0x000548, "Member 'UQuadrupedIKSubAnimInstance::_cameraPositionOffset' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKSubAnimInstance, _tailRotationOffset) == 0x000560, "Member 'UQuadrupedIKSubAnimInstance::_tailRotationOffset' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKSubAnimInstance, _tailPositionOffset) == 0x000578, "Member 'UQuadrupedIKSubAnimInstance::_tailPositionOffset' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKSubAnimInstance, _leftFrontFootLocation) == 0x000590, "Member 'UQuadrupedIKSubAnimInstance::_leftFrontFootLocation' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKSubAnimInstance, _leftFrontFootPoleLocation) == 0x0005A8, "Member 'UQuadrupedIKSubAnimInstance::_leftFrontFootPoleLocation' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKSubAnimInstance, _leftFrontFootPoleCurrentLocation) == 0x0005C0, "Member 'UQuadrupedIKSubAnimInstance::_leftFrontFootPoleCurrentLocation' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKSubAnimInstance, _rightFrontFootPoleCurrentLocation) == 0x0005D8, "Member 'UQuadrupedIKSubAnimInstance::_rightFrontFootPoleCurrentLocation' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKSubAnimInstance, _rightFrontFootLocation) == 0x0005F0, "Member 'UQuadrupedIKSubAnimInstance::_rightFrontFootLocation' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKSubAnimInstance, _rightFrontFootPoleLocation) == 0x000608, "Member 'UQuadrupedIKSubAnimInstance::_rightFrontFootPoleLocation' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKSubAnimInstance, _leftBackFootLocation) == 0x000620, "Member 'UQuadrupedIKSubAnimInstance::_leftBackFootLocation' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKSubAnimInstance, _rightBackFootLocation) == 0x000638, "Member 'UQuadrupedIKSubAnimInstance::_rightBackFootLocation' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKSubAnimInstance, _leftBackFootTransform) == 0x000650, "Member 'UQuadrupedIKSubAnimInstance::_leftBackFootTransform' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKSubAnimInstance, _rightBackFootTransform) == 0x0006B0, "Member 'UQuadrupedIKSubAnimInstance::_rightBackFootTransform' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKSubAnimInstance, _leftFrontFootRotation) == 0x000710, "Member 'UQuadrupedIKSubAnimInstance::_leftFrontFootRotation' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKSubAnimInstance, _rightFrontFootRotation) == 0x000728, "Member 'UQuadrupedIKSubAnimInstance::_rightFrontFootRotation' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKSubAnimInstance, _leftBackFootRotation) == 0x000740, "Member 'UQuadrupedIKSubAnimInstance::_leftBackFootRotation' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKSubAnimInstance, _rightBackFootRotation) == 0x000758, "Member 'UQuadrupedIKSubAnimInstance::_rightBackFootRotation' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKSubAnimInstance, _skeletalMeshComponent) == 0x000770, "Member 'UQuadrupedIKSubAnimInstance::_skeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(UQuadrupedIKSubAnimInstance, _world) == 0x000778, "Member 'UQuadrupedIKSubAnimInstance::_world' has a wrong offset!");

// Class DBDAnimation.RepairGeneratorSubAnimInstance
// 0x0090 (0x03E0 - 0x0350)
class URepairGeneratorSubAnimInstance : public UAnimInstance
{
public:
	class AGenerator*                             _owningGenerator;                                  // 0x0350(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isBeingRepaired;                                  // 0x0358(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_359[0x7];                                      // 0x0359(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ACamperPlayer*                          _repairingSurvivor;                                // 0x0360(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _animSequence;                                     // 0x0368(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _interactionTag;                                   // 0x0370(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _currentAnimId;                                    // 0x037C(0x000C)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<struct FGameplayTag, class UAnimSequence*> _taggedAnimSequences;                              // 0x0388(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_3D8[0x8];                                      // 0x03D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RepairGeneratorSubAnimInstance">();
	}
	static class URepairGeneratorSubAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<URepairGeneratorSubAnimInstance>();
	}
};
static_assert(alignof(URepairGeneratorSubAnimInstance) == 0x000010, "Wrong alignment on URepairGeneratorSubAnimInstance");
static_assert(sizeof(URepairGeneratorSubAnimInstance) == 0x0003E0, "Wrong size on URepairGeneratorSubAnimInstance");
static_assert(offsetof(URepairGeneratorSubAnimInstance, _owningGenerator) == 0x000350, "Member 'URepairGeneratorSubAnimInstance::_owningGenerator' has a wrong offset!");
static_assert(offsetof(URepairGeneratorSubAnimInstance, _isBeingRepaired) == 0x000358, "Member 'URepairGeneratorSubAnimInstance::_isBeingRepaired' has a wrong offset!");
static_assert(offsetof(URepairGeneratorSubAnimInstance, _repairingSurvivor) == 0x000360, "Member 'URepairGeneratorSubAnimInstance::_repairingSurvivor' has a wrong offset!");
static_assert(offsetof(URepairGeneratorSubAnimInstance, _animSequence) == 0x000368, "Member 'URepairGeneratorSubAnimInstance::_animSequence' has a wrong offset!");
static_assert(offsetof(URepairGeneratorSubAnimInstance, _interactionTag) == 0x000370, "Member 'URepairGeneratorSubAnimInstance::_interactionTag' has a wrong offset!");
static_assert(offsetof(URepairGeneratorSubAnimInstance, _currentAnimId) == 0x00037C, "Member 'URepairGeneratorSubAnimInstance::_currentAnimId' has a wrong offset!");
static_assert(offsetof(URepairGeneratorSubAnimInstance, _taggedAnimSequences) == 0x000388, "Member 'URepairGeneratorSubAnimInstance::_taggedAnimSequences' has a wrong offset!");

// Class DBDAnimation.RepairGeneratorSurvivorSubAnimInstance
// 0x0300 (0x08E0 - 0x05E0)
class URepairGeneratorSurvivorSubAnimInstance : public UBaseSurvivorAnimInstance
{
public:
	uint8                                         Pad_5E0[0x40];                                     // 0x05E0(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _skillCheckDelayTime;                              // 0x0620(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isReturningFromFail;                              // 0x0624(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_625[0x3];                                      // 0x0625(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                _snapPosition;                                     // 0x0628(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _side;                                             // 0x0640(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _repairAnimIndex;                                  // 0x0644(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_648[0xC];                                      // 0x0648(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _isRepairingGenerator;                             // 0x0654(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _rightFootDown;                                    // 0x0655(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_656[0x2];                                      // 0x0656(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _animSequenceVariationCount;                       // 0x0658(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _hasSkillCheckFailed;                              // 0x065C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isS34P01Accumulating;                             // 0x065D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_65E[0x2];                                      // 0x065E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           _asGeneratorIdleFTRTFootTag;                       // 0x0660(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _asGeneratorIdleBreak01FTRTTag;                    // 0x066C(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _asS34P01GenFTIdleInTag;                           // 0x0678(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _asS34P01GenFTIdleLoopTag;                         // 0x0684(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _asS34P01GenFTIdleOutTag;                          // 0x0690(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _asGeneratorIdleBKRTFootTag;                       // 0x069C(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _asGeneratorIdleBreak01BKRTFootTag;                // 0x06A8(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _asS34P01GenBKIdleInTag;                           // 0x06B4(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _asS34P01GenBKIdleLoopTag;                         // 0x06C0(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _asS34P01GenBKIdleOutTag;                          // 0x06CC(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _asGeneratorIdleLTRTFootTag;                       // 0x06D8(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _asGeneratorIdleBreak01LTRTFootTag;                // 0x06E4(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _asGeneratorIdleBreak02LTRTFootTag;                // 0x06F0(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _asS34P01GenLTIdleInTag;                           // 0x06FC(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _asS34P01GenLTIdleLoopTag;                         // 0x0708(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _asS34P01GenLTIdleOutTag;                          // 0x0714(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _asGeneratorIdleRTRTFootTag;                       // 0x0720(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _asGeneratorIdleBreak01RTRTFootTag;                // 0x072C(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _asS34P01GenRTIdleInTag;                           // 0x0738(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _asS34P01GenRTIdleLoopTag;                         // 0x0744(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _asS34P01GenRTIdleOutTag;                          // 0x0750(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _asS34P01GenFTFailTag;                             // 0x075C(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _asS34P01GenBKFailTag;                             // 0x0768(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _asS34P01GenLTFailTag;                             // 0x0774(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _asS34P01GenRTFailTag;                             // 0x0780(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _asGeneratorFailFTTag;                             // 0x078C(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _asGeneratorFailBKTag;                             // 0x0798(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _asGeneratorFailLTTag;                             // 0x07A4(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _asGeneratorFailRTTag;                             // 0x07B0(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7BC[0x4];                                      // 0x07BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          _asGeneratorIdleFTRTFoot;                          // 0x07C0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _asGeneratorIdleBreak01FTRT;                       // 0x07C8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _asS34P01GenFTIdleIn;                              // 0x07D0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _asS34P01GenFTIdleLoop;                            // 0x07D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _asS34P01GenFTIdleOut;                             // 0x07E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _asGeneratorIdleBKRTFoot;                          // 0x07E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _asGeneratorIdleBreak01BKRTFoot;                   // 0x07F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _asS34P01GenBKIdleIn;                              // 0x07F8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _asS34P01GenBKIdleLoop;                            // 0x0800(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _asS34P01GenBKIdleOut;                             // 0x0808(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _asGeneratorIdleLTRTFoot;                          // 0x0810(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _asGeneratorIdleBreak01LTRTFoot;                   // 0x0818(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _asGeneratorIdleBreak02LTRTFoot;                   // 0x0820(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _asS34P01GenLTIdleIn;                              // 0x0828(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _asS34P01GenLTIdleLoop;                            // 0x0830(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _asS34P01GenLTIdleOut;                             // 0x0838(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _asGeneratorIdleRTRTFoot;                          // 0x0840(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _asGeneratorIdleBreak01RTRTFoot;                   // 0x0848(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _asS34P01GenRTIdleIn;                              // 0x0850(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _asS34P01GenRTIdleLoop;                            // 0x0858(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _asS34P01GenRTIdleOut;                             // 0x0860(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _asS34P01GenFTFail;                                // 0x0868(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _asS34P01GenBKFail;                                // 0x0870(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _asS34P01GenLTFail;                                // 0x0878(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _asS34P01GenRTFail;                                // 0x0880(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _asGeneratorFailFT;                                // 0x0888(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _asGeneratorFailBK;                                // 0x0890(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _asGeneratorFailLT;                                // 0x0898(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _asGeneratorFailRT;                                // 0x08A0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isRepairIndex0;                                   // 0x08A8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isRepairIndex1;                                   // 0x08A9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isRepairIndex2;                                   // 0x08AA(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isS34P01AccumulatingAndReturningFromFail;         // 0x08AB(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isS34P01AccumulatingAndNotReturningFromFail;      // 0x08AC(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _generatorActivationToBaseRule;                    // 0x08AD(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8AE[0x32];                                     // 0x08AE(0x0032)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void UpdatePostSkillCheckResponse();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RepairGeneratorSurvivorSubAnimInstance">();
	}
	static class URepairGeneratorSurvivorSubAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<URepairGeneratorSurvivorSubAnimInstance>();
	}
};
static_assert(alignof(URepairGeneratorSurvivorSubAnimInstance) == 0x000010, "Wrong alignment on URepairGeneratorSurvivorSubAnimInstance");
static_assert(sizeof(URepairGeneratorSurvivorSubAnimInstance) == 0x0008E0, "Wrong size on URepairGeneratorSurvivorSubAnimInstance");
static_assert(offsetof(URepairGeneratorSurvivorSubAnimInstance, _skillCheckDelayTime) == 0x000620, "Member 'URepairGeneratorSurvivorSubAnimInstance::_skillCheckDelayTime' has a wrong offset!");
static_assert(offsetof(URepairGeneratorSurvivorSubAnimInstance, _isReturningFromFail) == 0x000624, "Member 'URepairGeneratorSurvivorSubAnimInstance::_isReturningFromFail' has a wrong offset!");
static_assert(offsetof(URepairGeneratorSurvivorSubAnimInstance, _snapPosition) == 0x000628, "Member 'URepairGeneratorSurvivorSubAnimInstance::_snapPosition' has a wrong offset!");
static_assert(offsetof(URepairGeneratorSurvivorSubAnimInstance, _side) == 0x000640, "Member 'URepairGeneratorSurvivorSubAnimInstance::_side' has a wrong offset!");
static_assert(offsetof(URepairGeneratorSurvivorSubAnimInstance, _repairAnimIndex) == 0x000644, "Member 'URepairGeneratorSurvivorSubAnimInstance::_repairAnimIndex' has a wrong offset!");
static_assert(offsetof(URepairGeneratorSurvivorSubAnimInstance, _isRepairingGenerator) == 0x000654, "Member 'URepairGeneratorSurvivorSubAnimInstance::_isRepairingGenerator' has a wrong offset!");
static_assert(offsetof(URepairGeneratorSurvivorSubAnimInstance, _rightFootDown) == 0x000655, "Member 'URepairGeneratorSurvivorSubAnimInstance::_rightFootDown' has a wrong offset!");
static_assert(offsetof(URepairGeneratorSurvivorSubAnimInstance, _animSequenceVariationCount) == 0x000658, "Member 'URepairGeneratorSurvivorSubAnimInstance::_animSequenceVariationCount' has a wrong offset!");
static_assert(offsetof(URepairGeneratorSurvivorSubAnimInstance, _hasSkillCheckFailed) == 0x00065C, "Member 'URepairGeneratorSurvivorSubAnimInstance::_hasSkillCheckFailed' has a wrong offset!");
static_assert(offsetof(URepairGeneratorSurvivorSubAnimInstance, _isS34P01Accumulating) == 0x00065D, "Member 'URepairGeneratorSurvivorSubAnimInstance::_isS34P01Accumulating' has a wrong offset!");
static_assert(offsetof(URepairGeneratorSurvivorSubAnimInstance, _asGeneratorIdleFTRTFootTag) == 0x000660, "Member 'URepairGeneratorSurvivorSubAnimInstance::_asGeneratorIdleFTRTFootTag' has a wrong offset!");
static_assert(offsetof(URepairGeneratorSurvivorSubAnimInstance, _asGeneratorIdleBreak01FTRTTag) == 0x00066C, "Member 'URepairGeneratorSurvivorSubAnimInstance::_asGeneratorIdleBreak01FTRTTag' has a wrong offset!");
static_assert(offsetof(URepairGeneratorSurvivorSubAnimInstance, _asS34P01GenFTIdleInTag) == 0x000678, "Member 'URepairGeneratorSurvivorSubAnimInstance::_asS34P01GenFTIdleInTag' has a wrong offset!");
static_assert(offsetof(URepairGeneratorSurvivorSubAnimInstance, _asS34P01GenFTIdleLoopTag) == 0x000684, "Member 'URepairGeneratorSurvivorSubAnimInstance::_asS34P01GenFTIdleLoopTag' has a wrong offset!");
static_assert(offsetof(URepairGeneratorSurvivorSubAnimInstance, _asS34P01GenFTIdleOutTag) == 0x000690, "Member 'URepairGeneratorSurvivorSubAnimInstance::_asS34P01GenFTIdleOutTag' has a wrong offset!");
static_assert(offsetof(URepairGeneratorSurvivorSubAnimInstance, _asGeneratorIdleBKRTFootTag) == 0x00069C, "Member 'URepairGeneratorSurvivorSubAnimInstance::_asGeneratorIdleBKRTFootTag' has a wrong offset!");
static_assert(offsetof(URepairGeneratorSurvivorSubAnimInstance, _asGeneratorIdleBreak01BKRTFootTag) == 0x0006A8, "Member 'URepairGeneratorSurvivorSubAnimInstance::_asGeneratorIdleBreak01BKRTFootTag' has a wrong offset!");
static_assert(offsetof(URepairGeneratorSurvivorSubAnimInstance, _asS34P01GenBKIdleInTag) == 0x0006B4, "Member 'URepairGeneratorSurvivorSubAnimInstance::_asS34P01GenBKIdleInTag' has a wrong offset!");
static_assert(offsetof(URepairGeneratorSurvivorSubAnimInstance, _asS34P01GenBKIdleLoopTag) == 0x0006C0, "Member 'URepairGeneratorSurvivorSubAnimInstance::_asS34P01GenBKIdleLoopTag' has a wrong offset!");
static_assert(offsetof(URepairGeneratorSurvivorSubAnimInstance, _asS34P01GenBKIdleOutTag) == 0x0006CC, "Member 'URepairGeneratorSurvivorSubAnimInstance::_asS34P01GenBKIdleOutTag' has a wrong offset!");
static_assert(offsetof(URepairGeneratorSurvivorSubAnimInstance, _asGeneratorIdleLTRTFootTag) == 0x0006D8, "Member 'URepairGeneratorSurvivorSubAnimInstance::_asGeneratorIdleLTRTFootTag' has a wrong offset!");
static_assert(offsetof(URepairGeneratorSurvivorSubAnimInstance, _asGeneratorIdleBreak01LTRTFootTag) == 0x0006E4, "Member 'URepairGeneratorSurvivorSubAnimInstance::_asGeneratorIdleBreak01LTRTFootTag' has a wrong offset!");
static_assert(offsetof(URepairGeneratorSurvivorSubAnimInstance, _asGeneratorIdleBreak02LTRTFootTag) == 0x0006F0, "Member 'URepairGeneratorSurvivorSubAnimInstance::_asGeneratorIdleBreak02LTRTFootTag' has a wrong offset!");
static_assert(offsetof(URepairGeneratorSurvivorSubAnimInstance, _asS34P01GenLTIdleInTag) == 0x0006FC, "Member 'URepairGeneratorSurvivorSubAnimInstance::_asS34P01GenLTIdleInTag' has a wrong offset!");
static_assert(offsetof(URepairGeneratorSurvivorSubAnimInstance, _asS34P01GenLTIdleLoopTag) == 0x000708, "Member 'URepairGeneratorSurvivorSubAnimInstance::_asS34P01GenLTIdleLoopTag' has a wrong offset!");
static_assert(offsetof(URepairGeneratorSurvivorSubAnimInstance, _asS34P01GenLTIdleOutTag) == 0x000714, "Member 'URepairGeneratorSurvivorSubAnimInstance::_asS34P01GenLTIdleOutTag' has a wrong offset!");
static_assert(offsetof(URepairGeneratorSurvivorSubAnimInstance, _asGeneratorIdleRTRTFootTag) == 0x000720, "Member 'URepairGeneratorSurvivorSubAnimInstance::_asGeneratorIdleRTRTFootTag' has a wrong offset!");
static_assert(offsetof(URepairGeneratorSurvivorSubAnimInstance, _asGeneratorIdleBreak01RTRTFootTag) == 0x00072C, "Member 'URepairGeneratorSurvivorSubAnimInstance::_asGeneratorIdleBreak01RTRTFootTag' has a wrong offset!");
static_assert(offsetof(URepairGeneratorSurvivorSubAnimInstance, _asS34P01GenRTIdleInTag) == 0x000738, "Member 'URepairGeneratorSurvivorSubAnimInstance::_asS34P01GenRTIdleInTag' has a wrong offset!");
static_assert(offsetof(URepairGeneratorSurvivorSubAnimInstance, _asS34P01GenRTIdleLoopTag) == 0x000744, "Member 'URepairGeneratorSurvivorSubAnimInstance::_asS34P01GenRTIdleLoopTag' has a wrong offset!");
static_assert(offsetof(URepairGeneratorSurvivorSubAnimInstance, _asS34P01GenRTIdleOutTag) == 0x000750, "Member 'URepairGeneratorSurvivorSubAnimInstance::_asS34P01GenRTIdleOutTag' has a wrong offset!");
static_assert(offsetof(URepairGeneratorSurvivorSubAnimInstance, _asS34P01GenFTFailTag) == 0x00075C, "Member 'URepairGeneratorSurvivorSubAnimInstance::_asS34P01GenFTFailTag' has a wrong offset!");
static_assert(offsetof(URepairGeneratorSurvivorSubAnimInstance, _asS34P01GenBKFailTag) == 0x000768, "Member 'URepairGeneratorSurvivorSubAnimInstance::_asS34P01GenBKFailTag' has a wrong offset!");
static_assert(offsetof(URepairGeneratorSurvivorSubAnimInstance, _asS34P01GenLTFailTag) == 0x000774, "Member 'URepairGeneratorSurvivorSubAnimInstance::_asS34P01GenLTFailTag' has a wrong offset!");
static_assert(offsetof(URepairGeneratorSurvivorSubAnimInstance, _asS34P01GenRTFailTag) == 0x000780, "Member 'URepairGeneratorSurvivorSubAnimInstance::_asS34P01GenRTFailTag' has a wrong offset!");
static_assert(offsetof(URepairGeneratorSurvivorSubAnimInstance, _asGeneratorFailFTTag) == 0x00078C, "Member 'URepairGeneratorSurvivorSubAnimInstance::_asGeneratorFailFTTag' has a wrong offset!");
static_assert(offsetof(URepairGeneratorSurvivorSubAnimInstance, _asGeneratorFailBKTag) == 0x000798, "Member 'URepairGeneratorSurvivorSubAnimInstance::_asGeneratorFailBKTag' has a wrong offset!");
static_assert(offsetof(URepairGeneratorSurvivorSubAnimInstance, _asGeneratorFailLTTag) == 0x0007A4, "Member 'URepairGeneratorSurvivorSubAnimInstance::_asGeneratorFailLTTag' has a wrong offset!");
static_assert(offsetof(URepairGeneratorSurvivorSubAnimInstance, _asGeneratorFailRTTag) == 0x0007B0, "Member 'URepairGeneratorSurvivorSubAnimInstance::_asGeneratorFailRTTag' has a wrong offset!");
static_assert(offsetof(URepairGeneratorSurvivorSubAnimInstance, _asGeneratorIdleFTRTFoot) == 0x0007C0, "Member 'URepairGeneratorSurvivorSubAnimInstance::_asGeneratorIdleFTRTFoot' has a wrong offset!");
static_assert(offsetof(URepairGeneratorSurvivorSubAnimInstance, _asGeneratorIdleBreak01FTRT) == 0x0007C8, "Member 'URepairGeneratorSurvivorSubAnimInstance::_asGeneratorIdleBreak01FTRT' has a wrong offset!");
static_assert(offsetof(URepairGeneratorSurvivorSubAnimInstance, _asS34P01GenFTIdleIn) == 0x0007D0, "Member 'URepairGeneratorSurvivorSubAnimInstance::_asS34P01GenFTIdleIn' has a wrong offset!");
static_assert(offsetof(URepairGeneratorSurvivorSubAnimInstance, _asS34P01GenFTIdleLoop) == 0x0007D8, "Member 'URepairGeneratorSurvivorSubAnimInstance::_asS34P01GenFTIdleLoop' has a wrong offset!");
static_assert(offsetof(URepairGeneratorSurvivorSubAnimInstance, _asS34P01GenFTIdleOut) == 0x0007E0, "Member 'URepairGeneratorSurvivorSubAnimInstance::_asS34P01GenFTIdleOut' has a wrong offset!");
static_assert(offsetof(URepairGeneratorSurvivorSubAnimInstance, _asGeneratorIdleBKRTFoot) == 0x0007E8, "Member 'URepairGeneratorSurvivorSubAnimInstance::_asGeneratorIdleBKRTFoot' has a wrong offset!");
static_assert(offsetof(URepairGeneratorSurvivorSubAnimInstance, _asGeneratorIdleBreak01BKRTFoot) == 0x0007F0, "Member 'URepairGeneratorSurvivorSubAnimInstance::_asGeneratorIdleBreak01BKRTFoot' has a wrong offset!");
static_assert(offsetof(URepairGeneratorSurvivorSubAnimInstance, _asS34P01GenBKIdleIn) == 0x0007F8, "Member 'URepairGeneratorSurvivorSubAnimInstance::_asS34P01GenBKIdleIn' has a wrong offset!");
static_assert(offsetof(URepairGeneratorSurvivorSubAnimInstance, _asS34P01GenBKIdleLoop) == 0x000800, "Member 'URepairGeneratorSurvivorSubAnimInstance::_asS34P01GenBKIdleLoop' has a wrong offset!");
static_assert(offsetof(URepairGeneratorSurvivorSubAnimInstance, _asS34P01GenBKIdleOut) == 0x000808, "Member 'URepairGeneratorSurvivorSubAnimInstance::_asS34P01GenBKIdleOut' has a wrong offset!");
static_assert(offsetof(URepairGeneratorSurvivorSubAnimInstance, _asGeneratorIdleLTRTFoot) == 0x000810, "Member 'URepairGeneratorSurvivorSubAnimInstance::_asGeneratorIdleLTRTFoot' has a wrong offset!");
static_assert(offsetof(URepairGeneratorSurvivorSubAnimInstance, _asGeneratorIdleBreak01LTRTFoot) == 0x000818, "Member 'URepairGeneratorSurvivorSubAnimInstance::_asGeneratorIdleBreak01LTRTFoot' has a wrong offset!");
static_assert(offsetof(URepairGeneratorSurvivorSubAnimInstance, _asGeneratorIdleBreak02LTRTFoot) == 0x000820, "Member 'URepairGeneratorSurvivorSubAnimInstance::_asGeneratorIdleBreak02LTRTFoot' has a wrong offset!");
static_assert(offsetof(URepairGeneratorSurvivorSubAnimInstance, _asS34P01GenLTIdleIn) == 0x000828, "Member 'URepairGeneratorSurvivorSubAnimInstance::_asS34P01GenLTIdleIn' has a wrong offset!");
static_assert(offsetof(URepairGeneratorSurvivorSubAnimInstance, _asS34P01GenLTIdleLoop) == 0x000830, "Member 'URepairGeneratorSurvivorSubAnimInstance::_asS34P01GenLTIdleLoop' has a wrong offset!");
static_assert(offsetof(URepairGeneratorSurvivorSubAnimInstance, _asS34P01GenLTIdleOut) == 0x000838, "Member 'URepairGeneratorSurvivorSubAnimInstance::_asS34P01GenLTIdleOut' has a wrong offset!");
static_assert(offsetof(URepairGeneratorSurvivorSubAnimInstance, _asGeneratorIdleRTRTFoot) == 0x000840, "Member 'URepairGeneratorSurvivorSubAnimInstance::_asGeneratorIdleRTRTFoot' has a wrong offset!");
static_assert(offsetof(URepairGeneratorSurvivorSubAnimInstance, _asGeneratorIdleBreak01RTRTFoot) == 0x000848, "Member 'URepairGeneratorSurvivorSubAnimInstance::_asGeneratorIdleBreak01RTRTFoot' has a wrong offset!");
static_assert(offsetof(URepairGeneratorSurvivorSubAnimInstance, _asS34P01GenRTIdleIn) == 0x000850, "Member 'URepairGeneratorSurvivorSubAnimInstance::_asS34P01GenRTIdleIn' has a wrong offset!");
static_assert(offsetof(URepairGeneratorSurvivorSubAnimInstance, _asS34P01GenRTIdleLoop) == 0x000858, "Member 'URepairGeneratorSurvivorSubAnimInstance::_asS34P01GenRTIdleLoop' has a wrong offset!");
static_assert(offsetof(URepairGeneratorSurvivorSubAnimInstance, _asS34P01GenRTIdleOut) == 0x000860, "Member 'URepairGeneratorSurvivorSubAnimInstance::_asS34P01GenRTIdleOut' has a wrong offset!");
static_assert(offsetof(URepairGeneratorSurvivorSubAnimInstance, _asS34P01GenFTFail) == 0x000868, "Member 'URepairGeneratorSurvivorSubAnimInstance::_asS34P01GenFTFail' has a wrong offset!");
static_assert(offsetof(URepairGeneratorSurvivorSubAnimInstance, _asS34P01GenBKFail) == 0x000870, "Member 'URepairGeneratorSurvivorSubAnimInstance::_asS34P01GenBKFail' has a wrong offset!");
static_assert(offsetof(URepairGeneratorSurvivorSubAnimInstance, _asS34P01GenLTFail) == 0x000878, "Member 'URepairGeneratorSurvivorSubAnimInstance::_asS34P01GenLTFail' has a wrong offset!");
static_assert(offsetof(URepairGeneratorSurvivorSubAnimInstance, _asS34P01GenRTFail) == 0x000880, "Member 'URepairGeneratorSurvivorSubAnimInstance::_asS34P01GenRTFail' has a wrong offset!");
static_assert(offsetof(URepairGeneratorSurvivorSubAnimInstance, _asGeneratorFailFT) == 0x000888, "Member 'URepairGeneratorSurvivorSubAnimInstance::_asGeneratorFailFT' has a wrong offset!");
static_assert(offsetof(URepairGeneratorSurvivorSubAnimInstance, _asGeneratorFailBK) == 0x000890, "Member 'URepairGeneratorSurvivorSubAnimInstance::_asGeneratorFailBK' has a wrong offset!");
static_assert(offsetof(URepairGeneratorSurvivorSubAnimInstance, _asGeneratorFailLT) == 0x000898, "Member 'URepairGeneratorSurvivorSubAnimInstance::_asGeneratorFailLT' has a wrong offset!");
static_assert(offsetof(URepairGeneratorSurvivorSubAnimInstance, _asGeneratorFailRT) == 0x0008A0, "Member 'URepairGeneratorSurvivorSubAnimInstance::_asGeneratorFailRT' has a wrong offset!");
static_assert(offsetof(URepairGeneratorSurvivorSubAnimInstance, _isRepairIndex0) == 0x0008A8, "Member 'URepairGeneratorSurvivorSubAnimInstance::_isRepairIndex0' has a wrong offset!");
static_assert(offsetof(URepairGeneratorSurvivorSubAnimInstance, _isRepairIndex1) == 0x0008A9, "Member 'URepairGeneratorSurvivorSubAnimInstance::_isRepairIndex1' has a wrong offset!");
static_assert(offsetof(URepairGeneratorSurvivorSubAnimInstance, _isRepairIndex2) == 0x0008AA, "Member 'URepairGeneratorSurvivorSubAnimInstance::_isRepairIndex2' has a wrong offset!");
static_assert(offsetof(URepairGeneratorSurvivorSubAnimInstance, _isS34P01AccumulatingAndReturningFromFail) == 0x0008AB, "Member 'URepairGeneratorSurvivorSubAnimInstance::_isS34P01AccumulatingAndReturningFromFail' has a wrong offset!");
static_assert(offsetof(URepairGeneratorSurvivorSubAnimInstance, _isS34P01AccumulatingAndNotReturningFromFail) == 0x0008AC, "Member 'URepairGeneratorSurvivorSubAnimInstance::_isS34P01AccumulatingAndNotReturningFromFail' has a wrong offset!");
static_assert(offsetof(URepairGeneratorSurvivorSubAnimInstance, _generatorActivationToBaseRule) == 0x0008AD, "Member 'URepairGeneratorSurvivorSubAnimInstance::_generatorActivationToBaseRule' has a wrong offset!");

// Class DBDAnimation.ScreamSurvivorSubAnimInstance
// 0x0020 (0x0600 - 0x05E0)
class UScreamSurvivorSubAnimInstance : public UBaseSurvivorAnimInstance
{
public:
	bool                                          _isScream;                                         // 0x05E0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _idle;                                             // 0x05E1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5E2[0x2];                                      // 0x05E2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           _asScreamTag;                                      // 0x05E4(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _asScream;                                         // 0x05F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _screamTrigger;                                    // 0x05F8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5F9[0x7];                                      // 0x05F9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ResetScreamTrigger();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScreamSurvivorSubAnimInstance">();
	}
	static class UScreamSurvivorSubAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScreamSurvivorSubAnimInstance>();
	}
};
static_assert(alignof(UScreamSurvivorSubAnimInstance) == 0x000010, "Wrong alignment on UScreamSurvivorSubAnimInstance");
static_assert(sizeof(UScreamSurvivorSubAnimInstance) == 0x000600, "Wrong size on UScreamSurvivorSubAnimInstance");
static_assert(offsetof(UScreamSurvivorSubAnimInstance, _isScream) == 0x0005E0, "Member 'UScreamSurvivorSubAnimInstance::_isScream' has a wrong offset!");
static_assert(offsetof(UScreamSurvivorSubAnimInstance, _idle) == 0x0005E1, "Member 'UScreamSurvivorSubAnimInstance::_idle' has a wrong offset!");
static_assert(offsetof(UScreamSurvivorSubAnimInstance, _asScreamTag) == 0x0005E4, "Member 'UScreamSurvivorSubAnimInstance::_asScreamTag' has a wrong offset!");
static_assert(offsetof(UScreamSurvivorSubAnimInstance, _asScream) == 0x0005F0, "Member 'UScreamSurvivorSubAnimInstance::_asScream' has a wrong offset!");
static_assert(offsetof(UScreamSurvivorSubAnimInstance, _screamTrigger) == 0x0005F8, "Member 'UScreamSurvivorSubAnimInstance::_screamTrigger' has a wrong offset!");

// Class DBDAnimation.ShowItemAnimNotify
// 0x0000 (0x0040 - 0x0040)
class UShowItemAnimNotify final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShowItemAnimNotify">();
	}
	static class UShowItemAnimNotify* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShowItemAnimNotify>();
	}
};
static_assert(alignof(UShowItemAnimNotify) == 0x000008, "Wrong alignment on UShowItemAnimNotify");
static_assert(sizeof(UShowItemAnimNotify) == 0x000040, "Wrong size on UShowItemAnimNotify");

// Class DBDAnimation.SkillCheckFailureTracker
// 0x0000 (0x0030 - 0x0030)
class ISkillCheckFailureTracker final : public IInterface
{
public:
	void OnSkillCheckFailed(const struct FGameplayTag& GameEventType, const struct FGameEventData& GameEventData);
	void ResetSkillCheckFailed();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SkillCheckFailureTracker">();
	}
	static class ISkillCheckFailureTracker* GetDefaultObj()
	{
		return GetDefaultObjImpl<ISkillCheckFailureTracker>();
	}
};
static_assert(alignof(ISkillCheckFailureTracker) == 0x000008, "Wrong alignment on ISkillCheckFailureTracker");
static_assert(sizeof(ISkillCheckFailureTracker) == 0x000030, "Wrong size on ISkillCheckFailureTracker");

// Class DBDAnimation.SteamPipeResetSwitchAnimInstance
// 0x0010 (0x0360 - 0x0350)
class USteamPipeResetSwitchAnimInstance final : public UAnimInstance
{
public:
	bool                                          _handleIsDown;                                     // 0x0350(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_351[0x7];                                      // 0x0351(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ASteamPipeResetSwitch*                  _resetSwitch;                                      // 0x0358(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamPipeResetSwitchAnimInstance">();
	}
	static class USteamPipeResetSwitchAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamPipeResetSwitchAnimInstance>();
	}
};
static_assert(alignof(USteamPipeResetSwitchAnimInstance) == 0x000010, "Wrong alignment on USteamPipeResetSwitchAnimInstance");
static_assert(sizeof(USteamPipeResetSwitchAnimInstance) == 0x000360, "Wrong size on USteamPipeResetSwitchAnimInstance");
static_assert(offsetof(USteamPipeResetSwitchAnimInstance, _handleIsDown) == 0x000350, "Member 'USteamPipeResetSwitchAnimInstance::_handleIsDown' has a wrong offset!");
static_assert(offsetof(USteamPipeResetSwitchAnimInstance, _resetSwitch) == 0x000358, "Member 'USteamPipeResetSwitchAnimInstance::_resetSwitch' has a wrong offset!");

// Class DBDAnimation.SteamPipeSurvivorSubAnimInstance
// 0x0020 (0x0600 - 0x05E0)
class USteamPipeSurvivorSubAnimInstance : public UBaseSurvivorAnimInstance
{
public:
	bool                                          _isIdle;                                           // 0x05E0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isMale;                                           // 0x05E1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isSteamed;                                        // 0x05E2(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5E3[0x5];                                      // 0x05E3(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          _asIdleMale;                                       // 0x05E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _asIdleFemale;                                     // 0x05F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5F8[0x8];                                      // 0x05F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamPipeSurvivorSubAnimInstance">();
	}
	static class USteamPipeSurvivorSubAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamPipeSurvivorSubAnimInstance>();
	}
};
static_assert(alignof(USteamPipeSurvivorSubAnimInstance) == 0x000010, "Wrong alignment on USteamPipeSurvivorSubAnimInstance");
static_assert(sizeof(USteamPipeSurvivorSubAnimInstance) == 0x000600, "Wrong size on USteamPipeSurvivorSubAnimInstance");
static_assert(offsetof(USteamPipeSurvivorSubAnimInstance, _isIdle) == 0x0005E0, "Member 'USteamPipeSurvivorSubAnimInstance::_isIdle' has a wrong offset!");
static_assert(offsetof(USteamPipeSurvivorSubAnimInstance, _isMale) == 0x0005E1, "Member 'USteamPipeSurvivorSubAnimInstance::_isMale' has a wrong offset!");
static_assert(offsetof(USteamPipeSurvivorSubAnimInstance, _isSteamed) == 0x0005E2, "Member 'USteamPipeSurvivorSubAnimInstance::_isSteamed' has a wrong offset!");
static_assert(offsetof(USteamPipeSurvivorSubAnimInstance, _asIdleMale) == 0x0005E8, "Member 'USteamPipeSurvivorSubAnimInstance::_asIdleMale' has a wrong offset!");
static_assert(offsetof(USteamPipeSurvivorSubAnimInstance, _asIdleFemale) == 0x0005F0, "Member 'USteamPipeSurvivorSubAnimInstance::_asIdleFemale' has a wrong offset!");

// Class DBDAnimation.SurvivorAnimInstance
// 0x0050 (0x0630 - 0x05E0)
class USurvivorAnimInstance : public UBaseSurvivorAnimInstance
{
public:
	bool                                          IsHooked;                                          // 0x05E0(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isFrightScreaming;                                // 0x05E1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsBeingCarried;                                    // 0x05E2(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsCrouched;                                        // 0x05E3(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EGuidedState                                  GuidedAction;                                      // 0x05E4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsCrawling;                                        // 0x05E5(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsDead;                                            // 0x05E6(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5E7[0x1];                                      // 0x05E7(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxSpeed;                                          // 0x05E8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsInsideCloset;                                    // 0x05EC(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsBeingHealed;                                     // 0x05ED(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsUsingAimItem;                                    // 0x05EE(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsHoldingAimItem;                                  // 0x05EF(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DropStaggerTimeLeft;                               // 0x05F0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsInteracting;                                     // 0x05F4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          Injured;                                           // 0x05F5(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EInteractionAnimation                         InteractionType;                                   // 0x05F6(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsHoldingHandleItem;                               // 0x05F7(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsHoldingSmallItem;                                // 0x05F8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsHoldingFirecracker;                              // 0x05F9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsHoldingFlashbang;                                // 0x05FA(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsHoldingVaccine;                                  // 0x05FB(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsHoldingLamentConfiguration;                      // 0x05FC(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsHoldingFragileObject;                            // 0x05FD(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsHoldingSprayObject;                              // 0x05FE(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsHoldingVHS;                                      // 0x05FF(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsHoldingWormholeFatherKeyCard;                    // 0x0600(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsHoldingLantern;                                  // 0x0601(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsArmOverrideDisabled;                             // 0x0602(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          InAir;                                             // 0x0603(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _walkAnimSpeed;                                    // 0x0604(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Pitch;                                             // 0x0608(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Yaw;                                               // 0x060C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          Idle;                                              // 0x0610(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          HasAnyMontagePlaying;                              // 0x0611(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isMale;                                           // 0x0612(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_613[0x1D];                                     // 0x0613(0x001D)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SurvivorAnimInstance">();
	}
	static class USurvivorAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USurvivorAnimInstance>();
	}
};
static_assert(alignof(USurvivorAnimInstance) == 0x000010, "Wrong alignment on USurvivorAnimInstance");
static_assert(sizeof(USurvivorAnimInstance) == 0x000630, "Wrong size on USurvivorAnimInstance");
static_assert(offsetof(USurvivorAnimInstance, IsHooked) == 0x0005E0, "Member 'USurvivorAnimInstance::IsHooked' has a wrong offset!");
static_assert(offsetof(USurvivorAnimInstance, _isFrightScreaming) == 0x0005E1, "Member 'USurvivorAnimInstance::_isFrightScreaming' has a wrong offset!");
static_assert(offsetof(USurvivorAnimInstance, IsBeingCarried) == 0x0005E2, "Member 'USurvivorAnimInstance::IsBeingCarried' has a wrong offset!");
static_assert(offsetof(USurvivorAnimInstance, IsCrouched) == 0x0005E3, "Member 'USurvivorAnimInstance::IsCrouched' has a wrong offset!");
static_assert(offsetof(USurvivorAnimInstance, GuidedAction) == 0x0005E4, "Member 'USurvivorAnimInstance::GuidedAction' has a wrong offset!");
static_assert(offsetof(USurvivorAnimInstance, IsCrawling) == 0x0005E5, "Member 'USurvivorAnimInstance::IsCrawling' has a wrong offset!");
static_assert(offsetof(USurvivorAnimInstance, IsDead) == 0x0005E6, "Member 'USurvivorAnimInstance::IsDead' has a wrong offset!");
static_assert(offsetof(USurvivorAnimInstance, MaxSpeed) == 0x0005E8, "Member 'USurvivorAnimInstance::MaxSpeed' has a wrong offset!");
static_assert(offsetof(USurvivorAnimInstance, IsInsideCloset) == 0x0005EC, "Member 'USurvivorAnimInstance::IsInsideCloset' has a wrong offset!");
static_assert(offsetof(USurvivorAnimInstance, IsBeingHealed) == 0x0005ED, "Member 'USurvivorAnimInstance::IsBeingHealed' has a wrong offset!");
static_assert(offsetof(USurvivorAnimInstance, IsUsingAimItem) == 0x0005EE, "Member 'USurvivorAnimInstance::IsUsingAimItem' has a wrong offset!");
static_assert(offsetof(USurvivorAnimInstance, IsHoldingAimItem) == 0x0005EF, "Member 'USurvivorAnimInstance::IsHoldingAimItem' has a wrong offset!");
static_assert(offsetof(USurvivorAnimInstance, DropStaggerTimeLeft) == 0x0005F0, "Member 'USurvivorAnimInstance::DropStaggerTimeLeft' has a wrong offset!");
static_assert(offsetof(USurvivorAnimInstance, IsInteracting) == 0x0005F4, "Member 'USurvivorAnimInstance::IsInteracting' has a wrong offset!");
static_assert(offsetof(USurvivorAnimInstance, Injured) == 0x0005F5, "Member 'USurvivorAnimInstance::Injured' has a wrong offset!");
static_assert(offsetof(USurvivorAnimInstance, InteractionType) == 0x0005F6, "Member 'USurvivorAnimInstance::InteractionType' has a wrong offset!");
static_assert(offsetof(USurvivorAnimInstance, IsHoldingHandleItem) == 0x0005F7, "Member 'USurvivorAnimInstance::IsHoldingHandleItem' has a wrong offset!");
static_assert(offsetof(USurvivorAnimInstance, IsHoldingSmallItem) == 0x0005F8, "Member 'USurvivorAnimInstance::IsHoldingSmallItem' has a wrong offset!");
static_assert(offsetof(USurvivorAnimInstance, IsHoldingFirecracker) == 0x0005F9, "Member 'USurvivorAnimInstance::IsHoldingFirecracker' has a wrong offset!");
static_assert(offsetof(USurvivorAnimInstance, IsHoldingFlashbang) == 0x0005FA, "Member 'USurvivorAnimInstance::IsHoldingFlashbang' has a wrong offset!");
static_assert(offsetof(USurvivorAnimInstance, IsHoldingVaccine) == 0x0005FB, "Member 'USurvivorAnimInstance::IsHoldingVaccine' has a wrong offset!");
static_assert(offsetof(USurvivorAnimInstance, IsHoldingLamentConfiguration) == 0x0005FC, "Member 'USurvivorAnimInstance::IsHoldingLamentConfiguration' has a wrong offset!");
static_assert(offsetof(USurvivorAnimInstance, IsHoldingFragileObject) == 0x0005FD, "Member 'USurvivorAnimInstance::IsHoldingFragileObject' has a wrong offset!");
static_assert(offsetof(USurvivorAnimInstance, IsHoldingSprayObject) == 0x0005FE, "Member 'USurvivorAnimInstance::IsHoldingSprayObject' has a wrong offset!");
static_assert(offsetof(USurvivorAnimInstance, IsHoldingVHS) == 0x0005FF, "Member 'USurvivorAnimInstance::IsHoldingVHS' has a wrong offset!");
static_assert(offsetof(USurvivorAnimInstance, IsHoldingWormholeFatherKeyCard) == 0x000600, "Member 'USurvivorAnimInstance::IsHoldingWormholeFatherKeyCard' has a wrong offset!");
static_assert(offsetof(USurvivorAnimInstance, IsHoldingLantern) == 0x000601, "Member 'USurvivorAnimInstance::IsHoldingLantern' has a wrong offset!");
static_assert(offsetof(USurvivorAnimInstance, IsArmOverrideDisabled) == 0x000602, "Member 'USurvivorAnimInstance::IsArmOverrideDisabled' has a wrong offset!");
static_assert(offsetof(USurvivorAnimInstance, InAir) == 0x000603, "Member 'USurvivorAnimInstance::InAir' has a wrong offset!");
static_assert(offsetof(USurvivorAnimInstance, _walkAnimSpeed) == 0x000604, "Member 'USurvivorAnimInstance::_walkAnimSpeed' has a wrong offset!");
static_assert(offsetof(USurvivorAnimInstance, Pitch) == 0x000608, "Member 'USurvivorAnimInstance::Pitch' has a wrong offset!");
static_assert(offsetof(USurvivorAnimInstance, Yaw) == 0x00060C, "Member 'USurvivorAnimInstance::Yaw' has a wrong offset!");
static_assert(offsetof(USurvivorAnimInstance, Idle) == 0x000610, "Member 'USurvivorAnimInstance::Idle' has a wrong offset!");
static_assert(offsetof(USurvivorAnimInstance, HasAnyMontagePlaying) == 0x000611, "Member 'USurvivorAnimInstance::HasAnyMontagePlaying' has a wrong offset!");
static_assert(offsetof(USurvivorAnimInstance, _isMale) == 0x000612, "Member 'USurvivorAnimInstance::_isMale' has a wrong offset!");

// Class DBDAnimation.WakerObjectAnimInstance
// 0x0040 (0x0390 - 0x0350)
class UWakerObjectAnimInstance final : public UAnimInstance
{
public:
	float                                         _reappearTimerCooldown;                            // 0x0350(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _wakeUpCharge;                                     // 0x0354(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _chargeStarted;                                    // 0x0358(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _interactionComplete;                              // 0x0359(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _outEnd;                                           // 0x035A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _reset;                                            // 0x035B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _inEnd;                                            // 0x035C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _wakerObjectStarted;                               // 0x035D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _respawnEnd;                                       // 0x035E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _cancelEnd;                                        // 0x035F(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_360[0x30];                                     // 0x0360(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnReappear();
	void ResetReappearTimer();

	class AWakerObject* GetWakerObject() const;
	float GetWakerObjectCharge() const;
	bool GetWakerObjectChargeComplete() const;
	bool GetWakerObjectStarted() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WakerObjectAnimInstance">();
	}
	static class UWakerObjectAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWakerObjectAnimInstance>();
	}
};
static_assert(alignof(UWakerObjectAnimInstance) == 0x000010, "Wrong alignment on UWakerObjectAnimInstance");
static_assert(sizeof(UWakerObjectAnimInstance) == 0x000390, "Wrong size on UWakerObjectAnimInstance");
static_assert(offsetof(UWakerObjectAnimInstance, _reappearTimerCooldown) == 0x000350, "Member 'UWakerObjectAnimInstance::_reappearTimerCooldown' has a wrong offset!");
static_assert(offsetof(UWakerObjectAnimInstance, _wakeUpCharge) == 0x000354, "Member 'UWakerObjectAnimInstance::_wakeUpCharge' has a wrong offset!");
static_assert(offsetof(UWakerObjectAnimInstance, _chargeStarted) == 0x000358, "Member 'UWakerObjectAnimInstance::_chargeStarted' has a wrong offset!");
static_assert(offsetof(UWakerObjectAnimInstance, _interactionComplete) == 0x000359, "Member 'UWakerObjectAnimInstance::_interactionComplete' has a wrong offset!");
static_assert(offsetof(UWakerObjectAnimInstance, _outEnd) == 0x00035A, "Member 'UWakerObjectAnimInstance::_outEnd' has a wrong offset!");
static_assert(offsetof(UWakerObjectAnimInstance, _reset) == 0x00035B, "Member 'UWakerObjectAnimInstance::_reset' has a wrong offset!");
static_assert(offsetof(UWakerObjectAnimInstance, _inEnd) == 0x00035C, "Member 'UWakerObjectAnimInstance::_inEnd' has a wrong offset!");
static_assert(offsetof(UWakerObjectAnimInstance, _wakerObjectStarted) == 0x00035D, "Member 'UWakerObjectAnimInstance::_wakerObjectStarted' has a wrong offset!");
static_assert(offsetof(UWakerObjectAnimInstance, _respawnEnd) == 0x00035E, "Member 'UWakerObjectAnimInstance::_respawnEnd' has a wrong offset!");
static_assert(offsetof(UWakerObjectAnimInstance, _cancelEnd) == 0x00035F, "Member 'UWakerObjectAnimInstance::_cancelEnd' has a wrong offset!");

}

