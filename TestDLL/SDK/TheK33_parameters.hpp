#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: TheK33

#include "Basic.hpp"

#include "DBDSharedTypes_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "TheK33_structs.hpp"
#include "DeadByDaylight_structs.hpp"
#include "GameplayTags_structs.hpp"
#include "Engine_structs.hpp"


namespace SDK::Params
{

// Function TheK33.FatherTerminalHackingInteraction.Authority_OnMinigameEnd
// 0x0010 (0x0010 - 0x0000)
struct FatherTerminalHackingInteraction_Authority_OnMinigameEnd final
{
public:
	class ACamperPlayer*                          Survivor;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDirectionalMinigameResult                    Result;                                            // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FatherTerminalHackingInteraction_Authority_OnMinigameEnd) == 0x000008, "Wrong alignment on FatherTerminalHackingInteraction_Authority_OnMinigameEnd");
static_assert(sizeof(FatherTerminalHackingInteraction_Authority_OnMinigameEnd) == 0x000010, "Wrong size on FatherTerminalHackingInteraction_Authority_OnMinigameEnd");
static_assert(offsetof(FatherTerminalHackingInteraction_Authority_OnMinigameEnd, Survivor) == 0x000000, "Member 'FatherTerminalHackingInteraction_Authority_OnMinigameEnd::Survivor' has a wrong offset!");
static_assert(offsetof(FatherTerminalHackingInteraction_Authority_OnMinigameEnd, Result) == 0x000008, "Member 'FatherTerminalHackingInteraction_Authority_OnMinigameEnd::Result' has a wrong offset!");

// DelegateFunction TheK33.FatherTerminalHackingInteraction.OnWormholeTerminalHackingCooldownTimerStartOrDone__DelegateSignature
// 0x0001 (0x0001 - 0x0000)
struct FatherTerminalHackingInteraction_OnWormholeTerminalHackingCooldownTimerStartOrDone__DelegateSignature final
{
public:
	bool                                          IsRunning;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FatherTerminalHackingInteraction_OnWormholeTerminalHackingCooldownTimerStartOrDone__DelegateSignature) == 0x000001, "Wrong alignment on FatherTerminalHackingInteraction_OnWormholeTerminalHackingCooldownTimerStartOrDone__DelegateSignature");
static_assert(sizeof(FatherTerminalHackingInteraction_OnWormholeTerminalHackingCooldownTimerStartOrDone__DelegateSignature) == 0x000001, "Wrong size on FatherTerminalHackingInteraction_OnWormholeTerminalHackingCooldownTimerStartOrDone__DelegateSignature");
static_assert(offsetof(FatherTerminalHackingInteraction_OnWormholeTerminalHackingCooldownTimerStartOrDone__DelegateSignature, IsRunning) == 0x000000, "Member 'FatherTerminalHackingInteraction_OnWormholeTerminalHackingCooldownTimerStartOrDone__DelegateSignature::IsRunning' has a wrong offset!");

// Function TheK33.K33TunnelPulse.Cosmetic_ActivatePulse
// 0x0004 (0x0004 - 0x0000)
struct K33TunnelPulse_Cosmetic_ActivatePulse final
{
public:
	int32                                         IdInPulseWave;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K33TunnelPulse_Cosmetic_ActivatePulse) == 0x000004, "Wrong alignment on K33TunnelPulse_Cosmetic_ActivatePulse");
static_assert(sizeof(K33TunnelPulse_Cosmetic_ActivatePulse) == 0x000004, "Wrong size on K33TunnelPulse_Cosmetic_ActivatePulse");
static_assert(offsetof(K33TunnelPulse_Cosmetic_ActivatePulse, IdInPulseWave) == 0x000000, "Member 'K33TunnelPulse_Cosmetic_ActivatePulse::IdInPulseWave' has a wrong offset!");

// Function TheK33.K33TunnelPulse.Cosmetic_GetFadeOutPercentage
// 0x0004 (0x0004 - 0x0000)
struct K33TunnelPulse_Cosmetic_GetFadeOutPercentage final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K33TunnelPulse_Cosmetic_GetFadeOutPercentage) == 0x000004, "Wrong alignment on K33TunnelPulse_Cosmetic_GetFadeOutPercentage");
static_assert(sizeof(K33TunnelPulse_Cosmetic_GetFadeOutPercentage) == 0x000004, "Wrong size on K33TunnelPulse_Cosmetic_GetFadeOutPercentage");
static_assert(offsetof(K33TunnelPulse_Cosmetic_GetFadeOutPercentage, ReturnValue) == 0x000000, "Member 'K33TunnelPulse_Cosmetic_GetFadeOutPercentage::ReturnValue' has a wrong offset!");

// Function TheK33.K33CheatComponent.DBD_K33DrawTunnelBlockConnections
// 0x0004 (0x0004 - 0x0000)
struct K33CheatComponent_DBD_K33DrawTunnelBlockConnections final
{
public:
	float                                         SecondsToDisplay;                                  // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K33CheatComponent_DBD_K33DrawTunnelBlockConnections) == 0x000004, "Wrong alignment on K33CheatComponent_DBD_K33DrawTunnelBlockConnections");
static_assert(sizeof(K33CheatComponent_DBD_K33DrawTunnelBlockConnections) == 0x000004, "Wrong size on K33CheatComponent_DBD_K33DrawTunnelBlockConnections");
static_assert(offsetof(K33CheatComponent_DBD_K33DrawTunnelBlockConnections, SecondsToDisplay) == 0x000000, "Member 'K33CheatComponent_DBD_K33DrawTunnelBlockConnections::SecondsToDisplay' has a wrong offset!");

// Function TheK33.K33CheatComponent.DBD_K33ForceSpecialMode
// 0x0001 (0x0001 - 0x0000)
struct K33CheatComponent_DBD_K33ForceSpecialMode final
{
public:
	uint8                                         Force;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K33CheatComponent_DBD_K33ForceSpecialMode) == 0x000001, "Wrong alignment on K33CheatComponent_DBD_K33ForceSpecialMode");
static_assert(sizeof(K33CheatComponent_DBD_K33ForceSpecialMode) == 0x000001, "Wrong size on K33CheatComponent_DBD_K33ForceSpecialMode");
static_assert(offsetof(K33CheatComponent_DBD_K33ForceSpecialMode, Force) == 0x000000, "Member 'K33CheatComponent_DBD_K33ForceSpecialMode::Force' has a wrong offset!");

// Function TheK33.K33ControlStation.Cosmetic_OnControlStationEnteringState
// 0x0001 (0x0001 - 0x0000)
struct K33ControlStation_Cosmetic_OnControlStationEnteringState final
{
public:
	EControlStationState                          EnteringState;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K33ControlStation_Cosmetic_OnControlStationEnteringState) == 0x000001, "Wrong alignment on K33ControlStation_Cosmetic_OnControlStationEnteringState");
static_assert(sizeof(K33ControlStation_Cosmetic_OnControlStationEnteringState) == 0x000001, "Wrong size on K33ControlStation_Cosmetic_OnControlStationEnteringState");
static_assert(offsetof(K33ControlStation_Cosmetic_OnControlStationEnteringState, EnteringState) == 0x000000, "Member 'K33ControlStation_Cosmetic_OnControlStationEnteringState::EnteringState' has a wrong offset!");

// Function TheK33.K33ControlStation.Cosmetic_OnControlStationExitingState
// 0x0001 (0x0001 - 0x0000)
struct K33ControlStation_Cosmetic_OnControlStationExitingState final
{
public:
	EControlStationState                          ExitingState;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K33ControlStation_Cosmetic_OnControlStationExitingState) == 0x000001, "Wrong alignment on K33ControlStation_Cosmetic_OnControlStationExitingState");
static_assert(sizeof(K33ControlStation_Cosmetic_OnControlStationExitingState) == 0x000001, "Wrong size on K33ControlStation_Cosmetic_OnControlStationExitingState");
static_assert(offsetof(K33ControlStation_Cosmetic_OnControlStationExitingState, ExitingState) == 0x000000, "Member 'K33ControlStation_Cosmetic_OnControlStationExitingState::ExitingState' has a wrong offset!");

// Function TheK33.K33ControlStation.Cosmetic_OnTurretInPoolCountChanged
// 0x0004 (0x0004 - 0x0000)
struct K33ControlStation_Cosmetic_OnTurretInPoolCountChanged final
{
public:
	int32                                         TurretCount;                                       // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K33ControlStation_Cosmetic_OnTurretInPoolCountChanged) == 0x000004, "Wrong alignment on K33ControlStation_Cosmetic_OnTurretInPoolCountChanged");
static_assert(sizeof(K33ControlStation_Cosmetic_OnTurretInPoolCountChanged) == 0x000004, "Wrong size on K33ControlStation_Cosmetic_OnTurretInPoolCountChanged");
static_assert(offsetof(K33ControlStation_Cosmetic_OnTurretInPoolCountChanged, TurretCount) == 0x000000, "Member 'K33ControlStation_Cosmetic_OnTurretInPoolCountChanged::TurretCount' has a wrong offset!");

// Function TheK33.K33ControlStation.Cosmetic_SetTunnelCapVisibility
// 0x0001 (0x0001 - 0x0000)
struct K33ControlStation_Cosmetic_SetTunnelCapVisibility final
{
public:
	bool                                          IsVisible;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K33ControlStation_Cosmetic_SetTunnelCapVisibility) == 0x000001, "Wrong alignment on K33ControlStation_Cosmetic_SetTunnelCapVisibility");
static_assert(sizeof(K33ControlStation_Cosmetic_SetTunnelCapVisibility) == 0x000001, "Wrong size on K33ControlStation_Cosmetic_SetTunnelCapVisibility");
static_assert(offsetof(K33ControlStation_Cosmetic_SetTunnelCapVisibility, IsVisible) == 0x000000, "Member 'K33ControlStation_Cosmetic_SetTunnelCapVisibility::IsVisible' has a wrong offset!");

// Function TheK33.K33ControlStation.Cosmetic_UpdateControlStationCooldown
// 0x0004 (0x0004 - 0x0000)
struct K33ControlStation_Cosmetic_UpdateControlStationCooldown final
{
public:
	float                                         CooldownElapsedTimePercent;                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K33ControlStation_Cosmetic_UpdateControlStationCooldown) == 0x000004, "Wrong alignment on K33ControlStation_Cosmetic_UpdateControlStationCooldown");
static_assert(sizeof(K33ControlStation_Cosmetic_UpdateControlStationCooldown) == 0x000004, "Wrong size on K33ControlStation_Cosmetic_UpdateControlStationCooldown");
static_assert(offsetof(K33ControlStation_Cosmetic_UpdateControlStationCooldown, CooldownElapsedTimePercent) == 0x000000, "Member 'K33ControlStation_Cosmetic_UpdateControlStationCooldown::CooldownElapsedTimePercent' has a wrong offset!");

// Function TheK33.K33ControlStation.OnRep_CurrentState
// 0x0001 (0x0001 - 0x0000)
struct K33ControlStation_OnRep_CurrentState final
{
public:
	EControlStationState                          OldState;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K33ControlStation_OnRep_CurrentState) == 0x000001, "Wrong alignment on K33ControlStation_OnRep_CurrentState");
static_assert(sizeof(K33ControlStation_OnRep_CurrentState) == 0x000001, "Wrong size on K33ControlStation_OnRep_CurrentState");
static_assert(offsetof(K33ControlStation_OnRep_CurrentState, OldState) == 0x000000, "Member 'K33ControlStation_OnRep_CurrentState::OldState' has a wrong offset!");

// Function TheK33.K33ControlStation.GetKillerExitTunnelEndLocation
// 0x0018 (0x0018 - 0x0000)
struct K33ControlStation_GetKillerExitTunnelEndLocation final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K33ControlStation_GetKillerExitTunnelEndLocation) == 0x000008, "Wrong alignment on K33ControlStation_GetKillerExitTunnelEndLocation");
static_assert(sizeof(K33ControlStation_GetKillerExitTunnelEndLocation) == 0x000018, "Wrong size on K33ControlStation_GetKillerExitTunnelEndLocation");
static_assert(offsetof(K33ControlStation_GetKillerExitTunnelEndLocation, ReturnValue) == 0x000000, "Member 'K33ControlStation_GetKillerExitTunnelEndLocation::ReturnValue' has a wrong offset!");

// Function TheK33.K33Turret.Cosmetic_BipMotionTrackerFX
// 0x0004 (0x0004 - 0x0000)
struct K33Turret_Cosmetic_BipMotionTrackerFX final
{
public:
	float                                         DistanceToKiller;                                  // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K33Turret_Cosmetic_BipMotionTrackerFX) == 0x000004, "Wrong alignment on K33Turret_Cosmetic_BipMotionTrackerFX");
static_assert(sizeof(K33Turret_Cosmetic_BipMotionTrackerFX) == 0x000004, "Wrong size on K33Turret_Cosmetic_BipMotionTrackerFX");
static_assert(offsetof(K33Turret_Cosmetic_BipMotionTrackerFX, DistanceToKiller) == 0x000000, "Member 'K33Turret_Cosmetic_BipMotionTrackerFX::DistanceToKiller' has a wrong offset!");

// Function TheK33.K33Turret.Cosmetic_OnTurretDetectionRangeChanged
// 0x0004 (0x0004 - 0x0000)
struct K33Turret_Cosmetic_OnTurretDetectionRangeChanged final
{
public:
	float                                         NewRange;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K33Turret_Cosmetic_OnTurretDetectionRangeChanged) == 0x000004, "Wrong alignment on K33Turret_Cosmetic_OnTurretDetectionRangeChanged");
static_assert(sizeof(K33Turret_Cosmetic_OnTurretDetectionRangeChanged) == 0x000004, "Wrong size on K33Turret_Cosmetic_OnTurretDetectionRangeChanged");
static_assert(offsetof(K33Turret_Cosmetic_OnTurretDetectionRangeChanged, NewRange) == 0x000000, "Member 'K33Turret_Cosmetic_OnTurretDetectionRangeChanged::NewRange' has a wrong offset!");

// Function TheK33.K33Turret.Cosmetic_OnTurretHeatChanged
// 0x0004 (0x0004 - 0x0000)
struct K33Turret_Cosmetic_OnTurretHeatChanged final
{
public:
	float                                         HeatAmount;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K33Turret_Cosmetic_OnTurretHeatChanged) == 0x000004, "Wrong alignment on K33Turret_Cosmetic_OnTurretHeatChanged");
static_assert(sizeof(K33Turret_Cosmetic_OnTurretHeatChanged) == 0x000004, "Wrong size on K33Turret_Cosmetic_OnTurretHeatChanged");
static_assert(offsetof(K33Turret_Cosmetic_OnTurretHeatChanged, HeatAmount) == 0x000000, "Member 'K33Turret_Cosmetic_OnTurretHeatChanged::HeatAmount' has a wrong offset!");

// Function TheK33.K33Turret.Cosmetic_UpdateLaserLength
// 0x0004 (0x0004 - 0x0000)
struct K33Turret_Cosmetic_UpdateLaserLength final
{
public:
	float                                         LaserLength;                                       // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K33Turret_Cosmetic_UpdateLaserLength) == 0x000004, "Wrong alignment on K33Turret_Cosmetic_UpdateLaserLength");
static_assert(sizeof(K33Turret_Cosmetic_UpdateLaserLength) == 0x000004, "Wrong size on K33Turret_Cosmetic_UpdateLaserLength");
static_assert(offsetof(K33Turret_Cosmetic_UpdateLaserLength, LaserLength) == 0x000000, "Member 'K33Turret_Cosmetic_UpdateLaserLength::LaserLength' has a wrong offset!");

// Function TheK33.K33Turret.Cosmetic_UpdateMotionTrackerSoundVolume
// 0x0004 (0x0004 - 0x0000)
struct K33Turret_Cosmetic_UpdateMotionTrackerSoundVolume final
{
public:
	float                                         DistanceToKiller;                                  // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K33Turret_Cosmetic_UpdateMotionTrackerSoundVolume) == 0x000004, "Wrong alignment on K33Turret_Cosmetic_UpdateMotionTrackerSoundVolume");
static_assert(sizeof(K33Turret_Cosmetic_UpdateMotionTrackerSoundVolume) == 0x000004, "Wrong size on K33Turret_Cosmetic_UpdateMotionTrackerSoundVolume");
static_assert(offsetof(K33Turret_Cosmetic_UpdateMotionTrackerSoundVolume, DistanceToKiller) == 0x000000, "Member 'K33Turret_Cosmetic_UpdateMotionTrackerSoundVolume::DistanceToKiller' has a wrong offset!");

// Function TheK33.K33Turret.Cosmetic_UpdateTurretVolumeRTPC
// 0x0004 (0x0004 - 0x0000)
struct K33Turret_Cosmetic_UpdateTurretVolumeRTPC final
{
public:
	int32                                         TurretsInRangeCount;                               // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K33Turret_Cosmetic_UpdateTurretVolumeRTPC) == 0x000004, "Wrong alignment on K33Turret_Cosmetic_UpdateTurretVolumeRTPC");
static_assert(sizeof(K33Turret_Cosmetic_UpdateTurretVolumeRTPC) == 0x000004, "Wrong size on K33Turret_Cosmetic_UpdateTurretVolumeRTPC");
static_assert(offsetof(K33Turret_Cosmetic_UpdateTurretVolumeRTPC, TurretsInRangeCount) == 0x000000, "Member 'K33Turret_Cosmetic_UpdateTurretVolumeRTPC::TurretsInRangeCount' has a wrong offset!");

// Function TheK33.K33EnterTunnelInteraction.Multicast_TeleportPlayerToTunnel
// 0x0038 (0x0038 - 0x0000)
struct K33EnterTunnelInteraction_Multicast_TeleportPlayerToTunnel final
{
public:
	class ADBDPlayer*                             Player;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0008(0x0018)(ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0020(0x0018)(ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(K33EnterTunnelInteraction_Multicast_TeleportPlayerToTunnel) == 0x000008, "Wrong alignment on K33EnterTunnelInteraction_Multicast_TeleportPlayerToTunnel");
static_assert(sizeof(K33EnterTunnelInteraction_Multicast_TeleportPlayerToTunnel) == 0x000038, "Wrong size on K33EnterTunnelInteraction_Multicast_TeleportPlayerToTunnel");
static_assert(offsetof(K33EnterTunnelInteraction_Multicast_TeleportPlayerToTunnel, Player) == 0x000000, "Member 'K33EnterTunnelInteraction_Multicast_TeleportPlayerToTunnel::Player' has a wrong offset!");
static_assert(offsetof(K33EnterTunnelInteraction_Multicast_TeleportPlayerToTunnel, Location) == 0x000008, "Member 'K33EnterTunnelInteraction_Multicast_TeleportPlayerToTunnel::Location' has a wrong offset!");
static_assert(offsetof(K33EnterTunnelInteraction_Multicast_TeleportPlayerToTunnel, Rotation) == 0x000020, "Member 'K33EnterTunnelInteraction_Multicast_TeleportPlayerToTunnel::Rotation' has a wrong offset!");

// Function TheK33.K33ExitTunnelInteraction.Multicast_OnSnapTransitionCompleted
// 0x0038 (0x0038 - 0x0000)
struct K33ExitTunnelInteraction_Multicast_OnSnapTransitionCompleted final
{
public:
	class ADBDPlayer*                             Player;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0008(0x0018)(ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0020(0x0018)(ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(K33ExitTunnelInteraction_Multicast_OnSnapTransitionCompleted) == 0x000008, "Wrong alignment on K33ExitTunnelInteraction_Multicast_OnSnapTransitionCompleted");
static_assert(sizeof(K33ExitTunnelInteraction_Multicast_OnSnapTransitionCompleted) == 0x000038, "Wrong size on K33ExitTunnelInteraction_Multicast_OnSnapTransitionCompleted");
static_assert(offsetof(K33ExitTunnelInteraction_Multicast_OnSnapTransitionCompleted, Player) == 0x000000, "Member 'K33ExitTunnelInteraction_Multicast_OnSnapTransitionCompleted::Player' has a wrong offset!");
static_assert(offsetof(K33ExitTunnelInteraction_Multicast_OnSnapTransitionCompleted, Location) == 0x000008, "Member 'K33ExitTunnelInteraction_Multicast_OnSnapTransitionCompleted::Location' has a wrong offset!");
static_assert(offsetof(K33ExitTunnelInteraction_Multicast_OnSnapTransitionCompleted, Rotation) == 0x000020, "Member 'K33ExitTunnelInteraction_Multicast_OnSnapTransitionCompleted::Rotation' has a wrong offset!");

// Function TheK33.K33FeetVFX.Cosmetic_TriggerFootstepTimeline
// 0x0020 (0x0020 - 0x0000)
struct K33FeetVFX_Cosmetic_TriggerFootstepTimeline final
{
public:
	EK33Foot                                      FootType;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EffectLifetime;                                    // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                KillerLocation;                                    // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K33FeetVFX_Cosmetic_TriggerFootstepTimeline) == 0x000008, "Wrong alignment on K33FeetVFX_Cosmetic_TriggerFootstepTimeline");
static_assert(sizeof(K33FeetVFX_Cosmetic_TriggerFootstepTimeline) == 0x000020, "Wrong size on K33FeetVFX_Cosmetic_TriggerFootstepTimeline");
static_assert(offsetof(K33FeetVFX_Cosmetic_TriggerFootstepTimeline, FootType) == 0x000000, "Member 'K33FeetVFX_Cosmetic_TriggerFootstepTimeline::FootType' has a wrong offset!");
static_assert(offsetof(K33FeetVFX_Cosmetic_TriggerFootstepTimeline, EffectLifetime) == 0x000004, "Member 'K33FeetVFX_Cosmetic_TriggerFootstepTimeline::EffectLifetime' has a wrong offset!");
static_assert(offsetof(K33FeetVFX_Cosmetic_TriggerFootstepTimeline, KillerLocation) == 0x000008, "Member 'K33FeetVFX_Cosmetic_TriggerFootstepTimeline::KillerLocation' has a wrong offset!");

// Function TheK33.K33FeetVFX.Cosmetic_TriggerFootstepVisibility
// 0x0002 (0x0002 - 0x0000)
struct K33FeetVFX_Cosmetic_TriggerFootstepVisibility final
{
public:
	EK33Foot                                      FootType;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsVisible;                                         // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K33FeetVFX_Cosmetic_TriggerFootstepVisibility) == 0x000001, "Wrong alignment on K33FeetVFX_Cosmetic_TriggerFootstepVisibility");
static_assert(sizeof(K33FeetVFX_Cosmetic_TriggerFootstepVisibility) == 0x000002, "Wrong size on K33FeetVFX_Cosmetic_TriggerFootstepVisibility");
static_assert(offsetof(K33FeetVFX_Cosmetic_TriggerFootstepVisibility, FootType) == 0x000000, "Member 'K33FeetVFX_Cosmetic_TriggerFootstepVisibility::FootType' has a wrong offset!");
static_assert(offsetof(K33FeetVFX_Cosmetic_TriggerFootstepVisibility, IsVisible) == 0x000001, "Member 'K33FeetVFX_Cosmetic_TriggerFootstepVisibility::IsVisible' has a wrong offset!");

// Function TheK33.K33FXInterface.Cosmetic_OnSpecialModeChanged
// 0x0001 (0x0001 - 0x0000)
struct K33FXInterface_Cosmetic_OnSpecialModeChanged final
{
public:
	bool                                          IsInSpecialMode;                                   // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K33FXInterface_Cosmetic_OnSpecialModeChanged) == 0x000001, "Wrong alignment on K33FXInterface_Cosmetic_OnSpecialModeChanged");
static_assert(sizeof(K33FXInterface_Cosmetic_OnSpecialModeChanged) == 0x000001, "Wrong size on K33FXInterface_Cosmetic_OnSpecialModeChanged");
static_assert(offsetof(K33FXInterface_Cosmetic_OnSpecialModeChanged, IsInSpecialMode) == 0x000000, "Member 'K33FXInterface_Cosmetic_OnSpecialModeChanged::IsInSpecialMode' has a wrong offset!");

// Function TheK33.K33FXInterface.Cosmetic_OnSurvivorHitByTailAttack
// 0x0008 (0x0008 - 0x0000)
struct K33FXInterface_Cosmetic_OnSurvivorHitByTailAttack final
{
public:
	class ACamperPlayer*                          Player;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K33FXInterface_Cosmetic_OnSurvivorHitByTailAttack) == 0x000008, "Wrong alignment on K33FXInterface_Cosmetic_OnSurvivorHitByTailAttack");
static_assert(sizeof(K33FXInterface_Cosmetic_OnSurvivorHitByTailAttack) == 0x000008, "Wrong size on K33FXInterface_Cosmetic_OnSurvivorHitByTailAttack");
static_assert(offsetof(K33FXInterface_Cosmetic_OnSurvivorHitByTailAttack, Player) == 0x000000, "Member 'K33FXInterface_Cosmetic_OnSurvivorHitByTailAttack::Player' has a wrong offset!");

// Function TheK33.K33FXInterface.Cosmetic_OnTurretDamageChanged
// 0x0004 (0x0004 - 0x0000)
struct K33FXInterface_Cosmetic_OnTurretDamageChanged final
{
public:
	float                                         DamagePercent;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K33FXInterface_Cosmetic_OnTurretDamageChanged) == 0x000004, "Wrong alignment on K33FXInterface_Cosmetic_OnTurretDamageChanged");
static_assert(sizeof(K33FXInterface_Cosmetic_OnTurretDamageChanged) == 0x000004, "Wrong size on K33FXInterface_Cosmetic_OnTurretDamageChanged");
static_assert(offsetof(K33FXInterface_Cosmetic_OnTurretDamageChanged, DamagePercent) == 0x000000, "Member 'K33FXInterface_Cosmetic_OnTurretDamageChanged::DamagePercent' has a wrong offset!");

// Function TheK33.K33FXInterface.Cosmetic_OnTurretHitByTailAttack
// 0x0008 (0x0008 - 0x0000)
struct K33FXInterface_Cosmetic_OnTurretHitByTailAttack final
{
public:
	class AK33Turret*                             Turret;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K33FXInterface_Cosmetic_OnTurretHitByTailAttack) == 0x000008, "Wrong alignment on K33FXInterface_Cosmetic_OnTurretHitByTailAttack");
static_assert(sizeof(K33FXInterface_Cosmetic_OnTurretHitByTailAttack) == 0x000008, "Wrong size on K33FXInterface_Cosmetic_OnTurretHitByTailAttack");
static_assert(offsetof(K33FXInterface_Cosmetic_OnTurretHitByTailAttack, Turret) == 0x000000, "Member 'K33FXInterface_Cosmetic_OnTurretHitByTailAttack::Turret' has a wrong offset!");

// Function TheK33.K33FXInterface.Cosmetic_SetKillerFPVAudioAmbiance
// 0x0001 (0x0001 - 0x0000)
struct K33FXInterface_Cosmetic_SetKillerFPVAudioAmbiance final
{
public:
	bool                                          IsTunnelAmbianceActive;                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K33FXInterface_Cosmetic_SetKillerFPVAudioAmbiance) == 0x000001, "Wrong alignment on K33FXInterface_Cosmetic_SetKillerFPVAudioAmbiance");
static_assert(sizeof(K33FXInterface_Cosmetic_SetKillerFPVAudioAmbiance) == 0x000001, "Wrong size on K33FXInterface_Cosmetic_SetKillerFPVAudioAmbiance");
static_assert(offsetof(K33FXInterface_Cosmetic_SetKillerFPVAudioAmbiance, IsTunnelAmbianceActive) == 0x000000, "Member 'K33FXInterface_Cosmetic_SetKillerFPVAudioAmbiance::IsTunnelAmbianceActive' has a wrong offset!");

// Function TheK33.K33FXInterface.Cosmetic_SetKillerInvisibleUnderCurrentFloor
// 0x0001 (0x0001 - 0x0000)
struct K33FXInterface_Cosmetic_SetKillerInvisibleUnderCurrentFloor final
{
public:
	bool                                          ShouldKillerBeInvisibleUnderFloor;                 // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K33FXInterface_Cosmetic_SetKillerInvisibleUnderCurrentFloor) == 0x000001, "Wrong alignment on K33FXInterface_Cosmetic_SetKillerInvisibleUnderCurrentFloor");
static_assert(sizeof(K33FXInterface_Cosmetic_SetKillerInvisibleUnderCurrentFloor) == 0x000001, "Wrong size on K33FXInterface_Cosmetic_SetKillerInvisibleUnderCurrentFloor");
static_assert(offsetof(K33FXInterface_Cosmetic_SetKillerInvisibleUnderCurrentFloor, ShouldKillerBeInvisibleUnderFloor) == 0x000000, "Member 'K33FXInterface_Cosmetic_SetKillerInvisibleUnderCurrentFloor::ShouldKillerBeInvisibleUnderFloor' has a wrong offset!");

// Function TheK33.K33FXInterface.Cosmetic_SetVisibility
// 0x0001 (0x0001 - 0x0000)
struct K33FXInterface_Cosmetic_SetVisibility final
{
public:
	bool                                          IsVisible;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K33FXInterface_Cosmetic_SetVisibility) == 0x000001, "Wrong alignment on K33FXInterface_Cosmetic_SetVisibility");
static_assert(sizeof(K33FXInterface_Cosmetic_SetVisibility) == 0x000001, "Wrong size on K33FXInterface_Cosmetic_SetVisibility");
static_assert(offsetof(K33FXInterface_Cosmetic_SetVisibility, IsVisible) == 0x000000, "Member 'K33FXInterface_Cosmetic_SetVisibility::IsVisible' has a wrong offset!");

// Function TheK33.K33FXInterface.Cosmetic_TailAttackObstructedVFX
// 0x0018 (0x0018 - 0x0000)
struct K33FXInterface_Cosmetic_TailAttackObstructedVFX final
{
public:
	struct FVector                                ObstructionLocation;                               // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K33FXInterface_Cosmetic_TailAttackObstructedVFX) == 0x000008, "Wrong alignment on K33FXInterface_Cosmetic_TailAttackObstructedVFX");
static_assert(sizeof(K33FXInterface_Cosmetic_TailAttackObstructedVFX) == 0x000018, "Wrong size on K33FXInterface_Cosmetic_TailAttackObstructedVFX");
static_assert(offsetof(K33FXInterface_Cosmetic_TailAttackObstructedVFX, ObstructionLocation) == 0x000000, "Member 'K33FXInterface_Cosmetic_TailAttackObstructedVFX::ObstructionLocation' has a wrong offset!");

// Function TheK33.K33FXInterface.Cosmetic_TriggerTunnelTransitionFadeIn
// 0x0004 (0x0004 - 0x0000)
struct K33FXInterface_Cosmetic_TriggerTunnelTransitionFadeIn final
{
public:
	float                                         TimeBeforeFadeIn;                                  // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K33FXInterface_Cosmetic_TriggerTunnelTransitionFadeIn) == 0x000004, "Wrong alignment on K33FXInterface_Cosmetic_TriggerTunnelTransitionFadeIn");
static_assert(sizeof(K33FXInterface_Cosmetic_TriggerTunnelTransitionFadeIn) == 0x000004, "Wrong size on K33FXInterface_Cosmetic_TriggerTunnelTransitionFadeIn");
static_assert(offsetof(K33FXInterface_Cosmetic_TriggerTunnelTransitionFadeIn, TimeBeforeFadeIn) == 0x000000, "Member 'K33FXInterface_Cosmetic_TriggerTunnelTransitionFadeIn::TimeBeforeFadeIn' has a wrong offset!");

// Function TheK33.K33FXInterface.Cosmetic_TriggerTunnelTransitionFadeOut
// 0x0004 (0x0004 - 0x0000)
struct K33FXInterface_Cosmetic_TriggerTunnelTransitionFadeOut final
{
public:
	float                                         TimeBeforeFadeOut;                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K33FXInterface_Cosmetic_TriggerTunnelTransitionFadeOut) == 0x000004, "Wrong alignment on K33FXInterface_Cosmetic_TriggerTunnelTransitionFadeOut");
static_assert(sizeof(K33FXInterface_Cosmetic_TriggerTunnelTransitionFadeOut) == 0x000004, "Wrong size on K33FXInterface_Cosmetic_TriggerTunnelTransitionFadeOut");
static_assert(offsetof(K33FXInterface_Cosmetic_TriggerTunnelTransitionFadeOut, TimeBeforeFadeOut) == 0x000000, "Member 'K33FXInterface_Cosmetic_TriggerTunnelTransitionFadeOut::TimeBeforeFadeOut' has a wrong offset!");

// Function TheK33.K33FXInterface.Cosmetic_UpdateTailAttackVFX
// 0x0030 (0x0030 - 0x0000)
struct K33FXInterface_Cosmetic_UpdateTailAttackVFX final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0018(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(K33FXInterface_Cosmetic_UpdateTailAttackVFX) == 0x000008, "Wrong alignment on K33FXInterface_Cosmetic_UpdateTailAttackVFX");
static_assert(sizeof(K33FXInterface_Cosmetic_UpdateTailAttackVFX) == 0x000030, "Wrong size on K33FXInterface_Cosmetic_UpdateTailAttackVFX");
static_assert(offsetof(K33FXInterface_Cosmetic_UpdateTailAttackVFX, Location) == 0x000000, "Member 'K33FXInterface_Cosmetic_UpdateTailAttackVFX::Location' has a wrong offset!");
static_assert(offsetof(K33FXInterface_Cosmetic_UpdateTailAttackVFX, Rotation) == 0x000018, "Member 'K33FXInterface_Cosmetic_UpdateTailAttackVFX::Rotation' has a wrong offset!");

// Function TheK33.K33HuskAnimInstance.GetCopiedCustomizedSkeletalMesh
// 0x0008 (0x0008 - 0x0000)
struct K33HuskAnimInstance_GetCopiedCustomizedSkeletalMesh final
{
public:
	const class UCustomizedSkeletalMesh*          ReturnValue;                                       // 0x0000(0x0008)(ConstParm, ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K33HuskAnimInstance_GetCopiedCustomizedSkeletalMesh) == 0x000008, "Wrong alignment on K33HuskAnimInstance_GetCopiedCustomizedSkeletalMesh");
static_assert(sizeof(K33HuskAnimInstance_GetCopiedCustomizedSkeletalMesh) == 0x000008, "Wrong size on K33HuskAnimInstance_GetCopiedCustomizedSkeletalMesh");
static_assert(offsetof(K33HuskAnimInstance_GetCopiedCustomizedSkeletalMesh, ReturnValue) == 0x000000, "Member 'K33HuskAnimInstance_GetCopiedCustomizedSkeletalMesh::ReturnValue' has a wrong offset!");

// Function TheK33.K33HuskAnimInstance.GetCopiedSkeletalMesh
// 0x0008 (0x0008 - 0x0000)
struct K33HuskAnimInstance_GetCopiedSkeletalMesh final
{
public:
	const class USkeletalMeshComponent*           ReturnValue;                                       // 0x0000(0x0008)(ConstParm, ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K33HuskAnimInstance_GetCopiedSkeletalMesh) == 0x000008, "Wrong alignment on K33HuskAnimInstance_GetCopiedSkeletalMesh");
static_assert(sizeof(K33HuskAnimInstance_GetCopiedSkeletalMesh) == 0x000008, "Wrong size on K33HuskAnimInstance_GetCopiedSkeletalMesh");
static_assert(offsetof(K33HuskAnimInstance_GetCopiedSkeletalMesh, ReturnValue) == 0x000000, "Member 'K33HuskAnimInstance_GetCopiedSkeletalMesh::ReturnValue' has a wrong offset!");

// Function TheK33.K33KillerControlStationSelectorComponent.OnRep_Replicated_SelectedControlStation
// 0x0008 (0x0008 - 0x0000)
struct K33KillerControlStationSelectorComponent_OnRep_Replicated_SelectedControlStation final
{
public:
	class AK33ControlStation*                     PreviousSelectedControlStation;                    // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K33KillerControlStationSelectorComponent_OnRep_Replicated_SelectedControlStation) == 0x000008, "Wrong alignment on K33KillerControlStationSelectorComponent_OnRep_Replicated_SelectedControlStation");
static_assert(sizeof(K33KillerControlStationSelectorComponent_OnRep_Replicated_SelectedControlStation) == 0x000008, "Wrong size on K33KillerControlStationSelectorComponent_OnRep_Replicated_SelectedControlStation");
static_assert(offsetof(K33KillerControlStationSelectorComponent_OnRep_Replicated_SelectedControlStation, PreviousSelectedControlStation) == 0x000000, "Member 'K33KillerControlStationSelectorComponent_OnRep_Replicated_SelectedControlStation::PreviousSelectedControlStation' has a wrong offset!");

// Function TheK33.K33KillerControlStationSelectorComponent.Server_SetSelectedControlStation
// 0x0008 (0x0008 - 0x0000)
struct K33KillerControlStationSelectorComponent_Server_SetSelectedControlStation final
{
public:
	class AK33ControlStation*                     ControlStation;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K33KillerControlStationSelectorComponent_Server_SetSelectedControlStation) == 0x000008, "Wrong alignment on K33KillerControlStationSelectorComponent_Server_SetSelectedControlStation");
static_assert(sizeof(K33KillerControlStationSelectorComponent_Server_SetSelectedControlStation) == 0x000008, "Wrong size on K33KillerControlStationSelectorComponent_Server_SetSelectedControlStation");
static_assert(offsetof(K33KillerControlStationSelectorComponent_Server_SetSelectedControlStation, ControlStation) == 0x000000, "Member 'K33KillerControlStationSelectorComponent_Server_SetSelectedControlStation::ControlStation' has a wrong offset!");

// Function TheK33.K33P01.GetBlindedEffectDurationAtLevel
// 0x0004 (0x0004 - 0x0000)
struct K33P01_GetBlindedEffectDurationAtLevel final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K33P01_GetBlindedEffectDurationAtLevel) == 0x000004, "Wrong alignment on K33P01_GetBlindedEffectDurationAtLevel");
static_assert(sizeof(K33P01_GetBlindedEffectDurationAtLevel) == 0x000004, "Wrong size on K33P01_GetBlindedEffectDurationAtLevel");
static_assert(offsetof(K33P01_GetBlindedEffectDurationAtLevel, ReturnValue) == 0x000000, "Member 'K33P01_GetBlindedEffectDurationAtLevel::ReturnValue' has a wrong offset!");

// Function TheK33.K33P01.GetPerkCooldownTimeAtLevel
// 0x0004 (0x0004 - 0x0000)
struct K33P01_GetPerkCooldownTimeAtLevel final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K33P01_GetPerkCooldownTimeAtLevel) == 0x000004, "Wrong alignment on K33P01_GetPerkCooldownTimeAtLevel");
static_assert(sizeof(K33P01_GetPerkCooldownTimeAtLevel) == 0x000004, "Wrong size on K33P01_GetPerkCooldownTimeAtLevel");
static_assert(offsetof(K33P01_GetPerkCooldownTimeAtLevel, ReturnValue) == 0x000000, "Member 'K33P01_GetPerkCooldownTimeAtLevel::ReturnValue' has a wrong offset!");

// Function TheK33.K33P01.GetScreamRevealRange
// 0x0004 (0x0004 - 0x0000)
struct K33P01_GetScreamRevealRange final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K33P01_GetScreamRevealRange) == 0x000004, "Wrong alignment on K33P01_GetScreamRevealRange");
static_assert(sizeof(K33P01_GetScreamRevealRange) == 0x000004, "Wrong size on K33P01_GetScreamRevealRange");
static_assert(offsetof(K33P01_GetScreamRevealRange, ReturnValue) == 0x000000, "Member 'K33P01_GetScreamRevealRange::ReturnValue' has a wrong offset!");

// Function TheK33.K33P01.Multicast_SurvivorRevealed
// 0x0008 (0x0008 - 0x0000)
struct K33P01_Multicast_SurvivorRevealed final
{
public:
	const class ACamperPlayer*                    Survivor;                                          // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K33P01_Multicast_SurvivorRevealed) == 0x000008, "Wrong alignment on K33P01_Multicast_SurvivorRevealed");
static_assert(sizeof(K33P01_Multicast_SurvivorRevealed) == 0x000008, "Wrong size on K33P01_Multicast_SurvivorRevealed");
static_assert(offsetof(K33P01_Multicast_SurvivorRevealed, Survivor) == 0x000000, "Member 'K33P01_Multicast_SurvivorRevealed::Survivor' has a wrong offset!");

// Function TheK33.K33P02.GetHasteAmount
// 0x0004 (0x0004 - 0x0000)
struct K33P02_GetHasteAmount final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K33P02_GetHasteAmount) == 0x000004, "Wrong alignment on K33P02_GetHasteAmount");
static_assert(sizeof(K33P02_GetHasteAmount) == 0x000004, "Wrong size on K33P02_GetHasteAmount");
static_assert(offsetof(K33P02_GetHasteAmount, ReturnValue) == 0x000000, "Member 'K33P02_GetHasteAmount::ReturnValue' has a wrong offset!");

// Function TheK33.K33P02.GetHasteDurationAtLevel
// 0x0004 (0x0004 - 0x0000)
struct K33P02_GetHasteDurationAtLevel final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K33P02_GetHasteDurationAtLevel) == 0x000004, "Wrong alignment on K33P02_GetHasteDurationAtLevel");
static_assert(sizeof(K33P02_GetHasteDurationAtLevel) == 0x000004, "Wrong size on K33P02_GetHasteDurationAtLevel");
static_assert(offsetof(K33P02_GetHasteDurationAtLevel, ReturnValue) == 0x000000, "Member 'K33P02_GetHasteDurationAtLevel::ReturnValue' has a wrong offset!");

// Function TheK33.K33P03.GetObliviousDurationAtLevel
// 0x0004 (0x0004 - 0x0000)
struct K33P03_GetObliviousDurationAtLevel final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K33P03_GetObliviousDurationAtLevel) == 0x000004, "Wrong alignment on K33P03_GetObliviousDurationAtLevel");
static_assert(sizeof(K33P03_GetObliviousDurationAtLevel) == 0x000004, "Wrong size on K33P03_GetObliviousDurationAtLevel");
static_assert(offsetof(K33P03_GetObliviousDurationAtLevel, ReturnValue) == 0x000000, "Member 'K33P03_GetObliviousDurationAtLevel::ReturnValue' has a wrong offset!");

// Function TheK33.K33P03.GetPerkAuraRevealDurationAtLevel
// 0x0004 (0x0004 - 0x0000)
struct K33P03_GetPerkAuraRevealDurationAtLevel final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K33P03_GetPerkAuraRevealDurationAtLevel) == 0x000004, "Wrong alignment on K33P03_GetPerkAuraRevealDurationAtLevel");
static_assert(sizeof(K33P03_GetPerkAuraRevealDurationAtLevel) == 0x000004, "Wrong size on K33P03_GetPerkAuraRevealDurationAtLevel");
static_assert(offsetof(K33P03_GetPerkAuraRevealDurationAtLevel, ReturnValue) == 0x000000, "Member 'K33P03_GetPerkAuraRevealDurationAtLevel::ReturnValue' has a wrong offset!");

// Function TheK33.K33Power.GetTailAttackInteraction
// 0x0008 (0x0008 - 0x0000)
struct K33Power_GetTailAttackInteraction final
{
public:
	class UK33TailAttackInteraction*              ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K33Power_GetTailAttackInteraction) == 0x000008, "Wrong alignment on K33Power_GetTailAttackInteraction");
static_assert(sizeof(K33Power_GetTailAttackInteraction) == 0x000008, "Wrong size on K33Power_GetTailAttackInteraction");
static_assert(offsetof(K33Power_GetTailAttackInteraction, ReturnValue) == 0x000000, "Member 'K33Power_GetTailAttackInteraction::ReturnValue' has a wrong offset!");

// Function TheK33.K33Power_Addon_16.BP_TriggerSurvivorScreamAndReveal
// 0x0008 (0x0008 - 0x0000)
struct K33Power_Addon_16_BP_TriggerSurvivorScreamAndReveal final
{
public:
	class ACamperPlayer*                          TargetSurvivor;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K33Power_Addon_16_BP_TriggerSurvivorScreamAndReveal) == 0x000008, "Wrong alignment on K33Power_Addon_16_BP_TriggerSurvivorScreamAndReveal");
static_assert(sizeof(K33Power_Addon_16_BP_TriggerSurvivorScreamAndReveal) == 0x000008, "Wrong size on K33Power_Addon_16_BP_TriggerSurvivorScreamAndReveal");
static_assert(offsetof(K33Power_Addon_16_BP_TriggerSurvivorScreamAndReveal, TargetSurvivor) == 0x000000, "Member 'K33Power_Addon_16_BP_TriggerSurvivorScreamAndReveal::TargetSurvivor' has a wrong offset!");

// Function TheK33.K33Power_Addon_16.Multicast_TriggerSurvivorsScreamAndReveal
// 0x0010 (0x0010 - 0x0000)
struct K33Power_Addon_16_Multicast_TriggerSurvivorsScreamAndReveal final
{
public:
	TArray<class ACamperPlayer*>                  TargetSurvivors;                                   // 0x0000(0x0010)(ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(K33Power_Addon_16_Multicast_TriggerSurvivorsScreamAndReveal) == 0x000008, "Wrong alignment on K33Power_Addon_16_Multicast_TriggerSurvivorsScreamAndReveal");
static_assert(sizeof(K33Power_Addon_16_Multicast_TriggerSurvivorsScreamAndReveal) == 0x000010, "Wrong size on K33Power_Addon_16_Multicast_TriggerSurvivorsScreamAndReveal");
static_assert(offsetof(K33Power_Addon_16_Multicast_TriggerSurvivorsScreamAndReveal, TargetSurvivors) == 0x000000, "Member 'K33Power_Addon_16_Multicast_TriggerSurvivorsScreamAndReveal::TargetSurvivors' has a wrong offset!");

// Function TheK33.K33TunnelBlock.GetEnterTunnelTeleportLocation
// 0x0018 (0x0018 - 0x0000)
struct K33TunnelBlock_GetEnterTunnelTeleportLocation final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K33TunnelBlock_GetEnterTunnelTeleportLocation) == 0x000008, "Wrong alignment on K33TunnelBlock_GetEnterTunnelTeleportLocation");
static_assert(sizeof(K33TunnelBlock_GetEnterTunnelTeleportLocation) == 0x000018, "Wrong size on K33TunnelBlock_GetEnterTunnelTeleportLocation");
static_assert(offsetof(K33TunnelBlock_GetEnterTunnelTeleportLocation, ReturnValue) == 0x000000, "Member 'K33TunnelBlock_GetEnterTunnelTeleportLocation::ReturnValue' has a wrong offset!");

// Function TheK33.K33TunnelBlock.GetExitTunnelInteractableSpawnLocation
// 0x0018 (0x0018 - 0x0000)
struct K33TunnelBlock_GetExitTunnelInteractableSpawnLocation final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K33TunnelBlock_GetExitTunnelInteractableSpawnLocation) == 0x000008, "Wrong alignment on K33TunnelBlock_GetExitTunnelInteractableSpawnLocation");
static_assert(sizeof(K33TunnelBlock_GetExitTunnelInteractableSpawnLocation) == 0x000018, "Wrong size on K33TunnelBlock_GetExitTunnelInteractableSpawnLocation");
static_assert(offsetof(K33TunnelBlock_GetExitTunnelInteractableSpawnLocation, ReturnValue) == 0x000000, "Member 'K33TunnelBlock_GetExitTunnelInteractableSpawnLocation::ReturnValue' has a wrong offset!");

// Function TheK33.K33TunnelBlock.GetExitTunnelInteractableSpawnRotation
// 0x0018 (0x0018 - 0x0000)
struct K33TunnelBlock_GetExitTunnelInteractableSpawnRotation final
{
public:
	struct FRotator                               ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(K33TunnelBlock_GetExitTunnelInteractableSpawnRotation) == 0x000008, "Wrong alignment on K33TunnelBlock_GetExitTunnelInteractableSpawnRotation");
static_assert(sizeof(K33TunnelBlock_GetExitTunnelInteractableSpawnRotation) == 0x000018, "Wrong size on K33TunnelBlock_GetExitTunnelInteractableSpawnRotation");
static_assert(offsetof(K33TunnelBlock_GetExitTunnelInteractableSpawnRotation, ReturnValue) == 0x000000, "Member 'K33TunnelBlock_GetExitTunnelInteractableSpawnRotation::ReturnValue' has a wrong offset!");

// Function TheK33.K33SpecialModeComponent.OnPowerChargeChanged
// 0x0004 (0x0004 - 0x0000)
struct K33SpecialModeComponent_OnPowerChargeChanged final
{
public:
	float                                         CurrentChargePercent;                              // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K33SpecialModeComponent_OnPowerChargeChanged) == 0x000004, "Wrong alignment on K33SpecialModeComponent_OnPowerChargeChanged");
static_assert(sizeof(K33SpecialModeComponent_OnPowerChargeChanged) == 0x000004, "Wrong size on K33SpecialModeComponent_OnPowerChargeChanged");
static_assert(offsetof(K33SpecialModeComponent_OnPowerChargeChanged, CurrentChargePercent) == 0x000000, "Member 'K33SpecialModeComponent_OnPowerChargeChanged::CurrentChargePercent' has a wrong offset!");

// Function TheK33.K33SurvivorCosmeticHelperActor.Cosmetic_InitializeTurretPlacementVisualFeedback
// 0x000C (0x000C - 0x0000)
struct K33SurvivorCosmeticHelperActor_Cosmetic_InitializeTurretPlacementVisualFeedback final
{
public:
	class FName                                   SocketName;                                        // 0x0000(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K33SurvivorCosmeticHelperActor_Cosmetic_InitializeTurretPlacementVisualFeedback) == 0x000004, "Wrong alignment on K33SurvivorCosmeticHelperActor_Cosmetic_InitializeTurretPlacementVisualFeedback");
static_assert(sizeof(K33SurvivorCosmeticHelperActor_Cosmetic_InitializeTurretPlacementVisualFeedback) == 0x00000C, "Wrong size on K33SurvivorCosmeticHelperActor_Cosmetic_InitializeTurretPlacementVisualFeedback");
static_assert(offsetof(K33SurvivorCosmeticHelperActor_Cosmetic_InitializeTurretPlacementVisualFeedback, SocketName) == 0x000000, "Member 'K33SurvivorCosmeticHelperActor_Cosmetic_InitializeTurretPlacementVisualFeedback::SocketName' has a wrong offset!");

// Function TheK33.K33SurvivorCosmeticHelperActor.Cosmetic_OnTurretPlacementValidityChanged
// 0x0001 (0x0001 - 0x0000)
struct K33SurvivorCosmeticHelperActor_Cosmetic_OnTurretPlacementValidityChanged final
{
public:
	bool                                          IsPlacementValid;                                  // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K33SurvivorCosmeticHelperActor_Cosmetic_OnTurretPlacementValidityChanged) == 0x000001, "Wrong alignment on K33SurvivorCosmeticHelperActor_Cosmetic_OnTurretPlacementValidityChanged");
static_assert(sizeof(K33SurvivorCosmeticHelperActor_Cosmetic_OnTurretPlacementValidityChanged) == 0x000001, "Wrong size on K33SurvivorCosmeticHelperActor_Cosmetic_OnTurretPlacementValidityChanged");
static_assert(offsetof(K33SurvivorCosmeticHelperActor_Cosmetic_OnTurretPlacementValidityChanged, IsPlacementValid) == 0x000000, "Member 'K33SurvivorCosmeticHelperActor_Cosmetic_OnTurretPlacementValidityChanged::IsPlacementValid' has a wrong offset!");

// Function TheK33.K33SurvivorCosmeticHelperActor.Cosmetic_OnTurretPlacementVisualFeedbackActivationChanged
// 0x0002 (0x0002 - 0x0000)
struct K33SurvivorCosmeticHelperActor_Cosmetic_OnTurretPlacementVisualFeedbackActivationChanged final
{
public:
	bool                                          Activated;                                         // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsPlacementValid;                                  // 0x0001(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K33SurvivorCosmeticHelperActor_Cosmetic_OnTurretPlacementVisualFeedbackActivationChanged) == 0x000001, "Wrong alignment on K33SurvivorCosmeticHelperActor_Cosmetic_OnTurretPlacementVisualFeedbackActivationChanged");
static_assert(sizeof(K33SurvivorCosmeticHelperActor_Cosmetic_OnTurretPlacementVisualFeedbackActivationChanged) == 0x000002, "Wrong size on K33SurvivorCosmeticHelperActor_Cosmetic_OnTurretPlacementVisualFeedbackActivationChanged");
static_assert(offsetof(K33SurvivorCosmeticHelperActor_Cosmetic_OnTurretPlacementVisualFeedbackActivationChanged, Activated) == 0x000000, "Member 'K33SurvivorCosmeticHelperActor_Cosmetic_OnTurretPlacementVisualFeedbackActivationChanged::Activated' has a wrong offset!");
static_assert(offsetof(K33SurvivorCosmeticHelperActor_Cosmetic_OnTurretPlacementVisualFeedbackActivationChanged, IsPlacementValid) == 0x000001, "Member 'K33SurvivorCosmeticHelperActor_Cosmetic_OnTurretPlacementVisualFeedbackActivationChanged::IsPlacementValid' has a wrong offset!");

// Function TheK33.K33SurvivorCosmeticHelperActor.Cosmetic_UpdateTurretLaserPlacement
// 0x0030 (0x0030 - 0x0000)
struct K33SurvivorCosmeticHelperActor_Cosmetic_UpdateTurretLaserPlacement final
{
public:
	struct FVector                                PlacementLocation;                                 // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               PlacementRotation;                                 // 0x0018(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(K33SurvivorCosmeticHelperActor_Cosmetic_UpdateTurretLaserPlacement) == 0x000008, "Wrong alignment on K33SurvivorCosmeticHelperActor_Cosmetic_UpdateTurretLaserPlacement");
static_assert(sizeof(K33SurvivorCosmeticHelperActor_Cosmetic_UpdateTurretLaserPlacement) == 0x000030, "Wrong size on K33SurvivorCosmeticHelperActor_Cosmetic_UpdateTurretLaserPlacement");
static_assert(offsetof(K33SurvivorCosmeticHelperActor_Cosmetic_UpdateTurretLaserPlacement, PlacementLocation) == 0x000000, "Member 'K33SurvivorCosmeticHelperActor_Cosmetic_UpdateTurretLaserPlacement::PlacementLocation' has a wrong offset!");
static_assert(offsetof(K33SurvivorCosmeticHelperActor_Cosmetic_UpdateTurretLaserPlacement, PlacementRotation) == 0x000018, "Member 'K33SurvivorCosmeticHelperActor_Cosmetic_UpdateTurretLaserPlacement::PlacementRotation' has a wrong offset!");

// Function TheK33.K33SurvivorCosmeticHelperActor.GetCarriedTurret
// 0x0008 (0x0008 - 0x0000)
struct K33SurvivorCosmeticHelperActor_GetCarriedTurret final
{
public:
	class AK33Turret*                             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K33SurvivorCosmeticHelperActor_GetCarriedTurret) == 0x000008, "Wrong alignment on K33SurvivorCosmeticHelperActor_GetCarriedTurret");
static_assert(sizeof(K33SurvivorCosmeticHelperActor_GetCarriedTurret) == 0x000008, "Wrong size on K33SurvivorCosmeticHelperActor_GetCarriedTurret");
static_assert(offsetof(K33SurvivorCosmeticHelperActor_GetCarriedTurret, ReturnValue) == 0x000000, "Member 'K33SurvivorCosmeticHelperActor_GetCarriedTurret::ReturnValue' has a wrong offset!");

// Function TheK33.K33SurvivorDetectionComponent.Authority_OnSurvivorInRangeChanged
// 0x0010 (0x0010 - 0x0000)
struct K33SurvivorDetectionComponent_Authority_OnSurvivorInRangeChanged final
{
public:
	bool                                          InRange;                                           // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ACamperPlayer*                          Player;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K33SurvivorDetectionComponent_Authority_OnSurvivorInRangeChanged) == 0x000008, "Wrong alignment on K33SurvivorDetectionComponent_Authority_OnSurvivorInRangeChanged");
static_assert(sizeof(K33SurvivorDetectionComponent_Authority_OnSurvivorInRangeChanged) == 0x000010, "Wrong size on K33SurvivorDetectionComponent_Authority_OnSurvivorInRangeChanged");
static_assert(offsetof(K33SurvivorDetectionComponent_Authority_OnSurvivorInRangeChanged, InRange) == 0x000000, "Member 'K33SurvivorDetectionComponent_Authority_OnSurvivorInRangeChanged::InRange' has a wrong offset!");
static_assert(offsetof(K33SurvivorDetectionComponent_Authority_OnSurvivorInRangeChanged, Player) == 0x000008, "Member 'K33SurvivorDetectionComponent_Authority_OnSurvivorInRangeChanged::Player' has a wrong offset!");

// Function TheK33.K33TunnelBlockCosmetic.Cosmetic_EnableTunnelVFXPathLight
// 0x0030 (0x0030 - 0x0000)
struct K33TunnelBlockCosmetic_Cosmetic_EnableTunnelVFXPathLight final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0018(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(K33TunnelBlockCosmetic_Cosmetic_EnableTunnelVFXPathLight) == 0x000008, "Wrong alignment on K33TunnelBlockCosmetic_Cosmetic_EnableTunnelVFXPathLight");
static_assert(sizeof(K33TunnelBlockCosmetic_Cosmetic_EnableTunnelVFXPathLight) == 0x000030, "Wrong size on K33TunnelBlockCosmetic_Cosmetic_EnableTunnelVFXPathLight");
static_assert(offsetof(K33TunnelBlockCosmetic_Cosmetic_EnableTunnelVFXPathLight, Location) == 0x000000, "Member 'K33TunnelBlockCosmetic_Cosmetic_EnableTunnelVFXPathLight::Location' has a wrong offset!");
static_assert(offsetof(K33TunnelBlockCosmetic_Cosmetic_EnableTunnelVFXPathLight, Rotation) == 0x000018, "Member 'K33TunnelBlockCosmetic_Cosmetic_EnableTunnelVFXPathLight::Rotation' has a wrong offset!");

// Function TheK33.K33TunnelBlockCosmetic.Cosmetic_OnTunnelBlockExitSelected
// 0x0001 (0x0001 - 0x0000)
struct K33TunnelBlockCosmetic_Cosmetic_OnTunnelBlockExitSelected final
{
public:
	bool                                          IsSelected;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K33TunnelBlockCosmetic_Cosmetic_OnTunnelBlockExitSelected) == 0x000001, "Wrong alignment on K33TunnelBlockCosmetic_Cosmetic_OnTunnelBlockExitSelected");
static_assert(sizeof(K33TunnelBlockCosmetic_Cosmetic_OnTunnelBlockExitSelected) == 0x000001, "Wrong size on K33TunnelBlockCosmetic_Cosmetic_OnTunnelBlockExitSelected");
static_assert(offsetof(K33TunnelBlockCosmetic_Cosmetic_OnTunnelBlockExitSelected, IsSelected) == 0x000000, "Member 'K33TunnelBlockCosmetic_Cosmetic_OnTunnelBlockExitSelected::IsSelected' has a wrong offset!");

// Function TheK33.K33TunnelBlockCosmetic.Cosmetic_SetTunnelExitAsBlocked
// 0x0001 (0x0001 - 0x0000)
struct K33TunnelBlockCosmetic_Cosmetic_SetTunnelExitAsBlocked final
{
public:
	bool                                          IsBlocked;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K33TunnelBlockCosmetic_Cosmetic_SetTunnelExitAsBlocked) == 0x000001, "Wrong alignment on K33TunnelBlockCosmetic_Cosmetic_SetTunnelExitAsBlocked");
static_assert(sizeof(K33TunnelBlockCosmetic_Cosmetic_SetTunnelExitAsBlocked) == 0x000001, "Wrong size on K33TunnelBlockCosmetic_Cosmetic_SetTunnelExitAsBlocked");
static_assert(offsetof(K33TunnelBlockCosmetic_Cosmetic_SetTunnelExitAsBlocked, IsBlocked) == 0x000000, "Member 'K33TunnelBlockCosmetic_Cosmetic_SetTunnelExitAsBlocked::IsBlocked' has a wrong offset!");

// Function TheK33.K33TunnelBlockCosmetic.GetExitTunnelLocation
// 0x0018 (0x0018 - 0x0000)
struct K33TunnelBlockCosmetic_GetExitTunnelLocation final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K33TunnelBlockCosmetic_GetExitTunnelLocation) == 0x000008, "Wrong alignment on K33TunnelBlockCosmetic_GetExitTunnelLocation");
static_assert(sizeof(K33TunnelBlockCosmetic_GetExitTunnelLocation) == 0x000018, "Wrong size on K33TunnelBlockCosmetic_GetExitTunnelLocation");
static_assert(offsetof(K33TunnelBlockCosmetic_GetExitTunnelLocation, ReturnValue) == 0x000000, "Member 'K33TunnelBlockCosmetic_GetExitTunnelLocation::ReturnValue' has a wrong offset!");

// Function TheK33.K33TurretDestructionComponent.GetTurretDestructionDisappearanceDelay
// 0x0004 (0x0004 - 0x0000)
struct K33TurretDestructionComponent_GetTurretDestructionDisappearanceDelay final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K33TurretDestructionComponent_GetTurretDestructionDisappearanceDelay) == 0x000004, "Wrong alignment on K33TurretDestructionComponent_GetTurretDestructionDisappearanceDelay");
static_assert(sizeof(K33TurretDestructionComponent_GetTurretDestructionDisappearanceDelay) == 0x000004, "Wrong size on K33TurretDestructionComponent_GetTurretDestructionDisappearanceDelay");
static_assert(offsetof(K33TurretDestructionComponent_GetTurretDestructionDisappearanceDelay, ReturnValue) == 0x000000, "Member 'K33TurretDestructionComponent_GetTurretDestructionDisappearanceDelay::ReturnValue' has a wrong offset!");

// Function TheK33.K33TurretRepairInteraction.Authority_OnChargeApplied
// 0x0018 (0x0018 - 0x0000)
struct K33TurretRepairInteraction_Authority_OnChargeApplied final
{
public:
	float                                         IndividualChargeAmount;                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TotalChargeAmount;                                 // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 ChargeInstigator;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          WasCoop;                                           // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DeltaTime;                                         // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K33TurretRepairInteraction_Authority_OnChargeApplied) == 0x000008, "Wrong alignment on K33TurretRepairInteraction_Authority_OnChargeApplied");
static_assert(sizeof(K33TurretRepairInteraction_Authority_OnChargeApplied) == 0x000018, "Wrong size on K33TurretRepairInteraction_Authority_OnChargeApplied");
static_assert(offsetof(K33TurretRepairInteraction_Authority_OnChargeApplied, IndividualChargeAmount) == 0x000000, "Member 'K33TurretRepairInteraction_Authority_OnChargeApplied::IndividualChargeAmount' has a wrong offset!");
static_assert(offsetof(K33TurretRepairInteraction_Authority_OnChargeApplied, TotalChargeAmount) == 0x000004, "Member 'K33TurretRepairInteraction_Authority_OnChargeApplied::TotalChargeAmount' has a wrong offset!");
static_assert(offsetof(K33TurretRepairInteraction_Authority_OnChargeApplied, ChargeInstigator) == 0x000008, "Member 'K33TurretRepairInteraction_Authority_OnChargeApplied::ChargeInstigator' has a wrong offset!");
static_assert(offsetof(K33TurretRepairInteraction_Authority_OnChargeApplied, WasCoop) == 0x000010, "Member 'K33TurretRepairInteraction_Authority_OnChargeApplied::WasCoop' has a wrong offset!");
static_assert(offsetof(K33TurretRepairInteraction_Authority_OnChargeApplied, DeltaTime) == 0x000014, "Member 'K33TurretRepairInteraction_Authority_OnChargeApplied::DeltaTime' has a wrong offset!");

// Function TheK33.K33Utilities.GetAvailableTurretsCountInPool
// 0x0010 (0x0010 - 0x0000)
struct K33Utilities_GetAvailableTurretsCountInPool final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(K33Utilities_GetAvailableTurretsCountInPool) == 0x000008, "Wrong alignment on K33Utilities_GetAvailableTurretsCountInPool");
static_assert(sizeof(K33Utilities_GetAvailableTurretsCountInPool) == 0x000010, "Wrong size on K33Utilities_GetAvailableTurretsCountInPool");
static_assert(offsetof(K33Utilities_GetAvailableTurretsCountInPool, WorldContextObject) == 0x000000, "Member 'K33Utilities_GetAvailableTurretsCountInPool::WorldContextObject' has a wrong offset!");
static_assert(offsetof(K33Utilities_GetAvailableTurretsCountInPool, ReturnValue) == 0x000008, "Member 'K33Utilities_GetAvailableTurretsCountInPool::ReturnValue' has a wrong offset!");

// Function TheK33.K33Utilities.GetK33Husk
// 0x0010 (0x0010 - 0x0000)
struct K33Utilities_GetK33Husk final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AK33Husk*                               ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K33Utilities_GetK33Husk) == 0x000008, "Wrong alignment on K33Utilities_GetK33Husk");
static_assert(sizeof(K33Utilities_GetK33Husk) == 0x000010, "Wrong size on K33Utilities_GetK33Husk");
static_assert(offsetof(K33Utilities_GetK33Husk, WorldContextObject) == 0x000000, "Member 'K33Utilities_GetK33Husk::WorldContextObject' has a wrong offset!");
static_assert(offsetof(K33Utilities_GetK33Husk, ReturnValue) == 0x000008, "Member 'K33Utilities_GetK33Husk::ReturnValue' has a wrong offset!");

// Function TheK33.K33Utilities.GetK33Power
// 0x0010 (0x0010 - 0x0000)
struct K33Utilities_GetK33Power final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AK33Power*                              ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K33Utilities_GetK33Power) == 0x000008, "Wrong alignment on K33Utilities_GetK33Power");
static_assert(sizeof(K33Utilities_GetK33Power) == 0x000010, "Wrong size on K33Utilities_GetK33Power");
static_assert(offsetof(K33Utilities_GetK33Power, WorldContextObject) == 0x000000, "Member 'K33Utilities_GetK33Power::WorldContextObject' has a wrong offset!");
static_assert(offsetof(K33Utilities_GetK33Power, ReturnValue) == 0x000008, "Member 'K33Utilities_GetK33Power::ReturnValue' has a wrong offset!");

// Function TheK33.K33Utilities.GetK33VFXFeetPool
// 0x0010 (0x0010 - 0x0000)
struct K33Utilities_GetK33VFXFeetPool final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULocalActorPoolComponent*               ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K33Utilities_GetK33VFXFeetPool) == 0x000008, "Wrong alignment on K33Utilities_GetK33VFXFeetPool");
static_assert(sizeof(K33Utilities_GetK33VFXFeetPool) == 0x000010, "Wrong size on K33Utilities_GetK33VFXFeetPool");
static_assert(offsetof(K33Utilities_GetK33VFXFeetPool, WorldContextObject) == 0x000000, "Member 'K33Utilities_GetK33VFXFeetPool::WorldContextObject' has a wrong offset!");
static_assert(offsetof(K33Utilities_GetK33VFXFeetPool, ReturnValue) == 0x000008, "Member 'K33Utilities_GetK33VFXFeetPool::ReturnValue' has a wrong offset!");

// Function TheK33.K33Utilities.GetSpecialModeComponent
// 0x0010 (0x0010 - 0x0000)
struct K33Utilities_GetSpecialModeComponent final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UK33SpecialModeComponent*               ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K33Utilities_GetSpecialModeComponent) == 0x000008, "Wrong alignment on K33Utilities_GetSpecialModeComponent");
static_assert(sizeof(K33Utilities_GetSpecialModeComponent) == 0x000010, "Wrong size on K33Utilities_GetSpecialModeComponent");
static_assert(offsetof(K33Utilities_GetSpecialModeComponent, WorldContextObject) == 0x000000, "Member 'K33Utilities_GetSpecialModeComponent::WorldContextObject' has a wrong offset!");
static_assert(offsetof(K33Utilities_GetSpecialModeComponent, ReturnValue) == 0x000008, "Member 'K33Utilities_GetSpecialModeComponent::ReturnValue' has a wrong offset!");

// Function TheK33.K33Utilities.GetTurretsPool
// 0x0010 (0x0010 - 0x0000)
struct K33Utilities_GetTurretsPool final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAuthoritativeActorPoolComponent*       ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K33Utilities_GetTurretsPool) == 0x000008, "Wrong alignment on K33Utilities_GetTurretsPool");
static_assert(sizeof(K33Utilities_GetTurretsPool) == 0x000010, "Wrong size on K33Utilities_GetTurretsPool");
static_assert(offsetof(K33Utilities_GetTurretsPool, WorldContextObject) == 0x000000, "Member 'K33Utilities_GetTurretsPool::WorldContextObject' has a wrong offset!");
static_assert(offsetof(K33Utilities_GetTurretsPool, ReturnValue) == 0x000008, "Member 'K33Utilities_GetTurretsPool::ReturnValue' has a wrong offset!");

// Function TheK33.MapObjectsCheatComponent.DBD_ShowFatherKey
// 0x0001 (0x0001 - 0x0000)
struct MapObjectsCheatComponent_DBD_ShowFatherKey final
{
public:
	bool                                          Enable;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MapObjectsCheatComponent_DBD_ShowFatherKey) == 0x000001, "Wrong alignment on MapObjectsCheatComponent_DBD_ShowFatherKey");
static_assert(sizeof(MapObjectsCheatComponent_DBD_ShowFatherKey) == 0x000001, "Wrong size on MapObjectsCheatComponent_DBD_ShowFatherKey");
static_assert(offsetof(MapObjectsCheatComponent_DBD_ShowFatherKey, Enable) == 0x000000, "Member 'MapObjectsCheatComponent_DBD_ShowFatherKey::Enable' has a wrong offset!");

// Function TheK33.MapObjectsCheatComponent.DBD_ShowQuesita
// 0x0001 (0x0001 - 0x0000)
struct MapObjectsCheatComponent_DBD_ShowQuesita final
{
public:
	bool                                          Enable;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MapObjectsCheatComponent_DBD_ShowQuesita) == 0x000001, "Wrong alignment on MapObjectsCheatComponent_DBD_ShowQuesita");
static_assert(sizeof(MapObjectsCheatComponent_DBD_ShowQuesita) == 0x000001, "Wrong size on MapObjectsCheatComponent_DBD_ShowQuesita");
static_assert(offsetof(MapObjectsCheatComponent_DBD_ShowQuesita, Enable) == 0x000000, "Member 'MapObjectsCheatComponent_DBD_ShowQuesita::Enable' has a wrong offset!");

// Function TheK33.QuesitaManagerComponent.Authority_OnLockerInteractorChanged
// 0x0001 (0x0001 - 0x0000)
struct QuesitaManagerComponent_Authority_OnLockerInteractorChanged final
{
public:
	bool                                          IsLocked;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(QuesitaManagerComponent_Authority_OnLockerInteractorChanged) == 0x000001, "Wrong alignment on QuesitaManagerComponent_Authority_OnLockerInteractorChanged");
static_assert(sizeof(QuesitaManagerComponent_Authority_OnLockerInteractorChanged) == 0x000001, "Wrong size on QuesitaManagerComponent_Authority_OnLockerInteractorChanged");
static_assert(offsetof(QuesitaManagerComponent_Authority_OnLockerInteractorChanged, IsLocked) == 0x000000, "Member 'QuesitaManagerComponent_Authority_OnLockerInteractorChanged::IsLocked' has a wrong offset!");

// Function TheK33.QuesitaManagerComponent.OnRep_QuesitaLocker
// 0x0008 (0x0008 - 0x0000)
struct QuesitaManagerComponent_OnRep_QuesitaLocker final
{
public:
	class ALocker*                                LastLocker;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(QuesitaManagerComponent_OnRep_QuesitaLocker) == 0x000008, "Wrong alignment on QuesitaManagerComponent_OnRep_QuesitaLocker");
static_assert(sizeof(QuesitaManagerComponent_OnRep_QuesitaLocker) == 0x000008, "Wrong size on QuesitaManagerComponent_OnRep_QuesitaLocker");
static_assert(offsetof(QuesitaManagerComponent_OnRep_QuesitaLocker, LastLocker) == 0x000000, "Member 'QuesitaManagerComponent_OnRep_QuesitaLocker::LastLocker' has a wrong offset!");

// Function TheK33.WormholeFatherDoorAnimInstance.OnStateChanged
// 0x0001 (0x0001 - 0x0000)
struct WormholeFatherDoorAnimInstance_OnStateChanged final
{
public:
	bool                                          HasBeenHacked;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WormholeFatherDoorAnimInstance_OnStateChanged) == 0x000001, "Wrong alignment on WormholeFatherDoorAnimInstance_OnStateChanged");
static_assert(sizeof(WormholeFatherDoorAnimInstance_OnStateChanged) == 0x000001, "Wrong size on WormholeFatherDoorAnimInstance_OnStateChanged");
static_assert(offsetof(WormholeFatherDoorAnimInstance_OnStateChanged, HasBeenHacked) == 0x000000, "Member 'WormholeFatherDoorAnimInstance_OnStateChanged::HasBeenHacked' has a wrong offset!");

// Function TheK33.WormholeFatherHackableActor.OnHackedEvent
// 0x0040 (0x0040 - 0x0000)
struct WormholeFatherHackableActor_OnHackedEvent final
{
public:
	struct FGameplayTag                           GameEvent;                                         // 0x0000(0x000C)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameEventData                         GameEventData;                                     // 0x0010(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(WormholeFatherHackableActor_OnHackedEvent) == 0x000008, "Wrong alignment on WormholeFatherHackableActor_OnHackedEvent");
static_assert(sizeof(WormholeFatherHackableActor_OnHackedEvent) == 0x000040, "Wrong size on WormholeFatherHackableActor_OnHackedEvent");
static_assert(offsetof(WormholeFatherHackableActor_OnHackedEvent, GameEvent) == 0x000000, "Member 'WormholeFatherHackableActor_OnHackedEvent::GameEvent' has a wrong offset!");
static_assert(offsetof(WormholeFatherHackableActor_OnHackedEvent, GameEventData) == 0x000010, "Member 'WormholeFatherHackableActor_OnHackedEvent::GameEventData' has a wrong offset!");

// DelegateFunction TheK33.WormholeFatherHackingComponent.OnWrmFatherHackedStateChangedDelegate__DelegateSignature
// 0x0001 (0x0001 - 0x0000)
struct WormholeFatherHackingComponent_OnWrmFatherHackedStateChangedDelegate__DelegateSignature final
{
public:
	bool                                          HasBeenHacked;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WormholeFatherHackingComponent_OnWrmFatherHackedStateChangedDelegate__DelegateSignature) == 0x000001, "Wrong alignment on WormholeFatherHackingComponent_OnWrmFatherHackedStateChangedDelegate__DelegateSignature");
static_assert(sizeof(WormholeFatherHackingComponent_OnWrmFatherHackedStateChangedDelegate__DelegateSignature) == 0x000001, "Wrong size on WormholeFatherHackingComponent_OnWrmFatherHackedStateChangedDelegate__DelegateSignature");
static_assert(offsetof(WormholeFatherHackingComponent_OnWrmFatherHackedStateChangedDelegate__DelegateSignature, HasBeenHacked) == 0x000000, "Member 'WormholeFatherHackingComponent_OnWrmFatherHackedStateChangedDelegate__DelegateSignature::HasBeenHacked' has a wrong offset!");

// Function TheK33.WormholeFatherHackingComponent.SetHasBeenHacked
// 0x0001 (0x0001 - 0x0000)
struct WormholeFatherHackingComponent_SetHasBeenHacked final
{
public:
	bool                                          HasBeenHacked;                                     // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WormholeFatherHackingComponent_SetHasBeenHacked) == 0x000001, "Wrong alignment on WormholeFatherHackingComponent_SetHasBeenHacked");
static_assert(sizeof(WormholeFatherHackingComponent_SetHasBeenHacked) == 0x000001, "Wrong size on WormholeFatherHackingComponent_SetHasBeenHacked");
static_assert(offsetof(WormholeFatherHackingComponent_SetHasBeenHacked, HasBeenHacked) == 0x000000, "Member 'WormholeFatherHackingComponent_SetHasBeenHacked::HasBeenHacked' has a wrong offset!");

// Function TheK33.WormholeFatherHackingComponent.HasBeenHacked
// 0x0001 (0x0001 - 0x0000)
struct WormholeFatherHackingComponent_HasBeenHacked final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WormholeFatherHackingComponent_HasBeenHacked) == 0x000001, "Wrong alignment on WormholeFatherHackingComponent_HasBeenHacked");
static_assert(sizeof(WormholeFatherHackingComponent_HasBeenHacked) == 0x000001, "Wrong size on WormholeFatherHackingComponent_HasBeenHacked");
static_assert(offsetof(WormholeFatherHackingComponent_HasBeenHacked, ReturnValue) == 0x000000, "Member 'WormholeFatherHackingComponent_HasBeenHacked::ReturnValue' has a wrong offset!");

// Function TheK33.WormholeFatherKeyCard.ApplyInitialTag
// 0x0008 (0x0008 - 0x0000)
struct WormholeFatherKeyCard_ApplyInitialTag final
{
public:
	class ADBDPlayer*                             Character;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WormholeFatherKeyCard_ApplyInitialTag) == 0x000008, "Wrong alignment on WormholeFatherKeyCard_ApplyInitialTag");
static_assert(sizeof(WormholeFatherKeyCard_ApplyInitialTag) == 0x000008, "Wrong size on WormholeFatherKeyCard_ApplyInitialTag");
static_assert(offsetof(WormholeFatherKeyCard_ApplyInitialTag, Character) == 0x000000, "Member 'WormholeFatherKeyCard_ApplyInitialTag::Character' has a wrong offset!");

// Function TheK33.WormholeFatherKeyCard.GetKeyCardState
// 0x0001 (0x0001 - 0x0000)
struct WormholeFatherKeyCard_GetKeyCardState final
{
public:
	EFatherKeyCardState                           ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WormholeFatherKeyCard_GetKeyCardState) == 0x000001, "Wrong alignment on WormholeFatherKeyCard_GetKeyCardState");
static_assert(sizeof(WormholeFatherKeyCard_GetKeyCardState) == 0x000001, "Wrong size on WormholeFatherKeyCard_GetKeyCardState");
static_assert(offsetof(WormholeFatherKeyCard_GetKeyCardState, ReturnValue) == 0x000000, "Member 'WormholeFatherKeyCard_GetKeyCardState::ReturnValue' has a wrong offset!");

// Function TheK33.WormholeFatherKeyCard.RemoveInitialTag
// 0x0008 (0x0008 - 0x0000)
struct WormholeFatherKeyCard_RemoveInitialTag final
{
public:
	class ADBDPlayer*                             Character;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WormholeFatherKeyCard_RemoveInitialTag) == 0x000008, "Wrong alignment on WormholeFatherKeyCard_RemoveInitialTag");
static_assert(sizeof(WormholeFatherKeyCard_RemoveInitialTag) == 0x000008, "Wrong size on WormholeFatherKeyCard_RemoveInitialTag");
static_assert(offsetof(WormholeFatherKeyCard_RemoveInitialTag, Character) == 0x000000, "Member 'WormholeFatherKeyCard_RemoveInitialTag::Character' has a wrong offset!");

// Function TheK33.WormholeFatherRoomZoneOverlap.OnOverlapEnter
// 0x0110 (0x0110 - 0x0000)
struct WormholeFatherRoomZoneOverlap_OnOverlapEnter final
{
public:
	class UPrimitiveComponent*                    HitComponent;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x00F0)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(WormholeFatherRoomZoneOverlap_OnOverlapEnter) == 0x000008, "Wrong alignment on WormholeFatherRoomZoneOverlap_OnOverlapEnter");
static_assert(sizeof(WormholeFatherRoomZoneOverlap_OnOverlapEnter) == 0x000110, "Wrong size on WormholeFatherRoomZoneOverlap_OnOverlapEnter");
static_assert(offsetof(WormholeFatherRoomZoneOverlap_OnOverlapEnter, HitComponent) == 0x000000, "Member 'WormholeFatherRoomZoneOverlap_OnOverlapEnter::HitComponent' has a wrong offset!");
static_assert(offsetof(WormholeFatherRoomZoneOverlap_OnOverlapEnter, OtherActor) == 0x000008, "Member 'WormholeFatherRoomZoneOverlap_OnOverlapEnter::OtherActor' has a wrong offset!");
static_assert(offsetof(WormholeFatherRoomZoneOverlap_OnOverlapEnter, OtherComp) == 0x000010, "Member 'WormholeFatherRoomZoneOverlap_OnOverlapEnter::OtherComp' has a wrong offset!");
static_assert(offsetof(WormholeFatherRoomZoneOverlap_OnOverlapEnter, OtherBodyIndex) == 0x000018, "Member 'WormholeFatherRoomZoneOverlap_OnOverlapEnter::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(WormholeFatherRoomZoneOverlap_OnOverlapEnter, bFromSweep) == 0x00001C, "Member 'WormholeFatherRoomZoneOverlap_OnOverlapEnter::bFromSweep' has a wrong offset!");
static_assert(offsetof(WormholeFatherRoomZoneOverlap_OnOverlapEnter, SweepResult) == 0x000020, "Member 'WormholeFatherRoomZoneOverlap_OnOverlapEnter::SweepResult' has a wrong offset!");

// Function TheK33.WormholeFatherRoomZoneOverlap.OnOverlapExit
// 0x0020 (0x0020 - 0x0000)
struct WormholeFatherRoomZoneOverlap_OnOverlapExit final
{
public:
	class UPrimitiveComponent*                    HitComponent;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(WormholeFatherRoomZoneOverlap_OnOverlapExit) == 0x000008, "Wrong alignment on WormholeFatherRoomZoneOverlap_OnOverlapExit");
static_assert(sizeof(WormholeFatherRoomZoneOverlap_OnOverlapExit) == 0x000020, "Wrong size on WormholeFatherRoomZoneOverlap_OnOverlapExit");
static_assert(offsetof(WormholeFatherRoomZoneOverlap_OnOverlapExit, HitComponent) == 0x000000, "Member 'WormholeFatherRoomZoneOverlap_OnOverlapExit::HitComponent' has a wrong offset!");
static_assert(offsetof(WormholeFatherRoomZoneOverlap_OnOverlapExit, OtherActor) == 0x000008, "Member 'WormholeFatherRoomZoneOverlap_OnOverlapExit::OtherActor' has a wrong offset!");
static_assert(offsetof(WormholeFatherRoomZoneOverlap_OnOverlapExit, OtherComp) == 0x000010, "Member 'WormholeFatherRoomZoneOverlap_OnOverlapExit::OtherComp' has a wrong offset!");
static_assert(offsetof(WormholeFatherRoomZoneOverlap_OnOverlapExit, OtherBodyIndex) == 0x000018, "Member 'WormholeFatherRoomZoneOverlap_OnOverlapExit::OtherBodyIndex' has a wrong offset!");

}

