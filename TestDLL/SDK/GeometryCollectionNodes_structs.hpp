#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: GeometryCollectionNodes

#include "Basic.hpp"

#include "Chaos_structs.hpp"
#include "DataflowCore_structs.hpp"
#include "GeometryCollectionEngine_structs.hpp"
#include "CoreUObject_structs.hpp"


namespace SDK
{

// Enum GeometryCollectionNodes.EDataflowFieldFalloffType
// NumValues: 0x0007
enum class EDataflowFieldFalloffType : uint8
{
	Dataflow_FieldFalloffType_None           = 0,
	Dataflow_FieldFalloffType_Linear         = 1,
	Dataflow_FieldFalloffType_Inverse        = 2,
	Dataflow_FieldFalloffType_Squared        = 3,
	Dataflow_FieldFalloffType_Logarithmic    = 4,
	Dataflow_Max                             = 5,
	Dataflow_Max_0                           = 6,
};

// Enum GeometryCollectionNodes.EDataflowSetMaskConditionType
// NumValues: 0x0005
enum class EDataflowSetMaskConditionType : uint8
{
	Dataflow_SetMaskConditionType_Always     = 0,
	Dataflow_SetMaskConditionType_IFF_NOT_Interior = 1,
	Dataflow_SetMaskConditionType_IFF_NOT_Exterior = 2,
	Dataflow_Max                             = 3,
	Dataflow_Max_0                           = 4,
};

// Enum GeometryCollectionNodes.EDataflowWaveFunctionType
// NumValues: 0x0006
enum class EDataflowWaveFunctionType : uint8
{
	Dataflow_WaveFunctionType_Cosine         = 0,
	Dataflow_WaveFunctionType_Gaussian       = 1,
	Dataflow_WaveFunctionType_Falloff        = 2,
	Dataflow_WaveFunctionType_Decay          = 3,
	Dataflow_Max                             = 4,
	Dataflow_Max_0                           = 5,
};

// Enum GeometryCollectionNodes.EDataflowFloatFieldOperationType
// NumValues: 0x0008
enum class EDataflowFloatFieldOperationType : uint8
{
	Dataflow_FloatFieldOperationType_Multiply = 0,
	Dataflow_FloatFieldFalloffType_Divide    = 1,
	Dataflow_FloatFieldFalloffType_Add       = 2,
	Dataflow_FloatFieldFalloffType_Substract = 3,
	Dataflow_FloatFieldFalloffType_Min       = 4,
	Dataflow_FloatFieldFalloffType_Max       = 5,
	Dataflow_Max                             = 6,
	Dataflow_Max_0                           = 7,
};

// Enum GeometryCollectionNodes.EDataflowVectorFieldOperationType
// NumValues: 0x0007
enum class EDataflowVectorFieldOperationType : uint8
{
	Dataflow_VectorFieldOperationType_Multiply = 0,
	Dataflow_VectorFieldFalloffType_Divide   = 1,
	Dataflow_VectorFieldFalloffType_Add      = 2,
	Dataflow_VectorFieldFalloffType_Substract = 3,
	Dataflow_VectorFieldFalloffType_CrossProduct = 4,
	Dataflow_Max                             = 5,
	Dataflow_Max_0                           = 6,
};

// Enum GeometryCollectionNodes.ESetMaterialOperationTypeEnum
// NumValues: 0x0004
enum class ESetMaterialOperationTypeEnum : uint8
{
	Dataflow_SetMaterialOperationType_Add    = 0,
	Dataflow_SetMaterialOperationType_Insert = 1,
	Dataflow_Max                             = 2,
	Dataflow_Max_0                           = 3,
};

// Enum GeometryCollectionNodes.EConvexOverlapRemovalMethodEnum
// NumValues: 0x0006
enum class EConvexOverlapRemovalMethodEnum : uint8
{
	Dataflow_EConvexOverlapRemovalMethod_None = 0,
	Dataflow_EConvexOverlapRemovalMethod_All = 1,
	Dataflow_EConvexOverlapRemovalMethod_OnlyClusters = 2,
	Dataflow_EConvexOverlapRemovalMethod_OnlyClustersVsClusters = 3,
	Dataflow_Max                             = 4,
	Dataflow_Max_0                           = 5,
};

// Enum GeometryCollectionNodes.EClusterSizeMethodEnum
// NumValues: 0x0005
enum class EClusterSizeMethodEnum : uint8
{
	Dataflow_ClusterSizeMethod_ByNumber      = 0,
	Dataflow_ClusterSizeMethod_ByFractionOfInput = 1,
	Dataflow_ClusterSizeMethod_BySize        = 2,
	Dataflow_Max                             = 3,
	Dataflow_Max_0                           = 4,
};

// Enum GeometryCollectionNodes.EVisibiltyOptionsEnum
// NumValues: 0x0004
enum class EVisibiltyOptionsEnum : uint8
{
	Dataflow_VisibilityOptions_Visible       = 0,
	Dataflow_VisibilityOptions_Invisible     = 1,
	Dataflow_Max                             = 2,
	Dataflow_Max_0                           = 3,
};

// Enum GeometryCollectionNodes.EMeshBooleanOperationEnum
// NumValues: 0x0005
enum class EMeshBooleanOperationEnum : uint8
{
	Dataflow_MeshBoolean_Union               = 0,
	Dataflow_MeshBoolean_Intersect           = 1,
	Dataflow_MeshBoolean_Difference          = 2,
	Dataflow_Max                             = 3,
	Dataflow_Max_0                           = 4,
};

// Enum GeometryCollectionNodes.EMakeBoxDataTypeEnum
// NumValues: 0x0004
enum class EMakeBoxDataTypeEnum : uint8
{
	Dataflow_MakeBox_DataType_MinMax         = 0,
	Dataflow_MakeBox_DataType_CenterSize     = 1,
	Dataflow_Max                             = 2,
	Dataflow_Max_0                           = 3,
};

// Enum GeometryCollectionNodes.EFloatToIntFunctionEnum
// NumValues: 0x0006
enum class EFloatToIntFunctionEnum : uint8
{
	Dataflow_FloatToInt_Function_Floor       = 0,
	Dataflow_FloatToInt_Function_Ceil        = 1,
	Dataflow_FloatToInt_Function_Round       = 2,
	Dataflow_FloatToInt_Function_Truncate    = 3,
	Dataflow_Max                             = 4,
	Dataflow_Max_0                           = 5,
};

// Enum GeometryCollectionNodes.EFloatArrayToIntArrayFunctionEnum
// NumValues: 0x0008
enum class EFloatArrayToIntArrayFunctionEnum : uint8
{
	Dataflow_FloatToInt_Function_Floor       = 0,
	Dataflow_FloatToInt_Function_Ceil        = 1,
	Dataflow_FloatToInt_Function_Round       = 2,
	Dataflow_FloatToInt_Function_Truncate    = 3,
	Dataflow_FloatToInt_NonZeroToIndex       = 4,
	Dataflow_FloatToInt_ZeroToIndex          = 5,
	Dataflow_Max                             = 6,
	Dataflow_Max_0                           = 7,
};

// Enum GeometryCollectionNodes.EMathConstantsEnum
// NumValues: 0x0010
enum class EMathConstantsEnum : uint8
{
	Dataflow_MathConstants_Pi                = 0,
	Dataflow_MathConstants_HalfPi            = 1,
	Dataflow_MathConstants_TwoPi             = 2,
	Dataflow_MathConstants_FourPi            = 3,
	Dataflow_MathConstants_InvPi             = 4,
	Dataflow_MathConstants_InvTwoPi          = 5,
	Dataflow_MathConstants_Sqrt2             = 6,
	Dataflow_MathConstants_InvSqrt2          = 7,
	Dataflow_MathConstants_Sqrt3             = 8,
	Dataflow_MathConstants_InvSqrt3          = 9,
	Dataflow_FloatToInt_Function_E           = 10,
	Dataflow_FloatToInt_Function_Gamma       = 11,
	Dataflow_FloatToInt_Function_GoldenRatio = 12,
	Dataflow_FloatToInt_Function_ZeroTolerance = 13,
	Dataflow_Max                             = 14,
	Dataflow_Max_0                           = 15,
};

// Enum GeometryCollectionNodes.ERotationOrderEnum
// NumValues: 0x0008
enum class ERotationOrderEnum : uint8
{
	Dataflow_RotationOrder_XYZ               = 0,
	Dataflow_RotationOrder_YZX               = 1,
	Dataflow_RotationOrder_ZXY               = 2,
	Dataflow_RotationOrder_XZY               = 3,
	Dataflow_RotationOrder_YXZ               = 4,
	Dataflow_RotationOrder_ZYX               = 5,
	Dataflow_Max                             = 6,
	Dataflow_Max_0                           = 7,
};

// Enum GeometryCollectionNodes.ECompareOperationEnum
// NumValues: 0x0007
enum class ECompareOperationEnum : uint8
{
	Dataflow_Compare_Equal                   = 0,
	Dataflow_Compare_Smaller                 = 1,
	Dataflow_Compare_SmallerOrEqual          = 2,
	Dataflow_Compare_Greater                 = 3,
	Dataflow_Compare_GreaterOrEqual          = 4,
	Dataflow_Max                             = 5,
	Dataflow_Max_0                           = 6,
};

// Enum GeometryCollectionNodes.EAnchorStateEnum
// NumValues: 0x0004
enum class EAnchorStateEnum : uint8
{
	Dataflow_AnchorState_Anchored            = 0,
	Dataflow_AnchorState_NotAnchored         = 1,
	Dataflow_Max                             = 2,
	Dataflow_Max_0                           = 3,
};

// Enum GeometryCollectionNodes.EProximityMethodEnum
// NumValues: 0x0004
enum class EProximityMethodEnum : uint8
{
	Dataflow_ProximityMethod_Precise         = 0,
	Dataflow_ProximityMethod_ConvexHull      = 1,
	Dataflow_Max                             = 2,
	Dataflow_Max_0                           = 3,
};

// Enum GeometryCollectionNodes.EStandardGroupNameEnum
// NumValues: 0x0009
enum class EStandardGroupNameEnum : uint8
{
	Dataflow_EStandardGroupNameEnum_Transform = 0,
	Dataflow_EStandardGroupNameEnum_Geometry = 1,
	Dataflow_EStandardGroupNameEnum_Faces    = 2,
	Dataflow_EStandardGroupNameEnum_Vertices = 3,
	Dataflow_EStandardGroupNameEnum_Material = 4,
	Dataflow_EStandardGroupNameEnum_Breaking = 5,
	Dataflow_EStandardGroupNameEnum_Custom   = 6,
	Dataflow_Max                             = 7,
	Dataflow_Max_0                           = 8,
};

// Enum GeometryCollectionNodes.ECustomAttributeTypeEnum
// NumValues: 0x001A
enum class ECustomAttributeTypeEnum : uint8
{
	Dataflow_CustomAttributeType_UInt8       = 0,
	Dataflow_CustomAttributeType_Int32       = 1,
	Dataflow_CustomAttributeType_Float       = 2,
	Dataflow_CustomAttributeType_Double      = 3,
	Dataflow_CustomAttributeType_Bool        = 4,
	Dataflow_CustomAttributeType_String      = 5,
	Dataflow_CustomAttributeType_Vector2f    = 6,
	Dataflow_CustomAttributeType_Vector3f    = 7,
	Dataflow_CustomAttributeType_Vector3d    = 8,
	Dataflow_CustomAttributeType_Vector4f    = 9,
	Dataflow_CustomAttributeType_LinearColor = 10,
	Dataflow_CustomAttributeType_Transform   = 11,
	Dataflow_CustomAttributeType_Quat4f      = 12,
	Dataflow_CustomAttributeType_Box         = 13,
	Dataflow_CustomAttributeType_Guid        = 14,
	Dataflow_CustomAttributeType_Int32Set    = 15,
	Dataflow_CustomAttributeType_Int32Array  = 16,
	Dataflow_CustomAttributeType_IntVector   = 17,
	Dataflow_CustomAttributeType_IntVector2  = 18,
	Dataflow_CustomAttributeType_IntVector4  = 19,
	Dataflow_CustomAttributeType_IntVector2Array = 20,
	Dataflow_CustomAttributeType_FloatArray  = 21,
	Dataflow_CustomAttributeType_Vector2fArray = 22,
	Dataflow_CustomAttributeType_FVector3fArray = 23,
	Dataflow_Max                             = 24,
	Dataflow_Max_0                           = 25,
};

// Enum GeometryCollectionNodes.ESetOperationEnum
// NumValues: 0x0005
enum class ESetOperationEnum : uint8
{
	Dataflow_SetOperation_AND                = 0,
	Dataflow_SetOperation_OR                 = 1,
	Dataflow_SetOperation_XOR                = 2,
	Dataflow_Max                             = 3,
	Dataflow_Max_0                           = 4,
};

// Enum GeometryCollectionNodes.ERangeSettingEnum
// NumValues: 0x0004
enum class ERangeSettingEnum : uint8
{
	Dataflow_RangeSetting_InsideRange        = 0,
	Dataflow_RangeSetting_OutsideRange       = 1,
	Dataflow_Max                             = 2,
	Dataflow_Max_0                           = 3,
};

// Enum GeometryCollectionNodes.ESelectSubjectTypeEnum
// NumValues: 0x0005
enum class ESelectSubjectTypeEnum : uint8
{
	Dataflow_SelectSubjectType_Vertices      = 0,
	Dataflow_SelectSubjectType_BoundingBox   = 1,
	Dataflow_SelectSubjectType_Centroid      = 2,
	Dataflow_Max                             = 3,
	Dataflow_Max_0                           = 4,
};

// ScriptStruct GeometryCollectionNodes.MakePointsDataflowNode
// 0x0020 (0x0110 - 0x00F0)
struct FMakePointsDataflowNode final : public FDataflowNode
{
public:
	TArray<struct FVector>                        Point;                                             // 0x00F0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        Points;                                            // 0x0100(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMakePointsDataflowNode) == 0x000008, "Wrong alignment on FMakePointsDataflowNode");
static_assert(sizeof(FMakePointsDataflowNode) == 0x000110, "Wrong size on FMakePointsDataflowNode");
static_assert(offsetof(FMakePointsDataflowNode, Point) == 0x0000F0, "Member 'FMakePointsDataflowNode::Point' has a wrong offset!");
static_assert(offsetof(FMakePointsDataflowNode, Points) == 0x000100, "Member 'FMakePointsDataflowNode::Points' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.GeometryCollectionTerminalDataflowNode
// 0x00D0 (0x01C0 - 0x00F0)
struct FGeometryCollectionTerminalDataflowNode final : public FDataflowTerminalNode
{
public:
	struct FManagedArrayCollection                Collection;                                        // 0x00F0(0x00B0)(NativeAccessSpecifierPublic)
	TArray<class UMaterial*>                      Materials;                                         // 0x01A0(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<struct FGeometryCollectionAutoInstanceMesh> InstancedMeshes;                                   // 0x01B0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGeometryCollectionTerminalDataflowNode) == 0x000008, "Wrong alignment on FGeometryCollectionTerminalDataflowNode");
static_assert(sizeof(FGeometryCollectionTerminalDataflowNode) == 0x0001C0, "Wrong size on FGeometryCollectionTerminalDataflowNode");
static_assert(offsetof(FGeometryCollectionTerminalDataflowNode, Collection) == 0x0000F0, "Member 'FGeometryCollectionTerminalDataflowNode::Collection' has a wrong offset!");
static_assert(offsetof(FGeometryCollectionTerminalDataflowNode, Materials) == 0x0001A0, "Member 'FGeometryCollectionTerminalDataflowNode::Materials' has a wrong offset!");
static_assert(offsetof(FGeometryCollectionTerminalDataflowNode, InstancedMeshes) == 0x0001B0, "Member 'FGeometryCollectionTerminalDataflowNode::InstancedMeshes' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.PlaneFalloffFieldDataflowNode
// 0x00E0 (0x01D0 - 0x00F0)
struct FPlaneFalloffFieldDataflowNode final : public FDataflowNode
{
public:
	TArray<struct FVector3f>                      SamplePositions;                                   // 0x00F0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FDataflowVertexSelection               SampleIndices;                                     // 0x0100(0x0020)(NativeAccessSpecifierPublic)
	struct FVector                                Position;                                          // 0x0120(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Normal;                                            // 0x0138(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Distance;                                          // 0x0150(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_154[0x4];                                      // 0x0154(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Translation;                                       // 0x0158(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Magnitude;                                         // 0x0170(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinRange;                                          // 0x0174(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRange;                                          // 0x0178(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Default;                                           // 0x017C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDataflowFieldFalloffType                     FalloffType;                                       // 0x0180(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_181[0x7];                                      // 0x0181(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 FieldFloatResult;                                  // 0x0188(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 FieldRemap;                                        // 0x0198(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FDataflowVertexSelection               FieldSelectionMask;                                // 0x01A8(0x0020)(NativeAccessSpecifierPublic)
	int32                                         NumSamplePositions;                                // 0x01C8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1CC[0x4];                                      // 0x01CC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlaneFalloffFieldDataflowNode) == 0x000008, "Wrong alignment on FPlaneFalloffFieldDataflowNode");
static_assert(sizeof(FPlaneFalloffFieldDataflowNode) == 0x0001D0, "Wrong size on FPlaneFalloffFieldDataflowNode");
static_assert(offsetof(FPlaneFalloffFieldDataflowNode, SamplePositions) == 0x0000F0, "Member 'FPlaneFalloffFieldDataflowNode::SamplePositions' has a wrong offset!");
static_assert(offsetof(FPlaneFalloffFieldDataflowNode, SampleIndices) == 0x000100, "Member 'FPlaneFalloffFieldDataflowNode::SampleIndices' has a wrong offset!");
static_assert(offsetof(FPlaneFalloffFieldDataflowNode, Position) == 0x000120, "Member 'FPlaneFalloffFieldDataflowNode::Position' has a wrong offset!");
static_assert(offsetof(FPlaneFalloffFieldDataflowNode, Normal) == 0x000138, "Member 'FPlaneFalloffFieldDataflowNode::Normal' has a wrong offset!");
static_assert(offsetof(FPlaneFalloffFieldDataflowNode, Distance) == 0x000150, "Member 'FPlaneFalloffFieldDataflowNode::Distance' has a wrong offset!");
static_assert(offsetof(FPlaneFalloffFieldDataflowNode, Translation) == 0x000158, "Member 'FPlaneFalloffFieldDataflowNode::Translation' has a wrong offset!");
static_assert(offsetof(FPlaneFalloffFieldDataflowNode, Magnitude) == 0x000170, "Member 'FPlaneFalloffFieldDataflowNode::Magnitude' has a wrong offset!");
static_assert(offsetof(FPlaneFalloffFieldDataflowNode, MinRange) == 0x000174, "Member 'FPlaneFalloffFieldDataflowNode::MinRange' has a wrong offset!");
static_assert(offsetof(FPlaneFalloffFieldDataflowNode, MaxRange) == 0x000178, "Member 'FPlaneFalloffFieldDataflowNode::MaxRange' has a wrong offset!");
static_assert(offsetof(FPlaneFalloffFieldDataflowNode, Default) == 0x00017C, "Member 'FPlaneFalloffFieldDataflowNode::Default' has a wrong offset!");
static_assert(offsetof(FPlaneFalloffFieldDataflowNode, FalloffType) == 0x000180, "Member 'FPlaneFalloffFieldDataflowNode::FalloffType' has a wrong offset!");
static_assert(offsetof(FPlaneFalloffFieldDataflowNode, FieldFloatResult) == 0x000188, "Member 'FPlaneFalloffFieldDataflowNode::FieldFloatResult' has a wrong offset!");
static_assert(offsetof(FPlaneFalloffFieldDataflowNode, FieldRemap) == 0x000198, "Member 'FPlaneFalloffFieldDataflowNode::FieldRemap' has a wrong offset!");
static_assert(offsetof(FPlaneFalloffFieldDataflowNode, FieldSelectionMask) == 0x0001A8, "Member 'FPlaneFalloffFieldDataflowNode::FieldSelectionMask' has a wrong offset!");
static_assert(offsetof(FPlaneFalloffFieldDataflowNode, NumSamplePositions) == 0x0001C8, "Member 'FPlaneFalloffFieldDataflowNode::NumSamplePositions' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.MakeLiteralFloatDataflowNode
// 0x0008 (0x00F8 - 0x00F0)
struct FMakeLiteralFloatDataflowNode final : public FDataflowNode
{
public:
	float                                         Value;                                             // 0x00F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Float;                                             // 0x00F4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMakeLiteralFloatDataflowNode) == 0x000008, "Wrong alignment on FMakeLiteralFloatDataflowNode");
static_assert(sizeof(FMakeLiteralFloatDataflowNode) == 0x0000F8, "Wrong size on FMakeLiteralFloatDataflowNode");
static_assert(offsetof(FMakeLiteralFloatDataflowNode, Value) == 0x0000F0, "Member 'FMakeLiteralFloatDataflowNode::Value' has a wrong offset!");
static_assert(offsetof(FMakeLiteralFloatDataflowNode, Float) == 0x0000F4, "Member 'FMakeLiteralFloatDataflowNode::Float' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.GetGeometryCollectionAssetDataflowNode
// 0x0008 (0x00F8 - 0x00F0)
struct FGetGeometryCollectionAssetDataflowNode final : public FDataflowNode
{
public:
	class UGeometryCollection*                    Asset;                                             // 0x00F0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGetGeometryCollectionAssetDataflowNode) == 0x000008, "Wrong alignment on FGetGeometryCollectionAssetDataflowNode");
static_assert(sizeof(FGetGeometryCollectionAssetDataflowNode) == 0x0000F8, "Wrong size on FGetGeometryCollectionAssetDataflowNode");
static_assert(offsetof(FGetGeometryCollectionAssetDataflowNode, Asset) == 0x0000F0, "Member 'FGetGeometryCollectionAssetDataflowNode::Asset' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.RadialIntMaskFieldDataflowNode
// 0x00A0 (0x0190 - 0x00F0)
struct FRadialIntMaskFieldDataflowNode final : public FDataflowNode
{
public:
	TArray<struct FVector3f>                      SamplePositions;                                   // 0x00F0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FDataflowVertexSelection               SampleIndices;                                     // 0x0100(0x0020)(NativeAccessSpecifierPublic)
	struct FSphere                                Sphere;                                            // 0x0120(0x0020)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Translation;                                       // 0x0140(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InteriorValue;                                     // 0x0158(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExteriorValue;                                     // 0x015C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDataflowSetMaskConditionType                 SetMaskConditionType;                              // 0x0160(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_161[0x7];                                      // 0x0161(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 FieldIntResult;                                    // 0x0168(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 FieldRemap;                                        // 0x0178(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         NumSamplePositions;                                // 0x0188(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18C[0x4];                                      // 0x018C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRadialIntMaskFieldDataflowNode) == 0x000008, "Wrong alignment on FRadialIntMaskFieldDataflowNode");
static_assert(sizeof(FRadialIntMaskFieldDataflowNode) == 0x000190, "Wrong size on FRadialIntMaskFieldDataflowNode");
static_assert(offsetof(FRadialIntMaskFieldDataflowNode, SamplePositions) == 0x0000F0, "Member 'FRadialIntMaskFieldDataflowNode::SamplePositions' has a wrong offset!");
static_assert(offsetof(FRadialIntMaskFieldDataflowNode, SampleIndices) == 0x000100, "Member 'FRadialIntMaskFieldDataflowNode::SampleIndices' has a wrong offset!");
static_assert(offsetof(FRadialIntMaskFieldDataflowNode, Sphere) == 0x000120, "Member 'FRadialIntMaskFieldDataflowNode::Sphere' has a wrong offset!");
static_assert(offsetof(FRadialIntMaskFieldDataflowNode, Translation) == 0x000140, "Member 'FRadialIntMaskFieldDataflowNode::Translation' has a wrong offset!");
static_assert(offsetof(FRadialIntMaskFieldDataflowNode, InteriorValue) == 0x000158, "Member 'FRadialIntMaskFieldDataflowNode::InteriorValue' has a wrong offset!");
static_assert(offsetof(FRadialIntMaskFieldDataflowNode, ExteriorValue) == 0x00015C, "Member 'FRadialIntMaskFieldDataflowNode::ExteriorValue' has a wrong offset!");
static_assert(offsetof(FRadialIntMaskFieldDataflowNode, SetMaskConditionType) == 0x000160, "Member 'FRadialIntMaskFieldDataflowNode::SetMaskConditionType' has a wrong offset!");
static_assert(offsetof(FRadialIntMaskFieldDataflowNode, FieldIntResult) == 0x000168, "Member 'FRadialIntMaskFieldDataflowNode::FieldIntResult' has a wrong offset!");
static_assert(offsetof(FRadialIntMaskFieldDataflowNode, FieldRemap) == 0x000178, "Member 'FRadialIntMaskFieldDataflowNode::FieldRemap' has a wrong offset!");
static_assert(offsetof(FRadialIntMaskFieldDataflowNode, NumSamplePositions) == 0x000188, "Member 'FRadialIntMaskFieldDataflowNode::NumSamplePositions' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.MakeLiteralIntDataflowNode
// 0x0008 (0x00F8 - 0x00F0)
struct FMakeLiteralIntDataflowNode final : public FDataflowNode
{
public:
	int32                                         Value;                                             // 0x00F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Int;                                               // 0x00F4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMakeLiteralIntDataflowNode) == 0x000008, "Wrong alignment on FMakeLiteralIntDataflowNode");
static_assert(sizeof(FMakeLiteralIntDataflowNode) == 0x0000F8, "Wrong size on FMakeLiteralIntDataflowNode");
static_assert(offsetof(FMakeLiteralIntDataflowNode, Value) == 0x0000F0, "Member 'FMakeLiteralIntDataflowNode::Value' has a wrong offset!");
static_assert(offsetof(FMakeLiteralIntDataflowNode, Int) == 0x0000F4, "Member 'FMakeLiteralIntDataflowNode::Int' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.GetGeometryCollectionSourcesDataflowNode
// 0x0018 (0x0108 - 0x00F0)
struct FGetGeometryCollectionSourcesDataflowNode final : public FDataflowNode
{
public:
	class UGeometryCollection*                    Asset;                                             // 0x00F0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGeometryCollectionSource>      Sources;                                           // 0x00F8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGetGeometryCollectionSourcesDataflowNode) == 0x000008, "Wrong alignment on FGetGeometryCollectionSourcesDataflowNode");
static_assert(sizeof(FGetGeometryCollectionSourcesDataflowNode) == 0x000108, "Wrong size on FGetGeometryCollectionSourcesDataflowNode");
static_assert(offsetof(FGetGeometryCollectionSourcesDataflowNode, Asset) == 0x0000F0, "Member 'FGetGeometryCollectionSourcesDataflowNode::Asset' has a wrong offset!");
static_assert(offsetof(FGetGeometryCollectionSourcesDataflowNode, Sources) == 0x0000F8, "Member 'FGetGeometryCollectionSourcesDataflowNode::Sources' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.MakeLiteralVectorDataflowNode
// 0x0028 (0x0118 - 0x00F0)
struct FMakeLiteralVectorDataflowNode final : public FDataflowNode
{
public:
	float                                         X;                                                 // 0x00F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Y;                                                 // 0x00F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Z;                                                 // 0x00F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FC[0x4];                                       // 0x00FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Vector;                                            // 0x0100(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMakeLiteralVectorDataflowNode) == 0x000008, "Wrong alignment on FMakeLiteralVectorDataflowNode");
static_assert(sizeof(FMakeLiteralVectorDataflowNode) == 0x000118, "Wrong size on FMakeLiteralVectorDataflowNode");
static_assert(offsetof(FMakeLiteralVectorDataflowNode, X) == 0x0000F0, "Member 'FMakeLiteralVectorDataflowNode::X' has a wrong offset!");
static_assert(offsetof(FMakeLiteralVectorDataflowNode, Y) == 0x0000F4, "Member 'FMakeLiteralVectorDataflowNode::Y' has a wrong offset!");
static_assert(offsetof(FMakeLiteralVectorDataflowNode, Z) == 0x0000F8, "Member 'FMakeLiteralVectorDataflowNode::Z' has a wrong offset!");
static_assert(offsetof(FMakeLiteralVectorDataflowNode, Vector) == 0x000100, "Member 'FMakeLiteralVectorDataflowNode::Vector' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.CreateGeometryCollectionFromSourcesDataflowNode
// 0x00E0 (0x01D0 - 0x00F0)
struct FCreateGeometryCollectionFromSourcesDataflowNode final : public FDataflowNode
{
public:
	TArray<struct FGeometryCollectionSource>      Sources;                                           // 0x00F0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FManagedArrayCollection                Collection;                                        // 0x0100(0x00B0)(NativeAccessSpecifierPublic)
	TArray<class UMaterial*>                      Materials;                                         // 0x01B0(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<struct FGeometryCollectionAutoInstanceMesh> InstancedMeshes;                                   // 0x01C0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCreateGeometryCollectionFromSourcesDataflowNode) == 0x000008, "Wrong alignment on FCreateGeometryCollectionFromSourcesDataflowNode");
static_assert(sizeof(FCreateGeometryCollectionFromSourcesDataflowNode) == 0x0001D0, "Wrong size on FCreateGeometryCollectionFromSourcesDataflowNode");
static_assert(offsetof(FCreateGeometryCollectionFromSourcesDataflowNode, Sources) == 0x0000F0, "Member 'FCreateGeometryCollectionFromSourcesDataflowNode::Sources' has a wrong offset!");
static_assert(offsetof(FCreateGeometryCollectionFromSourcesDataflowNode, Collection) == 0x000100, "Member 'FCreateGeometryCollectionFromSourcesDataflowNode::Collection' has a wrong offset!");
static_assert(offsetof(FCreateGeometryCollectionFromSourcesDataflowNode, Materials) == 0x0001B0, "Member 'FCreateGeometryCollectionFromSourcesDataflowNode::Materials' has a wrong offset!");
static_assert(offsetof(FCreateGeometryCollectionFromSourcesDataflowNode, InstancedMeshes) == 0x0001C0, "Member 'FCreateGeometryCollectionFromSourcesDataflowNode::InstancedMeshes' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.RadialFalloffFieldDataflowNode
// 0x00C8 (0x01B8 - 0x00F0)
struct FRadialFalloffFieldDataflowNode final : public FDataflowNode
{
public:
	TArray<struct FVector3f>                      SamplePositions;                                   // 0x00F0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FDataflowVertexSelection               SampleIndices;                                     // 0x0100(0x0020)(NativeAccessSpecifierPublic)
	struct FSphere                                Sphere;                                            // 0x0120(0x0020)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Translation;                                       // 0x0140(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Magnitude;                                         // 0x0158(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinRange;                                          // 0x015C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRange;                                          // 0x0160(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Default;                                           // 0x0164(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDataflowFieldFalloffType                     FalloffType;                                       // 0x0168(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_169[0x7];                                      // 0x0169(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 FieldFloatResult;                                  // 0x0170(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 FieldRemap;                                        // 0x0180(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FDataflowVertexSelection               FieldSelectionMask;                                // 0x0190(0x0020)(NativeAccessSpecifierPublic)
	int32                                         NumSamplePositions;                                // 0x01B0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B4[0x4];                                      // 0x01B4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRadialFalloffFieldDataflowNode) == 0x000008, "Wrong alignment on FRadialFalloffFieldDataflowNode");
static_assert(sizeof(FRadialFalloffFieldDataflowNode) == 0x0001B8, "Wrong size on FRadialFalloffFieldDataflowNode");
static_assert(offsetof(FRadialFalloffFieldDataflowNode, SamplePositions) == 0x0000F0, "Member 'FRadialFalloffFieldDataflowNode::SamplePositions' has a wrong offset!");
static_assert(offsetof(FRadialFalloffFieldDataflowNode, SampleIndices) == 0x000100, "Member 'FRadialFalloffFieldDataflowNode::SampleIndices' has a wrong offset!");
static_assert(offsetof(FRadialFalloffFieldDataflowNode, Sphere) == 0x000120, "Member 'FRadialFalloffFieldDataflowNode::Sphere' has a wrong offset!");
static_assert(offsetof(FRadialFalloffFieldDataflowNode, Translation) == 0x000140, "Member 'FRadialFalloffFieldDataflowNode::Translation' has a wrong offset!");
static_assert(offsetof(FRadialFalloffFieldDataflowNode, Magnitude) == 0x000158, "Member 'FRadialFalloffFieldDataflowNode::Magnitude' has a wrong offset!");
static_assert(offsetof(FRadialFalloffFieldDataflowNode, MinRange) == 0x00015C, "Member 'FRadialFalloffFieldDataflowNode::MinRange' has a wrong offset!");
static_assert(offsetof(FRadialFalloffFieldDataflowNode, MaxRange) == 0x000160, "Member 'FRadialFalloffFieldDataflowNode::MaxRange' has a wrong offset!");
static_assert(offsetof(FRadialFalloffFieldDataflowNode, Default) == 0x000164, "Member 'FRadialFalloffFieldDataflowNode::Default' has a wrong offset!");
static_assert(offsetof(FRadialFalloffFieldDataflowNode, FalloffType) == 0x000168, "Member 'FRadialFalloffFieldDataflowNode::FalloffType' has a wrong offset!");
static_assert(offsetof(FRadialFalloffFieldDataflowNode, FieldFloatResult) == 0x000170, "Member 'FRadialFalloffFieldDataflowNode::FieldFloatResult' has a wrong offset!");
static_assert(offsetof(FRadialFalloffFieldDataflowNode, FieldRemap) == 0x000180, "Member 'FRadialFalloffFieldDataflowNode::FieldRemap' has a wrong offset!");
static_assert(offsetof(FRadialFalloffFieldDataflowNode, FieldSelectionMask) == 0x000190, "Member 'FRadialFalloffFieldDataflowNode::FieldSelectionMask' has a wrong offset!");
static_assert(offsetof(FRadialFalloffFieldDataflowNode, NumSamplePositions) == 0x0001B0, "Member 'FRadialFalloffFieldDataflowNode::NumSamplePositions' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.BoxFalloffFieldDataflowNode
// 0x0130 (0x0220 - 0x00F0)
struct FBoxFalloffFieldDataflowNode final : public FDataflowNode
{
public:
	TArray<struct FVector3f>                      SamplePositions;                                   // 0x00F0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FDataflowVertexSelection               SampleIndices;                                     // 0x0100(0x0020)(NativeAccessSpecifierPublic)
	struct FBox                                   Box;                                               // 0x0120(0x0038)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_158[0x8];                                      // 0x0158(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Transform;                                         // 0x0160(0x0060)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Magnitude;                                         // 0x01C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinRange;                                          // 0x01C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRange;                                          // 0x01C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Default;                                           // 0x01CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDataflowFieldFalloffType                     FalloffType;                                       // 0x01D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D1[0x7];                                      // 0x01D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 FieldFloatResult;                                  // 0x01D8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 FieldRemap;                                        // 0x01E8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FDataflowVertexSelection               FieldSelectionMask;                                // 0x01F8(0x0020)(NativeAccessSpecifierPublic)
	int32                                         NumSamplePositions;                                // 0x0218(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21C[0x4];                                      // 0x021C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBoxFalloffFieldDataflowNode) == 0x000010, "Wrong alignment on FBoxFalloffFieldDataflowNode");
static_assert(sizeof(FBoxFalloffFieldDataflowNode) == 0x000220, "Wrong size on FBoxFalloffFieldDataflowNode");
static_assert(offsetof(FBoxFalloffFieldDataflowNode, SamplePositions) == 0x0000F0, "Member 'FBoxFalloffFieldDataflowNode::SamplePositions' has a wrong offset!");
static_assert(offsetof(FBoxFalloffFieldDataflowNode, SampleIndices) == 0x000100, "Member 'FBoxFalloffFieldDataflowNode::SampleIndices' has a wrong offset!");
static_assert(offsetof(FBoxFalloffFieldDataflowNode, Box) == 0x000120, "Member 'FBoxFalloffFieldDataflowNode::Box' has a wrong offset!");
static_assert(offsetof(FBoxFalloffFieldDataflowNode, Transform) == 0x000160, "Member 'FBoxFalloffFieldDataflowNode::Transform' has a wrong offset!");
static_assert(offsetof(FBoxFalloffFieldDataflowNode, Magnitude) == 0x0001C0, "Member 'FBoxFalloffFieldDataflowNode::Magnitude' has a wrong offset!");
static_assert(offsetof(FBoxFalloffFieldDataflowNode, MinRange) == 0x0001C4, "Member 'FBoxFalloffFieldDataflowNode::MinRange' has a wrong offset!");
static_assert(offsetof(FBoxFalloffFieldDataflowNode, MaxRange) == 0x0001C8, "Member 'FBoxFalloffFieldDataflowNode::MaxRange' has a wrong offset!");
static_assert(offsetof(FBoxFalloffFieldDataflowNode, Default) == 0x0001CC, "Member 'FBoxFalloffFieldDataflowNode::Default' has a wrong offset!");
static_assert(offsetof(FBoxFalloffFieldDataflowNode, FalloffType) == 0x0001D0, "Member 'FBoxFalloffFieldDataflowNode::FalloffType' has a wrong offset!");
static_assert(offsetof(FBoxFalloffFieldDataflowNode, FieldFloatResult) == 0x0001D8, "Member 'FBoxFalloffFieldDataflowNode::FieldFloatResult' has a wrong offset!");
static_assert(offsetof(FBoxFalloffFieldDataflowNode, FieldRemap) == 0x0001E8, "Member 'FBoxFalloffFieldDataflowNode::FieldRemap' has a wrong offset!");
static_assert(offsetof(FBoxFalloffFieldDataflowNode, FieldSelectionMask) == 0x0001F8, "Member 'FBoxFalloffFieldDataflowNode::FieldSelectionMask' has a wrong offset!");
static_assert(offsetof(FBoxFalloffFieldDataflowNode, NumSamplePositions) == 0x000218, "Member 'FBoxFalloffFieldDataflowNode::NumSamplePositions' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.UniformScalarFieldDataflowNode
// 0x0060 (0x0150 - 0x00F0)
struct FUniformScalarFieldDataflowNode final : public FDataflowNode
{
public:
	TArray<struct FVector3f>                      SamplePositions;                                   // 0x00F0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FDataflowVertexSelection               SampleIndices;                                     // 0x0100(0x0020)(NativeAccessSpecifierPublic)
	float                                         Magnitude;                                         // 0x0120(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_124[0x4];                                      // 0x0124(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 FieldFloatResult;                                  // 0x0128(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 FieldRemap;                                        // 0x0138(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         NumSamplePositions;                                // 0x0148(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14C[0x4];                                      // 0x014C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUniformScalarFieldDataflowNode) == 0x000008, "Wrong alignment on FUniformScalarFieldDataflowNode");
static_assert(sizeof(FUniformScalarFieldDataflowNode) == 0x000150, "Wrong size on FUniformScalarFieldDataflowNode");
static_assert(offsetof(FUniformScalarFieldDataflowNode, SamplePositions) == 0x0000F0, "Member 'FUniformScalarFieldDataflowNode::SamplePositions' has a wrong offset!");
static_assert(offsetof(FUniformScalarFieldDataflowNode, SampleIndices) == 0x000100, "Member 'FUniformScalarFieldDataflowNode::SampleIndices' has a wrong offset!");
static_assert(offsetof(FUniformScalarFieldDataflowNode, Magnitude) == 0x000120, "Member 'FUniformScalarFieldDataflowNode::Magnitude' has a wrong offset!");
static_assert(offsetof(FUniformScalarFieldDataflowNode, FieldFloatResult) == 0x000128, "Member 'FUniformScalarFieldDataflowNode::FieldFloatResult' has a wrong offset!");
static_assert(offsetof(FUniformScalarFieldDataflowNode, FieldRemap) == 0x000138, "Member 'FUniformScalarFieldDataflowNode::FieldRemap' has a wrong offset!");
static_assert(offsetof(FUniformScalarFieldDataflowNode, NumSamplePositions) == 0x000148, "Member 'FUniformScalarFieldDataflowNode::NumSamplePositions' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.UniformVectorFieldDataflowNode
// 0x0078 (0x0168 - 0x00F0)
struct FUniformVectorFieldDataflowNode final : public FDataflowNode
{
public:
	TArray<struct FVector3f>                      SamplePositions;                                   // 0x00F0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FDataflowVertexSelection               SampleIndices;                                     // 0x0100(0x0020)(NativeAccessSpecifierPublic)
	float                                         Magnitude;                                         // 0x0120(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_124[0x4];                                      // 0x0124(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Direction;                                         // 0x0128(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        FieldVectorResult;                                 // 0x0140(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 FieldRemap;                                        // 0x0150(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         NumSamplePositions;                                // 0x0160(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_164[0x4];                                      // 0x0164(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUniformVectorFieldDataflowNode) == 0x000008, "Wrong alignment on FUniformVectorFieldDataflowNode");
static_assert(sizeof(FUniformVectorFieldDataflowNode) == 0x000168, "Wrong size on FUniformVectorFieldDataflowNode");
static_assert(offsetof(FUniformVectorFieldDataflowNode, SamplePositions) == 0x0000F0, "Member 'FUniformVectorFieldDataflowNode::SamplePositions' has a wrong offset!");
static_assert(offsetof(FUniformVectorFieldDataflowNode, SampleIndices) == 0x000100, "Member 'FUniformVectorFieldDataflowNode::SampleIndices' has a wrong offset!");
static_assert(offsetof(FUniformVectorFieldDataflowNode, Magnitude) == 0x000120, "Member 'FUniformVectorFieldDataflowNode::Magnitude' has a wrong offset!");
static_assert(offsetof(FUniformVectorFieldDataflowNode, Direction) == 0x000128, "Member 'FUniformVectorFieldDataflowNode::Direction' has a wrong offset!");
static_assert(offsetof(FUniformVectorFieldDataflowNode, FieldVectorResult) == 0x000140, "Member 'FUniformVectorFieldDataflowNode::FieldVectorResult' has a wrong offset!");
static_assert(offsetof(FUniformVectorFieldDataflowNode, FieldRemap) == 0x000150, "Member 'FUniformVectorFieldDataflowNode::FieldRemap' has a wrong offset!");
static_assert(offsetof(FUniformVectorFieldDataflowNode, NumSamplePositions) == 0x000160, "Member 'FUniformVectorFieldDataflowNode::NumSamplePositions' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.RadialVectorFieldDataflowNode
// 0x0078 (0x0168 - 0x00F0)
struct FRadialVectorFieldDataflowNode final : public FDataflowNode
{
public:
	TArray<struct FVector3f>                      SamplePositions;                                   // 0x00F0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FDataflowVertexSelection               SampleIndices;                                     // 0x0100(0x0020)(NativeAccessSpecifierPublic)
	float                                         Magnitude;                                         // 0x0120(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_124[0x4];                                      // 0x0124(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Position;                                          // 0x0128(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        FieldVectorResult;                                 // 0x0140(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 FieldRemap;                                        // 0x0150(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         NumSamplePositions;                                // 0x0160(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_164[0x4];                                      // 0x0164(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRadialVectorFieldDataflowNode) == 0x000008, "Wrong alignment on FRadialVectorFieldDataflowNode");
static_assert(sizeof(FRadialVectorFieldDataflowNode) == 0x000168, "Wrong size on FRadialVectorFieldDataflowNode");
static_assert(offsetof(FRadialVectorFieldDataflowNode, SamplePositions) == 0x0000F0, "Member 'FRadialVectorFieldDataflowNode::SamplePositions' has a wrong offset!");
static_assert(offsetof(FRadialVectorFieldDataflowNode, SampleIndices) == 0x000100, "Member 'FRadialVectorFieldDataflowNode::SampleIndices' has a wrong offset!");
static_assert(offsetof(FRadialVectorFieldDataflowNode, Magnitude) == 0x000120, "Member 'FRadialVectorFieldDataflowNode::Magnitude' has a wrong offset!");
static_assert(offsetof(FRadialVectorFieldDataflowNode, Position) == 0x000128, "Member 'FRadialVectorFieldDataflowNode::Position' has a wrong offset!");
static_assert(offsetof(FRadialVectorFieldDataflowNode, FieldVectorResult) == 0x000140, "Member 'FRadialVectorFieldDataflowNode::FieldVectorResult' has a wrong offset!");
static_assert(offsetof(FRadialVectorFieldDataflowNode, FieldRemap) == 0x000150, "Member 'FRadialVectorFieldDataflowNode::FieldRemap' has a wrong offset!");
static_assert(offsetof(FRadialVectorFieldDataflowNode, NumSamplePositions) == 0x000160, "Member 'FRadialVectorFieldDataflowNode::NumSamplePositions' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.RandomVectorFieldDataflowNode
// 0x0060 (0x0150 - 0x00F0)
struct FRandomVectorFieldDataflowNode final : public FDataflowNode
{
public:
	TArray<struct FVector3f>                      SamplePositions;                                   // 0x00F0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FDataflowVertexSelection               SampleIndices;                                     // 0x0100(0x0020)(NativeAccessSpecifierPublic)
	float                                         Magnitude;                                         // 0x0120(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_124[0x4];                                      // 0x0124(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        FieldVectorResult;                                 // 0x0128(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 FieldRemap;                                        // 0x0138(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         NumSamplePositions;                                // 0x0148(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14C[0x4];                                      // 0x014C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRandomVectorFieldDataflowNode) == 0x000008, "Wrong alignment on FRandomVectorFieldDataflowNode");
static_assert(sizeof(FRandomVectorFieldDataflowNode) == 0x000150, "Wrong size on FRandomVectorFieldDataflowNode");
static_assert(offsetof(FRandomVectorFieldDataflowNode, SamplePositions) == 0x0000F0, "Member 'FRandomVectorFieldDataflowNode::SamplePositions' has a wrong offset!");
static_assert(offsetof(FRandomVectorFieldDataflowNode, SampleIndices) == 0x000100, "Member 'FRandomVectorFieldDataflowNode::SampleIndices' has a wrong offset!");
static_assert(offsetof(FRandomVectorFieldDataflowNode, Magnitude) == 0x000120, "Member 'FRandomVectorFieldDataflowNode::Magnitude' has a wrong offset!");
static_assert(offsetof(FRandomVectorFieldDataflowNode, FieldVectorResult) == 0x000128, "Member 'FRandomVectorFieldDataflowNode::FieldVectorResult' has a wrong offset!");
static_assert(offsetof(FRandomVectorFieldDataflowNode, FieldRemap) == 0x000138, "Member 'FRandomVectorFieldDataflowNode::FieldRemap' has a wrong offset!");
static_assert(offsetof(FRandomVectorFieldDataflowNode, NumSamplePositions) == 0x000148, "Member 'FRandomVectorFieldDataflowNode::NumSamplePositions' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.NoiseFieldDataflowNode
// 0x00D0 (0x01C0 - 0x00F0)
struct FNoiseFieldDataflowNode final : public FDataflowNode
{
public:
	TArray<struct FVector3f>                      SamplePositions;                                   // 0x00F0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FDataflowVertexSelection               SampleIndices;                                     // 0x0100(0x0020)(NativeAccessSpecifierPublic)
	float                                         MinRange;                                          // 0x0120(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRange;                                          // 0x0124(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_128[0x8];                                      // 0x0128(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Transform;                                         // 0x0130(0x0060)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 FieldFloatResult;                                  // 0x0190(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 FieldRemap;                                        // 0x01A0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         NumSamplePositions;                                // 0x01B0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B4[0xC];                                      // 0x01B4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNoiseFieldDataflowNode) == 0x000010, "Wrong alignment on FNoiseFieldDataflowNode");
static_assert(sizeof(FNoiseFieldDataflowNode) == 0x0001C0, "Wrong size on FNoiseFieldDataflowNode");
static_assert(offsetof(FNoiseFieldDataflowNode, SamplePositions) == 0x0000F0, "Member 'FNoiseFieldDataflowNode::SamplePositions' has a wrong offset!");
static_assert(offsetof(FNoiseFieldDataflowNode, SampleIndices) == 0x000100, "Member 'FNoiseFieldDataflowNode::SampleIndices' has a wrong offset!");
static_assert(offsetof(FNoiseFieldDataflowNode, MinRange) == 0x000120, "Member 'FNoiseFieldDataflowNode::MinRange' has a wrong offset!");
static_assert(offsetof(FNoiseFieldDataflowNode, MaxRange) == 0x000124, "Member 'FNoiseFieldDataflowNode::MaxRange' has a wrong offset!");
static_assert(offsetof(FNoiseFieldDataflowNode, Transform) == 0x000130, "Member 'FNoiseFieldDataflowNode::Transform' has a wrong offset!");
static_assert(offsetof(FNoiseFieldDataflowNode, FieldFloatResult) == 0x000190, "Member 'FNoiseFieldDataflowNode::FieldFloatResult' has a wrong offset!");
static_assert(offsetof(FNoiseFieldDataflowNode, FieldRemap) == 0x0001A0, "Member 'FNoiseFieldDataflowNode::FieldRemap' has a wrong offset!");
static_assert(offsetof(FNoiseFieldDataflowNode, NumSamplePositions) == 0x0001B0, "Member 'FNoiseFieldDataflowNode::NumSamplePositions' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.UniformIntegerFieldDataflowNode
// 0x0060 (0x0150 - 0x00F0)
struct FUniformIntegerFieldDataflowNode final : public FDataflowNode
{
public:
	TArray<struct FVector3f>                      SamplePositions;                                   // 0x00F0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FDataflowVertexSelection               SampleIndices;                                     // 0x0100(0x0020)(NativeAccessSpecifierPublic)
	int32                                         Magnitude;                                         // 0x0120(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_124[0x4];                                      // 0x0124(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 FieldIntResult;                                    // 0x0128(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 FieldRemap;                                        // 0x0138(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         NumSamplePositions;                                // 0x0148(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14C[0x4];                                      // 0x014C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUniformIntegerFieldDataflowNode) == 0x000008, "Wrong alignment on FUniformIntegerFieldDataflowNode");
static_assert(sizeof(FUniformIntegerFieldDataflowNode) == 0x000150, "Wrong size on FUniformIntegerFieldDataflowNode");
static_assert(offsetof(FUniformIntegerFieldDataflowNode, SamplePositions) == 0x0000F0, "Member 'FUniformIntegerFieldDataflowNode::SamplePositions' has a wrong offset!");
static_assert(offsetof(FUniformIntegerFieldDataflowNode, SampleIndices) == 0x000100, "Member 'FUniformIntegerFieldDataflowNode::SampleIndices' has a wrong offset!");
static_assert(offsetof(FUniformIntegerFieldDataflowNode, Magnitude) == 0x000120, "Member 'FUniformIntegerFieldDataflowNode::Magnitude' has a wrong offset!");
static_assert(offsetof(FUniformIntegerFieldDataflowNode, FieldIntResult) == 0x000128, "Member 'FUniformIntegerFieldDataflowNode::FieldIntResult' has a wrong offset!");
static_assert(offsetof(FUniformIntegerFieldDataflowNode, FieldRemap) == 0x000138, "Member 'FUniformIntegerFieldDataflowNode::FieldRemap' has a wrong offset!");
static_assert(offsetof(FUniformIntegerFieldDataflowNode, NumSamplePositions) == 0x000148, "Member 'FUniformIntegerFieldDataflowNode::NumSamplePositions' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.WaveScalarFieldDataflowNode
// 0x00A0 (0x0190 - 0x00F0)
struct FWaveScalarFieldDataflowNode final : public FDataflowNode
{
public:
	TArray<struct FVector3f>                      SamplePositions;                                   // 0x00F0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FDataflowVertexSelection               SampleIndices;                                     // 0x0100(0x0020)(NativeAccessSpecifierPublic)
	float                                         Magnitude;                                         // 0x0120(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_124[0x4];                                      // 0x0124(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Position;                                          // 0x0128(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Translation;                                       // 0x0140(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Wavelength;                                        // 0x0158(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Period;                                            // 0x015C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDataflowWaveFunctionType                     FunctionType;                                      // 0x0160(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDataflowFieldFalloffType                     FalloffType;                                       // 0x0161(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_162[0x6];                                      // 0x0162(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 FieldFloatResult;                                  // 0x0168(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 FieldRemap;                                        // 0x0178(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         NumSamplePositions;                                // 0x0188(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18C[0x4];                                      // 0x018C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWaveScalarFieldDataflowNode) == 0x000008, "Wrong alignment on FWaveScalarFieldDataflowNode");
static_assert(sizeof(FWaveScalarFieldDataflowNode) == 0x000190, "Wrong size on FWaveScalarFieldDataflowNode");
static_assert(offsetof(FWaveScalarFieldDataflowNode, SamplePositions) == 0x0000F0, "Member 'FWaveScalarFieldDataflowNode::SamplePositions' has a wrong offset!");
static_assert(offsetof(FWaveScalarFieldDataflowNode, SampleIndices) == 0x000100, "Member 'FWaveScalarFieldDataflowNode::SampleIndices' has a wrong offset!");
static_assert(offsetof(FWaveScalarFieldDataflowNode, Magnitude) == 0x000120, "Member 'FWaveScalarFieldDataflowNode::Magnitude' has a wrong offset!");
static_assert(offsetof(FWaveScalarFieldDataflowNode, Position) == 0x000128, "Member 'FWaveScalarFieldDataflowNode::Position' has a wrong offset!");
static_assert(offsetof(FWaveScalarFieldDataflowNode, Translation) == 0x000140, "Member 'FWaveScalarFieldDataflowNode::Translation' has a wrong offset!");
static_assert(offsetof(FWaveScalarFieldDataflowNode, Wavelength) == 0x000158, "Member 'FWaveScalarFieldDataflowNode::Wavelength' has a wrong offset!");
static_assert(offsetof(FWaveScalarFieldDataflowNode, Period) == 0x00015C, "Member 'FWaveScalarFieldDataflowNode::Period' has a wrong offset!");
static_assert(offsetof(FWaveScalarFieldDataflowNode, FunctionType) == 0x000160, "Member 'FWaveScalarFieldDataflowNode::FunctionType' has a wrong offset!");
static_assert(offsetof(FWaveScalarFieldDataflowNode, FalloffType) == 0x000161, "Member 'FWaveScalarFieldDataflowNode::FalloffType' has a wrong offset!");
static_assert(offsetof(FWaveScalarFieldDataflowNode, FieldFloatResult) == 0x000168, "Member 'FWaveScalarFieldDataflowNode::FieldFloatResult' has a wrong offset!");
static_assert(offsetof(FWaveScalarFieldDataflowNode, FieldRemap) == 0x000178, "Member 'FWaveScalarFieldDataflowNode::FieldRemap' has a wrong offset!");
static_assert(offsetof(FWaveScalarFieldDataflowNode, NumSamplePositions) == 0x000188, "Member 'FWaveScalarFieldDataflowNode::NumSamplePositions' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.SumScalarFieldDataflowNode
// 0x0068 (0x0158 - 0x00F0)
struct FSumScalarFieldDataflowNode final : public FDataflowNode
{
public:
	TArray<float>                                 FieldFloatLeft;                                    // 0x00F0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 FieldRemapLeft;                                    // 0x0100(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 FieldFloatRight;                                   // 0x0110(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 FieldRemapRight;                                   // 0x0120(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         Magnitude;                                         // 0x0130(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDataflowFloatFieldOperationType              Operation;                                         // 0x0134(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSwapInputs;                                       // 0x0135(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_136[0x2];                                      // 0x0136(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 FieldFloatResult;                                  // 0x0138(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 FieldRemap;                                        // 0x0148(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSumScalarFieldDataflowNode) == 0x000008, "Wrong alignment on FSumScalarFieldDataflowNode");
static_assert(sizeof(FSumScalarFieldDataflowNode) == 0x000158, "Wrong size on FSumScalarFieldDataflowNode");
static_assert(offsetof(FSumScalarFieldDataflowNode, FieldFloatLeft) == 0x0000F0, "Member 'FSumScalarFieldDataflowNode::FieldFloatLeft' has a wrong offset!");
static_assert(offsetof(FSumScalarFieldDataflowNode, FieldRemapLeft) == 0x000100, "Member 'FSumScalarFieldDataflowNode::FieldRemapLeft' has a wrong offset!");
static_assert(offsetof(FSumScalarFieldDataflowNode, FieldFloatRight) == 0x000110, "Member 'FSumScalarFieldDataflowNode::FieldFloatRight' has a wrong offset!");
static_assert(offsetof(FSumScalarFieldDataflowNode, FieldRemapRight) == 0x000120, "Member 'FSumScalarFieldDataflowNode::FieldRemapRight' has a wrong offset!");
static_assert(offsetof(FSumScalarFieldDataflowNode, Magnitude) == 0x000130, "Member 'FSumScalarFieldDataflowNode::Magnitude' has a wrong offset!");
static_assert(offsetof(FSumScalarFieldDataflowNode, Operation) == 0x000134, "Member 'FSumScalarFieldDataflowNode::Operation' has a wrong offset!");
static_assert(offsetof(FSumScalarFieldDataflowNode, bSwapInputs) == 0x000135, "Member 'FSumScalarFieldDataflowNode::bSwapInputs' has a wrong offset!");
static_assert(offsetof(FSumScalarFieldDataflowNode, FieldFloatResult) == 0x000138, "Member 'FSumScalarFieldDataflowNode::FieldFloatResult' has a wrong offset!");
static_assert(offsetof(FSumScalarFieldDataflowNode, FieldRemap) == 0x000148, "Member 'FSumScalarFieldDataflowNode::FieldRemap' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.SumVectorFieldDataflowNode
// 0x0088 (0x0178 - 0x00F0)
struct FSumVectorFieldDataflowNode final : public FDataflowNode
{
public:
	TArray<float>                                 FieldFloat;                                        // 0x00F0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 FieldFloatRemap;                                   // 0x0100(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        FieldVectorLeft;                                   // 0x0110(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 FieldRemapLeft;                                    // 0x0120(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        FieldVectorRight;                                  // 0x0130(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 FieldRemapRight;                                   // 0x0140(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         Magnitude;                                         // 0x0150(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDataflowVectorFieldOperationType             Operation;                                         // 0x0154(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSwapVectorInputs;                                 // 0x0155(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_156[0x2];                                      // 0x0156(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        FieldVectorResult;                                 // 0x0158(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 FieldRemap;                                        // 0x0168(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSumVectorFieldDataflowNode) == 0x000008, "Wrong alignment on FSumVectorFieldDataflowNode");
static_assert(sizeof(FSumVectorFieldDataflowNode) == 0x000178, "Wrong size on FSumVectorFieldDataflowNode");
static_assert(offsetof(FSumVectorFieldDataflowNode, FieldFloat) == 0x0000F0, "Member 'FSumVectorFieldDataflowNode::FieldFloat' has a wrong offset!");
static_assert(offsetof(FSumVectorFieldDataflowNode, FieldFloatRemap) == 0x000100, "Member 'FSumVectorFieldDataflowNode::FieldFloatRemap' has a wrong offset!");
static_assert(offsetof(FSumVectorFieldDataflowNode, FieldVectorLeft) == 0x000110, "Member 'FSumVectorFieldDataflowNode::FieldVectorLeft' has a wrong offset!");
static_assert(offsetof(FSumVectorFieldDataflowNode, FieldRemapLeft) == 0x000120, "Member 'FSumVectorFieldDataflowNode::FieldRemapLeft' has a wrong offset!");
static_assert(offsetof(FSumVectorFieldDataflowNode, FieldVectorRight) == 0x000130, "Member 'FSumVectorFieldDataflowNode::FieldVectorRight' has a wrong offset!");
static_assert(offsetof(FSumVectorFieldDataflowNode, FieldRemapRight) == 0x000140, "Member 'FSumVectorFieldDataflowNode::FieldRemapRight' has a wrong offset!");
static_assert(offsetof(FSumVectorFieldDataflowNode, Magnitude) == 0x000150, "Member 'FSumVectorFieldDataflowNode::Magnitude' has a wrong offset!");
static_assert(offsetof(FSumVectorFieldDataflowNode, Operation) == 0x000154, "Member 'FSumVectorFieldDataflowNode::Operation' has a wrong offset!");
static_assert(offsetof(FSumVectorFieldDataflowNode, bSwapVectorInputs) == 0x000155, "Member 'FSumVectorFieldDataflowNode::bSwapVectorInputs' has a wrong offset!");
static_assert(offsetof(FSumVectorFieldDataflowNode, FieldVectorResult) == 0x000158, "Member 'FSumVectorFieldDataflowNode::FieldVectorResult' has a wrong offset!");
static_assert(offsetof(FSumVectorFieldDataflowNode, FieldRemap) == 0x000168, "Member 'FSumVectorFieldDataflowNode::FieldRemap' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.FieldMakeDenseFloatArrayDataflowNode
// 0x0038 (0x0128 - 0x00F0)
struct FFieldMakeDenseFloatArrayDataflowNode final : public FDataflowNode
{
public:
	TArray<float>                                 FieldFloatInput;                                   // 0x00F0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 FieldRemap;                                        // 0x0100(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         NumSamplePositions;                                // 0x0110(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Default;                                           // 0x0114(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 FieldFloatResult;                                  // 0x0118(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFieldMakeDenseFloatArrayDataflowNode) == 0x000008, "Wrong alignment on FFieldMakeDenseFloatArrayDataflowNode");
static_assert(sizeof(FFieldMakeDenseFloatArrayDataflowNode) == 0x000128, "Wrong size on FFieldMakeDenseFloatArrayDataflowNode");
static_assert(offsetof(FFieldMakeDenseFloatArrayDataflowNode, FieldFloatInput) == 0x0000F0, "Member 'FFieldMakeDenseFloatArrayDataflowNode::FieldFloatInput' has a wrong offset!");
static_assert(offsetof(FFieldMakeDenseFloatArrayDataflowNode, FieldRemap) == 0x000100, "Member 'FFieldMakeDenseFloatArrayDataflowNode::FieldRemap' has a wrong offset!");
static_assert(offsetof(FFieldMakeDenseFloatArrayDataflowNode, NumSamplePositions) == 0x000110, "Member 'FFieldMakeDenseFloatArrayDataflowNode::NumSamplePositions' has a wrong offset!");
static_assert(offsetof(FFieldMakeDenseFloatArrayDataflowNode, Default) == 0x000114, "Member 'FFieldMakeDenseFloatArrayDataflowNode::Default' has a wrong offset!");
static_assert(offsetof(FFieldMakeDenseFloatArrayDataflowNode, FieldFloatResult) == 0x000118, "Member 'FFieldMakeDenseFloatArrayDataflowNode::FieldFloatResult' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.AddMaterialToCollectionDataflowNode
// 0x00F8 (0x01E8 - 0x00F0)
struct FAddMaterialToCollectionDataflowNode final : public FDataflowNode
{
public:
	struct FManagedArrayCollection                Collection;                                        // 0x00F0(0x00B0)(NativeAccessSpecifierPublic)
	struct FDataflowFaceSelection                 FaceSelection;                                     // 0x01A0(0x0020)(NativeAccessSpecifierPublic)
	TArray<class UMaterial*>                      Materials;                                         // 0x01C0(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	class UMaterial*                              OutsideMaterial;                                   // 0x01D0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterial*                              InsideMaterial;                                    // 0x01D8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAssignOutsideMaterial;                            // 0x01E0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAssignInsideMaterial;                             // 0x01E1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E2[0x6];                                      // 0x01E2(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAddMaterialToCollectionDataflowNode) == 0x000008, "Wrong alignment on FAddMaterialToCollectionDataflowNode");
static_assert(sizeof(FAddMaterialToCollectionDataflowNode) == 0x0001E8, "Wrong size on FAddMaterialToCollectionDataflowNode");
static_assert(offsetof(FAddMaterialToCollectionDataflowNode, Collection) == 0x0000F0, "Member 'FAddMaterialToCollectionDataflowNode::Collection' has a wrong offset!");
static_assert(offsetof(FAddMaterialToCollectionDataflowNode, FaceSelection) == 0x0001A0, "Member 'FAddMaterialToCollectionDataflowNode::FaceSelection' has a wrong offset!");
static_assert(offsetof(FAddMaterialToCollectionDataflowNode, Materials) == 0x0001C0, "Member 'FAddMaterialToCollectionDataflowNode::Materials' has a wrong offset!");
static_assert(offsetof(FAddMaterialToCollectionDataflowNode, OutsideMaterial) == 0x0001D0, "Member 'FAddMaterialToCollectionDataflowNode::OutsideMaterial' has a wrong offset!");
static_assert(offsetof(FAddMaterialToCollectionDataflowNode, InsideMaterial) == 0x0001D8, "Member 'FAddMaterialToCollectionDataflowNode::InsideMaterial' has a wrong offset!");
static_assert(offsetof(FAddMaterialToCollectionDataflowNode, bAssignOutsideMaterial) == 0x0001E0, "Member 'FAddMaterialToCollectionDataflowNode::bAssignOutsideMaterial' has a wrong offset!");
static_assert(offsetof(FAddMaterialToCollectionDataflowNode, bAssignInsideMaterial) == 0x0001E1, "Member 'FAddMaterialToCollectionDataflowNode::bAssignInsideMaterial' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.ReAssignMaterialInCollectionDataflowNode
// 0x00F0 (0x01E0 - 0x00F0)
struct FReAssignMaterialInCollectionDataflowNode final : public FDataflowNode
{
public:
	struct FManagedArrayCollection                Collection;                                        // 0x00F0(0x00B0)(NativeAccessSpecifierPublic)
	struct FDataflowFaceSelection                 FaceSelection;                                     // 0x01A0(0x0020)(NativeAccessSpecifierPublic)
	TArray<class UMaterial*>                      Materials;                                         // 0x01C0(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	int32                                         OutsideMaterialIdx;                                // 0x01D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InsideMaterialIdx;                                 // 0x01D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAssignOutsideMaterial;                            // 0x01D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAssignInsideMaterial;                             // 0x01D9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1DA[0x6];                                      // 0x01DA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FReAssignMaterialInCollectionDataflowNode) == 0x000008, "Wrong alignment on FReAssignMaterialInCollectionDataflowNode");
static_assert(sizeof(FReAssignMaterialInCollectionDataflowNode) == 0x0001E0, "Wrong size on FReAssignMaterialInCollectionDataflowNode");
static_assert(offsetof(FReAssignMaterialInCollectionDataflowNode, Collection) == 0x0000F0, "Member 'FReAssignMaterialInCollectionDataflowNode::Collection' has a wrong offset!");
static_assert(offsetof(FReAssignMaterialInCollectionDataflowNode, FaceSelection) == 0x0001A0, "Member 'FReAssignMaterialInCollectionDataflowNode::FaceSelection' has a wrong offset!");
static_assert(offsetof(FReAssignMaterialInCollectionDataflowNode, Materials) == 0x0001C0, "Member 'FReAssignMaterialInCollectionDataflowNode::Materials' has a wrong offset!");
static_assert(offsetof(FReAssignMaterialInCollectionDataflowNode, OutsideMaterialIdx) == 0x0001D0, "Member 'FReAssignMaterialInCollectionDataflowNode::OutsideMaterialIdx' has a wrong offset!");
static_assert(offsetof(FReAssignMaterialInCollectionDataflowNode, InsideMaterialIdx) == 0x0001D4, "Member 'FReAssignMaterialInCollectionDataflowNode::InsideMaterialIdx' has a wrong offset!");
static_assert(offsetof(FReAssignMaterialInCollectionDataflowNode, bAssignOutsideMaterial) == 0x0001D8, "Member 'FReAssignMaterialInCollectionDataflowNode::bAssignOutsideMaterial' has a wrong offset!");
static_assert(offsetof(FReAssignMaterialInCollectionDataflowNode, bAssignInsideMaterial) == 0x0001D9, "Member 'FReAssignMaterialInCollectionDataflowNode::bAssignInsideMaterial' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.MaterialsInfoDataflowNode
// 0x0020 (0x0110 - 0x00F0)
struct FMaterialsInfoDataflowNode final : public FDataflowNode
{
public:
	TArray<class UMaterial*>                      Materials;                                         // 0x00F0(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	class FString                                 String;                                            // 0x0100(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMaterialsInfoDataflowNode) == 0x000008, "Wrong alignment on FMaterialsInfoDataflowNode");
static_assert(sizeof(FMaterialsInfoDataflowNode) == 0x000110, "Wrong size on FMaterialsInfoDataflowNode");
static_assert(offsetof(FMaterialsInfoDataflowNode, Materials) == 0x0000F0, "Member 'FMaterialsInfoDataflowNode::Materials' has a wrong offset!");
static_assert(offsetof(FMaterialsInfoDataflowNode, String) == 0x000100, "Member 'FMaterialsInfoDataflowNode::String' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.GetMaterialFromMaterialsArrayDataflowNode
// 0x0020 (0x0110 - 0x00F0)
struct FGetMaterialFromMaterialsArrayDataflowNode final : public FDataflowNode
{
public:
	TArray<class UMaterial*>                      Materials;                                         // 0x00F0(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	class UMaterial*                              Material;                                          // 0x0100(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaterialIdx;                                       // 0x0108(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10C[0x4];                                      // 0x010C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGetMaterialFromMaterialsArrayDataflowNode) == 0x000008, "Wrong alignment on FGetMaterialFromMaterialsArrayDataflowNode");
static_assert(sizeof(FGetMaterialFromMaterialsArrayDataflowNode) == 0x000110, "Wrong size on FGetMaterialFromMaterialsArrayDataflowNode");
static_assert(offsetof(FGetMaterialFromMaterialsArrayDataflowNode, Materials) == 0x0000F0, "Member 'FGetMaterialFromMaterialsArrayDataflowNode::Materials' has a wrong offset!");
static_assert(offsetof(FGetMaterialFromMaterialsArrayDataflowNode, Material) == 0x000100, "Member 'FGetMaterialFromMaterialsArrayDataflowNode::Material' has a wrong offset!");
static_assert(offsetof(FGetMaterialFromMaterialsArrayDataflowNode, MaterialIdx) == 0x000108, "Member 'FGetMaterialFromMaterialsArrayDataflowNode::MaterialIdx' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.SetMaterialInMaterialsArrayDataflowNode
// 0x0020 (0x0110 - 0x00F0)
struct FSetMaterialInMaterialsArrayDataflowNode final : public FDataflowNode
{
public:
	TArray<class UMaterial*>                      Materials;                                         // 0x00F0(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	class UMaterial*                              Material;                                          // 0x0100(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESetMaterialOperationTypeEnum                 Operation;                                         // 0x0108(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_109[0x3];                                      // 0x0109(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaterialIdx;                                       // 0x010C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSetMaterialInMaterialsArrayDataflowNode) == 0x000008, "Wrong alignment on FSetMaterialInMaterialsArrayDataflowNode");
static_assert(sizeof(FSetMaterialInMaterialsArrayDataflowNode) == 0x000110, "Wrong size on FSetMaterialInMaterialsArrayDataflowNode");
static_assert(offsetof(FSetMaterialInMaterialsArrayDataflowNode, Materials) == 0x0000F0, "Member 'FSetMaterialInMaterialsArrayDataflowNode::Materials' has a wrong offset!");
static_assert(offsetof(FSetMaterialInMaterialsArrayDataflowNode, Material) == 0x000100, "Member 'FSetMaterialInMaterialsArrayDataflowNode::Material' has a wrong offset!");
static_assert(offsetof(FSetMaterialInMaterialsArrayDataflowNode, Operation) == 0x000108, "Member 'FSetMaterialInMaterialsArrayDataflowNode::Operation' has a wrong offset!");
static_assert(offsetof(FSetMaterialInMaterialsArrayDataflowNode, MaterialIdx) == 0x00010C, "Member 'FSetMaterialInMaterialsArrayDataflowNode::MaterialIdx' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.MakeMaterialDataflowNode
// 0x0010 (0x0100 - 0x00F0)
struct FMakeMaterialDataflowNode final : public FDataflowNode
{
public:
	class UMaterial*                              InMaterial;                                        // 0x00F0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterial*                              Material;                                          // 0x00F8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMakeMaterialDataflowNode) == 0x000008, "Wrong alignment on FMakeMaterialDataflowNode");
static_assert(sizeof(FMakeMaterialDataflowNode) == 0x000100, "Wrong size on FMakeMaterialDataflowNode");
static_assert(offsetof(FMakeMaterialDataflowNode, InMaterial) == 0x0000F0, "Member 'FMakeMaterialDataflowNode::InMaterial' has a wrong offset!");
static_assert(offsetof(FMakeMaterialDataflowNode, Material) == 0x0000F8, "Member 'FMakeMaterialDataflowNode::Material' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.MakeMaterialsArrayDataflowNode
// 0x0010 (0x0100 - 0x00F0)
struct FMakeMaterialsArrayDataflowNode final : public FDataflowNode
{
public:
	TArray<class UMaterial*>                      Materials;                                         // 0x00F0(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMakeMaterialsArrayDataflowNode) == 0x000008, "Wrong alignment on FMakeMaterialsArrayDataflowNode");
static_assert(sizeof(FMakeMaterialsArrayDataflowNode) == 0x000100, "Wrong size on FMakeMaterialsArrayDataflowNode");
static_assert(offsetof(FMakeMaterialsArrayDataflowNode, Materials) == 0x0000F0, "Member 'FMakeMaterialsArrayDataflowNode::Materials' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.CloseGeometryOnCollectionDataflowNode
// 0x00B0 (0x01A0 - 0x00F0)
struct FCloseGeometryOnCollectionDataflowNode final : public FDataflowNode
{
public:
	struct FManagedArrayCollection                Collection;                                        // 0x00F0(0x00B0)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FCloseGeometryOnCollectionDataflowNode) == 0x000008, "Wrong alignment on FCloseGeometryOnCollectionDataflowNode");
static_assert(sizeof(FCloseGeometryOnCollectionDataflowNode) == 0x0001A0, "Wrong size on FCloseGeometryOnCollectionDataflowNode");
static_assert(offsetof(FCloseGeometryOnCollectionDataflowNode, Collection) == 0x0000F0, "Member 'FCloseGeometryOnCollectionDataflowNode::Collection' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.SkeletonToCollectionDataflowNode
// 0x00B8 (0x01A8 - 0x00F0)
struct FSkeletonToCollectionDataflowNode final : public FDataflowNode
{
public:
	class USkeleton*                              Skeleton;                                          // 0x00F0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FManagedArrayCollection                Collection;                                        // 0x00F8(0x00B0)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FSkeletonToCollectionDataflowNode) == 0x000008, "Wrong alignment on FSkeletonToCollectionDataflowNode");
static_assert(sizeof(FSkeletonToCollectionDataflowNode) == 0x0001A8, "Wrong size on FSkeletonToCollectionDataflowNode");
static_assert(offsetof(FSkeletonToCollectionDataflowNode, Skeleton) == 0x0000F0, "Member 'FSkeletonToCollectionDataflowNode::Skeleton' has a wrong offset!");
static_assert(offsetof(FSkeletonToCollectionDataflowNode, Collection) == 0x0000F8, "Member 'FSkeletonToCollectionDataflowNode::Collection' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.CreateNonOverlappingConvexHullsDataflowNode
// 0x00C8 (0x01B8 - 0x00F0)
struct FCreateNonOverlappingConvexHullsDataflowNode final : public FDataflowNode
{
public:
	struct FManagedArrayCollection                Collection;                                        // 0x00F0(0x00B0)(NativeAccessSpecifierPublic)
	float                                         CanRemoveFraction;                                 // 0x01A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SimplificationDistanceThreshold;                   // 0x01A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CanExceedFraction;                                 // 0x01A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EConvexOverlapRemovalMethodEnum               OverlapRemovalMethod;                              // 0x01AC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1AD[0x3];                                      // 0x01AD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OverlapRemovalShrinkPercent;                       // 0x01B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B4[0x4];                                      // 0x01B4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCreateNonOverlappingConvexHullsDataflowNode) == 0x000008, "Wrong alignment on FCreateNonOverlappingConvexHullsDataflowNode");
static_assert(sizeof(FCreateNonOverlappingConvexHullsDataflowNode) == 0x0001B8, "Wrong size on FCreateNonOverlappingConvexHullsDataflowNode");
static_assert(offsetof(FCreateNonOverlappingConvexHullsDataflowNode, Collection) == 0x0000F0, "Member 'FCreateNonOverlappingConvexHullsDataflowNode::Collection' has a wrong offset!");
static_assert(offsetof(FCreateNonOverlappingConvexHullsDataflowNode, CanRemoveFraction) == 0x0001A0, "Member 'FCreateNonOverlappingConvexHullsDataflowNode::CanRemoveFraction' has a wrong offset!");
static_assert(offsetof(FCreateNonOverlappingConvexHullsDataflowNode, SimplificationDistanceThreshold) == 0x0001A4, "Member 'FCreateNonOverlappingConvexHullsDataflowNode::SimplificationDistanceThreshold' has a wrong offset!");
static_assert(offsetof(FCreateNonOverlappingConvexHullsDataflowNode, CanExceedFraction) == 0x0001A8, "Member 'FCreateNonOverlappingConvexHullsDataflowNode::CanExceedFraction' has a wrong offset!");
static_assert(offsetof(FCreateNonOverlappingConvexHullsDataflowNode, OverlapRemovalMethod) == 0x0001AC, "Member 'FCreateNonOverlappingConvexHullsDataflowNode::OverlapRemovalMethod' has a wrong offset!");
static_assert(offsetof(FCreateNonOverlappingConvexHullsDataflowNode, OverlapRemovalShrinkPercent) == 0x0001B0, "Member 'FCreateNonOverlappingConvexHullsDataflowNode::OverlapRemovalShrinkPercent' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.AutoClusterDataflowNode
// 0x00E8 (0x01D8 - 0x00F0)
struct FAutoClusterDataflowNode final : public FDataflowNode
{
public:
	EClusterSizeMethodEnum                        ClusterSizeMethod;                                 // 0x00F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F1[0x3];                                       // 0x00F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ClusterSites;                                      // 0x00F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClusterFraction;                                   // 0x00F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SiteSize;                                          // 0x00FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AutoCluster;                                       // 0x0100(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AvoidIsolated;                                     // 0x0101(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_102[0x6];                                      // 0x0102(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FManagedArrayCollection                Collection;                                        // 0x0108(0x00B0)(NativeAccessSpecifierPublic)
	struct FDataflowTransformSelection            TransformSelection;                                // 0x01B8(0x0020)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FAutoClusterDataflowNode) == 0x000008, "Wrong alignment on FAutoClusterDataflowNode");
static_assert(sizeof(FAutoClusterDataflowNode) == 0x0001D8, "Wrong size on FAutoClusterDataflowNode");
static_assert(offsetof(FAutoClusterDataflowNode, ClusterSizeMethod) == 0x0000F0, "Member 'FAutoClusterDataflowNode::ClusterSizeMethod' has a wrong offset!");
static_assert(offsetof(FAutoClusterDataflowNode, ClusterSites) == 0x0000F4, "Member 'FAutoClusterDataflowNode::ClusterSites' has a wrong offset!");
static_assert(offsetof(FAutoClusterDataflowNode, ClusterFraction) == 0x0000F8, "Member 'FAutoClusterDataflowNode::ClusterFraction' has a wrong offset!");
static_assert(offsetof(FAutoClusterDataflowNode, SiteSize) == 0x0000FC, "Member 'FAutoClusterDataflowNode::SiteSize' has a wrong offset!");
static_assert(offsetof(FAutoClusterDataflowNode, AutoCluster) == 0x000100, "Member 'FAutoClusterDataflowNode::AutoCluster' has a wrong offset!");
static_assert(offsetof(FAutoClusterDataflowNode, AvoidIsolated) == 0x000101, "Member 'FAutoClusterDataflowNode::AvoidIsolated' has a wrong offset!");
static_assert(offsetof(FAutoClusterDataflowNode, Collection) == 0x000108, "Member 'FAutoClusterDataflowNode::Collection' has a wrong offset!");
static_assert(offsetof(FAutoClusterDataflowNode, TransformSelection) == 0x0001B8, "Member 'FAutoClusterDataflowNode::TransformSelection' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.ClusterFlattenDataflowNode
// 0x00B0 (0x01A0 - 0x00F0)
struct FClusterFlattenDataflowNode final : public FDataflowNode
{
public:
	struct FManagedArrayCollection                Collection;                                        // 0x00F0(0x00B0)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FClusterFlattenDataflowNode) == 0x000008, "Wrong alignment on FClusterFlattenDataflowNode");
static_assert(sizeof(FClusterFlattenDataflowNode) == 0x0001A0, "Wrong size on FClusterFlattenDataflowNode");
static_assert(offsetof(FClusterFlattenDataflowNode, Collection) == 0x0000F0, "Member 'FClusterFlattenDataflowNode::Collection' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.PruneInCollectionDataflowNode
// 0x00D0 (0x01C0 - 0x00F0)
struct FPruneInCollectionDataflowNode final : public FDataflowNode
{
public:
	struct FManagedArrayCollection                Collection;                                        // 0x00F0(0x00B0)(NativeAccessSpecifierPublic)
	struct FDataflowTransformSelection            TransformSelection;                                // 0x01A0(0x0020)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FPruneInCollectionDataflowNode) == 0x000008, "Wrong alignment on FPruneInCollectionDataflowNode");
static_assert(sizeof(FPruneInCollectionDataflowNode) == 0x0001C0, "Wrong size on FPruneInCollectionDataflowNode");
static_assert(offsetof(FPruneInCollectionDataflowNode, Collection) == 0x0000F0, "Member 'FPruneInCollectionDataflowNode::Collection' has a wrong offset!");
static_assert(offsetof(FPruneInCollectionDataflowNode, TransformSelection) == 0x0001A0, "Member 'FPruneInCollectionDataflowNode::TransformSelection' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.SetVisibilityInCollectionDataflowNode
// 0x00F8 (0x01E8 - 0x00F0)
struct FSetVisibilityInCollectionDataflowNode final : public FDataflowNode
{
public:
	EVisibiltyOptionsEnum                         Visibility;                                        // 0x00F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F1[0x7];                                       // 0x00F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FManagedArrayCollection                Collection;                                        // 0x00F8(0x00B0)(NativeAccessSpecifierPublic)
	struct FDataflowTransformSelection            TransformSelection;                                // 0x01A8(0x0020)(NativeAccessSpecifierPublic)
	struct FDataflowFaceSelection                 FaceSelection;                                     // 0x01C8(0x0020)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FSetVisibilityInCollectionDataflowNode) == 0x000008, "Wrong alignment on FSetVisibilityInCollectionDataflowNode");
static_assert(sizeof(FSetVisibilityInCollectionDataflowNode) == 0x0001E8, "Wrong size on FSetVisibilityInCollectionDataflowNode");
static_assert(offsetof(FSetVisibilityInCollectionDataflowNode, Visibility) == 0x0000F0, "Member 'FSetVisibilityInCollectionDataflowNode::Visibility' has a wrong offset!");
static_assert(offsetof(FSetVisibilityInCollectionDataflowNode, Collection) == 0x0000F8, "Member 'FSetVisibilityInCollectionDataflowNode::Collection' has a wrong offset!");
static_assert(offsetof(FSetVisibilityInCollectionDataflowNode, TransformSelection) == 0x0001A8, "Member 'FSetVisibilityInCollectionDataflowNode::TransformSelection' has a wrong offset!");
static_assert(offsetof(FSetVisibilityInCollectionDataflowNode, FaceSelection) == 0x0001C8, "Member 'FSetVisibilityInCollectionDataflowNode::FaceSelection' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.MergeInCollectionDataflowNode
// 0x00D0 (0x01C0 - 0x00F0)
struct FMergeInCollectionDataflowNode final : public FDataflowNode
{
public:
	struct FManagedArrayCollection                Collection;                                        // 0x00F0(0x00B0)(NativeAccessSpecifierPublic)
	struct FDataflowTransformSelection            TransformSelection;                                // 0x01A0(0x0020)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FMergeInCollectionDataflowNode) == 0x000008, "Wrong alignment on FMergeInCollectionDataflowNode");
static_assert(sizeof(FMergeInCollectionDataflowNode) == 0x0001C0, "Wrong size on FMergeInCollectionDataflowNode");
static_assert(offsetof(FMergeInCollectionDataflowNode, Collection) == 0x0000F0, "Member 'FMergeInCollectionDataflowNode::Collection' has a wrong offset!");
static_assert(offsetof(FMergeInCollectionDataflowNode, TransformSelection) == 0x0001A0, "Member 'FMergeInCollectionDataflowNode::TransformSelection' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.UniformScatterPointsDataflowNode
// 0x0058 (0x0148 - 0x00F0)
struct FUniformScatterPointsDataflowNode final : public FDataflowNode
{
public:
	int32                                         MinNumberOfPoints;                                 // 0x00F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxNumberOfPoints;                                 // 0x00F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RandomSeed;                                        // 0x00F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FC[0x4];                                       // 0x00FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBox                                   BoundingBox;                                       // 0x0100(0x0038)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        Points;                                            // 0x0138(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUniformScatterPointsDataflowNode) == 0x000008, "Wrong alignment on FUniformScatterPointsDataflowNode");
static_assert(sizeof(FUniformScatterPointsDataflowNode) == 0x000148, "Wrong size on FUniformScatterPointsDataflowNode");
static_assert(offsetof(FUniformScatterPointsDataflowNode, MinNumberOfPoints) == 0x0000F0, "Member 'FUniformScatterPointsDataflowNode::MinNumberOfPoints' has a wrong offset!");
static_assert(offsetof(FUniformScatterPointsDataflowNode, MaxNumberOfPoints) == 0x0000F4, "Member 'FUniformScatterPointsDataflowNode::MaxNumberOfPoints' has a wrong offset!");
static_assert(offsetof(FUniformScatterPointsDataflowNode, RandomSeed) == 0x0000F8, "Member 'FUniformScatterPointsDataflowNode::RandomSeed' has a wrong offset!");
static_assert(offsetof(FUniformScatterPointsDataflowNode, BoundingBox) == 0x000100, "Member 'FUniformScatterPointsDataflowNode::BoundingBox' has a wrong offset!");
static_assert(offsetof(FUniformScatterPointsDataflowNode, Points) == 0x000138, "Member 'FUniformScatterPointsDataflowNode::Points' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.RadialScatterPointsDataflowNode
// 0x0058 (0x0148 - 0x00F0)
struct FRadialScatterPointsDataflowNode final : public FDataflowNode
{
public:
	struct FVector                                Center;                                            // 0x00F0(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Normal;                                            // 0x0108(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0120(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AngularSteps;                                      // 0x0124(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RadialSteps;                                       // 0x0128(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngleOffset;                                       // 0x012C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Variability;                                       // 0x0130(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RandomSeed;                                        // 0x0134(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        Points;                                            // 0x0138(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRadialScatterPointsDataflowNode) == 0x000008, "Wrong alignment on FRadialScatterPointsDataflowNode");
static_assert(sizeof(FRadialScatterPointsDataflowNode) == 0x000148, "Wrong size on FRadialScatterPointsDataflowNode");
static_assert(offsetof(FRadialScatterPointsDataflowNode, Center) == 0x0000F0, "Member 'FRadialScatterPointsDataflowNode::Center' has a wrong offset!");
static_assert(offsetof(FRadialScatterPointsDataflowNode, Normal) == 0x000108, "Member 'FRadialScatterPointsDataflowNode::Normal' has a wrong offset!");
static_assert(offsetof(FRadialScatterPointsDataflowNode, Radius) == 0x000120, "Member 'FRadialScatterPointsDataflowNode::Radius' has a wrong offset!");
static_assert(offsetof(FRadialScatterPointsDataflowNode, AngularSteps) == 0x000124, "Member 'FRadialScatterPointsDataflowNode::AngularSteps' has a wrong offset!");
static_assert(offsetof(FRadialScatterPointsDataflowNode, RadialSteps) == 0x000128, "Member 'FRadialScatterPointsDataflowNode::RadialSteps' has a wrong offset!");
static_assert(offsetof(FRadialScatterPointsDataflowNode, AngleOffset) == 0x00012C, "Member 'FRadialScatterPointsDataflowNode::AngleOffset' has a wrong offset!");
static_assert(offsetof(FRadialScatterPointsDataflowNode, Variability) == 0x000130, "Member 'FRadialScatterPointsDataflowNode::Variability' has a wrong offset!");
static_assert(offsetof(FRadialScatterPointsDataflowNode, RandomSeed) == 0x000134, "Member 'FRadialScatterPointsDataflowNode::RandomSeed' has a wrong offset!");
static_assert(offsetof(FRadialScatterPointsDataflowNode, Points) == 0x000138, "Member 'FRadialScatterPointsDataflowNode::Points' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.VoronoiFractureDataflowNode
// 0x0110 (0x0200 - 0x00F0)
struct FVoronoiFractureDataflowNode final : public FDataflowNode
{
public:
	struct FManagedArrayCollection                Collection;                                        // 0x00F0(0x00B0)(NativeAccessSpecifierPublic)
	TArray<struct FVector>                        Points;                                            // 0x01A0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FDataflowTransformSelection            TransformSelection;                                // 0x01B0(0x0020)(NativeAccessSpecifierPublic)
	float                                         RandomSeed;                                        // 0x01D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChanceToFracture;                                  // 0x01D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          GroupFracture;                                     // 0x01D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D9[0x3];                                      // 0x01D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Grout;                                             // 0x01DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Amplitude;                                         // 0x01E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Frequency;                                         // 0x01E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Persistence;                                       // 0x01E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Lacunarity;                                        // 0x01EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OctaveNumber;                                      // 0x01F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PointSpacing;                                      // 0x01F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AddSamplesForCollision;                            // 0x01F8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F9[0x3];                                      // 0x01F9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CollisionSampleSpacing;                            // 0x01FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVoronoiFractureDataflowNode) == 0x000008, "Wrong alignment on FVoronoiFractureDataflowNode");
static_assert(sizeof(FVoronoiFractureDataflowNode) == 0x000200, "Wrong size on FVoronoiFractureDataflowNode");
static_assert(offsetof(FVoronoiFractureDataflowNode, Collection) == 0x0000F0, "Member 'FVoronoiFractureDataflowNode::Collection' has a wrong offset!");
static_assert(offsetof(FVoronoiFractureDataflowNode, Points) == 0x0001A0, "Member 'FVoronoiFractureDataflowNode::Points' has a wrong offset!");
static_assert(offsetof(FVoronoiFractureDataflowNode, TransformSelection) == 0x0001B0, "Member 'FVoronoiFractureDataflowNode::TransformSelection' has a wrong offset!");
static_assert(offsetof(FVoronoiFractureDataflowNode, RandomSeed) == 0x0001D0, "Member 'FVoronoiFractureDataflowNode::RandomSeed' has a wrong offset!");
static_assert(offsetof(FVoronoiFractureDataflowNode, ChanceToFracture) == 0x0001D4, "Member 'FVoronoiFractureDataflowNode::ChanceToFracture' has a wrong offset!");
static_assert(offsetof(FVoronoiFractureDataflowNode, GroupFracture) == 0x0001D8, "Member 'FVoronoiFractureDataflowNode::GroupFracture' has a wrong offset!");
static_assert(offsetof(FVoronoiFractureDataflowNode, Grout) == 0x0001DC, "Member 'FVoronoiFractureDataflowNode::Grout' has a wrong offset!");
static_assert(offsetof(FVoronoiFractureDataflowNode, Amplitude) == 0x0001E0, "Member 'FVoronoiFractureDataflowNode::Amplitude' has a wrong offset!");
static_assert(offsetof(FVoronoiFractureDataflowNode, Frequency) == 0x0001E4, "Member 'FVoronoiFractureDataflowNode::Frequency' has a wrong offset!");
static_assert(offsetof(FVoronoiFractureDataflowNode, Persistence) == 0x0001E8, "Member 'FVoronoiFractureDataflowNode::Persistence' has a wrong offset!");
static_assert(offsetof(FVoronoiFractureDataflowNode, Lacunarity) == 0x0001EC, "Member 'FVoronoiFractureDataflowNode::Lacunarity' has a wrong offset!");
static_assert(offsetof(FVoronoiFractureDataflowNode, OctaveNumber) == 0x0001F0, "Member 'FVoronoiFractureDataflowNode::OctaveNumber' has a wrong offset!");
static_assert(offsetof(FVoronoiFractureDataflowNode, PointSpacing) == 0x0001F4, "Member 'FVoronoiFractureDataflowNode::PointSpacing' has a wrong offset!");
static_assert(offsetof(FVoronoiFractureDataflowNode, AddSamplesForCollision) == 0x0001F8, "Member 'FVoronoiFractureDataflowNode::AddSamplesForCollision' has a wrong offset!");
static_assert(offsetof(FVoronoiFractureDataflowNode, CollisionSampleSpacing) == 0x0001FC, "Member 'FVoronoiFractureDataflowNode::CollisionSampleSpacing' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.PlaneCutterDataflowNode
// 0x0138 (0x0228 - 0x00F0)
struct FPlaneCutterDataflowNode final : public FDataflowNode
{
public:
	struct FManagedArrayCollection                Collection;                                        // 0x00F0(0x00B0)(NativeAccessSpecifierPublic)
	struct FBox                                   BoundingBox;                                       // 0x01A0(0x0038)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FDataflowTransformSelection            TransformSelection;                                // 0x01D8(0x0020)(NativeAccessSpecifierPublic)
	int32                                         NumPlanes;                                         // 0x01F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RandomSeed;                                        // 0x01FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Grout;                                             // 0x0200(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Amplitude;                                         // 0x0204(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Frequency;                                         // 0x0208(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Persistence;                                       // 0x020C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Lacunarity;                                        // 0x0210(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OctaveNumber;                                      // 0x0214(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PointSpacing;                                      // 0x0218(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AddSamplesForCollision;                            // 0x021C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21D[0x3];                                      // 0x021D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CollisionSampleSpacing;                            // 0x0220(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_224[0x4];                                      // 0x0224(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlaneCutterDataflowNode) == 0x000008, "Wrong alignment on FPlaneCutterDataflowNode");
static_assert(sizeof(FPlaneCutterDataflowNode) == 0x000228, "Wrong size on FPlaneCutterDataflowNode");
static_assert(offsetof(FPlaneCutterDataflowNode, Collection) == 0x0000F0, "Member 'FPlaneCutterDataflowNode::Collection' has a wrong offset!");
static_assert(offsetof(FPlaneCutterDataflowNode, BoundingBox) == 0x0001A0, "Member 'FPlaneCutterDataflowNode::BoundingBox' has a wrong offset!");
static_assert(offsetof(FPlaneCutterDataflowNode, TransformSelection) == 0x0001D8, "Member 'FPlaneCutterDataflowNode::TransformSelection' has a wrong offset!");
static_assert(offsetof(FPlaneCutterDataflowNode, NumPlanes) == 0x0001F8, "Member 'FPlaneCutterDataflowNode::NumPlanes' has a wrong offset!");
static_assert(offsetof(FPlaneCutterDataflowNode, RandomSeed) == 0x0001FC, "Member 'FPlaneCutterDataflowNode::RandomSeed' has a wrong offset!");
static_assert(offsetof(FPlaneCutterDataflowNode, Grout) == 0x000200, "Member 'FPlaneCutterDataflowNode::Grout' has a wrong offset!");
static_assert(offsetof(FPlaneCutterDataflowNode, Amplitude) == 0x000204, "Member 'FPlaneCutterDataflowNode::Amplitude' has a wrong offset!");
static_assert(offsetof(FPlaneCutterDataflowNode, Frequency) == 0x000208, "Member 'FPlaneCutterDataflowNode::Frequency' has a wrong offset!");
static_assert(offsetof(FPlaneCutterDataflowNode, Persistence) == 0x00020C, "Member 'FPlaneCutterDataflowNode::Persistence' has a wrong offset!");
static_assert(offsetof(FPlaneCutterDataflowNode, Lacunarity) == 0x000210, "Member 'FPlaneCutterDataflowNode::Lacunarity' has a wrong offset!");
static_assert(offsetof(FPlaneCutterDataflowNode, OctaveNumber) == 0x000214, "Member 'FPlaneCutterDataflowNode::OctaveNumber' has a wrong offset!");
static_assert(offsetof(FPlaneCutterDataflowNode, PointSpacing) == 0x000218, "Member 'FPlaneCutterDataflowNode::PointSpacing' has a wrong offset!");
static_assert(offsetof(FPlaneCutterDataflowNode, AddSamplesForCollision) == 0x00021C, "Member 'FPlaneCutterDataflowNode::AddSamplesForCollision' has a wrong offset!");
static_assert(offsetof(FPlaneCutterDataflowNode, CollisionSampleSpacing) == 0x000220, "Member 'FPlaneCutterDataflowNode::CollisionSampleSpacing' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.ExplodedViewDataflowNode
// 0x00D0 (0x01C0 - 0x00F0)
struct FExplodedViewDataflowNode final : public FDataflowNode
{
public:
	struct FManagedArrayCollection                Collection;                                        // 0x00F0(0x00B0)(NativeAccessSpecifierPublic)
	float                                         UniformScale;                                      // 0x01A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A4[0x4];                                      // 0x01A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Scale;                                             // 0x01A8(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FExplodedViewDataflowNode) == 0x000008, "Wrong alignment on FExplodedViewDataflowNode");
static_assert(sizeof(FExplodedViewDataflowNode) == 0x0001C0, "Wrong size on FExplodedViewDataflowNode");
static_assert(offsetof(FExplodedViewDataflowNode, Collection) == 0x0000F0, "Member 'FExplodedViewDataflowNode::Collection' has a wrong offset!");
static_assert(offsetof(FExplodedViewDataflowNode, UniformScale) == 0x0001A0, "Member 'FExplodedViewDataflowNode::UniformScale' has a wrong offset!");
static_assert(offsetof(FExplodedViewDataflowNode, Scale) == 0x0001A8, "Member 'FExplodedViewDataflowNode::Scale' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.PointsToMeshDataflowNode
// 0x0020 (0x0110 - 0x00F0)
struct FPointsToMeshDataflowNode final : public FDataflowNode
{
public:
	TArray<struct FVector>                        Points;                                            // 0x00F0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class UDynamicMesh*                           Mesh;                                              // 0x0100(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TriangleCount;                                     // 0x0108(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10C[0x4];                                      // 0x010C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPointsToMeshDataflowNode) == 0x000008, "Wrong alignment on FPointsToMeshDataflowNode");
static_assert(sizeof(FPointsToMeshDataflowNode) == 0x000110, "Wrong size on FPointsToMeshDataflowNode");
static_assert(offsetof(FPointsToMeshDataflowNode, Points) == 0x0000F0, "Member 'FPointsToMeshDataflowNode::Points' has a wrong offset!");
static_assert(offsetof(FPointsToMeshDataflowNode, Mesh) == 0x000100, "Member 'FPointsToMeshDataflowNode::Mesh' has a wrong offset!");
static_assert(offsetof(FPointsToMeshDataflowNode, TriangleCount) == 0x000108, "Member 'FPointsToMeshDataflowNode::TriangleCount' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.BoxToMeshDataflowNode
// 0x0048 (0x0138 - 0x00F0)
struct FBoxToMeshDataflowNode final : public FDataflowNode
{
public:
	struct FBox                                   Box;                                               // 0x00F0(0x0038)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class UDynamicMesh*                           Mesh;                                              // 0x0128(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TriangleCount;                                     // 0x0130(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_134[0x4];                                      // 0x0134(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBoxToMeshDataflowNode) == 0x000008, "Wrong alignment on FBoxToMeshDataflowNode");
static_assert(sizeof(FBoxToMeshDataflowNode) == 0x000138, "Wrong size on FBoxToMeshDataflowNode");
static_assert(offsetof(FBoxToMeshDataflowNode, Box) == 0x0000F0, "Member 'FBoxToMeshDataflowNode::Box' has a wrong offset!");
static_assert(offsetof(FBoxToMeshDataflowNode, Mesh) == 0x000128, "Member 'FBoxToMeshDataflowNode::Mesh' has a wrong offset!");
static_assert(offsetof(FBoxToMeshDataflowNode, TriangleCount) == 0x000130, "Member 'FBoxToMeshDataflowNode::TriangleCount' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.MeshInfoDataflowNode
// 0x0018 (0x0108 - 0x00F0)
struct FMeshInfoDataflowNode final : public FDataflowNode
{
public:
	class UDynamicMesh*                           Mesh;                                              // 0x00F0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 InfoString;                                        // 0x00F8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMeshInfoDataflowNode) == 0x000008, "Wrong alignment on FMeshInfoDataflowNode");
static_assert(sizeof(FMeshInfoDataflowNode) == 0x000108, "Wrong size on FMeshInfoDataflowNode");
static_assert(offsetof(FMeshInfoDataflowNode, Mesh) == 0x0000F0, "Member 'FMeshInfoDataflowNode::Mesh' has a wrong offset!");
static_assert(offsetof(FMeshInfoDataflowNode, InfoString) == 0x0000F8, "Member 'FMeshInfoDataflowNode::InfoString' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.MeshToCollectionDataflowNode
// 0x00B8 (0x01A8 - 0x00F0)
struct FMeshToCollectionDataflowNode final : public FDataflowNode
{
public:
	class UDynamicMesh*                           Mesh;                                              // 0x00F0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FManagedArrayCollection                Collection;                                        // 0x00F8(0x00B0)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FMeshToCollectionDataflowNode) == 0x000008, "Wrong alignment on FMeshToCollectionDataflowNode");
static_assert(sizeof(FMeshToCollectionDataflowNode) == 0x0001A8, "Wrong size on FMeshToCollectionDataflowNode");
static_assert(offsetof(FMeshToCollectionDataflowNode, Mesh) == 0x0000F0, "Member 'FMeshToCollectionDataflowNode::Mesh' has a wrong offset!");
static_assert(offsetof(FMeshToCollectionDataflowNode, Collection) == 0x0000F8, "Member 'FMeshToCollectionDataflowNode::Collection' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.CollectionToMeshDataflowNode
// 0x00C0 (0x01B0 - 0x00F0)
struct FCollectionToMeshDataflowNode final : public FDataflowNode
{
public:
	struct FManagedArrayCollection                Collection;                                        // 0x00F0(0x00B0)(NativeAccessSpecifierPublic)
	bool                                          bCenterPivot;                                      // 0x01A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A1[0x7];                                      // 0x01A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UDynamicMesh*                           Mesh;                                              // 0x01A8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCollectionToMeshDataflowNode) == 0x000008, "Wrong alignment on FCollectionToMeshDataflowNode");
static_assert(sizeof(FCollectionToMeshDataflowNode) == 0x0001B0, "Wrong size on FCollectionToMeshDataflowNode");
static_assert(offsetof(FCollectionToMeshDataflowNode, Collection) == 0x0000F0, "Member 'FCollectionToMeshDataflowNode::Collection' has a wrong offset!");
static_assert(offsetof(FCollectionToMeshDataflowNode, bCenterPivot) == 0x0001A0, "Member 'FCollectionToMeshDataflowNode::bCenterPivot' has a wrong offset!");
static_assert(offsetof(FCollectionToMeshDataflowNode, Mesh) == 0x0001A8, "Member 'FCollectionToMeshDataflowNode::Mesh' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.StaticMeshToMeshDataflowNode
// 0x0018 (0x0108 - 0x00F0)
struct FStaticMeshToMeshDataflowNode final : public FDataflowNode
{
public:
	class UStaticMesh*                            StaticMesh;                                        // 0x00F0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseHiRes;                                         // 0x00F8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F9[0x3];                                       // 0x00F9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LODLevel;                                          // 0x00FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDynamicMesh*                           Mesh;                                              // 0x0100(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStaticMeshToMeshDataflowNode) == 0x000008, "Wrong alignment on FStaticMeshToMeshDataflowNode");
static_assert(sizeof(FStaticMeshToMeshDataflowNode) == 0x000108, "Wrong size on FStaticMeshToMeshDataflowNode");
static_assert(offsetof(FStaticMeshToMeshDataflowNode, StaticMesh) == 0x0000F0, "Member 'FStaticMeshToMeshDataflowNode::StaticMesh' has a wrong offset!");
static_assert(offsetof(FStaticMeshToMeshDataflowNode, bUseHiRes) == 0x0000F8, "Member 'FStaticMeshToMeshDataflowNode::bUseHiRes' has a wrong offset!");
static_assert(offsetof(FStaticMeshToMeshDataflowNode, LODLevel) == 0x0000FC, "Member 'FStaticMeshToMeshDataflowNode::LODLevel' has a wrong offset!");
static_assert(offsetof(FStaticMeshToMeshDataflowNode, Mesh) == 0x000100, "Member 'FStaticMeshToMeshDataflowNode::Mesh' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.MeshAppendDataflowNode
// 0x0018 (0x0108 - 0x00F0)
struct FMeshAppendDataflowNode final : public FDataflowNode
{
public:
	class UDynamicMesh*                           Mesh1;                                             // 0x00F0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDynamicMesh*                           Mesh2;                                             // 0x00F8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDynamicMesh*                           Mesh;                                              // 0x0100(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMeshAppendDataflowNode) == 0x000008, "Wrong alignment on FMeshAppendDataflowNode");
static_assert(sizeof(FMeshAppendDataflowNode) == 0x000108, "Wrong size on FMeshAppendDataflowNode");
static_assert(offsetof(FMeshAppendDataflowNode, Mesh1) == 0x0000F0, "Member 'FMeshAppendDataflowNode::Mesh1' has a wrong offset!");
static_assert(offsetof(FMeshAppendDataflowNode, Mesh2) == 0x0000F8, "Member 'FMeshAppendDataflowNode::Mesh2' has a wrong offset!");
static_assert(offsetof(FMeshAppendDataflowNode, Mesh) == 0x000100, "Member 'FMeshAppendDataflowNode::Mesh' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.MeshBooleanDataflowNode
// 0x0020 (0x0110 - 0x00F0)
struct FMeshBooleanDataflowNode final : public FDataflowNode
{
public:
	EMeshBooleanOperationEnum                     Operation;                                         // 0x00F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F1[0x7];                                       // 0x00F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UDynamicMesh*                           Mesh1;                                             // 0x00F8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDynamicMesh*                           Mesh2;                                             // 0x0100(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDynamicMesh*                           Mesh;                                              // 0x0108(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMeshBooleanDataflowNode) == 0x000008, "Wrong alignment on FMeshBooleanDataflowNode");
static_assert(sizeof(FMeshBooleanDataflowNode) == 0x000110, "Wrong size on FMeshBooleanDataflowNode");
static_assert(offsetof(FMeshBooleanDataflowNode, Operation) == 0x0000F0, "Member 'FMeshBooleanDataflowNode::Operation' has a wrong offset!");
static_assert(offsetof(FMeshBooleanDataflowNode, Mesh1) == 0x0000F8, "Member 'FMeshBooleanDataflowNode::Mesh1' has a wrong offset!");
static_assert(offsetof(FMeshBooleanDataflowNode, Mesh2) == 0x000100, "Member 'FMeshBooleanDataflowNode::Mesh2' has a wrong offset!");
static_assert(offsetof(FMeshBooleanDataflowNode, Mesh) == 0x000108, "Member 'FMeshBooleanDataflowNode::Mesh' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.MeshCopyToPointsDataflowNode
// 0x0028 (0x0118 - 0x00F0)
struct FMeshCopyToPointsDataflowNode final : public FDataflowNode
{
public:
	TArray<struct FVector>                        Points;                                            // 0x00F0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class UDynamicMesh*                           MeshToCopy;                                        // 0x0100(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x0108(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10C[0x4];                                      // 0x010C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UDynamicMesh*                           Mesh;                                              // 0x0110(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMeshCopyToPointsDataflowNode) == 0x000008, "Wrong alignment on FMeshCopyToPointsDataflowNode");
static_assert(sizeof(FMeshCopyToPointsDataflowNode) == 0x000118, "Wrong size on FMeshCopyToPointsDataflowNode");
static_assert(offsetof(FMeshCopyToPointsDataflowNode, Points) == 0x0000F0, "Member 'FMeshCopyToPointsDataflowNode::Points' has a wrong offset!");
static_assert(offsetof(FMeshCopyToPointsDataflowNode, MeshToCopy) == 0x000100, "Member 'FMeshCopyToPointsDataflowNode::MeshToCopy' has a wrong offset!");
static_assert(offsetof(FMeshCopyToPointsDataflowNode, Scale) == 0x000108, "Member 'FMeshCopyToPointsDataflowNode::Scale' has a wrong offset!");
static_assert(offsetof(FMeshCopyToPointsDataflowNode, Mesh) == 0x000110, "Member 'FMeshCopyToPointsDataflowNode::Mesh' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.GetMeshDataDataflowNode
// 0x0018 (0x0108 - 0x00F0)
struct FGetMeshDataDataflowNode final : public FDataflowNode
{
public:
	class UDynamicMesh*                           Mesh;                                              // 0x00F0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         VertexCount;                                       // 0x00F8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EdgeCount;                                         // 0x00FC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TriangleCount;                                     // 0x0100(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_104[0x4];                                      // 0x0104(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGetMeshDataDataflowNode) == 0x000008, "Wrong alignment on FGetMeshDataDataflowNode");
static_assert(sizeof(FGetMeshDataDataflowNode) == 0x000108, "Wrong size on FGetMeshDataDataflowNode");
static_assert(offsetof(FGetMeshDataDataflowNode, Mesh) == 0x0000F0, "Member 'FGetMeshDataDataflowNode::Mesh' has a wrong offset!");
static_assert(offsetof(FGetMeshDataDataflowNode, VertexCount) == 0x0000F8, "Member 'FGetMeshDataDataflowNode::VertexCount' has a wrong offset!");
static_assert(offsetof(FGetMeshDataDataflowNode, EdgeCount) == 0x0000FC, "Member 'FGetMeshDataDataflowNode::EdgeCount' has a wrong offset!");
static_assert(offsetof(FGetMeshDataDataflowNode, TriangleCount) == 0x000100, "Member 'FGetMeshDataDataflowNode::TriangleCount' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.GetCollectionFromAssetDataflowNode
// 0x00B8 (0x01A8 - 0x00F0)
struct FGetCollectionFromAssetDataflowNode final : public FDataflowNode
{
public:
	class UGeometryCollection*                    CollectionAsset;                                   // 0x00F0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FManagedArrayCollection                Collection;                                        // 0x00F8(0x00B0)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FGetCollectionFromAssetDataflowNode) == 0x000008, "Wrong alignment on FGetCollectionFromAssetDataflowNode");
static_assert(sizeof(FGetCollectionFromAssetDataflowNode) == 0x0001A8, "Wrong size on FGetCollectionFromAssetDataflowNode");
static_assert(offsetof(FGetCollectionFromAssetDataflowNode, CollectionAsset) == 0x0000F0, "Member 'FGetCollectionFromAssetDataflowNode::CollectionAsset' has a wrong offset!");
static_assert(offsetof(FGetCollectionFromAssetDataflowNode, Collection) == 0x0000F8, "Member 'FGetCollectionFromAssetDataflowNode::Collection' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.AppendCollectionAssetsDataflowNode
// 0x0180 (0x0270 - 0x00F0)
struct FAppendCollectionAssetsDataflowNode final : public FDataflowNode
{
public:
	struct FManagedArrayCollection                Collection1;                                       // 0x00F0(0x00B0)(NativeAccessSpecifierPublic)
	struct FManagedArrayCollection                Collection2;                                       // 0x01A0(0x00B0)(NativeAccessSpecifierPublic)
	TArray<class FString>                         GeometryGroupGuidsOut1;                            // 0x0250(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         GeometryGroupGuidsOut2;                            // 0x0260(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAppendCollectionAssetsDataflowNode) == 0x000008, "Wrong alignment on FAppendCollectionAssetsDataflowNode");
static_assert(sizeof(FAppendCollectionAssetsDataflowNode) == 0x000270, "Wrong size on FAppendCollectionAssetsDataflowNode");
static_assert(offsetof(FAppendCollectionAssetsDataflowNode, Collection1) == 0x0000F0, "Member 'FAppendCollectionAssetsDataflowNode::Collection1' has a wrong offset!");
static_assert(offsetof(FAppendCollectionAssetsDataflowNode, Collection2) == 0x0001A0, "Member 'FAppendCollectionAssetsDataflowNode::Collection2' has a wrong offset!");
static_assert(offsetof(FAppendCollectionAssetsDataflowNode, GeometryGroupGuidsOut1) == 0x000250, "Member 'FAppendCollectionAssetsDataflowNode::GeometryGroupGuidsOut1' has a wrong offset!");
static_assert(offsetof(FAppendCollectionAssetsDataflowNode, GeometryGroupGuidsOut2) == 0x000260, "Member 'FAppendCollectionAssetsDataflowNode::GeometryGroupGuidsOut2' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.PrintStringDataflowNode
// 0x0020 (0x0110 - 0x00F0)
struct FPrintStringDataflowNode final : public FDataflowNode
{
public:
	bool                                          bPrintToScreen;                                    // 0x00F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPrintToLog;                                       // 0x00F1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F2[0x2];                                       // 0x00F2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FColor                                 Color;                                             // 0x00F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x00F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FC[0x4];                                       // 0x00FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 String;                                            // 0x0100(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPrintStringDataflowNode) == 0x000008, "Wrong alignment on FPrintStringDataflowNode");
static_assert(sizeof(FPrintStringDataflowNode) == 0x000110, "Wrong size on FPrintStringDataflowNode");
static_assert(offsetof(FPrintStringDataflowNode, bPrintToScreen) == 0x0000F0, "Member 'FPrintStringDataflowNode::bPrintToScreen' has a wrong offset!");
static_assert(offsetof(FPrintStringDataflowNode, bPrintToLog) == 0x0000F1, "Member 'FPrintStringDataflowNode::bPrintToLog' has a wrong offset!");
static_assert(offsetof(FPrintStringDataflowNode, Color) == 0x0000F4, "Member 'FPrintStringDataflowNode::Color' has a wrong offset!");
static_assert(offsetof(FPrintStringDataflowNode, Duration) == 0x0000F8, "Member 'FPrintStringDataflowNode::Duration' has a wrong offset!");
static_assert(offsetof(FPrintStringDataflowNode, String) == 0x000100, "Member 'FPrintStringDataflowNode::String' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.LogStringDataflowNode
// 0x0018 (0x0108 - 0x00F0)
struct FLogStringDataflowNode final : public FDataflowNode
{
public:
	bool                                          bPrintToLog;                                       // 0x00F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F1[0x7];                                       // 0x00F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 String;                                            // 0x00F8(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLogStringDataflowNode) == 0x000008, "Wrong alignment on FLogStringDataflowNode");
static_assert(sizeof(FLogStringDataflowNode) == 0x000108, "Wrong size on FLogStringDataflowNode");
static_assert(offsetof(FLogStringDataflowNode, bPrintToLog) == 0x0000F0, "Member 'FLogStringDataflowNode::bPrintToLog' has a wrong offset!");
static_assert(offsetof(FLogStringDataflowNode, String) == 0x0000F8, "Member 'FLogStringDataflowNode::String' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.MakeLiteralStringDataflowNode
// 0x0020 (0x0110 - 0x00F0)
struct FMakeLiteralStringDataflowNode final : public FDataflowNode
{
public:
	class FString                                 Value;                                             // 0x00F0(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 String;                                            // 0x0100(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMakeLiteralStringDataflowNode) == 0x000008, "Wrong alignment on FMakeLiteralStringDataflowNode");
static_assert(sizeof(FMakeLiteralStringDataflowNode) == 0x000110, "Wrong size on FMakeLiteralStringDataflowNode");
static_assert(offsetof(FMakeLiteralStringDataflowNode, Value) == 0x0000F0, "Member 'FMakeLiteralStringDataflowNode::Value' has a wrong offset!");
static_assert(offsetof(FMakeLiteralStringDataflowNode, String) == 0x000100, "Member 'FMakeLiteralStringDataflowNode::String' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.BoundingBoxDataflowNode
// 0x00E8 (0x01D8 - 0x00F0)
struct FBoundingBoxDataflowNode final : public FDataflowNode
{
public:
	struct FManagedArrayCollection                Collection;                                        // 0x00F0(0x00B0)(NativeAccessSpecifierPublic)
	struct FBox                                   BoundingBox;                                       // 0x01A0(0x0038)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBoundingBoxDataflowNode) == 0x000008, "Wrong alignment on FBoundingBoxDataflowNode");
static_assert(sizeof(FBoundingBoxDataflowNode) == 0x0001D8, "Wrong size on FBoundingBoxDataflowNode");
static_assert(offsetof(FBoundingBoxDataflowNode, Collection) == 0x0000F0, "Member 'FBoundingBoxDataflowNode::Collection' has a wrong offset!");
static_assert(offsetof(FBoundingBoxDataflowNode, BoundingBox) == 0x0001A0, "Member 'FBoundingBoxDataflowNode::BoundingBox' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.ExpandBoundingBoxDataflowNode
// 0x00A0 (0x0190 - 0x00F0)
struct FExpandBoundingBoxDataflowNode final : public FDataflowNode
{
public:
	struct FBox                                   BoundingBox;                                       // 0x00F0(0x0038)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Min;                                               // 0x0128(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Max;                                               // 0x0140(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Center;                                            // 0x0158(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HalfExtents;                                       // 0x0170(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Volume;                                            // 0x0188(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18C[0x4];                                      // 0x018C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FExpandBoundingBoxDataflowNode) == 0x000008, "Wrong alignment on FExpandBoundingBoxDataflowNode");
static_assert(sizeof(FExpandBoundingBoxDataflowNode) == 0x000190, "Wrong size on FExpandBoundingBoxDataflowNode");
static_assert(offsetof(FExpandBoundingBoxDataflowNode, BoundingBox) == 0x0000F0, "Member 'FExpandBoundingBoxDataflowNode::BoundingBox' has a wrong offset!");
static_assert(offsetof(FExpandBoundingBoxDataflowNode, Min) == 0x000128, "Member 'FExpandBoundingBoxDataflowNode::Min' has a wrong offset!");
static_assert(offsetof(FExpandBoundingBoxDataflowNode, Max) == 0x000140, "Member 'FExpandBoundingBoxDataflowNode::Max' has a wrong offset!");
static_assert(offsetof(FExpandBoundingBoxDataflowNode, Center) == 0x000158, "Member 'FExpandBoundingBoxDataflowNode::Center' has a wrong offset!");
static_assert(offsetof(FExpandBoundingBoxDataflowNode, HalfExtents) == 0x000170, "Member 'FExpandBoundingBoxDataflowNode::HalfExtents' has a wrong offset!");
static_assert(offsetof(FExpandBoundingBoxDataflowNode, Volume) == 0x000188, "Member 'FExpandBoundingBoxDataflowNode::Volume' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.VectorToStringDataflowNode
// 0x0028 (0x0118 - 0x00F0)
struct FVectorToStringDataflowNode final : public FDataflowNode
{
public:
	struct FVector                                Vector;                                            // 0x00F0(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 String;                                            // 0x0108(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVectorToStringDataflowNode) == 0x000008, "Wrong alignment on FVectorToStringDataflowNode");
static_assert(sizeof(FVectorToStringDataflowNode) == 0x000118, "Wrong size on FVectorToStringDataflowNode");
static_assert(offsetof(FVectorToStringDataflowNode, Vector) == 0x0000F0, "Member 'FVectorToStringDataflowNode::Vector' has a wrong offset!");
static_assert(offsetof(FVectorToStringDataflowNode, String) == 0x000108, "Member 'FVectorToStringDataflowNode::String' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.FloatToStringDataflowNode
// 0x0018 (0x0108 - 0x00F0)
struct FFloatToStringDataflowNode final : public FDataflowNode
{
public:
	float                                         Float;                                             // 0x00F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F4[0x4];                                       // 0x00F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 String;                                            // 0x00F8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFloatToStringDataflowNode) == 0x000008, "Wrong alignment on FFloatToStringDataflowNode");
static_assert(sizeof(FFloatToStringDataflowNode) == 0x000108, "Wrong size on FFloatToStringDataflowNode");
static_assert(offsetof(FFloatToStringDataflowNode, Float) == 0x0000F0, "Member 'FFloatToStringDataflowNode::Float' has a wrong offset!");
static_assert(offsetof(FFloatToStringDataflowNode, String) == 0x0000F8, "Member 'FFloatToStringDataflowNode::String' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.MakeBoxDataflowNode
// 0x00A0 (0x0190 - 0x00F0)
struct FMakeBoxDataflowNode final : public FDataflowNode
{
public:
	EMakeBoxDataTypeEnum                          DataType;                                          // 0x00F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F1[0x7];                                       // 0x00F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Min;                                               // 0x00F8(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Max;                                               // 0x0110(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Center;                                            // 0x0128(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Size;                                              // 0x0140(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBox                                   Box;                                               // 0x0158(0x0038)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMakeBoxDataflowNode) == 0x000008, "Wrong alignment on FMakeBoxDataflowNode");
static_assert(sizeof(FMakeBoxDataflowNode) == 0x000190, "Wrong size on FMakeBoxDataflowNode");
static_assert(offsetof(FMakeBoxDataflowNode, DataType) == 0x0000F0, "Member 'FMakeBoxDataflowNode::DataType' has a wrong offset!");
static_assert(offsetof(FMakeBoxDataflowNode, Min) == 0x0000F8, "Member 'FMakeBoxDataflowNode::Min' has a wrong offset!");
static_assert(offsetof(FMakeBoxDataflowNode, Max) == 0x000110, "Member 'FMakeBoxDataflowNode::Max' has a wrong offset!");
static_assert(offsetof(FMakeBoxDataflowNode, Center) == 0x000128, "Member 'FMakeBoxDataflowNode::Center' has a wrong offset!");
static_assert(offsetof(FMakeBoxDataflowNode, Size) == 0x000140, "Member 'FMakeBoxDataflowNode::Size' has a wrong offset!");
static_assert(offsetof(FMakeBoxDataflowNode, Box) == 0x000158, "Member 'FMakeBoxDataflowNode::Box' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.MakeSphereDataflowNode
// 0x0040 (0x0130 - 0x00F0)
struct FMakeSphereDataflowNode final : public FDataflowNode
{
public:
	struct FVector                                Center;                                            // 0x00F0(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0108(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10C[0x4];                                      // 0x010C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSphere                                Sphere;                                            // 0x0110(0x0020)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMakeSphereDataflowNode) == 0x000008, "Wrong alignment on FMakeSphereDataflowNode");
static_assert(sizeof(FMakeSphereDataflowNode) == 0x000130, "Wrong size on FMakeSphereDataflowNode");
static_assert(offsetof(FMakeSphereDataflowNode, Center) == 0x0000F0, "Member 'FMakeSphereDataflowNode::Center' has a wrong offset!");
static_assert(offsetof(FMakeSphereDataflowNode, Radius) == 0x000108, "Member 'FMakeSphereDataflowNode::Radius' has a wrong offset!");
static_assert(offsetof(FMakeSphereDataflowNode, Sphere) == 0x000110, "Member 'FMakeSphereDataflowNode::Sphere' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.MakeLiteralBoolDataflowNode
// 0x0008 (0x00F8 - 0x00F0)
struct FMakeLiteralBoolDataflowNode final : public FDataflowNode
{
public:
	bool                                          Value;                                             // 0x00F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Bool;                                              // 0x00F1(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F2[0x6];                                       // 0x00F2(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMakeLiteralBoolDataflowNode) == 0x000008, "Wrong alignment on FMakeLiteralBoolDataflowNode");
static_assert(sizeof(FMakeLiteralBoolDataflowNode) == 0x0000F8, "Wrong size on FMakeLiteralBoolDataflowNode");
static_assert(offsetof(FMakeLiteralBoolDataflowNode, Value) == 0x0000F0, "Member 'FMakeLiteralBoolDataflowNode::Value' has a wrong offset!");
static_assert(offsetof(FMakeLiteralBoolDataflowNode, Bool) == 0x0000F1, "Member 'FMakeLiteralBoolDataflowNode::Bool' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.IntToStringDataflowNode
// 0x0018 (0x0108 - 0x00F0)
struct FIntToStringDataflowNode final : public FDataflowNode
{
public:
	int32                                         Int;                                               // 0x00F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F4[0x4];                                       // 0x00F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 String;                                            // 0x00F8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FIntToStringDataflowNode) == 0x000008, "Wrong alignment on FIntToStringDataflowNode");
static_assert(sizeof(FIntToStringDataflowNode) == 0x000108, "Wrong size on FIntToStringDataflowNode");
static_assert(offsetof(FIntToStringDataflowNode, Int) == 0x0000F0, "Member 'FIntToStringDataflowNode::Int' has a wrong offset!");
static_assert(offsetof(FIntToStringDataflowNode, String) == 0x0000F8, "Member 'FIntToStringDataflowNode::String' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.BoolToStringDataflowNode
// 0x0018 (0x0108 - 0x00F0)
struct FBoolToStringDataflowNode final : public FDataflowNode
{
public:
	bool                                          Bool;                                              // 0x00F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F1[0x7];                                       // 0x00F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 String;                                            // 0x00F8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBoolToStringDataflowNode) == 0x000008, "Wrong alignment on FBoolToStringDataflowNode");
static_assert(sizeof(FBoolToStringDataflowNode) == 0x000108, "Wrong size on FBoolToStringDataflowNode");
static_assert(offsetof(FBoolToStringDataflowNode, Bool) == 0x0000F0, "Member 'FBoolToStringDataflowNode::Bool' has a wrong offset!");
static_assert(offsetof(FBoolToStringDataflowNode, String) == 0x0000F8, "Member 'FBoolToStringDataflowNode::String' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.ExpandVectorDataflowNode
// 0x0028 (0x0118 - 0x00F0)
struct FExpandVectorDataflowNode final : public FDataflowNode
{
public:
	struct FVector                                Vector;                                            // 0x00F0(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         X;                                                 // 0x0108(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Y;                                                 // 0x010C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Z;                                                 // 0x0110(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_114[0x4];                                      // 0x0114(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FExpandVectorDataflowNode) == 0x000008, "Wrong alignment on FExpandVectorDataflowNode");
static_assert(sizeof(FExpandVectorDataflowNode) == 0x000118, "Wrong size on FExpandVectorDataflowNode");
static_assert(offsetof(FExpandVectorDataflowNode, Vector) == 0x0000F0, "Member 'FExpandVectorDataflowNode::Vector' has a wrong offset!");
static_assert(offsetof(FExpandVectorDataflowNode, X) == 0x000108, "Member 'FExpandVectorDataflowNode::X' has a wrong offset!");
static_assert(offsetof(FExpandVectorDataflowNode, Y) == 0x00010C, "Member 'FExpandVectorDataflowNode::Y' has a wrong offset!");
static_assert(offsetof(FExpandVectorDataflowNode, Z) == 0x000110, "Member 'FExpandVectorDataflowNode::Z' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.IntToFloatDataflowNode
// 0x0008 (0x00F8 - 0x00F0)
struct FIntToFloatDataflowNode final : public FDataflowNode
{
public:
	int32                                         Int;                                               // 0x00F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Float;                                             // 0x00F4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FIntToFloatDataflowNode) == 0x000008, "Wrong alignment on FIntToFloatDataflowNode");
static_assert(sizeof(FIntToFloatDataflowNode) == 0x0000F8, "Wrong size on FIntToFloatDataflowNode");
static_assert(offsetof(FIntToFloatDataflowNode, Int) == 0x0000F0, "Member 'FIntToFloatDataflowNode::Int' has a wrong offset!");
static_assert(offsetof(FIntToFloatDataflowNode, Float) == 0x0000F4, "Member 'FIntToFloatDataflowNode::Float' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.StringAppendDataflowNode
// 0x0030 (0x0120 - 0x00F0)
struct FStringAppendDataflowNode final : public FDataflowNode
{
public:
	class FString                                 String1;                                           // 0x00F0(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 String2;                                           // 0x0100(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 String;                                            // 0x0110(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStringAppendDataflowNode) == 0x000008, "Wrong alignment on FStringAppendDataflowNode");
static_assert(sizeof(FStringAppendDataflowNode) == 0x000120, "Wrong size on FStringAppendDataflowNode");
static_assert(offsetof(FStringAppendDataflowNode, String1) == 0x0000F0, "Member 'FStringAppendDataflowNode::String1' has a wrong offset!");
static_assert(offsetof(FStringAppendDataflowNode, String2) == 0x000100, "Member 'FStringAppendDataflowNode::String2' has a wrong offset!");
static_assert(offsetof(FStringAppendDataflowNode, String) == 0x000110, "Member 'FStringAppendDataflowNode::String' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.RandomFloatDataflowNode
// 0x0010 (0x0100 - 0x00F0)
struct FRandomFloatDataflowNode final : public FDataflowNode
{
public:
	bool                                          bDeterministic;                                    // 0x00F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F1[0x3];                                       // 0x00F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RandomSeed;                                        // 0x00F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Float;                                             // 0x00F8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FC[0x4];                                       // 0x00FC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRandomFloatDataflowNode) == 0x000008, "Wrong alignment on FRandomFloatDataflowNode");
static_assert(sizeof(FRandomFloatDataflowNode) == 0x000100, "Wrong size on FRandomFloatDataflowNode");
static_assert(offsetof(FRandomFloatDataflowNode, bDeterministic) == 0x0000F0, "Member 'FRandomFloatDataflowNode::bDeterministic' has a wrong offset!");
static_assert(offsetof(FRandomFloatDataflowNode, RandomSeed) == 0x0000F4, "Member 'FRandomFloatDataflowNode::RandomSeed' has a wrong offset!");
static_assert(offsetof(FRandomFloatDataflowNode, Float) == 0x0000F8, "Member 'FRandomFloatDataflowNode::Float' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.RandomFloatInRangeDataflowNode
// 0x0018 (0x0108 - 0x00F0)
struct FRandomFloatInRangeDataflowNode final : public FDataflowNode
{
public:
	bool                                          bDeterministic;                                    // 0x00F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F1[0x3];                                       // 0x00F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RandomSeed;                                        // 0x00F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Min;                                               // 0x00F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Max;                                               // 0x00FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Float;                                             // 0x0100(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_104[0x4];                                      // 0x0104(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRandomFloatInRangeDataflowNode) == 0x000008, "Wrong alignment on FRandomFloatInRangeDataflowNode");
static_assert(sizeof(FRandomFloatInRangeDataflowNode) == 0x000108, "Wrong size on FRandomFloatInRangeDataflowNode");
static_assert(offsetof(FRandomFloatInRangeDataflowNode, bDeterministic) == 0x0000F0, "Member 'FRandomFloatInRangeDataflowNode::bDeterministic' has a wrong offset!");
static_assert(offsetof(FRandomFloatInRangeDataflowNode, RandomSeed) == 0x0000F4, "Member 'FRandomFloatInRangeDataflowNode::RandomSeed' has a wrong offset!");
static_assert(offsetof(FRandomFloatInRangeDataflowNode, Min) == 0x0000F8, "Member 'FRandomFloatInRangeDataflowNode::Min' has a wrong offset!");
static_assert(offsetof(FRandomFloatInRangeDataflowNode, Max) == 0x0000FC, "Member 'FRandomFloatInRangeDataflowNode::Max' has a wrong offset!");
static_assert(offsetof(FRandomFloatInRangeDataflowNode, Float) == 0x000100, "Member 'FRandomFloatInRangeDataflowNode::Float' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.RandomUnitVectorDataflowNode
// 0x0020 (0x0110 - 0x00F0)
struct FRandomUnitVectorDataflowNode final : public FDataflowNode
{
public:
	bool                                          bDeterministic;                                    // 0x00F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F1[0x3];                                       // 0x00F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RandomSeed;                                        // 0x00F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Vector;                                            // 0x00F8(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRandomUnitVectorDataflowNode) == 0x000008, "Wrong alignment on FRandomUnitVectorDataflowNode");
static_assert(sizeof(FRandomUnitVectorDataflowNode) == 0x000110, "Wrong size on FRandomUnitVectorDataflowNode");
static_assert(offsetof(FRandomUnitVectorDataflowNode, bDeterministic) == 0x0000F0, "Member 'FRandomUnitVectorDataflowNode::bDeterministic' has a wrong offset!");
static_assert(offsetof(FRandomUnitVectorDataflowNode, RandomSeed) == 0x0000F4, "Member 'FRandomUnitVectorDataflowNode::RandomSeed' has a wrong offset!");
static_assert(offsetof(FRandomUnitVectorDataflowNode, Vector) == 0x0000F8, "Member 'FRandomUnitVectorDataflowNode::Vector' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.RandomUnitVectorInConeDataflowNode
// 0x0040 (0x0130 - 0x00F0)
struct FRandomUnitVectorInConeDataflowNode final : public FDataflowNode
{
public:
	bool                                          bDeterministic;                                    // 0x00F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F1[0x3];                                       // 0x00F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RandomSeed;                                        // 0x00F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ConeDirection;                                     // 0x00F8(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConeHalfAngle;                                     // 0x0110(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_114[0x4];                                      // 0x0114(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Vector;                                            // 0x0118(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRandomUnitVectorInConeDataflowNode) == 0x000008, "Wrong alignment on FRandomUnitVectorInConeDataflowNode");
static_assert(sizeof(FRandomUnitVectorInConeDataflowNode) == 0x000130, "Wrong size on FRandomUnitVectorInConeDataflowNode");
static_assert(offsetof(FRandomUnitVectorInConeDataflowNode, bDeterministic) == 0x0000F0, "Member 'FRandomUnitVectorInConeDataflowNode::bDeterministic' has a wrong offset!");
static_assert(offsetof(FRandomUnitVectorInConeDataflowNode, RandomSeed) == 0x0000F4, "Member 'FRandomUnitVectorInConeDataflowNode::RandomSeed' has a wrong offset!");
static_assert(offsetof(FRandomUnitVectorInConeDataflowNode, ConeDirection) == 0x0000F8, "Member 'FRandomUnitVectorInConeDataflowNode::ConeDirection' has a wrong offset!");
static_assert(offsetof(FRandomUnitVectorInConeDataflowNode, ConeHalfAngle) == 0x000110, "Member 'FRandomUnitVectorInConeDataflowNode::ConeHalfAngle' has a wrong offset!");
static_assert(offsetof(FRandomUnitVectorInConeDataflowNode, Vector) == 0x000118, "Member 'FRandomUnitVectorInConeDataflowNode::Vector' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.RadiansToDegreesDataflowNode
// 0x0008 (0x00F8 - 0x00F0)
struct FRadiansToDegreesDataflowNode final : public FDataflowNode
{
public:
	float                                         Radians;                                           // 0x00F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Degrees;                                           // 0x00F4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRadiansToDegreesDataflowNode) == 0x000008, "Wrong alignment on FRadiansToDegreesDataflowNode");
static_assert(sizeof(FRadiansToDegreesDataflowNode) == 0x0000F8, "Wrong size on FRadiansToDegreesDataflowNode");
static_assert(offsetof(FRadiansToDegreesDataflowNode, Radians) == 0x0000F0, "Member 'FRadiansToDegreesDataflowNode::Radians' has a wrong offset!");
static_assert(offsetof(FRadiansToDegreesDataflowNode, Degrees) == 0x0000F4, "Member 'FRadiansToDegreesDataflowNode::Degrees' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.DegreesToRadiansDataflowNode
// 0x0008 (0x00F8 - 0x00F0)
struct FDegreesToRadiansDataflowNode final : public FDataflowNode
{
public:
	float                                         Degrees;                                           // 0x00F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radians;                                           // 0x00F4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDegreesToRadiansDataflowNode) == 0x000008, "Wrong alignment on FDegreesToRadiansDataflowNode");
static_assert(sizeof(FDegreesToRadiansDataflowNode) == 0x0000F8, "Wrong size on FDegreesToRadiansDataflowNode");
static_assert(offsetof(FDegreesToRadiansDataflowNode, Degrees) == 0x0000F0, "Member 'FDegreesToRadiansDataflowNode::Degrees' has a wrong offset!");
static_assert(offsetof(FDegreesToRadiansDataflowNode, Radians) == 0x0000F4, "Member 'FDegreesToRadiansDataflowNode::Radians' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.HashStringDataflowNode
// 0x0018 (0x0108 - 0x00F0)
struct FHashStringDataflowNode final : public FDataflowNode
{
public:
	class FString                                 String;                                            // 0x00F0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Hash;                                              // 0x0100(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_104[0x4];                                      // 0x0104(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHashStringDataflowNode) == 0x000008, "Wrong alignment on FHashStringDataflowNode");
static_assert(sizeof(FHashStringDataflowNode) == 0x000108, "Wrong size on FHashStringDataflowNode");
static_assert(offsetof(FHashStringDataflowNode, String) == 0x0000F0, "Member 'FHashStringDataflowNode::String' has a wrong offset!");
static_assert(offsetof(FHashStringDataflowNode, Hash) == 0x000100, "Member 'FHashStringDataflowNode::Hash' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.HashVectorDataflowNode
// 0x0020 (0x0110 - 0x00F0)
struct FHashVectorDataflowNode final : public FDataflowNode
{
public:
	struct FVector                                Vector;                                            // 0x00F0(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Hash;                                              // 0x0108(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10C[0x4];                                      // 0x010C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHashVectorDataflowNode) == 0x000008, "Wrong alignment on FHashVectorDataflowNode");
static_assert(sizeof(FHashVectorDataflowNode) == 0x000110, "Wrong size on FHashVectorDataflowNode");
static_assert(offsetof(FHashVectorDataflowNode, Vector) == 0x0000F0, "Member 'FHashVectorDataflowNode::Vector' has a wrong offset!");
static_assert(offsetof(FHashVectorDataflowNode, Hash) == 0x000108, "Member 'FHashVectorDataflowNode::Hash' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.FloatToIntDataflowNode
// 0x0010 (0x0100 - 0x00F0)
struct FFloatToIntDataflowNode final : public FDataflowNode
{
public:
	EFloatToIntFunctionEnum                       Function;                                          // 0x00F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F1[0x3];                                       // 0x00F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Float;                                             // 0x00F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Int;                                               // 0x00F8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FC[0x4];                                       // 0x00FC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFloatToIntDataflowNode) == 0x000008, "Wrong alignment on FFloatToIntDataflowNode");
static_assert(sizeof(FFloatToIntDataflowNode) == 0x000100, "Wrong size on FFloatToIntDataflowNode");
static_assert(offsetof(FFloatToIntDataflowNode, Function) == 0x0000F0, "Member 'FFloatToIntDataflowNode::Function' has a wrong offset!");
static_assert(offsetof(FFloatToIntDataflowNode, Float) == 0x0000F4, "Member 'FFloatToIntDataflowNode::Float' has a wrong offset!");
static_assert(offsetof(FFloatToIntDataflowNode, Int) == 0x0000F8, "Member 'FFloatToIntDataflowNode::Int' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.FloatArrayToIntArrayDataflowNode
// 0x0028 (0x0118 - 0x00F0)
struct FFloatArrayToIntArrayDataflowNode final : public FDataflowNode
{
public:
	EFloatArrayToIntArrayFunctionEnum             Function;                                          // 0x00F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F1[0x7];                                       // 0x00F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 FloatArray;                                        // 0x00F8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 IntArray;                                          // 0x0108(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFloatArrayToIntArrayDataflowNode) == 0x000008, "Wrong alignment on FFloatArrayToIntArrayDataflowNode");
static_assert(sizeof(FFloatArrayToIntArrayDataflowNode) == 0x000118, "Wrong size on FFloatArrayToIntArrayDataflowNode");
static_assert(offsetof(FFloatArrayToIntArrayDataflowNode, Function) == 0x0000F0, "Member 'FFloatArrayToIntArrayDataflowNode::Function' has a wrong offset!");
static_assert(offsetof(FFloatArrayToIntArrayDataflowNode, FloatArray) == 0x0000F8, "Member 'FFloatArrayToIntArrayDataflowNode::FloatArray' has a wrong offset!");
static_assert(offsetof(FFloatArrayToIntArrayDataflowNode, IntArray) == 0x000108, "Member 'FFloatArrayToIntArrayDataflowNode::IntArray' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.MathConstantsDataflowNode
// 0x0008 (0x00F8 - 0x00F0)
struct FMathConstantsDataflowNode final : public FDataflowNode
{
public:
	EMathConstantsEnum                            Constant;                                          // 0x00F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F1[0x3];                                       // 0x00F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Float;                                             // 0x00F4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMathConstantsDataflowNode) == 0x000008, "Wrong alignment on FMathConstantsDataflowNode");
static_assert(sizeof(FMathConstantsDataflowNode) == 0x0000F8, "Wrong size on FMathConstantsDataflowNode");
static_assert(offsetof(FMathConstantsDataflowNode, Constant) == 0x0000F0, "Member 'FMathConstantsDataflowNode::Constant' has a wrong offset!");
static_assert(offsetof(FMathConstantsDataflowNode, Float) == 0x0000F4, "Member 'FMathConstantsDataflowNode::Float' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.GetArrayElementDataflowNode
// 0x0030 (0x0120 - 0x00F0)
struct FGetArrayElementDataflowNode final : public FDataflowNode
{
public:
	int32                                         Index;                                             // 0x00F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F4[0x4];                                       // 0x00F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        Points;                                            // 0x00F8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FVector                                Point;                                             // 0x0108(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGetArrayElementDataflowNode) == 0x000008, "Wrong alignment on FGetArrayElementDataflowNode");
static_assert(sizeof(FGetArrayElementDataflowNode) == 0x000120, "Wrong size on FGetArrayElementDataflowNode");
static_assert(offsetof(FGetArrayElementDataflowNode, Index) == 0x0000F0, "Member 'FGetArrayElementDataflowNode::Index' has a wrong offset!");
static_assert(offsetof(FGetArrayElementDataflowNode, Points) == 0x0000F8, "Member 'FGetArrayElementDataflowNode::Points' has a wrong offset!");
static_assert(offsetof(FGetArrayElementDataflowNode, Point) == 0x000108, "Member 'FGetArrayElementDataflowNode::Point' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.GetNumArrayElementsDataflowNode
// 0x0028 (0x0118 - 0x00F0)
struct FGetNumArrayElementsDataflowNode final : public FDataflowNode
{
public:
	TArray<struct FVector>                        Points;                                            // 0x00F0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector3f>                      Vector3fArray;                                     // 0x0100(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         NumElements;                                       // 0x0110(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_114[0x4];                                      // 0x0114(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGetNumArrayElementsDataflowNode) == 0x000008, "Wrong alignment on FGetNumArrayElementsDataflowNode");
static_assert(sizeof(FGetNumArrayElementsDataflowNode) == 0x000118, "Wrong size on FGetNumArrayElementsDataflowNode");
static_assert(offsetof(FGetNumArrayElementsDataflowNode, Points) == 0x0000F0, "Member 'FGetNumArrayElementsDataflowNode::Points' has a wrong offset!");
static_assert(offsetof(FGetNumArrayElementsDataflowNode, Vector3fArray) == 0x000100, "Member 'FGetNumArrayElementsDataflowNode::Vector3fArray' has a wrong offset!");
static_assert(offsetof(FGetNumArrayElementsDataflowNode, NumElements) == 0x000110, "Member 'FGetNumArrayElementsDataflowNode::NumElements' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.GetBoundingBoxesFromCollectionDataflowNode
// 0x00E0 (0x01D0 - 0x00F0)
struct FGetBoundingBoxesFromCollectionDataflowNode final : public FDataflowNode
{
public:
	struct FManagedArrayCollection                Collection;                                        // 0x00F0(0x00B0)(NativeAccessSpecifierPublic)
	struct FDataflowTransformSelection            TransformSelection;                                // 0x01A0(0x0020)(NativeAccessSpecifierPublic)
	TArray<struct FBox>                           BoundingBoxes;                                     // 0x01C0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGetBoundingBoxesFromCollectionDataflowNode) == 0x000008, "Wrong alignment on FGetBoundingBoxesFromCollectionDataflowNode");
static_assert(sizeof(FGetBoundingBoxesFromCollectionDataflowNode) == 0x0001D0, "Wrong size on FGetBoundingBoxesFromCollectionDataflowNode");
static_assert(offsetof(FGetBoundingBoxesFromCollectionDataflowNode, Collection) == 0x0000F0, "Member 'FGetBoundingBoxesFromCollectionDataflowNode::Collection' has a wrong offset!");
static_assert(offsetof(FGetBoundingBoxesFromCollectionDataflowNode, TransformSelection) == 0x0001A0, "Member 'FGetBoundingBoxesFromCollectionDataflowNode::TransformSelection' has a wrong offset!");
static_assert(offsetof(FGetBoundingBoxesFromCollectionDataflowNode, BoundingBoxes) == 0x0001C0, "Member 'FGetBoundingBoxesFromCollectionDataflowNode::BoundingBoxes' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.GetCentroidsFromCollectionDataflowNode
// 0x00E0 (0x01D0 - 0x00F0)
struct FGetCentroidsFromCollectionDataflowNode final : public FDataflowNode
{
public:
	struct FManagedArrayCollection                Collection;                                        // 0x00F0(0x00B0)(NativeAccessSpecifierPublic)
	struct FDataflowTransformSelection            TransformSelection;                                // 0x01A0(0x0020)(NativeAccessSpecifierPublic)
	TArray<struct FVector>                        Centroids;                                         // 0x01C0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGetCentroidsFromCollectionDataflowNode) == 0x000008, "Wrong alignment on FGetCentroidsFromCollectionDataflowNode");
static_assert(sizeof(FGetCentroidsFromCollectionDataflowNode) == 0x0001D0, "Wrong size on FGetCentroidsFromCollectionDataflowNode");
static_assert(offsetof(FGetCentroidsFromCollectionDataflowNode, Collection) == 0x0000F0, "Member 'FGetCentroidsFromCollectionDataflowNode::Collection' has a wrong offset!");
static_assert(offsetof(FGetCentroidsFromCollectionDataflowNode, TransformSelection) == 0x0001A0, "Member 'FGetCentroidsFromCollectionDataflowNode::TransformSelection' has a wrong offset!");
static_assert(offsetof(FGetCentroidsFromCollectionDataflowNode, Centroids) == 0x0001C0, "Member 'FGetCentroidsFromCollectionDataflowNode::Centroids' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.TransformCollectionDataflowNode
// 0x0140 (0x0230 - 0x00F0)
struct FTransformCollectionDataflowNode final : public FDataflowNode
{
public:
	struct FManagedArrayCollection                Collection;                                        // 0x00F0(0x00B0)(NativeAccessSpecifierPublic)
	struct FVector                                Translate;                                         // 0x01A0(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERotationOrderEnum                            RotationOrder;                                     // 0x01B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B9[0x7];                                      // 0x01B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Rotate;                                            // 0x01C0(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Scale;                                             // 0x01D8(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UniformScale;                                      // 0x01F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F4[0x4];                                      // 0x01F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                RotatePivot;                                       // 0x01F8(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ScalePivot;                                        // 0x0210(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInvertTransformation;                             // 0x0228(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_229[0x7];                                      // 0x0229(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTransformCollectionDataflowNode) == 0x000008, "Wrong alignment on FTransformCollectionDataflowNode");
static_assert(sizeof(FTransformCollectionDataflowNode) == 0x000230, "Wrong size on FTransformCollectionDataflowNode");
static_assert(offsetof(FTransformCollectionDataflowNode, Collection) == 0x0000F0, "Member 'FTransformCollectionDataflowNode::Collection' has a wrong offset!");
static_assert(offsetof(FTransformCollectionDataflowNode, Translate) == 0x0001A0, "Member 'FTransformCollectionDataflowNode::Translate' has a wrong offset!");
static_assert(offsetof(FTransformCollectionDataflowNode, RotationOrder) == 0x0001B8, "Member 'FTransformCollectionDataflowNode::RotationOrder' has a wrong offset!");
static_assert(offsetof(FTransformCollectionDataflowNode, Rotate) == 0x0001C0, "Member 'FTransformCollectionDataflowNode::Rotate' has a wrong offset!");
static_assert(offsetof(FTransformCollectionDataflowNode, Scale) == 0x0001D8, "Member 'FTransformCollectionDataflowNode::Scale' has a wrong offset!");
static_assert(offsetof(FTransformCollectionDataflowNode, UniformScale) == 0x0001F0, "Member 'FTransformCollectionDataflowNode::UniformScale' has a wrong offset!");
static_assert(offsetof(FTransformCollectionDataflowNode, RotatePivot) == 0x0001F8, "Member 'FTransformCollectionDataflowNode::RotatePivot' has a wrong offset!");
static_assert(offsetof(FTransformCollectionDataflowNode, ScalePivot) == 0x000210, "Member 'FTransformCollectionDataflowNode::ScalePivot' has a wrong offset!");
static_assert(offsetof(FTransformCollectionDataflowNode, bInvertTransformation) == 0x000228, "Member 'FTransformCollectionDataflowNode::bInvertTransformation' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.BakeTransformsInCollectionDataflowNode
// 0x00B0 (0x01A0 - 0x00F0)
struct FBakeTransformsInCollectionDataflowNode final : public FDataflowNode
{
public:
	struct FManagedArrayCollection                Collection;                                        // 0x00F0(0x00B0)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FBakeTransformsInCollectionDataflowNode) == 0x000008, "Wrong alignment on FBakeTransformsInCollectionDataflowNode");
static_assert(sizeof(FBakeTransformsInCollectionDataflowNode) == 0x0001A0, "Wrong size on FBakeTransformsInCollectionDataflowNode");
static_assert(offsetof(FBakeTransformsInCollectionDataflowNode, Collection) == 0x0000F0, "Member 'FBakeTransformsInCollectionDataflowNode::Collection' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.TransformMeshDataflowNode
// 0x0098 (0x0188 - 0x00F0)
struct FTransformMeshDataflowNode final : public FDataflowNode
{
public:
	class UDynamicMesh*                           Mesh;                                              // 0x00F0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Translate;                                         // 0x00F8(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERotationOrderEnum                            RotationOrder;                                     // 0x0110(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_111[0x7];                                      // 0x0111(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Rotate;                                            // 0x0118(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Scale;                                             // 0x0130(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UniformScale;                                      // 0x0148(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14C[0x4];                                      // 0x014C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                RotatePivot;                                       // 0x0150(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ScalePivot;                                        // 0x0168(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInvertTransformation;                             // 0x0180(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_181[0x7];                                      // 0x0181(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTransformMeshDataflowNode) == 0x000008, "Wrong alignment on FTransformMeshDataflowNode");
static_assert(sizeof(FTransformMeshDataflowNode) == 0x000188, "Wrong size on FTransformMeshDataflowNode");
static_assert(offsetof(FTransformMeshDataflowNode, Mesh) == 0x0000F0, "Member 'FTransformMeshDataflowNode::Mesh' has a wrong offset!");
static_assert(offsetof(FTransformMeshDataflowNode, Translate) == 0x0000F8, "Member 'FTransformMeshDataflowNode::Translate' has a wrong offset!");
static_assert(offsetof(FTransformMeshDataflowNode, RotationOrder) == 0x000110, "Member 'FTransformMeshDataflowNode::RotationOrder' has a wrong offset!");
static_assert(offsetof(FTransformMeshDataflowNode, Rotate) == 0x000118, "Member 'FTransformMeshDataflowNode::Rotate' has a wrong offset!");
static_assert(offsetof(FTransformMeshDataflowNode, Scale) == 0x000130, "Member 'FTransformMeshDataflowNode::Scale' has a wrong offset!");
static_assert(offsetof(FTransformMeshDataflowNode, UniformScale) == 0x000148, "Member 'FTransformMeshDataflowNode::UniformScale' has a wrong offset!");
static_assert(offsetof(FTransformMeshDataflowNode, RotatePivot) == 0x000150, "Member 'FTransformMeshDataflowNode::RotatePivot' has a wrong offset!");
static_assert(offsetof(FTransformMeshDataflowNode, ScalePivot) == 0x000168, "Member 'FTransformMeshDataflowNode::ScalePivot' has a wrong offset!");
static_assert(offsetof(FTransformMeshDataflowNode, bInvertTransformation) == 0x000180, "Member 'FTransformMeshDataflowNode::bInvertTransformation' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.CompareIntDataflowNode
// 0x0010 (0x0100 - 0x00F0)
struct FCompareIntDataflowNode final : public FDataflowNode
{
public:
	ECompareOperationEnum                         Operation;                                         // 0x00F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F1[0x3];                                       // 0x00F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         IntA;                                              // 0x00F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IntB;                                              // 0x00F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Result;                                            // 0x00FC(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FD[0x3];                                       // 0x00FD(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCompareIntDataflowNode) == 0x000008, "Wrong alignment on FCompareIntDataflowNode");
static_assert(sizeof(FCompareIntDataflowNode) == 0x000100, "Wrong size on FCompareIntDataflowNode");
static_assert(offsetof(FCompareIntDataflowNode, Operation) == 0x0000F0, "Member 'FCompareIntDataflowNode::Operation' has a wrong offset!");
static_assert(offsetof(FCompareIntDataflowNode, IntA) == 0x0000F4, "Member 'FCompareIntDataflowNode::IntA' has a wrong offset!");
static_assert(offsetof(FCompareIntDataflowNode, IntB) == 0x0000F8, "Member 'FCompareIntDataflowNode::IntB' has a wrong offset!");
static_assert(offsetof(FCompareIntDataflowNode, Result) == 0x0000FC, "Member 'FCompareIntDataflowNode::Result' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.BranchDataflowNode
// 0x0020 (0x0110 - 0x00F0)
struct FBranchDataflowNode final : public FDataflowNode
{
public:
	class UDynamicMesh*                           MeshA;                                             // 0x00F0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDynamicMesh*                           MeshB;                                             // 0x00F8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCondition;                                        // 0x0100(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_101[0x7];                                      // 0x0101(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UDynamicMesh*                           Mesh;                                              // 0x0108(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBranchDataflowNode) == 0x000008, "Wrong alignment on FBranchDataflowNode");
static_assert(sizeof(FBranchDataflowNode) == 0x000110, "Wrong size on FBranchDataflowNode");
static_assert(offsetof(FBranchDataflowNode, MeshA) == 0x0000F0, "Member 'FBranchDataflowNode::MeshA' has a wrong offset!");
static_assert(offsetof(FBranchDataflowNode, MeshB) == 0x0000F8, "Member 'FBranchDataflowNode::MeshB' has a wrong offset!");
static_assert(offsetof(FBranchDataflowNode, bCondition) == 0x000100, "Member 'FBranchDataflowNode::bCondition' has a wrong offset!");
static_assert(offsetof(FBranchDataflowNode, Mesh) == 0x000108, "Member 'FBranchDataflowNode::Mesh' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.GetSchemaDataflowNode
// 0x00C0 (0x01B0 - 0x00F0)
struct FGetSchemaDataflowNode final : public FDataflowNode
{
public:
	struct FManagedArrayCollection                Collection;                                        // 0x00F0(0x00B0)(NativeAccessSpecifierPublic)
	class FString                                 String;                                            // 0x01A0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGetSchemaDataflowNode) == 0x000008, "Wrong alignment on FGetSchemaDataflowNode");
static_assert(sizeof(FGetSchemaDataflowNode) == 0x0001B0, "Wrong size on FGetSchemaDataflowNode");
static_assert(offsetof(FGetSchemaDataflowNode, Collection) == 0x0000F0, "Member 'FGetSchemaDataflowNode::Collection' has a wrong offset!");
static_assert(offsetof(FGetSchemaDataflowNode, String) == 0x0001A0, "Member 'FGetSchemaDataflowNode::String' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.RemoveOnBreakDataflowNode
// 0x00E8 (0x01D8 - 0x00F0)
struct FRemoveOnBreakDataflowNode final : public FDataflowNode
{
public:
	struct FManagedArrayCollection                Collection;                                        // 0x00F0(0x00B0)(NativeAccessSpecifierPublic)
	struct FDataflowTransformSelection            TransformSelection;                                // 0x01A0(0x0020)(NativeAccessSpecifierPublic)
	bool                                          bEnabledRemoval;                                   // 0x01C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C1[0x3];                                      // 0x01C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2f                              PostBreakTimer;                                    // 0x01C4(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2f                              RemovalTimer;                                      // 0x01CC(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClusterCrumbling;                                 // 0x01D4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D5[0x3];                                      // 0x01D5(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRemoveOnBreakDataflowNode) == 0x000008, "Wrong alignment on FRemoveOnBreakDataflowNode");
static_assert(sizeof(FRemoveOnBreakDataflowNode) == 0x0001D8, "Wrong size on FRemoveOnBreakDataflowNode");
static_assert(offsetof(FRemoveOnBreakDataflowNode, Collection) == 0x0000F0, "Member 'FRemoveOnBreakDataflowNode::Collection' has a wrong offset!");
static_assert(offsetof(FRemoveOnBreakDataflowNode, TransformSelection) == 0x0001A0, "Member 'FRemoveOnBreakDataflowNode::TransformSelection' has a wrong offset!");
static_assert(offsetof(FRemoveOnBreakDataflowNode, bEnabledRemoval) == 0x0001C0, "Member 'FRemoveOnBreakDataflowNode::bEnabledRemoval' has a wrong offset!");
static_assert(offsetof(FRemoveOnBreakDataflowNode, PostBreakTimer) == 0x0001C4, "Member 'FRemoveOnBreakDataflowNode::PostBreakTimer' has a wrong offset!");
static_assert(offsetof(FRemoveOnBreakDataflowNode, RemovalTimer) == 0x0001CC, "Member 'FRemoveOnBreakDataflowNode::RemovalTimer' has a wrong offset!");
static_assert(offsetof(FRemoveOnBreakDataflowNode, bClusterCrumbling) == 0x0001D4, "Member 'FRemoveOnBreakDataflowNode::bClusterCrumbling' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.SetAnchorStateDataflowNode
// 0x00D8 (0x01C8 - 0x00F0)
struct FSetAnchorStateDataflowNode final : public FDataflowNode
{
public:
	EAnchorStateEnum                              AnchorState;                                       // 0x00F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSetNotSelectedBonesToOppositeState;               // 0x00F1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F2[0x6];                                       // 0x00F2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FManagedArrayCollection                Collection;                                        // 0x00F8(0x00B0)(NativeAccessSpecifierPublic)
	struct FDataflowTransformSelection            TransformSelection;                                // 0x01A8(0x0020)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FSetAnchorStateDataflowNode) == 0x000008, "Wrong alignment on FSetAnchorStateDataflowNode");
static_assert(sizeof(FSetAnchorStateDataflowNode) == 0x0001C8, "Wrong size on FSetAnchorStateDataflowNode");
static_assert(offsetof(FSetAnchorStateDataflowNode, AnchorState) == 0x0000F0, "Member 'FSetAnchorStateDataflowNode::AnchorState' has a wrong offset!");
static_assert(offsetof(FSetAnchorStateDataflowNode, bSetNotSelectedBonesToOppositeState) == 0x0000F1, "Member 'FSetAnchorStateDataflowNode::bSetNotSelectedBonesToOppositeState' has a wrong offset!");
static_assert(offsetof(FSetAnchorStateDataflowNode, Collection) == 0x0000F8, "Member 'FSetAnchorStateDataflowNode::Collection' has a wrong offset!");
static_assert(offsetof(FSetAnchorStateDataflowNode, TransformSelection) == 0x0001A8, "Member 'FSetAnchorStateDataflowNode::TransformSelection' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.ProximityDataflowNode
// 0x00C0 (0x01B0 - 0x00F0)
struct FProximityDataflowNode final : public FDataflowNode
{
public:
	EProximityMethodEnum                          ProximityMethod;                                   // 0x00F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F1[0x3];                                       // 0x00F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DistanceThreshold;                                 // 0x00F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ContactThreshold;                                  // 0x00F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseAsConnectionGraph;                             // 0x00FC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FD[0x3];                                       // 0x00FD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FManagedArrayCollection                Collection;                                        // 0x0100(0x00B0)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FProximityDataflowNode) == 0x000008, "Wrong alignment on FProximityDataflowNode");
static_assert(sizeof(FProximityDataflowNode) == 0x0001B0, "Wrong size on FProximityDataflowNode");
static_assert(offsetof(FProximityDataflowNode, ProximityMethod) == 0x0000F0, "Member 'FProximityDataflowNode::ProximityMethod' has a wrong offset!");
static_assert(offsetof(FProximityDataflowNode, DistanceThreshold) == 0x0000F4, "Member 'FProximityDataflowNode::DistanceThreshold' has a wrong offset!");
static_assert(offsetof(FProximityDataflowNode, ContactThreshold) == 0x0000F8, "Member 'FProximityDataflowNode::ContactThreshold' has a wrong offset!");
static_assert(offsetof(FProximityDataflowNode, bUseAsConnectionGraph) == 0x0000FC, "Member 'FProximityDataflowNode::bUseAsConnectionGraph' has a wrong offset!");
static_assert(offsetof(FProximityDataflowNode, Collection) == 0x000100, "Member 'FProximityDataflowNode::Collection' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.CollectionSetPivotDataflowNode
// 0x0110 (0x0200 - 0x00F0)
struct FCollectionSetPivotDataflowNode final : public FDataflowNode
{
public:
	struct FManagedArrayCollection                Collection;                                        // 0x00F0(0x00B0)(NativeAccessSpecifierPublic)
	struct FTransform                             Transform;                                         // 0x01A0(0x0060)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCollectionSetPivotDataflowNode) == 0x000010, "Wrong alignment on FCollectionSetPivotDataflowNode");
static_assert(sizeof(FCollectionSetPivotDataflowNode) == 0x000200, "Wrong size on FCollectionSetPivotDataflowNode");
static_assert(offsetof(FCollectionSetPivotDataflowNode, Collection) == 0x0000F0, "Member 'FCollectionSetPivotDataflowNode::Collection' has a wrong offset!");
static_assert(offsetof(FCollectionSetPivotDataflowNode, Transform) == 0x0001A0, "Member 'FCollectionSetPivotDataflowNode::Transform' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.AddCustomCollectionAttributeDataflowNode
// 0x00E0 (0x01D0 - 0x00F0)
struct FAddCustomCollectionAttributeDataflowNode final : public FDataflowNode
{
public:
	struct FManagedArrayCollection                Collection;                                        // 0x00F0(0x00B0)(NativeAccessSpecifierPublic)
	EStandardGroupNameEnum                        GroupName;                                         // 0x01A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A1[0x7];                                      // 0x01A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CustomGroupName;                                   // 0x01A8(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AttrName;                                          // 0x01B8(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECustomAttributeTypeEnum                      CustomAttributeType;                               // 0x01C8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C9[0x3];                                      // 0x01C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NumElements;                                       // 0x01CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAddCustomCollectionAttributeDataflowNode) == 0x000008, "Wrong alignment on FAddCustomCollectionAttributeDataflowNode");
static_assert(sizeof(FAddCustomCollectionAttributeDataflowNode) == 0x0001D0, "Wrong size on FAddCustomCollectionAttributeDataflowNode");
static_assert(offsetof(FAddCustomCollectionAttributeDataflowNode, Collection) == 0x0000F0, "Member 'FAddCustomCollectionAttributeDataflowNode::Collection' has a wrong offset!");
static_assert(offsetof(FAddCustomCollectionAttributeDataflowNode, GroupName) == 0x0001A0, "Member 'FAddCustomCollectionAttributeDataflowNode::GroupName' has a wrong offset!");
static_assert(offsetof(FAddCustomCollectionAttributeDataflowNode, CustomGroupName) == 0x0001A8, "Member 'FAddCustomCollectionAttributeDataflowNode::CustomGroupName' has a wrong offset!");
static_assert(offsetof(FAddCustomCollectionAttributeDataflowNode, AttrName) == 0x0001B8, "Member 'FAddCustomCollectionAttributeDataflowNode::AttrName' has a wrong offset!");
static_assert(offsetof(FAddCustomCollectionAttributeDataflowNode, CustomAttributeType) == 0x0001C8, "Member 'FAddCustomCollectionAttributeDataflowNode::CustomAttributeType' has a wrong offset!");
static_assert(offsetof(FAddCustomCollectionAttributeDataflowNode, NumElements) == 0x0001CC, "Member 'FAddCustomCollectionAttributeDataflowNode::NumElements' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.GetNumElementsInCollectionGroupDataflowNode
// 0x00D0 (0x01C0 - 0x00F0)
struct FGetNumElementsInCollectionGroupDataflowNode final : public FDataflowNode
{
public:
	struct FManagedArrayCollection                Collection;                                        // 0x00F0(0x00B0)(NativeAccessSpecifierPublic)
	EStandardGroupNameEnum                        GroupName;                                         // 0x01A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A1[0x7];                                      // 0x01A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CustomGroupName;                                   // 0x01A8(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumElements;                                       // 0x01B8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1BC[0x4];                                      // 0x01BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGetNumElementsInCollectionGroupDataflowNode) == 0x000008, "Wrong alignment on FGetNumElementsInCollectionGroupDataflowNode");
static_assert(sizeof(FGetNumElementsInCollectionGroupDataflowNode) == 0x0001C0, "Wrong size on FGetNumElementsInCollectionGroupDataflowNode");
static_assert(offsetof(FGetNumElementsInCollectionGroupDataflowNode, Collection) == 0x0000F0, "Member 'FGetNumElementsInCollectionGroupDataflowNode::Collection' has a wrong offset!");
static_assert(offsetof(FGetNumElementsInCollectionGroupDataflowNode, GroupName) == 0x0001A0, "Member 'FGetNumElementsInCollectionGroupDataflowNode::GroupName' has a wrong offset!");
static_assert(offsetof(FGetNumElementsInCollectionGroupDataflowNode, CustomGroupName) == 0x0001A8, "Member 'FGetNumElementsInCollectionGroupDataflowNode::CustomGroupName' has a wrong offset!");
static_assert(offsetof(FGetNumElementsInCollectionGroupDataflowNode, NumElements) == 0x0001B8, "Member 'FGetNumElementsInCollectionGroupDataflowNode::NumElements' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.GetCollectionAttributeDataTypedDataflowNode
// 0x0148 (0x0238 - 0x00F0)
struct FGetCollectionAttributeDataTypedDataflowNode final : public FDataflowNode
{
public:
	struct FManagedArrayCollection                Collection;                                        // 0x00F0(0x00B0)(NativeAccessSpecifierPublic)
	EStandardGroupNameEnum                        GroupName;                                         // 0x01A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A1[0x7];                                      // 0x01A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CustomGroupName;                                   // 0x01A8(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AttrName;                                          // 0x01B8(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<bool>                                  BoolAttributeData;                                 // 0x01C8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 FloatAttributeData;                                // 0x01D8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<double>                                DoubleAttributeData;                               // 0x01E8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 Int32AttributeData;                                // 0x01F8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         StringAttributeData;                               // 0x0208(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector3f>                      Vector3fAttributeData;                             // 0x0218(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector3d>                      Vector3dAttributeData;                             // 0x0228(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGetCollectionAttributeDataTypedDataflowNode) == 0x000008, "Wrong alignment on FGetCollectionAttributeDataTypedDataflowNode");
static_assert(sizeof(FGetCollectionAttributeDataTypedDataflowNode) == 0x000238, "Wrong size on FGetCollectionAttributeDataTypedDataflowNode");
static_assert(offsetof(FGetCollectionAttributeDataTypedDataflowNode, Collection) == 0x0000F0, "Member 'FGetCollectionAttributeDataTypedDataflowNode::Collection' has a wrong offset!");
static_assert(offsetof(FGetCollectionAttributeDataTypedDataflowNode, GroupName) == 0x0001A0, "Member 'FGetCollectionAttributeDataTypedDataflowNode::GroupName' has a wrong offset!");
static_assert(offsetof(FGetCollectionAttributeDataTypedDataflowNode, CustomGroupName) == 0x0001A8, "Member 'FGetCollectionAttributeDataTypedDataflowNode::CustomGroupName' has a wrong offset!");
static_assert(offsetof(FGetCollectionAttributeDataTypedDataflowNode, AttrName) == 0x0001B8, "Member 'FGetCollectionAttributeDataTypedDataflowNode::AttrName' has a wrong offset!");
static_assert(offsetof(FGetCollectionAttributeDataTypedDataflowNode, BoolAttributeData) == 0x0001C8, "Member 'FGetCollectionAttributeDataTypedDataflowNode::BoolAttributeData' has a wrong offset!");
static_assert(offsetof(FGetCollectionAttributeDataTypedDataflowNode, FloatAttributeData) == 0x0001D8, "Member 'FGetCollectionAttributeDataTypedDataflowNode::FloatAttributeData' has a wrong offset!");
static_assert(offsetof(FGetCollectionAttributeDataTypedDataflowNode, DoubleAttributeData) == 0x0001E8, "Member 'FGetCollectionAttributeDataTypedDataflowNode::DoubleAttributeData' has a wrong offset!");
static_assert(offsetof(FGetCollectionAttributeDataTypedDataflowNode, Int32AttributeData) == 0x0001F8, "Member 'FGetCollectionAttributeDataTypedDataflowNode::Int32AttributeData' has a wrong offset!");
static_assert(offsetof(FGetCollectionAttributeDataTypedDataflowNode, StringAttributeData) == 0x000208, "Member 'FGetCollectionAttributeDataTypedDataflowNode::StringAttributeData' has a wrong offset!");
static_assert(offsetof(FGetCollectionAttributeDataTypedDataflowNode, Vector3fAttributeData) == 0x000218, "Member 'FGetCollectionAttributeDataTypedDataflowNode::Vector3fAttributeData' has a wrong offset!");
static_assert(offsetof(FGetCollectionAttributeDataTypedDataflowNode, Vector3dAttributeData) == 0x000228, "Member 'FGetCollectionAttributeDataTypedDataflowNode::Vector3dAttributeData' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.SetCollectionAttributeDataTypedDataflowNode
// 0x0148 (0x0238 - 0x00F0)
struct FSetCollectionAttributeDataTypedDataflowNode final : public FDataflowNode
{
public:
	struct FManagedArrayCollection                Collection;                                        // 0x00F0(0x00B0)(NativeAccessSpecifierPublic)
	EStandardGroupNameEnum                        GroupName;                                         // 0x01A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A1[0x7];                                      // 0x01A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CustomGroupName;                                   // 0x01A8(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AttrName;                                          // 0x01B8(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<bool>                                  BoolAttributeData;                                 // 0x01C8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 FloatAttributeData;                                // 0x01D8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<double>                                DoubleAttributeData;                               // 0x01E8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 Int32AttributeData;                                // 0x01F8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         StringAttributeData;                               // 0x0208(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector3f>                      Vector3fAttributeData;                             // 0x0218(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector3d>                      Vector3dAttributeData;                             // 0x0228(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSetCollectionAttributeDataTypedDataflowNode) == 0x000008, "Wrong alignment on FSetCollectionAttributeDataTypedDataflowNode");
static_assert(sizeof(FSetCollectionAttributeDataTypedDataflowNode) == 0x000238, "Wrong size on FSetCollectionAttributeDataTypedDataflowNode");
static_assert(offsetof(FSetCollectionAttributeDataTypedDataflowNode, Collection) == 0x0000F0, "Member 'FSetCollectionAttributeDataTypedDataflowNode::Collection' has a wrong offset!");
static_assert(offsetof(FSetCollectionAttributeDataTypedDataflowNode, GroupName) == 0x0001A0, "Member 'FSetCollectionAttributeDataTypedDataflowNode::GroupName' has a wrong offset!");
static_assert(offsetof(FSetCollectionAttributeDataTypedDataflowNode, CustomGroupName) == 0x0001A8, "Member 'FSetCollectionAttributeDataTypedDataflowNode::CustomGroupName' has a wrong offset!");
static_assert(offsetof(FSetCollectionAttributeDataTypedDataflowNode, AttrName) == 0x0001B8, "Member 'FSetCollectionAttributeDataTypedDataflowNode::AttrName' has a wrong offset!");
static_assert(offsetof(FSetCollectionAttributeDataTypedDataflowNode, BoolAttributeData) == 0x0001C8, "Member 'FSetCollectionAttributeDataTypedDataflowNode::BoolAttributeData' has a wrong offset!");
static_assert(offsetof(FSetCollectionAttributeDataTypedDataflowNode, FloatAttributeData) == 0x0001D8, "Member 'FSetCollectionAttributeDataTypedDataflowNode::FloatAttributeData' has a wrong offset!");
static_assert(offsetof(FSetCollectionAttributeDataTypedDataflowNode, DoubleAttributeData) == 0x0001E8, "Member 'FSetCollectionAttributeDataTypedDataflowNode::DoubleAttributeData' has a wrong offset!");
static_assert(offsetof(FSetCollectionAttributeDataTypedDataflowNode, Int32AttributeData) == 0x0001F8, "Member 'FSetCollectionAttributeDataTypedDataflowNode::Int32AttributeData' has a wrong offset!");
static_assert(offsetof(FSetCollectionAttributeDataTypedDataflowNode, StringAttributeData) == 0x000208, "Member 'FSetCollectionAttributeDataTypedDataflowNode::StringAttributeData' has a wrong offset!");
static_assert(offsetof(FSetCollectionAttributeDataTypedDataflowNode, Vector3fAttributeData) == 0x000218, "Member 'FSetCollectionAttributeDataTypedDataflowNode::Vector3fAttributeData' has a wrong offset!");
static_assert(offsetof(FSetCollectionAttributeDataTypedDataflowNode, Vector3dAttributeData) == 0x000228, "Member 'FSetCollectionAttributeDataTypedDataflowNode::Vector3dAttributeData' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.BoolArrayToFaceSelectionDataflowNode
// 0x0030 (0x0120 - 0x00F0)
struct FBoolArrayToFaceSelectionDataflowNode final : public FDataflowNode
{
public:
	TArray<bool>                                  BoolAttributeData;                                 // 0x00F0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FDataflowFaceSelection                 FaceSelection;                                     // 0x0100(0x0020)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FBoolArrayToFaceSelectionDataflowNode) == 0x000008, "Wrong alignment on FBoolArrayToFaceSelectionDataflowNode");
static_assert(sizeof(FBoolArrayToFaceSelectionDataflowNode) == 0x000120, "Wrong size on FBoolArrayToFaceSelectionDataflowNode");
static_assert(offsetof(FBoolArrayToFaceSelectionDataflowNode, BoolAttributeData) == 0x0000F0, "Member 'FBoolArrayToFaceSelectionDataflowNode::BoolAttributeData' has a wrong offset!");
static_assert(offsetof(FBoolArrayToFaceSelectionDataflowNode, FaceSelection) == 0x000100, "Member 'FBoolArrayToFaceSelectionDataflowNode::FaceSelection' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.FloatArrayToVertexSelectionDataflowNode
// 0x0038 (0x0128 - 0x00F0)
struct FFloatArrayToVertexSelectionDataflowNode final : public FDataflowNode
{
public:
	TArray<float>                                 FloatArray;                                        // 0x00F0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	ECompareOperationEnum                         Operation;                                         // 0x0100(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_101[0x3];                                      // 0x0101(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Threshold;                                         // 0x0104(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDataflowVertexSelection               VertexSelection;                                   // 0x0108(0x0020)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FFloatArrayToVertexSelectionDataflowNode) == 0x000008, "Wrong alignment on FFloatArrayToVertexSelectionDataflowNode");
static_assert(sizeof(FFloatArrayToVertexSelectionDataflowNode) == 0x000128, "Wrong size on FFloatArrayToVertexSelectionDataflowNode");
static_assert(offsetof(FFloatArrayToVertexSelectionDataflowNode, FloatArray) == 0x0000F0, "Member 'FFloatArrayToVertexSelectionDataflowNode::FloatArray' has a wrong offset!");
static_assert(offsetof(FFloatArrayToVertexSelectionDataflowNode, Operation) == 0x000100, "Member 'FFloatArrayToVertexSelectionDataflowNode::Operation' has a wrong offset!");
static_assert(offsetof(FFloatArrayToVertexSelectionDataflowNode, Threshold) == 0x000104, "Member 'FFloatArrayToVertexSelectionDataflowNode::Threshold' has a wrong offset!");
static_assert(offsetof(FFloatArrayToVertexSelectionDataflowNode, VertexSelection) == 0x000108, "Member 'FFloatArrayToVertexSelectionDataflowNode::VertexSelection' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.SetVertexColorInCollectionFromVertexSelectionDataflowNode
// 0x00F0 (0x01E0 - 0x00F0)
struct FSetVertexColorInCollectionFromVertexSelectionDataflowNode final : public FDataflowNode
{
public:
	struct FManagedArrayCollection                Collection;                                        // 0x00F0(0x00B0)(NativeAccessSpecifierPublic)
	struct FDataflowVertexSelection               VertexSelection;                                   // 0x01A0(0x0020)(NativeAccessSpecifierPublic)
	struct FLinearColor                           SelectedColor;                                     // 0x01C0(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           NonSelectedColor;                                  // 0x01D0(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSetVertexColorInCollectionFromVertexSelectionDataflowNode) == 0x000008, "Wrong alignment on FSetVertexColorInCollectionFromVertexSelectionDataflowNode");
static_assert(sizeof(FSetVertexColorInCollectionFromVertexSelectionDataflowNode) == 0x0001E0, "Wrong size on FSetVertexColorInCollectionFromVertexSelectionDataflowNode");
static_assert(offsetof(FSetVertexColorInCollectionFromVertexSelectionDataflowNode, Collection) == 0x0000F0, "Member 'FSetVertexColorInCollectionFromVertexSelectionDataflowNode::Collection' has a wrong offset!");
static_assert(offsetof(FSetVertexColorInCollectionFromVertexSelectionDataflowNode, VertexSelection) == 0x0001A0, "Member 'FSetVertexColorInCollectionFromVertexSelectionDataflowNode::VertexSelection' has a wrong offset!");
static_assert(offsetof(FSetVertexColorInCollectionFromVertexSelectionDataflowNode, SelectedColor) == 0x0001C0, "Member 'FSetVertexColorInCollectionFromVertexSelectionDataflowNode::SelectedColor' has a wrong offset!");
static_assert(offsetof(FSetVertexColorInCollectionFromVertexSelectionDataflowNode, NonSelectedColor) == 0x0001D0, "Member 'FSetVertexColorInCollectionFromVertexSelectionDataflowNode::NonSelectedColor' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.SelectionToVertexListDataflowNode
// 0x0030 (0x0120 - 0x00F0)
struct FSelectionToVertexListDataflowNode final : public FDataflowNode
{
public:
	struct FDataflowVertexSelection               VertexSelection;                                   // 0x00F0(0x0020)(NativeAccessSpecifierPublic)
	TArray<int32>                                 VertexList;                                        // 0x0110(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSelectionToVertexListDataflowNode) == 0x000008, "Wrong alignment on FSelectionToVertexListDataflowNode");
static_assert(sizeof(FSelectionToVertexListDataflowNode) == 0x000120, "Wrong size on FSelectionToVertexListDataflowNode");
static_assert(offsetof(FSelectionToVertexListDataflowNode, VertexSelection) == 0x0000F0, "Member 'FSelectionToVertexListDataflowNode::VertexSelection' has a wrong offset!");
static_assert(offsetof(FSelectionToVertexListDataflowNode, VertexList) == 0x000110, "Member 'FSelectionToVertexListDataflowNode::VertexList' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.MakeTransformDataflowNode
// 0x00B0 (0x01A0 - 0x00F0)
struct FMakeTransformDataflowNode final : public FDataflowNode
{
public:
	struct FVector                                InTranslation;                                     // 0x00F0(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InRotation;                                        // 0x0108(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InScale;                                           // 0x0120(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_138[0x8];                                      // 0x0138(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             OutTransform;                                      // 0x0140(0x0060)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMakeTransformDataflowNode) == 0x000010, "Wrong alignment on FMakeTransformDataflowNode");
static_assert(sizeof(FMakeTransformDataflowNode) == 0x0001A0, "Wrong size on FMakeTransformDataflowNode");
static_assert(offsetof(FMakeTransformDataflowNode, InTranslation) == 0x0000F0, "Member 'FMakeTransformDataflowNode::InTranslation' has a wrong offset!");
static_assert(offsetof(FMakeTransformDataflowNode, InRotation) == 0x000108, "Member 'FMakeTransformDataflowNode::InRotation' has a wrong offset!");
static_assert(offsetof(FMakeTransformDataflowNode, InScale) == 0x000120, "Member 'FMakeTransformDataflowNode::InScale' has a wrong offset!");
static_assert(offsetof(FMakeTransformDataflowNode, OutTransform) == 0x000140, "Member 'FMakeTransformDataflowNode::OutTransform' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.SetVertexColorInCollectionFromFloatArrayDataflowNode
// 0x00C8 (0x01B8 - 0x00F0)
struct FSetVertexColorInCollectionFromFloatArrayDataflowNode final : public FDataflowNode
{
public:
	struct FManagedArrayCollection                Collection;                                        // 0x00F0(0x00B0)(NativeAccessSpecifierPublic)
	TArray<float>                                 FloatArray;                                        // 0x01A0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x01B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B4[0x4];                                      // 0x01B4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSetVertexColorInCollectionFromFloatArrayDataflowNode) == 0x000008, "Wrong alignment on FSetVertexColorInCollectionFromFloatArrayDataflowNode");
static_assert(sizeof(FSetVertexColorInCollectionFromFloatArrayDataflowNode) == 0x0001B8, "Wrong size on FSetVertexColorInCollectionFromFloatArrayDataflowNode");
static_assert(offsetof(FSetVertexColorInCollectionFromFloatArrayDataflowNode, Collection) == 0x0000F0, "Member 'FSetVertexColorInCollectionFromFloatArrayDataflowNode::Collection' has a wrong offset!");
static_assert(offsetof(FSetVertexColorInCollectionFromFloatArrayDataflowNode, FloatArray) == 0x0001A0, "Member 'FSetVertexColorInCollectionFromFloatArrayDataflowNode::FloatArray' has a wrong offset!");
static_assert(offsetof(FSetVertexColorInCollectionFromFloatArrayDataflowNode, Scale) == 0x0001B0, "Member 'FSetVertexColorInCollectionFromFloatArrayDataflowNode::Scale' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.FloatArrayNormalizeDataflowNode
// 0x0048 (0x0138 - 0x00F0)
struct FFloatArrayNormalizeDataflowNode final : public FDataflowNode
{
public:
	TArray<float>                                 InFloatArray;                                      // 0x00F0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FDataflowVertexSelection               Selection;                                         // 0x0100(0x0020)(NativeAccessSpecifierPublic)
	float                                         MinRange;                                          // 0x0120(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRange;                                          // 0x0124(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 OutFloatArray;                                     // 0x0128(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFloatArrayNormalizeDataflowNode) == 0x000008, "Wrong alignment on FFloatArrayNormalizeDataflowNode");
static_assert(sizeof(FFloatArrayNormalizeDataflowNode) == 0x000138, "Wrong size on FFloatArrayNormalizeDataflowNode");
static_assert(offsetof(FFloatArrayNormalizeDataflowNode, InFloatArray) == 0x0000F0, "Member 'FFloatArrayNormalizeDataflowNode::InFloatArray' has a wrong offset!");
static_assert(offsetof(FFloatArrayNormalizeDataflowNode, Selection) == 0x000100, "Member 'FFloatArrayNormalizeDataflowNode::Selection' has a wrong offset!");
static_assert(offsetof(FFloatArrayNormalizeDataflowNode, MinRange) == 0x000120, "Member 'FFloatArrayNormalizeDataflowNode::MinRange' has a wrong offset!");
static_assert(offsetof(FFloatArrayNormalizeDataflowNode, MaxRange) == 0x000124, "Member 'FFloatArrayNormalizeDataflowNode::MaxRange' has a wrong offset!");
static_assert(offsetof(FFloatArrayNormalizeDataflowNode, OutFloatArray) == 0x000128, "Member 'FFloatArrayNormalizeDataflowNode::OutFloatArray' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.VectorArrayNormalizeDataflowNode
// 0x0048 (0x0138 - 0x00F0)
struct FVectorArrayNormalizeDataflowNode final : public FDataflowNode
{
public:
	TArray<struct FVector>                        InVectorArray;                                     // 0x00F0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FDataflowVertexSelection               Selection;                                         // 0x0100(0x0020)(NativeAccessSpecifierPublic)
	float                                         Magnitude;                                         // 0x0120(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_124[0x4];                                      // 0x0124(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        OutVectorArray;                                    // 0x0128(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVectorArrayNormalizeDataflowNode) == 0x000008, "Wrong alignment on FVectorArrayNormalizeDataflowNode");
static_assert(sizeof(FVectorArrayNormalizeDataflowNode) == 0x000138, "Wrong size on FVectorArrayNormalizeDataflowNode");
static_assert(offsetof(FVectorArrayNormalizeDataflowNode, InVectorArray) == 0x0000F0, "Member 'FVectorArrayNormalizeDataflowNode::InVectorArray' has a wrong offset!");
static_assert(offsetof(FVectorArrayNormalizeDataflowNode, Selection) == 0x000100, "Member 'FVectorArrayNormalizeDataflowNode::Selection' has a wrong offset!");
static_assert(offsetof(FVectorArrayNormalizeDataflowNode, Magnitude) == 0x000120, "Member 'FVectorArrayNormalizeDataflowNode::Magnitude' has a wrong offset!");
static_assert(offsetof(FVectorArrayNormalizeDataflowNode, OutVectorArray) == 0x000128, "Member 'FVectorArrayNormalizeDataflowNode::OutVectorArray' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.MultiplyTransformDataflowNode
// 0x0120 (0x0210 - 0x00F0)
struct FMultiplyTransformDataflowNode final : public FDataflowNode
{
public:
	struct FTransform                             InLeftTransform;                                   // 0x00F0(0x0060)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             InRightTransform;                                  // 0x0150(0x0060)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             OutTransform;                                      // 0x01B0(0x0060)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMultiplyTransformDataflowNode) == 0x000010, "Wrong alignment on FMultiplyTransformDataflowNode");
static_assert(sizeof(FMultiplyTransformDataflowNode) == 0x000210, "Wrong size on FMultiplyTransformDataflowNode");
static_assert(offsetof(FMultiplyTransformDataflowNode, InLeftTransform) == 0x0000F0, "Member 'FMultiplyTransformDataflowNode::InLeftTransform' has a wrong offset!");
static_assert(offsetof(FMultiplyTransformDataflowNode, InRightTransform) == 0x000150, "Member 'FMultiplyTransformDataflowNode::InRightTransform' has a wrong offset!");
static_assert(offsetof(FMultiplyTransformDataflowNode, OutTransform) == 0x0001B0, "Member 'FMultiplyTransformDataflowNode::OutTransform' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.InvertTransformDataflowNode
// 0x00C0 (0x01B0 - 0x00F0)
struct FInvertTransformDataflowNode final : public FDataflowNode
{
public:
	struct FTransform                             InTransform;                                       // 0x00F0(0x0060)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             OutTransform;                                      // 0x0150(0x0060)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInvertTransformDataflowNode) == 0x000010, "Wrong alignment on FInvertTransformDataflowNode");
static_assert(sizeof(FInvertTransformDataflowNode) == 0x0001B0, "Wrong size on FInvertTransformDataflowNode");
static_assert(offsetof(FInvertTransformDataflowNode, InTransform) == 0x0000F0, "Member 'FInvertTransformDataflowNode::InTransform' has a wrong offset!");
static_assert(offsetof(FInvertTransformDataflowNode, OutTransform) == 0x000150, "Member 'FInvertTransformDataflowNode::OutTransform' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.UnionIntArraysDataflowNode
// 0x0030 (0x0120 - 0x00F0)
struct FUnionIntArraysDataflowNode final : public FDataflowNode
{
public:
	TArray<int32>                                 InArray1;                                          // 0x00F0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 InArray2;                                          // 0x0100(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 OutArray;                                          // 0x0110(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUnionIntArraysDataflowNode) == 0x000008, "Wrong alignment on FUnionIntArraysDataflowNode");
static_assert(sizeof(FUnionIntArraysDataflowNode) == 0x000120, "Wrong size on FUnionIntArraysDataflowNode");
static_assert(offsetof(FUnionIntArraysDataflowNode, InArray1) == 0x0000F0, "Member 'FUnionIntArraysDataflowNode::InArray1' has a wrong offset!");
static_assert(offsetof(FUnionIntArraysDataflowNode, InArray2) == 0x000100, "Member 'FUnionIntArraysDataflowNode::InArray2' has a wrong offset!");
static_assert(offsetof(FUnionIntArraysDataflowNode, OutArray) == 0x000110, "Member 'FUnionIntArraysDataflowNode::OutArray' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.MakeQuaternionDataflowNode
// 0x0030 (0x0120 - 0x00F0)
struct FMakeQuaternionDataflowNode final : public FDataflowNode
{
public:
	float                                         X;                                                 // 0x00F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Y;                                                 // 0x00F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Z;                                                 // 0x00F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         W;                                                 // 0x00FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FQuat                                  Quaternion;                                        // 0x0100(0x0020)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMakeQuaternionDataflowNode) == 0x000010, "Wrong alignment on FMakeQuaternionDataflowNode");
static_assert(sizeof(FMakeQuaternionDataflowNode) == 0x000120, "Wrong size on FMakeQuaternionDataflowNode");
static_assert(offsetof(FMakeQuaternionDataflowNode, X) == 0x0000F0, "Member 'FMakeQuaternionDataflowNode::X' has a wrong offset!");
static_assert(offsetof(FMakeQuaternionDataflowNode, Y) == 0x0000F4, "Member 'FMakeQuaternionDataflowNode::Y' has a wrong offset!");
static_assert(offsetof(FMakeQuaternionDataflowNode, Z) == 0x0000F8, "Member 'FMakeQuaternionDataflowNode::Z' has a wrong offset!");
static_assert(offsetof(FMakeQuaternionDataflowNode, W) == 0x0000FC, "Member 'FMakeQuaternionDataflowNode::W' has a wrong offset!");
static_assert(offsetof(FMakeQuaternionDataflowNode, Quaternion) == 0x000100, "Member 'FMakeQuaternionDataflowNode::Quaternion' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.CollectionTransformSelectionAllDataflowNode
// 0x00D0 (0x01C0 - 0x00F0)
struct FCollectionTransformSelectionAllDataflowNode final : public FDataflowNode
{
public:
	struct FManagedArrayCollection                Collection;                                        // 0x00F0(0x00B0)(NativeAccessSpecifierPublic)
	struct FDataflowTransformSelection            TransformSelection;                                // 0x01A0(0x0020)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FCollectionTransformSelectionAllDataflowNode) == 0x000008, "Wrong alignment on FCollectionTransformSelectionAllDataflowNode");
static_assert(sizeof(FCollectionTransformSelectionAllDataflowNode) == 0x0001C0, "Wrong size on FCollectionTransformSelectionAllDataflowNode");
static_assert(offsetof(FCollectionTransformSelectionAllDataflowNode, Collection) == 0x0000F0, "Member 'FCollectionTransformSelectionAllDataflowNode::Collection' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionAllDataflowNode, TransformSelection) == 0x0001A0, "Member 'FCollectionTransformSelectionAllDataflowNode::TransformSelection' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.CollectionTransformSelectionSetOperationDataflowNode
// 0x0068 (0x0158 - 0x00F0)
struct FCollectionTransformSelectionSetOperationDataflowNode final : public FDataflowNode
{
public:
	ESetOperationEnum                             Operation;                                         // 0x00F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F1[0x7];                                       // 0x00F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDataflowTransformSelection            TransformSelectionA;                               // 0x00F8(0x0020)(NativeAccessSpecifierPublic)
	struct FDataflowTransformSelection            TransformSelectionB;                               // 0x0118(0x0020)(NativeAccessSpecifierPublic)
	struct FDataflowTransformSelection            TransformSelection;                                // 0x0138(0x0020)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FCollectionTransformSelectionSetOperationDataflowNode) == 0x000008, "Wrong alignment on FCollectionTransformSelectionSetOperationDataflowNode");
static_assert(sizeof(FCollectionTransformSelectionSetOperationDataflowNode) == 0x000158, "Wrong size on FCollectionTransformSelectionSetOperationDataflowNode");
static_assert(offsetof(FCollectionTransformSelectionSetOperationDataflowNode, Operation) == 0x0000F0, "Member 'FCollectionTransformSelectionSetOperationDataflowNode::Operation' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionSetOperationDataflowNode, TransformSelectionA) == 0x0000F8, "Member 'FCollectionTransformSelectionSetOperationDataflowNode::TransformSelectionA' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionSetOperationDataflowNode, TransformSelectionB) == 0x000118, "Member 'FCollectionTransformSelectionSetOperationDataflowNode::TransformSelectionB' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionSetOperationDataflowNode, TransformSelection) == 0x000138, "Member 'FCollectionTransformSelectionSetOperationDataflowNode::TransformSelection' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.CollectionTransformSelectionInfoDataflowNode
// 0x00E0 (0x01D0 - 0x00F0)
struct FCollectionTransformSelectionInfoDataflowNode final : public FDataflowNode
{
public:
	struct FDataflowTransformSelection            TransformSelection;                                // 0x00F0(0x0020)(NativeAccessSpecifierPublic)
	struct FManagedArrayCollection                Collection;                                        // 0x0110(0x00B0)(NativeAccessSpecifierPublic)
	class FString                                 String;                                            // 0x01C0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCollectionTransformSelectionInfoDataflowNode) == 0x000008, "Wrong alignment on FCollectionTransformSelectionInfoDataflowNode");
static_assert(sizeof(FCollectionTransformSelectionInfoDataflowNode) == 0x0001D0, "Wrong size on FCollectionTransformSelectionInfoDataflowNode");
static_assert(offsetof(FCollectionTransformSelectionInfoDataflowNode, TransformSelection) == 0x0000F0, "Member 'FCollectionTransformSelectionInfoDataflowNode::TransformSelection' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionInfoDataflowNode, Collection) == 0x000110, "Member 'FCollectionTransformSelectionInfoDataflowNode::Collection' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionInfoDataflowNode, String) == 0x0001C0, "Member 'FCollectionTransformSelectionInfoDataflowNode::String' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.CollectionTransformSelectionNoneDataflowNode
// 0x00D0 (0x01C0 - 0x00F0)
struct FCollectionTransformSelectionNoneDataflowNode final : public FDataflowNode
{
public:
	struct FManagedArrayCollection                Collection;                                        // 0x00F0(0x00B0)(NativeAccessSpecifierPublic)
	struct FDataflowTransformSelection            TransformSelection;                                // 0x01A0(0x0020)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FCollectionTransformSelectionNoneDataflowNode) == 0x000008, "Wrong alignment on FCollectionTransformSelectionNoneDataflowNode");
static_assert(sizeof(FCollectionTransformSelectionNoneDataflowNode) == 0x0001C0, "Wrong size on FCollectionTransformSelectionNoneDataflowNode");
static_assert(offsetof(FCollectionTransformSelectionNoneDataflowNode, Collection) == 0x0000F0, "Member 'FCollectionTransformSelectionNoneDataflowNode::Collection' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionNoneDataflowNode, TransformSelection) == 0x0001A0, "Member 'FCollectionTransformSelectionNoneDataflowNode::TransformSelection' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.CollectionTransformSelectionInvertDataflowNode
// 0x0020 (0x0110 - 0x00F0)
struct FCollectionTransformSelectionInvertDataflowNode final : public FDataflowNode
{
public:
	struct FDataflowTransformSelection            TransformSelection;                                // 0x00F0(0x0020)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FCollectionTransformSelectionInvertDataflowNode) == 0x000008, "Wrong alignment on FCollectionTransformSelectionInvertDataflowNode");
static_assert(sizeof(FCollectionTransformSelectionInvertDataflowNode) == 0x000110, "Wrong size on FCollectionTransformSelectionInvertDataflowNode");
static_assert(offsetof(FCollectionTransformSelectionInvertDataflowNode, TransformSelection) == 0x0000F0, "Member 'FCollectionTransformSelectionInvertDataflowNode::TransformSelection' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.CollectionTransformSelectionRandomDataflowNode
// 0x00E0 (0x01D0 - 0x00F0)
struct FCollectionTransformSelectionRandomDataflowNode final : public FDataflowNode
{
public:
	bool                                          bDeterministic;                                    // 0x00F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F1[0x3];                                       // 0x00F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RandomSeed;                                        // 0x00F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RandomThreshold;                                   // 0x00F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FC[0x4];                                       // 0x00FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FManagedArrayCollection                Collection;                                        // 0x0100(0x00B0)(NativeAccessSpecifierPublic)
	struct FDataflowTransformSelection            TransformSelection;                                // 0x01B0(0x0020)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FCollectionTransformSelectionRandomDataflowNode) == 0x000008, "Wrong alignment on FCollectionTransformSelectionRandomDataflowNode");
static_assert(sizeof(FCollectionTransformSelectionRandomDataflowNode) == 0x0001D0, "Wrong size on FCollectionTransformSelectionRandomDataflowNode");
static_assert(offsetof(FCollectionTransformSelectionRandomDataflowNode, bDeterministic) == 0x0000F0, "Member 'FCollectionTransformSelectionRandomDataflowNode::bDeterministic' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionRandomDataflowNode, RandomSeed) == 0x0000F4, "Member 'FCollectionTransformSelectionRandomDataflowNode::RandomSeed' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionRandomDataflowNode, RandomThreshold) == 0x0000F8, "Member 'FCollectionTransformSelectionRandomDataflowNode::RandomThreshold' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionRandomDataflowNode, Collection) == 0x000100, "Member 'FCollectionTransformSelectionRandomDataflowNode::Collection' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionRandomDataflowNode, TransformSelection) == 0x0001B0, "Member 'FCollectionTransformSelectionRandomDataflowNode::TransformSelection' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.CollectionTransformSelectionRootDataflowNode
// 0x00D0 (0x01C0 - 0x00F0)
struct FCollectionTransformSelectionRootDataflowNode final : public FDataflowNode
{
public:
	struct FManagedArrayCollection                Collection;                                        // 0x00F0(0x00B0)(NativeAccessSpecifierPublic)
	struct FDataflowTransformSelection            TransformSelection;                                // 0x01A0(0x0020)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FCollectionTransformSelectionRootDataflowNode) == 0x000008, "Wrong alignment on FCollectionTransformSelectionRootDataflowNode");
static_assert(sizeof(FCollectionTransformSelectionRootDataflowNode) == 0x0001C0, "Wrong size on FCollectionTransformSelectionRootDataflowNode");
static_assert(offsetof(FCollectionTransformSelectionRootDataflowNode, Collection) == 0x0000F0, "Member 'FCollectionTransformSelectionRootDataflowNode::Collection' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionRootDataflowNode, TransformSelection) == 0x0001A0, "Member 'FCollectionTransformSelectionRootDataflowNode::TransformSelection' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.CollectionTransformSelectionCustomDataflowNode
// 0x00E0 (0x01D0 - 0x00F0)
struct FCollectionTransformSelectionCustomDataflowNode final : public FDataflowNode
{
public:
	struct FManagedArrayCollection                Collection;                                        // 0x00F0(0x00B0)(NativeAccessSpecifierPublic)
	class FString                                 BoneIndicies;                                      // 0x01A0(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDataflowTransformSelection            TransformSelection;                                // 0x01B0(0x0020)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FCollectionTransformSelectionCustomDataflowNode) == 0x000008, "Wrong alignment on FCollectionTransformSelectionCustomDataflowNode");
static_assert(sizeof(FCollectionTransformSelectionCustomDataflowNode) == 0x0001D0, "Wrong size on FCollectionTransformSelectionCustomDataflowNode");
static_assert(offsetof(FCollectionTransformSelectionCustomDataflowNode, Collection) == 0x0000F0, "Member 'FCollectionTransformSelectionCustomDataflowNode::Collection' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionCustomDataflowNode, BoneIndicies) == 0x0001A0, "Member 'FCollectionTransformSelectionCustomDataflowNode::BoneIndicies' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionCustomDataflowNode, TransformSelection) == 0x0001B0, "Member 'FCollectionTransformSelectionCustomDataflowNode::TransformSelection' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.CollectionTransformSelectionParentDataflowNode
// 0x00D0 (0x01C0 - 0x00F0)
struct FCollectionTransformSelectionParentDataflowNode final : public FDataflowNode
{
public:
	struct FDataflowTransformSelection            TransformSelection;                                // 0x00F0(0x0020)(NativeAccessSpecifierPublic)
	struct FManagedArrayCollection                Collection;                                        // 0x0110(0x00B0)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FCollectionTransformSelectionParentDataflowNode) == 0x000008, "Wrong alignment on FCollectionTransformSelectionParentDataflowNode");
static_assert(sizeof(FCollectionTransformSelectionParentDataflowNode) == 0x0001C0, "Wrong size on FCollectionTransformSelectionParentDataflowNode");
static_assert(offsetof(FCollectionTransformSelectionParentDataflowNode, TransformSelection) == 0x0000F0, "Member 'FCollectionTransformSelectionParentDataflowNode::TransformSelection' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionParentDataflowNode, Collection) == 0x000110, "Member 'FCollectionTransformSelectionParentDataflowNode::Collection' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.CollectionTransformSelectionByPercentageDataflowNode
// 0x0030 (0x0120 - 0x00F0)
struct FCollectionTransformSelectionByPercentageDataflowNode final : public FDataflowNode
{
public:
	struct FDataflowTransformSelection            TransformSelection;                                // 0x00F0(0x0020)(NativeAccessSpecifierPublic)
	int32                                         Percentage;                                        // 0x0110(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDeterministic;                                    // 0x0114(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_115[0x3];                                      // 0x0115(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RandomSeed;                                        // 0x0118(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11C[0x4];                                      // 0x011C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCollectionTransformSelectionByPercentageDataflowNode) == 0x000008, "Wrong alignment on FCollectionTransformSelectionByPercentageDataflowNode");
static_assert(sizeof(FCollectionTransformSelectionByPercentageDataflowNode) == 0x000120, "Wrong size on FCollectionTransformSelectionByPercentageDataflowNode");
static_assert(offsetof(FCollectionTransformSelectionByPercentageDataflowNode, TransformSelection) == 0x0000F0, "Member 'FCollectionTransformSelectionByPercentageDataflowNode::TransformSelection' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionByPercentageDataflowNode, Percentage) == 0x000110, "Member 'FCollectionTransformSelectionByPercentageDataflowNode::Percentage' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionByPercentageDataflowNode, bDeterministic) == 0x000114, "Member 'FCollectionTransformSelectionByPercentageDataflowNode::bDeterministic' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionByPercentageDataflowNode, RandomSeed) == 0x000118, "Member 'FCollectionTransformSelectionByPercentageDataflowNode::RandomSeed' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.CollectionTransformSelectionChildrenDataflowNode
// 0x00D0 (0x01C0 - 0x00F0)
struct FCollectionTransformSelectionChildrenDataflowNode final : public FDataflowNode
{
public:
	struct FDataflowTransformSelection            TransformSelection;                                // 0x00F0(0x0020)(NativeAccessSpecifierPublic)
	struct FManagedArrayCollection                Collection;                                        // 0x0110(0x00B0)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FCollectionTransformSelectionChildrenDataflowNode) == 0x000008, "Wrong alignment on FCollectionTransformSelectionChildrenDataflowNode");
static_assert(sizeof(FCollectionTransformSelectionChildrenDataflowNode) == 0x0001C0, "Wrong size on FCollectionTransformSelectionChildrenDataflowNode");
static_assert(offsetof(FCollectionTransformSelectionChildrenDataflowNode, TransformSelection) == 0x0000F0, "Member 'FCollectionTransformSelectionChildrenDataflowNode::TransformSelection' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionChildrenDataflowNode, Collection) == 0x000110, "Member 'FCollectionTransformSelectionChildrenDataflowNode::Collection' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.CollectionTransformSelectionSiblingsDataflowNode
// 0x00D0 (0x01C0 - 0x00F0)
struct FCollectionTransformSelectionSiblingsDataflowNode final : public FDataflowNode
{
public:
	struct FDataflowTransformSelection            TransformSelection;                                // 0x00F0(0x0020)(NativeAccessSpecifierPublic)
	struct FManagedArrayCollection                Collection;                                        // 0x0110(0x00B0)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FCollectionTransformSelectionSiblingsDataflowNode) == 0x000008, "Wrong alignment on FCollectionTransformSelectionSiblingsDataflowNode");
static_assert(sizeof(FCollectionTransformSelectionSiblingsDataflowNode) == 0x0001C0, "Wrong size on FCollectionTransformSelectionSiblingsDataflowNode");
static_assert(offsetof(FCollectionTransformSelectionSiblingsDataflowNode, TransformSelection) == 0x0000F0, "Member 'FCollectionTransformSelectionSiblingsDataflowNode::TransformSelection' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionSiblingsDataflowNode, Collection) == 0x000110, "Member 'FCollectionTransformSelectionSiblingsDataflowNode::Collection' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.CollectionTransformSelectionLevelDataflowNode
// 0x00D0 (0x01C0 - 0x00F0)
struct FCollectionTransformSelectionLevelDataflowNode final : public FDataflowNode
{
public:
	struct FDataflowTransformSelection            TransformSelection;                                // 0x00F0(0x0020)(NativeAccessSpecifierPublic)
	struct FManagedArrayCollection                Collection;                                        // 0x0110(0x00B0)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FCollectionTransformSelectionLevelDataflowNode) == 0x000008, "Wrong alignment on FCollectionTransformSelectionLevelDataflowNode");
static_assert(sizeof(FCollectionTransformSelectionLevelDataflowNode) == 0x0001C0, "Wrong size on FCollectionTransformSelectionLevelDataflowNode");
static_assert(offsetof(FCollectionTransformSelectionLevelDataflowNode, TransformSelection) == 0x0000F0, "Member 'FCollectionTransformSelectionLevelDataflowNode::TransformSelection' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionLevelDataflowNode, Collection) == 0x000110, "Member 'FCollectionTransformSelectionLevelDataflowNode::Collection' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.CollectionTransformSelectionContactDataflowNode
// 0x00D0 (0x01C0 - 0x00F0)
struct FCollectionTransformSelectionContactDataflowNode final : public FDataflowNode
{
public:
	struct FDataflowTransformSelection            TransformSelection;                                // 0x00F0(0x0020)(NativeAccessSpecifierPublic)
	struct FManagedArrayCollection                Collection;                                        // 0x0110(0x00B0)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FCollectionTransformSelectionContactDataflowNode) == 0x000008, "Wrong alignment on FCollectionTransformSelectionContactDataflowNode");
static_assert(sizeof(FCollectionTransformSelectionContactDataflowNode) == 0x0001C0, "Wrong size on FCollectionTransformSelectionContactDataflowNode");
static_assert(offsetof(FCollectionTransformSelectionContactDataflowNode, TransformSelection) == 0x0000F0, "Member 'FCollectionTransformSelectionContactDataflowNode::TransformSelection' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionContactDataflowNode, Collection) == 0x000110, "Member 'FCollectionTransformSelectionContactDataflowNode::Collection' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.CollectionTransformSelectionLeafDataflowNode
// 0x00D0 (0x01C0 - 0x00F0)
struct FCollectionTransformSelectionLeafDataflowNode final : public FDataflowNode
{
public:
	struct FManagedArrayCollection                Collection;                                        // 0x00F0(0x00B0)(NativeAccessSpecifierPublic)
	struct FDataflowTransformSelection            TransformSelection;                                // 0x01A0(0x0020)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FCollectionTransformSelectionLeafDataflowNode) == 0x000008, "Wrong alignment on FCollectionTransformSelectionLeafDataflowNode");
static_assert(sizeof(FCollectionTransformSelectionLeafDataflowNode) == 0x0001C0, "Wrong size on FCollectionTransformSelectionLeafDataflowNode");
static_assert(offsetof(FCollectionTransformSelectionLeafDataflowNode, Collection) == 0x0000F0, "Member 'FCollectionTransformSelectionLeafDataflowNode::Collection' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionLeafDataflowNode, TransformSelection) == 0x0001A0, "Member 'FCollectionTransformSelectionLeafDataflowNode::TransformSelection' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.CollectionTransformSelectionClusterDataflowNode
// 0x00D0 (0x01C0 - 0x00F0)
struct FCollectionTransformSelectionClusterDataflowNode final : public FDataflowNode
{
public:
	struct FManagedArrayCollection                Collection;                                        // 0x00F0(0x00B0)(NativeAccessSpecifierPublic)
	struct FDataflowTransformSelection            TransformSelection;                                // 0x01A0(0x0020)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FCollectionTransformSelectionClusterDataflowNode) == 0x000008, "Wrong alignment on FCollectionTransformSelectionClusterDataflowNode");
static_assert(sizeof(FCollectionTransformSelectionClusterDataflowNode) == 0x0001C0, "Wrong size on FCollectionTransformSelectionClusterDataflowNode");
static_assert(offsetof(FCollectionTransformSelectionClusterDataflowNode, Collection) == 0x0000F0, "Member 'FCollectionTransformSelectionClusterDataflowNode::Collection' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionClusterDataflowNode, TransformSelection) == 0x0001A0, "Member 'FCollectionTransformSelectionClusterDataflowNode::TransformSelection' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.CollectionTransformSelectionBySizeDataflowNode
// 0x00E0 (0x01D0 - 0x00F0)
struct FCollectionTransformSelectionBySizeDataflowNode final : public FDataflowNode
{
public:
	struct FManagedArrayCollection                Collection;                                        // 0x00F0(0x00B0)(NativeAccessSpecifierPublic)
	float                                         SizeMin;                                           // 0x01A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SizeMax;                                           // 0x01A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERangeSettingEnum                             RangeSetting;                                      // 0x01A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInclusive;                                        // 0x01A9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1AA[0x6];                                      // 0x01AA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDataflowTransformSelection            TransformSelection;                                // 0x01B0(0x0020)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FCollectionTransformSelectionBySizeDataflowNode) == 0x000008, "Wrong alignment on FCollectionTransformSelectionBySizeDataflowNode");
static_assert(sizeof(FCollectionTransformSelectionBySizeDataflowNode) == 0x0001D0, "Wrong size on FCollectionTransformSelectionBySizeDataflowNode");
static_assert(offsetof(FCollectionTransformSelectionBySizeDataflowNode, Collection) == 0x0000F0, "Member 'FCollectionTransformSelectionBySizeDataflowNode::Collection' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionBySizeDataflowNode, SizeMin) == 0x0001A0, "Member 'FCollectionTransformSelectionBySizeDataflowNode::SizeMin' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionBySizeDataflowNode, SizeMax) == 0x0001A4, "Member 'FCollectionTransformSelectionBySizeDataflowNode::SizeMax' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionBySizeDataflowNode, RangeSetting) == 0x0001A8, "Member 'FCollectionTransformSelectionBySizeDataflowNode::RangeSetting' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionBySizeDataflowNode, bInclusive) == 0x0001A9, "Member 'FCollectionTransformSelectionBySizeDataflowNode::bInclusive' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionBySizeDataflowNode, TransformSelection) == 0x0001B0, "Member 'FCollectionTransformSelectionBySizeDataflowNode::TransformSelection' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.CollectionTransformSelectionByVolumeDataflowNode
// 0x00E0 (0x01D0 - 0x00F0)
struct FCollectionTransformSelectionByVolumeDataflowNode final : public FDataflowNode
{
public:
	struct FManagedArrayCollection                Collection;                                        // 0x00F0(0x00B0)(NativeAccessSpecifierPublic)
	float                                         VolumeMin;                                         // 0x01A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VolumeMax;                                         // 0x01A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERangeSettingEnum                             RangeSetting;                                      // 0x01A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInclusive;                                        // 0x01A9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1AA[0x6];                                      // 0x01AA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDataflowTransformSelection            TransformSelection;                                // 0x01B0(0x0020)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FCollectionTransformSelectionByVolumeDataflowNode) == 0x000008, "Wrong alignment on FCollectionTransformSelectionByVolumeDataflowNode");
static_assert(sizeof(FCollectionTransformSelectionByVolumeDataflowNode) == 0x0001D0, "Wrong size on FCollectionTransformSelectionByVolumeDataflowNode");
static_assert(offsetof(FCollectionTransformSelectionByVolumeDataflowNode, Collection) == 0x0000F0, "Member 'FCollectionTransformSelectionByVolumeDataflowNode::Collection' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionByVolumeDataflowNode, VolumeMin) == 0x0001A0, "Member 'FCollectionTransformSelectionByVolumeDataflowNode::VolumeMin' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionByVolumeDataflowNode, VolumeMax) == 0x0001A4, "Member 'FCollectionTransformSelectionByVolumeDataflowNode::VolumeMax' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionByVolumeDataflowNode, RangeSetting) == 0x0001A8, "Member 'FCollectionTransformSelectionByVolumeDataflowNode::RangeSetting' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionByVolumeDataflowNode, bInclusive) == 0x0001A9, "Member 'FCollectionTransformSelectionByVolumeDataflowNode::bInclusive' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionByVolumeDataflowNode, TransformSelection) == 0x0001B0, "Member 'FCollectionTransformSelectionByVolumeDataflowNode::TransformSelection' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.CollectionTransformSelectionInBoxDataflowNode
// 0x0180 (0x0270 - 0x00F0)
struct FCollectionTransformSelectionInBoxDataflowNode final : public FDataflowNode
{
public:
	struct FManagedArrayCollection                Collection;                                        // 0x00F0(0x00B0)(NativeAccessSpecifierPublic)
	struct FBox                                   Box;                                               // 0x01A0(0x0038)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D8[0x8];                                      // 0x01D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Transform;                                         // 0x01E0(0x0060)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESelectSubjectTypeEnum                        Type;                                              // 0x0240(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllVerticesMustContainedInBox;                    // 0x0241(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_242[0x6];                                      // 0x0242(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDataflowTransformSelection            TransformSelection;                                // 0x0248(0x0020)(NativeAccessSpecifierPublic)
	uint8                                         Pad_268[0x8];                                      // 0x0268(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCollectionTransformSelectionInBoxDataflowNode) == 0x000010, "Wrong alignment on FCollectionTransformSelectionInBoxDataflowNode");
static_assert(sizeof(FCollectionTransformSelectionInBoxDataflowNode) == 0x000270, "Wrong size on FCollectionTransformSelectionInBoxDataflowNode");
static_assert(offsetof(FCollectionTransformSelectionInBoxDataflowNode, Collection) == 0x0000F0, "Member 'FCollectionTransformSelectionInBoxDataflowNode::Collection' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionInBoxDataflowNode, Box) == 0x0001A0, "Member 'FCollectionTransformSelectionInBoxDataflowNode::Box' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionInBoxDataflowNode, Transform) == 0x0001E0, "Member 'FCollectionTransformSelectionInBoxDataflowNode::Transform' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionInBoxDataflowNode, Type) == 0x000240, "Member 'FCollectionTransformSelectionInBoxDataflowNode::Type' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionInBoxDataflowNode, bAllVerticesMustContainedInBox) == 0x000241, "Member 'FCollectionTransformSelectionInBoxDataflowNode::bAllVerticesMustContainedInBox' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionInBoxDataflowNode, TransformSelection) == 0x000248, "Member 'FCollectionTransformSelectionInBoxDataflowNode::TransformSelection' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.CollectionTransformSelectionInSphereDataflowNode
// 0x0160 (0x0250 - 0x00F0)
struct FCollectionTransformSelectionInSphereDataflowNode final : public FDataflowNode
{
public:
	struct FManagedArrayCollection                Collection;                                        // 0x00F0(0x00B0)(NativeAccessSpecifierPublic)
	struct FSphere                                Sphere;                                            // 0x01A0(0x0020)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             Transform;                                         // 0x01C0(0x0060)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESelectSubjectTypeEnum                        Type;                                              // 0x0220(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllVerticesMustContainedInSphere;                 // 0x0221(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_222[0x6];                                      // 0x0222(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDataflowTransformSelection            TransformSelection;                                // 0x0228(0x0020)(NativeAccessSpecifierPublic)
	uint8                                         Pad_248[0x8];                                      // 0x0248(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCollectionTransformSelectionInSphereDataflowNode) == 0x000010, "Wrong alignment on FCollectionTransformSelectionInSphereDataflowNode");
static_assert(sizeof(FCollectionTransformSelectionInSphereDataflowNode) == 0x000250, "Wrong size on FCollectionTransformSelectionInSphereDataflowNode");
static_assert(offsetof(FCollectionTransformSelectionInSphereDataflowNode, Collection) == 0x0000F0, "Member 'FCollectionTransformSelectionInSphereDataflowNode::Collection' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionInSphereDataflowNode, Sphere) == 0x0001A0, "Member 'FCollectionTransformSelectionInSphereDataflowNode::Sphere' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionInSphereDataflowNode, Transform) == 0x0001C0, "Member 'FCollectionTransformSelectionInSphereDataflowNode::Transform' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionInSphereDataflowNode, Type) == 0x000220, "Member 'FCollectionTransformSelectionInSphereDataflowNode::Type' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionInSphereDataflowNode, bAllVerticesMustContainedInSphere) == 0x000221, "Member 'FCollectionTransformSelectionInSphereDataflowNode::bAllVerticesMustContainedInSphere' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionInSphereDataflowNode, TransformSelection) == 0x000228, "Member 'FCollectionTransformSelectionInSphereDataflowNode::TransformSelection' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.CollectionTransformSelectionByFloatAttrDataflowNode
// 0x0100 (0x01F0 - 0x00F0)
struct FCollectionTransformSelectionByFloatAttrDataflowNode final : public FDataflowNode
{
public:
	struct FManagedArrayCollection                Collection;                                        // 0x00F0(0x00B0)(NativeAccessSpecifierPublic)
	class FString                                 GroupName;                                         // 0x01A0(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AttrName;                                          // 0x01B0(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Min;                                               // 0x01C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Max;                                               // 0x01C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERangeSettingEnum                             RangeSetting;                                      // 0x01C8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInclusive;                                        // 0x01C9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1CA[0x6];                                      // 0x01CA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDataflowTransformSelection            TransformSelection;                                // 0x01D0(0x0020)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FCollectionTransformSelectionByFloatAttrDataflowNode) == 0x000008, "Wrong alignment on FCollectionTransformSelectionByFloatAttrDataflowNode");
static_assert(sizeof(FCollectionTransformSelectionByFloatAttrDataflowNode) == 0x0001F0, "Wrong size on FCollectionTransformSelectionByFloatAttrDataflowNode");
static_assert(offsetof(FCollectionTransformSelectionByFloatAttrDataflowNode, Collection) == 0x0000F0, "Member 'FCollectionTransformSelectionByFloatAttrDataflowNode::Collection' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionByFloatAttrDataflowNode, GroupName) == 0x0001A0, "Member 'FCollectionTransformSelectionByFloatAttrDataflowNode::GroupName' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionByFloatAttrDataflowNode, AttrName) == 0x0001B0, "Member 'FCollectionTransformSelectionByFloatAttrDataflowNode::AttrName' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionByFloatAttrDataflowNode, Min) == 0x0001C0, "Member 'FCollectionTransformSelectionByFloatAttrDataflowNode::Min' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionByFloatAttrDataflowNode, Max) == 0x0001C4, "Member 'FCollectionTransformSelectionByFloatAttrDataflowNode::Max' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionByFloatAttrDataflowNode, RangeSetting) == 0x0001C8, "Member 'FCollectionTransformSelectionByFloatAttrDataflowNode::RangeSetting' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionByFloatAttrDataflowNode, bInclusive) == 0x0001C9, "Member 'FCollectionTransformSelectionByFloatAttrDataflowNode::bInclusive' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionByFloatAttrDataflowNode, TransformSelection) == 0x0001D0, "Member 'FCollectionTransformSelectionByFloatAttrDataflowNode::TransformSelection' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.CollectionTransformSelectionByIntAttrDataflowNode
// 0x0100 (0x01F0 - 0x00F0)
struct FCollectionTransformSelectionByIntAttrDataflowNode final : public FDataflowNode
{
public:
	struct FManagedArrayCollection                Collection;                                        // 0x00F0(0x00B0)(NativeAccessSpecifierPublic)
	class FString                                 GroupName;                                         // 0x01A0(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AttrName;                                          // 0x01B0(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Min;                                               // 0x01C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Max;                                               // 0x01C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERangeSettingEnum                             RangeSetting;                                      // 0x01C8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInclusive;                                        // 0x01C9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1CA[0x6];                                      // 0x01CA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDataflowTransformSelection            TransformSelection;                                // 0x01D0(0x0020)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FCollectionTransformSelectionByIntAttrDataflowNode) == 0x000008, "Wrong alignment on FCollectionTransformSelectionByIntAttrDataflowNode");
static_assert(sizeof(FCollectionTransformSelectionByIntAttrDataflowNode) == 0x0001F0, "Wrong size on FCollectionTransformSelectionByIntAttrDataflowNode");
static_assert(offsetof(FCollectionTransformSelectionByIntAttrDataflowNode, Collection) == 0x0000F0, "Member 'FCollectionTransformSelectionByIntAttrDataflowNode::Collection' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionByIntAttrDataflowNode, GroupName) == 0x0001A0, "Member 'FCollectionTransformSelectionByIntAttrDataflowNode::GroupName' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionByIntAttrDataflowNode, AttrName) == 0x0001B0, "Member 'FCollectionTransformSelectionByIntAttrDataflowNode::AttrName' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionByIntAttrDataflowNode, Min) == 0x0001C0, "Member 'FCollectionTransformSelectionByIntAttrDataflowNode::Min' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionByIntAttrDataflowNode, Max) == 0x0001C4, "Member 'FCollectionTransformSelectionByIntAttrDataflowNode::Max' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionByIntAttrDataflowNode, RangeSetting) == 0x0001C8, "Member 'FCollectionTransformSelectionByIntAttrDataflowNode::RangeSetting' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionByIntAttrDataflowNode, bInclusive) == 0x0001C9, "Member 'FCollectionTransformSelectionByIntAttrDataflowNode::bInclusive' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionByIntAttrDataflowNode, TransformSelection) == 0x0001D0, "Member 'FCollectionTransformSelectionByIntAttrDataflowNode::TransformSelection' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.CollectionVertexSelectionCustomDataflowNode
// 0x00E0 (0x01D0 - 0x00F0)
struct FCollectionVertexSelectionCustomDataflowNode final : public FDataflowNode
{
public:
	struct FManagedArrayCollection                Collection;                                        // 0x00F0(0x00B0)(NativeAccessSpecifierPublic)
	class FString                                 VertexIndicies;                                    // 0x01A0(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDataflowVertexSelection               VertexSelection;                                   // 0x01B0(0x0020)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FCollectionVertexSelectionCustomDataflowNode) == 0x000008, "Wrong alignment on FCollectionVertexSelectionCustomDataflowNode");
static_assert(sizeof(FCollectionVertexSelectionCustomDataflowNode) == 0x0001D0, "Wrong size on FCollectionVertexSelectionCustomDataflowNode");
static_assert(offsetof(FCollectionVertexSelectionCustomDataflowNode, Collection) == 0x0000F0, "Member 'FCollectionVertexSelectionCustomDataflowNode::Collection' has a wrong offset!");
static_assert(offsetof(FCollectionVertexSelectionCustomDataflowNode, VertexIndicies) == 0x0001A0, "Member 'FCollectionVertexSelectionCustomDataflowNode::VertexIndicies' has a wrong offset!");
static_assert(offsetof(FCollectionVertexSelectionCustomDataflowNode, VertexSelection) == 0x0001B0, "Member 'FCollectionVertexSelectionCustomDataflowNode::VertexSelection' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.CollectionFaceSelectionCustomDataflowNode
// 0x00E0 (0x01D0 - 0x00F0)
struct FCollectionFaceSelectionCustomDataflowNode final : public FDataflowNode
{
public:
	struct FManagedArrayCollection                Collection;                                        // 0x00F0(0x00B0)(NativeAccessSpecifierPublic)
	class FString                                 FaceIndicies;                                      // 0x01A0(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDataflowFaceSelection                 FaceSelection;                                     // 0x01B0(0x0020)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FCollectionFaceSelectionCustomDataflowNode) == 0x000008, "Wrong alignment on FCollectionFaceSelectionCustomDataflowNode");
static_assert(sizeof(FCollectionFaceSelectionCustomDataflowNode) == 0x0001D0, "Wrong size on FCollectionFaceSelectionCustomDataflowNode");
static_assert(offsetof(FCollectionFaceSelectionCustomDataflowNode, Collection) == 0x0000F0, "Member 'FCollectionFaceSelectionCustomDataflowNode::Collection' has a wrong offset!");
static_assert(offsetof(FCollectionFaceSelectionCustomDataflowNode, FaceIndicies) == 0x0001A0, "Member 'FCollectionFaceSelectionCustomDataflowNode::FaceIndicies' has a wrong offset!");
static_assert(offsetof(FCollectionFaceSelectionCustomDataflowNode, FaceSelection) == 0x0001B0, "Member 'FCollectionFaceSelectionCustomDataflowNode::FaceSelection' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.CollectionSelectionConvertDataflowNode
// 0x0118 (0x0208 - 0x00F0)
struct FCollectionSelectionConvertDataflowNode final : public FDataflowNode
{
public:
	struct FManagedArrayCollection                Collection;                                        // 0x00F0(0x00B0)(NativeAccessSpecifierPublic)
	struct FDataflowTransformSelection            TransformSelection;                                // 0x01A0(0x0020)(NativeAccessSpecifierPublic)
	struct FDataflowFaceSelection                 FaceSelection;                                     // 0x01C0(0x0020)(NativeAccessSpecifierPublic)
	struct FDataflowVertexSelection               VertexSelection;                                   // 0x01E0(0x0020)(NativeAccessSpecifierPublic)
	bool                                          bAllElementsMustBeSelected;                        // 0x0200(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_201[0x7];                                      // 0x0201(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCollectionSelectionConvertDataflowNode) == 0x000008, "Wrong alignment on FCollectionSelectionConvertDataflowNode");
static_assert(sizeof(FCollectionSelectionConvertDataflowNode) == 0x000208, "Wrong size on FCollectionSelectionConvertDataflowNode");
static_assert(offsetof(FCollectionSelectionConvertDataflowNode, Collection) == 0x0000F0, "Member 'FCollectionSelectionConvertDataflowNode::Collection' has a wrong offset!");
static_assert(offsetof(FCollectionSelectionConvertDataflowNode, TransformSelection) == 0x0001A0, "Member 'FCollectionSelectionConvertDataflowNode::TransformSelection' has a wrong offset!");
static_assert(offsetof(FCollectionSelectionConvertDataflowNode, FaceSelection) == 0x0001C0, "Member 'FCollectionSelectionConvertDataflowNode::FaceSelection' has a wrong offset!");
static_assert(offsetof(FCollectionSelectionConvertDataflowNode, VertexSelection) == 0x0001E0, "Member 'FCollectionSelectionConvertDataflowNode::VertexSelection' has a wrong offset!");
static_assert(offsetof(FCollectionSelectionConvertDataflowNode, bAllElementsMustBeSelected) == 0x000200, "Member 'FCollectionSelectionConvertDataflowNode::bAllElementsMustBeSelected' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.CollectionFaceSelectionInvertDataflowNode
// 0x0020 (0x0110 - 0x00F0)
struct FCollectionFaceSelectionInvertDataflowNode final : public FDataflowNode
{
public:
	struct FDataflowFaceSelection                 FaceSelection;                                     // 0x00F0(0x0020)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FCollectionFaceSelectionInvertDataflowNode) == 0x000008, "Wrong alignment on FCollectionFaceSelectionInvertDataflowNode");
static_assert(sizeof(FCollectionFaceSelectionInvertDataflowNode) == 0x000110, "Wrong size on FCollectionFaceSelectionInvertDataflowNode");
static_assert(offsetof(FCollectionFaceSelectionInvertDataflowNode, FaceSelection) == 0x0000F0, "Member 'FCollectionFaceSelectionInvertDataflowNode::FaceSelection' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.CollectionVertexSelectionByPercentageDataflowNode
// 0x0030 (0x0120 - 0x00F0)
struct FCollectionVertexSelectionByPercentageDataflowNode final : public FDataflowNode
{
public:
	struct FDataflowVertexSelection               VertexSelection;                                   // 0x00F0(0x0020)(NativeAccessSpecifierPublic)
	int32                                         Percentage;                                        // 0x0110(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDeterministic;                                    // 0x0114(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_115[0x3];                                      // 0x0115(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RandomSeed;                                        // 0x0118(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11C[0x4];                                      // 0x011C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCollectionVertexSelectionByPercentageDataflowNode) == 0x000008, "Wrong alignment on FCollectionVertexSelectionByPercentageDataflowNode");
static_assert(sizeof(FCollectionVertexSelectionByPercentageDataflowNode) == 0x000120, "Wrong size on FCollectionVertexSelectionByPercentageDataflowNode");
static_assert(offsetof(FCollectionVertexSelectionByPercentageDataflowNode, VertexSelection) == 0x0000F0, "Member 'FCollectionVertexSelectionByPercentageDataflowNode::VertexSelection' has a wrong offset!");
static_assert(offsetof(FCollectionVertexSelectionByPercentageDataflowNode, Percentage) == 0x000110, "Member 'FCollectionVertexSelectionByPercentageDataflowNode::Percentage' has a wrong offset!");
static_assert(offsetof(FCollectionVertexSelectionByPercentageDataflowNode, bDeterministic) == 0x000114, "Member 'FCollectionVertexSelectionByPercentageDataflowNode::bDeterministic' has a wrong offset!");
static_assert(offsetof(FCollectionVertexSelectionByPercentageDataflowNode, RandomSeed) == 0x000118, "Member 'FCollectionVertexSelectionByPercentageDataflowNode::RandomSeed' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.CollectionVertexSelectionSetOperationDataflowNode
// 0x0068 (0x0158 - 0x00F0)
struct FCollectionVertexSelectionSetOperationDataflowNode final : public FDataflowNode
{
public:
	ESetOperationEnum                             Operation;                                         // 0x00F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F1[0x7];                                       // 0x00F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDataflowVertexSelection               VertexSelectionA;                                  // 0x00F8(0x0020)(NativeAccessSpecifierPublic)
	struct FDataflowVertexSelection               VertexSelectionB;                                  // 0x0118(0x0020)(NativeAccessSpecifierPublic)
	struct FDataflowVertexSelection               VertexSelection;                                   // 0x0138(0x0020)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FCollectionVertexSelectionSetOperationDataflowNode) == 0x000008, "Wrong alignment on FCollectionVertexSelectionSetOperationDataflowNode");
static_assert(sizeof(FCollectionVertexSelectionSetOperationDataflowNode) == 0x000158, "Wrong size on FCollectionVertexSelectionSetOperationDataflowNode");
static_assert(offsetof(FCollectionVertexSelectionSetOperationDataflowNode, Operation) == 0x0000F0, "Member 'FCollectionVertexSelectionSetOperationDataflowNode::Operation' has a wrong offset!");
static_assert(offsetof(FCollectionVertexSelectionSetOperationDataflowNode, VertexSelectionA) == 0x0000F8, "Member 'FCollectionVertexSelectionSetOperationDataflowNode::VertexSelectionA' has a wrong offset!");
static_assert(offsetof(FCollectionVertexSelectionSetOperationDataflowNode, VertexSelectionB) == 0x000118, "Member 'FCollectionVertexSelectionSetOperationDataflowNode::VertexSelectionB' has a wrong offset!");
static_assert(offsetof(FCollectionVertexSelectionSetOperationDataflowNode, VertexSelection) == 0x000138, "Member 'FCollectionVertexSelectionSetOperationDataflowNode::VertexSelection' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.TransformCollectionAttributeDataflowNode
// 0x0190 (0x0280 - 0x00F0)
struct FTransformCollectionAttributeDataflowNode final : public FDataflowNode
{
public:
	struct FManagedArrayCollection                Collection;                                        // 0x00F0(0x00B0)(NativeAccessSpecifierPublic)
	struct FTransform                             TransformIn;                                       // 0x01A0(0x0060)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             LocalTransform;                                    // 0x0200(0x0060)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 GroupName;                                         // 0x0260(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AttributeName;                                     // 0x0270(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTransformCollectionAttributeDataflowNode) == 0x000010, "Wrong alignment on FTransformCollectionAttributeDataflowNode");
static_assert(sizeof(FTransformCollectionAttributeDataflowNode) == 0x000280, "Wrong size on FTransformCollectionAttributeDataflowNode");
static_assert(offsetof(FTransformCollectionAttributeDataflowNode, Collection) == 0x0000F0, "Member 'FTransformCollectionAttributeDataflowNode::Collection' has a wrong offset!");
static_assert(offsetof(FTransformCollectionAttributeDataflowNode, TransformIn) == 0x0001A0, "Member 'FTransformCollectionAttributeDataflowNode::TransformIn' has a wrong offset!");
static_assert(offsetof(FTransformCollectionAttributeDataflowNode, LocalTransform) == 0x000200, "Member 'FTransformCollectionAttributeDataflowNode::LocalTransform' has a wrong offset!");
static_assert(offsetof(FTransformCollectionAttributeDataflowNode, GroupName) == 0x000260, "Member 'FTransformCollectionAttributeDataflowNode::GroupName' has a wrong offset!");
static_assert(offsetof(FTransformCollectionAttributeDataflowNode, AttributeName) == 0x000270, "Member 'FTransformCollectionAttributeDataflowNode::AttributeName' has a wrong offset!");

}

