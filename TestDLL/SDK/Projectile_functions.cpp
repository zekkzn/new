#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Projectile

#include "Basic.hpp"

#include "Projectile_classes.hpp"
#include "Projectile_parameters.hpp"


namespace SDK
{

// Function Projectile.SingleProjectileProviderComponent.OnRep_Projectile
// (Final, Native, Private)

void USingleProjectileProviderComponent::OnRep_Projectile()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SingleProjectileProviderComponent", "OnRep_Projectile");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Projectile.BaseProjectileLauncher.Authority_AddMaxAmmo
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   AmmoToAdd                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBaseProjectileLauncher::Authority_AddMaxAmmo(int32 AmmoToAdd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectileLauncher", "Authority_AddMaxAmmo");

	Params::BaseProjectileLauncher_Authority_AddMaxAmmo Parms{};

	Parms.AmmoToAdd = AmmoToAdd;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Projectile.BaseProjectileLauncher.Authority_Launch
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void UBaseProjectileLauncher::Authority_Launch()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectileLauncher", "Authority_Launch");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Projectile.BaseProjectileLauncher.Authority_Reload
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void UBaseProjectileLauncher::Authority_Reload()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectileLauncher", "Authority_Reload");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Projectile.BaseProjectileLauncher.Authority_ReturnAmmoUnits
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   AmountOfAmmoUnitsReturned                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBaseProjectileLauncher::Authority_ReturnAmmoUnits(int32 AmountOfAmmoUnitsReturned)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectileLauncher", "Authority_ReturnAmmoUnits");

	Params::BaseProjectileLauncher_Authority_ReturnAmmoUnits Parms{};

	Parms.AmountOfAmmoUnitsReturned = AmountOfAmmoUnitsReturned;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Projectile.BaseProjectileLauncher.Authority_SetMaxAmmo
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   NewMaxAmmo                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsMaxAmmoImmutable                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBaseProjectileLauncher::Authority_SetMaxAmmo(int32 NewMaxAmmo, bool IsMaxAmmoImmutable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectileLauncher", "Authority_SetMaxAmmo");

	Params::BaseProjectileLauncher_Authority_SetMaxAmmo Parms{};

	Parms.NewMaxAmmo = NewMaxAmmo;
	Parms.IsMaxAmmoImmutable = IsMaxAmmoImmutable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Projectile.BaseProjectileLauncher.Cosmetic_OnOutOfAmmo
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)

void UBaseProjectileLauncher::Cosmetic_OnOutOfAmmo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectileLauncher", "Cosmetic_OnOutOfAmmo");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Projectile.BaseProjectileLauncher.Local_Launch
// (Final, Native, Public, BlueprintCallable)

void UBaseProjectileLauncher::Local_Launch()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectileLauncher", "Local_Launch");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Projectile.BaseProjectileLauncher.OnLaunch
// (Event, Protected, BlueprintEvent)
// Parameters:
// struct FLaunchInfo                      LaunchInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class ABaseProjectile*                  Projectile                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBaseProjectileLauncher::OnLaunch(const struct FLaunchInfo& LaunchInfo, class ABaseProjectile* Projectile)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectileLauncher", "OnLaunch");

	Params::BaseProjectileLauncher_OnLaunch Parms{};

	Parms.LaunchInfo = std::move(LaunchInfo);
	Parms.Projectile = Projectile;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Projectile.BaseProjectileLauncher.OnRep_Ammo
// (Native, Protected)
// Parameters:
// int32                                   OldAmmo                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBaseProjectileLauncher::OnRep_Ammo(int32 OldAmmo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectileLauncher", "OnRep_Ammo");

	Params::BaseProjectileLauncher_OnRep_Ammo Parms{};

	Parms.OldAmmo = OldAmmo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Projectile.BaseProjectileLauncher.OnRep_MaxAmmo
// (Native, Protected)
// Parameters:
// int32                                   OldMaxAmmo                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBaseProjectileLauncher::OnRep_MaxAmmo(int32 OldMaxAmmo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectileLauncher", "OnRep_MaxAmmo");

	Params::BaseProjectileLauncher_OnRep_MaxAmmo Parms{};

	Parms.OldMaxAmmo = OldMaxAmmo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Projectile.BaseProjectileLauncher.Server_Launch
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// struct FLaunchInfo                      LaunchInfo                                             (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// class ABaseProjectile*                  Projectile                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBaseProjectileLauncher::Server_Launch(const struct FLaunchInfo& LaunchInfo, class ABaseProjectile* Projectile)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectileLauncher", "Server_Launch");

	Params::BaseProjectileLauncher_Server_Launch Parms{};

	Parms.LaunchInfo = std::move(LaunchInfo);
	Parms.Projectile = Projectile;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Projectile.BaseProjectileLauncher.Server_LaunchWithImpact
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// struct FLaunchInfo                      LaunchInfo                                             (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FImpactInfo                      ImpactInfo                                             (ConstParm, Parm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class ABaseProjectile*                  Projectile                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBaseProjectileLauncher::Server_LaunchWithImpact(const struct FLaunchInfo& LaunchInfo, const struct FImpactInfo& ImpactInfo, class ABaseProjectile* Projectile)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectileLauncher", "Server_LaunchWithImpact");

	Params::BaseProjectileLauncher_Server_LaunchWithImpact Parms{};

	Parms.LaunchInfo = std::move(LaunchInfo);
	Parms.ImpactInfo = std::move(ImpactInfo);
	Parms.Projectile = Projectile;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Projectile.BaseProjectileLauncher.SetProjectileProvider
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class IProjectileProvider>ProjectileProvider                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBaseProjectileLauncher::SetProjectileProvider(TScriptInterface<class IProjectileProvider> ProjectileProvider)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectileLauncher", "SetProjectileProvider");

	Params::BaseProjectileLauncher_SetProjectileProvider Parms{};

	Parms.ProjectileProvider = ProjectileProvider;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Projectile.BaseProjectileLauncher.SetProjectileVar
// (Event, Public, BlueprintEvent)
// Parameters:
// class FName                             VarName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBaseProjectileLauncher::SetProjectileVar(class FName VarName, float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectileLauncher", "SetProjectileVar");

	Params::BaseProjectileLauncher_SetProjectileVar Parms{};

	Parms.VarName = VarName;
	Parms.Value = Value;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Projectile.BaseProjectileLauncher.GetAmmo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UBaseProjectileLauncher::GetAmmo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectileLauncher", "GetAmmo");

	Params::BaseProjectileLauncher_GetAmmo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Projectile.BaseProjectileLauncher.GetLaunchDirection
// (Native, Event, Protected, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UBaseProjectileLauncher::GetLaunchDirection() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectileLauncher", "GetLaunchDirection");

	Params::BaseProjectileLauncher_GetLaunchDirection Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Projectile.BaseProjectileLauncher.GetLaunchDirectionAtViewAndThrowPowerRatio
// (Native, Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// struct FRotator                         ViewRotation                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   ThrowPowerRatio                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UBaseProjectileLauncher::GetLaunchDirectionAtViewAndThrowPowerRatio(const struct FRotator& ViewRotation, float ThrowPowerRatio) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectileLauncher", "GetLaunchDirectionAtViewAndThrowPowerRatio");

	Params::BaseProjectileLauncher_GetLaunchDirectionAtViewAndThrowPowerRatio Parms{};

	Parms.ViewRotation = std::move(ViewRotation);
	Parms.ThrowPowerRatio = ThrowPowerRatio;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Projectile.BaseProjectileLauncher.GetLaunchPosition
// (Native, Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UBaseProjectileLauncher::GetLaunchPosition() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectileLauncher", "GetLaunchPosition");

	Params::BaseProjectileLauncher_GetLaunchPosition Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Projectile.BaseProjectileLauncher.GetLaunchSpeed
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UBaseProjectileLauncher::GetLaunchSpeed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectileLauncher", "GetLaunchSpeed");

	Params::BaseProjectileLauncher_GetLaunchSpeed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Projectile.BaseProjectileLauncher.GetLaunchSpeedAtThrowPowerRatio
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// float                                   ThrowPowerRatio                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UBaseProjectileLauncher::GetLaunchSpeedAtThrowPowerRatio(float ThrowPowerRatio) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectileLauncher", "GetLaunchSpeedAtThrowPowerRatio");

	Params::BaseProjectileLauncher_GetLaunchSpeedAtThrowPowerRatio Parms{};

	Parms.ThrowPowerRatio = ThrowPowerRatio;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Projectile.BaseProjectileLauncher.GetOwningPawn
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class APawn*                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APawn* UBaseProjectileLauncher::GetOwningPawn() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectileLauncher", "GetOwningPawn");

	Params::BaseProjectileLauncher_GetOwningPawn Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Projectile.BaseProjectileLauncher.GetProjectileToLaunch
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// class ABaseProjectile*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ABaseProjectile* UBaseProjectileLauncher::GetProjectileToLaunch() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectileLauncher", "GetProjectileToLaunch");

	Params::BaseProjectileLauncher_GetProjectileToLaunch Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Projectile.BaseProjectileLauncher.HasAuthority
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBaseProjectileLauncher::HasAuthority() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectileLauncher", "HasAuthority");

	Params::BaseProjectileLauncher_HasAuthority Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Projectile.BaseProjectileLauncher.HasProjectile
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBaseProjectileLauncher::HasProjectile() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectileLauncher", "HasProjectile");

	Params::BaseProjectileLauncher_HasProjectile Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Projectile.BaseProjectileLauncher.IsAmmoFull
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBaseProjectileLauncher::IsAmmoFull() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectileLauncher", "IsAmmoFull");

	Params::BaseProjectileLauncher_IsAmmoFull Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Projectile.BaseProjectileLauncher.IsLocallyControlled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBaseProjectileLauncher::IsLocallyControlled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectileLauncher", "IsLocallyControlled");

	Params::BaseProjectileLauncher_IsLocallyControlled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Projectile.DBDProjectileMovementComponent.AddComponentToSweep
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              Component                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDProjectileMovementComponent::AddComponentToSweep(class UPrimitiveComponent* Component)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDProjectileMovementComponent", "AddComponentToSweep");

	Params::DBDProjectileMovementComponent_AddComponentToSweep Parms{};

	Parms.Component = Component;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// DelegateFunction Projectile.DBDProjectileMovementComponent.OnComponentToSweepCollisionBP__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              PrimitiveComponent                                     (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       HitResult                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UDBDProjectileMovementComponent::OnComponentToSweepCollisionBP__DelegateSignature(class UPrimitiveComponent* PrimitiveComponent, const struct FHitResult& HitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDProjectileMovementComponent", "OnComponentToSweepCollisionBP__DelegateSignature");

	Params::DBDProjectileMovementComponent_OnComponentToSweepCollisionBP__DelegateSignature Parms{};

	Parms.PrimitiveComponent = PrimitiveComponent;
	Parms.HitResult = std::move(HitResult);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Projectile.DBDProjectileMovementComponent.GetPreviousLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FVector                    ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const struct FVector UDBDProjectileMovementComponent::GetPreviousLocation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDProjectileMovementComponent", "GetPreviousLocation");

	Params::DBDProjectileMovementComponent_GetPreviousLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Projectile.BaseProjectile.Authority_TryDetectCollision
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// struct FImpactInfo                      ImpactInfo                                             (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    Force                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ABaseProjectile::Authority_TryDetectCollision(const struct FImpactInfo& ImpactInfo, bool Force)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectile", "Authority_TryDetectCollision");

	Params::BaseProjectile_Authority_TryDetectCollision Parms{};

	Parms.ImpactInfo = std::move(ImpactInfo);
	Parms.Force = Force;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Projectile.BaseProjectile.IsValidImpactDetection
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// struct FImpactInfo                      ImpactInfo                                             (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ABaseProjectile::IsValidImpactDetection(const struct FImpactInfo& ImpactInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectile", "IsValidImpactDetection");

	Params::BaseProjectile_IsValidImpactDetection Parms{};

	Parms.ImpactInfo = std::move(ImpactInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Projectile.BaseProjectile.IsValidPlayerDetection
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// struct FImpactInfo                      ImpactInfo                                             (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ABaseProjectile::IsValidPlayerDetection(const struct FImpactInfo& ImpactInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectile", "IsValidPlayerDetection");

	Params::BaseProjectile_IsValidPlayerDetection Parms{};

	Parms.ImpactInfo = std::move(ImpactInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Projectile.BaseProjectile.Local_OnPlayerDetected
// (Final, Native, Protected, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FImpactInfo                      ImpactInfo                                             (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FVector                          ProjectileLocation                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ABaseProjectile::Local_OnPlayerDetected(const struct FImpactInfo& ImpactInfo, const struct FVector& ProjectileLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectile", "Local_OnPlayerDetected");

	Params::BaseProjectile_Local_OnPlayerDetected Parms{};

	Parms.ImpactInfo = std::move(ImpactInfo);
	Parms.ProjectileLocation = std::move(ProjectileLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Projectile.BaseProjectile.Local_SweepImpactCollision
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Start                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          End                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         ColliderRotation                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FHitResult                       OutHit                                                 (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ABaseProjectile::Local_SweepImpactCollision(const struct FVector& Start, const struct FVector& End, const struct FRotator& ColliderRotation, struct FHitResult* OutHit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectile", "Local_SweepImpactCollision");

	Params::BaseProjectile_Local_SweepImpactCollision Parms{};

	Parms.Start = std::move(Start);
	Parms.End = std::move(End);
	Parms.ColliderRotation = std::move(ColliderRotation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutHit != nullptr)
		*OutHit = std::move(Parms.OutHit);

	return Parms.ReturnValue;
}


// Function Projectile.BaseProjectile.Local_TryDetectCollision
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FImpactInfo                      ImpactInfo                                             (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    Force                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ABaseProjectile::Local_TryDetectCollision(const struct FImpactInfo& ImpactInfo, bool Force)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectile", "Local_TryDetectCollision");

	Params::BaseProjectile_Local_TryDetectCollision Parms{};

	Parms.ImpactInfo = std::move(ImpactInfo);
	Parms.Force = Force;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Projectile.BaseProjectile.OnDetectCollision
// (Event, Protected, BlueprintEvent)
// Parameters:
// struct FImpactInfo                      ImpactInfo                                             (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ABaseProjectile::OnDetectCollision(const struct FImpactInfo& ImpactInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectile", "OnDetectCollision");

	Params::BaseProjectile_OnDetectCollision Parms{};

	Parms.ImpactInfo = std::move(ImpactInfo);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Projectile.BaseProjectile.OnDetectPlayer
// (Event, Protected, BlueprintEvent)
// Parameters:
// struct FImpactInfo                      ImpactInfo                                             (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ABaseProjectile::OnDetectPlayer(const struct FImpactInfo& ImpactInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectile", "OnDetectPlayer");

	Params::BaseProjectile_OnDetectPlayer Parms{};

	Parms.ImpactInfo = std::move(ImpactInfo);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Projectile.BaseProjectile.OnLaunch
// (Event, Protected, BlueprintEvent)
// Parameters:
// struct FLaunchInfo                      LaunchInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    HasImpactOnLaunch                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseProjectile::OnLaunch(const struct FLaunchInfo& LaunchInfo, bool HasImpactOnLaunch)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectile", "OnLaunch");

	Params::BaseProjectile_OnLaunch Parms{};

	Parms.LaunchInfo = std::move(LaunchInfo);
	Parms.HasImpactOnLaunch = HasImpactOnLaunch;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Projectile.BaseProjectile.OnSetActive
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    Active                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseProjectile::OnSetActive(const bool Active)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectile", "OnSetActive");

	Params::BaseProjectile_OnSetActive Parms{};

	Parms.Active = Active;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Projectile.BaseProjectile.GetAddLauncherVeloctyFactor
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ABaseProjectile::GetAddLauncherVeloctyFactor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectile", "GetAddLauncherVeloctyFactor");

	Params::BaseProjectile_GetAddLauncherVeloctyFactor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Projectile.BaseProjectile.GetImpactPrimitiveComponent
// (Native, Event, Protected, BlueprintEvent, Const)
// Parameters:
// class UPrimitiveComponent*              ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPrimitiveComponent* ABaseProjectile::GetImpactPrimitiveComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectile", "GetImpactPrimitiveComponent");

	Params::BaseProjectile_GetImpactPrimitiveComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Projectile.BaseProjectile.GetLauncher
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UBaseProjectileLauncher*          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UBaseProjectileLauncher* ABaseProjectile::GetLauncher() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectile", "GetLauncher");

	Params::BaseProjectile_GetLauncher Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Projectile.BaseProjectile.IsOwningPawnLocallyControlled
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ABaseProjectile::IsOwningPawnLocallyControlled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectile", "IsOwningPawnLocallyControlled");

	Params::BaseProjectile_IsOwningPawnLocallyControlled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Projectile.BaseProjectile.SphereTraceSingle
// (Final, Native, Protected, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          Start                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          End                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USphereComponent*                 Sphere                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       OutHitResult                                           (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ABaseProjectile::SphereTraceSingle(const struct FVector& Start, const struct FVector& End, class USphereComponent* Sphere, struct FHitResult* OutHitResult) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectile", "SphereTraceSingle");

	Params::BaseProjectile_SphereTraceSingle Parms{};

	Parms.Start = std::move(Start);
	Parms.End = std::move(End);
	Parms.Sphere = Sphere;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutHitResult != nullptr)
		*OutHitResult = std::move(Parms.OutHitResult);

	return Parms.ReturnValue;
}


// Function Projectile.AuthoritativePoolProjectileProviderAdapter.Init
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAuthoritativeActorPoolComponent* Pool                                                   (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAuthoritativePoolProjectileProviderAdapter::Init(class UAuthoritativeActorPoolComponent* Pool)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuthoritativePoolProjectileProviderAdapter", "Init");

	Params::AuthoritativePoolProjectileProviderAdapter_Init Parms{};

	Parms.Pool = Pool;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Projectile.BaseProjectileReplicationComponent.Client_LaunchRefusedByServer
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class ABaseProjectile*                  Projectile                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBaseProjectileReplicationComponent::Client_LaunchRefusedByServer(class ABaseProjectile* Projectile)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectileReplicationComponent", "Client_LaunchRefusedByServer");

	Params::BaseProjectileReplicationComponent_Client_LaunchRefusedByServer Parms{};

	Parms.Projectile = Projectile;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Projectile.BaseProjectileReplicationComponent.Client_ReceiveDetectPlayerValidation
// (Final, Net, NetReliable, Native, Event, Private, NetClient)
// Parameters:
// class ABaseProjectile*                  Projectile                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Success                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBaseProjectileReplicationComponent::Client_ReceiveDetectPlayerValidation(class ABaseProjectile* Projectile, bool Success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectileReplicationComponent", "Client_ReceiveDetectPlayerValidation");

	Params::BaseProjectileReplicationComponent_Client_ReceiveDetectPlayerValidation Parms{};

	Parms.Projectile = Projectile;
	Parms.Success = Success;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Projectile.BaseProjectileReplicationComponent.Multicast_DetectImpact
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// class ABaseProjectile*                  Projectile                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FImpactInfo                      ImpactInfo                                             (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UBaseProjectileReplicationComponent::Multicast_DetectImpact(class ABaseProjectile* Projectile, const struct FImpactInfo& ImpactInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectileReplicationComponent", "Multicast_DetectImpact");

	Params::BaseProjectileReplicationComponent_Multicast_DetectImpact Parms{};

	Parms.Projectile = Projectile;
	Parms.ImpactInfo = std::move(ImpactInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Projectile.BaseProjectileReplicationComponent.Multicast_DetectPlayer
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// class ABaseProjectile*                  Projectile                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FImpactInfo                      ImpactInfo                                             (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UBaseProjectileReplicationComponent::Multicast_DetectPlayer(class ABaseProjectile* Projectile, const struct FImpactInfo& ImpactInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectileReplicationComponent", "Multicast_DetectPlayer");

	Params::BaseProjectileReplicationComponent_Multicast_DetectPlayer Parms{};

	Parms.Projectile = Projectile;
	Parms.ImpactInfo = std::move(ImpactInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Projectile.BaseProjectileReplicationComponent.Multicast_OnLaunch
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// class ABaseProjectile*                  Projectile                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLaunchInfo                      LaunchInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UBaseProjectileReplicationComponent::Multicast_OnLaunch(class ABaseProjectile* Projectile, const struct FLaunchInfo& LaunchInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectileReplicationComponent", "Multicast_OnLaunch");

	Params::BaseProjectileReplicationComponent_Multicast_OnLaunch Parms{};

	Parms.Projectile = Projectile;
	Parms.LaunchInfo = std::move(LaunchInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Projectile.BaseProjectileReplicationComponent.Multicast_OnLaunchWithImpact
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// class ABaseProjectile*                  Projectile                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLaunchInfo                      LaunchInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FImpactInfo                      ImpactInfo                                             (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UBaseProjectileReplicationComponent::Multicast_OnLaunchWithImpact(class ABaseProjectile* Projectile, const struct FLaunchInfo& LaunchInfo, const struct FImpactInfo& ImpactInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectileReplicationComponent", "Multicast_OnLaunchWithImpact");

	Params::BaseProjectileReplicationComponent_Multicast_OnLaunchWithImpact Parms{};

	Parms.Projectile = Projectile;
	Parms.LaunchInfo = std::move(LaunchInfo);
	Parms.ImpactInfo = std::move(ImpactInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Projectile.BaseProjectileReplicationComponent.Multicast_SendAuthorityDetectPlayer
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// class ABaseProjectile*                  Projectile                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FImpactInfo                      ImpactInfo                                             (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UBaseProjectileReplicationComponent::Multicast_SendAuthorityDetectPlayer(class ABaseProjectile* Projectile, const struct FImpactInfo& ImpactInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectileReplicationComponent", "Multicast_SendAuthorityDetectPlayer");

	Params::BaseProjectileReplicationComponent_Multicast_SendAuthorityDetectPlayer Parms{};

	Parms.Projectile = Projectile;
	Parms.ImpactInfo = std::move(ImpactInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Projectile.BaseProjectileReplicationComponent.Server_TryDetectPlayer
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// class ABaseProjectile*                  Projectile                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FImpactInfo                      ImpactInfo                                             (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FVector_NetQuantize100           ProjectileLocation                                     (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector_NetQuantize10            ProjectileRotation                                     (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TargetLocationTimestamp                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBaseProjectileReplicationComponent::Server_TryDetectPlayer(class ABaseProjectile* Projectile, const struct FImpactInfo& ImpactInfo, const struct FVector_NetQuantize100& ProjectileLocation, const struct FVector_NetQuantize10& ProjectileRotation, const float TargetLocationTimestamp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectileReplicationComponent", "Server_TryDetectPlayer");

	Params::BaseProjectileReplicationComponent_Server_TryDetectPlayer Parms{};

	Parms.Projectile = Projectile;
	Parms.ImpactInfo = std::move(ImpactInfo);
	Parms.ProjectileLocation = std::move(ProjectileLocation);
	Parms.ProjectileRotation = std::move(ProjectileRotation);
	Parms.TargetLocationTimestamp = TargetLocationTimestamp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}

}

