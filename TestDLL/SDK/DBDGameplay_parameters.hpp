#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: DBDGameplay

#include "Basic.hpp"

#include "Engine_structs.hpp"
#include "DBDGameplay_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "DeadByDaylight_structs.hpp"
#include "GameplayTags_structs.hpp"
#include "DBDSharedTypes_structs.hpp"


namespace SDK::Params
{

// Function DBDGameplay.DebugIndicator.SetColor
// 0x0010 (0x0010 - 0x0000)
struct DebugIndicator_SetColor final
{
public:
	struct FLinearColor                           Color;                                             // 0x0000(0x0010)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DebugIndicator_SetColor) == 0x000004, "Wrong alignment on DebugIndicator_SetColor");
static_assert(sizeof(DebugIndicator_SetColor) == 0x000010, "Wrong size on DebugIndicator_SetColor");
static_assert(offsetof(DebugIndicator_SetColor, Color) == 0x000000, "Member 'DebugIndicator_SetColor::Color' has a wrong offset!");

// Function DBDGameplay.DebugIndicator.SetVisible
// 0x0001 (0x0001 - 0x0000)
struct DebugIndicator_SetVisible final
{
public:
	bool                                          Visible;                                           // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DebugIndicator_SetVisible) == 0x000001, "Wrong alignment on DebugIndicator_SetVisible");
static_assert(sizeof(DebugIndicator_SetVisible) == 0x000001, "Wrong size on DebugIndicator_SetVisible");
static_assert(offsetof(DebugIndicator_SetVisible, Visible) == 0x000000, "Member 'DebugIndicator_SetVisible::Visible' has a wrong offset!");

// Function DBDGameplay.BaseHusk.Cosmetic_InitializeSkeletalMesh
// 0x0008 (0x0008 - 0x0000)
struct BaseHusk_Cosmetic_InitializeSkeletalMesh final
{
public:
	class USkeletalMeshComponent*                 Mesh;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseHusk_Cosmetic_InitializeSkeletalMesh) == 0x000008, "Wrong alignment on BaseHusk_Cosmetic_InitializeSkeletalMesh");
static_assert(sizeof(BaseHusk_Cosmetic_InitializeSkeletalMesh) == 0x000008, "Wrong size on BaseHusk_Cosmetic_InitializeSkeletalMesh");
static_assert(offsetof(BaseHusk_Cosmetic_InitializeSkeletalMesh, Mesh) == 0x000000, "Member 'BaseHusk_Cosmetic_InitializeSkeletalMesh::Mesh' has a wrong offset!");

// Function DBDGameplay.BaseHusk.InitializeHusk
// 0x0018 (0x0018 - 0x0000)
struct BaseHusk_InitializeHusk final
{
public:
	class UCustomizedSkeletalMesh*                CustomizedSkeletalMeshToCopy;                      // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 SkeletalMeshToCopy;                                // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CharacterIdOverride;                               // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BaseHusk_InitializeHusk) == 0x000008, "Wrong alignment on BaseHusk_InitializeHusk");
static_assert(sizeof(BaseHusk_InitializeHusk) == 0x000018, "Wrong size on BaseHusk_InitializeHusk");
static_assert(offsetof(BaseHusk_InitializeHusk, CustomizedSkeletalMeshToCopy) == 0x000000, "Member 'BaseHusk_InitializeHusk::CustomizedSkeletalMeshToCopy' has a wrong offset!");
static_assert(offsetof(BaseHusk_InitializeHusk, SkeletalMeshToCopy) == 0x000008, "Member 'BaseHusk_InitializeHusk::SkeletalMeshToCopy' has a wrong offset!");
static_assert(offsetof(BaseHusk_InitializeHusk, CharacterIdOverride) == 0x000010, "Member 'BaseHusk_InitializeHusk::CharacterIdOverride' has a wrong offset!");

// Function DBDGameplay.BaseHusk.SetHuskVisibility
// 0x0001 (0x0001 - 0x0000)
struct BaseHusk_SetHuskVisibility final
{
public:
	bool                                          Visible;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseHusk_SetHuskVisibility) == 0x000001, "Wrong alignment on BaseHusk_SetHuskVisibility");
static_assert(sizeof(BaseHusk_SetHuskVisibility) == 0x000001, "Wrong size on BaseHusk_SetHuskVisibility");
static_assert(offsetof(BaseHusk_SetHuskVisibility, Visible) == 0x000000, "Member 'BaseHusk_SetHuskVisibility::Visible' has a wrong offset!");

// Function DBDGameplay.BaseHusk.SetScalarParameterOnAllChildrenMeshes
// 0x0018 (0x0018 - 0x0000)
struct BaseHusk_SetScalarParameterOnAllChildrenMeshes final
{
public:
	class FName                                   ParameterName;                                     // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 Mesh;                                              // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseHusk_SetScalarParameterOnAllChildrenMeshes) == 0x000008, "Wrong alignment on BaseHusk_SetScalarParameterOnAllChildrenMeshes");
static_assert(sizeof(BaseHusk_SetScalarParameterOnAllChildrenMeshes) == 0x000018, "Wrong size on BaseHusk_SetScalarParameterOnAllChildrenMeshes");
static_assert(offsetof(BaseHusk_SetScalarParameterOnAllChildrenMeshes, ParameterName) == 0x000000, "Member 'BaseHusk_SetScalarParameterOnAllChildrenMeshes::ParameterName' has a wrong offset!");
static_assert(offsetof(BaseHusk_SetScalarParameterOnAllChildrenMeshes, Value) == 0x00000C, "Member 'BaseHusk_SetScalarParameterOnAllChildrenMeshes::Value' has a wrong offset!");
static_assert(offsetof(BaseHusk_SetScalarParameterOnAllChildrenMeshes, Mesh) == 0x000010, "Member 'BaseHusk_SetScalarParameterOnAllChildrenMeshes::Mesh' has a wrong offset!");

// Function DBDGameplay.BaseHusk.GetCopiedCustomizedSkeletalMesh
// 0x0008 (0x0008 - 0x0000)
struct BaseHusk_GetCopiedCustomizedSkeletalMesh final
{
public:
	const class UCustomizedSkeletalMesh*          ReturnValue;                                       // 0x0000(0x0008)(ConstParm, ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseHusk_GetCopiedCustomizedSkeletalMesh) == 0x000008, "Wrong alignment on BaseHusk_GetCopiedCustomizedSkeletalMesh");
static_assert(sizeof(BaseHusk_GetCopiedCustomizedSkeletalMesh) == 0x000008, "Wrong size on BaseHusk_GetCopiedCustomizedSkeletalMesh");
static_assert(offsetof(BaseHusk_GetCopiedCustomizedSkeletalMesh, ReturnValue) == 0x000000, "Member 'BaseHusk_GetCopiedCustomizedSkeletalMesh::ReturnValue' has a wrong offset!");

// Function DBDGameplay.BlindAndDeafenRangedExplosiveActorEffect.Authority_TryToBlind
// 0x0018 (0x0018 - 0x0000)
struct BlindAndDeafenRangedExplosiveActorEffect_Authority_TryToBlind final
{
public:
	class UBlindableBaseComponent*                BlindableComponent;                                // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 EffectorActor;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BlindAndDeafenRangedExplosiveActorEffect_Authority_TryToBlind) == 0x000008, "Wrong alignment on BlindAndDeafenRangedExplosiveActorEffect_Authority_TryToBlind");
static_assert(sizeof(BlindAndDeafenRangedExplosiveActorEffect_Authority_TryToBlind) == 0x000018, "Wrong size on BlindAndDeafenRangedExplosiveActorEffect_Authority_TryToBlind");
static_assert(offsetof(BlindAndDeafenRangedExplosiveActorEffect_Authority_TryToBlind, BlindableComponent) == 0x000000, "Member 'BlindAndDeafenRangedExplosiveActorEffect_Authority_TryToBlind::BlindableComponent' has a wrong offset!");
static_assert(offsetof(BlindAndDeafenRangedExplosiveActorEffect_Authority_TryToBlind, EffectorActor) == 0x000008, "Member 'BlindAndDeafenRangedExplosiveActorEffect_Authority_TryToBlind::EffectorActor' has a wrong offset!");
static_assert(offsetof(BlindAndDeafenRangedExplosiveActorEffect_Authority_TryToBlind, ReturnValue) == 0x000010, "Member 'BlindAndDeafenRangedExplosiveActorEffect_Authority_TryToBlind::ReturnValue' has a wrong offset!");

// Function DBDGameplay.BlindAndDeafenRangedExplosiveActorEffect.Authority_TryToDeafen
// 0x0018 (0x0018 - 0x0000)
struct BlindAndDeafenRangedExplosiveActorEffect_Authority_TryToDeafen final
{
public:
	const class ADBDPlayer*                       Player;                                            // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAudioFXComponent*                      AudioFXComponent;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BlindAndDeafenRangedExplosiveActorEffect_Authority_TryToDeafen) == 0x000008, "Wrong alignment on BlindAndDeafenRangedExplosiveActorEffect_Authority_TryToDeafen");
static_assert(sizeof(BlindAndDeafenRangedExplosiveActorEffect_Authority_TryToDeafen) == 0x000018, "Wrong size on BlindAndDeafenRangedExplosiveActorEffect_Authority_TryToDeafen");
static_assert(offsetof(BlindAndDeafenRangedExplosiveActorEffect_Authority_TryToDeafen, Player) == 0x000000, "Member 'BlindAndDeafenRangedExplosiveActorEffect_Authority_TryToDeafen::Player' has a wrong offset!");
static_assert(offsetof(BlindAndDeafenRangedExplosiveActorEffect_Authority_TryToDeafen, AudioFXComponent) == 0x000008, "Member 'BlindAndDeafenRangedExplosiveActorEffect_Authority_TryToDeafen::AudioFXComponent' has a wrong offset!");
static_assert(offsetof(BlindAndDeafenRangedExplosiveActorEffect_Authority_TryToDeafen, ReturnValue) == 0x000010, "Member 'BlindAndDeafenRangedExplosiveActorEffect_Authority_TryToDeafen::ReturnValue' has a wrong offset!");

// Function DBDGameplay.BlindAndDeafenRangedExplosiveActorEffect.GetBlindnessEffectDuration
// 0x0010 (0x0010 - 0x0000)
struct BlindAndDeafenRangedExplosiveActorEffect_GetBlindnessEffectDuration final
{
public:
	const class AActor*                           Player;                                            // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BlindAndDeafenRangedExplosiveActorEffect_GetBlindnessEffectDuration) == 0x000008, "Wrong alignment on BlindAndDeafenRangedExplosiveActorEffect_GetBlindnessEffectDuration");
static_assert(sizeof(BlindAndDeafenRangedExplosiveActorEffect_GetBlindnessEffectDuration) == 0x000010, "Wrong size on BlindAndDeafenRangedExplosiveActorEffect_GetBlindnessEffectDuration");
static_assert(offsetof(BlindAndDeafenRangedExplosiveActorEffect_GetBlindnessEffectDuration, Player) == 0x000000, "Member 'BlindAndDeafenRangedExplosiveActorEffect_GetBlindnessEffectDuration::Player' has a wrong offset!");
static_assert(offsetof(BlindAndDeafenRangedExplosiveActorEffect_GetBlindnessEffectDuration, ReturnValue) == 0x000008, "Member 'BlindAndDeafenRangedExplosiveActorEffect_GetBlindnessEffectDuration::ReturnValue' has a wrong offset!");

// Function DBDGameplay.BlindAndDeafenRangedExplosiveActorEffect.GetDeafnessEffectDuration
// 0x0010 (0x0010 - 0x0000)
struct BlindAndDeafenRangedExplosiveActorEffect_GetDeafnessEffectDuration final
{
public:
	const class AActor*                           Player;                                            // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BlindAndDeafenRangedExplosiveActorEffect_GetDeafnessEffectDuration) == 0x000008, "Wrong alignment on BlindAndDeafenRangedExplosiveActorEffect_GetDeafnessEffectDuration");
static_assert(sizeof(BlindAndDeafenRangedExplosiveActorEffect_GetDeafnessEffectDuration) == 0x000010, "Wrong size on BlindAndDeafenRangedExplosiveActorEffect_GetDeafnessEffectDuration");
static_assert(offsetof(BlindAndDeafenRangedExplosiveActorEffect_GetDeafnessEffectDuration, Player) == 0x000000, "Member 'BlindAndDeafenRangedExplosiveActorEffect_GetDeafnessEffectDuration::Player' has a wrong offset!");
static_assert(offsetof(BlindAndDeafenRangedExplosiveActorEffect_GetDeafnessEffectDuration, ReturnValue) == 0x000008, "Member 'BlindAndDeafenRangedExplosiveActorEffect_GetDeafnessEffectDuration::ReturnValue' has a wrong offset!");

// Function DBDGameplay.CageHook.Cosmetic_DisplayCage
// 0x0001 (0x0001 - 0x0000)
struct CageHook_Cosmetic_DisplayCage final
{
public:
	bool                                          Display;                                           // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CageHook_Cosmetic_DisplayCage) == 0x000001, "Wrong alignment on CageHook_Cosmetic_DisplayCage");
static_assert(sizeof(CageHook_Cosmetic_DisplayCage) == 0x000001, "Wrong size on CageHook_Cosmetic_DisplayCage");
static_assert(offsetof(CageHook_Cosmetic_DisplayCage, Display) == 0x000000, "Member 'CageHook_Cosmetic_DisplayCage::Display' has a wrong offset!");

// Function DBDGameplay.CageHook.Multicast_Relocate
// 0x0038 (0x0038 - 0x0000)
struct CageHook_Multicast_Relocate final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x0018)(ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0018(0x0018)(ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          IsAnticampRelocation;                              // 0x0030(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CageHook_Multicast_Relocate) == 0x000008, "Wrong alignment on CageHook_Multicast_Relocate");
static_assert(sizeof(CageHook_Multicast_Relocate) == 0x000038, "Wrong size on CageHook_Multicast_Relocate");
static_assert(offsetof(CageHook_Multicast_Relocate, Location) == 0x000000, "Member 'CageHook_Multicast_Relocate::Location' has a wrong offset!");
static_assert(offsetof(CageHook_Multicast_Relocate, Rotation) == 0x000018, "Member 'CageHook_Multicast_Relocate::Rotation' has a wrong offset!");
static_assert(offsetof(CageHook_Multicast_Relocate, IsAnticampRelocation) == 0x000030, "Member 'CageHook_Multicast_Relocate::IsAnticampRelocation' has a wrong offset!");

// Function DBDGameplay.CageHook.Multicast_SendSurvivorToCage
// 0x0010 (0x0010 - 0x0000)
struct CageHook_Multicast_SendSurvivorToCage final
{
public:
	class ACamperPlayer*                          Survivor;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ASlasherPlayer*                         KillerInstigator;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CageHook_Multicast_SendSurvivorToCage) == 0x000008, "Wrong alignment on CageHook_Multicast_SendSurvivorToCage");
static_assert(sizeof(CageHook_Multicast_SendSurvivorToCage) == 0x000010, "Wrong size on CageHook_Multicast_SendSurvivorToCage");
static_assert(offsetof(CageHook_Multicast_SendSurvivorToCage, Survivor) == 0x000000, "Member 'CageHook_Multicast_SendSurvivorToCage::Survivor' has a wrong offset!");
static_assert(offsetof(CageHook_Multicast_SendSurvivorToCage, KillerInstigator) == 0x000008, "Member 'CageHook_Multicast_SendSurvivorToCage::KillerInstigator' has a wrong offset!");

// Function DBDGameplay.CageHook.Multicast_SendSurvivorToCageImmediately
// 0x0040 (0x0040 - 0x0000)
struct CageHook_Multicast_SendSurvivorToCageImmediately final
{
public:
	class ACamperPlayer*                          Survivor;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ASlasherPlayer*                         KillerInstigator;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0010(0x0018)(ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0028(0x0018)(ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(CageHook_Multicast_SendSurvivorToCageImmediately) == 0x000008, "Wrong alignment on CageHook_Multicast_SendSurvivorToCageImmediately");
static_assert(sizeof(CageHook_Multicast_SendSurvivorToCageImmediately) == 0x000040, "Wrong size on CageHook_Multicast_SendSurvivorToCageImmediately");
static_assert(offsetof(CageHook_Multicast_SendSurvivorToCageImmediately, Survivor) == 0x000000, "Member 'CageHook_Multicast_SendSurvivorToCageImmediately::Survivor' has a wrong offset!");
static_assert(offsetof(CageHook_Multicast_SendSurvivorToCageImmediately, KillerInstigator) == 0x000008, "Member 'CageHook_Multicast_SendSurvivorToCageImmediately::KillerInstigator' has a wrong offset!");
static_assert(offsetof(CageHook_Multicast_SendSurvivorToCageImmediately, Location) == 0x000010, "Member 'CageHook_Multicast_SendSurvivorToCageImmediately::Location' has a wrong offset!");
static_assert(offsetof(CageHook_Multicast_SendSurvivorToCageImmediately, Rotation) == 0x000028, "Member 'CageHook_Multicast_SendSurvivorToCageImmediately::Rotation' has a wrong offset!");

// Function DBDGameplay.CageHook.PlayerOverlapZoneBeginOverlap
// 0x0110 (0x0110 - 0x0000)
struct CageHook_PlayerOverlapZoneBeginOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x00F0)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(CageHook_PlayerOverlapZoneBeginOverlap) == 0x000008, "Wrong alignment on CageHook_PlayerOverlapZoneBeginOverlap");
static_assert(sizeof(CageHook_PlayerOverlapZoneBeginOverlap) == 0x000110, "Wrong size on CageHook_PlayerOverlapZoneBeginOverlap");
static_assert(offsetof(CageHook_PlayerOverlapZoneBeginOverlap, OverlappedComponent) == 0x000000, "Member 'CageHook_PlayerOverlapZoneBeginOverlap::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(CageHook_PlayerOverlapZoneBeginOverlap, OtherActor) == 0x000008, "Member 'CageHook_PlayerOverlapZoneBeginOverlap::OtherActor' has a wrong offset!");
static_assert(offsetof(CageHook_PlayerOverlapZoneBeginOverlap, OtherComp) == 0x000010, "Member 'CageHook_PlayerOverlapZoneBeginOverlap::OtherComp' has a wrong offset!");
static_assert(offsetof(CageHook_PlayerOverlapZoneBeginOverlap, OtherBodyIndex) == 0x000018, "Member 'CageHook_PlayerOverlapZoneBeginOverlap::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(CageHook_PlayerOverlapZoneBeginOverlap, bFromSweep) == 0x00001C, "Member 'CageHook_PlayerOverlapZoneBeginOverlap::bFromSweep' has a wrong offset!");
static_assert(offsetof(CageHook_PlayerOverlapZoneBeginOverlap, SweepResult) == 0x000020, "Member 'CageHook_PlayerOverlapZoneBeginOverlap::SweepResult' has a wrong offset!");

// Function DBDGameplay.CageHook.PlayerOverlapZoneEndOverlap
// 0x0020 (0x0020 - 0x0000)
struct CageHook_PlayerOverlapZoneEndOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CageHook_PlayerOverlapZoneEndOverlap) == 0x000008, "Wrong alignment on CageHook_PlayerOverlapZoneEndOverlap");
static_assert(sizeof(CageHook_PlayerOverlapZoneEndOverlap) == 0x000020, "Wrong size on CageHook_PlayerOverlapZoneEndOverlap");
static_assert(offsetof(CageHook_PlayerOverlapZoneEndOverlap, OverlappedComponent) == 0x000000, "Member 'CageHook_PlayerOverlapZoneEndOverlap::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(CageHook_PlayerOverlapZoneEndOverlap, OtherActor) == 0x000008, "Member 'CageHook_PlayerOverlapZoneEndOverlap::OtherActor' has a wrong offset!");
static_assert(offsetof(CageHook_PlayerOverlapZoneEndOverlap, OtherComp) == 0x000010, "Member 'CageHook_PlayerOverlapZoneEndOverlap::OtherComp' has a wrong offset!");
static_assert(offsetof(CageHook_PlayerOverlapZoneEndOverlap, OtherBodyIndex) == 0x000018, "Member 'CageHook_PlayerOverlapZoneEndOverlap::OtherBodyIndex' has a wrong offset!");

// Function DBDGameplay.CageHook.GetCagedSurvivor
// 0x0008 (0x0008 - 0x0000)
struct CageHook_GetCagedSurvivor final
{
public:
	class ACamperPlayer*                          ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CageHook_GetCagedSurvivor) == 0x000008, "Wrong alignment on CageHook_GetCagedSurvivor");
static_assert(sizeof(CageHook_GetCagedSurvivor) == 0x000008, "Wrong size on CageHook_GetCagedSurvivor");
static_assert(offsetof(CageHook_GetCagedSurvivor, ReturnValue) == 0x000000, "Member 'CageHook_GetCagedSurvivor::ReturnValue' has a wrong offset!");

// Function DBDGameplay.CageHook.GetMontagePlayer
// 0x0008 (0x0008 - 0x0000)
struct CageHook_GetMontagePlayer final
{
public:
	class UMontagePlayer*                         ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CageHook_GetMontagePlayer) == 0x000008, "Wrong alignment on CageHook_GetMontagePlayer");
static_assert(sizeof(CageHook_GetMontagePlayer) == 0x000008, "Wrong size on CageHook_GetMontagePlayer");
static_assert(offsetof(CageHook_GetMontagePlayer, ReturnValue) == 0x000000, "Member 'CageHook_GetMontagePlayer::ReturnValue' has a wrong offset!");

// Function DBDGameplay.CageHook.GetRescuerSnapPosition
// 0x0018 (0x0018 - 0x0000)
struct CageHook_GetRescuerSnapPosition final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CageHook_GetRescuerSnapPosition) == 0x000008, "Wrong alignment on CageHook_GetRescuerSnapPosition");
static_assert(sizeof(CageHook_GetRescuerSnapPosition) == 0x000018, "Wrong size on CageHook_GetRescuerSnapPosition");
static_assert(offsetof(CageHook_GetRescuerSnapPosition, ReturnValue) == 0x000000, "Member 'CageHook_GetRescuerSnapPosition::ReturnValue' has a wrong offset!");

// Function DBDGameplay.BaseActorAttackableComponent.HitWithProjectile
// 0x0008 (0x0008 - 0x0000)
struct BaseActorAttackableComponent_HitWithProjectile final
{
public:
	class ABaseProjectile*                        Projectile;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseActorAttackableComponent_HitWithProjectile) == 0x000008, "Wrong alignment on BaseActorAttackableComponent_HitWithProjectile");
static_assert(sizeof(BaseActorAttackableComponent_HitWithProjectile) == 0x000008, "Wrong size on BaseActorAttackableComponent_HitWithProjectile");
static_assert(offsetof(BaseActorAttackableComponent_HitWithProjectile, Projectile) == 0x000000, "Member 'BaseActorAttackableComponent_HitWithProjectile::Projectile' has a wrong offset!");

// Function DBDGameplay.CageRescueInteraction.GetRescuerSnapPosition
// 0x0018 (0x0018 - 0x0000)
struct CageRescueInteraction_GetRescuerSnapPosition final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CageRescueInteraction_GetRescuerSnapPosition) == 0x000008, "Wrong alignment on CageRescueInteraction_GetRescuerSnapPosition");
static_assert(sizeof(CageRescueInteraction_GetRescuerSnapPosition) == 0x000018, "Wrong size on CageRescueInteraction_GetRescuerSnapPosition");
static_assert(offsetof(CageRescueInteraction_GetRescuerSnapPosition, ReturnValue) == 0x000000, "Member 'CageRescueInteraction_GetRescuerSnapPosition::ReturnValue' has a wrong offset!");

// Function DBDGameplay.SendToCageInteraction.FX_InteractionChargeCompleted
// 0x0008 (0x0008 - 0x0000)
struct SendToCageInteraction_FX_InteractionChargeCompleted final
{
public:
	class ADBDPlayer*                             Player;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SendToCageInteraction_FX_InteractionChargeCompleted) == 0x000008, "Wrong alignment on SendToCageInteraction_FX_InteractionChargeCompleted");
static_assert(sizeof(SendToCageInteraction_FX_InteractionChargeCompleted) == 0x000008, "Wrong size on SendToCageInteraction_FX_InteractionChargeCompleted");
static_assert(offsetof(SendToCageInteraction_FX_InteractionChargeCompleted, Player) == 0x000000, "Member 'SendToCageInteraction_FX_InteractionChargeCompleted::Player' has a wrong offset!");

// Function DBDGameplay.SendToCageInteraction.GetOwningSurvivor
// 0x0008 (0x0008 - 0x0000)
struct SendToCageInteraction_GetOwningSurvivor final
{
public:
	const class ACamperPlayer*                    ReturnValue;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SendToCageInteraction_GetOwningSurvivor) == 0x000008, "Wrong alignment on SendToCageInteraction_GetOwningSurvivor");
static_assert(sizeof(SendToCageInteraction_GetOwningSurvivor) == 0x000008, "Wrong size on SendToCageInteraction_GetOwningSurvivor");
static_assert(offsetof(SendToCageInteraction_GetOwningSurvivor, ReturnValue) == 0x000000, "Member 'SendToCageInteraction_GetOwningSurvivor::ReturnValue' has a wrong offset!");

// Function DBDGameplay.AuraOverriderComponent.ForceShowAura
// 0x0028 (0x0028 - 0x0000)
struct AuraOverriderComponent_ForceShowAura final
{
public:
	const class AActor*                           Actor;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Color;                                             // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsAlwaysVisible;                                   // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinimumOutlineDistanceVisible;                     // 0x001C(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinimumOutlineDistance;                            // 0x0020(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AuraOverriderComponent_ForceShowAura) == 0x000008, "Wrong alignment on AuraOverriderComponent_ForceShowAura");
static_assert(sizeof(AuraOverriderComponent_ForceShowAura) == 0x000028, "Wrong size on AuraOverriderComponent_ForceShowAura");
static_assert(offsetof(AuraOverriderComponent_ForceShowAura, Actor) == 0x000000, "Member 'AuraOverriderComponent_ForceShowAura::Actor' has a wrong offset!");
static_assert(offsetof(AuraOverriderComponent_ForceShowAura, Color) == 0x000008, "Member 'AuraOverriderComponent_ForceShowAura::Color' has a wrong offset!");
static_assert(offsetof(AuraOverriderComponent_ForceShowAura, IsAlwaysVisible) == 0x000018, "Member 'AuraOverriderComponent_ForceShowAura::IsAlwaysVisible' has a wrong offset!");
static_assert(offsetof(AuraOverriderComponent_ForceShowAura, MinimumOutlineDistanceVisible) == 0x00001C, "Member 'AuraOverriderComponent_ForceShowAura::MinimumOutlineDistanceVisible' has a wrong offset!");
static_assert(offsetof(AuraOverriderComponent_ForceShowAura, MinimumOutlineDistance) == 0x000020, "Member 'AuraOverriderComponent_ForceShowAura::MinimumOutlineDistance' has a wrong offset!");

// Function DBDGameplay.AuraOverriderComponent.ResetAura
// 0x0008 (0x0008 - 0x0000)
struct AuraOverriderComponent_ResetAura final
{
public:
	const class AActor*                           Actor;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AuraOverriderComponent_ResetAura) == 0x000008, "Wrong alignment on AuraOverriderComponent_ResetAura");
static_assert(sizeof(AuraOverriderComponent_ResetAura) == 0x000008, "Wrong size on AuraOverriderComponent_ResetAura");
static_assert(offsetof(AuraOverriderComponent_ResetAura, Actor) == 0x000000, "Member 'AuraOverriderComponent_ResetAura::Actor' has a wrong offset!");

// Function DBDGameplay.BaseSightManagerComponent.Authority_OnCharacterSightChanged
// 0x0010 (0x0010 - 0x0000)
struct BaseSightManagerComponent_Authority_OnCharacterSightChanged final
{
public:
	class ACharacter*                             SightedCharacter;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCharacterSightComponent*               SightComponent;                                    // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseSightManagerComponent_Authority_OnCharacterSightChanged) == 0x000008, "Wrong alignment on BaseSightManagerComponent_Authority_OnCharacterSightChanged");
static_assert(sizeof(BaseSightManagerComponent_Authority_OnCharacterSightChanged) == 0x000010, "Wrong size on BaseSightManagerComponent_Authority_OnCharacterSightChanged");
static_assert(offsetof(BaseSightManagerComponent_Authority_OnCharacterSightChanged, SightedCharacter) == 0x000000, "Member 'BaseSightManagerComponent_Authority_OnCharacterSightChanged::SightedCharacter' has a wrong offset!");
static_assert(offsetof(BaseSightManagerComponent_Authority_OnCharacterSightChanged, SightComponent) == 0x000008, "Member 'BaseSightManagerComponent_Authority_OnCharacterSightChanged::SightComponent' has a wrong offset!");

// Function DBDGameplay.FadeComponent.GetFadePercent
// 0x0004 (0x0004 - 0x0000)
struct FadeComponent_GetFadePercent final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FadeComponent_GetFadePercent) == 0x000004, "Wrong alignment on FadeComponent_GetFadePercent");
static_assert(sizeof(FadeComponent_GetFadePercent) == 0x000004, "Wrong size on FadeComponent_GetFadePercent");
static_assert(offsetof(FadeComponent_GetFadePercent, ReturnValue) == 0x000000, "Member 'FadeComponent_GetFadePercent::ReturnValue' has a wrong offset!");

// Function DBDGameplay.FlashlightTargetFXComponent.OnIsLitChanged
// 0x0001 (0x0001 - 0x0000)
struct FlashlightTargetFXComponent_OnIsLitChanged final
{
public:
	bool                                          IsLit;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FlashlightTargetFXComponent_OnIsLitChanged) == 0x000001, "Wrong alignment on FlashlightTargetFXComponent_OnIsLitChanged");
static_assert(sizeof(FlashlightTargetFXComponent_OnIsLitChanged) == 0x000001, "Wrong size on FlashlightTargetFXComponent_OnIsLitChanged");
static_assert(offsetof(FlashlightTargetFXComponent_OnIsLitChanged, IsLit) == 0x000000, "Member 'FlashlightTargetFXComponent_OnIsLitChanged::IsLit' has a wrong offset!");

// Function DBDGameplay.TerrorRadiusScreenIndicatorComponent.OnHeartStateChanged
// 0x000C (0x000C - 0x0000)
struct TerrorRadiusScreenIndicatorComponent_OnHeartStateChanged final
{
public:
	struct FGameplayTag                           HeartState;                                        // 0x0000(0x000C)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TerrorRadiusScreenIndicatorComponent_OnHeartStateChanged) == 0x000004, "Wrong alignment on TerrorRadiusScreenIndicatorComponent_OnHeartStateChanged");
static_assert(sizeof(TerrorRadiusScreenIndicatorComponent_OnHeartStateChanged) == 0x00000C, "Wrong size on TerrorRadiusScreenIndicatorComponent_OnHeartStateChanged");
static_assert(offsetof(TerrorRadiusScreenIndicatorComponent_OnHeartStateChanged, HeartState) == 0x000000, "Member 'TerrorRadiusScreenIndicatorComponent_OnHeartStateChanged::HeartState' has a wrong offset!");

// Function DBDGameplay.KillerAbilityComponent.OnRep_TokenCount
// 0x0004 (0x0004 - 0x0000)
struct KillerAbilityComponent_OnRep_TokenCount final
{
public:
	int32                                         OldCount;                                          // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KillerAbilityComponent_OnRep_TokenCount) == 0x000004, "Wrong alignment on KillerAbilityComponent_OnRep_TokenCount");
static_assert(sizeof(KillerAbilityComponent_OnRep_TokenCount) == 0x000004, "Wrong size on KillerAbilityComponent_OnRep_TokenCount");
static_assert(offsetof(KillerAbilityComponent_OnRep_TokenCount, OldCount) == 0x000000, "Member 'KillerAbilityComponent_OnRep_TokenCount::OldCount' has a wrong offset!");

// Function DBDGameplay.KillerAbilityComponent.GetCooldown
// 0x0004 (0x0004 - 0x0000)
struct KillerAbilityComponent_GetCooldown final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KillerAbilityComponent_GetCooldown) == 0x000004, "Wrong alignment on KillerAbilityComponent_GetCooldown");
static_assert(sizeof(KillerAbilityComponent_GetCooldown) == 0x000004, "Wrong size on KillerAbilityComponent_GetCooldown");
static_assert(offsetof(KillerAbilityComponent_GetCooldown, ReturnValue) == 0x000000, "Member 'KillerAbilityComponent_GetCooldown::ReturnValue' has a wrong offset!");

// Function DBDGameplay.KillerAbilityComponent.GetDuration
// 0x0004 (0x0004 - 0x0000)
struct KillerAbilityComponent_GetDuration final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KillerAbilityComponent_GetDuration) == 0x000004, "Wrong alignment on KillerAbilityComponent_GetDuration");
static_assert(sizeof(KillerAbilityComponent_GetDuration) == 0x000004, "Wrong size on KillerAbilityComponent_GetDuration");
static_assert(offsetof(KillerAbilityComponent_GetDuration, ReturnValue) == 0x000000, "Member 'KillerAbilityComponent_GetDuration::ReturnValue' has a wrong offset!");

// Function DBDGameplay.KillerAbilityComponent.GetOwningKiller
// 0x0008 (0x0008 - 0x0000)
struct KillerAbilityComponent_GetOwningKiller final
{
public:
	class ASlasherPlayer*                         ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KillerAbilityComponent_GetOwningKiller) == 0x000008, "Wrong alignment on KillerAbilityComponent_GetOwningKiller");
static_assert(sizeof(KillerAbilityComponent_GetOwningKiller) == 0x000008, "Wrong size on KillerAbilityComponent_GetOwningKiller");
static_assert(offsetof(KillerAbilityComponent_GetOwningKiller, ReturnValue) == 0x000000, "Member 'KillerAbilityComponent_GetOwningKiller::ReturnValue' has a wrong offset!");

// Function DBDGameplay.KillerAbilityComponent.GetOwningPower
// 0x0008 (0x0008 - 0x0000)
struct KillerAbilityComponent_GetOwningPower final
{
public:
	class AKillerPower*                           ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KillerAbilityComponent_GetOwningPower) == 0x000008, "Wrong alignment on KillerAbilityComponent_GetOwningPower");
static_assert(sizeof(KillerAbilityComponent_GetOwningPower) == 0x000008, "Wrong size on KillerAbilityComponent_GetOwningPower");
static_assert(offsetof(KillerAbilityComponent_GetOwningPower, ReturnValue) == 0x000000, "Member 'KillerAbilityComponent_GetOwningPower::ReturnValue' has a wrong offset!");

// Function DBDGameplay.KillerAbilityComponent.GetRemainingCooldown
// 0x0004 (0x0004 - 0x0000)
struct KillerAbilityComponent_GetRemainingCooldown final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KillerAbilityComponent_GetRemainingCooldown) == 0x000004, "Wrong alignment on KillerAbilityComponent_GetRemainingCooldown");
static_assert(sizeof(KillerAbilityComponent_GetRemainingCooldown) == 0x000004, "Wrong size on KillerAbilityComponent_GetRemainingCooldown");
static_assert(offsetof(KillerAbilityComponent_GetRemainingCooldown, ReturnValue) == 0x000000, "Member 'KillerAbilityComponent_GetRemainingCooldown::ReturnValue' has a wrong offset!");

// Function DBDGameplay.KillerAbilityComponent.GetRemainingCooldownPercent
// 0x0004 (0x0004 - 0x0000)
struct KillerAbilityComponent_GetRemainingCooldownPercent final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KillerAbilityComponent_GetRemainingCooldownPercent) == 0x000004, "Wrong alignment on KillerAbilityComponent_GetRemainingCooldownPercent");
static_assert(sizeof(KillerAbilityComponent_GetRemainingCooldownPercent) == 0x000004, "Wrong size on KillerAbilityComponent_GetRemainingCooldownPercent");
static_assert(offsetof(KillerAbilityComponent_GetRemainingCooldownPercent, ReturnValue) == 0x000000, "Member 'KillerAbilityComponent_GetRemainingCooldownPercent::ReturnValue' has a wrong offset!");

// Function DBDGameplay.KillerAbilityComponent.IsApplicable
// 0x0001 (0x0001 - 0x0000)
struct KillerAbilityComponent_IsApplicable final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KillerAbilityComponent_IsApplicable) == 0x000001, "Wrong alignment on KillerAbilityComponent_IsApplicable");
static_assert(sizeof(KillerAbilityComponent_IsApplicable) == 0x000001, "Wrong size on KillerAbilityComponent_IsApplicable");
static_assert(offsetof(KillerAbilityComponent_IsApplicable, ReturnValue) == 0x000000, "Member 'KillerAbilityComponent_IsApplicable::ReturnValue' has a wrong offset!");

// Function DBDGameplay.KillerAbilityComponent.IsAvailable
// 0x0001 (0x0001 - 0x0000)
struct KillerAbilityComponent_IsAvailable final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KillerAbilityComponent_IsAvailable) == 0x000001, "Wrong alignment on KillerAbilityComponent_IsAvailable");
static_assert(sizeof(KillerAbilityComponent_IsAvailable) == 0x000001, "Wrong size on KillerAbilityComponent_IsAvailable");
static_assert(offsetof(KillerAbilityComponent_IsAvailable, ReturnValue) == 0x000000, "Member 'KillerAbilityComponent_IsAvailable::ReturnValue' has a wrong offset!");

// Function DBDGameplay.KillerAbilityComponent.IsOnCooldown
// 0x0001 (0x0001 - 0x0000)
struct KillerAbilityComponent_IsOnCooldown final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KillerAbilityComponent_IsOnCooldown) == 0x000001, "Wrong alignment on KillerAbilityComponent_IsOnCooldown");
static_assert(sizeof(KillerAbilityComponent_IsOnCooldown) == 0x000001, "Wrong size on KillerAbilityComponent_IsOnCooldown");
static_assert(offsetof(KillerAbilityComponent_IsOnCooldown, ReturnValue) == 0x000000, "Member 'KillerAbilityComponent_IsOnCooldown::ReturnValue' has a wrong offset!");

// Function DBDGameplay.KillerAbilityComponent.PlayAudioOnOwningKiller
// 0x0010 (0x0010 - 0x0000)
struct KillerAbilityComponent_PlayAudioOnOwningKiller final
{
public:
	class UAkAudioEvent*                          AudioEvent;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          OnlyPlayIfLocallyObserved;                         // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KillerAbilityComponent_PlayAudioOnOwningKiller) == 0x000008, "Wrong alignment on KillerAbilityComponent_PlayAudioOnOwningKiller");
static_assert(sizeof(KillerAbilityComponent_PlayAudioOnOwningKiller) == 0x000010, "Wrong size on KillerAbilityComponent_PlayAudioOnOwningKiller");
static_assert(offsetof(KillerAbilityComponent_PlayAudioOnOwningKiller, AudioEvent) == 0x000000, "Member 'KillerAbilityComponent_PlayAudioOnOwningKiller::AudioEvent' has a wrong offset!");
static_assert(offsetof(KillerAbilityComponent_PlayAudioOnOwningKiller, OnlyPlayIfLocallyObserved) == 0x000008, "Member 'KillerAbilityComponent_PlayAudioOnOwningKiller::OnlyPlayIfLocallyObserved' has a wrong offset!");

// Function DBDGameplay.PoseableHusk.OnActiveStateChanged
// 0x0001 (0x0001 - 0x0000)
struct PoseableHusk_OnActiveStateChanged final
{
public:
	bool                                          IsActive;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PoseableHusk_OnActiveStateChanged) == 0x000001, "Wrong alignment on PoseableHusk_OnActiveStateChanged");
static_assert(sizeof(PoseableHusk_OnActiveStateChanged) == 0x000001, "Wrong size on PoseableHusk_OnActiveStateChanged");
static_assert(offsetof(PoseableHusk_OnActiveStateChanged, IsActive) == 0x000000, "Member 'PoseableHusk_OnActiveStateChanged::IsActive' has a wrong offset!");

// Function DBDGameplay.PoseableHusk.SetIsActive
// 0x0001 (0x0001 - 0x0000)
struct PoseableHusk_SetIsActive final
{
public:
	bool                                          IsActive;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PoseableHusk_SetIsActive) == 0x000001, "Wrong alignment on PoseableHusk_SetIsActive");
static_assert(sizeof(PoseableHusk_SetIsActive) == 0x000001, "Wrong size on PoseableHusk_SetIsActive");
static_assert(offsetof(PoseableHusk_SetIsActive, IsActive) == 0x000000, "Member 'PoseableHusk_SetIsActive::IsActive' has a wrong offset!");

// Function DBDGameplay.PoseableHusk.GetIsActive
// 0x0001 (0x0001 - 0x0000)
struct PoseableHusk_GetIsActive final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PoseableHusk_GetIsActive) == 0x000001, "Wrong alignment on PoseableHusk_GetIsActive");
static_assert(sizeof(PoseableHusk_GetIsActive) == 0x000001, "Wrong size on PoseableHusk_GetIsActive");
static_assert(offsetof(PoseableHusk_GetIsActive, ReturnValue) == 0x000000, "Member 'PoseableHusk_GetIsActive::ReturnValue' has a wrong offset!");

// Function DBDGameplay.ClosetHideInteraction.FireSoundEventFromInteractor
// 0x0010 (0x0010 - 0x0000)
struct ClosetHideInteraction_FireSoundEventFromInteractor final
{
public:
	class AActor*                                 Instigator;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ADBDPlayer*                             InstigatingPlayer;                                 // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ClosetHideInteraction_FireSoundEventFromInteractor) == 0x000008, "Wrong alignment on ClosetHideInteraction_FireSoundEventFromInteractor");
static_assert(sizeof(ClosetHideInteraction_FireSoundEventFromInteractor) == 0x000010, "Wrong size on ClosetHideInteraction_FireSoundEventFromInteractor");
static_assert(offsetof(ClosetHideInteraction_FireSoundEventFromInteractor, Instigator) == 0x000000, "Member 'ClosetHideInteraction_FireSoundEventFromInteractor::Instigator' has a wrong offset!");
static_assert(offsetof(ClosetHideInteraction_FireSoundEventFromInteractor, InstigatingPlayer) == 0x000008, "Member 'ClosetHideInteraction_FireSoundEventFromInteractor::InstigatingPlayer' has a wrong offset!");

// Function DBDGameplay.ClosetHideInteraction.SetOtherInteractorsUsable
// 0x0001 (0x0001 - 0x0000)
struct ClosetHideInteraction_SetOtherInteractorsUsable final
{
public:
	bool                                          IsEnabled;                                         // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ClosetHideInteraction_SetOtherInteractorsUsable) == 0x000001, "Wrong alignment on ClosetHideInteraction_SetOtherInteractorsUsable");
static_assert(sizeof(ClosetHideInteraction_SetOtherInteractorsUsable) == 0x000001, "Wrong size on ClosetHideInteraction_SetOtherInteractorsUsable");
static_assert(offsetof(ClosetHideInteraction_SetOtherInteractorsUsable, IsEnabled) == 0x000000, "Member 'ClosetHideInteraction_SetOtherInteractorsUsable::IsEnabled' has a wrong offset!");

// Function DBDGameplay.ClosetHideInteraction.GetInsideInteractor
// 0x0008 (0x0008 - 0x0000)
struct ClosetHideInteraction_GetInsideInteractor final
{
public:
	class UInteractor*                            ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ClosetHideInteraction_GetInsideInteractor) == 0x000008, "Wrong alignment on ClosetHideInteraction_GetInsideInteractor");
static_assert(sizeof(ClosetHideInteraction_GetInsideInteractor) == 0x000008, "Wrong size on ClosetHideInteraction_GetInsideInteractor");
static_assert(offsetof(ClosetHideInteraction_GetInsideInteractor, ReturnValue) == 0x000000, "Member 'ClosetHideInteraction_GetInsideInteractor::ReturnValue' has a wrong offset!");

// Function DBDGameplay.ClosetHideInteraction.GetPlayerInCloset
// 0x0008 (0x0008 - 0x0000)
struct ClosetHideInteraction_GetPlayerInCloset final
{
public:
	class ADBDPlayer*                             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ClosetHideInteraction_GetPlayerInCloset) == 0x000008, "Wrong alignment on ClosetHideInteraction_GetPlayerInCloset");
static_assert(sizeof(ClosetHideInteraction_GetPlayerInCloset) == 0x000008, "Wrong size on ClosetHideInteraction_GetPlayerInCloset");
static_assert(offsetof(ClosetHideInteraction_GetPlayerInCloset, ReturnValue) == 0x000000, "Member 'ClosetHideInteraction_GetPlayerInCloset::ReturnValue' has a wrong offset!");

// Function DBDGameplay.ClosetHideInteraction.IsInteractingPlayerInsideCloset
// 0x0010 (0x0010 - 0x0000)
struct ClosetHideInteraction_IsInteractingPlayerInsideCloset final
{
public:
	const class ADBDPlayer*                       Player;                                            // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ClosetHideInteraction_IsInteractingPlayerInsideCloset) == 0x000008, "Wrong alignment on ClosetHideInteraction_IsInteractingPlayerInsideCloset");
static_assert(sizeof(ClosetHideInteraction_IsInteractingPlayerInsideCloset) == 0x000010, "Wrong size on ClosetHideInteraction_IsInteractingPlayerInsideCloset");
static_assert(offsetof(ClosetHideInteraction_IsInteractingPlayerInsideCloset, Player) == 0x000000, "Member 'ClosetHideInteraction_IsInteractingPlayerInsideCloset::Player' has a wrong offset!");
static_assert(offsetof(ClosetHideInteraction_IsInteractingPlayerInsideCloset, ReturnValue) == 0x000008, "Member 'ClosetHideInteraction_IsInteractingPlayerInsideCloset::ReturnValue' has a wrong offset!");

// Function DBDGameplay.ClosetHideInteraction.IsOccupied
// 0x0001 (0x0001 - 0x0000)
struct ClosetHideInteraction_IsOccupied final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ClosetHideInteraction_IsOccupied) == 0x000001, "Wrong alignment on ClosetHideInteraction_IsOccupied");
static_assert(sizeof(ClosetHideInteraction_IsOccupied) == 0x000001, "Wrong size on ClosetHideInteraction_IsOccupied");
static_assert(offsetof(ClosetHideInteraction_IsOccupied, ReturnValue) == 0x000000, "Member 'ClosetHideInteraction_IsOccupied::ReturnValue' has a wrong offset!");

// Function DBDGameplay.ClosetHideInteraction.IsRushed
// 0x0001 (0x0001 - 0x0000)
struct ClosetHideInteraction_IsRushed final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ClosetHideInteraction_IsRushed) == 0x000001, "Wrong alignment on ClosetHideInteraction_IsRushed");
static_assert(sizeof(ClosetHideInteraction_IsRushed) == 0x000001, "Wrong size on ClosetHideInteraction_IsRushed");
static_assert(offsetof(ClosetHideInteraction_IsRushed, ReturnValue) == 0x000000, "Member 'ClosetHideInteraction_IsRushed::ReturnValue' has a wrong offset!");

// Function DBDGameplay.ClosetHideInteraction.SetCollisionWithCloset
// 0x0010 (0x0010 - 0x0000)
struct ClosetHideInteraction_SetCollisionWithCloset final
{
public:
	bool                                          IsEnabled;                                         // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ADBDPlayer*                             Player;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ClosetHideInteraction_SetCollisionWithCloset) == 0x000008, "Wrong alignment on ClosetHideInteraction_SetCollisionWithCloset");
static_assert(sizeof(ClosetHideInteraction_SetCollisionWithCloset) == 0x000010, "Wrong size on ClosetHideInteraction_SetCollisionWithCloset");
static_assert(offsetof(ClosetHideInteraction_SetCollisionWithCloset, IsEnabled) == 0x000000, "Member 'ClosetHideInteraction_SetCollisionWithCloset::IsEnabled' has a wrong offset!");
static_assert(offsetof(ClosetHideInteraction_SetCollisionWithCloset, Player) == 0x000008, "Member 'ClosetHideInteraction_SetCollisionWithCloset::Player' has a wrong offset!");

// Function DBDGameplay.ClosetHideEnterInteraction.EjectSurvivorFromLocker
// 0x0010 (0x0010 - 0x0000)
struct ClosetHideEnterInteraction_EjectSurvivorFromLocker final
{
public:
	class ACamperPlayer*                          Survivor;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ALocker*                                Locker;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ClosetHideEnterInteraction_EjectSurvivorFromLocker) == 0x000008, "Wrong alignment on ClosetHideEnterInteraction_EjectSurvivorFromLocker");
static_assert(sizeof(ClosetHideEnterInteraction_EjectSurvivorFromLocker) == 0x000010, "Wrong size on ClosetHideEnterInteraction_EjectSurvivorFromLocker");
static_assert(offsetof(ClosetHideEnterInteraction_EjectSurvivorFromLocker, Survivor) == 0x000000, "Member 'ClosetHideEnterInteraction_EjectSurvivorFromLocker::Survivor' has a wrong offset!");
static_assert(offsetof(ClosetHideEnterInteraction_EjectSurvivorFromLocker, Locker) == 0x000008, "Member 'ClosetHideEnterInteraction_EjectSurvivorFromLocker::Locker' has a wrong offset!");

// Function DBDGameplay.PalletTrackerVisibilityComponent.Cosmetic_OnPalletTrackerSelectedChanged
// 0x0001 (0x0001 - 0x0000)
struct PalletTrackerVisibilityComponent_Cosmetic_OnPalletTrackerSelectedChanged final
{
public:
	bool                                          Selected;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PalletTrackerVisibilityComponent_Cosmetic_OnPalletTrackerSelectedChanged) == 0x000001, "Wrong alignment on PalletTrackerVisibilityComponent_Cosmetic_OnPalletTrackerSelectedChanged");
static_assert(sizeof(PalletTrackerVisibilityComponent_Cosmetic_OnPalletTrackerSelectedChanged) == 0x000001, "Wrong size on PalletTrackerVisibilityComponent_Cosmetic_OnPalletTrackerSelectedChanged");
static_assert(offsetof(PalletTrackerVisibilityComponent_Cosmetic_OnPalletTrackerSelectedChanged, Selected) == 0x000000, "Member 'PalletTrackerVisibilityComponent_Cosmetic_OnPalletTrackerSelectedChanged::Selected' has a wrong offset!");

// Function DBDGameplay.PalletTrackerVisibilityComponent.Cosmetic_OnVisibilityChanged
// 0x0001 (0x0001 - 0x0000)
struct PalletTrackerVisibilityComponent_Cosmetic_OnVisibilityChanged final
{
public:
	bool                                          IsVisible;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PalletTrackerVisibilityComponent_Cosmetic_OnVisibilityChanged) == 0x000001, "Wrong alignment on PalletTrackerVisibilityComponent_Cosmetic_OnVisibilityChanged");
static_assert(sizeof(PalletTrackerVisibilityComponent_Cosmetic_OnVisibilityChanged) == 0x000001, "Wrong size on PalletTrackerVisibilityComponent_Cosmetic_OnVisibilityChanged");
static_assert(offsetof(PalletTrackerVisibilityComponent_Cosmetic_OnVisibilityChanged, IsVisible) == 0x000000, "Member 'PalletTrackerVisibilityComponent_Cosmetic_OnVisibilityChanged::IsVisible' has a wrong offset!");

// Function DBDGameplay.PalletTrackerVisibilityComponent.GetPalletTrackerOwner
// 0x0008 (0x0008 - 0x0000)
struct PalletTrackerVisibilityComponent_GetPalletTrackerOwner final
{
public:
	class APalletTracker*                         ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PalletTrackerVisibilityComponent_GetPalletTrackerOwner) == 0x000008, "Wrong alignment on PalletTrackerVisibilityComponent_GetPalletTrackerOwner");
static_assert(sizeof(PalletTrackerVisibilityComponent_GetPalletTrackerOwner) == 0x000008, "Wrong size on PalletTrackerVisibilityComponent_GetPalletTrackerOwner");
static_assert(offsetof(PalletTrackerVisibilityComponent_GetPalletTrackerOwner, ReturnValue) == 0x000000, "Member 'PalletTrackerVisibilityComponent_GetPalletTrackerOwner::ReturnValue' has a wrong offset!");

// DelegateFunction DBDGameplay.LimitGeneratorRegressionEventComponent.CosmeticEvent__DelegateSignature
// 0x0004 (0x0004 - 0x0000)
struct LimitGeneratorRegressionEventComponent_CosmeticEvent__DelegateSignature final
{
public:
	int32                                         CurrentRegressionLevel;                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LimitGeneratorRegressionEventComponent_CosmeticEvent__DelegateSignature) == 0x000004, "Wrong alignment on LimitGeneratorRegressionEventComponent_CosmeticEvent__DelegateSignature");
static_assert(sizeof(LimitGeneratorRegressionEventComponent_CosmeticEvent__DelegateSignature) == 0x000004, "Wrong size on LimitGeneratorRegressionEventComponent_CosmeticEvent__DelegateSignature");
static_assert(offsetof(LimitGeneratorRegressionEventComponent_CosmeticEvent__DelegateSignature, CurrentRegressionLevel) == 0x000000, "Member 'LimitGeneratorRegressionEventComponent_CosmeticEvent__DelegateSignature::CurrentRegressionLevel' has a wrong offset!");

// DelegateFunction DBDGameplay.LimitGeneratorRegressionEventComponent.OnBlockingStatusChanged__DelegateSignature
// 0x0008 (0x0008 - 0x0000)
struct LimitGeneratorRegressionEventComponent_OnBlockingStatusChanged__DelegateSignature final
{
public:
	int32                                         CurrentRegressionLevel;                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Blocked;                                           // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LimitGeneratorRegressionEventComponent_OnBlockingStatusChanged__DelegateSignature) == 0x000004, "Wrong alignment on LimitGeneratorRegressionEventComponent_OnBlockingStatusChanged__DelegateSignature");
static_assert(sizeof(LimitGeneratorRegressionEventComponent_OnBlockingStatusChanged__DelegateSignature) == 0x000008, "Wrong size on LimitGeneratorRegressionEventComponent_OnBlockingStatusChanged__DelegateSignature");
static_assert(offsetof(LimitGeneratorRegressionEventComponent_OnBlockingStatusChanged__DelegateSignature, CurrentRegressionLevel) == 0x000000, "Member 'LimitGeneratorRegressionEventComponent_OnBlockingStatusChanged__DelegateSignature::CurrentRegressionLevel' has a wrong offset!");
static_assert(offsetof(LimitGeneratorRegressionEventComponent_OnBlockingStatusChanged__DelegateSignature, Blocked) == 0x000004, "Member 'LimitGeneratorRegressionEventComponent_OnBlockingStatusChanged__DelegateSignature::Blocked' has a wrong offset!");

// Function DBDGameplay.LimitGeneratorRegressionEventComponent.OnKillerProximityZoneForRegressionEventsOverlapBegin
// 0x0110 (0x0110 - 0x0000)
struct LimitGeneratorRegressionEventComponent_OnKillerProximityZoneForRegressionEventsOverlapBegin final
{
public:
	class UPrimitiveComponent*                    HitComponent;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x00F0)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(LimitGeneratorRegressionEventComponent_OnKillerProximityZoneForRegressionEventsOverlapBegin) == 0x000008, "Wrong alignment on LimitGeneratorRegressionEventComponent_OnKillerProximityZoneForRegressionEventsOverlapBegin");
static_assert(sizeof(LimitGeneratorRegressionEventComponent_OnKillerProximityZoneForRegressionEventsOverlapBegin) == 0x000110, "Wrong size on LimitGeneratorRegressionEventComponent_OnKillerProximityZoneForRegressionEventsOverlapBegin");
static_assert(offsetof(LimitGeneratorRegressionEventComponent_OnKillerProximityZoneForRegressionEventsOverlapBegin, HitComponent) == 0x000000, "Member 'LimitGeneratorRegressionEventComponent_OnKillerProximityZoneForRegressionEventsOverlapBegin::HitComponent' has a wrong offset!");
static_assert(offsetof(LimitGeneratorRegressionEventComponent_OnKillerProximityZoneForRegressionEventsOverlapBegin, OtherActor) == 0x000008, "Member 'LimitGeneratorRegressionEventComponent_OnKillerProximityZoneForRegressionEventsOverlapBegin::OtherActor' has a wrong offset!");
static_assert(offsetof(LimitGeneratorRegressionEventComponent_OnKillerProximityZoneForRegressionEventsOverlapBegin, OtherComp) == 0x000010, "Member 'LimitGeneratorRegressionEventComponent_OnKillerProximityZoneForRegressionEventsOverlapBegin::OtherComp' has a wrong offset!");
static_assert(offsetof(LimitGeneratorRegressionEventComponent_OnKillerProximityZoneForRegressionEventsOverlapBegin, OtherBodyIndex) == 0x000018, "Member 'LimitGeneratorRegressionEventComponent_OnKillerProximityZoneForRegressionEventsOverlapBegin::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(LimitGeneratorRegressionEventComponent_OnKillerProximityZoneForRegressionEventsOverlapBegin, bFromSweep) == 0x00001C, "Member 'LimitGeneratorRegressionEventComponent_OnKillerProximityZoneForRegressionEventsOverlapBegin::bFromSweep' has a wrong offset!");
static_assert(offsetof(LimitGeneratorRegressionEventComponent_OnKillerProximityZoneForRegressionEventsOverlapBegin, SweepResult) == 0x000020, "Member 'LimitGeneratorRegressionEventComponent_OnKillerProximityZoneForRegressionEventsOverlapBegin::SweepResult' has a wrong offset!");

// Function DBDGameplay.LimitGeneratorRegressionEventComponent.OnKillerProximityZoneForRegressionEventsOverlapEnd
// 0x0020 (0x0020 - 0x0000)
struct LimitGeneratorRegressionEventComponent_OnKillerProximityZoneForRegressionEventsOverlapEnd final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LimitGeneratorRegressionEventComponent_OnKillerProximityZoneForRegressionEventsOverlapEnd) == 0x000008, "Wrong alignment on LimitGeneratorRegressionEventComponent_OnKillerProximityZoneForRegressionEventsOverlapEnd");
static_assert(sizeof(LimitGeneratorRegressionEventComponent_OnKillerProximityZoneForRegressionEventsOverlapEnd) == 0x000020, "Wrong size on LimitGeneratorRegressionEventComponent_OnKillerProximityZoneForRegressionEventsOverlapEnd");
static_assert(offsetof(LimitGeneratorRegressionEventComponent_OnKillerProximityZoneForRegressionEventsOverlapEnd, OverlappedComponent) == 0x000000, "Member 'LimitGeneratorRegressionEventComponent_OnKillerProximityZoneForRegressionEventsOverlapEnd::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(LimitGeneratorRegressionEventComponent_OnKillerProximityZoneForRegressionEventsOverlapEnd, OtherActor) == 0x000008, "Member 'LimitGeneratorRegressionEventComponent_OnKillerProximityZoneForRegressionEventsOverlapEnd::OtherActor' has a wrong offset!");
static_assert(offsetof(LimitGeneratorRegressionEventComponent_OnKillerProximityZoneForRegressionEventsOverlapEnd, OtherComp) == 0x000010, "Member 'LimitGeneratorRegressionEventComponent_OnKillerProximityZoneForRegressionEventsOverlapEnd::OtherComp' has a wrong offset!");
static_assert(offsetof(LimitGeneratorRegressionEventComponent_OnKillerProximityZoneForRegressionEventsOverlapEnd, OtherBodyIndex) == 0x000018, "Member 'LimitGeneratorRegressionEventComponent_OnKillerProximityZoneForRegressionEventsOverlapEnd::OtherBodyIndex' has a wrong offset!");

// DelegateFunction DBDGameplay.LimitGeneratorRegressionEventComponent.OnRegressionEvent__DelegateSignature
// 0x0008 (0x0008 - 0x0000)
struct LimitGeneratorRegressionEventComponent_OnRegressionEvent__DelegateSignature final
{
public:
	int32                                         CurrentRegressionLevel;                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SurvivorInteracting;                               // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LimitGeneratorRegressionEventComponent_OnRegressionEvent__DelegateSignature) == 0x000004, "Wrong alignment on LimitGeneratorRegressionEventComponent_OnRegressionEvent__DelegateSignature");
static_assert(sizeof(LimitGeneratorRegressionEventComponent_OnRegressionEvent__DelegateSignature) == 0x000008, "Wrong size on LimitGeneratorRegressionEventComponent_OnRegressionEvent__DelegateSignature");
static_assert(offsetof(LimitGeneratorRegressionEventComponent_OnRegressionEvent__DelegateSignature, CurrentRegressionLevel) == 0x000000, "Member 'LimitGeneratorRegressionEventComponent_OnRegressionEvent__DelegateSignature::CurrentRegressionLevel' has a wrong offset!");
static_assert(offsetof(LimitGeneratorRegressionEventComponent_OnRegressionEvent__DelegateSignature, SurvivorInteracting) == 0x000004, "Member 'LimitGeneratorRegressionEventComponent_OnRegressionEvent__DelegateSignature::SurvivorInteracting' has a wrong offset!");

// Function DBDGameplay.LimitGeneratorRegressionEventComponent.GetMaxNumberRegressionEventsAllowed
// 0x0004 (0x0004 - 0x0000)
struct LimitGeneratorRegressionEventComponent_GetMaxNumberRegressionEventsAllowed final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LimitGeneratorRegressionEventComponent_GetMaxNumberRegressionEventsAllowed) == 0x000004, "Wrong alignment on LimitGeneratorRegressionEventComponent_GetMaxNumberRegressionEventsAllowed");
static_assert(sizeof(LimitGeneratorRegressionEventComponent_GetMaxNumberRegressionEventsAllowed) == 0x000004, "Wrong size on LimitGeneratorRegressionEventComponent_GetMaxNumberRegressionEventsAllowed");
static_assert(offsetof(LimitGeneratorRegressionEventComponent_GetMaxNumberRegressionEventsAllowed, ReturnValue) == 0x000000, "Member 'LimitGeneratorRegressionEventComponent_GetMaxNumberRegressionEventsAllowed::ReturnValue' has a wrong offset!");

// Function DBDGameplay.RangedExplosive.Multicast_InitFromSpawningPlayer
// 0x0008 (0x0008 - 0x0000)
struct RangedExplosive_Multicast_InitFromSpawningPlayer final
{
public:
	class ADBDPlayer*                             Spawner;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RangedExplosive_Multicast_InitFromSpawningPlayer) == 0x000008, "Wrong alignment on RangedExplosive_Multicast_InitFromSpawningPlayer");
static_assert(sizeof(RangedExplosive_Multicast_InitFromSpawningPlayer) == 0x000008, "Wrong size on RangedExplosive_Multicast_InitFromSpawningPlayer");
static_assert(offsetof(RangedExplosive_Multicast_InitFromSpawningPlayer, Spawner) == 0x000000, "Member 'RangedExplosive_Multicast_InitFromSpawningPlayer::Spawner' has a wrong offset!");

// Function DBDGameplay.RangedExplosive.OnFuseBurnUpdate
// 0x0008 (0x0008 - 0x0000)
struct RangedExplosive_OnFuseBurnUpdate final
{
public:
	float                                         DeltaSeconds;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FuseTimeLeftPercent;                               // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RangedExplosive_OnFuseBurnUpdate) == 0x000004, "Wrong alignment on RangedExplosive_OnFuseBurnUpdate");
static_assert(sizeof(RangedExplosive_OnFuseBurnUpdate) == 0x000008, "Wrong size on RangedExplosive_OnFuseBurnUpdate");
static_assert(offsetof(RangedExplosive_OnFuseBurnUpdate, DeltaSeconds) == 0x000000, "Member 'RangedExplosive_OnFuseBurnUpdate::DeltaSeconds' has a wrong offset!");
static_assert(offsetof(RangedExplosive_OnFuseBurnUpdate, FuseTimeLeftPercent) == 0x000004, "Member 'RangedExplosive_OnFuseBurnUpdate::FuseTimeLeftPercent' has a wrong offset!");

// Function DBDGameplay.RangedExplosive.GetExplosionEffectDuration
// 0x0004 (0x0004 - 0x0000)
struct RangedExplosive_GetExplosionEffectDuration final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RangedExplosive_GetExplosionEffectDuration) == 0x000004, "Wrong alignment on RangedExplosive_GetExplosionEffectDuration");
static_assert(sizeof(RangedExplosive_GetExplosionEffectDuration) == 0x000004, "Wrong size on RangedExplosive_GetExplosionEffectDuration");
static_assert(offsetof(RangedExplosive_GetExplosionEffectDuration, ReturnValue) == 0x000000, "Member 'RangedExplosive_GetExplosionEffectDuration::ReturnValue' has a wrong offset!");

// Function DBDGameplay.RangedExplosive.GetExplosionRange
// 0x0004 (0x0004 - 0x0000)
struct RangedExplosive_GetExplosionRange final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RangedExplosive_GetExplosionRange) == 0x000004, "Wrong alignment on RangedExplosive_GetExplosionRange");
static_assert(sizeof(RangedExplosive_GetExplosionRange) == 0x000004, "Wrong size on RangedExplosive_GetExplosionRange");
static_assert(offsetof(RangedExplosive_GetExplosionRange, ReturnValue) == 0x000000, "Member 'RangedExplosive_GetExplosionRange::ReturnValue' has a wrong offset!");

// Function DBDGameplay.RangedExplosive.GetModifierValue
// 0x0010 (0x0010 - 0x0000)
struct RangedExplosive_GetModifierValue final
{
public:
	struct FGameplayTag                           Type;                                              // 0x0000(0x000C)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RangedExplosive_GetModifierValue) == 0x000004, "Wrong alignment on RangedExplosive_GetModifierValue");
static_assert(sizeof(RangedExplosive_GetModifierValue) == 0x000010, "Wrong size on RangedExplosive_GetModifierValue");
static_assert(offsetof(RangedExplosive_GetModifierValue, Type) == 0x000000, "Member 'RangedExplosive_GetModifierValue::Type' has a wrong offset!");
static_assert(offsetof(RangedExplosive_GetModifierValue, ReturnValue) == 0x00000C, "Member 'RangedExplosive_GetModifierValue::ReturnValue' has a wrong offset!");

// Function DBDGameplay.RangedExplosive.GetOwningPlayer
// 0x0008 (0x0008 - 0x0000)
struct RangedExplosive_GetOwningPlayer final
{
public:
	class ADBDPlayer*                             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RangedExplosive_GetOwningPlayer) == 0x000008, "Wrong alignment on RangedExplosive_GetOwningPlayer");
static_assert(sizeof(RangedExplosive_GetOwningPlayer) == 0x000008, "Wrong size on RangedExplosive_GetOwningPlayer");
static_assert(offsetof(RangedExplosive_GetOwningPlayer, ReturnValue) == 0x000000, "Member 'RangedExplosive_GetOwningPlayer::ReturnValue' has a wrong offset!");

// Function DBDGameplay.RangedExplosive.GetRangedExplosiveActorEffect
// 0x0008 (0x0008 - 0x0000)
struct RangedExplosive_GetRangedExplosiveActorEffect final
{
public:
	class UBaseRangedExplosiveActorEffect*        ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RangedExplosive_GetRangedExplosiveActorEffect) == 0x000008, "Wrong alignment on RangedExplosive_GetRangedExplosiveActorEffect");
static_assert(sizeof(RangedExplosive_GetRangedExplosiveActorEffect) == 0x000008, "Wrong size on RangedExplosive_GetRangedExplosiveActorEffect");
static_assert(offsetof(RangedExplosive_GetRangedExplosiveActorEffect, ReturnValue) == 0x000000, "Member 'RangedExplosive_GetRangedExplosiveActorEffect::ReturnValue' has a wrong offset!");

// Function DBDGameplay.AimPointPerlinNoise.SetBaseInaccuracyNoiseAmplitude
// 0x0004 (0x0004 - 0x0000)
struct AimPointPerlinNoise_SetBaseInaccuracyNoiseAmplitude final
{
public:
	float                                         Amplitude;                                         // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AimPointPerlinNoise_SetBaseInaccuracyNoiseAmplitude) == 0x000004, "Wrong alignment on AimPointPerlinNoise_SetBaseInaccuracyNoiseAmplitude");
static_assert(sizeof(AimPointPerlinNoise_SetBaseInaccuracyNoiseAmplitude) == 0x000004, "Wrong size on AimPointPerlinNoise_SetBaseInaccuracyNoiseAmplitude");
static_assert(offsetof(AimPointPerlinNoise_SetBaseInaccuracyNoiseAmplitude, Amplitude) == 0x000000, "Member 'AimPointPerlinNoise_SetBaseInaccuracyNoiseAmplitude::Amplitude' has a wrong offset!");

// Function DBDGameplay.AimPointPerlinNoise.SetBaseInaccuracyNoiseFrequency
// 0x0004 (0x0004 - 0x0000)
struct AimPointPerlinNoise_SetBaseInaccuracyNoiseFrequency final
{
public:
	float                                         Frequency;                                         // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AimPointPerlinNoise_SetBaseInaccuracyNoiseFrequency) == 0x000004, "Wrong alignment on AimPointPerlinNoise_SetBaseInaccuracyNoiseFrequency");
static_assert(sizeof(AimPointPerlinNoise_SetBaseInaccuracyNoiseFrequency) == 0x000004, "Wrong size on AimPointPerlinNoise_SetBaseInaccuracyNoiseFrequency");
static_assert(offsetof(AimPointPerlinNoise_SetBaseInaccuracyNoiseFrequency, Frequency) == 0x000000, "Member 'AimPointPerlinNoise_SetBaseInaccuracyNoiseFrequency::Frequency' has a wrong offset!");

// Function DBDGameplay.AimPointPerlinNoise.SetBaseInaccuracyNoiseOctaveCount
// 0x0004 (0x0004 - 0x0000)
struct AimPointPerlinNoise_SetBaseInaccuracyNoiseOctaveCount final
{
public:
	int32                                         OctaveCount;                                       // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AimPointPerlinNoise_SetBaseInaccuracyNoiseOctaveCount) == 0x000004, "Wrong alignment on AimPointPerlinNoise_SetBaseInaccuracyNoiseOctaveCount");
static_assert(sizeof(AimPointPerlinNoise_SetBaseInaccuracyNoiseOctaveCount) == 0x000004, "Wrong size on AimPointPerlinNoise_SetBaseInaccuracyNoiseOctaveCount");
static_assert(offsetof(AimPointPerlinNoise_SetBaseInaccuracyNoiseOctaveCount, OctaveCount) == 0x000000, "Member 'AimPointPerlinNoise_SetBaseInaccuracyNoiseOctaveCount::OctaveCount' has a wrong offset!");

// Function DBDGameplay.AimPointPerlinNoise.SetBaseInaccuracyNoisePersistence
// 0x0004 (0x0004 - 0x0000)
struct AimPointPerlinNoise_SetBaseInaccuracyNoisePersistence final
{
public:
	float                                         NoisePersistence;                                  // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AimPointPerlinNoise_SetBaseInaccuracyNoisePersistence) == 0x000004, "Wrong alignment on AimPointPerlinNoise_SetBaseInaccuracyNoisePersistence");
static_assert(sizeof(AimPointPerlinNoise_SetBaseInaccuracyNoisePersistence) == 0x000004, "Wrong size on AimPointPerlinNoise_SetBaseInaccuracyNoisePersistence");
static_assert(offsetof(AimPointPerlinNoise_SetBaseInaccuracyNoisePersistence, NoisePersistence) == 0x000000, "Member 'AimPointPerlinNoise_SetBaseInaccuracyNoisePersistence::NoisePersistence' has a wrong offset!");

// Function DBDGameplay.AimPointPerlinNoise.SetNoiseAmplitudeMultiplier
// 0x0004 (0x0004 - 0x0000)
struct AimPointPerlinNoise_SetNoiseAmplitudeMultiplier final
{
public:
	float                                         Multiplier;                                        // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AimPointPerlinNoise_SetNoiseAmplitudeMultiplier) == 0x000004, "Wrong alignment on AimPointPerlinNoise_SetNoiseAmplitudeMultiplier");
static_assert(sizeof(AimPointPerlinNoise_SetNoiseAmplitudeMultiplier) == 0x000004, "Wrong size on AimPointPerlinNoise_SetNoiseAmplitudeMultiplier");
static_assert(offsetof(AimPointPerlinNoise_SetNoiseAmplitudeMultiplier, Multiplier) == 0x000000, "Member 'AimPointPerlinNoise_SetNoiseAmplitudeMultiplier::Multiplier' has a wrong offset!");

// Function DBDGameplay.AimPointPerlinNoise.SetNoiseFrequencyMultiplier
// 0x0004 (0x0004 - 0x0000)
struct AimPointPerlinNoise_SetNoiseFrequencyMultiplier final
{
public:
	float                                         Multiplier;                                        // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AimPointPerlinNoise_SetNoiseFrequencyMultiplier) == 0x000004, "Wrong alignment on AimPointPerlinNoise_SetNoiseFrequencyMultiplier");
static_assert(sizeof(AimPointPerlinNoise_SetNoiseFrequencyMultiplier) == 0x000004, "Wrong size on AimPointPerlinNoise_SetNoiseFrequencyMultiplier");
static_assert(offsetof(AimPointPerlinNoise_SetNoiseFrequencyMultiplier, Multiplier) == 0x000000, "Member 'AimPointPerlinNoise_SetNoiseFrequencyMultiplier::Multiplier' has a wrong offset!");

// Function DBDGameplay.KillerAbilityData.GetCooldown
// 0x0004 (0x0004 - 0x0000)
struct KillerAbilityData_GetCooldown final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KillerAbilityData_GetCooldown) == 0x000004, "Wrong alignment on KillerAbilityData_GetCooldown");
static_assert(sizeof(KillerAbilityData_GetCooldown) == 0x000004, "Wrong size on KillerAbilityData_GetCooldown");
static_assert(offsetof(KillerAbilityData_GetCooldown, ReturnValue) == 0x000000, "Member 'KillerAbilityData_GetCooldown::ReturnValue' has a wrong offset!");

// Function DBDGameplay.KillerAbilityData.GetDuration
// 0x0004 (0x0004 - 0x0000)
struct KillerAbilityData_GetDuration final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KillerAbilityData_GetDuration) == 0x000004, "Wrong alignment on KillerAbilityData_GetDuration");
static_assert(sizeof(KillerAbilityData_GetDuration) == 0x000004, "Wrong size on KillerAbilityData_GetDuration");
static_assert(offsetof(KillerAbilityData_GetDuration, ReturnValue) == 0x000000, "Member 'KillerAbilityData_GetDuration::ReturnValue' has a wrong offset!");

// Function DBDGameplay.KillerFormSwitchingAbility.Cosmetic_OnCurrentFormChanged
// 0x0001 (0x0001 - 0x0000)
struct KillerFormSwitchingAbility_Cosmetic_OnCurrentFormChanged final
{
public:
	bool                                          IsStartingForm;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KillerFormSwitchingAbility_Cosmetic_OnCurrentFormChanged) == 0x000001, "Wrong alignment on KillerFormSwitchingAbility_Cosmetic_OnCurrentFormChanged");
static_assert(sizeof(KillerFormSwitchingAbility_Cosmetic_OnCurrentFormChanged) == 0x000001, "Wrong size on KillerFormSwitchingAbility_Cosmetic_OnCurrentFormChanged");
static_assert(offsetof(KillerFormSwitchingAbility_Cosmetic_OnCurrentFormChanged, IsStartingForm) == 0x000000, "Member 'KillerFormSwitchingAbility_Cosmetic_OnCurrentFormChanged::IsStartingForm' has a wrong offset!");

// Function DBDGameplay.KillerFormSwitchingAbility.Cosmetic_OnEnterForm
// 0x0010 (0x0010 - 0x0000)
struct KillerFormSwitchingAbility_Cosmetic_OnEnterForm final
{
public:
	struct FGameplayTag                           FormID;                                            // 0x0000(0x000C)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsStartingForm;                                    // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KillerFormSwitchingAbility_Cosmetic_OnEnterForm) == 0x000004, "Wrong alignment on KillerFormSwitchingAbility_Cosmetic_OnEnterForm");
static_assert(sizeof(KillerFormSwitchingAbility_Cosmetic_OnEnterForm) == 0x000010, "Wrong size on KillerFormSwitchingAbility_Cosmetic_OnEnterForm");
static_assert(offsetof(KillerFormSwitchingAbility_Cosmetic_OnEnterForm, FormID) == 0x000000, "Member 'KillerFormSwitchingAbility_Cosmetic_OnEnterForm::FormID' has a wrong offset!");
static_assert(offsetof(KillerFormSwitchingAbility_Cosmetic_OnEnterForm, IsStartingForm) == 0x00000C, "Member 'KillerFormSwitchingAbility_Cosmetic_OnEnterForm::IsStartingForm' has a wrong offset!");

// Function DBDGameplay.KillerFormSwitchingAbility.Cosmetic_OnExitForm
// 0x000C (0x000C - 0x0000)
struct KillerFormSwitchingAbility_Cosmetic_OnExitForm final
{
public:
	struct FGameplayTag                           FormID;                                            // 0x0000(0x000C)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KillerFormSwitchingAbility_Cosmetic_OnExitForm) == 0x000004, "Wrong alignment on KillerFormSwitchingAbility_Cosmetic_OnExitForm");
static_assert(sizeof(KillerFormSwitchingAbility_Cosmetic_OnExitForm) == 0x00000C, "Wrong size on KillerFormSwitchingAbility_Cosmetic_OnExitForm");
static_assert(offsetof(KillerFormSwitchingAbility_Cosmetic_OnExitForm, FormID) == 0x000000, "Member 'KillerFormSwitchingAbility_Cosmetic_OnExitForm::FormID' has a wrong offset!");

// Function DBDGameplay.KillerFormSwitchingAbility.GetTransitionDuration
// 0x0004 (0x0004 - 0x0000)
struct KillerFormSwitchingAbility_GetTransitionDuration final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KillerFormSwitchingAbility_GetTransitionDuration) == 0x000004, "Wrong alignment on KillerFormSwitchingAbility_GetTransitionDuration");
static_assert(sizeof(KillerFormSwitchingAbility_GetTransitionDuration) == 0x000004, "Wrong size on KillerFormSwitchingAbility_GetTransitionDuration");
static_assert(offsetof(KillerFormSwitchingAbility_GetTransitionDuration, ReturnValue) == 0x000000, "Member 'KillerFormSwitchingAbility_GetTransitionDuration::ReturnValue' has a wrong offset!");

// Function DBDGameplay.KillerFormSwitchingAbility.OnRep_CurrentFormID
// 0x000C (0x000C - 0x0000)
struct KillerFormSwitchingAbility_OnRep_CurrentFormID final
{
public:
	struct FGameplayTag                           OldFormId;                                         // 0x0000(0x000C)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KillerFormSwitchingAbility_OnRep_CurrentFormID) == 0x000004, "Wrong alignment on KillerFormSwitchingAbility_OnRep_CurrentFormID");
static_assert(sizeof(KillerFormSwitchingAbility_OnRep_CurrentFormID) == 0x00000C, "Wrong size on KillerFormSwitchingAbility_OnRep_CurrentFormID");
static_assert(offsetof(KillerFormSwitchingAbility_OnRep_CurrentFormID, OldFormId) == 0x000000, "Member 'KillerFormSwitchingAbility_OnRep_CurrentFormID::OldFormId' has a wrong offset!");

// Function DBDGameplay.KillerFormSwitchingAbility.GetCurrentFormID
// 0x000C (0x000C - 0x0000)
struct KillerFormSwitchingAbility_GetCurrentFormID final
{
public:
	struct FGameplayTag                           ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KillerFormSwitchingAbility_GetCurrentFormID) == 0x000004, "Wrong alignment on KillerFormSwitchingAbility_GetCurrentFormID");
static_assert(sizeof(KillerFormSwitchingAbility_GetCurrentFormID) == 0x00000C, "Wrong size on KillerFormSwitchingAbility_GetCurrentFormID");
static_assert(offsetof(KillerFormSwitchingAbility_GetCurrentFormID, ReturnValue) == 0x000000, "Member 'KillerFormSwitchingAbility_GetCurrentFormID::ReturnValue' has a wrong offset!");

// Function DBDGameplay.AimableComponent.SetMaxAimDistance
// 0x0004 (0x0004 - 0x0000)
struct AimableComponent_SetMaxAimDistance final
{
public:
	float                                         MaxAimDistance;                                    // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AimableComponent_SetMaxAimDistance) == 0x000004, "Wrong alignment on AimableComponent_SetMaxAimDistance");
static_assert(sizeof(AimableComponent_SetMaxAimDistance) == 0x000004, "Wrong size on AimableComponent_SetMaxAimDistance");
static_assert(offsetof(AimableComponent_SetMaxAimDistance, MaxAimDistance) == 0x000000, "Member 'AimableComponent_SetMaxAimDistance::MaxAimDistance' has a wrong offset!");

// Function DBDGameplay.AimableComponent.SetOcclusionIgnoredActors
// 0x0010 (0x0010 - 0x0000)
struct AimableComponent_SetOcclusionIgnoredActors final
{
public:
	TArray<class AActor*>                         IgnoredActors;                                     // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(AimableComponent_SetOcclusionIgnoredActors) == 0x000008, "Wrong alignment on AimableComponent_SetOcclusionIgnoredActors");
static_assert(sizeof(AimableComponent_SetOcclusionIgnoredActors) == 0x000010, "Wrong size on AimableComponent_SetOcclusionIgnoredActors");
static_assert(offsetof(AimableComponent_SetOcclusionIgnoredActors, IgnoredActors) == 0x000000, "Member 'AimableComponent_SetOcclusionIgnoredActors::IgnoredActors' has a wrong offset!");

// Function DBDGameplay.AimableComponent.SetProcessors
// 0x0010 (0x0010 - 0x0000)
struct AimableComponent_SetProcessors final
{
public:
	TArray<class UAimPointProcessor*>             Processors;                                        // 0x0000(0x0010)(Parm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(AimableComponent_SetProcessors) == 0x000008, "Wrong alignment on AimableComponent_SetProcessors");
static_assert(sizeof(AimableComponent_SetProcessors) == 0x000010, "Wrong size on AimableComponent_SetProcessors");
static_assert(offsetof(AimableComponent_SetProcessors, Processors) == 0x000000, "Member 'AimableComponent_SetProcessors::Processors' has a wrong offset!");

// Function DBDGameplay.TerrorRadiusEmitterComponent.SetEmitterActive
// 0x0001 (0x0001 - 0x0000)
struct TerrorRadiusEmitterComponent_SetEmitterActive final
{
public:
	bool                                          Active;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TerrorRadiusEmitterComponent_SetEmitterActive) == 0x000001, "Wrong alignment on TerrorRadiusEmitterComponent_SetEmitterActive");
static_assert(sizeof(TerrorRadiusEmitterComponent_SetEmitterActive) == 0x000001, "Wrong size on TerrorRadiusEmitterComponent_SetEmitterActive");
static_assert(offsetof(TerrorRadiusEmitterComponent_SetEmitterActive, Active) == 0x000000, "Member 'TerrorRadiusEmitterComponent_SetEmitterActive::Active' has a wrong offset!");

// Function DBDGameplay.TerrorRadiusEmitterComponent.SetImitatesAudioOnly
// 0x0001 (0x0001 - 0x0000)
struct TerrorRadiusEmitterComponent_SetImitatesAudioOnly final
{
public:
	bool                                          ImitatesAudioOnly;                                 // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TerrorRadiusEmitterComponent_SetImitatesAudioOnly) == 0x000001, "Wrong alignment on TerrorRadiusEmitterComponent_SetImitatesAudioOnly");
static_assert(sizeof(TerrorRadiusEmitterComponent_SetImitatesAudioOnly) == 0x000001, "Wrong size on TerrorRadiusEmitterComponent_SetImitatesAudioOnly");
static_assert(offsetof(TerrorRadiusEmitterComponent_SetImitatesAudioOnly, ImitatesAudioOnly) == 0x000000, "Member 'TerrorRadiusEmitterComponent_SetImitatesAudioOnly::ImitatesAudioOnly' has a wrong offset!");

// Function DBDGameplay.TerrorRadiusEmitterComponent.SetIsFakeTerrorRadius
// 0x0001 (0x0001 - 0x0000)
struct TerrorRadiusEmitterComponent_SetIsFakeTerrorRadius final
{
public:
	bool                                          Value;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TerrorRadiusEmitterComponent_SetIsFakeTerrorRadius) == 0x000001, "Wrong alignment on TerrorRadiusEmitterComponent_SetIsFakeTerrorRadius");
static_assert(sizeof(TerrorRadiusEmitterComponent_SetIsFakeTerrorRadius) == 0x000001, "Wrong size on TerrorRadiusEmitterComponent_SetIsFakeTerrorRadius");
static_assert(offsetof(TerrorRadiusEmitterComponent_SetIsFakeTerrorRadius, Value) == 0x000000, "Member 'TerrorRadiusEmitterComponent_SetIsFakeTerrorRadius::Value' has a wrong offset!");

// Function DBDGameplay.TerrorRadiusEmitterComponent.SetSimulatedFixedDistance
// 0x0004 (0x0004 - 0x0000)
struct TerrorRadiusEmitterComponent_SetSimulatedFixedDistance final
{
public:
	float                                         Distance;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TerrorRadiusEmitterComponent_SetSimulatedFixedDistance) == 0x000004, "Wrong alignment on TerrorRadiusEmitterComponent_SetSimulatedFixedDistance");
static_assert(sizeof(TerrorRadiusEmitterComponent_SetSimulatedFixedDistance) == 0x000004, "Wrong size on TerrorRadiusEmitterComponent_SetSimulatedFixedDistance");
static_assert(offsetof(TerrorRadiusEmitterComponent_SetSimulatedFixedDistance, Distance) == 0x000000, "Member 'TerrorRadiusEmitterComponent_SetSimulatedFixedDistance::Distance' has a wrong offset!");

// Function DBDGameplay.TerrorRadiusEmitterComponent.SetTerrorRadius
// 0x0004 (0x0004 - 0x0000)
struct TerrorRadiusEmitterComponent_SetTerrorRadius final
{
public:
	float                                         Radius;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TerrorRadiusEmitterComponent_SetTerrorRadius) == 0x000004, "Wrong alignment on TerrorRadiusEmitterComponent_SetTerrorRadius");
static_assert(sizeof(TerrorRadiusEmitterComponent_SetTerrorRadius) == 0x000004, "Wrong size on TerrorRadiusEmitterComponent_SetTerrorRadius");
static_assert(offsetof(TerrorRadiusEmitterComponent_SetTerrorRadius, Radius) == 0x000000, "Member 'TerrorRadiusEmitterComponent_SetTerrorRadius::Radius' has a wrong offset!");

// Function DBDGameplay.TerrorRadiusEmitterComponent.GetImitatesAudioOnly
// 0x0001 (0x0001 - 0x0000)
struct TerrorRadiusEmitterComponent_GetImitatesAudioOnly final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TerrorRadiusEmitterComponent_GetImitatesAudioOnly) == 0x000001, "Wrong alignment on TerrorRadiusEmitterComponent_GetImitatesAudioOnly");
static_assert(sizeof(TerrorRadiusEmitterComponent_GetImitatesAudioOnly) == 0x000001, "Wrong size on TerrorRadiusEmitterComponent_GetImitatesAudioOnly");
static_assert(offsetof(TerrorRadiusEmitterComponent_GetImitatesAudioOnly, ReturnValue) == 0x000000, "Member 'TerrorRadiusEmitterComponent_GetImitatesAudioOnly::ReturnValue' has a wrong offset!");

// Function DBDGameplay.TerrorRadiusEmitterComponent.GetIsActive
// 0x0001 (0x0001 - 0x0000)
struct TerrorRadiusEmitterComponent_GetIsActive final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TerrorRadiusEmitterComponent_GetIsActive) == 0x000001, "Wrong alignment on TerrorRadiusEmitterComponent_GetIsActive");
static_assert(sizeof(TerrorRadiusEmitterComponent_GetIsActive) == 0x000001, "Wrong size on TerrorRadiusEmitterComponent_GetIsActive");
static_assert(offsetof(TerrorRadiusEmitterComponent_GetIsActive, ReturnValue) == 0x000000, "Member 'TerrorRadiusEmitterComponent_GetIsActive::ReturnValue' has a wrong offset!");

// Function DBDGameplay.TerrorRadiusEmitterComponent.GetRadius
// 0x0004 (0x0004 - 0x0000)
struct TerrorRadiusEmitterComponent_GetRadius final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TerrorRadiusEmitterComponent_GetRadius) == 0x000004, "Wrong alignment on TerrorRadiusEmitterComponent_GetRadius");
static_assert(sizeof(TerrorRadiusEmitterComponent_GetRadius) == 0x000004, "Wrong size on TerrorRadiusEmitterComponent_GetRadius");
static_assert(offsetof(TerrorRadiusEmitterComponent_GetRadius, ReturnValue) == 0x000000, "Member 'TerrorRadiusEmitterComponent_GetRadius::ReturnValue' has a wrong offset!");

// Function DBDGameplay.TerrorRadiusEmitterComponent.GetSimulatedFixedDistance
// 0x0004 (0x0004 - 0x0000)
struct TerrorRadiusEmitterComponent_GetSimulatedFixedDistance final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TerrorRadiusEmitterComponent_GetSimulatedFixedDistance) == 0x000004, "Wrong alignment on TerrorRadiusEmitterComponent_GetSimulatedFixedDistance");
static_assert(sizeof(TerrorRadiusEmitterComponent_GetSimulatedFixedDistance) == 0x000004, "Wrong size on TerrorRadiusEmitterComponent_GetSimulatedFixedDistance");
static_assert(offsetof(TerrorRadiusEmitterComponent_GetSimulatedFixedDistance, ReturnValue) == 0x000000, "Member 'TerrorRadiusEmitterComponent_GetSimulatedFixedDistance::ReturnValue' has a wrong offset!");

// Function DBDGameplay.TerrorRadiusEmitterComponent.IsInTerrorRadius
// 0x0010 (0x0010 - 0x0000)
struct TerrorRadiusEmitterComponent_IsInTerrorRadius final
{
public:
	class UTerrorRadiusReceiverComponent*         Receiver;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(TerrorRadiusEmitterComponent_IsInTerrorRadius) == 0x000008, "Wrong alignment on TerrorRadiusEmitterComponent_IsInTerrorRadius");
static_assert(sizeof(TerrorRadiusEmitterComponent_IsInTerrorRadius) == 0x000010, "Wrong size on TerrorRadiusEmitterComponent_IsInTerrorRadius");
static_assert(offsetof(TerrorRadiusEmitterComponent_IsInTerrorRadius, Receiver) == 0x000000, "Member 'TerrorRadiusEmitterComponent_IsInTerrorRadius::Receiver' has a wrong offset!");
static_assert(offsetof(TerrorRadiusEmitterComponent_IsInTerrorRadius, ReturnValue) == 0x000008, "Member 'TerrorRadiusEmitterComponent_IsInTerrorRadius::ReturnValue' has a wrong offset!");

// Function DBDGameplay.SlasherTerrorRadiusEmitterComponent.SetBaseTerrorRadius
// 0x0008 (0x0008 - 0x0000)
struct SlasherTerrorRadiusEmitterComponent_SetBaseTerrorRadius final
{
public:
	float                                         baseTerrorRadius;                                  // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Progressive;                                       // 0x0004(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SlasherTerrorRadiusEmitterComponent_SetBaseTerrorRadius) == 0x000004, "Wrong alignment on SlasherTerrorRadiusEmitterComponent_SetBaseTerrorRadius");
static_assert(sizeof(SlasherTerrorRadiusEmitterComponent_SetBaseTerrorRadius) == 0x000008, "Wrong size on SlasherTerrorRadiusEmitterComponent_SetBaseTerrorRadius");
static_assert(offsetof(SlasherTerrorRadiusEmitterComponent_SetBaseTerrorRadius, baseTerrorRadius) == 0x000000, "Member 'SlasherTerrorRadiusEmitterComponent_SetBaseTerrorRadius::baseTerrorRadius' has a wrong offset!");
static_assert(offsetof(SlasherTerrorRadiusEmitterComponent_SetBaseTerrorRadius, Progressive) == 0x000004, "Member 'SlasherTerrorRadiusEmitterComponent_SetBaseTerrorRadius::Progressive' has a wrong offset!");

// Function DBDGameplay.AISense_Terror.ReportTerrorEvent
// 0x0030 (0x0030 - 0x0000)
struct AISense_Terror_ReportTerrorEvent final
{
public:
	class UObject*                                WorldContextObj;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0008(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Instigator;                                        // 0x0020(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTerrorRadiusEmitterComponent*          TerrorEmitter;                                     // 0x0028(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AISense_Terror_ReportTerrorEvent) == 0x000008, "Wrong alignment on AISense_Terror_ReportTerrorEvent");
static_assert(sizeof(AISense_Terror_ReportTerrorEvent) == 0x000030, "Wrong size on AISense_Terror_ReportTerrorEvent");
static_assert(offsetof(AISense_Terror_ReportTerrorEvent, WorldContextObj) == 0x000000, "Member 'AISense_Terror_ReportTerrorEvent::WorldContextObj' has a wrong offset!");
static_assert(offsetof(AISense_Terror_ReportTerrorEvent, Location) == 0x000008, "Member 'AISense_Terror_ReportTerrorEvent::Location' has a wrong offset!");
static_assert(offsetof(AISense_Terror_ReportTerrorEvent, Instigator) == 0x000020, "Member 'AISense_Terror_ReportTerrorEvent::Instigator' has a wrong offset!");
static_assert(offsetof(AISense_Terror_ReportTerrorEvent, TerrorEmitter) == 0x000028, "Member 'AISense_Terror_ReportTerrorEvent::TerrorEmitter' has a wrong offset!");

// Function DBDGameplay.BubbleIndicator.ActivateBubbleFX
// 0x0004 (0x0004 - 0x0000)
struct BubbleIndicator_ActivateBubbleFX final
{
public:
	float                                         Duration;                                          // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BubbleIndicator_ActivateBubbleFX) == 0x000004, "Wrong alignment on BubbleIndicator_ActivateBubbleFX");
static_assert(sizeof(BubbleIndicator_ActivateBubbleFX) == 0x000004, "Wrong size on BubbleIndicator_ActivateBubbleFX");
static_assert(offsetof(BubbleIndicator_ActivateBubbleFX, Duration) == 0x000000, "Member 'BubbleIndicator_ActivateBubbleFX::Duration' has a wrong offset!");

// Function DBDGameplay.BubbleIndicator.RefreshBubbleVisibility
// 0x0001 (0x0001 - 0x0000)
struct BubbleIndicator_RefreshBubbleVisibility final
{
public:
	bool                                          IsVisible;                                         // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BubbleIndicator_RefreshBubbleVisibility) == 0x000001, "Wrong alignment on BubbleIndicator_RefreshBubbleVisibility");
static_assert(sizeof(BubbleIndicator_RefreshBubbleVisibility) == 0x000001, "Wrong size on BubbleIndicator_RefreshBubbleVisibility");
static_assert(offsetof(BubbleIndicator_RefreshBubbleVisibility, IsVisible) == 0x000000, "Member 'BubbleIndicator_RefreshBubbleVisibility::IsVisible' has a wrong offset!");

// Function DBDGameplay.BubbleIndicator.SetSilhouette
// 0x0008 (0x0008 - 0x0000)
struct BubbleIndicator_SetSilhouette final
{
public:
	class UStaticMesh*                            StaticMesh;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BubbleIndicator_SetSilhouette) == 0x000008, "Wrong alignment on BubbleIndicator_SetSilhouette");
static_assert(sizeof(BubbleIndicator_SetSilhouette) == 0x000008, "Wrong size on BubbleIndicator_SetSilhouette");
static_assert(offsetof(BubbleIndicator_SetSilhouette, StaticMesh) == 0x000000, "Member 'BubbleIndicator_SetSilhouette::StaticMesh' has a wrong offset!");

// Function DBDGameplay.BubbleIndicatorNotifier.ActivateBubbleIndicator
// 0x0080 (0x0080 - 0x0000)
struct BubbleIndicatorNotifier_ActivateBubbleIndicator final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ABubbleIndicator*                       BubbleIndicator;                                   // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             Transform;                                         // 0x0010(0x0060)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TriggerLoudNoise;                                  // 0x0070(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x3];                                       // 0x0071(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Lifetime;                                          // 0x0074(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AudibleRange;                                      // 0x0078(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BubbleIndicatorNotifier_ActivateBubbleIndicator) == 0x000010, "Wrong alignment on BubbleIndicatorNotifier_ActivateBubbleIndicator");
static_assert(sizeof(BubbleIndicatorNotifier_ActivateBubbleIndicator) == 0x000080, "Wrong size on BubbleIndicatorNotifier_ActivateBubbleIndicator");
static_assert(offsetof(BubbleIndicatorNotifier_ActivateBubbleIndicator, WorldContextObject) == 0x000000, "Member 'BubbleIndicatorNotifier_ActivateBubbleIndicator::WorldContextObject' has a wrong offset!");
static_assert(offsetof(BubbleIndicatorNotifier_ActivateBubbleIndicator, BubbleIndicator) == 0x000008, "Member 'BubbleIndicatorNotifier_ActivateBubbleIndicator::BubbleIndicator' has a wrong offset!");
static_assert(offsetof(BubbleIndicatorNotifier_ActivateBubbleIndicator, Transform) == 0x000010, "Member 'BubbleIndicatorNotifier_ActivateBubbleIndicator::Transform' has a wrong offset!");
static_assert(offsetof(BubbleIndicatorNotifier_ActivateBubbleIndicator, TriggerLoudNoise) == 0x000070, "Member 'BubbleIndicatorNotifier_ActivateBubbleIndicator::TriggerLoudNoise' has a wrong offset!");
static_assert(offsetof(BubbleIndicatorNotifier_ActivateBubbleIndicator, Lifetime) == 0x000074, "Member 'BubbleIndicatorNotifier_ActivateBubbleIndicator::Lifetime' has a wrong offset!");
static_assert(offsetof(BubbleIndicatorNotifier_ActivateBubbleIndicator, AudibleRange) == 0x000078, "Member 'BubbleIndicatorNotifier_ActivateBubbleIndicator::AudibleRange' has a wrong offset!");

// Function DBDGameplay.BubbleIndicatorNotifier.PreSpawnBubbleIndicator
// 0x0020 (0x0020 - 0x0000)
struct BubbleIndicatorNotifier_PreSpawnBubbleIndicator final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ABubbleIndicator>           bubbleIndicatorBP;                                 // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            SilhouetteStaticMesh;                              // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ABubbleIndicator*                       ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BubbleIndicatorNotifier_PreSpawnBubbleIndicator) == 0x000008, "Wrong alignment on BubbleIndicatorNotifier_PreSpawnBubbleIndicator");
static_assert(sizeof(BubbleIndicatorNotifier_PreSpawnBubbleIndicator) == 0x000020, "Wrong size on BubbleIndicatorNotifier_PreSpawnBubbleIndicator");
static_assert(offsetof(BubbleIndicatorNotifier_PreSpawnBubbleIndicator, WorldContextObject) == 0x000000, "Member 'BubbleIndicatorNotifier_PreSpawnBubbleIndicator::WorldContextObject' has a wrong offset!");
static_assert(offsetof(BubbleIndicatorNotifier_PreSpawnBubbleIndicator, bubbleIndicatorBP) == 0x000008, "Member 'BubbleIndicatorNotifier_PreSpawnBubbleIndicator::bubbleIndicatorBP' has a wrong offset!");
static_assert(offsetof(BubbleIndicatorNotifier_PreSpawnBubbleIndicator, SilhouetteStaticMesh) == 0x000010, "Member 'BubbleIndicatorNotifier_PreSpawnBubbleIndicator::SilhouetteStaticMesh' has a wrong offset!");
static_assert(offsetof(BubbleIndicatorNotifier_PreSpawnBubbleIndicator, ReturnValue) == 0x000018, "Member 'BubbleIndicatorNotifier_PreSpawnBubbleIndicator::ReturnValue' has a wrong offset!");

// Function DBDGameplay.BubbleIndicatorNotifier.SpawnBubbleIndicator
// 0x0090 (0x0090 - 0x0000)
struct BubbleIndicatorNotifier_SpawnBubbleIndicator final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ABubbleIndicator>           bubbleIndicatorBP;                                 // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             Transform;                                         // 0x0010(0x0060)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TriggerLoudNoise;                                  // 0x0070(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBubbleShowedPlayerType                       ShowedPlayerType;                                  // 0x0071(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_72[0x2];                                       // 0x0072(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Lifetime;                                          // 0x0074(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            SilhouetteStaticMesh;                              // 0x0078(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AudibleRange;                                      // 0x0080(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_84[0xC];                                       // 0x0084(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BubbleIndicatorNotifier_SpawnBubbleIndicator) == 0x000010, "Wrong alignment on BubbleIndicatorNotifier_SpawnBubbleIndicator");
static_assert(sizeof(BubbleIndicatorNotifier_SpawnBubbleIndicator) == 0x000090, "Wrong size on BubbleIndicatorNotifier_SpawnBubbleIndicator");
static_assert(offsetof(BubbleIndicatorNotifier_SpawnBubbleIndicator, WorldContextObject) == 0x000000, "Member 'BubbleIndicatorNotifier_SpawnBubbleIndicator::WorldContextObject' has a wrong offset!");
static_assert(offsetof(BubbleIndicatorNotifier_SpawnBubbleIndicator, bubbleIndicatorBP) == 0x000008, "Member 'BubbleIndicatorNotifier_SpawnBubbleIndicator::bubbleIndicatorBP' has a wrong offset!");
static_assert(offsetof(BubbleIndicatorNotifier_SpawnBubbleIndicator, Transform) == 0x000010, "Member 'BubbleIndicatorNotifier_SpawnBubbleIndicator::Transform' has a wrong offset!");
static_assert(offsetof(BubbleIndicatorNotifier_SpawnBubbleIndicator, TriggerLoudNoise) == 0x000070, "Member 'BubbleIndicatorNotifier_SpawnBubbleIndicator::TriggerLoudNoise' has a wrong offset!");
static_assert(offsetof(BubbleIndicatorNotifier_SpawnBubbleIndicator, ShowedPlayerType) == 0x000071, "Member 'BubbleIndicatorNotifier_SpawnBubbleIndicator::ShowedPlayerType' has a wrong offset!");
static_assert(offsetof(BubbleIndicatorNotifier_SpawnBubbleIndicator, Lifetime) == 0x000074, "Member 'BubbleIndicatorNotifier_SpawnBubbleIndicator::Lifetime' has a wrong offset!");
static_assert(offsetof(BubbleIndicatorNotifier_SpawnBubbleIndicator, SilhouetteStaticMesh) == 0x000078, "Member 'BubbleIndicatorNotifier_SpawnBubbleIndicator::SilhouetteStaticMesh' has a wrong offset!");
static_assert(offsetof(BubbleIndicatorNotifier_SpawnBubbleIndicator, AudibleRange) == 0x000080, "Member 'BubbleIndicatorNotifier_SpawnBubbleIndicator::AudibleRange' has a wrong offset!");

// Function DBDGameplay.CageHookPoolComponent.Multicast_SpawnTrapBlocker
// 0x0028 (0x0028 - 0x0000)
struct CageHookPoolComponent_Multicast_SpawnTrapBlocker final
{
public:
	TArray<struct FTransform>                     SpawnLocations;                                    // 0x0000(0x0010)(ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	struct FVector                                BoxExtent;                                         // 0x0010(0x0018)(ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CageHookPoolComponent_Multicast_SpawnTrapBlocker) == 0x000008, "Wrong alignment on CageHookPoolComponent_Multicast_SpawnTrapBlocker");
static_assert(sizeof(CageHookPoolComponent_Multicast_SpawnTrapBlocker) == 0x000028, "Wrong size on CageHookPoolComponent_Multicast_SpawnTrapBlocker");
static_assert(offsetof(CageHookPoolComponent_Multicast_SpawnTrapBlocker, SpawnLocations) == 0x000000, "Member 'CageHookPoolComponent_Multicast_SpawnTrapBlocker::SpawnLocations' has a wrong offset!");
static_assert(offsetof(CageHookPoolComponent_Multicast_SpawnTrapBlocker, BoxExtent) == 0x000010, "Member 'CageHookPoolComponent_Multicast_SpawnTrapBlocker::BoxExtent' has a wrong offset!");

// Function DBDGameplay.SightRevealableComponent.Authority_IsBeingRevealed
// 0x0001 (0x0001 - 0x0000)
struct SightRevealableComponent_Authority_IsBeingRevealed final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SightRevealableComponent_Authority_IsBeingRevealed) == 0x000001, "Wrong alignment on SightRevealableComponent_Authority_IsBeingRevealed");
static_assert(sizeof(SightRevealableComponent_Authority_IsBeingRevealed) == 0x000001, "Wrong size on SightRevealableComponent_Authority_IsBeingRevealed");
static_assert(offsetof(SightRevealableComponent_Authority_IsBeingRevealed, ReturnValue) == 0x000000, "Member 'SightRevealableComponent_Authority_IsBeingRevealed::ReturnValue' has a wrong offset!");

// Function DBDGameplay.CamperFootstepCreatorComponent.OnLoudNoiseTriggered
// 0x0038 (0x0038 - 0x0000)
struct CamperFootstepCreatorComponent_OnLoudNoiseTriggered final
{
public:
	class AActor*                                 Originator;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 InstigatingActor;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0010(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShouldTrack;                                       // 0x0028(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AudibleRange;                                      // 0x002C(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsQuickAction;                                     // 0x0030(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsDeceivingNoise;                                  // 0x0031(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x6];                                       // 0x0032(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CamperFootstepCreatorComponent_OnLoudNoiseTriggered) == 0x000008, "Wrong alignment on CamperFootstepCreatorComponent_OnLoudNoiseTriggered");
static_assert(sizeof(CamperFootstepCreatorComponent_OnLoudNoiseTriggered) == 0x000038, "Wrong size on CamperFootstepCreatorComponent_OnLoudNoiseTriggered");
static_assert(offsetof(CamperFootstepCreatorComponent_OnLoudNoiseTriggered, Originator) == 0x000000, "Member 'CamperFootstepCreatorComponent_OnLoudNoiseTriggered::Originator' has a wrong offset!");
static_assert(offsetof(CamperFootstepCreatorComponent_OnLoudNoiseTriggered, InstigatingActor) == 0x000008, "Member 'CamperFootstepCreatorComponent_OnLoudNoiseTriggered::InstigatingActor' has a wrong offset!");
static_assert(offsetof(CamperFootstepCreatorComponent_OnLoudNoiseTriggered, Location) == 0x000010, "Member 'CamperFootstepCreatorComponent_OnLoudNoiseTriggered::Location' has a wrong offset!");
static_assert(offsetof(CamperFootstepCreatorComponent_OnLoudNoiseTriggered, ShouldTrack) == 0x000028, "Member 'CamperFootstepCreatorComponent_OnLoudNoiseTriggered::ShouldTrack' has a wrong offset!");
static_assert(offsetof(CamperFootstepCreatorComponent_OnLoudNoiseTriggered, AudibleRange) == 0x00002C, "Member 'CamperFootstepCreatorComponent_OnLoudNoiseTriggered::AudibleRange' has a wrong offset!");
static_assert(offsetof(CamperFootstepCreatorComponent_OnLoudNoiseTriggered, IsQuickAction) == 0x000030, "Member 'CamperFootstepCreatorComponent_OnLoudNoiseTriggered::IsQuickAction' has a wrong offset!");
static_assert(offsetof(CamperFootstepCreatorComponent_OnLoudNoiseTriggered, IsDeceivingNoise) == 0x000031, "Member 'CamperFootstepCreatorComponent_OnLoudNoiseTriggered::IsDeceivingNoise' has a wrong offset!");

// Function DBDGameplay.CollectableComponentUtilities.GetCollector
// 0x0010 (0x0010 - 0x0000)
struct CollectableComponentUtilities_GetCollector final
{
public:
	const class UActorComponent*                  Component;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ADBDPlayer*                             ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CollectableComponentUtilities_GetCollector) == 0x000008, "Wrong alignment on CollectableComponentUtilities_GetCollector");
static_assert(sizeof(CollectableComponentUtilities_GetCollector) == 0x000010, "Wrong size on CollectableComponentUtilities_GetCollector");
static_assert(offsetof(CollectableComponentUtilities_GetCollector, Component) == 0x000000, "Member 'CollectableComponentUtilities_GetCollector::Component' has a wrong offset!");
static_assert(offsetof(CollectableComponentUtilities_GetCollector, ReturnValue) == 0x000008, "Member 'CollectableComponentUtilities_GetCollector::ReturnValue' has a wrong offset!");

// Function DBDGameplay.DecoySlasherComponent.DoPostVFXUpdates
// 0x0030 (0x0030 - 0x0000)
struct DecoySlasherComponent_DoPostVFXUpdates final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0018(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(DecoySlasherComponent_DoPostVFXUpdates) == 0x000008, "Wrong alignment on DecoySlasherComponent_DoPostVFXUpdates");
static_assert(sizeof(DecoySlasherComponent_DoPostVFXUpdates) == 0x000030, "Wrong size on DecoySlasherComponent_DoPostVFXUpdates");
static_assert(offsetof(DecoySlasherComponent_DoPostVFXUpdates, Location) == 0x000000, "Member 'DecoySlasherComponent_DoPostVFXUpdates::Location' has a wrong offset!");
static_assert(offsetof(DecoySlasherComponent_DoPostVFXUpdates, Rotation) == 0x000018, "Member 'DecoySlasherComponent_DoPostVFXUpdates::Rotation' has a wrong offset!");

// Function DBDGameplay.DecoySlasherComponent.OnRealSlasherTerrorRadiusChanged
// 0x0004 (0x0004 - 0x0000)
struct DecoySlasherComponent_OnRealSlasherTerrorRadiusChanged final
{
public:
	float                                         NewValue;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DecoySlasherComponent_OnRealSlasherTerrorRadiusChanged) == 0x000004, "Wrong alignment on DecoySlasherComponent_OnRealSlasherTerrorRadiusChanged");
static_assert(sizeof(DecoySlasherComponent_OnRealSlasherTerrorRadiusChanged) == 0x000004, "Wrong size on DecoySlasherComponent_OnRealSlasherTerrorRadiusChanged");
static_assert(offsetof(DecoySlasherComponent_OnRealSlasherTerrorRadiusChanged, NewValue) == 0x000000, "Member 'DecoySlasherComponent_OnRealSlasherTerrorRadiusChanged::NewValue' has a wrong offset!");

// Function DBDGameplay.DecoySlasherComponent.SetDecoyIsActive
// 0x0040 (0x0040 - 0x0000)
struct DecoySlasherComponent_SetDecoyIsActive final
{
public:
	bool                                          Param_IsActive;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Location;                                          // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0020(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          VisibleRedGlow;                                    // 0x0038(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DecoySlasherComponent_SetDecoyIsActive) == 0x000008, "Wrong alignment on DecoySlasherComponent_SetDecoyIsActive");
static_assert(sizeof(DecoySlasherComponent_SetDecoyIsActive) == 0x000040, "Wrong size on DecoySlasherComponent_SetDecoyIsActive");
static_assert(offsetof(DecoySlasherComponent_SetDecoyIsActive, Param_IsActive) == 0x000000, "Member 'DecoySlasherComponent_SetDecoyIsActive::Param_IsActive' has a wrong offset!");
static_assert(offsetof(DecoySlasherComponent_SetDecoyIsActive, Location) == 0x000008, "Member 'DecoySlasherComponent_SetDecoyIsActive::Location' has a wrong offset!");
static_assert(offsetof(DecoySlasherComponent_SetDecoyIsActive, Rotation) == 0x000020, "Member 'DecoySlasherComponent_SetDecoyIsActive::Rotation' has a wrong offset!");
static_assert(offsetof(DecoySlasherComponent_SetDecoyIsActive, VisibleRedGlow) == 0x000038, "Member 'DecoySlasherComponent_SetDecoyIsActive::VisibleRedGlow' has a wrong offset!");

// Function DBDGameplay.DecoySlasherComponent.GetRealSlasher
// 0x0008 (0x0008 - 0x0000)
struct DecoySlasherComponent_GetRealSlasher final
{
public:
	class ASlasherPlayer*                         ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DecoySlasherComponent_GetRealSlasher) == 0x000008, "Wrong alignment on DecoySlasherComponent_GetRealSlasher");
static_assert(sizeof(DecoySlasherComponent_GetRealSlasher) == 0x000008, "Wrong size on DecoySlasherComponent_GetRealSlasher");
static_assert(offsetof(DecoySlasherComponent_GetRealSlasher, ReturnValue) == 0x000000, "Member 'DecoySlasherComponent_GetRealSlasher::ReturnValue' has a wrong offset!");

// Function DBDGameplay.DecoySlasherComponent.IsDecoyActive
// 0x0001 (0x0001 - 0x0000)
struct DecoySlasherComponent_IsDecoyActive final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DecoySlasherComponent_IsDecoyActive) == 0x000001, "Wrong alignment on DecoySlasherComponent_IsDecoyActive");
static_assert(sizeof(DecoySlasherComponent_IsDecoyActive) == 0x000001, "Wrong size on DecoySlasherComponent_IsDecoyActive");
static_assert(offsetof(DecoySlasherComponent_IsDecoyActive, ReturnValue) == 0x000000, "Member 'DecoySlasherComponent_IsDecoyActive::ReturnValue' has a wrong offset!");

// Function DBDGameplay.EndGameEffectsComponent.OnLocallyObservedChanged
// 0x0008 (0x0008 - 0x0000)
struct EndGameEffectsComponent_OnLocallyObservedChanged final
{
public:
	class ADBDPlayer*                             Player;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(EndGameEffectsComponent_OnLocallyObservedChanged) == 0x000008, "Wrong alignment on EndGameEffectsComponent_OnLocallyObservedChanged");
static_assert(sizeof(EndGameEffectsComponent_OnLocallyObservedChanged) == 0x000008, "Wrong size on EndGameEffectsComponent_OnLocallyObservedChanged");
static_assert(offsetof(EndGameEffectsComponent_OnLocallyObservedChanged, Player) == 0x000000, "Member 'EndGameEffectsComponent_OnLocallyObservedChanged::Player' has a wrong offset!");

// Function DBDGameplay.EndGameEffectsComponent.StartUpdateTimer
// 0x0040 (0x0040 - 0x0000)
struct EndGameEffectsComponent_StartUpdateTimer final
{
public:
	struct FGameplayTag                           GameEventType;                                     // 0x0000(0x000C)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameEventData                         GameEventData;                                     // 0x0010(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(EndGameEffectsComponent_StartUpdateTimer) == 0x000008, "Wrong alignment on EndGameEffectsComponent_StartUpdateTimer");
static_assert(sizeof(EndGameEffectsComponent_StartUpdateTimer) == 0x000040, "Wrong size on EndGameEffectsComponent_StartUpdateTimer");
static_assert(offsetof(EndGameEffectsComponent_StartUpdateTimer, GameEventType) == 0x000000, "Member 'EndGameEffectsComponent_StartUpdateTimer::GameEventType' has a wrong offset!");
static_assert(offsetof(EndGameEffectsComponent_StartUpdateTimer, GameEventData) == 0x000010, "Member 'EndGameEffectsComponent_StartUpdateTimer::GameEventData' has a wrong offset!");

// Function DBDGameplay.EtherealComponent.Server_SetIsEthereal
// 0x0008 (0x0008 - 0x0000)
struct EtherealComponent_Server_SetIsEthereal final
{
public:
	float                                         Timestamp;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Ethereal;                                          // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(EtherealComponent_Server_SetIsEthereal) == 0x000004, "Wrong alignment on EtherealComponent_Server_SetIsEthereal");
static_assert(sizeof(EtherealComponent_Server_SetIsEthereal) == 0x000008, "Wrong size on EtherealComponent_Server_SetIsEthereal");
static_assert(offsetof(EtherealComponent_Server_SetIsEthereal, Timestamp) == 0x000000, "Member 'EtherealComponent_Server_SetIsEthereal::Timestamp' has a wrong offset!");
static_assert(offsetof(EtherealComponent_Server_SetIsEthereal, Ethereal) == 0x000004, "Member 'EtherealComponent_Server_SetIsEthereal::Ethereal' has a wrong offset!");

// Function DBDGameplay.RangeToActorsTrackerStrategy.OnInRangeToTrackedActorsChanged
// 0x0001 (0x0001 - 0x0000)
struct RangeToActorsTrackerStrategy_OnInRangeToTrackedActorsChanged final
{
public:
	bool                                          InRange;                                           // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RangeToActorsTrackerStrategy_OnInRangeToTrackedActorsChanged) == 0x000001, "Wrong alignment on RangeToActorsTrackerStrategy_OnInRangeToTrackedActorsChanged");
static_assert(sizeof(RangeToActorsTrackerStrategy_OnInRangeToTrackedActorsChanged) == 0x000001, "Wrong size on RangeToActorsTrackerStrategy_OnInRangeToTrackedActorsChanged");
static_assert(offsetof(RangeToActorsTrackerStrategy_OnInRangeToTrackedActorsChanged, InRange) == 0x000000, "Member 'RangeToActorsTrackerStrategy_OnInRangeToTrackedActorsChanged::InRange' has a wrong offset!");

// Function DBDGameplay.FadingBlockFeedback.OnFadeOutStarted
// 0x0004 (0x0004 - 0x0000)
struct FadingBlockFeedback_OnFadeOutStarted final
{
public:
	float                                         FadeDuration;                                      // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FadingBlockFeedback_OnFadeOutStarted) == 0x000004, "Wrong alignment on FadingBlockFeedback_OnFadeOutStarted");
static_assert(sizeof(FadingBlockFeedback_OnFadeOutStarted) == 0x000004, "Wrong size on FadingBlockFeedback_OnFadeOutStarted");
static_assert(offsetof(FadingBlockFeedback_OnFadeOutStarted, FadeDuration) == 0x000000, "Member 'FadingBlockFeedback_OnFadeOutStarted::FadeDuration' has a wrong offset!");

// Function DBDGameplay.Flashlight.GetSpotlightComponent
// 0x0008 (0x0008 - 0x0000)
struct Flashlight_GetSpotlightComponent final
{
public:
	class USpotLightComponent*                    ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Flashlight_GetSpotlightComponent) == 0x000008, "Wrong alignment on Flashlight_GetSpotlightComponent");
static_assert(sizeof(Flashlight_GetSpotlightComponent) == 0x000008, "Wrong size on Flashlight_GetSpotlightComponent");
static_assert(offsetof(Flashlight_GetSpotlightComponent, ReturnValue) == 0x000000, "Member 'Flashlight_GetSpotlightComponent::ReturnValue' has a wrong offset!");

// DelegateFunction DBDGameplay.FlashlightableComponent.OnFlashlightAddedRemovedEvent__DelegateSignature
// 0x0008 (0x0008 - 0x0000)
struct FlashlightableComponent_OnFlashlightAddedRemovedEvent__DelegateSignature final
{
public:
	const class UFlashlightComponent*             Flashlight;                                        // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FlashlightableComponent_OnFlashlightAddedRemovedEvent__DelegateSignature) == 0x000008, "Wrong alignment on FlashlightableComponent_OnFlashlightAddedRemovedEvent__DelegateSignature");
static_assert(sizeof(FlashlightableComponent_OnFlashlightAddedRemovedEvent__DelegateSignature) == 0x000008, "Wrong size on FlashlightableComponent_OnFlashlightAddedRemovedEvent__DelegateSignature");
static_assert(offsetof(FlashlightableComponent_OnFlashlightAddedRemovedEvent__DelegateSignature, Flashlight) == 0x000000, "Member 'FlashlightableComponent_OnFlashlightAddedRemovedEvent__DelegateSignature::Flashlight' has a wrong offset!");

// DelegateFunction DBDGameplay.FlashlightableComponent.OnFlashlightLitChangedEvent__DelegateSignature
// 0x0001 (0x0001 - 0x0000)
struct FlashlightableComponent_OnFlashlightLitChangedEvent__DelegateSignature final
{
public:
	bool                                          IsLit;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FlashlightableComponent_OnFlashlightLitChangedEvent__DelegateSignature) == 0x000001, "Wrong alignment on FlashlightableComponent_OnFlashlightLitChangedEvent__DelegateSignature");
static_assert(sizeof(FlashlightableComponent_OnFlashlightLitChangedEvent__DelegateSignature) == 0x000001, "Wrong size on FlashlightableComponent_OnFlashlightLitChangedEvent__DelegateSignature");
static_assert(offsetof(FlashlightableComponent_OnFlashlightLitChangedEvent__DelegateSignature, IsLit) == 0x000000, "Member 'FlashlightableComponent_OnFlashlightLitChangedEvent__DelegateSignature::IsLit' has a wrong offset!");

// Function DBDGameplay.FlashlightableComponent.IsLit
// 0x0001 (0x0001 - 0x0000)
struct FlashlightableComponent_IsLit final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FlashlightableComponent_IsLit) == 0x000001, "Wrong alignment on FlashlightableComponent_IsLit");
static_assert(sizeof(FlashlightableComponent_IsLit) == 0x000001, "Wrong size on FlashlightableComponent_IsLit");
static_assert(offsetof(FlashlightableComponent_IsLit, ReturnValue) == 0x000000, "Member 'FlashlightableComponent_IsLit::ReturnValue' has a wrong offset!");

// Function DBDGameplay.FlashlightComponent.Server_SetAndUpdateAutonomousLitFlashlightables
// 0x0010 (0x0010 - 0x0000)
struct FlashlightComponent_Server_SetAndUpdateAutonomousLitFlashlightables final
{
public:
	TArray<class UFlashlightableComponent*>       NewLitFlashlightables;                             // 0x0000(0x0010)(ConstParm, Parm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FlashlightComponent_Server_SetAndUpdateAutonomousLitFlashlightables) == 0x000008, "Wrong alignment on FlashlightComponent_Server_SetAndUpdateAutonomousLitFlashlightables");
static_assert(sizeof(FlashlightComponent_Server_SetAndUpdateAutonomousLitFlashlightables) == 0x000010, "Wrong size on FlashlightComponent_Server_SetAndUpdateAutonomousLitFlashlightables");
static_assert(offsetof(FlashlightComponent_Server_SetAndUpdateAutonomousLitFlashlightables, NewLitFlashlightables) == 0x000000, "Member 'FlashlightComponent_Server_SetAndUpdateAutonomousLitFlashlightables::NewLitFlashlightables' has a wrong offset!");

// Function DBDGameplay.FlashlightComponent.GetEffectiveBlindnessDuration
// 0x0004 (0x0004 - 0x0000)
struct FlashlightComponent_GetEffectiveBlindnessDuration final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FlashlightComponent_GetEffectiveBlindnessDuration) == 0x000004, "Wrong alignment on FlashlightComponent_GetEffectiveBlindnessDuration");
static_assert(sizeof(FlashlightComponent_GetEffectiveBlindnessDuration) == 0x000004, "Wrong size on FlashlightComponent_GetEffectiveBlindnessDuration");
static_assert(offsetof(FlashlightComponent_GetEffectiveBlindnessDuration, ReturnValue) == 0x000000, "Member 'FlashlightComponent_GetEffectiveBlindnessDuration::ReturnValue' has a wrong offset!");

// Function DBDGameplay.FlashlightComponent.GetEffectiveTimeToBlindModifier
// 0x0004 (0x0004 - 0x0000)
struct FlashlightComponent_GetEffectiveTimeToBlindModifier final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FlashlightComponent_GetEffectiveTimeToBlindModifier) == 0x000004, "Wrong alignment on FlashlightComponent_GetEffectiveTimeToBlindModifier");
static_assert(sizeof(FlashlightComponent_GetEffectiveTimeToBlindModifier) == 0x000004, "Wrong size on FlashlightComponent_GetEffectiveTimeToBlindModifier");
static_assert(offsetof(FlashlightComponent_GetEffectiveTimeToBlindModifier, ReturnValue) == 0x000000, "Member 'FlashlightComponent_GetEffectiveTimeToBlindModifier::ReturnValue' has a wrong offset!");

// Function DBDGameplay.FlashlightComponent.IsOn
// 0x0001 (0x0001 - 0x0000)
struct FlashlightComponent_IsOn final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FlashlightComponent_IsOn) == 0x000001, "Wrong alignment on FlashlightComponent_IsOn");
static_assert(sizeof(FlashlightComponent_IsOn) == 0x000001, "Wrong size on FlashlightComponent_IsOn");
static_assert(offsetof(FlashlightComponent_IsOn, ReturnValue) == 0x000000, "Member 'FlashlightComponent_IsOn::ReturnValue' has a wrong offset!");

// Function DBDGameplay.FlashlightConeComponent.GetEffectiveConeHalfAngle
// 0x0004 (0x0004 - 0x0000)
struct FlashlightConeComponent_GetEffectiveConeHalfAngle final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FlashlightConeComponent_GetEffectiveConeHalfAngle) == 0x000004, "Wrong alignment on FlashlightConeComponent_GetEffectiveConeHalfAngle");
static_assert(sizeof(FlashlightConeComponent_GetEffectiveConeHalfAngle) == 0x000004, "Wrong size on FlashlightConeComponent_GetEffectiveConeHalfAngle");
static_assert(offsetof(FlashlightConeComponent_GetEffectiveConeHalfAngle, ReturnValue) == 0x000000, "Member 'FlashlightConeComponent_GetEffectiveConeHalfAngle::ReturnValue' has a wrong offset!");

// Function DBDGameplay.FlashlightConeComponent.GetEffectiveConeLength
// 0x0004 (0x0004 - 0x0000)
struct FlashlightConeComponent_GetEffectiveConeLength final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FlashlightConeComponent_GetEffectiveConeLength) == 0x000004, "Wrong alignment on FlashlightConeComponent_GetEffectiveConeLength");
static_assert(sizeof(FlashlightConeComponent_GetEffectiveConeLength) == 0x000004, "Wrong size on FlashlightConeComponent_GetEffectiveConeLength");
static_assert(offsetof(FlashlightConeComponent_GetEffectiveConeLength, ReturnValue) == 0x000000, "Member 'FlashlightConeComponent_GetEffectiveConeLength::ReturnValue' has a wrong offset!");

// Function DBDGameplay.FlashlightConeComponent.GetOcclusionDistance
// 0x0004 (0x0004 - 0x0000)
struct FlashlightConeComponent_GetOcclusionDistance final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FlashlightConeComponent_GetOcclusionDistance) == 0x000004, "Wrong alignment on FlashlightConeComponent_GetOcclusionDistance");
static_assert(sizeof(FlashlightConeComponent_GetOcclusionDistance) == 0x000004, "Wrong size on FlashlightConeComponent_GetOcclusionDistance");
static_assert(offsetof(FlashlightConeComponent_GetOcclusionDistance, ReturnValue) == 0x000000, "Member 'FlashlightConeComponent_GetOcclusionDistance::ReturnValue' has a wrong offset!");

// Function DBDGameplay.FlashlightFXComponent.OnCollectedEvent
// 0x0008 (0x0008 - 0x0000)
struct FlashlightFXComponent_OnCollectedEvent final
{
public:
	class ADBDPlayer*                             Collector;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FlashlightFXComponent_OnCollectedEvent) == 0x000008, "Wrong alignment on FlashlightFXComponent_OnCollectedEvent");
static_assert(sizeof(FlashlightFXComponent_OnCollectedEvent) == 0x000008, "Wrong size on FlashlightFXComponent_OnCollectedEvent");
static_assert(offsetof(FlashlightFXComponent_OnCollectedEvent, Collector) == 0x000000, "Member 'FlashlightFXComponent_OnCollectedEvent::Collector' has a wrong offset!");

// Function DBDGameplay.FlashlightFXComponent.OnCollectorLocallyObservedChangedEvent
// 0x0001 (0x0001 - 0x0000)
struct FlashlightFXComponent_OnCollectorLocallyObservedChangedEvent final
{
public:
	bool                                          IsLocallyObserved;                                 // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FlashlightFXComponent_OnCollectorLocallyObservedChangedEvent) == 0x000001, "Wrong alignment on FlashlightFXComponent_OnCollectorLocallyObservedChangedEvent");
static_assert(sizeof(FlashlightFXComponent_OnCollectorLocallyObservedChangedEvent) == 0x000001, "Wrong size on FlashlightFXComponent_OnCollectorLocallyObservedChangedEvent");
static_assert(offsetof(FlashlightFXComponent_OnCollectorLocallyObservedChangedEvent, IsLocallyObserved) == 0x000000, "Member 'FlashlightFXComponent_OnCollectorLocallyObservedChangedEvent::IsLocallyObserved' has a wrong offset!");

// Function DBDGameplay.FlashlightFXComponent.UpdateConeEvent
// 0x0008 (0x0008 - 0x0000)
struct FlashlightFXComponent_UpdateConeEvent final
{
public:
	float                                         Length;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HalfAngle;                                         // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FlashlightFXComponent_UpdateConeEvent) == 0x000004, "Wrong alignment on FlashlightFXComponent_UpdateConeEvent");
static_assert(sizeof(FlashlightFXComponent_UpdateConeEvent) == 0x000008, "Wrong size on FlashlightFXComponent_UpdateConeEvent");
static_assert(offsetof(FlashlightFXComponent_UpdateConeEvent, Length) == 0x000000, "Member 'FlashlightFXComponent_UpdateConeEvent::Length' has a wrong offset!");
static_assert(offsetof(FlashlightFXComponent_UpdateConeEvent, HalfAngle) == 0x000004, "Member 'FlashlightFXComponent_UpdateConeEvent::HalfAngle' has a wrong offset!");

// Function DBDGameplay.FlashlightFXComponent.GetBlindingSuccessRatio
// 0x0004 (0x0004 - 0x0000)
struct FlashlightFXComponent_GetBlindingSuccessRatio final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FlashlightFXComponent_GetBlindingSuccessRatio) == 0x000004, "Wrong alignment on FlashlightFXComponent_GetBlindingSuccessRatio");
static_assert(sizeof(FlashlightFXComponent_GetBlindingSuccessRatio) == 0x000004, "Wrong size on FlashlightFXComponent_GetBlindingSuccessRatio");
static_assert(offsetof(FlashlightFXComponent_GetBlindingSuccessRatio, ReturnValue) == 0x000000, "Member 'FlashlightFXComponent_GetBlindingSuccessRatio::ReturnValue' has a wrong offset!");

// Function DBDGameplay.FootstepManagerComponent.OnUpdateCreatorFootsteps
// 0x0008 (0x0008 - 0x0000)
struct FootstepManagerComponent_OnUpdateCreatorFootsteps final
{
public:
	class UFootstepCreatorComponent*              Creator;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FootstepManagerComponent_OnUpdateCreatorFootsteps) == 0x000008, "Wrong alignment on FootstepManagerComponent_OnUpdateCreatorFootsteps");
static_assert(sizeof(FootstepManagerComponent_OnUpdateCreatorFootsteps) == 0x000008, "Wrong size on FootstepManagerComponent_OnUpdateCreatorFootsteps");
static_assert(offsetof(FootstepManagerComponent_OnUpdateCreatorFootsteps, Creator) == 0x000000, "Member 'FootstepManagerComponent_OnUpdateCreatorFootsteps::Creator' has a wrong offset!");

// Function DBDGameplay.FootstepManagerComponent.TriggerSpawnFootstep
// 0x0020 (0x0020 - 0x0000)
struct FootstepManagerComponent_TriggerSpawnFootstep final
{
public:
	class UFootstepCreatorComponent*              OriginatorComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0008(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FootstepManagerComponent_TriggerSpawnFootstep) == 0x000008, "Wrong alignment on FootstepManagerComponent_TriggerSpawnFootstep");
static_assert(sizeof(FootstepManagerComponent_TriggerSpawnFootstep) == 0x000020, "Wrong size on FootstepManagerComponent_TriggerSpawnFootstep");
static_assert(offsetof(FootstepManagerComponent_TriggerSpawnFootstep, OriginatorComponent) == 0x000000, "Member 'FootstepManagerComponent_TriggerSpawnFootstep::OriginatorComponent' has a wrong offset!");
static_assert(offsetof(FootstepManagerComponent_TriggerSpawnFootstep, Location) == 0x000008, "Member 'FootstepManagerComponent_TriggerSpawnFootstep::Location' has a wrong offset!");

// Function DBDGameplay.GeneratorWithMostProgressTracker.OnGeneratorCompleted
// 0x0001 (0x0001 - 0x0000)
struct GeneratorWithMostProgressTracker_OnGeneratorCompleted final
{
public:
	bool                                          IsAutoCompleted;                                   // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GeneratorWithMostProgressTracker_OnGeneratorCompleted) == 0x000001, "Wrong alignment on GeneratorWithMostProgressTracker_OnGeneratorCompleted");
static_assert(sizeof(GeneratorWithMostProgressTracker_OnGeneratorCompleted) == 0x000001, "Wrong size on GeneratorWithMostProgressTracker_OnGeneratorCompleted");
static_assert(offsetof(GeneratorWithMostProgressTracker_OnGeneratorCompleted, IsAutoCompleted) == 0x000000, "Member 'GeneratorWithMostProgressTracker_OnGeneratorCompleted::IsAutoCompleted' has a wrong offset!");

// Function DBDGameplay.GlassBeadMapAddon.Authority_OnSecondaryInputPressed
// 0x0018 (0x0018 - 0x0000)
struct GlassBeadMapAddon_Authority_OnSecondaryInputPressed final
{
public:
	class ADBDPlayer*                             Player;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInteractionDefinition*                 Interaction;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          FromCancelRequest;                                 // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GlassBeadMapAddon_Authority_OnSecondaryInputPressed) == 0x000008, "Wrong alignment on GlassBeadMapAddon_Authority_OnSecondaryInputPressed");
static_assert(sizeof(GlassBeadMapAddon_Authority_OnSecondaryInputPressed) == 0x000018, "Wrong size on GlassBeadMapAddon_Authority_OnSecondaryInputPressed");
static_assert(offsetof(GlassBeadMapAddon_Authority_OnSecondaryInputPressed, Player) == 0x000000, "Member 'GlassBeadMapAddon_Authority_OnSecondaryInputPressed::Player' has a wrong offset!");
static_assert(offsetof(GlassBeadMapAddon_Authority_OnSecondaryInputPressed, Interaction) == 0x000008, "Member 'GlassBeadMapAddon_Authority_OnSecondaryInputPressed::Interaction' has a wrong offset!");
static_assert(offsetof(GlassBeadMapAddon_Authority_OnSecondaryInputPressed, FromCancelRequest) == 0x000010, "Member 'GlassBeadMapAddon_Authority_OnSecondaryInputPressed::FromCancelRequest' has a wrong offset!");

// Function DBDGameplay.KillerInstinctComponent.GetParticleSystem
// 0x0008 (0x0008 - 0x0000)
struct KillerInstinctComponent_GetParticleSystem final
{
public:
	class UNiagaraComponent*                      ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KillerInstinctComponent_GetParticleSystem) == 0x000008, "Wrong alignment on KillerInstinctComponent_GetParticleSystem");
static_assert(sizeof(KillerInstinctComponent_GetParticleSystem) == 0x000008, "Wrong size on KillerInstinctComponent_GetParticleSystem");
static_assert(offsetof(KillerInstinctComponent_GetParticleSystem, ReturnValue) == 0x000000, "Member 'KillerInstinctComponent_GetParticleSystem::ReturnValue' has a wrong offset!");

// Function DBDGameplay.KillerInstinctComponent.OnKillerLocallyObservedChanged
// 0x0001 (0x0001 - 0x0000)
struct KillerInstinctComponent_OnKillerLocallyObservedChanged final
{
public:
	bool                                          LocallyObserved;                                   // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KillerInstinctComponent_OnKillerLocallyObservedChanged) == 0x000001, "Wrong alignment on KillerInstinctComponent_OnKillerLocallyObservedChanged");
static_assert(sizeof(KillerInstinctComponent_OnKillerLocallyObservedChanged) == 0x000001, "Wrong size on KillerInstinctComponent_OnKillerLocallyObservedChanged");
static_assert(offsetof(KillerInstinctComponent_OnKillerLocallyObservedChanged, LocallyObserved) == 0x000000, "Member 'KillerInstinctComponent_OnKillerLocallyObservedChanged::LocallyObserved' has a wrong offset!");

// Function DBDGameplay.KillerInstinctComponent.SetParticleSystem
// 0x0008 (0x0008 - 0x0000)
struct KillerInstinctComponent_SetParticleSystem final
{
public:
	class UNiagaraComponent*                      ParticleSystemComponent;                           // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KillerInstinctComponent_SetParticleSystem) == 0x000008, "Wrong alignment on KillerInstinctComponent_SetParticleSystem");
static_assert(sizeof(KillerInstinctComponent_SetParticleSystem) == 0x000008, "Wrong size on KillerInstinctComponent_SetParticleSystem");
static_assert(offsetof(KillerInstinctComponent_SetParticleSystem, ParticleSystemComponent) == 0x000000, "Member 'KillerInstinctComponent_SetParticleSystem::ParticleSystemComponent' has a wrong offset!");

// Function DBDGameplay.KillerPowerUtilities.GetKillerPowerFromPlayer
// 0x0010 (0x0010 - 0x0000)
struct KillerPowerUtilities_GetKillerPowerFromPlayer final
{
public:
	const class ADBDPlayer*                       Player;                                            // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AKillerPower*                           ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KillerPowerUtilities_GetKillerPowerFromPlayer) == 0x000008, "Wrong alignment on KillerPowerUtilities_GetKillerPowerFromPlayer");
static_assert(sizeof(KillerPowerUtilities_GetKillerPowerFromPlayer) == 0x000010, "Wrong size on KillerPowerUtilities_GetKillerPowerFromPlayer");
static_assert(offsetof(KillerPowerUtilities_GetKillerPowerFromPlayer, Player) == 0x000000, "Member 'KillerPowerUtilities_GetKillerPowerFromPlayer::Player' has a wrong offset!");
static_assert(offsetof(KillerPowerUtilities_GetKillerPowerFromPlayer, ReturnValue) == 0x000008, "Member 'KillerPowerUtilities_GetKillerPowerFromPlayer::ReturnValue' has a wrong offset!");

// Function DBDGameplay.MapCollectable.GetActorKnowledgeCollection
// 0x0008 (0x0008 - 0x0000)
struct MapCollectable_GetActorKnowledgeCollection final
{
public:
	class UActorKnowledgeCollection*              ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MapCollectable_GetActorKnowledgeCollection) == 0x000008, "Wrong alignment on MapCollectable_GetActorKnowledgeCollection");
static_assert(sizeof(MapCollectable_GetActorKnowledgeCollection) == 0x000008, "Wrong size on MapCollectable_GetActorKnowledgeCollection");
static_assert(offsetof(MapCollectable_GetActorKnowledgeCollection, ReturnValue) == 0x000000, "Member 'MapCollectable_GetActorKnowledgeCollection::ReturnValue' has a wrong offset!");

// Function DBDGameplay.MapCollectable.GetChargeableComponent
// 0x0008 (0x0008 - 0x0000)
struct MapCollectable_GetChargeableComponent final
{
public:
	class UChargeableComponent*                   ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MapCollectable_GetChargeableComponent) == 0x000008, "Wrong alignment on MapCollectable_GetChargeableComponent");
static_assert(sizeof(MapCollectable_GetChargeableComponent) == 0x000008, "Wrong size on MapCollectable_GetChargeableComponent");
static_assert(offsetof(MapCollectable_GetChargeableComponent, ReturnValue) == 0x000000, "Member 'MapCollectable_GetChargeableComponent::ReturnValue' has a wrong offset!");

// Function DBDGameplay.MapCollectable.GetChargerComponent
// 0x0008 (0x0008 - 0x0000)
struct MapCollectable_GetChargerComponent final
{
public:
	class UChargerComponent*                      ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MapCollectable_GetChargerComponent) == 0x000008, "Wrong alignment on MapCollectable_GetChargerComponent");
static_assert(sizeof(MapCollectable_GetChargerComponent) == 0x000008, "Wrong size on MapCollectable_GetChargerComponent");
static_assert(offsetof(MapCollectable_GetChargerComponent, ReturnValue) == 0x000000, "Member 'MapCollectable_GetChargerComponent::ReturnValue' has a wrong offset!");

// Function DBDGameplay.Medkit.Authority_OnAnyOngoingInteractionChanged
// 0x0001 (0x0001 - 0x0000)
struct Medkit_Authority_OnAnyOngoingInteractionChanged final
{
public:
	bool                                          IsInteracting;                                     // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Medkit_Authority_OnAnyOngoingInteractionChanged) == 0x000001, "Wrong alignment on Medkit_Authority_OnAnyOngoingInteractionChanged");
static_assert(sizeof(Medkit_Authority_OnAnyOngoingInteractionChanged) == 0x000001, "Wrong size on Medkit_Authority_OnAnyOngoingInteractionChanged");
static_assert(offsetof(Medkit_Authority_OnAnyOngoingInteractionChanged, IsInteracting) == 0x000000, "Member 'Medkit_Authority_OnAnyOngoingInteractionChanged::IsInteracting' has a wrong offset!");

// Function DBDGameplay.Medkit.Authority_OnChargeStateChange
// 0x0001 (0x0001 - 0x0000)
struct Medkit_Authority_OnChargeStateChange final
{
public:
	bool                                          Empty;                                             // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Medkit_Authority_OnChargeStateChange) == 0x000001, "Wrong alignment on Medkit_Authority_OnChargeStateChange");
static_assert(sizeof(Medkit_Authority_OnChargeStateChange) == 0x000001, "Wrong size on Medkit_Authority_OnChargeStateChange");
static_assert(offsetof(Medkit_Authority_OnChargeStateChange, Empty) == 0x000000, "Member 'Medkit_Authority_OnChargeStateChange::Empty' has a wrong offset!");

// Function DBDGameplay.Medkit.OnMedkitHealedCamper
// 0x0008 (0x0008 - 0x0000)
struct Medkit_OnMedkitHealedCamper final
{
public:
	class ADBDPlayer*                             HealedPlayer;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Medkit_OnMedkitHealedCamper) == 0x000008, "Wrong alignment on Medkit_OnMedkitHealedCamper");
static_assert(sizeof(Medkit_OnMedkitHealedCamper) == 0x000008, "Wrong size on Medkit_OnMedkitHealedCamper");
static_assert(offsetof(Medkit_OnMedkitHealedCamper, HealedPlayer) == 0x000000, "Member 'Medkit_OnMedkitHealedCamper::HealedPlayer' has a wrong offset!");

// Function DBDGameplay.Medkit.UseCharge
// 0x0004 (0x0004 - 0x0000)
struct Medkit_UseCharge final
{
public:
	float                                         Seconds;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Medkit_UseCharge) == 0x000004, "Wrong alignment on Medkit_UseCharge");
static_assert(sizeof(Medkit_UseCharge) == 0x000004, "Wrong size on Medkit_UseCharge");
static_assert(offsetof(Medkit_UseCharge, Seconds) == 0x000000, "Member 'Medkit_UseCharge::Seconds' has a wrong offset!");

// Function DBDGameplay.Medkit.GetCharge
// 0x0004 (0x0004 - 0x0000)
struct Medkit_GetCharge final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Medkit_GetCharge) == 0x000004, "Wrong alignment on Medkit_GetCharge");
static_assert(sizeof(Medkit_GetCharge) == 0x000004, "Wrong size on Medkit_GetCharge");
static_assert(offsetof(Medkit_GetCharge, ReturnValue) == 0x000000, "Member 'Medkit_GetCharge::ReturnValue' has a wrong offset!");

// Function DBDGameplay.Medkit.GetChargeMultiplier
// 0x0004 (0x0004 - 0x0000)
struct Medkit_GetChargeMultiplier final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Medkit_GetChargeMultiplier) == 0x000004, "Wrong alignment on Medkit_GetChargeMultiplier");
static_assert(sizeof(Medkit_GetChargeMultiplier) == 0x000004, "Wrong size on Medkit_GetChargeMultiplier");
static_assert(offsetof(Medkit_GetChargeMultiplier, ReturnValue) == 0x000000, "Member 'Medkit_GetChargeMultiplier::ReturnValue' has a wrong offset!");

// Function DBDGameplay.Medkit.HasCharge
// 0x0001 (0x0001 - 0x0000)
struct Medkit_HasCharge final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Medkit_HasCharge) == 0x000001, "Wrong alignment on Medkit_HasCharge");
static_assert(sizeof(Medkit_HasCharge) == 0x000001, "Wrong size on Medkit_HasCharge");
static_assert(offsetof(Medkit_HasCharge, ReturnValue) == 0x000000, "Member 'Medkit_HasCharge::ReturnValue' has a wrong offset!");

// Function DBDGameplay.NearestOutsideMapBoundsLocator.OnGameEnd
// 0x0001 (0x0001 - 0x0000)
struct NearestOutsideMapBoundsLocator_OnGameEnd final
{
public:
	EEndGameReason                                EndGameReason;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NearestOutsideMapBoundsLocator_OnGameEnd) == 0x000001, "Wrong alignment on NearestOutsideMapBoundsLocator_OnGameEnd");
static_assert(sizeof(NearestOutsideMapBoundsLocator_OnGameEnd) == 0x000001, "Wrong size on NearestOutsideMapBoundsLocator_OnGameEnd");
static_assert(offsetof(NearestOutsideMapBoundsLocator_OnGameEnd, EndGameReason) == 0x000000, "Member 'NearestOutsideMapBoundsLocator_OnGameEnd::EndGameReason' has a wrong offset!");

// Function DBDGameplay.Passage.Cosmetic_OnPlayerInRangeChanged
// 0x0010 (0x0010 - 0x0000)
struct Passage_Cosmetic_OnPlayerInRangeChanged final
{
public:
	bool                                          InRange;                                           // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	const class ADBDPlayer*                       Player;                                            // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Passage_Cosmetic_OnPlayerInRangeChanged) == 0x000008, "Wrong alignment on Passage_Cosmetic_OnPlayerInRangeChanged");
static_assert(sizeof(Passage_Cosmetic_OnPlayerInRangeChanged) == 0x000010, "Wrong size on Passage_Cosmetic_OnPlayerInRangeChanged");
static_assert(offsetof(Passage_Cosmetic_OnPlayerInRangeChanged, InRange) == 0x000000, "Member 'Passage_Cosmetic_OnPlayerInRangeChanged::InRange' has a wrong offset!");
static_assert(offsetof(Passage_Cosmetic_OnPlayerInRangeChanged, Player) == 0x000008, "Member 'Passage_Cosmetic_OnPlayerInRangeChanged::Player' has a wrong offset!");

// DelegateFunction DBDGameplay.Passage.CosmeticPassageEventDelegate__DelegateSignature
// 0x0002 (0x0002 - 0x0000)
struct Passage_CosmeticPassageEventDelegate__DelegateSignature final
{
public:
	EPassageCosmeticState                         NewState;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPassageCosmeticState                         OldState;                                          // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Passage_CosmeticPassageEventDelegate__DelegateSignature) == 0x000001, "Wrong alignment on Passage_CosmeticPassageEventDelegate__DelegateSignature");
static_assert(sizeof(Passage_CosmeticPassageEventDelegate__DelegateSignature) == 0x000002, "Wrong size on Passage_CosmeticPassageEventDelegate__DelegateSignature");
static_assert(offsetof(Passage_CosmeticPassageEventDelegate__DelegateSignature, NewState) == 0x000000, "Member 'Passage_CosmeticPassageEventDelegate__DelegateSignature::NewState' has a wrong offset!");
static_assert(offsetof(Passage_CosmeticPassageEventDelegate__DelegateSignature, OldState) == 0x000001, "Member 'Passage_CosmeticPassageEventDelegate__DelegateSignature::OldState' has a wrong offset!");

// DelegateFunction DBDGameplay.Passage.CosmeticPlayerInRangeOfPassageEvent__DelegateSignature
// 0x0010 (0x0010 - 0x0000)
struct Passage_CosmeticPlayerInRangeOfPassageEvent__DelegateSignature final
{
public:
	const class ADBDPlayer*                       Player;                                            // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsInRange;                                         // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Passage_CosmeticPlayerInRangeOfPassageEvent__DelegateSignature) == 0x000008, "Wrong alignment on Passage_CosmeticPlayerInRangeOfPassageEvent__DelegateSignature");
static_assert(sizeof(Passage_CosmeticPlayerInRangeOfPassageEvent__DelegateSignature) == 0x000010, "Wrong size on Passage_CosmeticPlayerInRangeOfPassageEvent__DelegateSignature");
static_assert(offsetof(Passage_CosmeticPlayerInRangeOfPassageEvent__DelegateSignature, Player) == 0x000000, "Member 'Passage_CosmeticPlayerInRangeOfPassageEvent__DelegateSignature::Player' has a wrong offset!");
static_assert(offsetof(Passage_CosmeticPlayerInRangeOfPassageEvent__DelegateSignature, IsInRange) == 0x000008, "Member 'Passage_CosmeticPlayerInRangeOfPassageEvent__DelegateSignature::IsInRange' has a wrong offset!");

// Function DBDGameplay.Passage.Local_OnPlayerLeftGame
// 0x0040 (0x0040 - 0x0000)
struct Passage_Local_OnPlayerLeftGame final
{
public:
	struct FGameplayTag                           GameplayTag;                                       // 0x0000(0x000C)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameEventData                         GameEventData;                                     // 0x0010(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(Passage_Local_OnPlayerLeftGame) == 0x000008, "Wrong alignment on Passage_Local_OnPlayerLeftGame");
static_assert(sizeof(Passage_Local_OnPlayerLeftGame) == 0x000040, "Wrong size on Passage_Local_OnPlayerLeftGame");
static_assert(offsetof(Passage_Local_OnPlayerLeftGame, GameplayTag) == 0x000000, "Member 'Passage_Local_OnPlayerLeftGame::GameplayTag' has a wrong offset!");
static_assert(offsetof(Passage_Local_OnPlayerLeftGame, GameEventData) == 0x000010, "Member 'Passage_Local_OnPlayerLeftGame::GameEventData' has a wrong offset!");

// Function DBDGameplay.Passage.Local_OnPlayerLocallyObservedChanged
// 0x0010 (0x0010 - 0x0000)
struct Passage_Local_OnPlayerLocallyObservedChanged final
{
public:
	bool                                          IsObserved;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	const class ADBDPlayer*                       Player;                                            // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Passage_Local_OnPlayerLocallyObservedChanged) == 0x000008, "Wrong alignment on Passage_Local_OnPlayerLocallyObservedChanged");
static_assert(sizeof(Passage_Local_OnPlayerLocallyObservedChanged) == 0x000010, "Wrong size on Passage_Local_OnPlayerLocallyObservedChanged");
static_assert(offsetof(Passage_Local_OnPlayerLocallyObservedChanged, IsObserved) == 0x000000, "Member 'Passage_Local_OnPlayerLocallyObservedChanged::IsObserved' has a wrong offset!");
static_assert(offsetof(Passage_Local_OnPlayerLocallyObservedChanged, Player) == 0x000008, "Member 'Passage_Local_OnPlayerLocallyObservedChanged::Player' has a wrong offset!");

// Function DBDGameplay.Passage.OnBeginOverlapRevealExitAuraZone
// 0x0110 (0x0110 - 0x0000)
struct Passage_OnBeginOverlapRevealExitAuraZone final
{
public:
	class UPrimitiveComponent*                    HitComponent;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x00F0)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(Passage_OnBeginOverlapRevealExitAuraZone) == 0x000008, "Wrong alignment on Passage_OnBeginOverlapRevealExitAuraZone");
static_assert(sizeof(Passage_OnBeginOverlapRevealExitAuraZone) == 0x000110, "Wrong size on Passage_OnBeginOverlapRevealExitAuraZone");
static_assert(offsetof(Passage_OnBeginOverlapRevealExitAuraZone, HitComponent) == 0x000000, "Member 'Passage_OnBeginOverlapRevealExitAuraZone::HitComponent' has a wrong offset!");
static_assert(offsetof(Passage_OnBeginOverlapRevealExitAuraZone, OtherActor) == 0x000008, "Member 'Passage_OnBeginOverlapRevealExitAuraZone::OtherActor' has a wrong offset!");
static_assert(offsetof(Passage_OnBeginOverlapRevealExitAuraZone, OtherComp) == 0x000010, "Member 'Passage_OnBeginOverlapRevealExitAuraZone::OtherComp' has a wrong offset!");
static_assert(offsetof(Passage_OnBeginOverlapRevealExitAuraZone, OtherBodyIndex) == 0x000018, "Member 'Passage_OnBeginOverlapRevealExitAuraZone::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(Passage_OnBeginOverlapRevealExitAuraZone, bFromSweep) == 0x00001C, "Member 'Passage_OnBeginOverlapRevealExitAuraZone::bFromSweep' has a wrong offset!");
static_assert(offsetof(Passage_OnBeginOverlapRevealExitAuraZone, SweepResult) == 0x000020, "Member 'Passage_OnBeginOverlapRevealExitAuraZone::SweepResult' has a wrong offset!");

// Function DBDGameplay.Passage.OnEndOverlapRevealExitAuraZone
// 0x0020 (0x0020 - 0x0000)
struct Passage_OnEndOverlapRevealExitAuraZone final
{
public:
	class UPrimitiveComponent*                    HitComponent;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Passage_OnEndOverlapRevealExitAuraZone) == 0x000008, "Wrong alignment on Passage_OnEndOverlapRevealExitAuraZone");
static_assert(sizeof(Passage_OnEndOverlapRevealExitAuraZone) == 0x000020, "Wrong size on Passage_OnEndOverlapRevealExitAuraZone");
static_assert(offsetof(Passage_OnEndOverlapRevealExitAuraZone, HitComponent) == 0x000000, "Member 'Passage_OnEndOverlapRevealExitAuraZone::HitComponent' has a wrong offset!");
static_assert(offsetof(Passage_OnEndOverlapRevealExitAuraZone, OtherActor) == 0x000008, "Member 'Passage_OnEndOverlapRevealExitAuraZone::OtherActor' has a wrong offset!");
static_assert(offsetof(Passage_OnEndOverlapRevealExitAuraZone, OtherComp) == 0x000010, "Member 'Passage_OnEndOverlapRevealExitAuraZone::OtherComp' has a wrong offset!");
static_assert(offsetof(Passage_OnEndOverlapRevealExitAuraZone, OtherBodyIndex) == 0x000018, "Member 'Passage_OnEndOverlapRevealExitAuraZone::OtherBodyIndex' has a wrong offset!");

// Function DBDGameplay.Passage.GetConnectedPassage
// 0x0008 (0x0008 - 0x0000)
struct Passage_GetConnectedPassage final
{
public:
	class APassage*                               ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Passage_GetConnectedPassage) == 0x000008, "Wrong alignment on Passage_GetConnectedPassage");
static_assert(sizeof(Passage_GetConnectedPassage) == 0x000008, "Wrong size on Passage_GetConnectedPassage");
static_assert(offsetof(Passage_GetConnectedPassage, ReturnValue) == 0x000000, "Member 'Passage_GetConnectedPassage::ReturnValue' has a wrong offset!");

// Function DBDGameplay.Passage.GetPassageCosmeticState
// 0x0001 (0x0001 - 0x0000)
struct Passage_GetPassageCosmeticState final
{
public:
	EPassageCosmeticState                         ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Passage_GetPassageCosmeticState) == 0x000001, "Wrong alignment on Passage_GetPassageCosmeticState");
static_assert(sizeof(Passage_GetPassageCosmeticState) == 0x000001, "Wrong size on Passage_GetPassageCosmeticState");
static_assert(offsetof(Passage_GetPassageCosmeticState, ReturnValue) == 0x000000, "Member 'Passage_GetPassageCosmeticState::ReturnValue' has a wrong offset!");

// DelegateFunction DBDGameplay.PassageEnterInteraction.CosmeticPassageInteractionEventDelegate__DelegateSignature
// 0x0008 (0x0008 - 0x0000)
struct PassageEnterInteraction_CosmeticPassageInteractionEventDelegate__DelegateSignature final
{
public:
	class ADBDPlayer*                             Player;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PassageEnterInteraction_CosmeticPassageInteractionEventDelegate__DelegateSignature) == 0x000008, "Wrong alignment on PassageEnterInteraction_CosmeticPassageInteractionEventDelegate__DelegateSignature");
static_assert(sizeof(PassageEnterInteraction_CosmeticPassageInteractionEventDelegate__DelegateSignature) == 0x000008, "Wrong size on PassageEnterInteraction_CosmeticPassageInteractionEventDelegate__DelegateSignature");
static_assert(offsetof(PassageEnterInteraction_CosmeticPassageInteractionEventDelegate__DelegateSignature, Player) == 0x000000, "Member 'PassageEnterInteraction_CosmeticPassageInteractionEventDelegate__DelegateSignature::Player' has a wrong offset!");

// Function DBDGameplay.PassageEnterInteraction.GetOwningPassage
// 0x0008 (0x0008 - 0x0000)
struct PassageEnterInteraction_GetOwningPassage final
{
public:
	class APassage*                               ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PassageEnterInteraction_GetOwningPassage) == 0x000008, "Wrong alignment on PassageEnterInteraction_GetOwningPassage");
static_assert(sizeof(PassageEnterInteraction_GetOwningPassage) == 0x000008, "Wrong size on PassageEnterInteraction_GetOwningPassage");
static_assert(offsetof(PassageEnterInteraction_GetOwningPassage, ReturnValue) == 0x000000, "Member 'PassageEnterInteraction_GetOwningPassage::ReturnValue' has a wrong offset!");

// DelegateFunction DBDGameplay.PlayerInteractionListenerComponent.InteractionDelegate__DelegateSignature
// 0x0018 (0x0018 - 0x0000)
struct PlayerInteractionListenerComponent_InteractionDelegate__DelegateSignature final
{
public:
	class ADBDPlayer*                             Player;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           InteractionSemantic;                               // 0x0008(0x000C)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PlayerInteractionListenerComponent_InteractionDelegate__DelegateSignature) == 0x000008, "Wrong alignment on PlayerInteractionListenerComponent_InteractionDelegate__DelegateSignature");
static_assert(sizeof(PlayerInteractionListenerComponent_InteractionDelegate__DelegateSignature) == 0x000018, "Wrong size on PlayerInteractionListenerComponent_InteractionDelegate__DelegateSignature");
static_assert(offsetof(PlayerInteractionListenerComponent_InteractionDelegate__DelegateSignature, Player) == 0x000000, "Member 'PlayerInteractionListenerComponent_InteractionDelegate__DelegateSignature::Player' has a wrong offset!");
static_assert(offsetof(PlayerInteractionListenerComponent_InteractionDelegate__DelegateSignature, InteractionSemantic) == 0x000008, "Member 'PlayerInteractionListenerComponent_InteractionDelegate__DelegateSignature::InteractionSemantic' has a wrong offset!");

// DelegateFunction DBDGameplay.PlayerInteractionListenerComponent.InteractionMulticastDelegate__DelegateSignature
// 0x0018 (0x0018 - 0x0000)
struct PlayerInteractionListenerComponent_InteractionMulticastDelegate__DelegateSignature final
{
public:
	class ADBDPlayer*                             Player;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           InteractionSemantic;                               // 0x0008(0x000C)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PlayerInteractionListenerComponent_InteractionMulticastDelegate__DelegateSignature) == 0x000008, "Wrong alignment on PlayerInteractionListenerComponent_InteractionMulticastDelegate__DelegateSignature");
static_assert(sizeof(PlayerInteractionListenerComponent_InteractionMulticastDelegate__DelegateSignature) == 0x000018, "Wrong size on PlayerInteractionListenerComponent_InteractionMulticastDelegate__DelegateSignature");
static_assert(offsetof(PlayerInteractionListenerComponent_InteractionMulticastDelegate__DelegateSignature, Player) == 0x000000, "Member 'PlayerInteractionListenerComponent_InteractionMulticastDelegate__DelegateSignature::Player' has a wrong offset!");
static_assert(offsetof(PlayerInteractionListenerComponent_InteractionMulticastDelegate__DelegateSignature, InteractionSemantic) == 0x000008, "Member 'PlayerInteractionListenerComponent_InteractionMulticastDelegate__DelegateSignature::InteractionSemantic' has a wrong offset!");

// Function DBDGameplay.PlayerInteractionListenerComponent.ListenToInteractionEnd
// 0x0028 (0x0028 - 0x0000)
struct PlayerInteractionListenerComponent_ListenToInteractionEnd final
{
public:
	class ADBDPlayer*                             Player;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           InteractionSemantic;                               // 0x0008(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(class ADBDPlayer* Player, const struct FGameplayTag& InteractionSemantic)> InteractionDelegate;                               // 0x0014(0x0014)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerInteractionListenerComponent_ListenToInteractionEnd) == 0x000008, "Wrong alignment on PlayerInteractionListenerComponent_ListenToInteractionEnd");
static_assert(sizeof(PlayerInteractionListenerComponent_ListenToInteractionEnd) == 0x000028, "Wrong size on PlayerInteractionListenerComponent_ListenToInteractionEnd");
static_assert(offsetof(PlayerInteractionListenerComponent_ListenToInteractionEnd, Player) == 0x000000, "Member 'PlayerInteractionListenerComponent_ListenToInteractionEnd::Player' has a wrong offset!");
static_assert(offsetof(PlayerInteractionListenerComponent_ListenToInteractionEnd, InteractionSemantic) == 0x000008, "Member 'PlayerInteractionListenerComponent_ListenToInteractionEnd::InteractionSemantic' has a wrong offset!");
static_assert(offsetof(PlayerInteractionListenerComponent_ListenToInteractionEnd, InteractionDelegate) == 0x000014, "Member 'PlayerInteractionListenerComponent_ListenToInteractionEnd::InteractionDelegate' has a wrong offset!");

// Function DBDGameplay.PlayerInteractionListenerComponent.ListenToInteractionStart
// 0x0028 (0x0028 - 0x0000)
struct PlayerInteractionListenerComponent_ListenToInteractionStart final
{
public:
	class ADBDPlayer*                             Player;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           InteractionSemantic;                               // 0x0008(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(class ADBDPlayer* Player, const struct FGameplayTag& InteractionSemantic)> InteractionDelegate;                               // 0x0014(0x0014)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerInteractionListenerComponent_ListenToInteractionStart) == 0x000008, "Wrong alignment on PlayerInteractionListenerComponent_ListenToInteractionStart");
static_assert(sizeof(PlayerInteractionListenerComponent_ListenToInteractionStart) == 0x000028, "Wrong size on PlayerInteractionListenerComponent_ListenToInteractionStart");
static_assert(offsetof(PlayerInteractionListenerComponent_ListenToInteractionStart, Player) == 0x000000, "Member 'PlayerInteractionListenerComponent_ListenToInteractionStart::Player' has a wrong offset!");
static_assert(offsetof(PlayerInteractionListenerComponent_ListenToInteractionStart, InteractionSemantic) == 0x000008, "Member 'PlayerInteractionListenerComponent_ListenToInteractionStart::InteractionSemantic' has a wrong offset!");
static_assert(offsetof(PlayerInteractionListenerComponent_ListenToInteractionStart, InteractionDelegate) == 0x000014, "Member 'PlayerInteractionListenerComponent_ListenToInteractionStart::InteractionDelegate' has a wrong offset!");

// Function DBDGameplay.PlayerInteractionListenerComponent.OnActorDestroyed
// 0x0008 (0x0008 - 0x0000)
struct PlayerInteractionListenerComponent_OnActorDestroyed final
{
public:
	class AActor*                                 DestroyedActor;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerInteractionListenerComponent_OnActorDestroyed) == 0x000008, "Wrong alignment on PlayerInteractionListenerComponent_OnActorDestroyed");
static_assert(sizeof(PlayerInteractionListenerComponent_OnActorDestroyed) == 0x000008, "Wrong size on PlayerInteractionListenerComponent_OnActorDestroyed");
static_assert(offsetof(PlayerInteractionListenerComponent_OnActorDestroyed, DestroyedActor) == 0x000000, "Member 'PlayerInteractionListenerComponent_OnActorDestroyed::DestroyedActor' has a wrong offset!");

// Function DBDGameplay.PlayerInteractionListenerComponent.UnlistenToInteractionEnd
// 0x0018 (0x0018 - 0x0000)
struct PlayerInteractionListenerComponent_UnlistenToInteractionEnd final
{
public:
	class ADBDPlayer*                             Player;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           InteractionSemantic;                               // 0x0008(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PlayerInteractionListenerComponent_UnlistenToInteractionEnd) == 0x000008, "Wrong alignment on PlayerInteractionListenerComponent_UnlistenToInteractionEnd");
static_assert(sizeof(PlayerInteractionListenerComponent_UnlistenToInteractionEnd) == 0x000018, "Wrong size on PlayerInteractionListenerComponent_UnlistenToInteractionEnd");
static_assert(offsetof(PlayerInteractionListenerComponent_UnlistenToInteractionEnd, Player) == 0x000000, "Member 'PlayerInteractionListenerComponent_UnlistenToInteractionEnd::Player' has a wrong offset!");
static_assert(offsetof(PlayerInteractionListenerComponent_UnlistenToInteractionEnd, InteractionSemantic) == 0x000008, "Member 'PlayerInteractionListenerComponent_UnlistenToInteractionEnd::InteractionSemantic' has a wrong offset!");

// Function DBDGameplay.PlayerInteractionListenerComponent.UnlistenToInteractionStart
// 0x0018 (0x0018 - 0x0000)
struct PlayerInteractionListenerComponent_UnlistenToInteractionStart final
{
public:
	class ADBDPlayer*                             Player;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           InteractionSemantic;                               // 0x0008(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PlayerInteractionListenerComponent_UnlistenToInteractionStart) == 0x000008, "Wrong alignment on PlayerInteractionListenerComponent_UnlistenToInteractionStart");
static_assert(sizeof(PlayerInteractionListenerComponent_UnlistenToInteractionStart) == 0x000018, "Wrong size on PlayerInteractionListenerComponent_UnlistenToInteractionStart");
static_assert(offsetof(PlayerInteractionListenerComponent_UnlistenToInteractionStart, Player) == 0x000000, "Member 'PlayerInteractionListenerComponent_UnlistenToInteractionStart::Player' has a wrong offset!");
static_assert(offsetof(PlayerInteractionListenerComponent_UnlistenToInteractionStart, InteractionSemantic) == 0x000008, "Member 'PlayerInteractionListenerComponent_UnlistenToInteractionStart::InteractionSemantic' has a wrong offset!");

// Function DBDGameplay.PlayerMovementUtilities.Local_ApplyGamepadPitchScaleMultiplier
// 0x0010 (0x0010 - 0x0000)
struct PlayerMovementUtilities_Local_ApplyGamepadPitchScaleMultiplier final
{
public:
	class ADBDPlayer*                             Player;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Multiplier;                                        // 0x0008(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdjustmentTime;                                    // 0x000C(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerMovementUtilities_Local_ApplyGamepadPitchScaleMultiplier) == 0x000008, "Wrong alignment on PlayerMovementUtilities_Local_ApplyGamepadPitchScaleMultiplier");
static_assert(sizeof(PlayerMovementUtilities_Local_ApplyGamepadPitchScaleMultiplier) == 0x000010, "Wrong size on PlayerMovementUtilities_Local_ApplyGamepadPitchScaleMultiplier");
static_assert(offsetof(PlayerMovementUtilities_Local_ApplyGamepadPitchScaleMultiplier, Player) == 0x000000, "Member 'PlayerMovementUtilities_Local_ApplyGamepadPitchScaleMultiplier::Player' has a wrong offset!");
static_assert(offsetof(PlayerMovementUtilities_Local_ApplyGamepadPitchScaleMultiplier, Multiplier) == 0x000008, "Member 'PlayerMovementUtilities_Local_ApplyGamepadPitchScaleMultiplier::Multiplier' has a wrong offset!");
static_assert(offsetof(PlayerMovementUtilities_Local_ApplyGamepadPitchScaleMultiplier, AdjustmentTime) == 0x00000C, "Member 'PlayerMovementUtilities_Local_ApplyGamepadPitchScaleMultiplier::AdjustmentTime' has a wrong offset!");

// Function DBDGameplay.PlayerMovementUtilities.Local_ApplyGamepadYawScaleMultiplier
// 0x0010 (0x0010 - 0x0000)
struct PlayerMovementUtilities_Local_ApplyGamepadYawScaleMultiplier final
{
public:
	class ADBDPlayer*                             Player;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Multiplier;                                        // 0x0008(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdjustmentTime;                                    // 0x000C(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerMovementUtilities_Local_ApplyGamepadYawScaleMultiplier) == 0x000008, "Wrong alignment on PlayerMovementUtilities_Local_ApplyGamepadYawScaleMultiplier");
static_assert(sizeof(PlayerMovementUtilities_Local_ApplyGamepadYawScaleMultiplier) == 0x000010, "Wrong size on PlayerMovementUtilities_Local_ApplyGamepadYawScaleMultiplier");
static_assert(offsetof(PlayerMovementUtilities_Local_ApplyGamepadYawScaleMultiplier, Player) == 0x000000, "Member 'PlayerMovementUtilities_Local_ApplyGamepadYawScaleMultiplier::Player' has a wrong offset!");
static_assert(offsetof(PlayerMovementUtilities_Local_ApplyGamepadYawScaleMultiplier, Multiplier) == 0x000008, "Member 'PlayerMovementUtilities_Local_ApplyGamepadYawScaleMultiplier::Multiplier' has a wrong offset!");
static_assert(offsetof(PlayerMovementUtilities_Local_ApplyGamepadYawScaleMultiplier, AdjustmentTime) == 0x00000C, "Member 'PlayerMovementUtilities_Local_ApplyGamepadYawScaleMultiplier::AdjustmentTime' has a wrong offset!");

// Function DBDGameplay.PlayerMovementUtilities.Local_ApplyMousePitchScaleMultiplier
// 0x0010 (0x0010 - 0x0000)
struct PlayerMovementUtilities_Local_ApplyMousePitchScaleMultiplier final
{
public:
	class ADBDPlayer*                             Player;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Multiplier;                                        // 0x0008(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdjustmentTime;                                    // 0x000C(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerMovementUtilities_Local_ApplyMousePitchScaleMultiplier) == 0x000008, "Wrong alignment on PlayerMovementUtilities_Local_ApplyMousePitchScaleMultiplier");
static_assert(sizeof(PlayerMovementUtilities_Local_ApplyMousePitchScaleMultiplier) == 0x000010, "Wrong size on PlayerMovementUtilities_Local_ApplyMousePitchScaleMultiplier");
static_assert(offsetof(PlayerMovementUtilities_Local_ApplyMousePitchScaleMultiplier, Player) == 0x000000, "Member 'PlayerMovementUtilities_Local_ApplyMousePitchScaleMultiplier::Player' has a wrong offset!");
static_assert(offsetof(PlayerMovementUtilities_Local_ApplyMousePitchScaleMultiplier, Multiplier) == 0x000008, "Member 'PlayerMovementUtilities_Local_ApplyMousePitchScaleMultiplier::Multiplier' has a wrong offset!");
static_assert(offsetof(PlayerMovementUtilities_Local_ApplyMousePitchScaleMultiplier, AdjustmentTime) == 0x00000C, "Member 'PlayerMovementUtilities_Local_ApplyMousePitchScaleMultiplier::AdjustmentTime' has a wrong offset!");

// Function DBDGameplay.PlayerMovementUtilities.Local_ApplyMouseYawScaleMultiplier
// 0x0010 (0x0010 - 0x0000)
struct PlayerMovementUtilities_Local_ApplyMouseYawScaleMultiplier final
{
public:
	class ADBDPlayer*                             Player;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Multiplier;                                        // 0x0008(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdjustmentTime;                                    // 0x000C(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerMovementUtilities_Local_ApplyMouseYawScaleMultiplier) == 0x000008, "Wrong alignment on PlayerMovementUtilities_Local_ApplyMouseYawScaleMultiplier");
static_assert(sizeof(PlayerMovementUtilities_Local_ApplyMouseYawScaleMultiplier) == 0x000010, "Wrong size on PlayerMovementUtilities_Local_ApplyMouseYawScaleMultiplier");
static_assert(offsetof(PlayerMovementUtilities_Local_ApplyMouseYawScaleMultiplier, Player) == 0x000000, "Member 'PlayerMovementUtilities_Local_ApplyMouseYawScaleMultiplier::Player' has a wrong offset!");
static_assert(offsetof(PlayerMovementUtilities_Local_ApplyMouseYawScaleMultiplier, Multiplier) == 0x000008, "Member 'PlayerMovementUtilities_Local_ApplyMouseYawScaleMultiplier::Multiplier' has a wrong offset!");
static_assert(offsetof(PlayerMovementUtilities_Local_ApplyMouseYawScaleMultiplier, AdjustmentTime) == 0x00000C, "Member 'PlayerMovementUtilities_Local_ApplyMouseYawScaleMultiplier::AdjustmentTime' has a wrong offset!");

// Function DBDGameplay.PlayerMovementUtilities.Local_ApplyPitchScaleMultiplier
// 0x0010 (0x0010 - 0x0000)
struct PlayerMovementUtilities_Local_ApplyPitchScaleMultiplier final
{
public:
	class ADBDPlayer*                             Player;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Multiplier;                                        // 0x0008(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdjustmentTime;                                    // 0x000C(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerMovementUtilities_Local_ApplyPitchScaleMultiplier) == 0x000008, "Wrong alignment on PlayerMovementUtilities_Local_ApplyPitchScaleMultiplier");
static_assert(sizeof(PlayerMovementUtilities_Local_ApplyPitchScaleMultiplier) == 0x000010, "Wrong size on PlayerMovementUtilities_Local_ApplyPitchScaleMultiplier");
static_assert(offsetof(PlayerMovementUtilities_Local_ApplyPitchScaleMultiplier, Player) == 0x000000, "Member 'PlayerMovementUtilities_Local_ApplyPitchScaleMultiplier::Player' has a wrong offset!");
static_assert(offsetof(PlayerMovementUtilities_Local_ApplyPitchScaleMultiplier, Multiplier) == 0x000008, "Member 'PlayerMovementUtilities_Local_ApplyPitchScaleMultiplier::Multiplier' has a wrong offset!");
static_assert(offsetof(PlayerMovementUtilities_Local_ApplyPitchScaleMultiplier, AdjustmentTime) == 0x00000C, "Member 'PlayerMovementUtilities_Local_ApplyPitchScaleMultiplier::AdjustmentTime' has a wrong offset!");

// Function DBDGameplay.PlayerMovementUtilities.Local_ApplyRotationScaleMultiplier
// 0x0010 (0x0010 - 0x0000)
struct PlayerMovementUtilities_Local_ApplyRotationScaleMultiplier final
{
public:
	class ADBDPlayer*                             Player;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Multiplier;                                        // 0x0008(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdjustmentTime;                                    // 0x000C(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerMovementUtilities_Local_ApplyRotationScaleMultiplier) == 0x000008, "Wrong alignment on PlayerMovementUtilities_Local_ApplyRotationScaleMultiplier");
static_assert(sizeof(PlayerMovementUtilities_Local_ApplyRotationScaleMultiplier) == 0x000010, "Wrong size on PlayerMovementUtilities_Local_ApplyRotationScaleMultiplier");
static_assert(offsetof(PlayerMovementUtilities_Local_ApplyRotationScaleMultiplier, Player) == 0x000000, "Member 'PlayerMovementUtilities_Local_ApplyRotationScaleMultiplier::Player' has a wrong offset!");
static_assert(offsetof(PlayerMovementUtilities_Local_ApplyRotationScaleMultiplier, Multiplier) == 0x000008, "Member 'PlayerMovementUtilities_Local_ApplyRotationScaleMultiplier::Multiplier' has a wrong offset!");
static_assert(offsetof(PlayerMovementUtilities_Local_ApplyRotationScaleMultiplier, AdjustmentTime) == 0x00000C, "Member 'PlayerMovementUtilities_Local_ApplyRotationScaleMultiplier::AdjustmentTime' has a wrong offset!");

// Function DBDGameplay.PlayerMovementUtilities.Local_ApplyYawScaleMultiplier
// 0x0010 (0x0010 - 0x0000)
struct PlayerMovementUtilities_Local_ApplyYawScaleMultiplier final
{
public:
	class ADBDPlayer*                             Player;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Multiplier;                                        // 0x0008(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdjustmentTime;                                    // 0x000C(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerMovementUtilities_Local_ApplyYawScaleMultiplier) == 0x000008, "Wrong alignment on PlayerMovementUtilities_Local_ApplyYawScaleMultiplier");
static_assert(sizeof(PlayerMovementUtilities_Local_ApplyYawScaleMultiplier) == 0x000010, "Wrong size on PlayerMovementUtilities_Local_ApplyYawScaleMultiplier");
static_assert(offsetof(PlayerMovementUtilities_Local_ApplyYawScaleMultiplier, Player) == 0x000000, "Member 'PlayerMovementUtilities_Local_ApplyYawScaleMultiplier::Player' has a wrong offset!");
static_assert(offsetof(PlayerMovementUtilities_Local_ApplyYawScaleMultiplier, Multiplier) == 0x000008, "Member 'PlayerMovementUtilities_Local_ApplyYawScaleMultiplier::Multiplier' has a wrong offset!");
static_assert(offsetof(PlayerMovementUtilities_Local_ApplyYawScaleMultiplier, AdjustmentTime) == 0x00000C, "Member 'PlayerMovementUtilities_Local_ApplyYawScaleMultiplier::AdjustmentTime' has a wrong offset!");

// Function DBDGameplay.PlayerMovementUtilities.Local_ResetGamepadLookCurves
// 0x0008 (0x0008 - 0x0000)
struct PlayerMovementUtilities_Local_ResetGamepadLookCurves final
{
public:
	class ADBDPlayer*                             Player;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerMovementUtilities_Local_ResetGamepadLookCurves) == 0x000008, "Wrong alignment on PlayerMovementUtilities_Local_ResetGamepadLookCurves");
static_assert(sizeof(PlayerMovementUtilities_Local_ResetGamepadLookCurves) == 0x000008, "Wrong size on PlayerMovementUtilities_Local_ResetGamepadLookCurves");
static_assert(offsetof(PlayerMovementUtilities_Local_ResetGamepadLookCurves, Player) == 0x000000, "Member 'PlayerMovementUtilities_Local_ResetGamepadLookCurves::Player' has a wrong offset!");

// Function DBDGameplay.PlayerMovementUtilities.Local_ResetRotationScale
// 0x0010 (0x0010 - 0x0000)
struct PlayerMovementUtilities_Local_ResetRotationScale final
{
public:
	class ADBDPlayer*                             Player;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdjustmentTime;                                    // 0x0008(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PlayerMovementUtilities_Local_ResetRotationScale) == 0x000008, "Wrong alignment on PlayerMovementUtilities_Local_ResetRotationScale");
static_assert(sizeof(PlayerMovementUtilities_Local_ResetRotationScale) == 0x000010, "Wrong size on PlayerMovementUtilities_Local_ResetRotationScale");
static_assert(offsetof(PlayerMovementUtilities_Local_ResetRotationScale, Player) == 0x000000, "Member 'PlayerMovementUtilities_Local_ResetRotationScale::Player' has a wrong offset!");
static_assert(offsetof(PlayerMovementUtilities_Local_ResetRotationScale, AdjustmentTime) == 0x000008, "Member 'PlayerMovementUtilities_Local_ResetRotationScale::AdjustmentTime' has a wrong offset!");

// Function DBDGameplay.PlayerMovementUtilities.Local_SetGamepadPitchCurve
// 0x0010 (0x0010 - 0x0000)
struct PlayerMovementUtilities_Local_SetGamepadPitchCurve final
{
public:
	class ADBDPlayer*                             Player;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            Curve;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerMovementUtilities_Local_SetGamepadPitchCurve) == 0x000008, "Wrong alignment on PlayerMovementUtilities_Local_SetGamepadPitchCurve");
static_assert(sizeof(PlayerMovementUtilities_Local_SetGamepadPitchCurve) == 0x000010, "Wrong size on PlayerMovementUtilities_Local_SetGamepadPitchCurve");
static_assert(offsetof(PlayerMovementUtilities_Local_SetGamepadPitchCurve, Player) == 0x000000, "Member 'PlayerMovementUtilities_Local_SetGamepadPitchCurve::Player' has a wrong offset!");
static_assert(offsetof(PlayerMovementUtilities_Local_SetGamepadPitchCurve, Curve) == 0x000008, "Member 'PlayerMovementUtilities_Local_SetGamepadPitchCurve::Curve' has a wrong offset!");

// Function DBDGameplay.PlayerMovementUtilities.Local_SetGamepadYawCurve
// 0x0010 (0x0010 - 0x0000)
struct PlayerMovementUtilities_Local_SetGamepadYawCurve final
{
public:
	class ADBDPlayer*                             Player;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            Curve;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerMovementUtilities_Local_SetGamepadYawCurve) == 0x000008, "Wrong alignment on PlayerMovementUtilities_Local_SetGamepadYawCurve");
static_assert(sizeof(PlayerMovementUtilities_Local_SetGamepadYawCurve) == 0x000010, "Wrong size on PlayerMovementUtilities_Local_SetGamepadYawCurve");
static_assert(offsetof(PlayerMovementUtilities_Local_SetGamepadYawCurve, Player) == 0x000000, "Member 'PlayerMovementUtilities_Local_SetGamepadYawCurve::Player' has a wrong offset!");
static_assert(offsetof(PlayerMovementUtilities_Local_SetGamepadYawCurve, Curve) == 0x000008, "Member 'PlayerMovementUtilities_Local_SetGamepadYawCurve::Curve' has a wrong offset!");

// Function DBDGameplay.PlayersInZoneTracker.Authority_OnBeginPlayerOverlap
// 0x0110 (0x0110 - 0x0000)
struct PlayersInZoneTracker_Authority_OnBeginPlayerOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Other;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x00F0)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayersInZoneTracker_Authority_OnBeginPlayerOverlap) == 0x000008, "Wrong alignment on PlayersInZoneTracker_Authority_OnBeginPlayerOverlap");
static_assert(sizeof(PlayersInZoneTracker_Authority_OnBeginPlayerOverlap) == 0x000110, "Wrong size on PlayersInZoneTracker_Authority_OnBeginPlayerOverlap");
static_assert(offsetof(PlayersInZoneTracker_Authority_OnBeginPlayerOverlap, OverlappedComponent) == 0x000000, "Member 'PlayersInZoneTracker_Authority_OnBeginPlayerOverlap::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(PlayersInZoneTracker_Authority_OnBeginPlayerOverlap, Other) == 0x000008, "Member 'PlayersInZoneTracker_Authority_OnBeginPlayerOverlap::Other' has a wrong offset!");
static_assert(offsetof(PlayersInZoneTracker_Authority_OnBeginPlayerOverlap, OtherComp) == 0x000010, "Member 'PlayersInZoneTracker_Authority_OnBeginPlayerOverlap::OtherComp' has a wrong offset!");
static_assert(offsetof(PlayersInZoneTracker_Authority_OnBeginPlayerOverlap, OtherBodyIndex) == 0x000018, "Member 'PlayersInZoneTracker_Authority_OnBeginPlayerOverlap::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(PlayersInZoneTracker_Authority_OnBeginPlayerOverlap, bFromSweep) == 0x00001C, "Member 'PlayersInZoneTracker_Authority_OnBeginPlayerOverlap::bFromSweep' has a wrong offset!");
static_assert(offsetof(PlayersInZoneTracker_Authority_OnBeginPlayerOverlap, SweepResult) == 0x000020, "Member 'PlayersInZoneTracker_Authority_OnBeginPlayerOverlap::SweepResult' has a wrong offset!");

// Function DBDGameplay.PlayersInZoneTracker.Authority_OnEndPlayerOverlap
// 0x0020 (0x0020 - 0x0000)
struct PlayersInZoneTracker_Authority_OnEndPlayerOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PlayersInZoneTracker_Authority_OnEndPlayerOverlap) == 0x000008, "Wrong alignment on PlayersInZoneTracker_Authority_OnEndPlayerOverlap");
static_assert(sizeof(PlayersInZoneTracker_Authority_OnEndPlayerOverlap) == 0x000020, "Wrong size on PlayersInZoneTracker_Authority_OnEndPlayerOverlap");
static_assert(offsetof(PlayersInZoneTracker_Authority_OnEndPlayerOverlap, OverlappedComponent) == 0x000000, "Member 'PlayersInZoneTracker_Authority_OnEndPlayerOverlap::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(PlayersInZoneTracker_Authority_OnEndPlayerOverlap, OtherActor) == 0x000008, "Member 'PlayersInZoneTracker_Authority_OnEndPlayerOverlap::OtherActor' has a wrong offset!");
static_assert(offsetof(PlayersInZoneTracker_Authority_OnEndPlayerOverlap, OtherComp) == 0x000010, "Member 'PlayersInZoneTracker_Authority_OnEndPlayerOverlap::OtherComp' has a wrong offset!");
static_assert(offsetof(PlayersInZoneTracker_Authority_OnEndPlayerOverlap, OtherBodyIndex) == 0x000018, "Member 'PlayersInZoneTracker_Authority_OnEndPlayerOverlap::OtherBodyIndex' has a wrong offset!");

// DelegateFunction DBDGameplay.PlayersInZoneTracker.OnCosmeticNeeded__DelegateSignature
// 0x0008 (0x0008 - 0x0000)
struct PlayersInZoneTracker_OnCosmeticNeeded__DelegateSignature final
{
public:
	class ADBDPlayer*                             Player;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayersInZoneTracker_OnCosmeticNeeded__DelegateSignature) == 0x000008, "Wrong alignment on PlayersInZoneTracker_OnCosmeticNeeded__DelegateSignature");
static_assert(sizeof(PlayersInZoneTracker_OnCosmeticNeeded__DelegateSignature) == 0x000008, "Wrong size on PlayersInZoneTracker_OnCosmeticNeeded__DelegateSignature");
static_assert(offsetof(PlayersInZoneTracker_OnCosmeticNeeded__DelegateSignature, Player) == 0x000000, "Member 'PlayersInZoneTracker_OnCosmeticNeeded__DelegateSignature::Player' has a wrong offset!");

// Function DBDGameplay.PowerChargeComponent.OnCurrentChargeChanged
// 0x0004 (0x0004 - 0x0000)
struct PowerChargeComponent_OnCurrentChargeChanged final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PowerChargeComponent_OnCurrentChargeChanged) == 0x000004, "Wrong alignment on PowerChargeComponent_OnCurrentChargeChanged");
static_assert(sizeof(PowerChargeComponent_OnCurrentChargeChanged) == 0x000004, "Wrong size on PowerChargeComponent_OnCurrentChargeChanged");
static_assert(offsetof(PowerChargeComponent_OnCurrentChargeChanged, Value) == 0x000000, "Member 'PowerChargeComponent_OnCurrentChargeChanged::Value' has a wrong offset!");

// Function DBDGameplay.RacoonDogComponent.Authority_OnPlayerInRangeChanged
// 0x0010 (0x0010 - 0x0000)
struct RacoonDogComponent_Authority_OnPlayerInRangeChanged final
{
public:
	class AActor*                                 PlayerActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsInRange;                                         // 0x0008(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(RacoonDogComponent_Authority_OnPlayerInRangeChanged) == 0x000008, "Wrong alignment on RacoonDogComponent_Authority_OnPlayerInRangeChanged");
static_assert(sizeof(RacoonDogComponent_Authority_OnPlayerInRangeChanged) == 0x000010, "Wrong size on RacoonDogComponent_Authority_OnPlayerInRangeChanged");
static_assert(offsetof(RacoonDogComponent_Authority_OnPlayerInRangeChanged, PlayerActor) == 0x000000, "Member 'RacoonDogComponent_Authority_OnPlayerInRangeChanged::PlayerActor' has a wrong offset!");
static_assert(offsetof(RacoonDogComponent_Authority_OnPlayerInRangeChanged, IsInRange) == 0x000008, "Member 'RacoonDogComponent_Authority_OnPlayerInRangeChanged::IsInRange' has a wrong offset!");

// Function DBDGameplay.RacoonDogComponent.Authority_OnPlayerIsLookingTowardsChanged
// 0x0010 (0x0010 - 0x0000)
struct RacoonDogComponent_Authority_OnPlayerIsLookingTowardsChanged final
{
public:
	bool                                          IsLookingTowards;                                  // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	const class ADBDPlayer*                       Player;                                            // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RacoonDogComponent_Authority_OnPlayerIsLookingTowardsChanged) == 0x000008, "Wrong alignment on RacoonDogComponent_Authority_OnPlayerIsLookingTowardsChanged");
static_assert(sizeof(RacoonDogComponent_Authority_OnPlayerIsLookingTowardsChanged) == 0x000010, "Wrong size on RacoonDogComponent_Authority_OnPlayerIsLookingTowardsChanged");
static_assert(offsetof(RacoonDogComponent_Authority_OnPlayerIsLookingTowardsChanged, IsLookingTowards) == 0x000000, "Member 'RacoonDogComponent_Authority_OnPlayerIsLookingTowardsChanged::IsLookingTowards' has a wrong offset!");
static_assert(offsetof(RacoonDogComponent_Authority_OnPlayerIsLookingTowardsChanged, Player) == 0x000008, "Member 'RacoonDogComponent_Authority_OnPlayerIsLookingTowardsChanged::Player' has a wrong offset!");

// Function DBDGameplay.RacoonDogComponent.Authority_OnPossessedPawnChanged
// 0x0010 (0x0010 - 0x0000)
struct RacoonDogComponent_Authority_OnPossessedPawnChanged final
{
public:
	class APawn*                                  OldPawn;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APawn*                                  NewPawn;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RacoonDogComponent_Authority_OnPossessedPawnChanged) == 0x000008, "Wrong alignment on RacoonDogComponent_Authority_OnPossessedPawnChanged");
static_assert(sizeof(RacoonDogComponent_Authority_OnPossessedPawnChanged) == 0x000010, "Wrong size on RacoonDogComponent_Authority_OnPossessedPawnChanged");
static_assert(offsetof(RacoonDogComponent_Authority_OnPossessedPawnChanged, OldPawn) == 0x000000, "Member 'RacoonDogComponent_Authority_OnPossessedPawnChanged::OldPawn' has a wrong offset!");
static_assert(offsetof(RacoonDogComponent_Authority_OnPossessedPawnChanged, NewPawn) == 0x000008, "Member 'RacoonDogComponent_Authority_OnPossessedPawnChanged::NewPawn' has a wrong offset!");

// Function DBDGameplay.RacoonDogComponent.DBD_SetSelectedRacoonDogAnimIndex
// 0x0001 (0x0001 - 0x0000)
struct RacoonDogComponent_DBD_SetSelectedRacoonDogAnimIndex final
{
public:
	uint8                                         Param_Index;                                       // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RacoonDogComponent_DBD_SetSelectedRacoonDogAnimIndex) == 0x000001, "Wrong alignment on RacoonDogComponent_DBD_SetSelectedRacoonDogAnimIndex");
static_assert(sizeof(RacoonDogComponent_DBD_SetSelectedRacoonDogAnimIndex) == 0x000001, "Wrong size on RacoonDogComponent_DBD_SetSelectedRacoonDogAnimIndex");
static_assert(offsetof(RacoonDogComponent_DBD_SetSelectedRacoonDogAnimIndex, Param_Index) == 0x000000, "Member 'RacoonDogComponent_DBD_SetSelectedRacoonDogAnimIndex::Param_Index' has a wrong offset!");

// Function DBDGameplay.RangedExplosiveEffectHandlerComponent.OnRangedExplosiveDestroyed
// 0x0008 (0x0008 - 0x0000)
struct RangedExplosiveEffectHandlerComponent_OnRangedExplosiveDestroyed final
{
public:
	class AActor*                                 DestroyedActor;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RangedExplosiveEffectHandlerComponent_OnRangedExplosiveDestroyed) == 0x000008, "Wrong alignment on RangedExplosiveEffectHandlerComponent_OnRangedExplosiveDestroyed");
static_assert(sizeof(RangedExplosiveEffectHandlerComponent_OnRangedExplosiveDestroyed) == 0x000008, "Wrong size on RangedExplosiveEffectHandlerComponent_OnRangedExplosiveDestroyed");
static_assert(offsetof(RangedExplosiveEffectHandlerComponent_OnRangedExplosiveDestroyed, DestroyedActor) == 0x000000, "Member 'RangedExplosiveEffectHandlerComponent_OnRangedExplosiveDestroyed::DestroyedActor' has a wrong offset!");

// Function DBDGameplay.RespawnableComponent.Authority_TryTeleport
// 0x0001 (0x0001 - 0x0000)
struct RespawnableComponent_Authority_TryTeleport final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RespawnableComponent_Authority_TryTeleport) == 0x000001, "Wrong alignment on RespawnableComponent_Authority_TryTeleport");
static_assert(sizeof(RespawnableComponent_Authority_TryTeleport) == 0x000001, "Wrong size on RespawnableComponent_Authority_TryTeleport");
static_assert(offsetof(RespawnableComponent_Authority_TryTeleport, ReturnValue) == 0x000000, "Member 'RespawnableComponent_Authority_TryTeleport::ReturnValue' has a wrong offset!");

// Function DBDGameplay.SteamPipe.Authority_OnBeginOverlap
// 0x0110 (0x0110 - 0x0000)
struct SteamPipe_Authority_OnBeginOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x00F0)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(SteamPipe_Authority_OnBeginOverlap) == 0x000008, "Wrong alignment on SteamPipe_Authority_OnBeginOverlap");
static_assert(sizeof(SteamPipe_Authority_OnBeginOverlap) == 0x000110, "Wrong size on SteamPipe_Authority_OnBeginOverlap");
static_assert(offsetof(SteamPipe_Authority_OnBeginOverlap, OverlappedComponent) == 0x000000, "Member 'SteamPipe_Authority_OnBeginOverlap::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(SteamPipe_Authority_OnBeginOverlap, OtherActor) == 0x000008, "Member 'SteamPipe_Authority_OnBeginOverlap::OtherActor' has a wrong offset!");
static_assert(offsetof(SteamPipe_Authority_OnBeginOverlap, OtherComp) == 0x000010, "Member 'SteamPipe_Authority_OnBeginOverlap::OtherComp' has a wrong offset!");
static_assert(offsetof(SteamPipe_Authority_OnBeginOverlap, OtherBodyIndex) == 0x000018, "Member 'SteamPipe_Authority_OnBeginOverlap::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(SteamPipe_Authority_OnBeginOverlap, bFromSweep) == 0x00001C, "Member 'SteamPipe_Authority_OnBeginOverlap::bFromSweep' has a wrong offset!");
static_assert(offsetof(SteamPipe_Authority_OnBeginOverlap, SweepResult) == 0x000020, "Member 'SteamPipe_Authority_OnBeginOverlap::SweepResult' has a wrong offset!");

// Function DBDGameplay.SteamPipe.Authority_OnEndOverlap
// 0x0020 (0x0020 - 0x0000)
struct SteamPipe_Authority_OnEndOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SteamPipe_Authority_OnEndOverlap) == 0x000008, "Wrong alignment on SteamPipe_Authority_OnEndOverlap");
static_assert(sizeof(SteamPipe_Authority_OnEndOverlap) == 0x000020, "Wrong size on SteamPipe_Authority_OnEndOverlap");
static_assert(offsetof(SteamPipe_Authority_OnEndOverlap, OverlappedComponent) == 0x000000, "Member 'SteamPipe_Authority_OnEndOverlap::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(SteamPipe_Authority_OnEndOverlap, OtherActor) == 0x000008, "Member 'SteamPipe_Authority_OnEndOverlap::OtherActor' has a wrong offset!");
static_assert(offsetof(SteamPipe_Authority_OnEndOverlap, OtherComp) == 0x000010, "Member 'SteamPipe_Authority_OnEndOverlap::OtherComp' has a wrong offset!");
static_assert(offsetof(SteamPipe_Authority_OnEndOverlap, OtherBodyIndex) == 0x000018, "Member 'SteamPipe_Authority_OnEndOverlap::OtherBodyIndex' has a wrong offset!");

// Function DBDGameplay.SteamPipe.Cosmetic_OnSteamPipeStateChanged
// 0x0001 (0x0001 - 0x0000)
struct SteamPipe_Cosmetic_OnSteamPipeStateChanged final
{
public:
	ESteamPipeState                               NewState;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SteamPipe_Cosmetic_OnSteamPipeStateChanged) == 0x000001, "Wrong alignment on SteamPipe_Cosmetic_OnSteamPipeStateChanged");
static_assert(sizeof(SteamPipe_Cosmetic_OnSteamPipeStateChanged) == 0x000001, "Wrong size on SteamPipe_Cosmetic_OnSteamPipeStateChanged");
static_assert(offsetof(SteamPipe_Cosmetic_OnSteamPipeStateChanged, NewState) == 0x000000, "Member 'SteamPipe_Cosmetic_OnSteamPipeStateChanged::NewState' has a wrong offset!");

// Function DBDGameplay.SteamPipe.GetCurrentSteamPipeState
// 0x0001 (0x0001 - 0x0000)
struct SteamPipe_GetCurrentSteamPipeState final
{
public:
	ESteamPipeState                               ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SteamPipe_GetCurrentSteamPipeState) == 0x000001, "Wrong alignment on SteamPipe_GetCurrentSteamPipeState");
static_assert(sizeof(SteamPipe_GetCurrentSteamPipeState) == 0x000001, "Wrong size on SteamPipe_GetCurrentSteamPipeState");
static_assert(offsetof(SteamPipe_GetCurrentSteamPipeState, ReturnValue) == 0x000000, "Member 'SteamPipe_GetCurrentSteamPipeState::ReturnValue' has a wrong offset!");

// Function DBDGameplay.SteamPipeEffectComponent.Authority_OnHealthStateChanged
// 0x0040 (0x0040 - 0x0000)
struct SteamPipeEffectComponent_Authority_OnHealthStateChanged final
{
public:
	struct FGameplayTag                           GameplayTag;                                       // 0x0000(0x000C)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameEventData                         GameEventData;                                     // 0x0010(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(SteamPipeEffectComponent_Authority_OnHealthStateChanged) == 0x000008, "Wrong alignment on SteamPipeEffectComponent_Authority_OnHealthStateChanged");
static_assert(sizeof(SteamPipeEffectComponent_Authority_OnHealthStateChanged) == 0x000040, "Wrong size on SteamPipeEffectComponent_Authority_OnHealthStateChanged");
static_assert(offsetof(SteamPipeEffectComponent_Authority_OnHealthStateChanged, GameplayTag) == 0x000000, "Member 'SteamPipeEffectComponent_Authority_OnHealthStateChanged::GameplayTag' has a wrong offset!");
static_assert(offsetof(SteamPipeEffectComponent_Authority_OnHealthStateChanged, GameEventData) == 0x000010, "Member 'SteamPipeEffectComponent_Authority_OnHealthStateChanged::GameEventData' has a wrong offset!");

// Function DBDGameplay.SteamPipeEffectComponent.Authority_OnStoppedCrouching
// 0x0040 (0x0040 - 0x0000)
struct SteamPipeEffectComponent_Authority_OnStoppedCrouching final
{
public:
	struct FGameplayTag                           GameplayTag;                                       // 0x0000(0x000C)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameEventData                         GameEventData;                                     // 0x0010(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(SteamPipeEffectComponent_Authority_OnStoppedCrouching) == 0x000008, "Wrong alignment on SteamPipeEffectComponent_Authority_OnStoppedCrouching");
static_assert(sizeof(SteamPipeEffectComponent_Authority_OnStoppedCrouching) == 0x000040, "Wrong size on SteamPipeEffectComponent_Authority_OnStoppedCrouching");
static_assert(offsetof(SteamPipeEffectComponent_Authority_OnStoppedCrouching, GameplayTag) == 0x000000, "Member 'SteamPipeEffectComponent_Authority_OnStoppedCrouching::GameplayTag' has a wrong offset!");
static_assert(offsetof(SteamPipeEffectComponent_Authority_OnStoppedCrouching, GameEventData) == 0x000010, "Member 'SteamPipeEffectComponent_Authority_OnStoppedCrouching::GameEventData' has a wrong offset!");

// Function DBDGameplay.SteamPipeManagerComponent.Authority_OnCharacterAdded
// 0x0008 (0x0008 - 0x0000)
struct SteamPipeManagerComponent_Authority_OnCharacterAdded final
{
public:
	class ADBDPlayer*                             Character;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SteamPipeManagerComponent_Authority_OnCharacterAdded) == 0x000008, "Wrong alignment on SteamPipeManagerComponent_Authority_OnCharacterAdded");
static_assert(sizeof(SteamPipeManagerComponent_Authority_OnCharacterAdded) == 0x000008, "Wrong size on SteamPipeManagerComponent_Authority_OnCharacterAdded");
static_assert(offsetof(SteamPipeManagerComponent_Authority_OnCharacterAdded, Character) == 0x000000, "Member 'SteamPipeManagerComponent_Authority_OnCharacterAdded::Character' has a wrong offset!");

// Function DBDGameplay.SteamPipeManagerComponent.Authority_OnResetInteractionComplete
// 0x0018 (0x0018 - 0x0000)
struct SteamPipeManagerComponent_Authority_OnResetInteractionComplete final
{
public:
	bool                                          COMPLETED;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         InstigatorsForCompletion;                          // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(SteamPipeManagerComponent_Authority_OnResetInteractionComplete) == 0x000008, "Wrong alignment on SteamPipeManagerComponent_Authority_OnResetInteractionComplete");
static_assert(sizeof(SteamPipeManagerComponent_Authority_OnResetInteractionComplete) == 0x000018, "Wrong size on SteamPipeManagerComponent_Authority_OnResetInteractionComplete");
static_assert(offsetof(SteamPipeManagerComponent_Authority_OnResetInteractionComplete, COMPLETED) == 0x000000, "Member 'SteamPipeManagerComponent_Authority_OnResetInteractionComplete::COMPLETED' has a wrong offset!");
static_assert(offsetof(SteamPipeManagerComponent_Authority_OnResetInteractionComplete, InstigatorsForCompletion) == 0x000008, "Member 'SteamPipeManagerComponent_Authority_OnResetInteractionComplete::InstigatorsForCompletion' has a wrong offset!");

// Function DBDGameplay.SteamPipeManagerComponent.Authority_OnSteamPipeStateChanged
// 0x0010 (0x0010 - 0x0000)
struct SteamPipeManagerComponent_Authority_OnSteamPipeStateChanged final
{
public:
	const class ASteamPipe*                       SteamPipe;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESteamPipeState                               NewState;                                          // 0x0008(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SteamPipeManagerComponent_Authority_OnSteamPipeStateChanged) == 0x000008, "Wrong alignment on SteamPipeManagerComponent_Authority_OnSteamPipeStateChanged");
static_assert(sizeof(SteamPipeManagerComponent_Authority_OnSteamPipeStateChanged) == 0x000010, "Wrong size on SteamPipeManagerComponent_Authority_OnSteamPipeStateChanged");
static_assert(offsetof(SteamPipeManagerComponent_Authority_OnSteamPipeStateChanged, SteamPipe) == 0x000000, "Member 'SteamPipeManagerComponent_Authority_OnSteamPipeStateChanged::SteamPipe' has a wrong offset!");
static_assert(offsetof(SteamPipeManagerComponent_Authority_OnSteamPipeStateChanged, NewState) == 0x000008, "Member 'SteamPipeManagerComponent_Authority_OnSteamPipeStateChanged::NewState' has a wrong offset!");

// Function DBDGameplay.SteamPipeResetSwitch.Cosmetic_NumberOfDisabledSteamPipesChanged
// 0x0004 (0x0004 - 0x0000)
struct SteamPipeResetSwitch_Cosmetic_NumberOfDisabledSteamPipesChanged final
{
public:
	int32                                         NumberOfDisabledSteamPipes;                        // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SteamPipeResetSwitch_Cosmetic_NumberOfDisabledSteamPipesChanged) == 0x000004, "Wrong alignment on SteamPipeResetSwitch_Cosmetic_NumberOfDisabledSteamPipesChanged");
static_assert(sizeof(SteamPipeResetSwitch_Cosmetic_NumberOfDisabledSteamPipesChanged) == 0x000004, "Wrong size on SteamPipeResetSwitch_Cosmetic_NumberOfDisabledSteamPipesChanged");
static_assert(offsetof(SteamPipeResetSwitch_Cosmetic_NumberOfDisabledSteamPipesChanged, NumberOfDisabledSteamPipes) == 0x000000, "Member 'SteamPipeResetSwitch_Cosmetic_NumberOfDisabledSteamPipesChanged::NumberOfDisabledSteamPipes' has a wrong offset!");

// Function DBDGameplay.SteamPipeResetSwitch.Cosmetic_OnSwitchTriggered
// 0x0004 (0x0004 - 0x0000)
struct SteamPipeResetSwitch_Cosmetic_OnSwitchTriggered final
{
public:
	float                                         CooldownTime;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SteamPipeResetSwitch_Cosmetic_OnSwitchTriggered) == 0x000004, "Wrong alignment on SteamPipeResetSwitch_Cosmetic_OnSwitchTriggered");
static_assert(sizeof(SteamPipeResetSwitch_Cosmetic_OnSwitchTriggered) == 0x000004, "Wrong size on SteamPipeResetSwitch_Cosmetic_OnSwitchTriggered");
static_assert(offsetof(SteamPipeResetSwitch_Cosmetic_OnSwitchTriggered, CooldownTime) == 0x000000, "Member 'SteamPipeResetSwitch_Cosmetic_OnSwitchTriggered::CooldownTime' has a wrong offset!");

// Function DBDGameplay.SteamPipeResetSwitch.Cosmetic_OnTotalSteamPipesInLevelChanged
// 0x0004 (0x0004 - 0x0000)
struct SteamPipeResetSwitch_Cosmetic_OnTotalSteamPipesInLevelChanged final
{
public:
	int32                                         TotalSteamPipesInLevel;                            // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SteamPipeResetSwitch_Cosmetic_OnTotalSteamPipesInLevelChanged) == 0x000004, "Wrong alignment on SteamPipeResetSwitch_Cosmetic_OnTotalSteamPipesInLevelChanged");
static_assert(sizeof(SteamPipeResetSwitch_Cosmetic_OnTotalSteamPipesInLevelChanged) == 0x000004, "Wrong size on SteamPipeResetSwitch_Cosmetic_OnTotalSteamPipesInLevelChanged");
static_assert(offsetof(SteamPipeResetSwitch_Cosmetic_OnTotalSteamPipesInLevelChanged, TotalSteamPipesInLevel) == 0x000000, "Member 'SteamPipeResetSwitch_Cosmetic_OnTotalSteamPipesInLevelChanged::TotalSteamPipesInLevel' has a wrong offset!");

// Function DBDGameplay.SteamPipeResetSwitch.GetTotalSteamPipesInLevel
// 0x0004 (0x0004 - 0x0000)
struct SteamPipeResetSwitch_GetTotalSteamPipesInLevel final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SteamPipeResetSwitch_GetTotalSteamPipesInLevel) == 0x000004, "Wrong alignment on SteamPipeResetSwitch_GetTotalSteamPipesInLevel");
static_assert(sizeof(SteamPipeResetSwitch_GetTotalSteamPipesInLevel) == 0x000004, "Wrong size on SteamPipeResetSwitch_GetTotalSteamPipesInLevel");
static_assert(offsetof(SteamPipeResetSwitch_GetTotalSteamPipesInLevel, ReturnValue) == 0x000000, "Member 'SteamPipeResetSwitch_GetTotalSteamPipesInLevel::ReturnValue' has a wrong offset!");

// Function DBDGameplay.StruggleComponent.OnSkillCheckEnd
// 0x0010 (0x0010 - 0x0000)
struct StruggleComponent_OnSkillCheckEnd final
{
public:
	bool                                          HadInput;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Success;                                           // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Bonus;                                             // 0x0002(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESkillCheckCustomType                         Type;                                              // 0x0003(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ADBDPlayer*                             Player;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(StruggleComponent_OnSkillCheckEnd) == 0x000008, "Wrong alignment on StruggleComponent_OnSkillCheckEnd");
static_assert(sizeof(StruggleComponent_OnSkillCheckEnd) == 0x000010, "Wrong size on StruggleComponent_OnSkillCheckEnd");
static_assert(offsetof(StruggleComponent_OnSkillCheckEnd, HadInput) == 0x000000, "Member 'StruggleComponent_OnSkillCheckEnd::HadInput' has a wrong offset!");
static_assert(offsetof(StruggleComponent_OnSkillCheckEnd, Success) == 0x000001, "Member 'StruggleComponent_OnSkillCheckEnd::Success' has a wrong offset!");
static_assert(offsetof(StruggleComponent_OnSkillCheckEnd, Bonus) == 0x000002, "Member 'StruggleComponent_OnSkillCheckEnd::Bonus' has a wrong offset!");
static_assert(offsetof(StruggleComponent_OnSkillCheckEnd, Type) == 0x000003, "Member 'StruggleComponent_OnSkillCheckEnd::Type' has a wrong offset!");
static_assert(offsetof(StruggleComponent_OnSkillCheckEnd, Player) == 0x000008, "Member 'StruggleComponent_OnSkillCheckEnd::Player' has a wrong offset!");

// Function DBDGameplay.TerrorRadiusEmitterFunctionLibrary.GetActiveFakeTerrorRadiusEmittersCount
// 0x0010 (0x0010 - 0x0000)
struct TerrorRadiusEmitterFunctionLibrary_GetActiveFakeTerrorRadiusEmittersCount final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(TerrorRadiusEmitterFunctionLibrary_GetActiveFakeTerrorRadiusEmittersCount) == 0x000008, "Wrong alignment on TerrorRadiusEmitterFunctionLibrary_GetActiveFakeTerrorRadiusEmittersCount");
static_assert(sizeof(TerrorRadiusEmitterFunctionLibrary_GetActiveFakeTerrorRadiusEmittersCount) == 0x000010, "Wrong size on TerrorRadiusEmitterFunctionLibrary_GetActiveFakeTerrorRadiusEmittersCount");
static_assert(offsetof(TerrorRadiusEmitterFunctionLibrary_GetActiveFakeTerrorRadiusEmittersCount, WorldContextObject) == 0x000000, "Member 'TerrorRadiusEmitterFunctionLibrary_GetActiveFakeTerrorRadiusEmittersCount::WorldContextObject' has a wrong offset!");
static_assert(offsetof(TerrorRadiusEmitterFunctionLibrary_GetActiveFakeTerrorRadiusEmittersCount, ReturnValue) == 0x000008, "Member 'TerrorRadiusEmitterFunctionLibrary_GetActiveFakeTerrorRadiusEmittersCount::ReturnValue' has a wrong offset!");

// Function DBDGameplay.TerrorRadiusReceiverComponent.IsInTerrorRadius
// 0x0001 (0x0001 - 0x0000)
struct TerrorRadiusReceiverComponent_IsInTerrorRadius final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TerrorRadiusReceiverComponent_IsInTerrorRadius) == 0x000001, "Wrong alignment on TerrorRadiusReceiverComponent_IsInTerrorRadius");
static_assert(sizeof(TerrorRadiusReceiverComponent_IsInTerrorRadius) == 0x000001, "Wrong size on TerrorRadiusReceiverComponent_IsInTerrorRadius");
static_assert(offsetof(TerrorRadiusReceiverComponent_IsInTerrorRadius, ReturnValue) == 0x000000, "Member 'TerrorRadiusReceiverComponent_IsInTerrorRadius::ReturnValue' has a wrong offset!");

// Function DBDGameplay.TerrorRadiusReceiverComponent.IsInTerrorRadiusRange
// 0x0001 (0x0001 - 0x0000)
struct TerrorRadiusReceiverComponent_IsInTerrorRadiusRange final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TerrorRadiusReceiverComponent_IsInTerrorRadiusRange) == 0x000001, "Wrong alignment on TerrorRadiusReceiverComponent_IsInTerrorRadiusRange");
static_assert(sizeof(TerrorRadiusReceiverComponent_IsInTerrorRadiusRange) == 0x000001, "Wrong size on TerrorRadiusReceiverComponent_IsInTerrorRadiusRange");
static_assert(offsetof(TerrorRadiusReceiverComponent_IsInTerrorRadiusRange, ReturnValue) == 0x000000, "Member 'TerrorRadiusReceiverComponent_IsInTerrorRadiusRange::ReturnValue' has a wrong offset!");

// Function DBDGameplay.WiggleComponent.Authority_AddWiggleCharge
// 0x0004 (0x0004 - 0x0000)
struct WiggleComponent_Authority_AddWiggleCharge final
{
public:
	float                                         ChargeAmount;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WiggleComponent_Authority_AddWiggleCharge) == 0x000004, "Wrong alignment on WiggleComponent_Authority_AddWiggleCharge");
static_assert(sizeof(WiggleComponent_Authority_AddWiggleCharge) == 0x000004, "Wrong size on WiggleComponent_Authority_AddWiggleCharge");
static_assert(offsetof(WiggleComponent_Authority_AddWiggleCharge, ChargeAmount) == 0x000000, "Member 'WiggleComponent_Authority_AddWiggleCharge::ChargeAmount' has a wrong offset!");

// Function DBDGameplay.WiggleComponent.OnHideWiggleSkillCheck
// 0x0001 (0x0001 - 0x0000)
struct WiggleComponent_OnHideWiggleSkillCheck final
{
public:
	ESkillCheckCustomType                         Type;                                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WiggleComponent_OnHideWiggleSkillCheck) == 0x000001, "Wrong alignment on WiggleComponent_OnHideWiggleSkillCheck");
static_assert(sizeof(WiggleComponent_OnHideWiggleSkillCheck) == 0x000001, "Wrong size on WiggleComponent_OnHideWiggleSkillCheck");
static_assert(offsetof(WiggleComponent_OnHideWiggleSkillCheck, Type) == 0x000000, "Member 'WiggleComponent_OnHideWiggleSkillCheck::Type' has a wrong offset!");

// Function DBDGameplay.WiggleComponent.OnPickedUpSkillCheckEnd
// 0x0010 (0x0010 - 0x0000)
struct WiggleComponent_OnPickedUpSkillCheckEnd final
{
public:
	bool                                          HadInput;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Success;                                           // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Bonus;                                             // 0x0002(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESkillCheckCustomType                         Type;                                              // 0x0003(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ADBDPlayer*                             Player;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WiggleComponent_OnPickedUpSkillCheckEnd) == 0x000008, "Wrong alignment on WiggleComponent_OnPickedUpSkillCheckEnd");
static_assert(sizeof(WiggleComponent_OnPickedUpSkillCheckEnd) == 0x000010, "Wrong size on WiggleComponent_OnPickedUpSkillCheckEnd");
static_assert(offsetof(WiggleComponent_OnPickedUpSkillCheckEnd, HadInput) == 0x000000, "Member 'WiggleComponent_OnPickedUpSkillCheckEnd::HadInput' has a wrong offset!");
static_assert(offsetof(WiggleComponent_OnPickedUpSkillCheckEnd, Success) == 0x000001, "Member 'WiggleComponent_OnPickedUpSkillCheckEnd::Success' has a wrong offset!");
static_assert(offsetof(WiggleComponent_OnPickedUpSkillCheckEnd, Bonus) == 0x000002, "Member 'WiggleComponent_OnPickedUpSkillCheckEnd::Bonus' has a wrong offset!");
static_assert(offsetof(WiggleComponent_OnPickedUpSkillCheckEnd, Type) == 0x000003, "Member 'WiggleComponent_OnPickedUpSkillCheckEnd::Type' has a wrong offset!");
static_assert(offsetof(WiggleComponent_OnPickedUpSkillCheckEnd, Player) == 0x000008, "Member 'WiggleComponent_OnPickedUpSkillCheckEnd::Player' has a wrong offset!");

// Function DBDGameplay.WiggleComponent.OnPlayerPickedUpEnd
// 0x0008 (0x0008 - 0x0000)
struct WiggleComponent_OnPlayerPickedUpEnd final
{
public:
	class ADBDPlayer*                             Picker;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WiggleComponent_OnPlayerPickedUpEnd) == 0x000008, "Wrong alignment on WiggleComponent_OnPlayerPickedUpEnd");
static_assert(sizeof(WiggleComponent_OnPlayerPickedUpEnd) == 0x000008, "Wrong size on WiggleComponent_OnPlayerPickedUpEnd");
static_assert(offsetof(WiggleComponent_OnPlayerPickedUpEnd, Picker) == 0x000000, "Member 'WiggleComponent_OnPlayerPickedUpEnd::Picker' has a wrong offset!");

// Function DBDGameplay.WiggleComponent.OnPlayerPickedUpStart
// 0x0008 (0x0008 - 0x0000)
struct WiggleComponent_OnPlayerPickedUpStart final
{
public:
	class ADBDPlayer*                             Picker;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WiggleComponent_OnPlayerPickedUpStart) == 0x000008, "Wrong alignment on WiggleComponent_OnPlayerPickedUpStart");
static_assert(sizeof(WiggleComponent_OnPlayerPickedUpStart) == 0x000008, "Wrong size on WiggleComponent_OnPlayerPickedUpStart");
static_assert(offsetof(WiggleComponent_OnPlayerPickedUpStart, Picker) == 0x000000, "Member 'WiggleComponent_OnPlayerPickedUpStart::Picker' has a wrong offset!");

// Function DBDGameplay.WiggleComponent.OnWiggleSkillCheckEnd
// 0x0010 (0x0010 - 0x0000)
struct WiggleComponent_OnWiggleSkillCheckEnd final
{
public:
	bool                                          HadInput;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Success;                                           // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Bonus;                                             // 0x0002(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESkillCheckCustomType                         Type;                                              // 0x0003(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ADBDPlayer*                             Player;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WiggleComponent_OnWiggleSkillCheckEnd) == 0x000008, "Wrong alignment on WiggleComponent_OnWiggleSkillCheckEnd");
static_assert(sizeof(WiggleComponent_OnWiggleSkillCheckEnd) == 0x000010, "Wrong size on WiggleComponent_OnWiggleSkillCheckEnd");
static_assert(offsetof(WiggleComponent_OnWiggleSkillCheckEnd, HadInput) == 0x000000, "Member 'WiggleComponent_OnWiggleSkillCheckEnd::HadInput' has a wrong offset!");
static_assert(offsetof(WiggleComponent_OnWiggleSkillCheckEnd, Success) == 0x000001, "Member 'WiggleComponent_OnWiggleSkillCheckEnd::Success' has a wrong offset!");
static_assert(offsetof(WiggleComponent_OnWiggleSkillCheckEnd, Bonus) == 0x000002, "Member 'WiggleComponent_OnWiggleSkillCheckEnd::Bonus' has a wrong offset!");
static_assert(offsetof(WiggleComponent_OnWiggleSkillCheckEnd, Type) == 0x000003, "Member 'WiggleComponent_OnWiggleSkillCheckEnd::Type' has a wrong offset!");
static_assert(offsetof(WiggleComponent_OnWiggleSkillCheckEnd, Player) == 0x000008, "Member 'WiggleComponent_OnWiggleSkillCheckEnd::Player' has a wrong offset!");

// Function DBDGameplay.WiggleComponent.DBD_SetWiggleProgress
// 0x0004 (0x0004 - 0x0000)
struct WiggleComponent_DBD_SetWiggleProgress final
{
public:
	float                                         ProgressPercent;                                   // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WiggleComponent_DBD_SetWiggleProgress) == 0x000004, "Wrong alignment on WiggleComponent_DBD_SetWiggleProgress");
static_assert(sizeof(WiggleComponent_DBD_SetWiggleProgress) == 0x000004, "Wrong size on WiggleComponent_DBD_SetWiggleProgress");
static_assert(offsetof(WiggleComponent_DBD_SetWiggleProgress, ProgressPercent) == 0x000000, "Member 'WiggleComponent_DBD_SetWiggleProgress::ProgressPercent' has a wrong offset!");

// Function DBDGameplay.WiggleComponent.GetWiggleChargeable
// 0x0008 (0x0008 - 0x0000)
struct WiggleComponent_GetWiggleChargeable final
{
public:
	class UChargeableComponent*                   ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WiggleComponent_GetWiggleChargeable) == 0x000008, "Wrong alignment on WiggleComponent_GetWiggleChargeable");
static_assert(sizeof(WiggleComponent_GetWiggleChargeable) == 0x000008, "Wrong size on WiggleComponent_GetWiggleChargeable");
static_assert(offsetof(WiggleComponent_GetWiggleChargeable, ReturnValue) == 0x000000, "Member 'WiggleComponent_GetWiggleChargeable::ReturnValue' has a wrong offset!");

// Function DBDGameplay.WiggleFreeComponent.Authority_OnChargeableCompleteEvent
// 0x0018 (0x0018 - 0x0000)
struct WiggleFreeComponent_Authority_OnChargeableCompleteEvent final
{
public:
	bool                                          COMPLETED;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         InstigatorsForCompletion;                          // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(WiggleFreeComponent_Authority_OnChargeableCompleteEvent) == 0x000008, "Wrong alignment on WiggleFreeComponent_Authority_OnChargeableCompleteEvent");
static_assert(sizeof(WiggleFreeComponent_Authority_OnChargeableCompleteEvent) == 0x000018, "Wrong size on WiggleFreeComponent_Authority_OnChargeableCompleteEvent");
static_assert(offsetof(WiggleFreeComponent_Authority_OnChargeableCompleteEvent, COMPLETED) == 0x000000, "Member 'WiggleFreeComponent_Authority_OnChargeableCompleteEvent::COMPLETED' has a wrong offset!");
static_assert(offsetof(WiggleFreeComponent_Authority_OnChargeableCompleteEvent, InstigatorsForCompletion) == 0x000008, "Member 'WiggleFreeComponent_Authority_OnChargeableCompleteEvent::InstigatorsForCompletion' has a wrong offset!");

// Function DBDGameplay.WiggleFreeComponent.Authority_OnChargeApplied
// 0x0018 (0x0018 - 0x0000)
struct WiggleFreeComponent_Authority_OnChargeApplied final
{
public:
	float                                         IndividualChargeAmount;                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TotalChargeAmount;                                 // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 ChargeInstigator;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          WasCoop;                                           // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DeltaTime;                                         // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WiggleFreeComponent_Authority_OnChargeApplied) == 0x000008, "Wrong alignment on WiggleFreeComponent_Authority_OnChargeApplied");
static_assert(sizeof(WiggleFreeComponent_Authority_OnChargeApplied) == 0x000018, "Wrong size on WiggleFreeComponent_Authority_OnChargeApplied");
static_assert(offsetof(WiggleFreeComponent_Authority_OnChargeApplied, IndividualChargeAmount) == 0x000000, "Member 'WiggleFreeComponent_Authority_OnChargeApplied::IndividualChargeAmount' has a wrong offset!");
static_assert(offsetof(WiggleFreeComponent_Authority_OnChargeApplied, TotalChargeAmount) == 0x000004, "Member 'WiggleFreeComponent_Authority_OnChargeApplied::TotalChargeAmount' has a wrong offset!");
static_assert(offsetof(WiggleFreeComponent_Authority_OnChargeApplied, ChargeInstigator) == 0x000008, "Member 'WiggleFreeComponent_Authority_OnChargeApplied::ChargeInstigator' has a wrong offset!");
static_assert(offsetof(WiggleFreeComponent_Authority_OnChargeApplied, WasCoop) == 0x000010, "Member 'WiggleFreeComponent_Authority_OnChargeApplied::WasCoop' has a wrong offset!");
static_assert(offsetof(WiggleFreeComponent_Authority_OnChargeApplied, DeltaTime) == 0x000014, "Member 'WiggleFreeComponent_Authority_OnChargeApplied::DeltaTime' has a wrong offset!");

// Function DBDGameplay.WiggleFreeComponent.Authority_OnPlayerPickedUpEnd
// 0x0008 (0x0008 - 0x0000)
struct WiggleFreeComponent_Authority_OnPlayerPickedUpEnd final
{
public:
	class ADBDPlayer*                             Picker;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WiggleFreeComponent_Authority_OnPlayerPickedUpEnd) == 0x000008, "Wrong alignment on WiggleFreeComponent_Authority_OnPlayerPickedUpEnd");
static_assert(sizeof(WiggleFreeComponent_Authority_OnPlayerPickedUpEnd) == 0x000008, "Wrong size on WiggleFreeComponent_Authority_OnPlayerPickedUpEnd");
static_assert(offsetof(WiggleFreeComponent_Authority_OnPlayerPickedUpEnd, Picker) == 0x000000, "Member 'WiggleFreeComponent_Authority_OnPlayerPickedUpEnd::Picker' has a wrong offset!");

// Function DBDGameplay.WiggleMotionComponent.OnHideWiggleSkillCheck
// 0x0001 (0x0001 - 0x0000)
struct WiggleMotionComponent_OnHideWiggleSkillCheck final
{
public:
	ESkillCheckCustomType                         Type;                                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WiggleMotionComponent_OnHideWiggleSkillCheck) == 0x000001, "Wrong alignment on WiggleMotionComponent_OnHideWiggleSkillCheck");
static_assert(sizeof(WiggleMotionComponent_OnHideWiggleSkillCheck) == 0x000001, "Wrong size on WiggleMotionComponent_OnHideWiggleSkillCheck");
static_assert(offsetof(WiggleMotionComponent_OnHideWiggleSkillCheck, Type) == 0x000000, "Member 'WiggleMotionComponent_OnHideWiggleSkillCheck::Type' has a wrong offset!");

// Function DBDGameplay.WiggleMotionComponent.OnSurvivorPickedUp
// 0x0008 (0x0008 - 0x0000)
struct WiggleMotionComponent_OnSurvivorPickedUp final
{
public:
	class ADBDPlayer*                             Target;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WiggleMotionComponent_OnSurvivorPickedUp) == 0x000008, "Wrong alignment on WiggleMotionComponent_OnSurvivorPickedUp");
static_assert(sizeof(WiggleMotionComponent_OnSurvivorPickedUp) == 0x000008, "Wrong size on WiggleMotionComponent_OnSurvivorPickedUp");
static_assert(offsetof(WiggleMotionComponent_OnSurvivorPickedUp, Target) == 0x000000, "Member 'WiggleMotionComponent_OnSurvivorPickedUp::Target' has a wrong offset!");

// Function DBDGameplay.WiggleMotionComponent.OnSurvivorRemoved
// 0x0008 (0x0008 - 0x0000)
struct WiggleMotionComponent_OnSurvivorRemoved final
{
public:
	class ADBDPlayer*                             Target;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WiggleMotionComponent_OnSurvivorRemoved) == 0x000008, "Wrong alignment on WiggleMotionComponent_OnSurvivorRemoved");
static_assert(sizeof(WiggleMotionComponent_OnSurvivorRemoved) == 0x000008, "Wrong size on WiggleMotionComponent_OnSurvivorRemoved");
static_assert(offsetof(WiggleMotionComponent_OnSurvivorRemoved, Target) == 0x000000, "Member 'WiggleMotionComponent_OnSurvivorRemoved::Target' has a wrong offset!");

// Function DBDGameplay.WiggleMotionComponent.OnWiggleSkillCheckEnd
// 0x0010 (0x0010 - 0x0000)
struct WiggleMotionComponent_OnWiggleSkillCheckEnd final
{
public:
	bool                                          HadInput;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Success;                                           // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Bonus;                                             // 0x0002(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESkillCheckCustomType                         Type;                                              // 0x0003(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ADBDPlayer*                             Player;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WiggleMotionComponent_OnWiggleSkillCheckEnd) == 0x000008, "Wrong alignment on WiggleMotionComponent_OnWiggleSkillCheckEnd");
static_assert(sizeof(WiggleMotionComponent_OnWiggleSkillCheckEnd) == 0x000010, "Wrong size on WiggleMotionComponent_OnWiggleSkillCheckEnd");
static_assert(offsetof(WiggleMotionComponent_OnWiggleSkillCheckEnd, HadInput) == 0x000000, "Member 'WiggleMotionComponent_OnWiggleSkillCheckEnd::HadInput' has a wrong offset!");
static_assert(offsetof(WiggleMotionComponent_OnWiggleSkillCheckEnd, Success) == 0x000001, "Member 'WiggleMotionComponent_OnWiggleSkillCheckEnd::Success' has a wrong offset!");
static_assert(offsetof(WiggleMotionComponent_OnWiggleSkillCheckEnd, Bonus) == 0x000002, "Member 'WiggleMotionComponent_OnWiggleSkillCheckEnd::Bonus' has a wrong offset!");
static_assert(offsetof(WiggleMotionComponent_OnWiggleSkillCheckEnd, Type) == 0x000003, "Member 'WiggleMotionComponent_OnWiggleSkillCheckEnd::Type' has a wrong offset!");
static_assert(offsetof(WiggleMotionComponent_OnWiggleSkillCheckEnd, Player) == 0x000008, "Member 'WiggleMotionComponent_OnWiggleSkillCheckEnd::Player' has a wrong offset!");

// Function DBDGameplay.WiggleMotionComponent.Server_SetIsBeingWiggled
// 0x0001 (0x0001 - 0x0000)
struct WiggleMotionComponent_Server_SetIsBeingWiggled final
{
public:
	bool                                          IsBeingWiggled;                                    // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WiggleMotionComponent_Server_SetIsBeingWiggled) == 0x000001, "Wrong alignment on WiggleMotionComponent_Server_SetIsBeingWiggled");
static_assert(sizeof(WiggleMotionComponent_Server_SetIsBeingWiggled) == 0x000001, "Wrong size on WiggleMotionComponent_Server_SetIsBeingWiggled");
static_assert(offsetof(WiggleMotionComponent_Server_SetIsBeingWiggled, IsBeingWiggled) == 0x000000, "Member 'WiggleMotionComponent_Server_SetIsBeingWiggled::IsBeingWiggled' has a wrong offset!");

// Function DBDGameplay.WiggleMotionComponent.SetIsBeingWiggled
// 0x0001 (0x0001 - 0x0000)
struct WiggleMotionComponent_SetIsBeingWiggled final
{
public:
	bool                                          IsBeingWiggled;                                    // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WiggleMotionComponent_SetIsBeingWiggled) == 0x000001, "Wrong alignment on WiggleMotionComponent_SetIsBeingWiggled");
static_assert(sizeof(WiggleMotionComponent_SetIsBeingWiggled) == 0x000001, "Wrong size on WiggleMotionComponent_SetIsBeingWiggled");
static_assert(offsetof(WiggleMotionComponent_SetIsBeingWiggled, IsBeingWiggled) == 0x000000, "Member 'WiggleMotionComponent_SetIsBeingWiggled::IsBeingWiggled' has a wrong offset!");

}

