#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: GFXUtilities

#include "Basic.hpp"

#include "GFXUtilities_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "Niagara_classes.hpp"


namespace SDK
{

// Class GFXUtilities.ClonedSplineMeshComponent
// 0x0000 (0x0780 - 0x0780)
class UClonedSplineMeshComponent final : public USplineMeshComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClonedSplineMeshComponent">();
	}
	static class UClonedSplineMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UClonedSplineMeshComponent>();
	}
};
static_assert(alignof(UClonedSplineMeshComponent) == 0x000010, "Wrong alignment on UClonedSplineMeshComponent");
static_assert(sizeof(UClonedSplineMeshComponent) == 0x000780, "Wrong size on UClonedSplineMeshComponent");

// Class GFXUtilities.BatchMeshCommands
// 0x0090 (0x0350 - 0x02C0)
class UBatchMeshCommands : public USceneComponent
{
public:
	uint8                                         Pad_2C0[0x60];                                     // 0x02C0(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMaterialNamedGroup>            Groups;                                            // 0x0320(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FMaterialHelperOriginalMeshState> TargetMeshes;                                      // 0x0330(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class FString                                 _materialGroupName;                                // 0x0340(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void AddGroup(const struct FMaterialNamedGroup& Group);
	void BatchSetComponentTickEnabled(bool Enabled);
	void BatchSetSkipComponentAndChildrenTransformUpdate(bool Skip);
	void BatchSetVisibility(bool bNewVisibility, bool bPropagateToChildren);
	bool CopyFirstScalarParameter(const class FName ParameterName, float* OutValue);
	void ResetMaterials();
	void SetAllToSameMaterial(class UMaterialInterface* MaterialInterface);
	void SetCastCinematicShadows(bool CastCinematicShadows);
	void SetColourParameter(const class FName ParameterName, const struct FLinearColor& NewValue);
	void SetCustomDepthStencilValue(int32 StencilValue);
	void SetLightingChannelForAllMeshes(const struct FLightingChannels& LightingChannels);
	void SetMaterial(const class FString& GroupName);
	void SetReceivesDecals(bool ReceivesDecals);
	void SetRenderInCustomColourNoDepth(bool RenderInCustomColour);
	void SetRenderInCustomDepth(bool RenderInCustomDepth);
	void SetRenderInMainPass(bool InRenderInMainPass);
	void SetScalarParameter(const class FName ParameterName, const float NewValue);
	void SetStencilIntegerScalarParameter(const class FName ParameterName, const int32& NewValue);
	void SetTextureParameter(const class FName ParameterName, class UTexture* NewTexture);
	void SetVectorParameter(const class FName ParameterName, const struct FVector& NewValue);
	void UpdateMaterials();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BatchMeshCommands">();
	}
	static class UBatchMeshCommands* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBatchMeshCommands>();
	}
};
static_assert(alignof(UBatchMeshCommands) == 0x000010, "Wrong alignment on UBatchMeshCommands");
static_assert(sizeof(UBatchMeshCommands) == 0x000350, "Wrong size on UBatchMeshCommands");
static_assert(offsetof(UBatchMeshCommands, Groups) == 0x000320, "Member 'UBatchMeshCommands::Groups' has a wrong offset!");
static_assert(offsetof(UBatchMeshCommands, TargetMeshes) == 0x000330, "Member 'UBatchMeshCommands::TargetMeshes' has a wrong offset!");
static_assert(offsetof(UBatchMeshCommands, _materialGroupName) == 0x000340, "Member 'UBatchMeshCommands::_materialGroupName' has a wrong offset!");

// Class GFXUtilities.AlternatingColor
// 0x0048 (0x0078 - 0x0030)
class UAlternatingColor final : public UObject
{
public:
	struct FLinearColor                           FirstColor;                                        // 0x0030(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           SecondColor;                                       // 0x0040(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ColorChangePeriod;                                 // 0x0050(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_54[0x24];                                      // 0x0054(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AlternatingColor">();
	}
	static class UAlternatingColor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAlternatingColor>();
	}
};
static_assert(alignof(UAlternatingColor) == 0x000008, "Wrong alignment on UAlternatingColor");
static_assert(sizeof(UAlternatingColor) == 0x000078, "Wrong size on UAlternatingColor");
static_assert(offsetof(UAlternatingColor, FirstColor) == 0x000030, "Member 'UAlternatingColor::FirstColor' has a wrong offset!");
static_assert(offsetof(UAlternatingColor, SecondColor) == 0x000040, "Member 'UAlternatingColor::SecondColor' has a wrong offset!");
static_assert(offsetof(UAlternatingColor, ColorChangePeriod) == 0x000050, "Member 'UAlternatingColor::ColorChangePeriod' has a wrong offset!");

// Class GFXUtilities.BaseOutlineRenderStrategy
// 0x0048 (0x0078 - 0x0030)
class UBaseOutlineRenderStrategy : public UObject
{
public:
	TArray<class UBatchMeshCommands*>             _batchCommands;                                    // 0x0030(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_40[0x38];                                      // 0x0040(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseOutlineRenderStrategy">();
	}
	static class UBaseOutlineRenderStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseOutlineRenderStrategy>();
	}
};
static_assert(alignof(UBaseOutlineRenderStrategy) == 0x000008, "Wrong alignment on UBaseOutlineRenderStrategy");
static_assert(sizeof(UBaseOutlineRenderStrategy) == 0x000078, "Wrong size on UBaseOutlineRenderStrategy");
static_assert(offsetof(UBaseOutlineRenderStrategy, _batchCommands) == 0x000030, "Member 'UBaseOutlineRenderStrategy::_batchCommands' has a wrong offset!");

// Class GFXUtilities.ClippableProviderComponent
// 0x0068 (0x0110 - 0x00A8)
class UClippableProviderComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x18];                                      // 0x00A8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class UPrimitiveComponent*>              _ignoredPrimitives;                                // 0x00C0(0x0050)(ExportObject, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	void AddIgnoredPrimitives(const TArray<class UPrimitiveComponent*>& IgnoredPrimitives);
	void SetIgnoredPrimitives(const TArray<class UPrimitiveComponent*>& IgnoredPrimitives);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClippableProviderComponent">();
	}
	static class UClippableProviderComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UClippableProviderComponent>();
	}
};
static_assert(alignof(UClippableProviderComponent) == 0x000008, "Wrong alignment on UClippableProviderComponent");
static_assert(sizeof(UClippableProviderComponent) == 0x000110, "Wrong size on UClippableProviderComponent");
static_assert(offsetof(UClippableProviderComponent, _ignoredPrimitives) == 0x0000C0, "Member 'UClippableProviderComponent::_ignoredPrimitives' has a wrong offset!");

// Class GFXUtilities.ClonedMeshComponent
// 0x00A0 (0x03F0 - 0x0350)
class UClonedMeshComponent : public UBatchMeshCommands
{
public:
	TMap<class USceneComponent*, class UMeshComponent*> _originalToClone;                                  // 0x0350(0x0050)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TMap<class UMeshComponent*, class USceneComponent*> _cloneToOriginal;                                  // 0x03A0(0x0050)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClonedMeshComponent">();
	}
	static class UClonedMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UClonedMeshComponent>();
	}
};
static_assert(alignof(UClonedMeshComponent) == 0x000010, "Wrong alignment on UClonedMeshComponent");
static_assert(sizeof(UClonedMeshComponent) == 0x0003F0, "Wrong size on UClonedMeshComponent");
static_assert(offsetof(UClonedMeshComponent, _originalToClone) == 0x000350, "Member 'UClonedMeshComponent::_originalToClone' has a wrong offset!");
static_assert(offsetof(UClonedMeshComponent, _cloneToOriginal) == 0x0003A0, "Member 'UClonedMeshComponent::_cloneToOriginal' has a wrong offset!");

// Class GFXUtilities.ClonedMeshComponentTranslucentOutline
// 0x0000 (0x03F0 - 0x03F0)
class UClonedMeshComponentTranslucentOutline final : public UClonedMeshComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClonedMeshComponentTranslucentOutline">();
	}
	static class UClonedMeshComponentTranslucentOutline* GetDefaultObj()
	{
		return GetDefaultObjImpl<UClonedMeshComponentTranslucentOutline>();
	}
};
static_assert(alignof(UClonedMeshComponentTranslucentOutline) == 0x000010, "Wrong alignment on UClonedMeshComponentTranslucentOutline");
static_assert(sizeof(UClonedMeshComponentTranslucentOutline) == 0x0003F0, "Wrong size on UClonedMeshComponentTranslucentOutline");

// Class GFXUtilities.ClonedStaticMeshComponent
// 0x0000 (0x0680 - 0x0680)
class UClonedStaticMeshComponent final : public UStaticMeshComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClonedStaticMeshComponent">();
	}
	static class UClonedStaticMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UClonedStaticMeshComponent>();
	}
};
static_assert(alignof(UClonedStaticMeshComponent) == 0x000010, "Wrong alignment on UClonedStaticMeshComponent");
static_assert(sizeof(UClonedStaticMeshComponent) == 0x000680, "Wrong size on UClonedStaticMeshComponent");

// Class GFXUtilities.ClonedSkeletalMeshComponent
// 0x0000 (0x10A0 - 0x10A0)
class UClonedSkeletalMeshComponent final : public USkeletalMeshComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClonedSkeletalMeshComponent">();
	}
	static class UClonedSkeletalMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UClonedSkeletalMeshComponent>();
	}
};
static_assert(alignof(UClonedSkeletalMeshComponent) == 0x000010, "Wrong alignment on UClonedSkeletalMeshComponent");
static_assert(sizeof(UClonedSkeletalMeshComponent) == 0x0010A0, "Wrong size on UClonedSkeletalMeshComponent");

// Class GFXUtilities.CustomDepthOutlineRenderStrategy
// 0x0018 (0x0090 - 0x0078)
class UCustomDepthOutlineRenderStrategy final : public UBaseOutlineRenderStrategy
{
public:
	class UMaterialInterface*                     _replacementMaterial;                              // 0x0078(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UBatchMeshCommands*>             _translucentCopies;                                // 0x0080(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomDepthOutlineRenderStrategy">();
	}
	static class UCustomDepthOutlineRenderStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomDepthOutlineRenderStrategy>();
	}
};
static_assert(alignof(UCustomDepthOutlineRenderStrategy) == 0x000008, "Wrong alignment on UCustomDepthOutlineRenderStrategy");
static_assert(sizeof(UCustomDepthOutlineRenderStrategy) == 0x000090, "Wrong size on UCustomDepthOutlineRenderStrategy");
static_assert(offsetof(UCustomDepthOutlineRenderStrategy, _replacementMaterial) == 0x000078, "Member 'UCustomDepthOutlineRenderStrategy::_replacementMaterial' has a wrong offset!");
static_assert(offsetof(UCustomDepthOutlineRenderStrategy, _translucentCopies) == 0x000080, "Member 'UCustomDepthOutlineRenderStrategy::_translucentCopies' has a wrong offset!");

// Class GFXUtilities.DBDReflectionCaptureSpawnerComponent
// 0x0070 (0x0330 - 0x02C0)
class UDBDReflectionCaptureSpawnerComponent : public USceneComponent
{
public:
	EReflectionSourceType                         ReflectionSourceType;                              // 0x02C0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C1[0x7];                                      // 0x02C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextureCube*                           Cubemap;                                           // 0x02C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SourceCubemapAngle;                                // 0x02D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Brightness;                                        // 0x02D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ContributionFactor;                                // 0x02D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IBLMultiplicator;                                  // 0x02DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanBeTinted;                                      // 0x02E0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E1[0x7];                                      // 0x02E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                CaptureOffset;                                     // 0x02E8(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_300[0x8];                                      // 0x0300(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AReflectionCapture*>             SpawnedReflectionCaptures;                         // 0x0308(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class UReflectionCaptureComponent*>    SpawnedReflectionCaptureComponents;                // 0x0318(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_328[0x8];                                      // 0x0328(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetBrightness(float Param_Brightness);
	void SetContributionFactor(float Param_ContributionFactor);
	void SetIBLMultiplicator(float Param_IBLMultiplicator);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDReflectionCaptureSpawnerComponent">();
	}
	static class UDBDReflectionCaptureSpawnerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDReflectionCaptureSpawnerComponent>();
	}
};
static_assert(alignof(UDBDReflectionCaptureSpawnerComponent) == 0x000010, "Wrong alignment on UDBDReflectionCaptureSpawnerComponent");
static_assert(sizeof(UDBDReflectionCaptureSpawnerComponent) == 0x000330, "Wrong size on UDBDReflectionCaptureSpawnerComponent");
static_assert(offsetof(UDBDReflectionCaptureSpawnerComponent, ReflectionSourceType) == 0x0002C0, "Member 'UDBDReflectionCaptureSpawnerComponent::ReflectionSourceType' has a wrong offset!");
static_assert(offsetof(UDBDReflectionCaptureSpawnerComponent, Cubemap) == 0x0002C8, "Member 'UDBDReflectionCaptureSpawnerComponent::Cubemap' has a wrong offset!");
static_assert(offsetof(UDBDReflectionCaptureSpawnerComponent, SourceCubemapAngle) == 0x0002D0, "Member 'UDBDReflectionCaptureSpawnerComponent::SourceCubemapAngle' has a wrong offset!");
static_assert(offsetof(UDBDReflectionCaptureSpawnerComponent, Brightness) == 0x0002D4, "Member 'UDBDReflectionCaptureSpawnerComponent::Brightness' has a wrong offset!");
static_assert(offsetof(UDBDReflectionCaptureSpawnerComponent, ContributionFactor) == 0x0002D8, "Member 'UDBDReflectionCaptureSpawnerComponent::ContributionFactor' has a wrong offset!");
static_assert(offsetof(UDBDReflectionCaptureSpawnerComponent, IBLMultiplicator) == 0x0002DC, "Member 'UDBDReflectionCaptureSpawnerComponent::IBLMultiplicator' has a wrong offset!");
static_assert(offsetof(UDBDReflectionCaptureSpawnerComponent, bCanBeTinted) == 0x0002E0, "Member 'UDBDReflectionCaptureSpawnerComponent::bCanBeTinted' has a wrong offset!");
static_assert(offsetof(UDBDReflectionCaptureSpawnerComponent, CaptureOffset) == 0x0002E8, "Member 'UDBDReflectionCaptureSpawnerComponent::CaptureOffset' has a wrong offset!");
static_assert(offsetof(UDBDReflectionCaptureSpawnerComponent, SpawnedReflectionCaptures) == 0x000308, "Member 'UDBDReflectionCaptureSpawnerComponent::SpawnedReflectionCaptures' has a wrong offset!");
static_assert(offsetof(UDBDReflectionCaptureSpawnerComponent, SpawnedReflectionCaptureComponents) == 0x000318, "Member 'UDBDReflectionCaptureSpawnerComponent::SpawnedReflectionCaptureComponents' has a wrong offset!");

// Class GFXUtilities.DBDBoxReflectionCaptureSpawnerComponent
// 0x0030 (0x0360 - 0x0330)
class UDBDBoxReflectionCaptureSpawnerComponent final : public UDBDReflectionCaptureSpawnerComponent
{
public:
	struct FVector                                InfluenceBox;                                      // 0x0330(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BoxTransitionDistance;                             // 0x0348(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34C[0x4];                                      // 0x034C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBoxComponent*                          PreviewInfluenceBox;                               // 0x0350(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBoxComponent*                          PreviewCaptureBox;                                 // 0x0358(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDBoxReflectionCaptureSpawnerComponent">();
	}
	static class UDBDBoxReflectionCaptureSpawnerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDBoxReflectionCaptureSpawnerComponent>();
	}
};
static_assert(alignof(UDBDBoxReflectionCaptureSpawnerComponent) == 0x000010, "Wrong alignment on UDBDBoxReflectionCaptureSpawnerComponent");
static_assert(sizeof(UDBDBoxReflectionCaptureSpawnerComponent) == 0x000360, "Wrong size on UDBDBoxReflectionCaptureSpawnerComponent");
static_assert(offsetof(UDBDBoxReflectionCaptureSpawnerComponent, InfluenceBox) == 0x000330, "Member 'UDBDBoxReflectionCaptureSpawnerComponent::InfluenceBox' has a wrong offset!");
static_assert(offsetof(UDBDBoxReflectionCaptureSpawnerComponent, BoxTransitionDistance) == 0x000348, "Member 'UDBDBoxReflectionCaptureSpawnerComponent::BoxTransitionDistance' has a wrong offset!");
static_assert(offsetof(UDBDBoxReflectionCaptureSpawnerComponent, PreviewInfluenceBox) == 0x000350, "Member 'UDBDBoxReflectionCaptureSpawnerComponent::PreviewInfluenceBox' has a wrong offset!");
static_assert(offsetof(UDBDBoxReflectionCaptureSpawnerComponent, PreviewCaptureBox) == 0x000358, "Member 'UDBDBoxReflectionCaptureSpawnerComponent::PreviewCaptureBox' has a wrong offset!");

// Class GFXUtilities.DBDCullDistanceVolumeComponent
// 0x0040 (0x0300 - 0x02C0)
class UDBDCullDistanceVolumeComponent final : public USceneComponent
{
public:
	TArray<struct FDBDCullDistanceSizePair>       CullDistances;                                     // 0x02C0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FVector                                InfluenceBox;                                      // 0x02D0(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Enabled;                                           // 0x02E8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Unbound;                                           // 0x02E9(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2EA[0x6];                                      // 0x02EA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UBoxComponent*                          _previewInfluenceBox;                              // 0x02F0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2F8[0x8];                                      // 0x02F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDCullDistanceVolumeComponent">();
	}
	static class UDBDCullDistanceVolumeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDCullDistanceVolumeComponent>();
	}
};
static_assert(alignof(UDBDCullDistanceVolumeComponent) == 0x000010, "Wrong alignment on UDBDCullDistanceVolumeComponent");
static_assert(sizeof(UDBDCullDistanceVolumeComponent) == 0x000300, "Wrong size on UDBDCullDistanceVolumeComponent");
static_assert(offsetof(UDBDCullDistanceVolumeComponent, CullDistances) == 0x0002C0, "Member 'UDBDCullDistanceVolumeComponent::CullDistances' has a wrong offset!");
static_assert(offsetof(UDBDCullDistanceVolumeComponent, InfluenceBox) == 0x0002D0, "Member 'UDBDCullDistanceVolumeComponent::InfluenceBox' has a wrong offset!");
static_assert(offsetof(UDBDCullDistanceVolumeComponent, Enabled) == 0x0002E8, "Member 'UDBDCullDistanceVolumeComponent::Enabled' has a wrong offset!");
static_assert(offsetof(UDBDCullDistanceVolumeComponent, Unbound) == 0x0002E9, "Member 'UDBDCullDistanceVolumeComponent::Unbound' has a wrong offset!");
static_assert(offsetof(UDBDCullDistanceVolumeComponent, _previewInfluenceBox) == 0x0002F0, "Member 'UDBDCullDistanceVolumeComponent::_previewInfluenceBox' has a wrong offset!");

// Class GFXUtilities.DBDSphereReflectionCaptureSpawnerComponent
// 0x0010 (0x0340 - 0x0330)
class UDBDSphereReflectionCaptureSpawnerComponent final : public UDBDReflectionCaptureSpawnerComponent
{
public:
	float                                         InfluenceRadius;                                   // 0x0330(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_334[0x4];                                      // 0x0334(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UDrawSphereComponent*                   PreviewInfluenceRadius;                            // 0x0338(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDSphereReflectionCaptureSpawnerComponent">();
	}
	static class UDBDSphereReflectionCaptureSpawnerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDSphereReflectionCaptureSpawnerComponent>();
	}
};
static_assert(alignof(UDBDSphereReflectionCaptureSpawnerComponent) == 0x000010, "Wrong alignment on UDBDSphereReflectionCaptureSpawnerComponent");
static_assert(sizeof(UDBDSphereReflectionCaptureSpawnerComponent) == 0x000340, "Wrong size on UDBDSphereReflectionCaptureSpawnerComponent");
static_assert(offsetof(UDBDSphereReflectionCaptureSpawnerComponent, InfluenceRadius) == 0x000330, "Member 'UDBDSphereReflectionCaptureSpawnerComponent::InfluenceRadius' has a wrong offset!");
static_assert(offsetof(UDBDSphereReflectionCaptureSpawnerComponent, PreviewInfluenceRadius) == 0x000338, "Member 'UDBDSphereReflectionCaptureSpawnerComponent::PreviewInfluenceRadius' has a wrong offset!");

// Class GFXUtilities.GFXUtilities
// 0x0000 (0x0030 - 0x0030)
class UGFXUtilities final : public UBlueprintFunctionLibrary
{
public:
	static void ActivateVFX(class USkeletalMeshComponent* SkeletalMeshComponent, bool Active);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GFXUtilities">();
	}
	static class UGFXUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGFXUtilities>();
	}
};
static_assert(alignof(UGFXUtilities) == 0x000008, "Wrong alignment on UGFXUtilities");
static_assert(sizeof(UGFXUtilities) == 0x000030, "Wrong size on UGFXUtilities");

// Class GFXUtilities.InFrustumComponent
// 0x0008 (0x00B0 - 0x00A8)
class UInFrustumComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InFrustumComponent">();
	}
	static class UInFrustumComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInFrustumComponent>();
	}
};
static_assert(alignof(UInFrustumComponent) == 0x000008, "Wrong alignment on UInFrustumComponent");
static_assert(sizeof(UInFrustumComponent) == 0x0000B0, "Wrong size on UInFrustumComponent");

// Class GFXUtilities.LightIntensityTimelineComponent
// 0x0058 (0x0100 - 0x00A8)
class ULightIntensityTimelineComponent final : public UActorComponent
{
public:
	TArray<struct FLightUpdate>                   Lights;                                            // 0x00A8(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FLightMaterialUpdate>           MaterialHelpers;                                   // 0x00B8(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UCurveFloat*                            IntensityCurve;                                    // 0x00C8(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RandomizeStart;                                    // 0x00D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RandomizeLength;                                   // 0x00D1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D2[0x2];                                       // 0x00D2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinLength;                                         // 0x00D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxLength;                                         // 0x00D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NormalizeCurve;                                    // 0x00DC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          StartTicking;                                      // 0x00DD(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELightUnits                                   InputLightUnit;                                    // 0x00DE(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DF[0x1];                                       // 0x00DF(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnTimelineFinished;                                // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_F0[0x10];                                      // 0x00F0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddLight(class ULightComponent* Light, float Multiplier);
	void AddMaterialHelper(class UMaterialHelper* MatHelper, class FName PropName, float Multiplier);
	void DeactivateTick();
	void RegisterForTick();
	void Reset();
	void SetLightCurve(class UCurveFloat* Lightcurve);
	void SetLightToMaxValue();
	void SetMaxLength(float NewMaxValue);
	void SetMinLength(float NewMinValue);
	void SetRandomizeLength(bool IsRandom);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LightIntensityTimelineComponent">();
	}
	static class ULightIntensityTimelineComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULightIntensityTimelineComponent>();
	}
};
static_assert(alignof(ULightIntensityTimelineComponent) == 0x000008, "Wrong alignment on ULightIntensityTimelineComponent");
static_assert(sizeof(ULightIntensityTimelineComponent) == 0x000100, "Wrong size on ULightIntensityTimelineComponent");
static_assert(offsetof(ULightIntensityTimelineComponent, Lights) == 0x0000A8, "Member 'ULightIntensityTimelineComponent::Lights' has a wrong offset!");
static_assert(offsetof(ULightIntensityTimelineComponent, MaterialHelpers) == 0x0000B8, "Member 'ULightIntensityTimelineComponent::MaterialHelpers' has a wrong offset!");
static_assert(offsetof(ULightIntensityTimelineComponent, IntensityCurve) == 0x0000C8, "Member 'ULightIntensityTimelineComponent::IntensityCurve' has a wrong offset!");
static_assert(offsetof(ULightIntensityTimelineComponent, RandomizeStart) == 0x0000D0, "Member 'ULightIntensityTimelineComponent::RandomizeStart' has a wrong offset!");
static_assert(offsetof(ULightIntensityTimelineComponent, RandomizeLength) == 0x0000D1, "Member 'ULightIntensityTimelineComponent::RandomizeLength' has a wrong offset!");
static_assert(offsetof(ULightIntensityTimelineComponent, MinLength) == 0x0000D4, "Member 'ULightIntensityTimelineComponent::MinLength' has a wrong offset!");
static_assert(offsetof(ULightIntensityTimelineComponent, MaxLength) == 0x0000D8, "Member 'ULightIntensityTimelineComponent::MaxLength' has a wrong offset!");
static_assert(offsetof(ULightIntensityTimelineComponent, NormalizeCurve) == 0x0000DC, "Member 'ULightIntensityTimelineComponent::NormalizeCurve' has a wrong offset!");
static_assert(offsetof(ULightIntensityTimelineComponent, StartTicking) == 0x0000DD, "Member 'ULightIntensityTimelineComponent::StartTicking' has a wrong offset!");
static_assert(offsetof(ULightIntensityTimelineComponent, InputLightUnit) == 0x0000DE, "Member 'ULightIntensityTimelineComponent::InputLightUnit' has a wrong offset!");
static_assert(offsetof(ULightIntensityTimelineComponent, OnTimelineFinished) == 0x0000E0, "Member 'ULightIntensityTimelineComponent::OnTimelineFinished' has a wrong offset!");

// Class GFXUtilities.MaterialExpressionBHVRCustomColorOutput
// 0x0030 (0x00E8 - 0x00B8)
class UMaterialExpressionBHVRCustomColorOutput final : public UMaterialExpressionCustomOutput
{
public:
	struct FExpressionInput                       Input;                                             // 0x00B8(0x0030)(NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionBHVRCustomColorOutput">();
	}
	static class UMaterialExpressionBHVRCustomColorOutput* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionBHVRCustomColorOutput>();
	}
};
static_assert(alignof(UMaterialExpressionBHVRCustomColorOutput) == 0x000008, "Wrong alignment on UMaterialExpressionBHVRCustomColorOutput");
static_assert(sizeof(UMaterialExpressionBHVRCustomColorOutput) == 0x0000E8, "Wrong size on UMaterialExpressionBHVRCustomColorOutput");
static_assert(offsetof(UMaterialExpressionBHVRCustomColorOutput, Input) == 0x0000B8, "Member 'UMaterialExpressionBHVRCustomColorOutput::Input' has a wrong offset!");

// Class GFXUtilities.MaterialExpressionBHVRCustomColorSampler
// 0x0000 (0x00B8 - 0x00B8)
class UMaterialExpressionBHVRCustomColorSampler final : public UMaterialExpressionCustomOutput
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionBHVRCustomColorSampler">();
	}
	static class UMaterialExpressionBHVRCustomColorSampler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionBHVRCustomColorSampler>();
	}
};
static_assert(alignof(UMaterialExpressionBHVRCustomColorSampler) == 0x000008, "Wrong alignment on UMaterialExpressionBHVRCustomColorSampler");
static_assert(sizeof(UMaterialExpressionBHVRCustomColorSampler) == 0x0000B8, "Wrong size on UMaterialExpressionBHVRCustomColorSampler");

// Class GFXUtilities.MaterialHelper
// 0x0000 (0x0350 - 0x0350)
class UMaterialHelper final : public UBatchMeshCommands
{
public:
	static void SetSceneComponentVisibility(class USceneComponent* InSceneComponent, const bool NewVisibility, const bool PropagateToChildren);

	void RefreshMesh(class UMeshComponent* Mc);
	void RefreshMeshes();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialHelper">();
	}
	static class UMaterialHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialHelper>();
	}
};
static_assert(alignof(UMaterialHelper) == 0x000010, "Wrong alignment on UMaterialHelper");
static_assert(sizeof(UMaterialHelper) == 0x000350, "Wrong size on UMaterialHelper");

// Class GFXUtilities.MaterialHelperUnaffectedComponentInterface
// 0x0000 (0x0030 - 0x0030)
class IMaterialHelperUnaffectedComponentInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialHelperUnaffectedComponentInterface">();
	}
	static class IMaterialHelperUnaffectedComponentInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IMaterialHelperUnaffectedComponentInterface>();
	}
};
static_assert(alignof(IMaterialHelperUnaffectedComponentInterface) == 0x000008, "Wrong alignment on IMaterialHelperUnaffectedComponentInterface");
static_assert(sizeof(IMaterialHelperUnaffectedComponentInterface) == 0x000030, "Wrong size on IMaterialHelperUnaffectedComponentInterface");

// Class GFXUtilities.MaterialHelperUnaffectedStaticMeshComponent
// 0x0000 (0x0680 - 0x0680)
class UMaterialHelperUnaffectedStaticMeshComponent final : public UStaticMeshComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialHelperUnaffectedStaticMeshComponent">();
	}
	static class UMaterialHelperUnaffectedStaticMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialHelperUnaffectedStaticMeshComponent>();
	}
};
static_assert(alignof(UMaterialHelperUnaffectedStaticMeshComponent) == 0x000010, "Wrong alignment on UMaterialHelperUnaffectedStaticMeshComponent");
static_assert(sizeof(UMaterialHelperUnaffectedStaticMeshComponent) == 0x000680, "Wrong size on UMaterialHelperUnaffectedStaticMeshComponent");

// Class GFXUtilities.MaterialHelperUnaffectedNiagaraComponent
// 0x0000 (0x0840 - 0x0840)
class UMaterialHelperUnaffectedNiagaraComponent final : public UNiagaraComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialHelperUnaffectedNiagaraComponent">();
	}
	static class UMaterialHelperUnaffectedNiagaraComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialHelperUnaffectedNiagaraComponent>();
	}
};
static_assert(alignof(UMaterialHelperUnaffectedNiagaraComponent) == 0x000010, "Wrong alignment on UMaterialHelperUnaffectedNiagaraComponent");
static_assert(sizeof(UMaterialHelperUnaffectedNiagaraComponent) == 0x000840, "Wrong size on UMaterialHelperUnaffectedNiagaraComponent");

// Class GFXUtilities.AsyncAction_OverrideMaterial
// 0x0028 (0x0060 - 0x0038)
class UAsyncAction_OverrideMaterial final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             COMPLETED;                                         // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UMeshComponent*                         MeshComponent;                                     // 0x0048(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x10];                                      // 0x0050(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAsyncAction_OverrideMaterial* AsyncOverrideMaterial(class UObject* WorldContextObject, class UMeshComponent* Mesh, const struct FGameplayTag& Group, EMaterialOverridePriority Priority, bool CopyPhysicalMaterial);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AsyncAction_OverrideMaterial">();
	}
	static class UAsyncAction_OverrideMaterial* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAsyncAction_OverrideMaterial>();
	}
};
static_assert(alignof(UAsyncAction_OverrideMaterial) == 0x000008, "Wrong alignment on UAsyncAction_OverrideMaterial");
static_assert(sizeof(UAsyncAction_OverrideMaterial) == 0x000060, "Wrong size on UAsyncAction_OverrideMaterial");
static_assert(offsetof(UAsyncAction_OverrideMaterial, COMPLETED) == 0x000038, "Member 'UAsyncAction_OverrideMaterial::COMPLETED' has a wrong offset!");
static_assert(offsetof(UAsyncAction_OverrideMaterial, MeshComponent) == 0x000048, "Member 'UAsyncAction_OverrideMaterial::MeshComponent' has a wrong offset!");

// Class GFXUtilities.MaterialOverrideSubsystem
// 0x00A0 (0x00D8 - 0x0038)
class UMaterialOverrideSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class UMeshComponent*, struct FMeshRecordedMaterialOverrideData> _meshesWithActiveMaterialOverride;                 // 0x0088(0x0050)(Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	void AddNewVariantPairToLibrary(const struct FGameplayTag& VariantName, TSoftObjectPtr<class UMaterialInterface> Src, TSoftObjectPtr<class UMaterialInterface> Dst);
	void RemoveMaterialVariantOverride(class UMeshComponent* Mesh, const struct FGameplayTag& VariantName);
	void RemoveVariantsWithNameFromLibrary(const struct FGameplayTag& VariantName);
	bool SetOverrideMaterials(class UMeshComponent* Mesh, const struct FGameplayTag& VariantName, EMaterialOverridePriority Priority);
	bool SetOverrideMaterialsAdvanced(class UMeshComponent* Mesh, const struct FGameplayTag& VariantName, bool bCopyPhysicalMaterial, EMaterialOverridePriority Priority, EMaterialOverrideParameterCopyType ParameterCopyType, int32 RecursionLimit);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialOverrideSubsystem">();
	}
	static class UMaterialOverrideSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialOverrideSubsystem>();
	}
};
static_assert(alignof(UMaterialOverrideSubsystem) == 0x000008, "Wrong alignment on UMaterialOverrideSubsystem");
static_assert(sizeof(UMaterialOverrideSubsystem) == 0x0000D8, "Wrong size on UMaterialOverrideSubsystem");
static_assert(offsetof(UMaterialOverrideSubsystem, _meshesWithActiveMaterialOverride) == 0x000088, "Member 'UMaterialOverrideSubsystem::_meshesWithActiveMaterialOverride' has a wrong offset!");

// Class GFXUtilities.MeshCloningFactory
// 0x0000 (0x0350 - 0x0350)
class UMeshCloningFactory final : public UBatchMeshCommands
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MeshCloningFactory">();
	}
	static class UMeshCloningFactory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMeshCloningFactory>();
	}
};
static_assert(alignof(UMeshCloningFactory) == 0x000010, "Wrong alignment on UMeshCloningFactory");
static_assert(sizeof(UMeshCloningFactory) == 0x000350, "Wrong size on UMeshCloningFactory");

// Class GFXUtilities.OuterlineComponent
// 0x0030 (0x02F0 - 0x02C0)
class UOuterlineComponent final : public USceneComponent
{
public:
	class UMaterialInterface*                     CloneCustomDepthMaterial;                          // 0x02C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     CloneTranslucentMaterial;                          // 0x02C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               _cloneCustomDepthMaterialDynamic;                  // 0x02D0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               _cloneTranslucentMaterialDynamic;                  // 0x02D8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USkeletalMeshComponent*                 _customDepthSkeletalMesh;                          // 0x02E0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USkeletalMeshComponent*                 _overlaySkeletalMesh;                              // 0x02E8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void SetIntensity(float Intensity);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OuterlineComponent">();
	}
	static class UOuterlineComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOuterlineComponent>();
	}
};
static_assert(alignof(UOuterlineComponent) == 0x000010, "Wrong alignment on UOuterlineComponent");
static_assert(sizeof(UOuterlineComponent) == 0x0002F0, "Wrong size on UOuterlineComponent");
static_assert(offsetof(UOuterlineComponent, CloneCustomDepthMaterial) == 0x0002C0, "Member 'UOuterlineComponent::CloneCustomDepthMaterial' has a wrong offset!");
static_assert(offsetof(UOuterlineComponent, CloneTranslucentMaterial) == 0x0002C8, "Member 'UOuterlineComponent::CloneTranslucentMaterial' has a wrong offset!");
static_assert(offsetof(UOuterlineComponent, _cloneCustomDepthMaterialDynamic) == 0x0002D0, "Member 'UOuterlineComponent::_cloneCustomDepthMaterialDynamic' has a wrong offset!");
static_assert(offsetof(UOuterlineComponent, _cloneTranslucentMaterialDynamic) == 0x0002D8, "Member 'UOuterlineComponent::_cloneTranslucentMaterialDynamic' has a wrong offset!");
static_assert(offsetof(UOuterlineComponent, _customDepthSkeletalMesh) == 0x0002E0, "Member 'UOuterlineComponent::_customDepthSkeletalMesh' has a wrong offset!");
static_assert(offsetof(UOuterlineComponent, _overlaySkeletalMesh) == 0x0002E8, "Member 'UOuterlineComponent::_overlaySkeletalMesh' has a wrong offset!");

// Class GFXUtilities.StencilOutlineRenderStrategy
// 0x0028 (0x00A0 - 0x0078)
class UStencilOutlineRenderStrategy final : public UBaseOutlineRenderStrategy
{
public:
	TArray<class UMaterialInterface*>             _replacementMaterials;                             // 0x0078(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class UBatchMeshCommands*>             _translucentCopies;                                // 0x0088(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_98[0x8];                                       // 0x0098(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void EnableCopyStencilToCustomStencil(bool Enabled);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StencilOutlineRenderStrategy">();
	}
	static class UStencilOutlineRenderStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStencilOutlineRenderStrategy>();
	}
};
static_assert(alignof(UStencilOutlineRenderStrategy) == 0x000008, "Wrong alignment on UStencilOutlineRenderStrategy");
static_assert(sizeof(UStencilOutlineRenderStrategy) == 0x0000A0, "Wrong size on UStencilOutlineRenderStrategy");
static_assert(offsetof(UStencilOutlineRenderStrategy, _replacementMaterials) == 0x000078, "Member 'UStencilOutlineRenderStrategy::_replacementMaterials' has a wrong offset!");
static_assert(offsetof(UStencilOutlineRenderStrategy, _translucentCopies) == 0x000088, "Member 'UStencilOutlineRenderStrategy::_translucentCopies' has a wrong offset!");

// Class GFXUtilities.TranslucentOutlineRenderStrategy
// 0x0010 (0x0088 - 0x0078)
class UTranslucentOutlineRenderStrategy final : public UBaseOutlineRenderStrategy
{
public:
	TArray<class UMaterialInterface*>             _replacementMaterials;                             // 0x0078(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TranslucentOutlineRenderStrategy">();
	}
	static class UTranslucentOutlineRenderStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTranslucentOutlineRenderStrategy>();
	}
};
static_assert(alignof(UTranslucentOutlineRenderStrategy) == 0x000008, "Wrong alignment on UTranslucentOutlineRenderStrategy");
static_assert(sizeof(UTranslucentOutlineRenderStrategy) == 0x000088, "Wrong size on UTranslucentOutlineRenderStrategy");
static_assert(offsetof(UTranslucentOutlineRenderStrategy, _replacementMaterials) == 0x000078, "Member 'UTranslucentOutlineRenderStrategy::_replacementMaterials' has a wrong offset!");

}

