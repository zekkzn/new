#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: GFXUtilities

#include "Basic.hpp"

#include "GFXUtilities_classes.hpp"
#include "GFXUtilities_parameters.hpp"


namespace SDK
{

// Function GFXUtilities.BatchMeshCommands.AddGroup
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FMaterialNamedGroup              Group                                                  (ConstParm, Parm, NativeAccessSpecifierPublic)

void UBatchMeshCommands::AddGroup(const struct FMaterialNamedGroup& Group)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BatchMeshCommands", "AddGroup");

	Params::BatchMeshCommands_AddGroup Parms{};

	Parms.Group = std::move(Group);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.BatchMeshCommands.BatchSetComponentTickEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBatchMeshCommands::BatchSetComponentTickEnabled(bool Enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BatchMeshCommands", "BatchSetComponentTickEnabled");

	Params::BatchMeshCommands_BatchSetComponentTickEnabled Parms{};

	Parms.Enabled = Enabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.BatchMeshCommands.BatchSetSkipComponentAndChildrenTransformUpdate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Skip                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBatchMeshCommands::BatchSetSkipComponentAndChildrenTransformUpdate(bool Skip)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BatchMeshCommands", "BatchSetSkipComponentAndChildrenTransformUpdate");

	Params::BatchMeshCommands_BatchSetSkipComponentAndChildrenTransformUpdate Parms{};

	Parms.Skip = Skip;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.BatchMeshCommands.BatchSetVisibility
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewVisibility                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPropagateToChildren                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBatchMeshCommands::BatchSetVisibility(bool bNewVisibility, bool bPropagateToChildren)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BatchMeshCommands", "BatchSetVisibility");

	Params::BatchMeshCommands_BatchSetVisibility Parms{};

	Parms.bNewVisibility = bNewVisibility;
	Parms.bPropagateToChildren = bPropagateToChildren;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.BatchMeshCommands.CopyFirstScalarParameter
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             ParameterName                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OutValue                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBatchMeshCommands::CopyFirstScalarParameter(const class FName ParameterName, float* OutValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BatchMeshCommands", "CopyFirstScalarParameter");

	Params::BatchMeshCommands_CopyFirstScalarParameter Parms{};

	Parms.ParameterName = ParameterName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutValue != nullptr)
		*OutValue = Parms.OutValue;

	return Parms.ReturnValue;
}


// Function GFXUtilities.BatchMeshCommands.ResetMaterials
// (Final, Native, Public, BlueprintCallable)

void UBatchMeshCommands::ResetMaterials()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BatchMeshCommands", "ResetMaterials");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.BatchMeshCommands.SetAllToSameMaterial
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMaterialInterface*               MaterialInterface                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBatchMeshCommands::SetAllToSameMaterial(class UMaterialInterface* MaterialInterface)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BatchMeshCommands", "SetAllToSameMaterial");

	Params::BatchMeshCommands_SetAllToSameMaterial Parms{};

	Parms.MaterialInterface = MaterialInterface;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.BatchMeshCommands.SetCastCinematicShadows
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    CastCinematicShadows                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBatchMeshCommands::SetCastCinematicShadows(bool CastCinematicShadows)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BatchMeshCommands", "SetCastCinematicShadows");

	Params::BatchMeshCommands_SetCastCinematicShadows Parms{};

	Parms.CastCinematicShadows = CastCinematicShadows;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.BatchMeshCommands.SetColourParameter
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             ParameterName                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     NewValue                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBatchMeshCommands::SetColourParameter(const class FName ParameterName, const struct FLinearColor& NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BatchMeshCommands", "SetColourParameter");

	Params::BatchMeshCommands_SetColourParameter Parms{};

	Parms.ParameterName = ParameterName;
	Parms.NewValue = std::move(NewValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.BatchMeshCommands.SetCustomDepthStencilValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   StencilValue                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBatchMeshCommands::SetCustomDepthStencilValue(int32 StencilValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BatchMeshCommands", "SetCustomDepthStencilValue");

	Params::BatchMeshCommands_SetCustomDepthStencilValue Parms{};

	Parms.StencilValue = StencilValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.BatchMeshCommands.SetLightingChannelForAllMeshes
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FLightingChannels                LightingChannels                                       (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UBatchMeshCommands::SetLightingChannelForAllMeshes(const struct FLightingChannels& LightingChannels)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BatchMeshCommands", "SetLightingChannelForAllMeshes");

	Params::BatchMeshCommands_SetLightingChannelForAllMeshes Parms{};

	Parms.LightingChannels = std::move(LightingChannels);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.BatchMeshCommands.SetMaterial
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           GroupName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBatchMeshCommands::SetMaterial(const class FString& GroupName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BatchMeshCommands", "SetMaterial");

	Params::BatchMeshCommands_SetMaterial Parms{};

	Parms.GroupName = std::move(GroupName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.BatchMeshCommands.SetReceivesDecals
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReceivesDecals                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBatchMeshCommands::SetReceivesDecals(bool ReceivesDecals)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BatchMeshCommands", "SetReceivesDecals");

	Params::BatchMeshCommands_SetReceivesDecals Parms{};

	Parms.ReceivesDecals = ReceivesDecals;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.BatchMeshCommands.SetRenderInCustomColourNoDepth
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    RenderInCustomColour                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBatchMeshCommands::SetRenderInCustomColourNoDepth(bool RenderInCustomColour)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BatchMeshCommands", "SetRenderInCustomColourNoDepth");

	Params::BatchMeshCommands_SetRenderInCustomColourNoDepth Parms{};

	Parms.RenderInCustomColour = RenderInCustomColour;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.BatchMeshCommands.SetRenderInCustomDepth
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    RenderInCustomDepth                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBatchMeshCommands::SetRenderInCustomDepth(bool RenderInCustomDepth)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BatchMeshCommands", "SetRenderInCustomDepth");

	Params::BatchMeshCommands_SetRenderInCustomDepth Parms{};

	Parms.RenderInCustomDepth = RenderInCustomDepth;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.BatchMeshCommands.SetRenderInMainPass
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InRenderInMainPass                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBatchMeshCommands::SetRenderInMainPass(bool InRenderInMainPass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BatchMeshCommands", "SetRenderInMainPass");

	Params::BatchMeshCommands_SetRenderInMainPass Parms{};

	Parms.InRenderInMainPass = InRenderInMainPass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.BatchMeshCommands.SetScalarParameter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ParameterName                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewValue                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBatchMeshCommands::SetScalarParameter(const class FName ParameterName, const float NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BatchMeshCommands", "SetScalarParameter");

	Params::BatchMeshCommands_SetScalarParameter Parms{};

	Parms.ParameterName = ParameterName;
	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.BatchMeshCommands.SetStencilIntegerScalarParameter
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             ParameterName                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NewValue                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBatchMeshCommands::SetStencilIntegerScalarParameter(const class FName ParameterName, const int32& NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BatchMeshCommands", "SetStencilIntegerScalarParameter");

	Params::BatchMeshCommands_SetStencilIntegerScalarParameter Parms{};

	Parms.ParameterName = ParameterName;
	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.BatchMeshCommands.SetTextureParameter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ParameterName                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture*                         NewTexture                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBatchMeshCommands::SetTextureParameter(const class FName ParameterName, class UTexture* NewTexture)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BatchMeshCommands", "SetTextureParameter");

	Params::BatchMeshCommands_SetTextureParameter Parms{};

	Parms.ParameterName = ParameterName;
	Parms.NewTexture = NewTexture;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.BatchMeshCommands.SetVectorParameter
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             ParameterName                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          NewValue                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBatchMeshCommands::SetVectorParameter(const class FName ParameterName, const struct FVector& NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BatchMeshCommands", "SetVectorParameter");

	Params::BatchMeshCommands_SetVectorParameter Parms{};

	Parms.ParameterName = ParameterName;
	Parms.NewValue = std::move(NewValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.BatchMeshCommands.UpdateMaterials
// (Final, Native, Public, BlueprintCallable)

void UBatchMeshCommands::UpdateMaterials()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BatchMeshCommands", "UpdateMaterials");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.ClippableProviderComponent.AddIgnoredPrimitives
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class UPrimitiveComponent*>      IgnoredPrimitives                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UClippableProviderComponent::AddIgnoredPrimitives(const TArray<class UPrimitiveComponent*>& IgnoredPrimitives)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClippableProviderComponent", "AddIgnoredPrimitives");

	Params::ClippableProviderComponent_AddIgnoredPrimitives Parms{};

	Parms.IgnoredPrimitives = std::move(IgnoredPrimitives);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.ClippableProviderComponent.SetIgnoredPrimitives
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class UPrimitiveComponent*>      IgnoredPrimitives                                      (ConstParm, Parm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UClippableProviderComponent::SetIgnoredPrimitives(const TArray<class UPrimitiveComponent*>& IgnoredPrimitives)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClippableProviderComponent", "SetIgnoredPrimitives");

	Params::ClippableProviderComponent_SetIgnoredPrimitives Parms{};

	Parms.IgnoredPrimitives = std::move(IgnoredPrimitives);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.DBDReflectionCaptureSpawnerComponent.SetBrightness
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Param_Brightness                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDReflectionCaptureSpawnerComponent::SetBrightness(float Param_Brightness)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDReflectionCaptureSpawnerComponent", "SetBrightness");

	Params::DBDReflectionCaptureSpawnerComponent_SetBrightness Parms{};

	Parms.Param_Brightness = Param_Brightness;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.DBDReflectionCaptureSpawnerComponent.SetContributionFactor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Param_ContributionFactor                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDReflectionCaptureSpawnerComponent::SetContributionFactor(float Param_ContributionFactor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDReflectionCaptureSpawnerComponent", "SetContributionFactor");

	Params::DBDReflectionCaptureSpawnerComponent_SetContributionFactor Parms{};

	Parms.Param_ContributionFactor = Param_ContributionFactor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.DBDReflectionCaptureSpawnerComponent.SetIBLMultiplicator
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Param_IBLMultiplicator                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDReflectionCaptureSpawnerComponent::SetIBLMultiplicator(float Param_IBLMultiplicator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDReflectionCaptureSpawnerComponent", "SetIBLMultiplicator");

	Params::DBDReflectionCaptureSpawnerComponent_SetIBLMultiplicator Parms{};

	Parms.Param_IBLMultiplicator = Param_IBLMultiplicator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.GFXUtilities.ActivateVFX
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*           SkeletalMeshComponent                                  (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Active                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGFXUtilities::ActivateVFX(class USkeletalMeshComponent* SkeletalMeshComponent, bool Active)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GFXUtilities", "ActivateVFX");

	Params::GFXUtilities_ActivateVFX Parms{};

	Parms.SkeletalMeshComponent = SkeletalMeshComponent;
	Parms.Active = Active;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.LightIntensityTimelineComponent.AddLight
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ULightComponent*                  Light                                                  (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Multiplier                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightIntensityTimelineComponent::AddLight(class ULightComponent* Light, float Multiplier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightIntensityTimelineComponent", "AddLight");

	Params::LightIntensityTimelineComponent_AddLight Parms{};

	Parms.Light = Light;
	Parms.Multiplier = Multiplier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.LightIntensityTimelineComponent.AddMaterialHelper
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMaterialHelper*                  MatHelper                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             PropName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Multiplier                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightIntensityTimelineComponent::AddMaterialHelper(class UMaterialHelper* MatHelper, class FName PropName, float Multiplier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightIntensityTimelineComponent", "AddMaterialHelper");

	Params::LightIntensityTimelineComponent_AddMaterialHelper Parms{};

	Parms.MatHelper = MatHelper;
	Parms.PropName = PropName;
	Parms.Multiplier = Multiplier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.LightIntensityTimelineComponent.DeactivateTick
// (Final, Native, Public, BlueprintCallable)

void ULightIntensityTimelineComponent::DeactivateTick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightIntensityTimelineComponent", "DeactivateTick");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.LightIntensityTimelineComponent.RegisterForTick
// (Final, Native, Public, BlueprintCallable)

void ULightIntensityTimelineComponent::RegisterForTick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightIntensityTimelineComponent", "RegisterForTick");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.LightIntensityTimelineComponent.Reset
// (Final, Native, Public, BlueprintCallable)

void ULightIntensityTimelineComponent::Reset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightIntensityTimelineComponent", "Reset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.LightIntensityTimelineComponent.SetLightCurve
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UCurveFloat*                      Lightcurve                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightIntensityTimelineComponent::SetLightCurve(class UCurveFloat* Lightcurve)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightIntensityTimelineComponent", "SetLightCurve");

	Params::LightIntensityTimelineComponent_SetLightCurve Parms{};

	Parms.Lightcurve = Lightcurve;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.LightIntensityTimelineComponent.SetLightToMaxValue
// (Final, Native, Public, BlueprintCallable)

void ULightIntensityTimelineComponent::SetLightToMaxValue()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightIntensityTimelineComponent", "SetLightToMaxValue");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.LightIntensityTimelineComponent.SetMaxLength
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewMaxValue                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightIntensityTimelineComponent::SetMaxLength(float NewMaxValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightIntensityTimelineComponent", "SetMaxLength");

	Params::LightIntensityTimelineComponent_SetMaxLength Parms{};

	Parms.NewMaxValue = NewMaxValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.LightIntensityTimelineComponent.SetMinLength
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewMinValue                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightIntensityTimelineComponent::SetMinLength(float NewMinValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightIntensityTimelineComponent", "SetMinLength");

	Params::LightIntensityTimelineComponent_SetMinLength Parms{};

	Parms.NewMinValue = NewMinValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.LightIntensityTimelineComponent.SetRandomizeLength
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    IsRandom                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightIntensityTimelineComponent::SetRandomizeLength(bool IsRandom)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightIntensityTimelineComponent", "SetRandomizeLength");

	Params::LightIntensityTimelineComponent_SetRandomizeLength Parms{};

	Parms.IsRandom = IsRandom;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.MaterialHelper.SetSceneComponentVisibility
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class USceneComponent*                  InSceneComponent                                       (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    NewVisibility                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    PropagateToChildren                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaterialHelper::SetSceneComponentVisibility(class USceneComponent* InSceneComponent, const bool NewVisibility, const bool PropagateToChildren)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MaterialHelper", "SetSceneComponentVisibility");

	Params::MaterialHelper_SetSceneComponentVisibility Parms{};

	Parms.InSceneComponent = InSceneComponent;
	Parms.NewVisibility = NewVisibility;
	Parms.PropagateToChildren = PropagateToChildren;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.MaterialHelper.RefreshMesh
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMeshComponent*                   Mc                                                     (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaterialHelper::RefreshMesh(class UMeshComponent* Mc)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaterialHelper", "RefreshMesh");

	Params::MaterialHelper_RefreshMesh Parms{};

	Parms.Mc = Mc;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.MaterialHelper.RefreshMeshes
// (Final, Native, Public, BlueprintCallable)

void UMaterialHelper::RefreshMeshes()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaterialHelper", "RefreshMeshes");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.AsyncAction_OverrideMaterial.AsyncOverrideMaterial
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMeshComponent*                   Mesh                                                   (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     Group                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMaterialOverridePriority               Priority                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    CopyPhysicalMaterial                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAsyncAction_OverrideMaterial*    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAsyncAction_OverrideMaterial* UAsyncAction_OverrideMaterial::AsyncOverrideMaterial(class UObject* WorldContextObject, class UMeshComponent* Mesh, const struct FGameplayTag& Group, EMaterialOverridePriority Priority, bool CopyPhysicalMaterial)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AsyncAction_OverrideMaterial", "AsyncOverrideMaterial");

	Params::AsyncAction_OverrideMaterial_AsyncOverrideMaterial Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Mesh = Mesh;
	Parms.Group = std::move(Group);
	Parms.Priority = Priority;
	Parms.CopyPhysicalMaterial = CopyPhysicalMaterial;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GFXUtilities.MaterialOverrideSubsystem.AddNewVariantPairToLibrary
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     VariantName                                            (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UMaterialInterface>Src                                                    (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UMaterialInterface>Dst                                                    (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaterialOverrideSubsystem::AddNewVariantPairToLibrary(const struct FGameplayTag& VariantName, TSoftObjectPtr<class UMaterialInterface> Src, TSoftObjectPtr<class UMaterialInterface> Dst)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaterialOverrideSubsystem", "AddNewVariantPairToLibrary");

	Params::MaterialOverrideSubsystem_AddNewVariantPairToLibrary Parms{};

	Parms.VariantName = std::move(VariantName);
	Parms.Src = Src;
	Parms.Dst = Dst;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.MaterialOverrideSubsystem.RemoveMaterialVariantOverride
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMeshComponent*                   Mesh                                                   (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     VariantName                                            (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaterialOverrideSubsystem::RemoveMaterialVariantOverride(class UMeshComponent* Mesh, const struct FGameplayTag& VariantName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaterialOverrideSubsystem", "RemoveMaterialVariantOverride");

	Params::MaterialOverrideSubsystem_RemoveMaterialVariantOverride Parms{};

	Parms.Mesh = Mesh;
	Parms.VariantName = std::move(VariantName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.MaterialOverrideSubsystem.RemoveVariantsWithNameFromLibrary
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     VariantName                                            (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaterialOverrideSubsystem::RemoveVariantsWithNameFromLibrary(const struct FGameplayTag& VariantName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaterialOverrideSubsystem", "RemoveVariantsWithNameFromLibrary");

	Params::MaterialOverrideSubsystem_RemoveVariantsWithNameFromLibrary Parms{};

	Parms.VariantName = std::move(VariantName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.MaterialOverrideSubsystem.SetOverrideMaterials
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMeshComponent*                   Mesh                                                   (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     VariantName                                            (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMaterialOverridePriority               Priority                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMaterialOverrideSubsystem::SetOverrideMaterials(class UMeshComponent* Mesh, const struct FGameplayTag& VariantName, EMaterialOverridePriority Priority)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaterialOverrideSubsystem", "SetOverrideMaterials");

	Params::MaterialOverrideSubsystem_SetOverrideMaterials Parms{};

	Parms.Mesh = Mesh;
	Parms.VariantName = std::move(VariantName);
	Parms.Priority = Priority;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GFXUtilities.MaterialOverrideSubsystem.SetOverrideMaterialsAdvanced
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMeshComponent*                   Mesh                                                   (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     VariantName                                            (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCopyPhysicalMaterial                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMaterialOverridePriority               Priority                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMaterialOverrideParameterCopyType      ParameterCopyType                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   RecursionLimit                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMaterialOverrideSubsystem::SetOverrideMaterialsAdvanced(class UMeshComponent* Mesh, const struct FGameplayTag& VariantName, bool bCopyPhysicalMaterial, EMaterialOverridePriority Priority, EMaterialOverrideParameterCopyType ParameterCopyType, int32 RecursionLimit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaterialOverrideSubsystem", "SetOverrideMaterialsAdvanced");

	Params::MaterialOverrideSubsystem_SetOverrideMaterialsAdvanced Parms{};

	Parms.Mesh = Mesh;
	Parms.VariantName = std::move(VariantName);
	Parms.bCopyPhysicalMaterial = bCopyPhysicalMaterial;
	Parms.Priority = Priority;
	Parms.ParameterCopyType = ParameterCopyType;
	Parms.RecursionLimit = RecursionLimit;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GFXUtilities.OuterlineComponent.SetIntensity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Intensity                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOuterlineComponent::SetIntensity(float Intensity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OuterlineComponent", "SetIntensity");

	Params::OuterlineComponent_SetIntensity Parms{};

	Parms.Intensity = Intensity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.StencilOutlineRenderStrategy.EnableCopyStencilToCustomStencil
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    Enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStencilOutlineRenderStrategy::EnableCopyStencilToCustomStencil(bool Enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("StencilOutlineRenderStrategy", "EnableCopyStencilToCustomStencil");

	Params::StencilOutlineRenderStrategy_EnableCopyStencilToCustomStencil Parms{};

	Parms.Enabled = Enabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}

}

