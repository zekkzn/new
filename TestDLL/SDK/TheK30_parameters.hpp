#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: TheK30

#include "Basic.hpp"

#include "GameplayTags_structs.hpp"
#include "DeadByDaylight_structs.hpp"
#include "TheK30_structs.hpp"
#include "AIModule_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "Engine_structs.hpp"


namespace SDK::Params
{

// Function TheK30.K30Power.Cosmetic_UpdateRemainingPathLength
// 0x0004 (0x0004 - 0x0000)
struct K30Power_Cosmetic_UpdateRemainingPathLength final
{
public:
	float                                         RemainingPathLengthPercent;                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K30Power_Cosmetic_UpdateRemainingPathLength) == 0x000004, "Wrong alignment on K30Power_Cosmetic_UpdateRemainingPathLength");
static_assert(sizeof(K30Power_Cosmetic_UpdateRemainingPathLength) == 0x000004, "Wrong size on K30Power_Cosmetic_UpdateRemainingPathLength");
static_assert(offsetof(K30Power_Cosmetic_UpdateRemainingPathLength, RemainingPathLengthPercent) == 0x000000, "Member 'K30Power_Cosmetic_UpdateRemainingPathLength::RemainingPathLengthPercent' has a wrong offset!");

// DelegateFunction TheK30.K30Power.GuardSwappedTo__DelegateSignature
// 0x0001 (0x0001 - 0x0000)
struct K30Power_GuardSwappedTo__DelegateSignature final
{
public:
	ESwapToState                                  SwapTo;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K30Power_GuardSwappedTo__DelegateSignature) == 0x000001, "Wrong alignment on K30Power_GuardSwappedTo__DelegateSignature");
static_assert(sizeof(K30Power_GuardSwappedTo__DelegateSignature) == 0x000001, "Wrong size on K30Power_GuardSwappedTo__DelegateSignature");
static_assert(offsetof(K30Power_GuardSwappedTo__DelegateSignature, SwapTo) == 0x000000, "Member 'K30Power_GuardSwappedTo__DelegateSignature::SwapTo' has a wrong offset!");

// DelegateFunction TheK30.K30Power.PowerStateChanged__DelegateSignature
// 0x0002 (0x0002 - 0x0000)
struct K30Power_PowerStateChanged__DelegateSignature final
{
public:
	EPowerState                                   PreviousState;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPowerState                                   NewState;                                          // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K30Power_PowerStateChanged__DelegateSignature) == 0x000001, "Wrong alignment on K30Power_PowerStateChanged__DelegateSignature");
static_assert(sizeof(K30Power_PowerStateChanged__DelegateSignature) == 0x000002, "Wrong size on K30Power_PowerStateChanged__DelegateSignature");
static_assert(offsetof(K30Power_PowerStateChanged__DelegateSignature, PreviousState) == 0x000000, "Member 'K30Power_PowerStateChanged__DelegateSignature::PreviousState' has a wrong offset!");
static_assert(offsetof(K30Power_PowerStateChanged__DelegateSignature, NewState) == 0x000001, "Member 'K30Power_PowerStateChanged__DelegateSignature::NewState' has a wrong offset!");

// Function TheK30.K30Power.GetDrawPatrolPathInteraction
// 0x0008 (0x0008 - 0x0000)
struct K30Power_GetDrawPatrolPathInteraction final
{
public:
	class UDrawPatrolPathInteraction*             ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K30Power_GetDrawPatrolPathInteraction) == 0x000008, "Wrong alignment on K30Power_GetDrawPatrolPathInteraction");
static_assert(sizeof(K30Power_GetDrawPatrolPathInteraction) == 0x000008, "Wrong size on K30Power_GetDrawPatrolPathInteraction");
static_assert(offsetof(K30Power_GetDrawPatrolPathInteraction, ReturnValue) == 0x000000, "Member 'K30Power_GetDrawPatrolPathInteraction::ReturnValue' has a wrong offset!");

// Function TheK30.K30Power.GetKnightOrderComponent
// 0x0008 (0x0008 - 0x0000)
struct K30Power_GetKnightOrderComponent final
{
public:
	class UKnightOrderComponent*                  ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K30Power_GetKnightOrderComponent) == 0x000008, "Wrong alignment on K30Power_GetKnightOrderComponent");
static_assert(sizeof(K30Power_GetKnightOrderComponent) == 0x000008, "Wrong size on K30Power_GetKnightOrderComponent");
static_assert(offsetof(K30Power_GetKnightOrderComponent, ReturnValue) == 0x000000, "Member 'K30Power_GetKnightOrderComponent::ReturnValue' has a wrong offset!");

// Function TheK30.K30Power.GetPatrolTrailComponent
// 0x0008 (0x0008 - 0x0000)
struct K30Power_GetPatrolTrailComponent final
{
public:
	class UPatrolTrailComponent*                  ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K30Power_GetPatrolTrailComponent) == 0x000008, "Wrong alignment on K30Power_GetPatrolTrailComponent");
static_assert(sizeof(K30Power_GetPatrolTrailComponent) == 0x000008, "Wrong size on K30Power_GetPatrolTrailComponent");
static_assert(offsetof(K30Power_GetPatrolTrailComponent, ReturnValue) == 0x000000, "Member 'K30Power_GetPatrolTrailComponent::ReturnValue' has a wrong offset!");

// Function TheK30.K30Power.GetRemainingPathLengthPercent
// 0x0004 (0x0004 - 0x0000)
struct K30Power_GetRemainingPathLengthPercent final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K30Power_GetRemainingPathLengthPercent) == 0x000004, "Wrong alignment on K30Power_GetRemainingPathLengthPercent");
static_assert(sizeof(K30Power_GetRemainingPathLengthPercent) == 0x000004, "Wrong size on K30Power_GetRemainingPathLengthPercent");
static_assert(offsetof(K30Power_GetRemainingPathLengthPercent, ReturnValue) == 0x000000, "Member 'K30Power_GetRemainingPathLengthPercent::ReturnValue' has a wrong offset!");

// Function TheK30.K30Power.GetSwapGuardTypeInteraction
// 0x0008 (0x0008 - 0x0000)
struct K30Power_GetSwapGuardTypeInteraction final
{
public:
	class USwapGuardTypeInteraction*              ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K30Power_GetSwapGuardTypeInteraction) == 0x000008, "Wrong alignment on K30Power_GetSwapGuardTypeInteraction");
static_assert(sizeof(K30Power_GetSwapGuardTypeInteraction) == 0x000008, "Wrong size on K30Power_GetSwapGuardTypeInteraction");
static_assert(offsetof(K30Power_GetSwapGuardTypeInteraction, ReturnValue) == 0x000000, "Member 'K30Power_GetSwapGuardTypeInteraction::ReturnValue' has a wrong offset!");

// Function TheK30.K30Power.IsDrawingPath
// 0x0001 (0x0001 - 0x0000)
struct K30Power_IsDrawingPath final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K30Power_IsDrawingPath) == 0x000001, "Wrong alignment on K30Power_IsDrawingPath");
static_assert(sizeof(K30Power_IsDrawingPath) == 0x000001, "Wrong size on K30Power_IsDrawingPath");
static_assert(offsetof(K30Power_IsDrawingPath, ReturnValue) == 0x000000, "Member 'K30Power_IsDrawingPath::ReturnValue' has a wrong offset!");

// Function TheK30.TrailNode.IsFirstNode
// 0x0001 (0x0001 - 0x0000)
struct TrailNode_IsFirstNode final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TrailNode_IsFirstNode) == 0x000001, "Wrong alignment on TrailNode_IsFirstNode");
static_assert(sizeof(TrailNode_IsFirstNode) == 0x000001, "Wrong size on TrailNode_IsFirstNode");
static_assert(offsetof(TrailNode_IsFirstNode, ReturnValue) == 0x000000, "Member 'TrailNode_IsFirstNode::ReturnValue' has a wrong offset!");

// Function TheK30.GuardController.OnLoudNoiseTriggered
// 0x0038 (0x0038 - 0x0000)
struct GuardController_OnLoudNoiseTriggered final
{
public:
	class AActor*                                 Originator;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 InstigatingActor;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0010(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShouldTrack;                                       // 0x0028(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AudibleRange;                                      // 0x002C(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsQuickAction;                                     // 0x0030(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsDeceivingNoise;                                  // 0x0031(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x6];                                       // 0x0032(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GuardController_OnLoudNoiseTriggered) == 0x000008, "Wrong alignment on GuardController_OnLoudNoiseTriggered");
static_assert(sizeof(GuardController_OnLoudNoiseTriggered) == 0x000038, "Wrong size on GuardController_OnLoudNoiseTriggered");
static_assert(offsetof(GuardController_OnLoudNoiseTriggered, Originator) == 0x000000, "Member 'GuardController_OnLoudNoiseTriggered::Originator' has a wrong offset!");
static_assert(offsetof(GuardController_OnLoudNoiseTriggered, InstigatingActor) == 0x000008, "Member 'GuardController_OnLoudNoiseTriggered::InstigatingActor' has a wrong offset!");
static_assert(offsetof(GuardController_OnLoudNoiseTriggered, Location) == 0x000010, "Member 'GuardController_OnLoudNoiseTriggered::Location' has a wrong offset!");
static_assert(offsetof(GuardController_OnLoudNoiseTriggered, ShouldTrack) == 0x000028, "Member 'GuardController_OnLoudNoiseTriggered::ShouldTrack' has a wrong offset!");
static_assert(offsetof(GuardController_OnLoudNoiseTriggered, AudibleRange) == 0x00002C, "Member 'GuardController_OnLoudNoiseTriggered::AudibleRange' has a wrong offset!");
static_assert(offsetof(GuardController_OnLoudNoiseTriggered, IsQuickAction) == 0x000030, "Member 'GuardController_OnLoudNoiseTriggered::IsQuickAction' has a wrong offset!");
static_assert(offsetof(GuardController_OnLoudNoiseTriggered, IsDeceivingNoise) == 0x000031, "Member 'GuardController_OnLoudNoiseTriggered::IsDeceivingNoise' has a wrong offset!");

// Function TheK30.GuardController.OnTargetPerceptionUpdated
// 0x0068 (0x0068 - 0x0000)
struct GuardController_OnTargetPerceptionUpdated final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAIStimulus                            Stimulus;                                          // 0x0008(0x0060)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GuardController_OnTargetPerceptionUpdated) == 0x000008, "Wrong alignment on GuardController_OnTargetPerceptionUpdated");
static_assert(sizeof(GuardController_OnTargetPerceptionUpdated) == 0x000068, "Wrong size on GuardController_OnTargetPerceptionUpdated");
static_assert(offsetof(GuardController_OnTargetPerceptionUpdated, Actor) == 0x000000, "Member 'GuardController_OnTargetPerceptionUpdated::Actor' has a wrong offset!");
static_assert(offsetof(GuardController_OnTargetPerceptionUpdated, Stimulus) == 0x000008, "Member 'GuardController_OnTargetPerceptionUpdated::Stimulus' has a wrong offset!");

// Function TheK30.GuardFlag.Authority_OnBeginOverlap
// 0x0110 (0x0110 - 0x0000)
struct GuardFlag_Authority_OnBeginOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Other;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             HitResult;                                         // 0x0020(0x00F0)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(GuardFlag_Authority_OnBeginOverlap) == 0x000008, "Wrong alignment on GuardFlag_Authority_OnBeginOverlap");
static_assert(sizeof(GuardFlag_Authority_OnBeginOverlap) == 0x000110, "Wrong size on GuardFlag_Authority_OnBeginOverlap");
static_assert(offsetof(GuardFlag_Authority_OnBeginOverlap, OverlappedComponent) == 0x000000, "Member 'GuardFlag_Authority_OnBeginOverlap::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(GuardFlag_Authority_OnBeginOverlap, Other) == 0x000008, "Member 'GuardFlag_Authority_OnBeginOverlap::Other' has a wrong offset!");
static_assert(offsetof(GuardFlag_Authority_OnBeginOverlap, OtherComp) == 0x000010, "Member 'GuardFlag_Authority_OnBeginOverlap::OtherComp' has a wrong offset!");
static_assert(offsetof(GuardFlag_Authority_OnBeginOverlap, OtherBodyIndex) == 0x000018, "Member 'GuardFlag_Authority_OnBeginOverlap::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(GuardFlag_Authority_OnBeginOverlap, bFromSweep) == 0x00001C, "Member 'GuardFlag_Authority_OnBeginOverlap::bFromSweep' has a wrong offset!");
static_assert(offsetof(GuardFlag_Authority_OnBeginOverlap, HitResult) == 0x000020, "Member 'GuardFlag_Authority_OnBeginOverlap::HitResult' has a wrong offset!");

// Function TheK30.GuardFlag.Cosmetic_OnFlagDisappearDueToHuntEnding
// 0x0008 (0x0008 - 0x0000)
struct GuardFlag_Cosmetic_OnFlagDisappearDueToHuntEnding final
{
public:
	class ADBDPlayer*                             PreviouslyHuntedSurvivor;                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GuardFlag_Cosmetic_OnFlagDisappearDueToHuntEnding) == 0x000008, "Wrong alignment on GuardFlag_Cosmetic_OnFlagDisappearDueToHuntEnding");
static_assert(sizeof(GuardFlag_Cosmetic_OnFlagDisappearDueToHuntEnding) == 0x000008, "Wrong size on GuardFlag_Cosmetic_OnFlagDisappearDueToHuntEnding");
static_assert(offsetof(GuardFlag_Cosmetic_OnFlagDisappearDueToHuntEnding, PreviouslyHuntedSurvivor) == 0x000000, "Member 'GuardFlag_Cosmetic_OnFlagDisappearDueToHuntEnding::PreviouslyHuntedSurvivor' has a wrong offset!");

// Function TheK30.GuardFlag.Cosmetic_OnFlagSpawned
// 0x0004 (0x0004 - 0x0000)
struct GuardFlag_Cosmetic_OnFlagSpawned final
{
public:
	float                                         ActivationTimerDuration;                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GuardFlag_Cosmetic_OnFlagSpawned) == 0x000004, "Wrong alignment on GuardFlag_Cosmetic_OnFlagSpawned");
static_assert(sizeof(GuardFlag_Cosmetic_OnFlagSpawned) == 0x000004, "Wrong size on GuardFlag_Cosmetic_OnFlagSpawned");
static_assert(offsetof(GuardFlag_Cosmetic_OnFlagSpawned, ActivationTimerDuration) == 0x000000, "Member 'GuardFlag_Cosmetic_OnFlagSpawned::ActivationTimerDuration' has a wrong offset!");

// Function TheK30.GuardFlag.Cosmetic_OnSurvivorCapturedFlag
// 0x0008 (0x0008 - 0x0000)
struct GuardFlag_Cosmetic_OnSurvivorCapturedFlag final
{
public:
	class ADBDPlayer*                             PreviouslyHuntedSurvivor;                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GuardFlag_Cosmetic_OnSurvivorCapturedFlag) == 0x000008, "Wrong alignment on GuardFlag_Cosmetic_OnSurvivorCapturedFlag");
static_assert(sizeof(GuardFlag_Cosmetic_OnSurvivorCapturedFlag) == 0x000008, "Wrong size on GuardFlag_Cosmetic_OnSurvivorCapturedFlag");
static_assert(offsetof(GuardFlag_Cosmetic_OnSurvivorCapturedFlag, PreviouslyHuntedSurvivor) == 0x000000, "Member 'GuardFlag_Cosmetic_OnSurvivorCapturedFlag::PreviouslyHuntedSurvivor' has a wrong offset!");

// Function TheK30.GuardFlag.Multicast_OnCamperCapturedFlag
// 0x0008 (0x0008 - 0x0000)
struct GuardFlag_Multicast_OnCamperCapturedFlag final
{
public:
	class ADBDPlayer*                             HuntedSurvivor;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GuardFlag_Multicast_OnCamperCapturedFlag) == 0x000008, "Wrong alignment on GuardFlag_Multicast_OnCamperCapturedFlag");
static_assert(sizeof(GuardFlag_Multicast_OnCamperCapturedFlag) == 0x000008, "Wrong size on GuardFlag_Multicast_OnCamperCapturedFlag");
static_assert(offsetof(GuardFlag_Multicast_OnCamperCapturedFlag, HuntedSurvivor) == 0x000000, "Member 'GuardFlag_Multicast_OnCamperCapturedFlag::HuntedSurvivor' has a wrong offset!");

// Function TheK30.GuardFlag.GetActivationTimeLeft
// 0x0004 (0x0004 - 0x0000)
struct GuardFlag_GetActivationTimeLeft final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GuardFlag_GetActivationTimeLeft) == 0x000004, "Wrong alignment on GuardFlag_GetActivationTimeLeft");
static_assert(sizeof(GuardFlag_GetActivationTimeLeft) == 0x000004, "Wrong size on GuardFlag_GetActivationTimeLeft");
static_assert(offsetof(GuardFlag_GetActivationTimeLeft, ReturnValue) == 0x000000, "Member 'GuardFlag_GetActivationTimeLeft::ReturnValue' has a wrong offset!");

// Function TheK30.GuardFlag.GetFlagPickupEnduranceDuration
// 0x0004 (0x0004 - 0x0000)
struct GuardFlag_GetFlagPickupEnduranceDuration final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GuardFlag_GetFlagPickupEnduranceDuration) == 0x000004, "Wrong alignment on GuardFlag_GetFlagPickupEnduranceDuration");
static_assert(sizeof(GuardFlag_GetFlagPickupEnduranceDuration) == 0x000004, "Wrong size on GuardFlag_GetFlagPickupEnduranceDuration");
static_assert(offsetof(GuardFlag_GetFlagPickupEnduranceDuration, ReturnValue) == 0x000000, "Member 'GuardFlag_GetFlagPickupEnduranceDuration::ReturnValue' has a wrong offset!");

// Function TheK30.GuardFlag.GetFlagPickupHasteDuration
// 0x0004 (0x0004 - 0x0000)
struct GuardFlag_GetFlagPickupHasteDuration final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GuardFlag_GetFlagPickupHasteDuration) == 0x000004, "Wrong alignment on GuardFlag_GetFlagPickupHasteDuration");
static_assert(sizeof(GuardFlag_GetFlagPickupHasteDuration) == 0x000004, "Wrong size on GuardFlag_GetFlagPickupHasteDuration");
static_assert(offsetof(GuardFlag_GetFlagPickupHasteDuration, ReturnValue) == 0x000000, "Member 'GuardFlag_GetFlagPickupHasteDuration::ReturnValue' has a wrong offset!");

// Function TheK30.GuardFlag.GetHuntedSurvivor
// 0x0008 (0x0008 - 0x0000)
struct GuardFlag_GetHuntedSurvivor final
{
public:
	class ADBDPlayer*                             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GuardFlag_GetHuntedSurvivor) == 0x000008, "Wrong alignment on GuardFlag_GetHuntedSurvivor");
static_assert(sizeof(GuardFlag_GetHuntedSurvivor) == 0x000008, "Wrong size on GuardFlag_GetHuntedSurvivor");
static_assert(offsetof(GuardFlag_GetHuntedSurvivor, ReturnValue) == 0x000000, "Member 'GuardFlag_GetHuntedSurvivor::ReturnValue' has a wrong offset!");

// DelegateFunction TheK30.GuardHuntComponent.OnGuardPhaseProgressUpdate__DelegateSignature
// 0x0004 (0x0004 - 0x0000)
struct GuardHuntComponent_OnGuardPhaseProgressUpdate__DelegateSignature final
{
public:
	float                                         CompletionProgress;                                // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GuardHuntComponent_OnGuardPhaseProgressUpdate__DelegateSignature) == 0x000004, "Wrong alignment on GuardHuntComponent_OnGuardPhaseProgressUpdate__DelegateSignature");
static_assert(sizeof(GuardHuntComponent_OnGuardPhaseProgressUpdate__DelegateSignature) == 0x000004, "Wrong size on GuardHuntComponent_OnGuardPhaseProgressUpdate__DelegateSignature");
static_assert(offsetof(GuardHuntComponent_OnGuardPhaseProgressUpdate__DelegateSignature, CompletionProgress) == 0x000000, "Member 'GuardHuntComponent_OnGuardPhaseProgressUpdate__DelegateSignature::CompletionProgress' has a wrong offset!");

// Function TheK30.GuardHuntComponent.OnRep_HuntedSurvivor
// 0x0008 (0x0008 - 0x0000)
struct GuardHuntComponent_OnRep_HuntedSurvivor final
{
public:
	class ACamperPlayer*                          PreviousChasedSurvivor;                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GuardHuntComponent_OnRep_HuntedSurvivor) == 0x000008, "Wrong alignment on GuardHuntComponent_OnRep_HuntedSurvivor");
static_assert(sizeof(GuardHuntComponent_OnRep_HuntedSurvivor) == 0x000008, "Wrong size on GuardHuntComponent_OnRep_HuntedSurvivor");
static_assert(offsetof(GuardHuntComponent_OnRep_HuntedSurvivor, PreviousChasedSurvivor) == 0x000000, "Member 'GuardHuntComponent_OnRep_HuntedSurvivor::PreviousChasedSurvivor' has a wrong offset!");

// Function TheK30.GuardHuntComponent.GetHuntedSurvivor
// 0x0008 (0x0008 - 0x0000)
struct GuardHuntComponent_GetHuntedSurvivor final
{
public:
	class ACamperPlayer*                          ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GuardHuntComponent_GetHuntedSurvivor) == 0x000008, "Wrong alignment on GuardHuntComponent_GetHuntedSurvivor");
static_assert(sizeof(GuardHuntComponent_GetHuntedSurvivor) == 0x000008, "Wrong size on GuardHuntComponent_GetHuntedSurvivor");
static_assert(offsetof(GuardHuntComponent_GetHuntedSurvivor, ReturnValue) == 0x000000, "Member 'GuardHuntComponent_GetHuntedSurvivor::ReturnValue' has a wrong offset!");

// Function TheK30.GuardIdleComponent.Multicast_OnIdleStopped
// 0x0001 (0x0001 - 0x0000)
struct GuardIdleComponent_Multicast_OnIdleStopped final
{
public:
	EIdlePostStopOperation                        Operation;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GuardIdleComponent_Multicast_OnIdleStopped) == 0x000001, "Wrong alignment on GuardIdleComponent_Multicast_OnIdleStopped");
static_assert(sizeof(GuardIdleComponent_Multicast_OnIdleStopped) == 0x000001, "Wrong size on GuardIdleComponent_Multicast_OnIdleStopped");
static_assert(offsetof(GuardIdleComponent_Multicast_OnIdleStopped, Operation) == 0x000000, "Member 'GuardIdleComponent_Multicast_OnIdleStopped::Operation' has a wrong offset!");

// Function TheK30.GuardSlowingZone.OnZoneBeginOverlap
// 0x0010 (0x0010 - 0x0000)
struct GuardSlowingZone_OnZoneBeginOverlap final
{
public:
	class AActor*                                 OverlappedActor;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GuardSlowingZone_OnZoneBeginOverlap) == 0x000008, "Wrong alignment on GuardSlowingZone_OnZoneBeginOverlap");
static_assert(sizeof(GuardSlowingZone_OnZoneBeginOverlap) == 0x000010, "Wrong size on GuardSlowingZone_OnZoneBeginOverlap");
static_assert(offsetof(GuardSlowingZone_OnZoneBeginOverlap, OverlappedActor) == 0x000000, "Member 'GuardSlowingZone_OnZoneBeginOverlap::OverlappedActor' has a wrong offset!");
static_assert(offsetof(GuardSlowingZone_OnZoneBeginOverlap, OtherActor) == 0x000008, "Member 'GuardSlowingZone_OnZoneBeginOverlap::OtherActor' has a wrong offset!");

// Function TheK30.GuardSlowingZone.OnZoneEndOverlap
// 0x0010 (0x0010 - 0x0000)
struct GuardSlowingZone_OnZoneEndOverlap final
{
public:
	class AActor*                                 OverlappedActor;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GuardSlowingZone_OnZoneEndOverlap) == 0x000008, "Wrong alignment on GuardSlowingZone_OnZoneEndOverlap");
static_assert(sizeof(GuardSlowingZone_OnZoneEndOverlap) == 0x000010, "Wrong size on GuardSlowingZone_OnZoneEndOverlap");
static_assert(offsetof(GuardSlowingZone_OnZoneEndOverlap, OverlappedActor) == 0x000000, "Member 'GuardSlowingZone_OnZoneEndOverlap::OverlappedActor' has a wrong offset!");
static_assert(offsetof(GuardSlowingZone_OnZoneEndOverlap, OtherActor) == 0x000008, "Member 'GuardSlowingZone_OnZoneEndOverlap::OtherActor' has a wrong offset!");

// Function TheK30.K30Addon18.Authority_OnSplineBeginOverlap
// 0x0110 (0x0110 - 0x0000)
struct K30Addon18_Authority_OnSplineBeginOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x00F0)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(K30Addon18_Authority_OnSplineBeginOverlap) == 0x000008, "Wrong alignment on K30Addon18_Authority_OnSplineBeginOverlap");
static_assert(sizeof(K30Addon18_Authority_OnSplineBeginOverlap) == 0x000110, "Wrong size on K30Addon18_Authority_OnSplineBeginOverlap");
static_assert(offsetof(K30Addon18_Authority_OnSplineBeginOverlap, OverlappedComponent) == 0x000000, "Member 'K30Addon18_Authority_OnSplineBeginOverlap::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(K30Addon18_Authority_OnSplineBeginOverlap, OtherActor) == 0x000008, "Member 'K30Addon18_Authority_OnSplineBeginOverlap::OtherActor' has a wrong offset!");
static_assert(offsetof(K30Addon18_Authority_OnSplineBeginOverlap, OtherComp) == 0x000010, "Member 'K30Addon18_Authority_OnSplineBeginOverlap::OtherComp' has a wrong offset!");
static_assert(offsetof(K30Addon18_Authority_OnSplineBeginOverlap, OtherBodyIndex) == 0x000018, "Member 'K30Addon18_Authority_OnSplineBeginOverlap::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(K30Addon18_Authority_OnSplineBeginOverlap, bFromSweep) == 0x00001C, "Member 'K30Addon18_Authority_OnSplineBeginOverlap::bFromSweep' has a wrong offset!");
static_assert(offsetof(K30Addon18_Authority_OnSplineBeginOverlap, SweepResult) == 0x000020, "Member 'K30Addon18_Authority_OnSplineBeginOverlap::SweepResult' has a wrong offset!");

// Function TheK30.K30Addon18.Authority_OnSplineEndOverlap
// 0x0020 (0x0020 - 0x0000)
struct K30Addon18_Authority_OnSplineEndOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(K30Addon18_Authority_OnSplineEndOverlap) == 0x000008, "Wrong alignment on K30Addon18_Authority_OnSplineEndOverlap");
static_assert(sizeof(K30Addon18_Authority_OnSplineEndOverlap) == 0x000020, "Wrong size on K30Addon18_Authority_OnSplineEndOverlap");
static_assert(offsetof(K30Addon18_Authority_OnSplineEndOverlap, OverlappedComponent) == 0x000000, "Member 'K30Addon18_Authority_OnSplineEndOverlap::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(K30Addon18_Authority_OnSplineEndOverlap, OtherActor) == 0x000008, "Member 'K30Addon18_Authority_OnSplineEndOverlap::OtherActor' has a wrong offset!");
static_assert(offsetof(K30Addon18_Authority_OnSplineEndOverlap, OtherComp) == 0x000010, "Member 'K30Addon18_Authority_OnSplineEndOverlap::OtherComp' has a wrong offset!");
static_assert(offsetof(K30Addon18_Authority_OnSplineEndOverlap, OtherBodyIndex) == 0x000018, "Member 'K30Addon18_Authority_OnSplineEndOverlap::OtherBodyIndex' has a wrong offset!");

// Function TheK30.K30Addon20.Authority_OnPowerStateChanged
// 0x0002 (0x0002 - 0x0000)
struct K30Addon20_Authority_OnPowerStateChanged final
{
public:
	EPowerState                                   PreviousState;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPowerState                                   NewState;                                          // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K30Addon20_Authority_OnPowerStateChanged) == 0x000001, "Wrong alignment on K30Addon20_Authority_OnPowerStateChanged");
static_assert(sizeof(K30Addon20_Authority_OnPowerStateChanged) == 0x000002, "Wrong size on K30Addon20_Authority_OnPowerStateChanged");
static_assert(offsetof(K30Addon20_Authority_OnPowerStateChanged, PreviousState) == 0x000000, "Member 'K30Addon20_Authority_OnPowerStateChanged::PreviousState' has a wrong offset!");
static_assert(offsetof(K30Addon20_Authority_OnPowerStateChanged, NewState) == 0x000001, "Member 'K30Addon20_Authority_OnPowerStateChanged::NewState' has a wrong offset!");

// Function TheK30.K30Addon20.OnEndOverlapWindow
// 0x0020 (0x0020 - 0x0000)
struct K30Addon20_OnEndOverlapWindow final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(K30Addon20_OnEndOverlapWindow) == 0x000008, "Wrong alignment on K30Addon20_OnEndOverlapWindow");
static_assert(sizeof(K30Addon20_OnEndOverlapWindow) == 0x000020, "Wrong size on K30Addon20_OnEndOverlapWindow");
static_assert(offsetof(K30Addon20_OnEndOverlapWindow, OverlappedComponent) == 0x000000, "Member 'K30Addon20_OnEndOverlapWindow::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(K30Addon20_OnEndOverlapWindow, OtherActor) == 0x000008, "Member 'K30Addon20_OnEndOverlapWindow::OtherActor' has a wrong offset!");
static_assert(offsetof(K30Addon20_OnEndOverlapWindow, OtherComp) == 0x000010, "Member 'K30Addon20_OnEndOverlapWindow::OtherComp' has a wrong offset!");
static_assert(offsetof(K30Addon20_OnEndOverlapWindow, OtherBodyIndex) == 0x000018, "Member 'K30Addon20_OnEndOverlapWindow::OtherBodyIndex' has a wrong offset!");

// Function TheK30.K30CheatComponent.DBD_K30SetPatrolAndHuntDuration
// 0x0004 (0x0004 - 0x0000)
struct K30CheatComponent_DBD_K30SetPatrolAndHuntDuration final
{
public:
	float                                         Seconds;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K30CheatComponent_DBD_K30SetPatrolAndHuntDuration) == 0x000004, "Wrong alignment on K30CheatComponent_DBD_K30SetPatrolAndHuntDuration");
static_assert(sizeof(K30CheatComponent_DBD_K30SetPatrolAndHuntDuration) == 0x000004, "Wrong size on K30CheatComponent_DBD_K30SetPatrolAndHuntDuration");
static_assert(offsetof(K30CheatComponent_DBD_K30SetPatrolAndHuntDuration, Seconds) == 0x000000, "Member 'K30CheatComponent_DBD_K30SetPatrolAndHuntDuration::Seconds' has a wrong offset!");

// Function TheK30.K30CheatComponent.DBD_K30ToggleGuardAttackDespawn
// 0x0004 (0x0004 - 0x0000)
struct K30CheatComponent_DBD_K30ToggleGuardAttackDespawn final
{
public:
	int32                                         DespawnOnAttack;                                   // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K30CheatComponent_DBD_K30ToggleGuardAttackDespawn) == 0x000004, "Wrong alignment on K30CheatComponent_DBD_K30ToggleGuardAttackDespawn");
static_assert(sizeof(K30CheatComponent_DBD_K30ToggleGuardAttackDespawn) == 0x000004, "Wrong size on K30CheatComponent_DBD_K30ToggleGuardAttackDespawn");
static_assert(offsetof(K30CheatComponent_DBD_K30ToggleGuardAttackDespawn, DespawnOnAttack) == 0x000000, "Member 'K30CheatComponent_DBD_K30ToggleGuardAttackDespawn::DespawnOnAttack' has a wrong offset!");

// Function TheK30.K30GuardUtilities.GetMaximumHuntDuration
// 0x0010 (0x0010 - 0x0000)
struct K30GuardUtilities_GetMaximumHuntDuration final
{
public:
	const class AKnightGuard*                     Guard;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(K30GuardUtilities_GetMaximumHuntDuration) == 0x000008, "Wrong alignment on K30GuardUtilities_GetMaximumHuntDuration");
static_assert(sizeof(K30GuardUtilities_GetMaximumHuntDuration) == 0x000010, "Wrong size on K30GuardUtilities_GetMaximumHuntDuration");
static_assert(offsetof(K30GuardUtilities_GetMaximumHuntDuration, Guard) == 0x000000, "Member 'K30GuardUtilities_GetMaximumHuntDuration::Guard' has a wrong offset!");
static_assert(offsetof(K30GuardUtilities_GetMaximumHuntDuration, ReturnValue) == 0x000008, "Member 'K30GuardUtilities_GetMaximumHuntDuration::ReturnValue' has a wrong offset!");

// Function TheK30.K30GuardUtilities.GetPatrolDuration
// 0x0010 (0x0010 - 0x0000)
struct K30GuardUtilities_GetPatrolDuration final
{
public:
	const class AKnightGuard*                     Guard;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(K30GuardUtilities_GetPatrolDuration) == 0x000008, "Wrong alignment on K30GuardUtilities_GetPatrolDuration");
static_assert(sizeof(K30GuardUtilities_GetPatrolDuration) == 0x000010, "Wrong size on K30GuardUtilities_GetPatrolDuration");
static_assert(offsetof(K30GuardUtilities_GetPatrolDuration, Guard) == 0x000000, "Member 'K30GuardUtilities_GetPatrolDuration::Guard' has a wrong offset!");
static_assert(offsetof(K30GuardUtilities_GetPatrolDuration, ReturnValue) == 0x000008, "Member 'K30GuardUtilities_GetPatrolDuration::ReturnValue' has a wrong offset!");

// Function TheK30.K30GuardUtilities.GetPatrollingVisionRangeBaseValue
// 0x0010 (0x0010 - 0x0000)
struct K30GuardUtilities_GetPatrollingVisionRangeBaseValue final
{
public:
	const class AKnightGuard*                     Guard;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(K30GuardUtilities_GetPatrollingVisionRangeBaseValue) == 0x000008, "Wrong alignment on K30GuardUtilities_GetPatrollingVisionRangeBaseValue");
static_assert(sizeof(K30GuardUtilities_GetPatrollingVisionRangeBaseValue) == 0x000010, "Wrong size on K30GuardUtilities_GetPatrollingVisionRangeBaseValue");
static_assert(offsetof(K30GuardUtilities_GetPatrollingVisionRangeBaseValue, Guard) == 0x000000, "Member 'K30GuardUtilities_GetPatrollingVisionRangeBaseValue::Guard' has a wrong offset!");
static_assert(offsetof(K30GuardUtilities_GetPatrollingVisionRangeBaseValue, ReturnValue) == 0x000008, "Member 'K30GuardUtilities_GetPatrollingVisionRangeBaseValue::ReturnValue' has a wrong offset!");

// Function TheK30.K30HugCosmeticHandler.Cosmetic_Hug
// 0x0018 (0x0018 - 0x0000)
struct K30HugCosmeticHandler_Cosmetic_Hug final
{
public:
	bool                                          IsHugging;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 VaultableOwner;                                    // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACamperPlayer*                          HugInstigator;                                     // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K30HugCosmeticHandler_Cosmetic_Hug) == 0x000008, "Wrong alignment on K30HugCosmeticHandler_Cosmetic_Hug");
static_assert(sizeof(K30HugCosmeticHandler_Cosmetic_Hug) == 0x000018, "Wrong size on K30HugCosmeticHandler_Cosmetic_Hug");
static_assert(offsetof(K30HugCosmeticHandler_Cosmetic_Hug, IsHugging) == 0x000000, "Member 'K30HugCosmeticHandler_Cosmetic_Hug::IsHugging' has a wrong offset!");
static_assert(offsetof(K30HugCosmeticHandler_Cosmetic_Hug, VaultableOwner) == 0x000008, "Member 'K30HugCosmeticHandler_Cosmetic_Hug::VaultableOwner' has a wrong offset!");
static_assert(offsetof(K30HugCosmeticHandler_Cosmetic_Hug, HugInstigator) == 0x000010, "Member 'K30HugCosmeticHandler_Cosmetic_Hug::HugInstigator' has a wrong offset!");

// Function TheK30.K30HugCosmeticHandler.OnBeginOverlap
// 0x0110 (0x0110 - 0x0000)
struct K30HugCosmeticHandler_OnBeginOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Other;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x00F0)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(K30HugCosmeticHandler_OnBeginOverlap) == 0x000008, "Wrong alignment on K30HugCosmeticHandler_OnBeginOverlap");
static_assert(sizeof(K30HugCosmeticHandler_OnBeginOverlap) == 0x000110, "Wrong size on K30HugCosmeticHandler_OnBeginOverlap");
static_assert(offsetof(K30HugCosmeticHandler_OnBeginOverlap, OverlappedComponent) == 0x000000, "Member 'K30HugCosmeticHandler_OnBeginOverlap::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(K30HugCosmeticHandler_OnBeginOverlap, Other) == 0x000008, "Member 'K30HugCosmeticHandler_OnBeginOverlap::Other' has a wrong offset!");
static_assert(offsetof(K30HugCosmeticHandler_OnBeginOverlap, OtherComp) == 0x000010, "Member 'K30HugCosmeticHandler_OnBeginOverlap::OtherComp' has a wrong offset!");
static_assert(offsetof(K30HugCosmeticHandler_OnBeginOverlap, OtherBodyIndex) == 0x000018, "Member 'K30HugCosmeticHandler_OnBeginOverlap::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(K30HugCosmeticHandler_OnBeginOverlap, bFromSweep) == 0x00001C, "Member 'K30HugCosmeticHandler_OnBeginOverlap::bFromSweep' has a wrong offset!");
static_assert(offsetof(K30HugCosmeticHandler_OnBeginOverlap, SweepResult) == 0x000020, "Member 'K30HugCosmeticHandler_OnBeginOverlap::SweepResult' has a wrong offset!");

// Function TheK30.K30HugCosmeticHandler.OnVault
// 0x0008 (0x0008 - 0x0000)
struct K30HugCosmeticHandler_OnVault final
{
public:
	class ADBDPlayer*                             Vaulter;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K30HugCosmeticHandler_OnVault) == 0x000008, "Wrong alignment on K30HugCosmeticHandler_OnVault");
static_assert(sizeof(K30HugCosmeticHandler_OnVault) == 0x000008, "Wrong size on K30HugCosmeticHandler_OnVault");
static_assert(offsetof(K30HugCosmeticHandler_OnVault, Vaulter) == 0x000000, "Member 'K30HugCosmeticHandler_OnVault::Vaulter' has a wrong offset!");

// Function TheK30.K30P02.Authority_OnSurvivorFirstScream
// 0x0008 (0x0008 - 0x0000)
struct K30P02_Authority_OnSurvivorFirstScream final
{
public:
	class ADBDPlayer*                             Player;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K30P02_Authority_OnSurvivorFirstScream) == 0x000008, "Wrong alignment on K30P02_Authority_OnSurvivorFirstScream");
static_assert(sizeof(K30P02_Authority_OnSurvivorFirstScream) == 0x000008, "Wrong size on K30P02_Authority_OnSurvivorFirstScream");
static_assert(offsetof(K30P02_Authority_OnSurvivorFirstScream, Player) == 0x000000, "Member 'K30P02_Authority_OnSurvivorFirstScream::Player' has a wrong offset!");

// Function TheK30.K30P02.Authority_OnTotemStateChanged
// 0x0002 (0x0002 - 0x0000)
struct K30P02_Authority_OnTotemStateChanged final
{
public:
	ETotemState                                   OldState;                                          // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETotemState                                   NewState;                                          // 0x0001(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K30P02_Authority_OnTotemStateChanged) == 0x000001, "Wrong alignment on K30P02_Authority_OnTotemStateChanged");
static_assert(sizeof(K30P02_Authority_OnTotemStateChanged) == 0x000002, "Wrong size on K30P02_Authority_OnTotemStateChanged");
static_assert(offsetof(K30P02_Authority_OnTotemStateChanged, OldState) == 0x000000, "Member 'K30P02_Authority_OnTotemStateChanged::OldState' has a wrong offset!");
static_assert(offsetof(K30P02_Authority_OnTotemStateChanged, NewState) == 0x000001, "Member 'K30P02_Authority_OnTotemStateChanged::NewState' has a wrong offset!");

// Function TheK30.K30P02.GetScreamInterval
// 0x0004 (0x0004 - 0x0000)
struct K30P02_GetScreamInterval final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K30P02_GetScreamInterval) == 0x000004, "Wrong alignment on K30P02_GetScreamInterval");
static_assert(sizeof(K30P02_GetScreamInterval) == 0x000004, "Wrong size on K30P02_GetScreamInterval");
static_assert(offsetof(K30P02_GetScreamInterval, ReturnValue) == 0x000000, "Member 'K30P02_GetScreamInterval::ReturnValue' has a wrong offset!");

// Function TheK30.K30P02ScreamStatusEffect.Multicast_MakePlayerScream
// 0x0004 (0x0004 - 0x0000)
struct K30P02ScreamStatusEffect_Multicast_MakePlayerScream final
{
public:
	float                                         ScreamRevealDuration;                              // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K30P02ScreamStatusEffect_Multicast_MakePlayerScream) == 0x000004, "Wrong alignment on K30P02ScreamStatusEffect_Multicast_MakePlayerScream");
static_assert(sizeof(K30P02ScreamStatusEffect_Multicast_MakePlayerScream) == 0x000004, "Wrong size on K30P02ScreamStatusEffect_Multicast_MakePlayerScream");
static_assert(offsetof(K30P02ScreamStatusEffect_Multicast_MakePlayerScream, ScreamRevealDuration) == 0x000000, "Member 'K30P02ScreamStatusEffect_Multicast_MakePlayerScream::ScreamRevealDuration' has a wrong offset!");

// Function TheK30.K30P02ScreamStatusEffect.GetTimerDuration
// 0x0004 (0x0004 - 0x0000)
struct K30P02ScreamStatusEffect_GetTimerDuration final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K30P02ScreamStatusEffect_GetTimerDuration) == 0x000004, "Wrong alignment on K30P02ScreamStatusEffect_GetTimerDuration");
static_assert(sizeof(K30P02ScreamStatusEffect_GetTimerDuration) == 0x000004, "Wrong size on K30P02ScreamStatusEffect_GetTimerDuration");
static_assert(offsetof(K30P02ScreamStatusEffect_GetTimerDuration, ReturnValue) == 0x000000, "Member 'K30P02ScreamStatusEffect_GetTimerDuration::ReturnValue' has a wrong offset!");

// Function TheK30.K30P02ScreamStatusEffect.GetTimerRemainingTime
// 0x0004 (0x0004 - 0x0000)
struct K30P02ScreamStatusEffect_GetTimerRemainingTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K30P02ScreamStatusEffect_GetTimerRemainingTime) == 0x000004, "Wrong alignment on K30P02ScreamStatusEffect_GetTimerRemainingTime");
static_assert(sizeof(K30P02ScreamStatusEffect_GetTimerRemainingTime) == 0x000004, "Wrong size on K30P02ScreamStatusEffect_GetTimerRemainingTime");
static_assert(offsetof(K30P02ScreamStatusEffect_GetTimerRemainingTime, ReturnValue) == 0x000000, "Member 'K30P02ScreamStatusEffect_GetTimerRemainingTime::ReturnValue' has a wrong offset!");

// Function TheK30.K30P02ScreamStatusEffect.IsTimerActive
// 0x0001 (0x0001 - 0x0000)
struct K30P02ScreamStatusEffect_IsTimerActive final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K30P02ScreamStatusEffect_IsTimerActive) == 0x000001, "Wrong alignment on K30P02ScreamStatusEffect_IsTimerActive");
static_assert(sizeof(K30P02ScreamStatusEffect_IsTimerActive) == 0x000001, "Wrong size on K30P02ScreamStatusEffect_IsTimerActive");
static_assert(offsetof(K30P02ScreamStatusEffect_IsTimerActive, ReturnValue) == 0x000000, "Member 'K30P02ScreamStatusEffect_IsTimerActive::ReturnValue' has a wrong offset!");

// Function TheK30.K30P02ScreamStatusEffect.IsTimerPaused
// 0x0001 (0x0001 - 0x0000)
struct K30P02ScreamStatusEffect_IsTimerPaused final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K30P02ScreamStatusEffect_IsTimerPaused) == 0x000001, "Wrong alignment on K30P02ScreamStatusEffect_IsTimerPaused");
static_assert(sizeof(K30P02ScreamStatusEffect_IsTimerPaused) == 0x000001, "Wrong size on K30P02ScreamStatusEffect_IsTimerPaused");
static_assert(offsetof(K30P02ScreamStatusEffect_IsTimerPaused, ReturnValue) == 0x000000, "Member 'K30P02ScreamStatusEffect_IsTimerPaused::ReturnValue' has a wrong offset!");

// Function TheK30.K30SurvivorCosmeticHelperActor.Cosmetic_OnHuntBegin
// 0x0008 (0x0008 - 0x0000)
struct K30SurvivorCosmeticHelperActor_Cosmetic_OnHuntBegin final
{
public:
	const class AKnightGuard*                     Guard;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K30SurvivorCosmeticHelperActor_Cosmetic_OnHuntBegin) == 0x000008, "Wrong alignment on K30SurvivorCosmeticHelperActor_Cosmetic_OnHuntBegin");
static_assert(sizeof(K30SurvivorCosmeticHelperActor_Cosmetic_OnHuntBegin) == 0x000008, "Wrong size on K30SurvivorCosmeticHelperActor_Cosmetic_OnHuntBegin");
static_assert(offsetof(K30SurvivorCosmeticHelperActor_Cosmetic_OnHuntBegin, Guard) == 0x000000, "Member 'K30SurvivorCosmeticHelperActor_Cosmetic_OnHuntBegin::Guard' has a wrong offset!");

// Function TheK30.K30SurvivorCosmeticHelperActor.Cosmetic_OnSurvivorCaptureFlagBuffActivationStateChanged
// 0x0001 (0x0001 - 0x0000)
struct K30SurvivorCosmeticHelperActor_Cosmetic_OnSurvivorCaptureFlagBuffActivationStateChanged final
{
public:
	bool                                          IsFlagCaptureBuffActive;                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K30SurvivorCosmeticHelperActor_Cosmetic_OnSurvivorCaptureFlagBuffActivationStateChanged) == 0x000001, "Wrong alignment on K30SurvivorCosmeticHelperActor_Cosmetic_OnSurvivorCaptureFlagBuffActivationStateChanged");
static_assert(sizeof(K30SurvivorCosmeticHelperActor_Cosmetic_OnSurvivorCaptureFlagBuffActivationStateChanged) == 0x000001, "Wrong size on K30SurvivorCosmeticHelperActor_Cosmetic_OnSurvivorCaptureFlagBuffActivationStateChanged");
static_assert(offsetof(K30SurvivorCosmeticHelperActor_Cosmetic_OnSurvivorCaptureFlagBuffActivationStateChanged, IsFlagCaptureBuffActive) == 0x000000, "Member 'K30SurvivorCosmeticHelperActor_Cosmetic_OnSurvivorCaptureFlagBuffActivationStateChanged::IsFlagCaptureBuffActive' has a wrong offset!");

// Function TheK30.K30Utilities.GetCurrentGuard
// 0x0010 (0x0010 - 0x0000)
struct K30Utilities_GetCurrentGuard final
{
public:
	const class AActor*                           TheK30;                                            // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AKnightGuard*                           ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K30Utilities_GetCurrentGuard) == 0x000008, "Wrong alignment on K30Utilities_GetCurrentGuard");
static_assert(sizeof(K30Utilities_GetCurrentGuard) == 0x000010, "Wrong size on K30Utilities_GetCurrentGuard");
static_assert(offsetof(K30Utilities_GetCurrentGuard, TheK30) == 0x000000, "Member 'K30Utilities_GetCurrentGuard::TheK30' has a wrong offset!");
static_assert(offsetof(K30Utilities_GetCurrentGuard, ReturnValue) == 0x000008, "Member 'K30Utilities_GetCurrentGuard::ReturnValue' has a wrong offset!");

// Function TheK30.K30Utilities.GetCurrentGuardIndex
// 0x0010 (0x0010 - 0x0000)
struct K30Utilities_GetCurrentGuardIndex final
{
public:
	const class AActor*                           TheK30;                                            // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(K30Utilities_GetCurrentGuardIndex) == 0x000008, "Wrong alignment on K30Utilities_GetCurrentGuardIndex");
static_assert(sizeof(K30Utilities_GetCurrentGuardIndex) == 0x000010, "Wrong size on K30Utilities_GetCurrentGuardIndex");
static_assert(offsetof(K30Utilities_GetCurrentGuardIndex, TheK30) == 0x000000, "Member 'K30Utilities_GetCurrentGuardIndex::TheK30' has a wrong offset!");
static_assert(offsetof(K30Utilities_GetCurrentGuardIndex, ReturnValue) == 0x000008, "Member 'K30Utilities_GetCurrentGuardIndex::ReturnValue' has a wrong offset!");

// Function TheK30.K30Utilities.GetK30Power
// 0x0010 (0x0010 - 0x0000)
struct K30Utilities_GetK30Power final
{
public:
	const class AActor*                           TheK30;                                            // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AK30Power*                              ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K30Utilities_GetK30Power) == 0x000008, "Wrong alignment on K30Utilities_GetK30Power");
static_assert(sizeof(K30Utilities_GetK30Power) == 0x000010, "Wrong size on K30Utilities_GetK30Power");
static_assert(offsetof(K30Utilities_GetK30Power, TheK30) == 0x000000, "Member 'K30Utilities_GetK30Power::TheK30' has a wrong offset!");
static_assert(offsetof(K30Utilities_GetK30Power, ReturnValue) == 0x000008, "Member 'K30Utilities_GetK30Power::ReturnValue' has a wrong offset!");

// Function TheK30.KnightGuard.Cosmetic_OnGuardVisionRadiusChanged
// 0x000C (0x000C - 0x0000)
struct KnightGuard_Cosmetic_OnGuardVisionRadiusChanged final
{
public:
	bool                                          IsVisible;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Radius;                                            // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Angle;                                             // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KnightGuard_Cosmetic_OnGuardVisionRadiusChanged) == 0x000004, "Wrong alignment on KnightGuard_Cosmetic_OnGuardVisionRadiusChanged");
static_assert(sizeof(KnightGuard_Cosmetic_OnGuardVisionRadiusChanged) == 0x00000C, "Wrong size on KnightGuard_Cosmetic_OnGuardVisionRadiusChanged");
static_assert(offsetof(KnightGuard_Cosmetic_OnGuardVisionRadiusChanged, IsVisible) == 0x000000, "Member 'KnightGuard_Cosmetic_OnGuardVisionRadiusChanged::IsVisible' has a wrong offset!");
static_assert(offsetof(KnightGuard_Cosmetic_OnGuardVisionRadiusChanged, Radius) == 0x000004, "Member 'KnightGuard_Cosmetic_OnGuardVisionRadiusChanged::Radius' has a wrong offset!");
static_assert(offsetof(KnightGuard_Cosmetic_OnGuardVisionRadiusChanged, Angle) == 0x000008, "Member 'KnightGuard_Cosmetic_OnGuardVisionRadiusChanged::Angle' has a wrong offset!");

// Function TheK30.KnightGuard.Cosmetic_OnHuntEnded
// 0x0001 (0x0001 - 0x0000)
struct KnightGuard_Cosmetic_OnHuntEnded final
{
public:
	EGuardHuntEndReason                           Reason;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KnightGuard_Cosmetic_OnHuntEnded) == 0x000001, "Wrong alignment on KnightGuard_Cosmetic_OnHuntEnded");
static_assert(sizeof(KnightGuard_Cosmetic_OnHuntEnded) == 0x000001, "Wrong size on KnightGuard_Cosmetic_OnHuntEnded");
static_assert(offsetof(KnightGuard_Cosmetic_OnHuntEnded, Reason) == 0x000000, "Member 'KnightGuard_Cosmetic_OnHuntEnded::Reason' has a wrong offset!");

// Function TheK30.KnightGuard.Cosmetic_OnHuntTeleportStarted
// 0x0004 (0x0004 - 0x0000)
struct KnightGuard_Cosmetic_OnHuntTeleportStarted final
{
public:
	float                                         Duration;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KnightGuard_Cosmetic_OnHuntTeleportStarted) == 0x000004, "Wrong alignment on KnightGuard_Cosmetic_OnHuntTeleportStarted");
static_assert(sizeof(KnightGuard_Cosmetic_OnHuntTeleportStarted) == 0x000004, "Wrong size on KnightGuard_Cosmetic_OnHuntTeleportStarted");
static_assert(offsetof(KnightGuard_Cosmetic_OnHuntTeleportStarted, Duration) == 0x000000, "Member 'KnightGuard_Cosmetic_OnHuntTeleportStarted::Duration' has a wrong offset!");

// Function TheK30.KnightGuard.Cosmetic_OnPatrolEnded
// 0x0008 (0x0008 - 0x0000)
struct KnightGuard_Cosmetic_OnPatrolEnded final
{
public:
	class ADBDPlayer*                             FoundSurvivor;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KnightGuard_Cosmetic_OnPatrolEnded) == 0x000008, "Wrong alignment on KnightGuard_Cosmetic_OnPatrolEnded");
static_assert(sizeof(KnightGuard_Cosmetic_OnPatrolEnded) == 0x000008, "Wrong size on KnightGuard_Cosmetic_OnPatrolEnded");
static_assert(offsetof(KnightGuard_Cosmetic_OnPatrolEnded, FoundSurvivor) == 0x000000, "Member 'KnightGuard_Cosmetic_OnPatrolEnded::FoundSurvivor' has a wrong offset!");

// Function TheK30.KnightGuard.Cosmetic_OnSurvivorDetected
// 0x0008 (0x0008 - 0x0000)
struct KnightGuard_Cosmetic_OnSurvivorDetected final
{
public:
	class ADBDPlayer*                             FoundSurvivor;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KnightGuard_Cosmetic_OnSurvivorDetected) == 0x000008, "Wrong alignment on KnightGuard_Cosmetic_OnSurvivorDetected");
static_assert(sizeof(KnightGuard_Cosmetic_OnSurvivorDetected) == 0x000008, "Wrong size on KnightGuard_Cosmetic_OnSurvivorDetected");
static_assert(offsetof(KnightGuard_Cosmetic_OnSurvivorDetected, FoundSurvivor) == 0x000000, "Member 'KnightGuard_Cosmetic_OnSurvivorDetected::FoundSurvivor' has a wrong offset!");

// Function TheK30.KnightGuard.Multicast_OnHuntEnded
// 0x0001 (0x0001 - 0x0000)
struct KnightGuard_Multicast_OnHuntEnded final
{
public:
	EGuardHuntEndReason                           Reason;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KnightGuard_Multicast_OnHuntEnded) == 0x000001, "Wrong alignment on KnightGuard_Multicast_OnHuntEnded");
static_assert(sizeof(KnightGuard_Multicast_OnHuntEnded) == 0x000001, "Wrong size on KnightGuard_Multicast_OnHuntEnded");
static_assert(offsetof(KnightGuard_Multicast_OnHuntEnded, Reason) == 0x000000, "Member 'KnightGuard_Multicast_OnHuntEnded::Reason' has a wrong offset!");

// Function TheK30.KnightGuard.Multicast_OnOrderEnded
// 0x0008 (0x0008 - 0x0000)
struct KnightGuard_Multicast_OnOrderEnded final
{
public:
	class AInteractable*                          Target;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KnightGuard_Multicast_OnOrderEnded) == 0x000008, "Wrong alignment on KnightGuard_Multicast_OnOrderEnded");
static_assert(sizeof(KnightGuard_Multicast_OnOrderEnded) == 0x000008, "Wrong size on KnightGuard_Multicast_OnOrderEnded");
static_assert(offsetof(KnightGuard_Multicast_OnOrderEnded, Target) == 0x000000, "Member 'KnightGuard_Multicast_OnOrderEnded::Target' has a wrong offset!");

// Function TheK30.KnightGuard.Multicast_OnPatrolEnded
// 0x0010 (0x0010 - 0x0000)
struct KnightGuard_Multicast_OnPatrolEnded final
{
public:
	class ADBDPlayer*                             FoundSurvivor;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CooldownOverride;                                  // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KnightGuard_Multicast_OnPatrolEnded) == 0x000008, "Wrong alignment on KnightGuard_Multicast_OnPatrolEnded");
static_assert(sizeof(KnightGuard_Multicast_OnPatrolEnded) == 0x000010, "Wrong size on KnightGuard_Multicast_OnPatrolEnded");
static_assert(offsetof(KnightGuard_Multicast_OnPatrolEnded, FoundSurvivor) == 0x000000, "Member 'KnightGuard_Multicast_OnPatrolEnded::FoundSurvivor' has a wrong offset!");
static_assert(offsetof(KnightGuard_Multicast_OnPatrolEnded, CooldownOverride) == 0x000008, "Member 'KnightGuard_Multicast_OnPatrolEnded::CooldownOverride' has a wrong offset!");

// Function TheK30.KnightGuard.Multicast_OnSurvivorDetected
// 0x0008 (0x0008 - 0x0000)
struct KnightGuard_Multicast_OnSurvivorDetected final
{
public:
	class ADBDPlayer*                             FoundSurvivor;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KnightGuard_Multicast_OnSurvivorDetected) == 0x000008, "Wrong alignment on KnightGuard_Multicast_OnSurvivorDetected");
static_assert(sizeof(KnightGuard_Multicast_OnSurvivorDetected) == 0x000008, "Wrong size on KnightGuard_Multicast_OnSurvivorDetected");
static_assert(offsetof(KnightGuard_Multicast_OnSurvivorDetected, FoundSurvivor) == 0x000000, "Member 'KnightGuard_Multicast_OnSurvivorDetected::FoundSurvivor' has a wrong offset!");

// Function TheK30.KnightGuard.OnRep_IsActive
// 0x0001 (0x0001 - 0x0000)
struct KnightGuard_OnRep_IsActive final
{
public:
	bool                                          PreviousIsActive;                                  // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KnightGuard_OnRep_IsActive) == 0x000001, "Wrong alignment on KnightGuard_OnRep_IsActive");
static_assert(sizeof(KnightGuard_OnRep_IsActive) == 0x000001, "Wrong size on KnightGuard_OnRep_IsActive");
static_assert(offsetof(KnightGuard_OnRep_IsActive, PreviousIsActive) == 0x000000, "Member 'KnightGuard_OnRep_IsActive::PreviousIsActive' has a wrong offset!");

// Function TheK30.KnightGuard.GetHuntAuraVisibilityMinDistanceToKiller
// 0x0004 (0x0004 - 0x0000)
struct KnightGuard_GetHuntAuraVisibilityMinDistanceToKiller final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KnightGuard_GetHuntAuraVisibilityMinDistanceToKiller) == 0x000004, "Wrong alignment on KnightGuard_GetHuntAuraVisibilityMinDistanceToKiller");
static_assert(sizeof(KnightGuard_GetHuntAuraVisibilityMinDistanceToKiller) == 0x000004, "Wrong size on KnightGuard_GetHuntAuraVisibilityMinDistanceToKiller");
static_assert(offsetof(KnightGuard_GetHuntAuraVisibilityMinDistanceToKiller, ReturnValue) == 0x000000, "Member 'KnightGuard_GetHuntAuraVisibilityMinDistanceToKiller::ReturnValue' has a wrong offset!");

// Function TheK30.KnightGuard.GetImmediateGeneratorRegressionPercent
// 0x0004 (0x0004 - 0x0000)
struct KnightGuard_GetImmediateGeneratorRegressionPercent final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KnightGuard_GetImmediateGeneratorRegressionPercent) == 0x000004, "Wrong alignment on KnightGuard_GetImmediateGeneratorRegressionPercent");
static_assert(sizeof(KnightGuard_GetImmediateGeneratorRegressionPercent) == 0x000004, "Wrong size on KnightGuard_GetImmediateGeneratorRegressionPercent");
static_assert(offsetof(KnightGuard_GetImmediateGeneratorRegressionPercent, ReturnValue) == 0x000000, "Member 'KnightGuard_GetImmediateGeneratorRegressionPercent::ReturnValue' has a wrong offset!");

// Function TheK30.KnightGuard.GetOrderDuration
// 0x0004 (0x0004 - 0x0000)
struct KnightGuard_GetOrderDuration final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KnightGuard_GetOrderDuration) == 0x000004, "Wrong alignment on KnightGuard_GetOrderDuration");
static_assert(sizeof(KnightGuard_GetOrderDuration) == 0x000004, "Wrong size on KnightGuard_GetOrderDuration");
static_assert(offsetof(KnightGuard_GetOrderDuration, ReturnValue) == 0x000000, "Member 'KnightGuard_GetOrderDuration::ReturnValue' has a wrong offset!");

// Function TheK30.KnightGuard.GetOwningKiller
// 0x0008 (0x0008 - 0x0000)
struct KnightGuard_GetOwningKiller final
{
public:
	class ASlasherPlayer*                         ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KnightGuard_GetOwningKiller) == 0x000008, "Wrong alignment on KnightGuard_GetOwningKiller");
static_assert(sizeof(KnightGuard_GetOwningKiller) == 0x000008, "Wrong size on KnightGuard_GetOwningKiller");
static_assert(offsetof(KnightGuard_GetOwningKiller, ReturnValue) == 0x000000, "Member 'KnightGuard_GetOwningKiller::ReturnValue' has a wrong offset!");

// Function TheK30.KnightGuard.GetPatrolComponent
// 0x0008 (0x0008 - 0x0000)
struct KnightGuard_GetPatrolComponent final
{
public:
	class UGuardPatrolComponent*                  ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KnightGuard_GetPatrolComponent) == 0x000008, "Wrong alignment on KnightGuard_GetPatrolComponent");
static_assert(sizeof(KnightGuard_GetPatrolComponent) == 0x000008, "Wrong size on KnightGuard_GetPatrolComponent");
static_assert(offsetof(KnightGuard_GetPatrolComponent, ReturnValue) == 0x000000, "Member 'KnightGuard_GetPatrolComponent::ReturnValue' has a wrong offset!");

// Function TheK30.KnightOrderComponent.Cosmetic_OnNewTargetSelected
// 0x0010 (0x0010 - 0x0000)
struct KnightOrderComponent_Cosmetic_OnNewTargetSelected final
{
public:
	class AInteractable*                          NewTarget;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AInteractable*                          OldTarget;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KnightOrderComponent_Cosmetic_OnNewTargetSelected) == 0x000008, "Wrong alignment on KnightOrderComponent_Cosmetic_OnNewTargetSelected");
static_assert(sizeof(KnightOrderComponent_Cosmetic_OnNewTargetSelected) == 0x000010, "Wrong size on KnightOrderComponent_Cosmetic_OnNewTargetSelected");
static_assert(offsetof(KnightOrderComponent_Cosmetic_OnNewTargetSelected, NewTarget) == 0x000000, "Member 'KnightOrderComponent_Cosmetic_OnNewTargetSelected::NewTarget' has a wrong offset!");
static_assert(offsetof(KnightOrderComponent_Cosmetic_OnNewTargetSelected, OldTarget) == 0x000008, "Member 'KnightOrderComponent_Cosmetic_OnNewTargetSelected::OldTarget' has a wrong offset!");

// Function TheK30.KnightOrderComponent.Cosmetic_OnTargetableObjectsChanged
// 0x0010 (0x0010 - 0x0000)
struct KnightOrderComponent_Cosmetic_OnTargetableObjectsChanged final
{
public:
	class AInteractable*                          Object;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsTargetable;                                      // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KnightOrderComponent_Cosmetic_OnTargetableObjectsChanged) == 0x000008, "Wrong alignment on KnightOrderComponent_Cosmetic_OnTargetableObjectsChanged");
static_assert(sizeof(KnightOrderComponent_Cosmetic_OnTargetableObjectsChanged) == 0x000010, "Wrong size on KnightOrderComponent_Cosmetic_OnTargetableObjectsChanged");
static_assert(offsetof(KnightOrderComponent_Cosmetic_OnTargetableObjectsChanged, Object) == 0x000000, "Member 'KnightOrderComponent_Cosmetic_OnTargetableObjectsChanged::Object' has a wrong offset!");
static_assert(offsetof(KnightOrderComponent_Cosmetic_OnTargetableObjectsChanged, IsTargetable) == 0x000008, "Member 'KnightOrderComponent_Cosmetic_OnTargetableObjectsChanged::IsTargetable' has a wrong offset!");

// Function TheK30.KnightOrderComponent.OnGameEventDispatched
// 0x0040 (0x0040 - 0x0000)
struct KnightOrderComponent_OnGameEventDispatched final
{
public:
	struct FGameplayTag                           GameEventType;                                     // 0x0000(0x000C)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameEventData                         GameEventData;                                     // 0x0010(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(KnightOrderComponent_OnGameEventDispatched) == 0x000008, "Wrong alignment on KnightOrderComponent_OnGameEventDispatched");
static_assert(sizeof(KnightOrderComponent_OnGameEventDispatched) == 0x000040, "Wrong size on KnightOrderComponent_OnGameEventDispatched");
static_assert(offsetof(KnightOrderComponent_OnGameEventDispatched, GameEventType) == 0x000000, "Member 'KnightOrderComponent_OnGameEventDispatched::GameEventType' has a wrong offset!");
static_assert(offsetof(KnightOrderComponent_OnGameEventDispatched, GameEventData) == 0x000010, "Member 'KnightOrderComponent_OnGameEventDispatched::GameEventData' has a wrong offset!");

// Function TheK30.KnightOrderComponent.GetTargetingRange
// 0x0004 (0x0004 - 0x0000)
struct KnightOrderComponent_GetTargetingRange final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KnightOrderComponent_GetTargetingRange) == 0x000004, "Wrong alignment on KnightOrderComponent_GetTargetingRange");
static_assert(sizeof(KnightOrderComponent_GetTargetingRange) == 0x000004, "Wrong size on KnightOrderComponent_GetTargetingRange");
static_assert(offsetof(KnightOrderComponent_GetTargetingRange, ReturnValue) == 0x000000, "Member 'KnightOrderComponent_GetTargetingRange::ReturnValue' has a wrong offset!");

// Function TheK30.PatrolTrailComponent.DoesTrailExist
// 0x0001 (0x0001 - 0x0000)
struct PatrolTrailComponent_DoesTrailExist final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PatrolTrailComponent_DoesTrailExist) == 0x000001, "Wrong alignment on PatrolTrailComponent_DoesTrailExist");
static_assert(sizeof(PatrolTrailComponent_DoesTrailExist) == 0x000001, "Wrong size on PatrolTrailComponent_DoesTrailExist");
static_assert(offsetof(PatrolTrailComponent_DoesTrailExist, ReturnValue) == 0x000000, "Member 'PatrolTrailComponent_DoesTrailExist::ReturnValue' has a wrong offset!");

// Function TheK30.PatrolTrailComponent.GetCurrentTrailLength
// 0x0004 (0x0004 - 0x0000)
struct PatrolTrailComponent_GetCurrentTrailLength final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PatrolTrailComponent_GetCurrentTrailLength) == 0x000004, "Wrong alignment on PatrolTrailComponent_GetCurrentTrailLength");
static_assert(sizeof(PatrolTrailComponent_GetCurrentTrailLength) == 0x000004, "Wrong size on PatrolTrailComponent_GetCurrentTrailLength");
static_assert(offsetof(PatrolTrailComponent_GetCurrentTrailLength, ReturnValue) == 0x000000, "Member 'PatrolTrailComponent_GetCurrentTrailLength::ReturnValue' has a wrong offset!");

// Function TheK30.PatrolTrailComponent.GetFirstNode
// 0x0008 (0x0008 - 0x0000)
struct PatrolTrailComponent_GetFirstNode final
{
public:
	class ATrailNode*                             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PatrolTrailComponent_GetFirstNode) == 0x000008, "Wrong alignment on PatrolTrailComponent_GetFirstNode");
static_assert(sizeof(PatrolTrailComponent_GetFirstNode) == 0x000008, "Wrong size on PatrolTrailComponent_GetFirstNode");
static_assert(offsetof(PatrolTrailComponent_GetFirstNode, ReturnValue) == 0x000000, "Member 'PatrolTrailComponent_GetFirstNode::ReturnValue' has a wrong offset!");

// Function TheK30.PatrolTrailComponent.GetLastNode
// 0x0008 (0x0008 - 0x0000)
struct PatrolTrailComponent_GetLastNode final
{
public:
	class ATrailNode*                             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PatrolTrailComponent_GetLastNode) == 0x000008, "Wrong alignment on PatrolTrailComponent_GetLastNode");
static_assert(sizeof(PatrolTrailComponent_GetLastNode) == 0x000008, "Wrong size on PatrolTrailComponent_GetLastNode");
static_assert(offsetof(PatrolTrailComponent_GetLastNode, ReturnValue) == 0x000000, "Member 'PatrolTrailComponent_GetLastNode::ReturnValue' has a wrong offset!");

}

