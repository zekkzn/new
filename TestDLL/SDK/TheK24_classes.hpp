#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: TheK24

#include "Basic.hpp"

#include "DataTableUtilities_structs.hpp"
#include "TheK24_structs.hpp"
#include "GameplayTags_structs.hpp"
#include "AIModule_classes.hpp"
#include "DeadByDaylight_structs.hpp"
#include "DeadByDaylight_classes.hpp"
#include "DBDGameplay_classes.hpp"
#include "DBDCompetence_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "DBDBots_classes.hpp"
#include "DBDSharedTypes_structs.hpp"
#include "DBDAnimation_classes.hpp"
#include "StatSystem_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "DBDAttack_classes.hpp"
#include "GameplayTagUtilities_structs.hpp"


namespace SDK
{

// Class TheK24.ZombieBlindingFXComponent
// 0x0000 (0x0140 - 0x0140)
class UZombieBlindingFXComponent final : public UKillerBlindingFXComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ZombieBlindingFXComponent">();
	}
	static class UZombieBlindingFXComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UZombieBlindingFXComponent>();
	}
};
static_assert(alignof(UZombieBlindingFXComponent) == 0x000008, "Wrong alignment on UZombieBlindingFXComponent");
static_assert(sizeof(UZombieBlindingFXComponent) == 0x000140, "Wrong size on UZombieBlindingFXComponent");

// Class TheK24.ActivateK24PowerInteraction
// 0x0090 (0x0950 - 0x08C0)
class UActivateK24PowerInteraction final : public UChargeableInteractionDefinition
{
public:
	uint8                                         Pad_8C0[0x10];                                     // 0x08C0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _interactionViewPitchMax;                          // 0x08D0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _interactionViewPitchMin;                          // 0x08F8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _maximumTimeToTriggerRegularAttack;                // 0x0920(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_948[0x8];                                      // 0x0948(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetK24Power(class AK24Power* K24Power);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActivateK24PowerInteraction">();
	}
	static class UActivateK24PowerInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActivateK24PowerInteraction>();
	}
};
static_assert(alignof(UActivateK24PowerInteraction) == 0x000010, "Wrong alignment on UActivateK24PowerInteraction");
static_assert(sizeof(UActivateK24PowerInteraction) == 0x000950, "Wrong size on UActivateK24PowerInteraction");
static_assert(offsetof(UActivateK24PowerInteraction, _interactionViewPitchMax) == 0x0008D0, "Member 'UActivateK24PowerInteraction::_interactionViewPitchMax' has a wrong offset!");
static_assert(offsetof(UActivateK24PowerInteraction, _interactionViewPitchMin) == 0x0008F8, "Member 'UActivateK24PowerInteraction::_interactionViewPitchMin' has a wrong offset!");
static_assert(offsetof(UActivateK24PowerInteraction, _maximumTimeToTriggerRegularAttack) == 0x000920, "Member 'UActivateK24PowerInteraction::_maximumTimeToTriggerRegularAttack' has a wrong offset!");

// Class TheK24.ZombieCharacter
// 0x0390 (0x09E0 - 0x0650)
class AZombieCharacter final : public ACharacter
{
public:
	uint8                                         Pad_650[0x40];                                     // 0x0650(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTunableStat                           _zombieWalkSpeed;                                  // 0x0690(0x0080)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_710[0x8];                                      // 0x0710(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAuthoritativePoolableActorComponent*   _poolableComponent;                                // 0x0718(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USphereComponent*                       _zombieAttackDetector;                             // 0x0720(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticMeshComponent*                   _attackDamageZone;                                 // 0x0728(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EZombieState                                  _zombieState;                                      // 0x0730(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_731[0x3F];                                     // 0x0731(0x003F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTunableStat                           _zombieRespawnTimeKilledBySlasher;                 // 0x0770(0x0080)(Edit, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _zombieRespawnTimeKilledBySurvivor;                // 0x07F0(0x0080)(Edit, NativeAccessSpecifierPrivate)
	struct FTransform                             _respawnPositionBehindGate;                        // 0x0870(0x0060)(Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EZombieGender                                 _zombieGender;                                     // 0x08D0(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8D1[0x7];                                      // 0x08D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ASlasherPlayer*                         _owningKiller;                                     // 0x08D8(0x0008)(Net, ZeroConstructor, Transient, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USkeletalMesh*                          _femaleSkeletalMesh;                               // 0x08E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 _audioSwitchState;                                 // 0x08E8(0x0010)(Edit, Net, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UZombieBlindableComponent*              _blindableComponent;                               // 0x08F8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UChargeableComponent*                   _blindingChargeableComponent;                      // 0x0900(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URangedExplosiveEffectHandlerComponent* _rangedExplosiveEffectHandlerComponent;            // 0x0908(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFlashlightableComponent*               _flashLightableComponent;                          // 0x0910(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_918[0x50];                                     // 0x0918(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _zombieStunBaseTime;                               // 0x0968(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class UGameplayTagContainerComponent*         _objectState;                                      // 0x0990(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_998[0x8];                                      // 0x0998(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UCharacterPositionRecorderComponent*    _positionRecorder;                                 // 0x09A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAuthoritativeMovementComponent*        _authoritativeMovementComponent;                   // 0x09A8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOtherCharactersVerticalCollisionsHandler* _otherCharactersVerticalCollisionsHandler;         // 0x09B0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class AActor*>                         _ignoreActors;                                     // 0x09B8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_9C8[0x4];                                      // 0x09C8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _zombieStunnedCapsuleRadius;                       // 0x09CC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _minFallHeight;                                    // 0x09D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_9D4[0x8];                                      // 0x09D4(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _afterInAirAttackCooldown;                         // 0x09DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Authority_DeactivateZombieAndStartRespawnTimer();
	void Authority_OnFlashlightAdded(const class UFlashlightComponent* Flashlight);
	void Authority_OnFlashlightRemoved(const class UFlashlightComponent* Flashlight);
	void Authority_OnRangedExplosiveInRangeBegin(const struct FRangedExplosiveEffectData& EffectData);
	void Authority_OnZombieStateChanged(EZombieState ZombieState);
	void Multicast_ZombieKilledByKillerCosmetic(EAttackType AttackType);
	void OnBeginOverlapZombieAttackDetector(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnEndOverlapZombieAttackDetector(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void OnFemaleGenderSet_Cosmetic();
	void OnRep_OwningKiller();
	void OnRep_ZombieGender();
	void OnRep_ZombieState(EZombieState PreviousState);
	void OnZombieStateChanged_Cosmetic(EZombieState ZombieState);
	void SetCharacterActive_Cosmetic(const bool Value);
	void ZombieKilledByKiller_Cosmetic(EAttackType AttackType);

	class FString GetAudioSwitchState() const;
	class UAuthoritativeMovementComponent* GetAuthoritativeMovementComponent() const;
	class UOtherCharactersVerticalCollisionsHandler* GetOtherCharactersVerticalCollisionsHandler() const;
	EZombieGender GetZombieGender() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ZombieCharacter">();
	}
	static class AZombieCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AZombieCharacter>();
	}
};
static_assert(alignof(AZombieCharacter) == 0x000010, "Wrong alignment on AZombieCharacter");
static_assert(sizeof(AZombieCharacter) == 0x0009E0, "Wrong size on AZombieCharacter");
static_assert(offsetof(AZombieCharacter, _zombieWalkSpeed) == 0x000690, "Member 'AZombieCharacter::_zombieWalkSpeed' has a wrong offset!");
static_assert(offsetof(AZombieCharacter, _poolableComponent) == 0x000718, "Member 'AZombieCharacter::_poolableComponent' has a wrong offset!");
static_assert(offsetof(AZombieCharacter, _zombieAttackDetector) == 0x000720, "Member 'AZombieCharacter::_zombieAttackDetector' has a wrong offset!");
static_assert(offsetof(AZombieCharacter, _attackDamageZone) == 0x000728, "Member 'AZombieCharacter::_attackDamageZone' has a wrong offset!");
static_assert(offsetof(AZombieCharacter, _zombieState) == 0x000730, "Member 'AZombieCharacter::_zombieState' has a wrong offset!");
static_assert(offsetof(AZombieCharacter, _zombieRespawnTimeKilledBySlasher) == 0x000770, "Member 'AZombieCharacter::_zombieRespawnTimeKilledBySlasher' has a wrong offset!");
static_assert(offsetof(AZombieCharacter, _zombieRespawnTimeKilledBySurvivor) == 0x0007F0, "Member 'AZombieCharacter::_zombieRespawnTimeKilledBySurvivor' has a wrong offset!");
static_assert(offsetof(AZombieCharacter, _respawnPositionBehindGate) == 0x000870, "Member 'AZombieCharacter::_respawnPositionBehindGate' has a wrong offset!");
static_assert(offsetof(AZombieCharacter, _zombieGender) == 0x0008D0, "Member 'AZombieCharacter::_zombieGender' has a wrong offset!");
static_assert(offsetof(AZombieCharacter, _owningKiller) == 0x0008D8, "Member 'AZombieCharacter::_owningKiller' has a wrong offset!");
static_assert(offsetof(AZombieCharacter, _femaleSkeletalMesh) == 0x0008E0, "Member 'AZombieCharacter::_femaleSkeletalMesh' has a wrong offset!");
static_assert(offsetof(AZombieCharacter, _audioSwitchState) == 0x0008E8, "Member 'AZombieCharacter::_audioSwitchState' has a wrong offset!");
static_assert(offsetof(AZombieCharacter, _blindableComponent) == 0x0008F8, "Member 'AZombieCharacter::_blindableComponent' has a wrong offset!");
static_assert(offsetof(AZombieCharacter, _blindingChargeableComponent) == 0x000900, "Member 'AZombieCharacter::_blindingChargeableComponent' has a wrong offset!");
static_assert(offsetof(AZombieCharacter, _rangedExplosiveEffectHandlerComponent) == 0x000908, "Member 'AZombieCharacter::_rangedExplosiveEffectHandlerComponent' has a wrong offset!");
static_assert(offsetof(AZombieCharacter, _flashLightableComponent) == 0x000910, "Member 'AZombieCharacter::_flashLightableComponent' has a wrong offset!");
static_assert(offsetof(AZombieCharacter, _zombieStunBaseTime) == 0x000968, "Member 'AZombieCharacter::_zombieStunBaseTime' has a wrong offset!");
static_assert(offsetof(AZombieCharacter, _objectState) == 0x000990, "Member 'AZombieCharacter::_objectState' has a wrong offset!");
static_assert(offsetof(AZombieCharacter, _positionRecorder) == 0x0009A0, "Member 'AZombieCharacter::_positionRecorder' has a wrong offset!");
static_assert(offsetof(AZombieCharacter, _authoritativeMovementComponent) == 0x0009A8, "Member 'AZombieCharacter::_authoritativeMovementComponent' has a wrong offset!");
static_assert(offsetof(AZombieCharacter, _otherCharactersVerticalCollisionsHandler) == 0x0009B0, "Member 'AZombieCharacter::_otherCharactersVerticalCollisionsHandler' has a wrong offset!");
static_assert(offsetof(AZombieCharacter, _ignoreActors) == 0x0009B8, "Member 'AZombieCharacter::_ignoreActors' has a wrong offset!");
static_assert(offsetof(AZombieCharacter, _zombieStunnedCapsuleRadius) == 0x0009CC, "Member 'AZombieCharacter::_zombieStunnedCapsuleRadius' has a wrong offset!");
static_assert(offsetof(AZombieCharacter, _minFallHeight) == 0x0009D0, "Member 'AZombieCharacter::_minFallHeight' has a wrong offset!");
static_assert(offsetof(AZombieCharacter, _afterInAirAttackCooldown) == 0x0009DC, "Member 'AZombieCharacter::_afterInAirAttackCooldown' has a wrong offset!");

// Class TheK24.Addon_K24_04
// 0x0018 (0x0310 - 0x02F8)
class UAddon_K24_04 final : public UOnEventBaseAddon
{
public:
	float                                         _effectTime;                                       // 0x02F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           OutlineColor;                                      // 0x02FC(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_30C[0x4];                                      // 0x030C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Addon_K24_04">();
	}
	static class UAddon_K24_04* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAddon_K24_04>();
	}
};
static_assert(alignof(UAddon_K24_04) == 0x000008, "Wrong alignment on UAddon_K24_04");
static_assert(sizeof(UAddon_K24_04) == 0x000310, "Wrong size on UAddon_K24_04");
static_assert(offsetof(UAddon_K24_04, _effectTime) == 0x0002F8, "Member 'UAddon_K24_04::_effectTime' has a wrong offset!");
static_assert(offsetof(UAddon_K24_04, OutlineColor) == 0x0002FC, "Member 'UAddon_K24_04::OutlineColor' has a wrong offset!");

// Class TheK24.ZombieChaseStateBTService
// 0x0000 (0x00A0 - 0x00A0)
class UZombieChaseStateBTService final : public UBTService_BlueprintBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ZombieChaseStateBTService">();
	}
	static class UZombieChaseStateBTService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UZombieChaseStateBTService>();
	}
};
static_assert(alignof(UZombieChaseStateBTService) == 0x000008, "Wrong alignment on UZombieChaseStateBTService");
static_assert(sizeof(UZombieChaseStateBTService) == 0x0000A0, "Wrong size on UZombieChaseStateBTService");

// Class TheK24.Addon_K24_18
// 0x0008 (0x0318 - 0x0310)
class UAddon_K24_18 final : public UImposeStatusEffectOnEventAddon
{
public:
	TSubclassOf<class AZombieEscapeDoorPointsActor> _zombieEscapeDoorPointsActor;                      // 0x0310(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Addon_K24_18">();
	}
	static class UAddon_K24_18* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAddon_K24_18>();
	}
};
static_assert(alignof(UAddon_K24_18) == 0x000008, "Wrong alignment on UAddon_K24_18");
static_assert(sizeof(UAddon_K24_18) == 0x000318, "Wrong size on UAddon_K24_18");
static_assert(offsetof(UAddon_K24_18, _zombieEscapeDoorPointsActor) == 0x000310, "Member 'UAddon_K24_18::_zombieEscapeDoorPointsActor' has a wrong offset!");

// Class TheK24.ZombiesManagement
// 0x00C8 (0x0368 - 0x02A0)
class AZombiesManagement final : public AActor
{
public:
	uint8                                         Pad_2A0[0x10];                                     // 0x02A0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UAuthoritativeActorPoolComponent*       _zombiePool;                                       // 0x02B0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UZombiesPatrolAreaManager*              _zombiesPatrolAreaManager;                         // 0x02B8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class AZombieCharacter*>               _spawnedZombiesArray;                              // 0x02C0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D0[0x38];                                     // 0x02D0(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _firstZombieSpawnTime;                             // 0x0308(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _numberOfZombieToSpawnAtStart;                     // 0x0330(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TArray<class AZombieEscapeDoorPointsActor*>   _zombieEscapeDoorPoints;                           // 0x0358(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	void Authority_OnIntroComplete();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ZombiesManagement">();
	}
	static class AZombiesManagement* GetDefaultObj()
	{
		return GetDefaultObjImpl<AZombiesManagement>();
	}
};
static_assert(alignof(AZombiesManagement) == 0x000008, "Wrong alignment on AZombiesManagement");
static_assert(sizeof(AZombiesManagement) == 0x000368, "Wrong size on AZombiesManagement");
static_assert(offsetof(AZombiesManagement, _zombiePool) == 0x0002B0, "Member 'AZombiesManagement::_zombiePool' has a wrong offset!");
static_assert(offsetof(AZombiesManagement, _zombiesPatrolAreaManager) == 0x0002B8, "Member 'AZombiesManagement::_zombiesPatrolAreaManager' has a wrong offset!");
static_assert(offsetof(AZombiesManagement, _spawnedZombiesArray) == 0x0002C0, "Member 'AZombiesManagement::_spawnedZombiesArray' has a wrong offset!");
static_assert(offsetof(AZombiesManagement, _firstZombieSpawnTime) == 0x000308, "Member 'AZombiesManagement::_firstZombieSpawnTime' has a wrong offset!");
static_assert(offsetof(AZombiesManagement, _numberOfZombieToSpawnAtStart) == 0x000330, "Member 'AZombiesManagement::_numberOfZombieToSpawnAtStart' has a wrong offset!");
static_assert(offsetof(AZombiesManagement, _zombieEscapeDoorPoints) == 0x000358, "Member 'AZombiesManagement::_zombieEscapeDoorPoints' has a wrong offset!");

// Class TheK24.BTTask_MoveToAbortIfStuck
// 0x0028 (0x00E8 - 0x00C0)
class UBTTask_MoveToAbortIfStuck final : public UBTTask_MoveTo
{
public:
	uint8                                         Pad_C0[0x4];                                       // 0x00C0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _deltaConsideredStuck;                             // 0x00C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C8[0x18];                                      // 0x00C8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _maxTimeStuck;                                     // 0x00E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E4[0x4];                                       // 0x00E4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_MoveToAbortIfStuck">();
	}
	static class UBTTask_MoveToAbortIfStuck* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_MoveToAbortIfStuck>();
	}
};
static_assert(alignof(UBTTask_MoveToAbortIfStuck) == 0x000008, "Wrong alignment on UBTTask_MoveToAbortIfStuck");
static_assert(sizeof(UBTTask_MoveToAbortIfStuck) == 0x0000E8, "Wrong size on UBTTask_MoveToAbortIfStuck");
static_assert(offsetof(UBTTask_MoveToAbortIfStuck, _deltaConsideredStuck) == 0x0000C4, "Member 'UBTTask_MoveToAbortIfStuck::_deltaConsideredStuck' has a wrong offset!");
static_assert(offsetof(UBTTask_MoveToAbortIfStuck, _maxTimeStuck) == 0x0000E0, "Member 'UBTTask_MoveToAbortIfStuck::_maxTimeStuck' has a wrong offset!");

// Class TheK24.ZombieEscapeDoorPointsActor
// 0x0010 (0x02B0 - 0x02A0)
class AZombieEscapeDoorPointsActor final : public AActor
{
public:
	TArray<class UArrowComponent*>                _availablePoints;                                  // 0x02A0(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ZombieEscapeDoorPointsActor">();
	}
	static class AZombieEscapeDoorPointsActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AZombieEscapeDoorPointsActor>();
	}
};
static_assert(alignof(AZombieEscapeDoorPointsActor) == 0x000008, "Wrong alignment on AZombieEscapeDoorPointsActor");
static_assert(sizeof(AZombieEscapeDoorPointsActor) == 0x0002B0, "Wrong size on AZombieEscapeDoorPointsActor");
static_assert(offsetof(AZombieEscapeDoorPointsActor, _availablePoints) == 0x0002A0, "Member 'AZombieEscapeDoorPointsActor::_availablePoints' has a wrong offset!");

// Class TheK24.AISkill_FindCollectable_SupplyCrate
// 0x00C0 (0x0450 - 0x0390)
class UAISkill_FindCollectable_SupplyCrate final : public UAISkill_FindCollectable_Searchable
{
public:
	struct FAITunableParameter                    UrgencyGoalWeight;                                 // 0x0390(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    OpenedWeightMultiplier;                            // 0x03F0(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_FindCollectable_SupplyCrate">();
	}
	static class UAISkill_FindCollectable_SupplyCrate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_FindCollectable_SupplyCrate>();
	}
};
static_assert(alignof(UAISkill_FindCollectable_SupplyCrate) == 0x000008, "Wrong alignment on UAISkill_FindCollectable_SupplyCrate");
static_assert(sizeof(UAISkill_FindCollectable_SupplyCrate) == 0x000450, "Wrong size on UAISkill_FindCollectable_SupplyCrate");
static_assert(offsetof(UAISkill_FindCollectable_SupplyCrate, UrgencyGoalWeight) == 0x000390, "Member 'UAISkill_FindCollectable_SupplyCrate::UrgencyGoalWeight' has a wrong offset!");
static_assert(offsetof(UAISkill_FindCollectable_SupplyCrate, OpenedWeightMultiplier) == 0x0003F0, "Member 'UAISkill_FindCollectable_SupplyCrate::OpenedWeightMultiplier' has a wrong offset!");

// Class TheK24.ZombieEvaluateEnterChaseBTService
// 0x0000 (0x00A0 - 0x00A0)
class UZombieEvaluateEnterChaseBTService final : public UBTService_BlueprintBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ZombieEvaluateEnterChaseBTService">();
	}
	static class UZombieEvaluateEnterChaseBTService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UZombieEvaluateEnterChaseBTService>();
	}
};
static_assert(alignof(UZombieEvaluateEnterChaseBTService) == 0x000008, "Wrong alignment on UZombieEvaluateEnterChaseBTService");
static_assert(sizeof(UZombieEvaluateEnterChaseBTService) == 0x0000A0, "Wrong size on UZombieEvaluateEnterChaseBTService");

// Class TheK24.AISkill_InteractionUseItem_Serum
// 0x0000 (0x0290 - 0x0290)
class UAISkill_InteractionUseItem_Serum final : public UAISkill_InteractionUseItem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_InteractionUseItem_Serum">();
	}
	static class UAISkill_InteractionUseItem_Serum* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_InteractionUseItem_Serum>();
	}
};
static_assert(alignof(UAISkill_InteractionUseItem_Serum) == 0x000008, "Wrong alignment on UAISkill_InteractionUseItem_Serum");
static_assert(sizeof(UAISkill_InteractionUseItem_Serum) == 0x000290, "Wrong size on UAISkill_InteractionUseItem_Serum");

// Class TheK24.ZombieStunnableComponent
// 0x0008 (0x00B0 - 0x00A8)
class UZombieStunnableComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ZombieStunnableComponent">();
	}
	static class UZombieStunnableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UZombieStunnableComponent>();
	}
};
static_assert(alignof(UZombieStunnableComponent) == 0x000008, "Wrong alignment on UZombieStunnableComponent");
static_assert(sizeof(UZombieStunnableComponent) == 0x0000B0, "Wrong size on UZombieStunnableComponent");

// Class TheK24.ChangeZombieStateBTTask
// 0x0008 (0x00B8 - 0x00B0)
class UChangeZombieStateBTTask final : public UBTTask_BlueprintBase
{
public:
	EZombieState                                  _zombieState;                                      // 0x00B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B1[0x7];                                       // 0x00B1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChangeZombieStateBTTask">();
	}
	static class UChangeZombieStateBTTask* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChangeZombieStateBTTask>();
	}
};
static_assert(alignof(UChangeZombieStateBTTask) == 0x000008, "Wrong alignment on UChangeZombieStateBTTask");
static_assert(sizeof(UChangeZombieStateBTTask) == 0x0000B8, "Wrong size on UChangeZombieStateBTTask");
static_assert(offsetof(UChangeZombieStateBTTask, _zombieState) == 0x0000B0, "Member 'UChangeZombieStateBTTask::_zombieState' has a wrong offset!");

// Class TheK24.ZombieEvaluteEnterAttackBTService
// 0x0000 (0x00A0 - 0x00A0)
class UZombieEvaluteEnterAttackBTService final : public UBTService_BlueprintBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ZombieEvaluteEnterAttackBTService">();
	}
	static class UZombieEvaluteEnterAttackBTService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UZombieEvaluteEnterAttackBTService>();
	}
};
static_assert(alignof(UZombieEvaluteEnterAttackBTService) == 0x000008, "Wrong alignment on UZombieEvaluteEnterAttackBTService");
static_assert(sizeof(UZombieEvaluteEnterAttackBTService) == 0x0000A0, "Wrong size on UZombieEvaluteEnterAttackBTService");

// Class TheK24.BlindZombieFlashlightableLightingStrategy
// 0x0000 (0x0040 - 0x0040)
class UBlindZombieFlashlightableLightingStrategy final : public UFlashlightablePointsLightingStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlindZombieFlashlightableLightingStrategy">();
	}
	static class UBlindZombieFlashlightableLightingStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlindZombieFlashlightableLightingStrategy>();
	}
};
static_assert(alignof(UBlindZombieFlashlightableLightingStrategy) == 0x000008, "Wrong alignment on UBlindZombieFlashlightableLightingStrategy");
static_assert(sizeof(UBlindZombieFlashlightableLightingStrategy) == 0x000040, "Wrong size on UBlindZombieFlashlightableLightingStrategy");

// Class TheK24.ContaminationSerumCollectable
// 0x0010 (0x05A8 - 0x0598)
class AContaminationSerumCollectable final : public ABaseCamperCollectable
{
public:
	uint8                                         Pad_598[0x10];                                     // 0x0598(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ContaminationSerumCollectable">();
	}
	static class AContaminationSerumCollectable* GetDefaultObj()
	{
		return GetDefaultObjImpl<AContaminationSerumCollectable>();
	}
};
static_assert(alignof(AContaminationSerumCollectable) == 0x000008, "Wrong alignment on AContaminationSerumCollectable");
static_assert(sizeof(AContaminationSerumCollectable) == 0x0005A8, "Wrong size on AContaminationSerumCollectable");

// Class TheK24.ContaminationSubAnimInstance
// 0x0080 (0x0660 - 0x05E0)
class UContaminationSubAnimInstance final : public UBaseSurvivorAnimInstance
{
public:
	uint8                                         Pad_5E0[0x8];                                      // 0x05E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _isContaminated;                                   // 0x05E8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isInjectingSerumSelf;                             // 0x05E9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isInjectingSerumOther;                            // 0x05EA(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isBeingInjectedWithSerum;                         // 0x05EB(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isBeingHealed;                                    // 0x05EC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isFirstContaminationHit;                          // 0x05ED(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _triggerCough;                                     // 0x05EE(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5EF[0x1];                                      // 0x05EF(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _timeBetweenCough;                                 // 0x05F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isIdle;                                           // 0x05F4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isCrouched;                                       // 0x05F5(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isInsideCloset;                                   // 0x05F6(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isInteracting;                                    // 0x05F7(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isHoldingAimItem;                                 // 0x05F8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isCrawling;                                       // 0x05F9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isHooked;                                         // 0x05FA(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isDead;                                           // 0x05FB(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isFrightScreaming;                                // 0x05FC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isHoldingSmallItem;                               // 0x05FD(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isUsingAimItem;                                   // 0x05FE(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isHoldingHandleItem;                              // 0x05FF(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isInjured;                                        // 0x0600(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isCarried;                                        // 0x0601(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EInteractionAnimation                         _interactionType;                                  // 0x0602(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_603[0x5D];                                     // 0x0603(0x005D)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ContaminationSubAnimInstance">();
	}
	static class UContaminationSubAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UContaminationSubAnimInstance>();
	}
};
static_assert(alignof(UContaminationSubAnimInstance) == 0x000010, "Wrong alignment on UContaminationSubAnimInstance");
static_assert(sizeof(UContaminationSubAnimInstance) == 0x000660, "Wrong size on UContaminationSubAnimInstance");
static_assert(offsetof(UContaminationSubAnimInstance, _isContaminated) == 0x0005E8, "Member 'UContaminationSubAnimInstance::_isContaminated' has a wrong offset!");
static_assert(offsetof(UContaminationSubAnimInstance, _isInjectingSerumSelf) == 0x0005E9, "Member 'UContaminationSubAnimInstance::_isInjectingSerumSelf' has a wrong offset!");
static_assert(offsetof(UContaminationSubAnimInstance, _isInjectingSerumOther) == 0x0005EA, "Member 'UContaminationSubAnimInstance::_isInjectingSerumOther' has a wrong offset!");
static_assert(offsetof(UContaminationSubAnimInstance, _isBeingInjectedWithSerum) == 0x0005EB, "Member 'UContaminationSubAnimInstance::_isBeingInjectedWithSerum' has a wrong offset!");
static_assert(offsetof(UContaminationSubAnimInstance, _isBeingHealed) == 0x0005EC, "Member 'UContaminationSubAnimInstance::_isBeingHealed' has a wrong offset!");
static_assert(offsetof(UContaminationSubAnimInstance, _isFirstContaminationHit) == 0x0005ED, "Member 'UContaminationSubAnimInstance::_isFirstContaminationHit' has a wrong offset!");
static_assert(offsetof(UContaminationSubAnimInstance, _triggerCough) == 0x0005EE, "Member 'UContaminationSubAnimInstance::_triggerCough' has a wrong offset!");
static_assert(offsetof(UContaminationSubAnimInstance, _timeBetweenCough) == 0x0005F0, "Member 'UContaminationSubAnimInstance::_timeBetweenCough' has a wrong offset!");
static_assert(offsetof(UContaminationSubAnimInstance, _isIdle) == 0x0005F4, "Member 'UContaminationSubAnimInstance::_isIdle' has a wrong offset!");
static_assert(offsetof(UContaminationSubAnimInstance, _isCrouched) == 0x0005F5, "Member 'UContaminationSubAnimInstance::_isCrouched' has a wrong offset!");
static_assert(offsetof(UContaminationSubAnimInstance, _isInsideCloset) == 0x0005F6, "Member 'UContaminationSubAnimInstance::_isInsideCloset' has a wrong offset!");
static_assert(offsetof(UContaminationSubAnimInstance, _isInteracting) == 0x0005F7, "Member 'UContaminationSubAnimInstance::_isInteracting' has a wrong offset!");
static_assert(offsetof(UContaminationSubAnimInstance, _isHoldingAimItem) == 0x0005F8, "Member 'UContaminationSubAnimInstance::_isHoldingAimItem' has a wrong offset!");
static_assert(offsetof(UContaminationSubAnimInstance, _isCrawling) == 0x0005F9, "Member 'UContaminationSubAnimInstance::_isCrawling' has a wrong offset!");
static_assert(offsetof(UContaminationSubAnimInstance, _isHooked) == 0x0005FA, "Member 'UContaminationSubAnimInstance::_isHooked' has a wrong offset!");
static_assert(offsetof(UContaminationSubAnimInstance, _isDead) == 0x0005FB, "Member 'UContaminationSubAnimInstance::_isDead' has a wrong offset!");
static_assert(offsetof(UContaminationSubAnimInstance, _isFrightScreaming) == 0x0005FC, "Member 'UContaminationSubAnimInstance::_isFrightScreaming' has a wrong offset!");
static_assert(offsetof(UContaminationSubAnimInstance, _isHoldingSmallItem) == 0x0005FD, "Member 'UContaminationSubAnimInstance::_isHoldingSmallItem' has a wrong offset!");
static_assert(offsetof(UContaminationSubAnimInstance, _isUsingAimItem) == 0x0005FE, "Member 'UContaminationSubAnimInstance::_isUsingAimItem' has a wrong offset!");
static_assert(offsetof(UContaminationSubAnimInstance, _isHoldingHandleItem) == 0x0005FF, "Member 'UContaminationSubAnimInstance::_isHoldingHandleItem' has a wrong offset!");
static_assert(offsetof(UContaminationSubAnimInstance, _isInjured) == 0x000600, "Member 'UContaminationSubAnimInstance::_isInjured' has a wrong offset!");
static_assert(offsetof(UContaminationSubAnimInstance, _isCarried) == 0x000601, "Member 'UContaminationSubAnimInstance::_isCarried' has a wrong offset!");
static_assert(offsetof(UContaminationSubAnimInstance, _interactionType) == 0x000602, "Member 'UContaminationSubAnimInstance::_interactionType' has a wrong offset!");

// Class TheK24.EnvQueryContext_ZombiePatrolAreaPoint
// 0x0000 (0x0030 - 0x0030)
class UEnvQueryContext_ZombiePatrolAreaPoint final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryContext_ZombiePatrolAreaPoint">();
	}
	static class UEnvQueryContext_ZombiePatrolAreaPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryContext_ZombiePatrolAreaPoint>();
	}
};
static_assert(alignof(UEnvQueryContext_ZombiePatrolAreaPoint) == 0x000008, "Wrong alignment on UEnvQueryContext_ZombiePatrolAreaPoint");
static_assert(sizeof(UEnvQueryContext_ZombiePatrolAreaPoint) == 0x000030, "Wrong size on UEnvQueryContext_ZombiePatrolAreaPoint");

// Class TheK24.Eruption
// 0x0058 (0x0478 - 0x0420)
class UEruption final : public UPerk
{
public:
	TArray<class AGenerator*>                     _server_affectedGenerators;                        // 0x0420(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	bool                                          _isPerkEnabled;                                    // 0x0430(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_431[0x3];                                      // 0x0431(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _generatorRegressPercentage[0x3];                  // 0x0434(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _survivorImposedStatusEffectDuration[0x3];         // 0x0440(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _perkCooldownDuration[0x3];                        // 0x044C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _screamRevealLocationDuration;                     // 0x0458(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_45C[0x4];                                      // 0x045C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UStatusEffect>              _survivorEffectClass;                              // 0x0460(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_468[0x10];                                     // 0x0468(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_OnGeneratorHighlightEnd(class AGenerator* HighlightedGenerator);
	void Cosmetic_OnGeneratorHighlightStart(class AGenerator* HighlightedGenerator);
	void Multicast_HighlightGenerator(class AGenerator* Generator);
	void Multicast_RemoveHighlights(const TArray<class AGenerator*>& HighlightedGenerators);

	float GetGeneratorRegressPercentageAtLevel() const;
	float GetScreamRevealLocationDuration() const;
	float GetSurvivorImposedStatusEffectDurationAtLevel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Eruption">();
	}
	static class UEruption* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEruption>();
	}
};
static_assert(alignof(UEruption) == 0x000008, "Wrong alignment on UEruption");
static_assert(sizeof(UEruption) == 0x000478, "Wrong size on UEruption");
static_assert(offsetof(UEruption, _server_affectedGenerators) == 0x000420, "Member 'UEruption::_server_affectedGenerators' has a wrong offset!");
static_assert(offsetof(UEruption, _isPerkEnabled) == 0x000430, "Member 'UEruption::_isPerkEnabled' has a wrong offset!");
static_assert(offsetof(UEruption, _generatorRegressPercentage) == 0x000434, "Member 'UEruption::_generatorRegressPercentage' has a wrong offset!");
static_assert(offsetof(UEruption, _survivorImposedStatusEffectDuration) == 0x000440, "Member 'UEruption::_survivorImposedStatusEffectDuration' has a wrong offset!");
static_assert(offsetof(UEruption, _perkCooldownDuration) == 0x00044C, "Member 'UEruption::_perkCooldownDuration' has a wrong offset!");
static_assert(offsetof(UEruption, _screamRevealLocationDuration) == 0x000458, "Member 'UEruption::_screamRevealLocationDuration' has a wrong offset!");
static_assert(offsetof(UEruption, _survivorEffectClass) == 0x000460, "Member 'UEruption::_survivorEffectClass' has a wrong offset!");

// Class TheK24.EruptionIconStrategy
// 0x0000 (0x0038 - 0x0038)
class UEruptionIconStrategy final : public UBasePerkIconStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EruptionIconStrategy">();
	}
	static class UEruptionIconStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEruptionIconStrategy>();
	}
};
static_assert(alignof(UEruptionIconStrategy) == 0x000008, "Wrong alignment on UEruptionIconStrategy");
static_assert(sizeof(UEruptionIconStrategy) == 0x000038, "Wrong size on UEruptionIconStrategy");

// Class TheK24.Hysteria
// 0x0078 (0x0498 - 0x0420)
class UHysteria final : public UPerk
{
public:
	float                                         _obliviousEffectDuration[0x3];                     // 0x0420(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _perkCooldownDuration[0x3];                        // 0x042C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_438[0x8];                                      // 0x0438(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UHysteriaObliviousEffect>   _obliviousEffectClass;                             // 0x0440(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class ACamperPlayer*, class UHysteriaObliviousEffect*> _obliviousEffectPerSurvivorMap;                    // 0x0448(0x0050)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	float GetObliviousEffectDurationAtLevel() const;
	float GetPerkCooldownDurationAtLevel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Hysteria">();
	}
	static class UHysteria* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHysteria>();
	}
};
static_assert(alignof(UHysteria) == 0x000008, "Wrong alignment on UHysteria");
static_assert(sizeof(UHysteria) == 0x000498, "Wrong size on UHysteria");
static_assert(offsetof(UHysteria, _obliviousEffectDuration) == 0x000420, "Member 'UHysteria::_obliviousEffectDuration' has a wrong offset!");
static_assert(offsetof(UHysteria, _perkCooldownDuration) == 0x00042C, "Member 'UHysteria::_perkCooldownDuration' has a wrong offset!");
static_assert(offsetof(UHysteria, _obliviousEffectClass) == 0x000440, "Member 'UHysteria::_obliviousEffectClass' has a wrong offset!");
static_assert(offsetof(UHysteria, _obliviousEffectPerSurvivorMap) == 0x000448, "Member 'UHysteria::_obliviousEffectPerSurvivorMap' has a wrong offset!");

// Class TheK24.HysteriaObliviousEffect
// 0x0000 (0x0390 - 0x0390)
class UHysteriaObliviousEffect final : public UTimedObliviousEffect
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HysteriaObliviousEffect">();
	}
	static class UHysteriaObliviousEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHysteriaObliviousEffect>();
	}
};
static_assert(alignof(UHysteriaObliviousEffect) == 0x000008, "Wrong alignment on UHysteriaObliviousEffect");
static_assert(sizeof(UHysteriaObliviousEffect) == 0x000390, "Wrong size on UHysteriaObliviousEffect");

// Class TheK24.IncreaseZombiesSpeedStatusEffect
// 0x0008 (0x0388 - 0x0380)
class UIncreaseZombiesSpeedStatusEffect final : public UStatusEffect
{
public:
	float                                         _zombieSpeedAdditive;                              // 0x0380(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_384[0x4];                                      // 0x0384(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IncreaseZombiesSpeedStatusEffect">();
	}
	static class UIncreaseZombiesSpeedStatusEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIncreaseZombiesSpeedStatusEffect>();
	}
};
static_assert(alignof(UIncreaseZombiesSpeedStatusEffect) == 0x000008, "Wrong alignment on UIncreaseZombiesSpeedStatusEffect");
static_assert(sizeof(UIncreaseZombiesSpeedStatusEffect) == 0x000388, "Wrong size on UIncreaseZombiesSpeedStatusEffect");
static_assert(offsetof(UIncreaseZombiesSpeedStatusEffect, _zombieSpeedAdditive) == 0x000380, "Member 'UIncreaseZombiesSpeedStatusEffect::_zombieSpeedAdditive' has a wrong offset!");

// Class TheK24.InjectSerumInteraction
// 0x00D0 (0x0990 - 0x08C0)
class UInjectSerumInteraction : public UChargeableInteractionDefinition
{
public:
	TSubclassOf<class UStatusEffect>              _killerInstinctStatusEffectClass;                  // 0x08C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTunableStat                           _injectSerumKillerInstinctTime;                    // 0x08C8(0x0080)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_948[0x8];                                      // 0x0948(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           _scoreEvent;                                       // 0x0950(0x000C)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_95C[0x4];                                      // 0x095C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _serumApplyHeal;                                   // 0x0960(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_988[0x8];                                      // 0x0988(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_CureSurvivor(class ACamperPlayer* CamperPlayer);

	class ACamperPlayer* GetInjectionTarget() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InjectSerumInteraction">();
	}
	static class UInjectSerumInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInjectSerumInteraction>();
	}
};
static_assert(alignof(UInjectSerumInteraction) == 0x000010, "Wrong alignment on UInjectSerumInteraction");
static_assert(sizeof(UInjectSerumInteraction) == 0x000990, "Wrong size on UInjectSerumInteraction");
static_assert(offsetof(UInjectSerumInteraction, _killerInstinctStatusEffectClass) == 0x0008C0, "Member 'UInjectSerumInteraction::_killerInstinctStatusEffectClass' has a wrong offset!");
static_assert(offsetof(UInjectSerumInteraction, _injectSerumKillerInstinctTime) == 0x0008C8, "Member 'UInjectSerumInteraction::_injectSerumKillerInstinctTime' has a wrong offset!");
static_assert(offsetof(UInjectSerumInteraction, _scoreEvent) == 0x000950, "Member 'UInjectSerumInteraction::_scoreEvent' has a wrong offset!");
static_assert(offsetof(UInjectSerumInteraction, _serumApplyHeal) == 0x000960, "Member 'UInjectSerumInteraction::_serumApplyHeal' has a wrong offset!");

// Class TheK24.InjectSerumOther
// 0x0000 (0x0990 - 0x0990)
class UInjectSerumOther final : public UInjectSerumInteraction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InjectSerumOther">();
	}
	static class UInjectSerumOther* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInjectSerumOther>();
	}
};
static_assert(alignof(UInjectSerumOther) == 0x000010, "Wrong alignment on UInjectSerumOther");
static_assert(sizeof(UInjectSerumOther) == 0x000990, "Wrong size on UInjectSerumOther");

// Class TheK24.InjectSerumSelf
// 0x0000 (0x0990 - 0x0990)
class UInjectSerumSelf final : public UInjectSerumInteraction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InjectSerumSelf">();
	}
	static class UInjectSerumSelf* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInjectSerumSelf>();
	}
};
static_assert(alignof(UInjectSerumSelf) == 0x000010, "Wrong alignment on UInjectSerumSelf");
static_assert(sizeof(UInjectSerumSelf) == 0x000990, "Wrong size on UInjectSerumSelf");

// Class TheK24.K24AnimInstance
// 0x0020 (0x0740 - 0x0720)
class UK24AnimInstance final : public UKillerAnimInstance
{
public:
	bool                                          _isInPowerMode;                                    // 0x0720(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isChargingPower;                                  // 0x0721(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isK24PowerAttacking;                              // 0x0722(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isRequestingPowerAttack;                          // 0x0723(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _powerLevel;                                       // 0x0724(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_728[0x18];                                     // 0x0728(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnKillerPowerLevelChanged(int32 Powerlevel);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K24AnimInstance">();
	}
	static class UK24AnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK24AnimInstance>();
	}
};
static_assert(alignof(UK24AnimInstance) == 0x000010, "Wrong alignment on UK24AnimInstance");
static_assert(sizeof(UK24AnimInstance) == 0x000740, "Wrong size on UK24AnimInstance");
static_assert(offsetof(UK24AnimInstance, _isInPowerMode) == 0x000720, "Member 'UK24AnimInstance::_isInPowerMode' has a wrong offset!");
static_assert(offsetof(UK24AnimInstance, _isChargingPower) == 0x000721, "Member 'UK24AnimInstance::_isChargingPower' has a wrong offset!");
static_assert(offsetof(UK24AnimInstance, _isK24PowerAttacking) == 0x000722, "Member 'UK24AnimInstance::_isK24PowerAttacking' has a wrong offset!");
static_assert(offsetof(UK24AnimInstance, _isRequestingPowerAttack) == 0x000723, "Member 'UK24AnimInstance::_isRequestingPowerAttack' has a wrong offset!");
static_assert(offsetof(UK24AnimInstance, _powerLevel) == 0x000724, "Member 'UK24AnimInstance::_powerLevel' has a wrong offset!");

// Class TheK24.K24CharacterFXComponent
// 0x0050 (0x00F8 - 0x00A8)
class UK24CharacterFXComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnPowerLevelChangedFx;                             // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             Local_OnKillerHitZombie;                           // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             Local_OnKillerContaminatedSurvivor;                // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_D8[0x20];                                      // 0x00D8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Local_OnKillerPowerLevelChanged(int32 Powerlevel);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K24CharacterFXComponent">();
	}
	static class UK24CharacterFXComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK24CharacterFXComponent>();
	}
};
static_assert(alignof(UK24CharacterFXComponent) == 0x000008, "Wrong alignment on UK24CharacterFXComponent");
static_assert(sizeof(UK24CharacterFXComponent) == 0x0000F8, "Wrong size on UK24CharacterFXComponent");
static_assert(offsetof(UK24CharacterFXComponent, OnPowerLevelChangedFx) == 0x0000A8, "Member 'UK24CharacterFXComponent::OnPowerLevelChangedFx' has a wrong offset!");
static_assert(offsetof(UK24CharacterFXComponent, Local_OnKillerHitZombie) == 0x0000B8, "Member 'UK24CharacterFXComponent::Local_OnKillerHitZombie' has a wrong offset!");
static_assert(offsetof(UK24CharacterFXComponent, Local_OnKillerContaminatedSurvivor) == 0x0000C8, "Member 'UK24CharacterFXComponent::Local_OnKillerContaminatedSurvivor' has a wrong offset!");

// Class TheK24.K24CheatComponent
// 0x0010 (0x00B8 - 0x00A8)
class UK24CheatComponent final : public UActorComponent
{
public:
	TSubclassOf<class AZombiesManagement>         _zombieManagementClass;                            // 0x00A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AZombiesManagement*                     _zombiesManagement;                                // 0x00B0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void DBD_K24ComeToMeMyZombies();
	void DBD_K24SetContaminationOnSurvivor(const bool Value);
	void DBD_K24SetPowerLevelPoints(const float Value);
	void DBD_K24SpawnZombieOnKiller();
	void DBD_K24StartAllZombies();
	void DBD_K24StopAllZombies();
	void DBD_K24ZombieFall(const float Zvalue);
	void DBD_TeleportZombiesTo(float X, float Y, float Z);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K24CheatComponent">();
	}
	static class UK24CheatComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK24CheatComponent>();
	}
};
static_assert(alignof(UK24CheatComponent) == 0x000008, "Wrong alignment on UK24CheatComponent");
static_assert(sizeof(UK24CheatComponent) == 0x0000B8, "Wrong size on UK24CheatComponent");
static_assert(offsetof(UK24CheatComponent, _zombieManagementClass) == 0x0000A8, "Member 'UK24CheatComponent::_zombieManagementClass' has a wrong offset!");
static_assert(offsetof(UK24CheatComponent, _zombiesManagement) == 0x0000B0, "Member 'UK24CheatComponent::_zombiesManagement' has a wrong offset!");

// Class TheK24.K24PounceAttack
// 0x0000 (0x0420 - 0x0420)
class UK24PounceAttack : public UPounceAttack
{
public:
	void Server_HitZombie(class AZombieCharacter* Zombie, const float TargetLocationTimestamp);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K24PounceAttack">();
	}
	static class UK24PounceAttack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK24PounceAttack>();
	}
};
static_assert(alignof(UK24PounceAttack) == 0x000010, "Wrong alignment on UK24PounceAttack");
static_assert(sizeof(UK24PounceAttack) == 0x000420, "Wrong size on UK24PounceAttack");

// Class TheK24.K24Power
// 0x0450 (0x09A0 - 0x0550)
class AK24Power final : public ACollectable
{
public:
	uint8                                         Pad_550[0xB0];                                     // 0x0550(0x00B0)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _powerWalkSpeed;                                   // 0x0600(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _powerWalkSpeedLevel3;                             // 0x0628(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _normalWalkSpeed;                                  // 0x0650(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _powerMouseYawScale;                               // 0x0678(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _powerYawAdjustTime;                               // 0x06A0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _powerGamePadYawScale;                             // 0x06C8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class UChargeableComponent*                   _activateK24PowerCharge;                           // 0x06F0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _activateK24PowerSecondsToCharge;                  // 0x06F8(0x0028)(Edit, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _activatePowerChargeSpeedCurve;                    // 0x0720(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _activatePowerChargeLvl3SpeedCurve;                // 0x0728(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _playedPowerChargeSpeedCurve;                      // 0x0730(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInteractionDefinition*                 _k24PowerCooldownInteraction;                      // 0x0738(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _whipLengthLevel1;                                 // 0x0740(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _whipLengthLevel2;                                 // 0x0768(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _whipLengthLevel3;                                 // 0x0790(0x0028)(Edit, NativeAccessSpecifierPrivate)
	TSubclassOf<class USurvivorContaminationComponent> _contaminationComponentBP;                         // 0x07B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _powerChargeSurvivorContaminatedPoint;             // 0x07C0(0x0080)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _powerChargeZombieKilledPoint;                     // 0x0840(0x0080)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _powerChargeSurvivorHitPoint;                      // 0x08C0(0x0080)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	float                                         _powerLevelPoints;                                 // 0x0940(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_944[0x4];                                      // 0x0944(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _powerLevelPointsToLevel2;                         // 0x0948(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _powerLevelPointsToLevel3;                         // 0x0970(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_998[0x8];                                      // 0x0998(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnSurvivorContaminated(const EContaminator Contaminator);
	void Multicast_PowerDestroyBreakable(class ABreakableBase* breakable);
	void Multicast_PowerDestroyPallet(class APallet* Pallet);
	void OnPowerLevelChanged_Cosmetic(const int32 Powerlevel);
	void OnPowerStartCharge_Cosmetic();
	void OnPowerStop_Cosmetic();
	void OnRep_PowerLevelPoints();
	void PowerCooldownEnd_Cosmetic();
	void PowerHitStateEnd_Cosmetic(const struct FVector& WhipStartLocation, const struct FVector& WhipEndLocation);
	void Server_KillAZombie(class AZombieCharacter* Zombie, EAttackType AttackType);
	void Server_PowerDestroyBreakable(class ABreakableBase* breakable);
	void Server_PowerDestroyPallet(class APallet* Pallet);
	void WhipAttackEnd_Cosmetic();
	void WhipAttackHit_Cosmetic(const struct FVector& WhipStartLocation, const struct FVector& ImpactPointLocation, const struct FVector& WhipEndLocation, bool IsFirstHit, const struct FVector& ImpactNormal, const class FName PhyMaterial, bool HitACharacter);
	void WhipAttackMove_Cosmetic(const struct FVector& WhipStartLocation, const struct FVector& WhipEndLocation, bool IsFirstRayCast);
	void WhipAttackStart_Cosmetic();

	int32 GetPowerLevel() const;
	float GetWhipLength() const;
	bool IsInPower() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K24Power">();
	}
	static class AK24Power* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK24Power>();
	}
};
static_assert(alignof(AK24Power) == 0x000008, "Wrong alignment on AK24Power");
static_assert(sizeof(AK24Power) == 0x0009A0, "Wrong size on AK24Power");
static_assert(offsetof(AK24Power, _powerWalkSpeed) == 0x000600, "Member 'AK24Power::_powerWalkSpeed' has a wrong offset!");
static_assert(offsetof(AK24Power, _powerWalkSpeedLevel3) == 0x000628, "Member 'AK24Power::_powerWalkSpeedLevel3' has a wrong offset!");
static_assert(offsetof(AK24Power, _normalWalkSpeed) == 0x000650, "Member 'AK24Power::_normalWalkSpeed' has a wrong offset!");
static_assert(offsetof(AK24Power, _powerMouseYawScale) == 0x000678, "Member 'AK24Power::_powerMouseYawScale' has a wrong offset!");
static_assert(offsetof(AK24Power, _powerYawAdjustTime) == 0x0006A0, "Member 'AK24Power::_powerYawAdjustTime' has a wrong offset!");
static_assert(offsetof(AK24Power, _powerGamePadYawScale) == 0x0006C8, "Member 'AK24Power::_powerGamePadYawScale' has a wrong offset!");
static_assert(offsetof(AK24Power, _activateK24PowerCharge) == 0x0006F0, "Member 'AK24Power::_activateK24PowerCharge' has a wrong offset!");
static_assert(offsetof(AK24Power, _activateK24PowerSecondsToCharge) == 0x0006F8, "Member 'AK24Power::_activateK24PowerSecondsToCharge' has a wrong offset!");
static_assert(offsetof(AK24Power, _activatePowerChargeSpeedCurve) == 0x000720, "Member 'AK24Power::_activatePowerChargeSpeedCurve' has a wrong offset!");
static_assert(offsetof(AK24Power, _activatePowerChargeLvl3SpeedCurve) == 0x000728, "Member 'AK24Power::_activatePowerChargeLvl3SpeedCurve' has a wrong offset!");
static_assert(offsetof(AK24Power, _playedPowerChargeSpeedCurve) == 0x000730, "Member 'AK24Power::_playedPowerChargeSpeedCurve' has a wrong offset!");
static_assert(offsetof(AK24Power, _k24PowerCooldownInteraction) == 0x000738, "Member 'AK24Power::_k24PowerCooldownInteraction' has a wrong offset!");
static_assert(offsetof(AK24Power, _whipLengthLevel1) == 0x000740, "Member 'AK24Power::_whipLengthLevel1' has a wrong offset!");
static_assert(offsetof(AK24Power, _whipLengthLevel2) == 0x000768, "Member 'AK24Power::_whipLengthLevel2' has a wrong offset!");
static_assert(offsetof(AK24Power, _whipLengthLevel3) == 0x000790, "Member 'AK24Power::_whipLengthLevel3' has a wrong offset!");
static_assert(offsetof(AK24Power, _contaminationComponentBP) == 0x0007B8, "Member 'AK24Power::_contaminationComponentBP' has a wrong offset!");
static_assert(offsetof(AK24Power, _powerChargeSurvivorContaminatedPoint) == 0x0007C0, "Member 'AK24Power::_powerChargeSurvivorContaminatedPoint' has a wrong offset!");
static_assert(offsetof(AK24Power, _powerChargeZombieKilledPoint) == 0x000840, "Member 'AK24Power::_powerChargeZombieKilledPoint' has a wrong offset!");
static_assert(offsetof(AK24Power, _powerChargeSurvivorHitPoint) == 0x0008C0, "Member 'AK24Power::_powerChargeSurvivorHitPoint' has a wrong offset!");
static_assert(offsetof(AK24Power, _powerLevelPoints) == 0x000940, "Member 'AK24Power::_powerLevelPoints' has a wrong offset!");
static_assert(offsetof(AK24Power, _powerLevelPointsToLevel2) == 0x000948, "Member 'AK24Power::_powerLevelPointsToLevel2' has a wrong offset!");
static_assert(offsetof(AK24Power, _powerLevelPointsToLevel3) == 0x000970, "Member 'AK24Power::_powerLevelPointsToLevel3' has a wrong offset!");

// Class TheK24.K24PowerAnimInstance
// 0x0160 (0x04B0 - 0x0350)
class UK24PowerAnimInstance final : public UAnimInstance
{
public:
	class ASlasherPlayer*                         _owningKiller;                                     // 0x0350(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isInPowerMode;                                    // 0x0358(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isChargingPower;                                  // 0x0359(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isK24PowerAttacking;                              // 0x035A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isRequestingPowerAttack;                          // 0x035B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _tentacleLength;                                   // 0x035C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isFirstPersonView;                                // 0x0360(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAttackSubstate                               _attackSubState;                                   // 0x0361(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isIntroCompleted;                                 // 0x0362(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isLevelReadyToPlay;                               // 0x0363(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _powerLevel;                                       // 0x0364(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _forwardVelocity;                                  // 0x0368(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _lateralVelocity;                                  // 0x036C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isIdle;                                           // 0x0370(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isKilling;                                        // 0x0371(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_372[0x6];                                      // 0x0372(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          _swingIdleTPVSequences[0x3];                       // 0x0378(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _wipeIdleTPVSequences[0x3];                        // 0x0390(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _missIdleTPVSequences[0x3];                        // 0x03A8(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _bowIdleTPVSequences[0x3];                         // 0x03C0(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _swingIdleTPVSequence;                             // 0x03D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _wipeIdleTPVSequence;                              // 0x03E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _missIdleTPVSequence;                              // 0x03E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _bowIdleTPVSequence;                               // 0x03F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _swingLocoTPVSequence;                             // 0x03F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _wipeLocoTPVSequence;                              // 0x0400(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _missLocoTPVSequence;                              // 0x0408(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _bowLocoTPVSequence;                               // 0x0410(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _swingFPVSequences[0x3];                           // 0x0418(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _wipeFPVSequences[0x3];                            // 0x0430(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _missFPVSequences[0x3];                            // 0x0448(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _bowFPVSequences[0x3];                             // 0x0460(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _swingFPVSequence;                                 // 0x0478(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _wipeFPVSequence;                                  // 0x0480(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _missFPVSequence;                                  // 0x0488(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _bowFPVSequence;                                   // 0x0490(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AK24Power*                              _k24Power;                                         // 0x0498(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4A0[0x10];                                     // 0x04A0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnIntroCompleted();
	void OnKillerPowerLevelChanged(int32 Powerlevel);
	void OnLevelReadyToPlay();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K24PowerAnimInstance">();
	}
	static class UK24PowerAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK24PowerAnimInstance>();
	}
};
static_assert(alignof(UK24PowerAnimInstance) == 0x000010, "Wrong alignment on UK24PowerAnimInstance");
static_assert(sizeof(UK24PowerAnimInstance) == 0x0004B0, "Wrong size on UK24PowerAnimInstance");
static_assert(offsetof(UK24PowerAnimInstance, _owningKiller) == 0x000350, "Member 'UK24PowerAnimInstance::_owningKiller' has a wrong offset!");
static_assert(offsetof(UK24PowerAnimInstance, _isInPowerMode) == 0x000358, "Member 'UK24PowerAnimInstance::_isInPowerMode' has a wrong offset!");
static_assert(offsetof(UK24PowerAnimInstance, _isChargingPower) == 0x000359, "Member 'UK24PowerAnimInstance::_isChargingPower' has a wrong offset!");
static_assert(offsetof(UK24PowerAnimInstance, _isK24PowerAttacking) == 0x00035A, "Member 'UK24PowerAnimInstance::_isK24PowerAttacking' has a wrong offset!");
static_assert(offsetof(UK24PowerAnimInstance, _isRequestingPowerAttack) == 0x00035B, "Member 'UK24PowerAnimInstance::_isRequestingPowerAttack' has a wrong offset!");
static_assert(offsetof(UK24PowerAnimInstance, _tentacleLength) == 0x00035C, "Member 'UK24PowerAnimInstance::_tentacleLength' has a wrong offset!");
static_assert(offsetof(UK24PowerAnimInstance, _isFirstPersonView) == 0x000360, "Member 'UK24PowerAnimInstance::_isFirstPersonView' has a wrong offset!");
static_assert(offsetof(UK24PowerAnimInstance, _attackSubState) == 0x000361, "Member 'UK24PowerAnimInstance::_attackSubState' has a wrong offset!");
static_assert(offsetof(UK24PowerAnimInstance, _isIntroCompleted) == 0x000362, "Member 'UK24PowerAnimInstance::_isIntroCompleted' has a wrong offset!");
static_assert(offsetof(UK24PowerAnimInstance, _isLevelReadyToPlay) == 0x000363, "Member 'UK24PowerAnimInstance::_isLevelReadyToPlay' has a wrong offset!");
static_assert(offsetof(UK24PowerAnimInstance, _powerLevel) == 0x000364, "Member 'UK24PowerAnimInstance::_powerLevel' has a wrong offset!");
static_assert(offsetof(UK24PowerAnimInstance, _forwardVelocity) == 0x000368, "Member 'UK24PowerAnimInstance::_forwardVelocity' has a wrong offset!");
static_assert(offsetof(UK24PowerAnimInstance, _lateralVelocity) == 0x00036C, "Member 'UK24PowerAnimInstance::_lateralVelocity' has a wrong offset!");
static_assert(offsetof(UK24PowerAnimInstance, _isIdle) == 0x000370, "Member 'UK24PowerAnimInstance::_isIdle' has a wrong offset!");
static_assert(offsetof(UK24PowerAnimInstance, _isKilling) == 0x000371, "Member 'UK24PowerAnimInstance::_isKilling' has a wrong offset!");
static_assert(offsetof(UK24PowerAnimInstance, _swingIdleTPVSequences) == 0x000378, "Member 'UK24PowerAnimInstance::_swingIdleTPVSequences' has a wrong offset!");
static_assert(offsetof(UK24PowerAnimInstance, _wipeIdleTPVSequences) == 0x000390, "Member 'UK24PowerAnimInstance::_wipeIdleTPVSequences' has a wrong offset!");
static_assert(offsetof(UK24PowerAnimInstance, _missIdleTPVSequences) == 0x0003A8, "Member 'UK24PowerAnimInstance::_missIdleTPVSequences' has a wrong offset!");
static_assert(offsetof(UK24PowerAnimInstance, _bowIdleTPVSequences) == 0x0003C0, "Member 'UK24PowerAnimInstance::_bowIdleTPVSequences' has a wrong offset!");
static_assert(offsetof(UK24PowerAnimInstance, _swingIdleTPVSequence) == 0x0003D8, "Member 'UK24PowerAnimInstance::_swingIdleTPVSequence' has a wrong offset!");
static_assert(offsetof(UK24PowerAnimInstance, _wipeIdleTPVSequence) == 0x0003E0, "Member 'UK24PowerAnimInstance::_wipeIdleTPVSequence' has a wrong offset!");
static_assert(offsetof(UK24PowerAnimInstance, _missIdleTPVSequence) == 0x0003E8, "Member 'UK24PowerAnimInstance::_missIdleTPVSequence' has a wrong offset!");
static_assert(offsetof(UK24PowerAnimInstance, _bowIdleTPVSequence) == 0x0003F0, "Member 'UK24PowerAnimInstance::_bowIdleTPVSequence' has a wrong offset!");
static_assert(offsetof(UK24PowerAnimInstance, _swingLocoTPVSequence) == 0x0003F8, "Member 'UK24PowerAnimInstance::_swingLocoTPVSequence' has a wrong offset!");
static_assert(offsetof(UK24PowerAnimInstance, _wipeLocoTPVSequence) == 0x000400, "Member 'UK24PowerAnimInstance::_wipeLocoTPVSequence' has a wrong offset!");
static_assert(offsetof(UK24PowerAnimInstance, _missLocoTPVSequence) == 0x000408, "Member 'UK24PowerAnimInstance::_missLocoTPVSequence' has a wrong offset!");
static_assert(offsetof(UK24PowerAnimInstance, _bowLocoTPVSequence) == 0x000410, "Member 'UK24PowerAnimInstance::_bowLocoTPVSequence' has a wrong offset!");
static_assert(offsetof(UK24PowerAnimInstance, _swingFPVSequences) == 0x000418, "Member 'UK24PowerAnimInstance::_swingFPVSequences' has a wrong offset!");
static_assert(offsetof(UK24PowerAnimInstance, _wipeFPVSequences) == 0x000430, "Member 'UK24PowerAnimInstance::_wipeFPVSequences' has a wrong offset!");
static_assert(offsetof(UK24PowerAnimInstance, _missFPVSequences) == 0x000448, "Member 'UK24PowerAnimInstance::_missFPVSequences' has a wrong offset!");
static_assert(offsetof(UK24PowerAnimInstance, _bowFPVSequences) == 0x000460, "Member 'UK24PowerAnimInstance::_bowFPVSequences' has a wrong offset!");
static_assert(offsetof(UK24PowerAnimInstance, _swingFPVSequence) == 0x000478, "Member 'UK24PowerAnimInstance::_swingFPVSequence' has a wrong offset!");
static_assert(offsetof(UK24PowerAnimInstance, _wipeFPVSequence) == 0x000480, "Member 'UK24PowerAnimInstance::_wipeFPVSequence' has a wrong offset!");
static_assert(offsetof(UK24PowerAnimInstance, _missFPVSequence) == 0x000488, "Member 'UK24PowerAnimInstance::_missFPVSequence' has a wrong offset!");
static_assert(offsetof(UK24PowerAnimInstance, _bowFPVSequence) == 0x000490, "Member 'UK24PowerAnimInstance::_bowFPVSequence' has a wrong offset!");
static_assert(offsetof(UK24PowerAnimInstance, _k24Power) == 0x000498, "Member 'UK24PowerAnimInstance::_k24Power' has a wrong offset!");

// Class TheK24.k24PowerCooldownInteraction
// 0x0040 (0x07C0 - 0x0780)
class UK24PowerCooldownInteraction final : public UInteractionDefinition
{
public:
	struct FDBDTunableRowHandle                   _k24PowerCooldownTime;                             // 0x0778(0x0028)(Edit, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _cooldownSpeedCurve;                               // 0x07A0(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _cooldownLvl3SpeedCurve;                           // 0x07A8(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _playedCooldownSpeedCurve;                         // 0x07B0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7B8[0x8];                                      // 0x07B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetK24Power(class AK24Power* K24Power);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"k24PowerCooldownInteraction">();
	}
	static class UK24PowerCooldownInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK24PowerCooldownInteraction>();
	}
};
static_assert(alignof(UK24PowerCooldownInteraction) == 0x000010, "Wrong alignment on UK24PowerCooldownInteraction");
static_assert(sizeof(UK24PowerCooldownInteraction) == 0x0007C0, "Wrong size on UK24PowerCooldownInteraction");
static_assert(offsetof(UK24PowerCooldownInteraction, _k24PowerCooldownTime) == 0x000778, "Member 'UK24PowerCooldownInteraction::_k24PowerCooldownTime' has a wrong offset!");
static_assert(offsetof(UK24PowerCooldownInteraction, _cooldownSpeedCurve) == 0x0007A0, "Member 'UK24PowerCooldownInteraction::_cooldownSpeedCurve' has a wrong offset!");
static_assert(offsetof(UK24PowerCooldownInteraction, _cooldownLvl3SpeedCurve) == 0x0007A8, "Member 'UK24PowerCooldownInteraction::_cooldownLvl3SpeedCurve' has a wrong offset!");
static_assert(offsetof(UK24PowerCooldownInteraction, _playedCooldownSpeedCurve) == 0x0007B0, "Member 'UK24PowerCooldownInteraction::_playedCooldownSpeedCurve' has a wrong offset!");

// Class TheK24.K24PowerPresentationItemProgressComponent
// 0x0008 (0x00B8 - 0x00B0)
class UK24PowerPresentationItemProgressComponent final : public UPresentationItemProgressComponent
{
public:
	class AK24Power*                              _k24Power;                                         // 0x00B0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void SetK24Power(class AK24Power* K24Power);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K24PowerPresentationItemProgressComponent">();
	}
	static class UK24PowerPresentationItemProgressComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK24PowerPresentationItemProgressComponent>();
	}
};
static_assert(alignof(UK24PowerPresentationItemProgressComponent) == 0x000008, "Wrong alignment on UK24PowerPresentationItemProgressComponent");
static_assert(sizeof(UK24PowerPresentationItemProgressComponent) == 0x0000B8, "Wrong size on UK24PowerPresentationItemProgressComponent");
static_assert(offsetof(UK24PowerPresentationItemProgressComponent, _k24Power) == 0x0000B0, "Member 'UK24PowerPresentationItemProgressComponent::_k24Power' has a wrong offset!");

// Class TheK24.K24SlashAttack
// 0x0000 (0x0420 - 0x0420)
class UK24SlashAttack final : public UK24PounceAttack
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K24SlashAttack">();
	}
	static class UK24SlashAttack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK24SlashAttack>();
	}
};
static_assert(alignof(UK24SlashAttack) == 0x000010, "Wrong alignment on UK24SlashAttack");
static_assert(sizeof(UK24SlashAttack) == 0x000420, "Wrong size on UK24SlashAttack");

// Class TheK24.K24WhipAttack
// 0x0090 (0x04B0 - 0x0420)
class UK24WhipAttack final : public UPounceAttack
{
public:
	struct FDBDTunableRowHandle                   _attackSphereTraceRadius;                          // 0x0420(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _attackMinDistanceToObstruction;                   // 0x0448(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FVector                                _whipMovementFromOffset;                           // 0x0470(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                _whipMovementToOffset;                             // 0x0488(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4A0[0x10];                                     // 0x04A0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Client_ContaminationResult(class ADBDPlayer* Target, bool IsValid);
	void Server_ContaminatePlayer(class ACamperPlayer* Target, const float TargetLocationTimestamp);
	void Server_HitBreakableOrZombie();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K24WhipAttack">();
	}
	static class UK24WhipAttack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK24WhipAttack>();
	}
};
static_assert(alignof(UK24WhipAttack) == 0x000010, "Wrong alignment on UK24WhipAttack");
static_assert(sizeof(UK24WhipAttack) == 0x0004B0, "Wrong size on UK24WhipAttack");
static_assert(offsetof(UK24WhipAttack, _attackSphereTraceRadius) == 0x000420, "Member 'UK24WhipAttack::_attackSphereTraceRadius' has a wrong offset!");
static_assert(offsetof(UK24WhipAttack, _attackMinDistanceToObstruction) == 0x000448, "Member 'UK24WhipAttack::_attackMinDistanceToObstruction' has a wrong offset!");
static_assert(offsetof(UK24WhipAttack, _whipMovementFromOffset) == 0x000470, "Member 'UK24WhipAttack::_whipMovementFromOffset' has a wrong offset!");
static_assert(offsetof(UK24WhipAttack, _whipMovementToOffset) == 0x000488, "Member 'UK24WhipAttack::_whipMovementToOffset' has a wrong offset!");

// Class TheK24.K24WhipAttackOpenSubstate
// 0x0008 (0x0138 - 0x0130)
class UK24WhipAttackOpenSubstate final : public UPounceAttackOpenSubstate
{
public:
	class UCurveFloat*                            _lvl3SpeedCurve;                                   // 0x0130(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K24WhipAttackOpenSubstate">();
	}
	static class UK24WhipAttackOpenSubstate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK24WhipAttackOpenSubstate>();
	}
};
static_assert(alignof(UK24WhipAttackOpenSubstate) == 0x000008, "Wrong alignment on UK24WhipAttackOpenSubstate");
static_assert(sizeof(UK24WhipAttackOpenSubstate) == 0x000138, "Wrong size on UK24WhipAttackOpenSubstate");
static_assert(offsetof(UK24WhipAttackOpenSubstate, _lvl3SpeedCurve) == 0x000130, "Member 'UK24WhipAttackOpenSubstate::_lvl3SpeedCurve' has a wrong offset!");

// Class TheK24.K24WhipAttackHittingSubstate
// 0x00F8 (0x0298 - 0x01A0)
class UK24WhipAttackHittingSubstate final : public UPounceAttackHittingSubstate
{
public:
	struct FDBDTunableRowHandle                   _attackSphereTraceRadius;                          // 0x01A0(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _powerAttackBreakObjectLevel;                      // 0x01C8(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _powerCanBreakObjectAfterAPlayerDamage;            // 0x01F0(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FVector                                _whipMovementFromOffset;                           // 0x0218(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                _whipMovementToOffset;                             // 0x0230(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _whipMovementCurve;                                // 0x0248(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _lvl3SpeedCurve;                                   // 0x0250(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _whipGroundDetectionOffset;                        // 0x0258(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_25C[0x3C];                                     // 0x025C(0x003C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K24WhipAttackHittingSubstate">();
	}
	static class UK24WhipAttackHittingSubstate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK24WhipAttackHittingSubstate>();
	}
};
static_assert(alignof(UK24WhipAttackHittingSubstate) == 0x000008, "Wrong alignment on UK24WhipAttackHittingSubstate");
static_assert(sizeof(UK24WhipAttackHittingSubstate) == 0x000298, "Wrong size on UK24WhipAttackHittingSubstate");
static_assert(offsetof(UK24WhipAttackHittingSubstate, _attackSphereTraceRadius) == 0x0001A0, "Member 'UK24WhipAttackHittingSubstate::_attackSphereTraceRadius' has a wrong offset!");
static_assert(offsetof(UK24WhipAttackHittingSubstate, _powerAttackBreakObjectLevel) == 0x0001C8, "Member 'UK24WhipAttackHittingSubstate::_powerAttackBreakObjectLevel' has a wrong offset!");
static_assert(offsetof(UK24WhipAttackHittingSubstate, _powerCanBreakObjectAfterAPlayerDamage) == 0x0001F0, "Member 'UK24WhipAttackHittingSubstate::_powerCanBreakObjectAfterAPlayerDamage' has a wrong offset!");
static_assert(offsetof(UK24WhipAttackHittingSubstate, _whipMovementFromOffset) == 0x000218, "Member 'UK24WhipAttackHittingSubstate::_whipMovementFromOffset' has a wrong offset!");
static_assert(offsetof(UK24WhipAttackHittingSubstate, _whipMovementToOffset) == 0x000230, "Member 'UK24WhipAttackHittingSubstate::_whipMovementToOffset' has a wrong offset!");
static_assert(offsetof(UK24WhipAttackHittingSubstate, _whipMovementCurve) == 0x000248, "Member 'UK24WhipAttackHittingSubstate::_whipMovementCurve' has a wrong offset!");
static_assert(offsetof(UK24WhipAttackHittingSubstate, _lvl3SpeedCurve) == 0x000250, "Member 'UK24WhipAttackHittingSubstate::_lvl3SpeedCurve' has a wrong offset!");
static_assert(offsetof(UK24WhipAttackHittingSubstate, _whipGroundDetectionOffset) == 0x000258, "Member 'UK24WhipAttackHittingSubstate::_whipGroundDetectionOffset' has a wrong offset!");

// Class TheK24.K24WhipAttackSuccessSubstate
// 0x0000 (0x0118 - 0x0118)
class UK24WhipAttackSuccessSubstate final : public UPounceAttackSuccessSubstate
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K24WhipAttackSuccessSubstate">();
	}
	static class UK24WhipAttackSuccessSubstate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK24WhipAttackSuccessSubstate>();
	}
};
static_assert(alignof(UK24WhipAttackSuccessSubstate) == 0x000008, "Wrong alignment on UK24WhipAttackSuccessSubstate");
static_assert(sizeof(UK24WhipAttackSuccessSubstate) == 0x000118, "Wrong size on UK24WhipAttackSuccessSubstate");

// Class TheK24.K24WhipAttackMissSubstate
// 0x0000 (0x0120 - 0x0120)
class UK24WhipAttackMissSubstate final : public UPounceAttackMissSubstate
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K24WhipAttackMissSubstate">();
	}
	static class UK24WhipAttackMissSubstate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK24WhipAttackMissSubstate>();
	}
};
static_assert(alignof(UK24WhipAttackMissSubstate) == 0x000008, "Wrong alignment on UK24WhipAttackMissSubstate");
static_assert(sizeof(UK24WhipAttackMissSubstate) == 0x000120, "Wrong size on UK24WhipAttackMissSubstate");

// Class TheK24.K24WhipAttackObstructSubstate
// 0x0000 (0x0128 - 0x0128)
class UK24WhipAttackObstructSubstate final : public UPounceAttackObstructSubstate
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K24WhipAttackObstructSubstate">();
	}
	static class UK24WhipAttackObstructSubstate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK24WhipAttackObstructSubstate>();
	}
};
static_assert(alignof(UK24WhipAttackObstructSubstate) == 0x000008, "Wrong alignment on UK24WhipAttackObstructSubstate");
static_assert(sizeof(UK24WhipAttackObstructSubstate) == 0x000128, "Wrong size on UK24WhipAttackObstructSubstate");

// Class TheK24.LethalPursuer
// 0x0018 (0x0438 - 0x0420)
class ULethalPursuer final : public UPerk
{
public:
	float                                         _survivorRevealDuration[0x3];                      // 0x0420(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_42C[0x4];                                      // 0x042C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UStatusEffect>              _timedRevealEffect;                                // 0x0430(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Local_OnIntroCompleted();
	void Server_ActivatePerk();

	float GetSurvivorRevealDurationAtLevel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LethalPursuer">();
	}
	static class ULethalPursuer* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULethalPursuer>();
	}
};
static_assert(alignof(ULethalPursuer) == 0x000008, "Wrong alignment on ULethalPursuer");
static_assert(sizeof(ULethalPursuer) == 0x000438, "Wrong size on ULethalPursuer");
static_assert(offsetof(ULethalPursuer, _survivorRevealDuration) == 0x000420, "Member 'ULethalPursuer::_survivorRevealDuration' has a wrong offset!");
static_assert(offsetof(ULethalPursuer, _timedRevealEffect) == 0x000430, "Member 'ULethalPursuer::_timedRevealEffect' has a wrong offset!");

// Class TheK24.SupplyCrateOutlineUpdateStrategy
// 0x0000 (0x00F0 - 0x00F0)
class USupplyCrateOutlineUpdateStrategy final : public UDefaultOutlineUpdateStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SupplyCrateOutlineUpdateStrategy">();
	}
	static class USupplyCrateOutlineUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<USupplyCrateOutlineUpdateStrategy>();
	}
};
static_assert(alignof(USupplyCrateOutlineUpdateStrategy) == 0x000008, "Wrong alignment on USupplyCrateOutlineUpdateStrategy");
static_assert(sizeof(USupplyCrateOutlineUpdateStrategy) == 0x0000F0, "Wrong size on USupplyCrateOutlineUpdateStrategy");

// Class TheK24.SurvivorContaminationComponent
// 0x0168 (0x0210 - 0x00A8)
class USurvivorContaminationComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x18];                                      // 0x00A8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTagStateBool                          _isContaminated;                                   // 0x00C0(0x0048)(Net, RepNotify, NativeAccessSpecifierPrivate)
	class UChargeableComponent*                   _injectSerumChargeable;                            // 0x0108(0x0008)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _injectSerumSecondsToCharge;                       // 0x0110(0x0028)(Edit, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _hinderedEffect;                                   // 0x0138(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _contaminationHinderedSeconds;                     // 0x0140(0x0080)(Edit, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _contaminationHinderedValue;                       // 0x01C0(0x0028)(Edit, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1E8[0x8];                                      // 0x01E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UInteractionDefinition>> _injectSerumInteractionsClasses;                   // 0x01F0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<class UInteractionDefinition*>         _injectSerumInteractions;                          // 0x0200(0x0010)(ExportObject, Net, ZeroConstructor, Transient, RepNotify, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	void Multicast_OnContaminated_Cosmetic(EContaminator Contaminator);
	void OnContaminated_Cosmetic(EContaminator Contaminator);
	void OnContaminated_SFX_Stinger_Cosmetic();
	void OnContaminationCured_Cosmetic();
	void OnRep_InjectSerumInteractions();
	void OnRep_IsContaminated();

	bool IsContaminated() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SurvivorContaminationComponent">();
	}
	static class USurvivorContaminationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USurvivorContaminationComponent>();
	}
};
static_assert(alignof(USurvivorContaminationComponent) == 0x000008, "Wrong alignment on USurvivorContaminationComponent");
static_assert(sizeof(USurvivorContaminationComponent) == 0x000210, "Wrong size on USurvivorContaminationComponent");
static_assert(offsetof(USurvivorContaminationComponent, _isContaminated) == 0x0000C0, "Member 'USurvivorContaminationComponent::_isContaminated' has a wrong offset!");
static_assert(offsetof(USurvivorContaminationComponent, _injectSerumChargeable) == 0x000108, "Member 'USurvivorContaminationComponent::_injectSerumChargeable' has a wrong offset!");
static_assert(offsetof(USurvivorContaminationComponent, _injectSerumSecondsToCharge) == 0x000110, "Member 'USurvivorContaminationComponent::_injectSerumSecondsToCharge' has a wrong offset!");
static_assert(offsetof(USurvivorContaminationComponent, _hinderedEffect) == 0x000138, "Member 'USurvivorContaminationComponent::_hinderedEffect' has a wrong offset!");
static_assert(offsetof(USurvivorContaminationComponent, _contaminationHinderedSeconds) == 0x000140, "Member 'USurvivorContaminationComponent::_contaminationHinderedSeconds' has a wrong offset!");
static_assert(offsetof(USurvivorContaminationComponent, _contaminationHinderedValue) == 0x0001C0, "Member 'USurvivorContaminationComponent::_contaminationHinderedValue' has a wrong offset!");
static_assert(offsetof(USurvivorContaminationComponent, _injectSerumInteractionsClasses) == 0x0001F0, "Member 'USurvivorContaminationComponent::_injectSerumInteractionsClasses' has a wrong offset!");
static_assert(offsetof(USurvivorContaminationComponent, _injectSerumInteractions) == 0x000200, "Member 'USurvivorContaminationComponent::_injectSerumInteractions' has a wrong offset!");

// Class TheK24.TheK24Utilities
// 0x0000 (0x0030 - 0x0030)
class UTheK24Utilities final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TheK24Utilities">();
	}
	static class UTheK24Utilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTheK24Utilities>();
	}
};
static_assert(alignof(UTheK24Utilities) == 0x000008, "Wrong alignment on UTheK24Utilities");
static_assert(sizeof(UTheK24Utilities) == 0x000030, "Wrong size on UTheK24Utilities");

// Class TheK24.ZombieAcquirePatrolAreaBTService
// 0x0000 (0x00A0 - 0x00A0)
class UZombieAcquirePatrolAreaBTService final : public UBTService_BlueprintBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ZombieAcquirePatrolAreaBTService">();
	}
	static class UZombieAcquirePatrolAreaBTService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UZombieAcquirePatrolAreaBTService>();
	}
};
static_assert(alignof(UZombieAcquirePatrolAreaBTService) == 0x000008, "Wrong alignment on UZombieAcquirePatrolAreaBTService");
static_assert(sizeof(UZombieAcquirePatrolAreaBTService) == 0x0000A0, "Wrong size on UZombieAcquirePatrolAreaBTService");

// Class TheK24.ZombieAcquireTargetBTService
// 0x0000 (0x00A0 - 0x00A0)
class UZombieAcquireTargetBTService final : public UBTService_BlueprintBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ZombieAcquireTargetBTService">();
	}
	static class UZombieAcquireTargetBTService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UZombieAcquireTargetBTService>();
	}
};
static_assert(alignof(UZombieAcquireTargetBTService) == 0x000008, "Wrong alignment on UZombieAcquireTargetBTService");
static_assert(sizeof(UZombieAcquireTargetBTService) == 0x0000A0, "Wrong size on UZombieAcquireTargetBTService");

// Class TheK24.ZombieAIController
// 0x0300 (0x06D0 - 0x03D0)
class AZombieAIController final : public AAIController
{
public:
	uint8                                         Pad_3D0[0x20];                                     // 0x03D0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UBehaviorTree*                          _zombieBehaviorTree;                               // 0x03F0(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAIPerceptionComponent*                 _aiPerceptionComponent;                            // 0x03F8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_400[0x8];                                      // 0x0400(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ACamperPlayer*>                  _survivorInVision;                                 // 0x0408(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class ACamperPlayer*                          _chaseTargetSurvivor;                              // 0x0418(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                _goToLocation;                                     // 0x0420(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AMeatHook*                              _patrolArea;                                       // 0x0438(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class ACamperPlayer*>                  _survivorsInAttackDetector;                        // 0x0440(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<struct FGameplayTag>                   _cannotChaseWhileIdleTags;                         // 0x0450(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _zombieAttackHitTime;                              // 0x0460(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _zombieAttackOpenTime;                             // 0x0488(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _zombieAnimSpawnTime;                              // 0x04B0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _zombieAnimDyingTime;                              // 0x04D8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _zombieSightRadius;                                // 0x0500(0x0080)(Edit, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _zombieLoseSightRadius;                            // 0x0580(0x0080)(Edit, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _zombieVisionHalfAngle;                            // 0x0600(0x0080)(Edit, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _zombieFallSmashTime;                              // 0x0680(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _zombieAttackCooldownTime;                         // 0x06A8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	void Authority_OnTargetPerceptionUpdated(class AActor* Actor, const struct FAIStimulus& Stimulus);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ZombieAIController">();
	}
	static class AZombieAIController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AZombieAIController>();
	}
};
static_assert(alignof(AZombieAIController) == 0x000008, "Wrong alignment on AZombieAIController");
static_assert(sizeof(AZombieAIController) == 0x0006D0, "Wrong size on AZombieAIController");
static_assert(offsetof(AZombieAIController, _zombieBehaviorTree) == 0x0003F0, "Member 'AZombieAIController::_zombieBehaviorTree' has a wrong offset!");
static_assert(offsetof(AZombieAIController, _aiPerceptionComponent) == 0x0003F8, "Member 'AZombieAIController::_aiPerceptionComponent' has a wrong offset!");
static_assert(offsetof(AZombieAIController, _survivorInVision) == 0x000408, "Member 'AZombieAIController::_survivorInVision' has a wrong offset!");
static_assert(offsetof(AZombieAIController, _chaseTargetSurvivor) == 0x000418, "Member 'AZombieAIController::_chaseTargetSurvivor' has a wrong offset!");
static_assert(offsetof(AZombieAIController, _goToLocation) == 0x000420, "Member 'AZombieAIController::_goToLocation' has a wrong offset!");
static_assert(offsetof(AZombieAIController, _patrolArea) == 0x000438, "Member 'AZombieAIController::_patrolArea' has a wrong offset!");
static_assert(offsetof(AZombieAIController, _survivorsInAttackDetector) == 0x000440, "Member 'AZombieAIController::_survivorsInAttackDetector' has a wrong offset!");
static_assert(offsetof(AZombieAIController, _cannotChaseWhileIdleTags) == 0x000450, "Member 'AZombieAIController::_cannotChaseWhileIdleTags' has a wrong offset!");
static_assert(offsetof(AZombieAIController, _zombieAttackHitTime) == 0x000460, "Member 'AZombieAIController::_zombieAttackHitTime' has a wrong offset!");
static_assert(offsetof(AZombieAIController, _zombieAttackOpenTime) == 0x000488, "Member 'AZombieAIController::_zombieAttackOpenTime' has a wrong offset!");
static_assert(offsetof(AZombieAIController, _zombieAnimSpawnTime) == 0x0004B0, "Member 'AZombieAIController::_zombieAnimSpawnTime' has a wrong offset!");
static_assert(offsetof(AZombieAIController, _zombieAnimDyingTime) == 0x0004D8, "Member 'AZombieAIController::_zombieAnimDyingTime' has a wrong offset!");
static_assert(offsetof(AZombieAIController, _zombieSightRadius) == 0x000500, "Member 'AZombieAIController::_zombieSightRadius' has a wrong offset!");
static_assert(offsetof(AZombieAIController, _zombieLoseSightRadius) == 0x000580, "Member 'AZombieAIController::_zombieLoseSightRadius' has a wrong offset!");
static_assert(offsetof(AZombieAIController, _zombieVisionHalfAngle) == 0x000600, "Member 'AZombieAIController::_zombieVisionHalfAngle' has a wrong offset!");
static_assert(offsetof(AZombieAIController, _zombieFallSmashTime) == 0x000680, "Member 'AZombieAIController::_zombieFallSmashTime' has a wrong offset!");
static_assert(offsetof(AZombieAIController, _zombieAttackCooldownTime) == 0x0006A8, "Member 'AZombieAIController::_zombieAttackCooldownTime' has a wrong offset!");

// Class TheK24.ZombieAnimInstance
// 0x00A0 (0x03F0 - 0x0350)
class UZombieAnimInstance final : public UAnimInstance
{
public:
	bool                                          _isChasing;                                        // 0x0350(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_351[0x3];                                      // 0x0351(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _chaseLocomotionPlayRate;                          // 0x0354(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _chaseSequenceMaxSpeed;                            // 0x0358(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _chaseLocomotionIndex;                             // 0x035C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _chaseLocomotionMaxIndex;                          // 0x0360(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FFloatRange                            _chaseLocomotionIndexChangeTimerDurationRange;     // 0x0364(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isUsingFirstChaseLocomotionPlayer;                // 0x0374(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isAttacking;                                      // 0x0375(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_376[0x2];                                      // 0x0376(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _attackIndex;                                      // 0x0378(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _maxAttackIndex;                                   // 0x037C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isPatrollingOrSearching;                          // 0x0380(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isStunned;                                        // 0x0381(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isDying;                                          // 0x0382(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isSpawning;                                       // 0x0383(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isInPool;                                         // 0x0384(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_385[0x3];                                      // 0x0385(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class AZombieCharacter*                       _zombieCharacter;                                  // 0x0388(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _speed;                                            // 0x0390(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isMoving;                                         // 0x0394(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isFalling;                                        // 0x0395(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isMale;                                           // 0x0396(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_397[0x1];                                      // 0x0397(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _currentDirection;                                 // 0x0398(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_39C[0x4];                                      // 0x039C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               _currentRotation;                                  // 0x03A0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         _rotationInterpolationSpeed;                       // 0x03B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _rotationInterpolationSpeedDuringChase;            // 0x03BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C0[0x30];                                     // 0x03C0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ZombieAnimInstance">();
	}
	static class UZombieAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UZombieAnimInstance>();
	}
};
static_assert(alignof(UZombieAnimInstance) == 0x000010, "Wrong alignment on UZombieAnimInstance");
static_assert(sizeof(UZombieAnimInstance) == 0x0003F0, "Wrong size on UZombieAnimInstance");
static_assert(offsetof(UZombieAnimInstance, _isChasing) == 0x000350, "Member 'UZombieAnimInstance::_isChasing' has a wrong offset!");
static_assert(offsetof(UZombieAnimInstance, _chaseLocomotionPlayRate) == 0x000354, "Member 'UZombieAnimInstance::_chaseLocomotionPlayRate' has a wrong offset!");
static_assert(offsetof(UZombieAnimInstance, _chaseSequenceMaxSpeed) == 0x000358, "Member 'UZombieAnimInstance::_chaseSequenceMaxSpeed' has a wrong offset!");
static_assert(offsetof(UZombieAnimInstance, _chaseLocomotionIndex) == 0x00035C, "Member 'UZombieAnimInstance::_chaseLocomotionIndex' has a wrong offset!");
static_assert(offsetof(UZombieAnimInstance, _chaseLocomotionMaxIndex) == 0x000360, "Member 'UZombieAnimInstance::_chaseLocomotionMaxIndex' has a wrong offset!");
static_assert(offsetof(UZombieAnimInstance, _chaseLocomotionIndexChangeTimerDurationRange) == 0x000364, "Member 'UZombieAnimInstance::_chaseLocomotionIndexChangeTimerDurationRange' has a wrong offset!");
static_assert(offsetof(UZombieAnimInstance, _isUsingFirstChaseLocomotionPlayer) == 0x000374, "Member 'UZombieAnimInstance::_isUsingFirstChaseLocomotionPlayer' has a wrong offset!");
static_assert(offsetof(UZombieAnimInstance, _isAttacking) == 0x000375, "Member 'UZombieAnimInstance::_isAttacking' has a wrong offset!");
static_assert(offsetof(UZombieAnimInstance, _attackIndex) == 0x000378, "Member 'UZombieAnimInstance::_attackIndex' has a wrong offset!");
static_assert(offsetof(UZombieAnimInstance, _maxAttackIndex) == 0x00037C, "Member 'UZombieAnimInstance::_maxAttackIndex' has a wrong offset!");
static_assert(offsetof(UZombieAnimInstance, _isPatrollingOrSearching) == 0x000380, "Member 'UZombieAnimInstance::_isPatrollingOrSearching' has a wrong offset!");
static_assert(offsetof(UZombieAnimInstance, _isStunned) == 0x000381, "Member 'UZombieAnimInstance::_isStunned' has a wrong offset!");
static_assert(offsetof(UZombieAnimInstance, _isDying) == 0x000382, "Member 'UZombieAnimInstance::_isDying' has a wrong offset!");
static_assert(offsetof(UZombieAnimInstance, _isSpawning) == 0x000383, "Member 'UZombieAnimInstance::_isSpawning' has a wrong offset!");
static_assert(offsetof(UZombieAnimInstance, _isInPool) == 0x000384, "Member 'UZombieAnimInstance::_isInPool' has a wrong offset!");
static_assert(offsetof(UZombieAnimInstance, _zombieCharacter) == 0x000388, "Member 'UZombieAnimInstance::_zombieCharacter' has a wrong offset!");
static_assert(offsetof(UZombieAnimInstance, _speed) == 0x000390, "Member 'UZombieAnimInstance::_speed' has a wrong offset!");
static_assert(offsetof(UZombieAnimInstance, _isMoving) == 0x000394, "Member 'UZombieAnimInstance::_isMoving' has a wrong offset!");
static_assert(offsetof(UZombieAnimInstance, _isFalling) == 0x000395, "Member 'UZombieAnimInstance::_isFalling' has a wrong offset!");
static_assert(offsetof(UZombieAnimInstance, _isMale) == 0x000396, "Member 'UZombieAnimInstance::_isMale' has a wrong offset!");
static_assert(offsetof(UZombieAnimInstance, _currentDirection) == 0x000398, "Member 'UZombieAnimInstance::_currentDirection' has a wrong offset!");
static_assert(offsetof(UZombieAnimInstance, _currentRotation) == 0x0003A0, "Member 'UZombieAnimInstance::_currentRotation' has a wrong offset!");
static_assert(offsetof(UZombieAnimInstance, _rotationInterpolationSpeed) == 0x0003B8, "Member 'UZombieAnimInstance::_rotationInterpolationSpeed' has a wrong offset!");
static_assert(offsetof(UZombieAnimInstance, _rotationInterpolationSpeedDuringChase) == 0x0003BC, "Member 'UZombieAnimInstance::_rotationInterpolationSpeedDuringChase' has a wrong offset!");

// Class TheK24.ZombieAttackSurvivorBTTask
// 0x0000 (0x00B0 - 0x00B0)
class UZombieAttackSurvivorBTTask final : public UBTTask_BlueprintBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ZombieAttackSurvivorBTTask">();
	}
	static class UZombieAttackSurvivorBTTask* GetDefaultObj()
	{
		return GetDefaultObjImpl<UZombieAttackSurvivorBTTask>();
	}
};
static_assert(alignof(UZombieAttackSurvivorBTTask) == 0x000008, "Wrong alignment on UZombieAttackSurvivorBTTask");
static_assert(sizeof(UZombieAttackSurvivorBTTask) == 0x0000B0, "Wrong size on UZombieAttackSurvivorBTTask");

// Class TheK24.ZombieAttractedByGeneratorBTService
// 0x0028 (0x00C8 - 0x00A0)
class UZombieAttractedByGeneratorBTService final : public UBTService_BlueprintBase
{
public:
	float                                         _genRepairingHearingRange;                         // 0x00A0(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A4[0x24];                                      // 0x00A4(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnInRangeChanged(const bool InRange, class AGenerator* Generator);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ZombieAttractedByGeneratorBTService">();
	}
	static class UZombieAttractedByGeneratorBTService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UZombieAttractedByGeneratorBTService>();
	}
};
static_assert(alignof(UZombieAttractedByGeneratorBTService) == 0x000008, "Wrong alignment on UZombieAttractedByGeneratorBTService");
static_assert(sizeof(UZombieAttractedByGeneratorBTService) == 0x0000C8, "Wrong size on UZombieAttractedByGeneratorBTService");
static_assert(offsetof(UZombieAttractedByGeneratorBTService, _genRepairingHearingRange) == 0x0000A0, "Member 'UZombieAttractedByGeneratorBTService::_genRepairingHearingRange' has a wrong offset!");

// Class TheK24.ZombieBlindableComponent
// 0x0008 (0x0268 - 0x0260)
class UZombieBlindableComponent final : public UBlindableBaseComponent
{
public:
	class UGameplayTagContainerComponent*         _ownerObjectState;                                 // 0x0260(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ZombieBlindableComponent">();
	}
	static class UZombieBlindableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UZombieBlindableComponent>();
	}
};
static_assert(alignof(UZombieBlindableComponent) == 0x000008, "Wrong alignment on UZombieBlindableComponent");
static_assert(sizeof(UZombieBlindableComponent) == 0x000268, "Wrong size on UZombieBlindableComponent");
static_assert(offsetof(UZombieBlindableComponent, _ownerObjectState) == 0x000260, "Member 'UZombieBlindableComponent::_ownerObjectState' has a wrong offset!");

// Class TheK24.ZombieChaseSurvivorTargetBTTask
// 0x0000 (0x00B0 - 0x00B0)
class UZombieChaseSurvivorTargetBTTask final : public UBTTask_BlueprintBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ZombieChaseSurvivorTargetBTTask">();
	}
	static class UZombieChaseSurvivorTargetBTTask* GetDefaultObj()
	{
		return GetDefaultObjImpl<UZombieChaseSurvivorTargetBTTask>();
	}
};
static_assert(alignof(UZombieChaseSurvivorTargetBTTask) == 0x000008, "Wrong alignment on UZombieChaseSurvivorTargetBTTask");
static_assert(sizeof(UZombieChaseSurvivorTargetBTTask) == 0x0000B0, "Wrong size on UZombieChaseSurvivorTargetBTTask");

// Class TheK24.ZombieFallDetectorComponent
// 0x0040 (0x00E8 - 0x00A8)
class UZombieFallDetectorComponent final : public UActorComponent
{
public:
	struct FDBDTunableRowHandle                   _zombieDistanceConsideredSmashFall;                // 0x00A8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D0[0x18];                                      // 0x00D0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnMovementModeChange(class ACharacter* Character, EMovementMode PrevMovementMode, uint8 PreviousCustomMode);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ZombieFallDetectorComponent">();
	}
	static class UZombieFallDetectorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UZombieFallDetectorComponent>();
	}
};
static_assert(alignof(UZombieFallDetectorComponent) == 0x000008, "Wrong alignment on UZombieFallDetectorComponent");
static_assert(sizeof(UZombieFallDetectorComponent) == 0x0000E8, "Wrong size on UZombieFallDetectorComponent");
static_assert(offsetof(UZombieFallDetectorComponent, _zombieDistanceConsideredSmashFall) == 0x0000A8, "Member 'UZombieFallDetectorComponent::_zombieDistanceConsideredSmashFall' has a wrong offset!");

// Class TheK24.ZombieOutlineUpdateStrategy
// 0x0008 (0x0150 - 0x0148)
class UZombieOutlineUpdateStrategy final : public USourceBasedOutlineUpdateStrategy
{
public:
	class AZombieCharacter*                       _zombieCharacter;                                  // 0x0148(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ZombieOutlineUpdateStrategy">();
	}
	static class UZombieOutlineUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UZombieOutlineUpdateStrategy>();
	}
};
static_assert(alignof(UZombieOutlineUpdateStrategy) == 0x000008, "Wrong alignment on UZombieOutlineUpdateStrategy");
static_assert(sizeof(UZombieOutlineUpdateStrategy) == 0x000150, "Wrong size on UZombieOutlineUpdateStrategy");
static_assert(offsetof(UZombieOutlineUpdateStrategy, _zombieCharacter) == 0x000148, "Member 'UZombieOutlineUpdateStrategy::_zombieCharacter' has a wrong offset!");

// Class TheK24.ZombieResurrector
// 0x0060 (0x0108 - 0x00A8)
class UZombieResurrector final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x10];                                      // 0x00A8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _powerLevelToSpawnZombie;                          // 0x00B8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E0[0x10];                                      // 0x00E0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AZombieCharacter*>               _delayedSpawnZombies;                              // 0x00F0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_100[0x8];                                      // 0x0100(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnKillerPowerLevelChanged(int32 Powerlevel);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ZombieResurrector">();
	}
	static class UZombieResurrector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UZombieResurrector>();
	}
};
static_assert(alignof(UZombieResurrector) == 0x000008, "Wrong alignment on UZombieResurrector");
static_assert(sizeof(UZombieResurrector) == 0x000108, "Wrong size on UZombieResurrector");
static_assert(offsetof(UZombieResurrector, _powerLevelToSpawnZombie) == 0x0000B8, "Member 'UZombieResurrector::_powerLevelToSpawnZombie' has a wrong offset!");
static_assert(offsetof(UZombieResurrector, _delayedSpawnZombies) == 0x0000F0, "Member 'UZombieResurrector::_delayedSpawnZombies' has a wrong offset!");

// Class TheK24.ZombieRotateTowardsTargetBTTask
// 0x0000 (0x00B0 - 0x00B0)
class UZombieRotateTowardsTargetBTTask final : public UBTTask_BlueprintBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ZombieRotateTowardsTargetBTTask">();
	}
	static class UZombieRotateTowardsTargetBTTask* GetDefaultObj()
	{
		return GetDefaultObjImpl<UZombieRotateTowardsTargetBTTask>();
	}
};
static_assert(alignof(UZombieRotateTowardsTargetBTTask) == 0x000008, "Wrong alignment on UZombieRotateTowardsTargetBTTask");
static_assert(sizeof(UZombieRotateTowardsTargetBTTask) == 0x0000B0, "Wrong size on UZombieRotateTowardsTargetBTTask");

// Class TheK24.ZombiesInterestEventManager
// 0x0028 (0x00D0 - 0x00A8)
class UZombiesInterestEventManager final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x10];                                      // 0x00A8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameplayTag>                   _zombieInterestEvents;                             // 0x00B8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C8[0x8];                                       // 0x00C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnLoudNoiseTriggered(class AActor* Originator, class AActor* InstigatingActor, const struct FVector& Location, bool ShouldTrack, float* AudibleRange, bool IsQuickAction, bool IsDeceivingNoise);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ZombiesInterestEventManager">();
	}
	static class UZombiesInterestEventManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UZombiesInterestEventManager>();
	}
};
static_assert(alignof(UZombiesInterestEventManager) == 0x000008, "Wrong alignment on UZombiesInterestEventManager");
static_assert(sizeof(UZombiesInterestEventManager) == 0x0000D0, "Wrong size on UZombiesInterestEventManager");
static_assert(offsetof(UZombiesInterestEventManager, _zombieInterestEvents) == 0x0000B8, "Member 'UZombiesInterestEventManager::_zombieInterestEvents' has a wrong offset!");

// Class TheK24.ZombiesPatrolAreaManager
// 0x0028 (0x00D0 - 0x00A8)
class UZombiesPatrolAreaManager final : public UActorComponent
{
public:
	TArray<class AMeatHook*>                      _availablePatrolAreas;                             // 0x00A8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class AMeatHook*>                      _usedPatrolAreas;                                  // 0x00B8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	float                                         _maxDistanceBetweenMeatHookAndPlayers;             // 0x00C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_CC[0x4];                                       // 0x00CC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ZombiesPatrolAreaManager">();
	}
	static class UZombiesPatrolAreaManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UZombiesPatrolAreaManager>();
	}
};
static_assert(alignof(UZombiesPatrolAreaManager) == 0x000008, "Wrong alignment on UZombiesPatrolAreaManager");
static_assert(sizeof(UZombiesPatrolAreaManager) == 0x0000D0, "Wrong size on UZombiesPatrolAreaManager");
static_assert(offsetof(UZombiesPatrolAreaManager, _availablePatrolAreas) == 0x0000A8, "Member 'UZombiesPatrolAreaManager::_availablePatrolAreas' has a wrong offset!");
static_assert(offsetof(UZombiesPatrolAreaManager, _usedPatrolAreas) == 0x0000B8, "Member 'UZombiesPatrolAreaManager::_usedPatrolAreas' has a wrong offset!");
static_assert(offsetof(UZombiesPatrolAreaManager, _maxDistanceBetweenMeatHookAndPlayers) == 0x0000C8, "Member 'UZombiesPatrolAreaManager::_maxDistanceBetweenMeatHookAndPlayers' has a wrong offset!");

}

