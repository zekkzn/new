#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: DBDBots

#include "Basic.hpp"

#include "AIModule_structs.hpp"
#include "AIModule_classes.hpp"
#include "DeadByDaylight_structs.hpp"
#include "DeadByDaylight_classes.hpp"
#include "GameplayTags_structs.hpp"
#include "DBDBots_structs.hpp"
#include "NavigationSystem_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "DBDSharedTypes_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"


namespace SDK
{

// Class DBDBots.AIPathValidatorInterface
// 0x0000 (0x0030 - 0x0030)
class IAIPathValidatorInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIPathValidatorInterface">();
	}
	static class IAIPathValidatorInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IAIPathValidatorInterface>();
	}
};
static_assert(alignof(IAIPathValidatorInterface) == 0x000008, "Wrong alignment on IAIPathValidatorInterface");
static_assert(sizeof(IAIPathValidatorInterface) == 0x000030, "Wrong size on IAIPathValidatorInterface");

// Class DBDBots.AISkill
// 0x00E8 (0x0118 - 0x0030)
class UAISkill : public UObject
{
public:
	struct FGameplayTagContainer                  RunContexts;                                       // 0x0030(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          StopIfPausedByNavLinkProxy;                        // 0x0050(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RunTimeLimit;                                      // 0x0054(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RunCooldownTime;                                   // 0x0058(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RunCooldownTimeDeviation;                          // 0x005C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UNavigationQueryFilter>     SkillNavigationFilterClass;                        // 0x0060(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UAISenseConfig*>                 SkillSenseConfigs;                                 // 0x0068(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FKillerFilterItem>              KillerFilter;                                      // 0x0078(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UBehaviorTree>           DynamicSubtree;                                    // 0x0088(0x0038)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FAdditionalDynamicSubtree>      AdditionalDynamicSubtrees;                         // 0x00C0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FAISkillContextWeights>         ContextWeights;                                    // 0x00D0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class UObject*>                        _pausedByObjects;                                  // 0x00E0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_F0[0x20];                                      // 0x00F0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class ADBDAIBTController*                     _aiControllerOwner;                                // 0x0110(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill">();
	}
	static class UAISkill* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill>();
	}
};
static_assert(alignof(UAISkill) == 0x000008, "Wrong alignment on UAISkill");
static_assert(sizeof(UAISkill) == 0x000118, "Wrong size on UAISkill");
static_assert(offsetof(UAISkill, RunContexts) == 0x000030, "Member 'UAISkill::RunContexts' has a wrong offset!");
static_assert(offsetof(UAISkill, StopIfPausedByNavLinkProxy) == 0x000050, "Member 'UAISkill::StopIfPausedByNavLinkProxy' has a wrong offset!");
static_assert(offsetof(UAISkill, RunTimeLimit) == 0x000054, "Member 'UAISkill::RunTimeLimit' has a wrong offset!");
static_assert(offsetof(UAISkill, RunCooldownTime) == 0x000058, "Member 'UAISkill::RunCooldownTime' has a wrong offset!");
static_assert(offsetof(UAISkill, RunCooldownTimeDeviation) == 0x00005C, "Member 'UAISkill::RunCooldownTimeDeviation' has a wrong offset!");
static_assert(offsetof(UAISkill, SkillNavigationFilterClass) == 0x000060, "Member 'UAISkill::SkillNavigationFilterClass' has a wrong offset!");
static_assert(offsetof(UAISkill, SkillSenseConfigs) == 0x000068, "Member 'UAISkill::SkillSenseConfigs' has a wrong offset!");
static_assert(offsetof(UAISkill, KillerFilter) == 0x000078, "Member 'UAISkill::KillerFilter' has a wrong offset!");
static_assert(offsetof(UAISkill, DynamicSubtree) == 0x000088, "Member 'UAISkill::DynamicSubtree' has a wrong offset!");
static_assert(offsetof(UAISkill, AdditionalDynamicSubtrees) == 0x0000C0, "Member 'UAISkill::AdditionalDynamicSubtrees' has a wrong offset!");
static_assert(offsetof(UAISkill, ContextWeights) == 0x0000D0, "Member 'UAISkill::ContextWeights' has a wrong offset!");
static_assert(offsetof(UAISkill, _pausedByObjects) == 0x0000E0, "Member 'UAISkill::_pausedByObjects' has a wrong offset!");
static_assert(offsetof(UAISkill, _aiControllerOwner) == 0x000110, "Member 'UAISkill::_aiControllerOwner' has a wrong offset!");

// Class DBDBots.AISkill_Interaction
// 0x0168 (0x0280 - 0x0118)
class UAISkill_Interaction : public UAISkill
{
public:
	EPawnInputPressTypes                          InputType;                                         // 0x0118(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInteractionSkillInputModes                   InputMode;                                         // 0x0119(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPawnInputPressTypes                          CancelInputType;                                   // 0x011A(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInteractionCancelInputModes                  CancelInputMode;                                   // 0x011B(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AutoLockInput;                                     // 0x011C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11D[0x3];                                      // 0x011D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAIRoll                                StartRoll;                                         // 0x0120(0x00C8)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FString                                 StartInteractionID;                                // 0x01E8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         AdditionalStartInteractionIDs;                     // 0x01F8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FString                                 StopInteractionID;                                 // 0x0208(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinHoldInputTime;                                  // 0x0218(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AutoReleaseHoldInputWhenCharged;                   // 0x021C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21D[0x63];                                     // 0x021D(0x0063)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_Interaction">();
	}
	static class UAISkill_Interaction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_Interaction>();
	}
};
static_assert(alignof(UAISkill_Interaction) == 0x000008, "Wrong alignment on UAISkill_Interaction");
static_assert(sizeof(UAISkill_Interaction) == 0x000280, "Wrong size on UAISkill_Interaction");
static_assert(offsetof(UAISkill_Interaction, InputType) == 0x000118, "Member 'UAISkill_Interaction::InputType' has a wrong offset!");
static_assert(offsetof(UAISkill_Interaction, InputMode) == 0x000119, "Member 'UAISkill_Interaction::InputMode' has a wrong offset!");
static_assert(offsetof(UAISkill_Interaction, CancelInputType) == 0x00011A, "Member 'UAISkill_Interaction::CancelInputType' has a wrong offset!");
static_assert(offsetof(UAISkill_Interaction, CancelInputMode) == 0x00011B, "Member 'UAISkill_Interaction::CancelInputMode' has a wrong offset!");
static_assert(offsetof(UAISkill_Interaction, AutoLockInput) == 0x00011C, "Member 'UAISkill_Interaction::AutoLockInput' has a wrong offset!");
static_assert(offsetof(UAISkill_Interaction, StartRoll) == 0x000120, "Member 'UAISkill_Interaction::StartRoll' has a wrong offset!");
static_assert(offsetof(UAISkill_Interaction, StartInteractionID) == 0x0001E8, "Member 'UAISkill_Interaction::StartInteractionID' has a wrong offset!");
static_assert(offsetof(UAISkill_Interaction, AdditionalStartInteractionIDs) == 0x0001F8, "Member 'UAISkill_Interaction::AdditionalStartInteractionIDs' has a wrong offset!");
static_assert(offsetof(UAISkill_Interaction, StopInteractionID) == 0x000208, "Member 'UAISkill_Interaction::StopInteractionID' has a wrong offset!");
static_assert(offsetof(UAISkill_Interaction, MinHoldInputTime) == 0x000218, "Member 'UAISkill_Interaction::MinHoldInputTime' has a wrong offset!");
static_assert(offsetof(UAISkill_Interaction, AutoReleaseHoldInputWhenCharged) == 0x00021C, "Member 'UAISkill_Interaction::AutoReleaseHoldInputWhenCharged' has a wrong offset!");

// Class DBDBots.AISkill_InteractionUseItem
// 0x0010 (0x0290 - 0x0280)
class UAISkill_InteractionUseItem : public UAISkill_Interaction
{
public:
	ELoadoutItemType                              ItemType;                                          // 0x0280(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_281[0x7];                                      // 0x0281(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ACollectable>               ItemClass;                                         // 0x0288(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_InteractionUseItem">();
	}
	static class UAISkill_InteractionUseItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_InteractionUseItem>();
	}
};
static_assert(alignof(UAISkill_InteractionUseItem) == 0x000008, "Wrong alignment on UAISkill_InteractionUseItem");
static_assert(sizeof(UAISkill_InteractionUseItem) == 0x000290, "Wrong size on UAISkill_InteractionUseItem");
static_assert(offsetof(UAISkill_InteractionUseItem, ItemType) == 0x000280, "Member 'UAISkill_InteractionUseItem::ItemType' has a wrong offset!");
static_assert(offsetof(UAISkill_InteractionUseItem, ItemClass) == 0x000288, "Member 'UAISkill_InteractionUseItem::ItemClass' has a wrong offset!");

// Class DBDBots.AISkill_Find
// 0x01D8 (0x02F0 - 0x0118)
class UAISkill_Find : public UAISkill
{
public:
	TSoftClassPtr<class UClass>                   FindClass;                                         // 0x0118(0x0038)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           BlackboardWishListTag;                             // 0x0150(0x000C)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SearchInterval;                                    // 0x015C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MustBeSeen;                                        // 0x0160(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RejectIfWasInCooldownAndFocusedOnAnotherObject;    // 0x0161(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IgnoreMindFocusCooldown;                           // 0x0162(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AbandonIfInChase;                                  // 0x0163(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RejectIfInPressureZone;                            // 0x0164(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RejectIfNotFocusedBySelf;                          // 0x0165(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RejectIfInteractableFocusedByOther;                // 0x0166(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UsesActorLocation;                                 // 0x0167(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ActorLocationOffset;                               // 0x0168(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    GoalBasicWeight;                                   // 0x0180(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    GoalWeightMaxDistance;                             // 0x01E0(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    GoalWeightAtMinDistance;                           // 0x0240(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         SearchHeightAmplifier;                             // 0x02A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SearchHeightAmplifierActivationHeight;             // 0x02A4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsUnsafeAction;                                    // 0x02A8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A9[0x7];                                      // 0x02A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 UnsafeInteractionID;                               // 0x02B0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UnsafeActionUsesItemAddons;                        // 0x02C0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UnsafeActionIsSelfInteraction;                     // 0x02C1(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C2[0x2];                                      // 0x02C2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UnsafeActionRange;                                 // 0x02C4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UObject*>                        _currentWishedObjects;                             // 0x02C8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D8[0x18];                                     // 0x02D8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_Find">();
	}
	static class UAISkill_Find* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_Find>();
	}
};
static_assert(alignof(UAISkill_Find) == 0x000008, "Wrong alignment on UAISkill_Find");
static_assert(sizeof(UAISkill_Find) == 0x0002F0, "Wrong size on UAISkill_Find");
static_assert(offsetof(UAISkill_Find, FindClass) == 0x000118, "Member 'UAISkill_Find::FindClass' has a wrong offset!");
static_assert(offsetof(UAISkill_Find, BlackboardWishListTag) == 0x000150, "Member 'UAISkill_Find::BlackboardWishListTag' has a wrong offset!");
static_assert(offsetof(UAISkill_Find, SearchInterval) == 0x00015C, "Member 'UAISkill_Find::SearchInterval' has a wrong offset!");
static_assert(offsetof(UAISkill_Find, MustBeSeen) == 0x000160, "Member 'UAISkill_Find::MustBeSeen' has a wrong offset!");
static_assert(offsetof(UAISkill_Find, RejectIfWasInCooldownAndFocusedOnAnotherObject) == 0x000161, "Member 'UAISkill_Find::RejectIfWasInCooldownAndFocusedOnAnotherObject' has a wrong offset!");
static_assert(offsetof(UAISkill_Find, IgnoreMindFocusCooldown) == 0x000162, "Member 'UAISkill_Find::IgnoreMindFocusCooldown' has a wrong offset!");
static_assert(offsetof(UAISkill_Find, AbandonIfInChase) == 0x000163, "Member 'UAISkill_Find::AbandonIfInChase' has a wrong offset!");
static_assert(offsetof(UAISkill_Find, RejectIfInPressureZone) == 0x000164, "Member 'UAISkill_Find::RejectIfInPressureZone' has a wrong offset!");
static_assert(offsetof(UAISkill_Find, RejectIfNotFocusedBySelf) == 0x000165, "Member 'UAISkill_Find::RejectIfNotFocusedBySelf' has a wrong offset!");
static_assert(offsetof(UAISkill_Find, RejectIfInteractableFocusedByOther) == 0x000166, "Member 'UAISkill_Find::RejectIfInteractableFocusedByOther' has a wrong offset!");
static_assert(offsetof(UAISkill_Find, UsesActorLocation) == 0x000167, "Member 'UAISkill_Find::UsesActorLocation' has a wrong offset!");
static_assert(offsetof(UAISkill_Find, ActorLocationOffset) == 0x000168, "Member 'UAISkill_Find::ActorLocationOffset' has a wrong offset!");
static_assert(offsetof(UAISkill_Find, GoalBasicWeight) == 0x000180, "Member 'UAISkill_Find::GoalBasicWeight' has a wrong offset!");
static_assert(offsetof(UAISkill_Find, GoalWeightMaxDistance) == 0x0001E0, "Member 'UAISkill_Find::GoalWeightMaxDistance' has a wrong offset!");
static_assert(offsetof(UAISkill_Find, GoalWeightAtMinDistance) == 0x000240, "Member 'UAISkill_Find::GoalWeightAtMinDistance' has a wrong offset!");
static_assert(offsetof(UAISkill_Find, SearchHeightAmplifier) == 0x0002A0, "Member 'UAISkill_Find::SearchHeightAmplifier' has a wrong offset!");
static_assert(offsetof(UAISkill_Find, SearchHeightAmplifierActivationHeight) == 0x0002A4, "Member 'UAISkill_Find::SearchHeightAmplifierActivationHeight' has a wrong offset!");
static_assert(offsetof(UAISkill_Find, IsUnsafeAction) == 0x0002A8, "Member 'UAISkill_Find::IsUnsafeAction' has a wrong offset!");
static_assert(offsetof(UAISkill_Find, UnsafeInteractionID) == 0x0002B0, "Member 'UAISkill_Find::UnsafeInteractionID' has a wrong offset!");
static_assert(offsetof(UAISkill_Find, UnsafeActionUsesItemAddons) == 0x0002C0, "Member 'UAISkill_Find::UnsafeActionUsesItemAddons' has a wrong offset!");
static_assert(offsetof(UAISkill_Find, UnsafeActionIsSelfInteraction) == 0x0002C1, "Member 'UAISkill_Find::UnsafeActionIsSelfInteraction' has a wrong offset!");
static_assert(offsetof(UAISkill_Find, UnsafeActionRange) == 0x0002C4, "Member 'UAISkill_Find::UnsafeActionRange' has a wrong offset!");
static_assert(offsetof(UAISkill_Find, _currentWishedObjects) == 0x0002C8, "Member 'UAISkill_Find::_currentWishedObjects' has a wrong offset!");

// Class DBDBots.AISkill_FindInteractable
// 0x0018 (0x0308 - 0x02F0)
class UAISkill_FindInteractable : public UAISkill_Find
{
public:
	class FString                                 RequiredInteractionId;                             // 0x02F0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInputInteractionType                         RequiredInteractionInputType;                      // 0x0300(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_301[0x7];                                      // 0x0301(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_FindInteractable">();
	}
	static class UAISkill_FindInteractable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_FindInteractable>();
	}
};
static_assert(alignof(UAISkill_FindInteractable) == 0x000008, "Wrong alignment on UAISkill_FindInteractable");
static_assert(sizeof(UAISkill_FindInteractable) == 0x000308, "Wrong size on UAISkill_FindInteractable");
static_assert(offsetof(UAISkill_FindInteractable, RequiredInteractionId) == 0x0002F0, "Member 'UAISkill_FindInteractable::RequiredInteractionId' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable, RequiredInteractionInputType) == 0x000300, "Member 'UAISkill_FindInteractable::RequiredInteractionInputType' has a wrong offset!");

// Class DBDBots.AISkill_FindCollectable
// 0x0070 (0x0378 - 0x0308)
class UAISkill_FindCollectable : public UAISkill_FindInteractable
{
public:
	float                                         CollectUnderItemRatio;                             // 0x0308(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CollectOverItemChargeRatio;                        // 0x030C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    GoalItemCountBonusWeight;                          // 0x0310(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          ItemMustHaveNormalPickupFlow;                      // 0x0370(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_371[0x7];                                      // 0x0371(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_FindCollectable">();
	}
	static class UAISkill_FindCollectable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_FindCollectable>();
	}
};
static_assert(alignof(UAISkill_FindCollectable) == 0x000008, "Wrong alignment on UAISkill_FindCollectable");
static_assert(sizeof(UAISkill_FindCollectable) == 0x000378, "Wrong size on UAISkill_FindCollectable");
static_assert(offsetof(UAISkill_FindCollectable, CollectUnderItemRatio) == 0x000308, "Member 'UAISkill_FindCollectable::CollectUnderItemRatio' has a wrong offset!");
static_assert(offsetof(UAISkill_FindCollectable, CollectOverItemChargeRatio) == 0x00030C, "Member 'UAISkill_FindCollectable::CollectOverItemChargeRatio' has a wrong offset!");
static_assert(offsetof(UAISkill_FindCollectable, GoalItemCountBonusWeight) == 0x000310, "Member 'UAISkill_FindCollectable::GoalItemCountBonusWeight' has a wrong offset!");
static_assert(offsetof(UAISkill_FindCollectable, ItemMustHaveNormalPickupFlow) == 0x000370, "Member 'UAISkill_FindCollectable::ItemMustHaveNormalPickupFlow' has a wrong offset!");

// Class DBDBots.AISkill_FindCollectable_Hatchet
// 0x0000 (0x0378 - 0x0378)
class UAISkill_FindCollectable_Hatchet final : public UAISkill_FindCollectable
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_FindCollectable_Hatchet">();
	}
	static class UAISkill_FindCollectable_Hatchet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_FindCollectable_Hatchet>();
	}
};
static_assert(alignof(UAISkill_FindCollectable_Hatchet) == 0x000008, "Wrong alignment on UAISkill_FindCollectable_Hatchet");
static_assert(sizeof(UAISkill_FindCollectable_Hatchet) == 0x000378, "Wrong size on UAISkill_FindCollectable_Hatchet");

// Class DBDBots.AISkill_Interaction_QuietMode
// 0x0000 (0x0280 - 0x0280)
class UAISkill_Interaction_QuietMode final : public UAISkill_Interaction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_Interaction_QuietMode">();
	}
	static class UAISkill_Interaction_QuietMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_Interaction_QuietMode>();
	}
};
static_assert(alignof(UAISkill_Interaction_QuietMode) == 0x000008, "Wrong alignment on UAISkill_Interaction_QuietMode");
static_assert(sizeof(UAISkill_Interaction_QuietMode) == 0x000280, "Wrong size on UAISkill_Interaction_QuietMode");

// Class DBDBots.AISkill_CharacterClass
// 0x0000 (0x0118 - 0x0118)
class UAISkill_CharacterClass final : public UAISkill
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_CharacterClass">();
	}
	static class UAISkill_CharacterClass* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_CharacterClass>();
	}
};
static_assert(alignof(UAISkill_CharacterClass) == 0x000008, "Wrong alignment on UAISkill_CharacterClass");
static_assert(sizeof(UAISkill_CharacterClass) == 0x000118, "Wrong size on UAISkill_CharacterClass");

// Class DBDBots.AISkill_BuiltToLast
// 0x0030 (0x0148 - 0x0118)
class UAISkill_BuiltToLast final : public UAISkill
{
public:
	struct FDataTableDropdown                     PerkId;                                            // 0x0118(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_BuiltToLast">();
	}
	static class UAISkill_BuiltToLast* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_BuiltToLast>();
	}
};
static_assert(alignof(UAISkill_BuiltToLast) == 0x000008, "Wrong alignment on UAISkill_BuiltToLast");
static_assert(sizeof(UAISkill_BuiltToLast) == 0x000148, "Wrong size on UAISkill_BuiltToLast");
static_assert(offsetof(UAISkill_BuiltToLast, PerkId) == 0x000118, "Member 'UAISkill_BuiltToLast::PerkId' has a wrong offset!");

// Class DBDBots.BTDecorator_TickableBase
// 0x0000 (0x0070 - 0x0070)
class UBTDecorator_TickableBase : public UBTDecorator
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_TickableBase">();
	}
	static class UBTDecorator_TickableBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_TickableBase>();
	}
};
static_assert(alignof(UBTDecorator_TickableBase) == 0x000008, "Wrong alignment on UBTDecorator_TickableBase");
static_assert(sizeof(UBTDecorator_TickableBase) == 0x000070, "Wrong size on UBTDecorator_TickableBase");

// Class DBDBots.BTDecorator_RandomByDistance
// 0x0220 (0x0290 - 0x0070)
class UBTDecorator_RandomByDistance final : public UBTDecorator_TickableBase
{
public:
	struct FBlackboardKeySelector                 BBAroundLoc;                                       // 0x0070(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBRelativeFromTime;                                // 0x00A0(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBRelativeToTime;                                  // 0x00D0(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    StartDistance;                                     // 0x0100(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    EndDistance;                                       // 0x0160(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    PercentageAtStartDistance;                         // 0x01C0(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    PercentageAtEndDistance;                           // 0x0220(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	TArray<struct FAIRandomByDistancePercentagesAtTime> PercentagesAtTimes;                                // 0x0280(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_RandomByDistance">();
	}
	static class UBTDecorator_RandomByDistance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_RandomByDistance>();
	}
};
static_assert(alignof(UBTDecorator_RandomByDistance) == 0x000008, "Wrong alignment on UBTDecorator_RandomByDistance");
static_assert(sizeof(UBTDecorator_RandomByDistance) == 0x000290, "Wrong size on UBTDecorator_RandomByDistance");
static_assert(offsetof(UBTDecorator_RandomByDistance, BBAroundLoc) == 0x000070, "Member 'UBTDecorator_RandomByDistance::BBAroundLoc' has a wrong offset!");
static_assert(offsetof(UBTDecorator_RandomByDistance, BBRelativeFromTime) == 0x0000A0, "Member 'UBTDecorator_RandomByDistance::BBRelativeFromTime' has a wrong offset!");
static_assert(offsetof(UBTDecorator_RandomByDistance, BBRelativeToTime) == 0x0000D0, "Member 'UBTDecorator_RandomByDistance::BBRelativeToTime' has a wrong offset!");
static_assert(offsetof(UBTDecorator_RandomByDistance, StartDistance) == 0x000100, "Member 'UBTDecorator_RandomByDistance::StartDistance' has a wrong offset!");
static_assert(offsetof(UBTDecorator_RandomByDistance, EndDistance) == 0x000160, "Member 'UBTDecorator_RandomByDistance::EndDistance' has a wrong offset!");
static_assert(offsetof(UBTDecorator_RandomByDistance, PercentageAtStartDistance) == 0x0001C0, "Member 'UBTDecorator_RandomByDistance::PercentageAtStartDistance' has a wrong offset!");
static_assert(offsetof(UBTDecorator_RandomByDistance, PercentageAtEndDistance) == 0x000220, "Member 'UBTDecorator_RandomByDistance::PercentageAtEndDistance' has a wrong offset!");
static_assert(offsetof(UBTDecorator_RandomByDistance, PercentagesAtTimes) == 0x000280, "Member 'UBTDecorator_RandomByDistance::PercentagesAtTimes' has a wrong offset!");

// Class DBDBots.AISkill_FindInteractable_K32ItemBox
// 0x0058 (0x0360 - 0x0308)
class UAISkill_FindInteractable_K32ItemBox final : public UAISkill_FindInteractable
{
public:
	class FName                                   BBK32EmpTargetActor;                               // 0x0308(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BBOriginalFocusedActor;                            // 0x0314(0x000C)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class AActor>>             GoalClassesToGiveAdditionalWeight;                 // 0x0320(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, UObjectWrapper, NativeAccessSpecifierPublic)
	float                                         EmpTargetNearGoalWeight;                           // 0x0330(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NearEmpBoxGoalWeight;                              // 0x0334(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NearEmpBoxDistance;                                // 0x0338(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         K32EmpMaxCount;                                    // 0x033C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         K32ItemBoxChargeWeightRatio;                       // 0x0340(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_344[0x1C];                                     // 0x0344(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_FindInteractable_K32ItemBox">();
	}
	static class UAISkill_FindInteractable_K32ItemBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_FindInteractable_K32ItemBox>();
	}
};
static_assert(alignof(UAISkill_FindInteractable_K32ItemBox) == 0x000008, "Wrong alignment on UAISkill_FindInteractable_K32ItemBox");
static_assert(sizeof(UAISkill_FindInteractable_K32ItemBox) == 0x000360, "Wrong size on UAISkill_FindInteractable_K32ItemBox");
static_assert(offsetof(UAISkill_FindInteractable_K32ItemBox, BBK32EmpTargetActor) == 0x000308, "Member 'UAISkill_FindInteractable_K32ItemBox::BBK32EmpTargetActor' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_K32ItemBox, BBOriginalFocusedActor) == 0x000314, "Member 'UAISkill_FindInteractable_K32ItemBox::BBOriginalFocusedActor' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_K32ItemBox, GoalClassesToGiveAdditionalWeight) == 0x000320, "Member 'UAISkill_FindInteractable_K32ItemBox::GoalClassesToGiveAdditionalWeight' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_K32ItemBox, EmpTargetNearGoalWeight) == 0x000330, "Member 'UAISkill_FindInteractable_K32ItemBox::EmpTargetNearGoalWeight' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_K32ItemBox, NearEmpBoxGoalWeight) == 0x000334, "Member 'UAISkill_FindInteractable_K32ItemBox::NearEmpBoxGoalWeight' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_K32ItemBox, NearEmpBoxDistance) == 0x000338, "Member 'UAISkill_FindInteractable_K32ItemBox::NearEmpBoxDistance' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_K32ItemBox, K32EmpMaxCount) == 0x00033C, "Member 'UAISkill_FindInteractable_K32ItemBox::K32EmpMaxCount' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_K32ItemBox, K32ItemBoxChargeWeightRatio) == 0x000340, "Member 'UAISkill_FindInteractable_K32ItemBox::K32ItemBoxChargeWeightRatio' has a wrong offset!");

// Class DBDBots.AISkill_FindInteractable_Invitation
// 0x0000 (0x0308 - 0x0308)
class UAISkill_FindInteractable_Invitation final : public UAISkill_FindInteractable
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_FindInteractable_Invitation">();
	}
	static class UAISkill_FindInteractable_Invitation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_FindInteractable_Invitation>();
	}
};
static_assert(alignof(UAISkill_FindInteractable_Invitation) == 0x000008, "Wrong alignment on UAISkill_FindInteractable_Invitation");
static_assert(sizeof(UAISkill_FindInteractable_Invitation) == 0x000308, "Wrong size on UAISkill_FindInteractable_Invitation");

// Class DBDBots.AISkill_FindCollectable_Camper
// 0x0190 (0x0508 - 0x0378)
class UAISkill_FindCollectable_Camper : public UAISkill_FindCollectable
{
public:
	float                                         CollectUnderItemWeight;                            // 0x0378(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CollectOverWeightRatioDifference;                  // 0x037C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    WantToKeepEmptyItemPenalty;                        // 0x0380(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    CloseItemDistThreshold;                            // 0x03E0(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    CloseItemWeightMultiplier;                         // 0x0440(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    ItemGoalWeightMultiplier;                          // 0x04A0(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	float                                         EmptyItemChargeThreshold;                          // 0x0500(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_504[0x4];                                      // 0x0504(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_FindCollectable_Camper">();
	}
	static class UAISkill_FindCollectable_Camper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_FindCollectable_Camper>();
	}
};
static_assert(alignof(UAISkill_FindCollectable_Camper) == 0x000008, "Wrong alignment on UAISkill_FindCollectable_Camper");
static_assert(sizeof(UAISkill_FindCollectable_Camper) == 0x000508, "Wrong size on UAISkill_FindCollectable_Camper");
static_assert(offsetof(UAISkill_FindCollectable_Camper, CollectUnderItemWeight) == 0x000378, "Member 'UAISkill_FindCollectable_Camper::CollectUnderItemWeight' has a wrong offset!");
static_assert(offsetof(UAISkill_FindCollectable_Camper, CollectOverWeightRatioDifference) == 0x00037C, "Member 'UAISkill_FindCollectable_Camper::CollectOverWeightRatioDifference' has a wrong offset!");
static_assert(offsetof(UAISkill_FindCollectable_Camper, WantToKeepEmptyItemPenalty) == 0x000380, "Member 'UAISkill_FindCollectable_Camper::WantToKeepEmptyItemPenalty' has a wrong offset!");
static_assert(offsetof(UAISkill_FindCollectable_Camper, CloseItemDistThreshold) == 0x0003E0, "Member 'UAISkill_FindCollectable_Camper::CloseItemDistThreshold' has a wrong offset!");
static_assert(offsetof(UAISkill_FindCollectable_Camper, CloseItemWeightMultiplier) == 0x000440, "Member 'UAISkill_FindCollectable_Camper::CloseItemWeightMultiplier' has a wrong offset!");
static_assert(offsetof(UAISkill_FindCollectable_Camper, ItemGoalWeightMultiplier) == 0x0004A0, "Member 'UAISkill_FindCollectable_Camper::ItemGoalWeightMultiplier' has a wrong offset!");
static_assert(offsetof(UAISkill_FindCollectable_Camper, EmptyItemChargeThreshold) == 0x000500, "Member 'UAISkill_FindCollectable_Camper::EmptyItemChargeThreshold' has a wrong offset!");

// Class DBDBots.BTDecorator_ExtIsAtLocation
// 0x00A0 (0x0110 - 0x0070)
class UBTDecorator_ExtIsAtLocation final : public UBTDecorator_TickableBase
{
public:
	struct FBlackboardKeySelector                 BBLoc;                                             // 0x0070(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	bool                                          UseAlternativeLoc;                                 // 0x00A0(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAITunableParameter                    AcceptableRadius;                                  // 0x00A8(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	bool                                          IncludeAgentRadius;                                // 0x0108(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_109[0x7];                                      // 0x0109(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_ExtIsAtLocation">();
	}
	static class UBTDecorator_ExtIsAtLocation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_ExtIsAtLocation>();
	}
};
static_assert(alignof(UBTDecorator_ExtIsAtLocation) == 0x000008, "Wrong alignment on UBTDecorator_ExtIsAtLocation");
static_assert(sizeof(UBTDecorator_ExtIsAtLocation) == 0x000110, "Wrong size on UBTDecorator_ExtIsAtLocation");
static_assert(offsetof(UBTDecorator_ExtIsAtLocation, BBLoc) == 0x000070, "Member 'UBTDecorator_ExtIsAtLocation::BBLoc' has a wrong offset!");
static_assert(offsetof(UBTDecorator_ExtIsAtLocation, UseAlternativeLoc) == 0x0000A0, "Member 'UBTDecorator_ExtIsAtLocation::UseAlternativeLoc' has a wrong offset!");
static_assert(offsetof(UBTDecorator_ExtIsAtLocation, AcceptableRadius) == 0x0000A8, "Member 'UBTDecorator_ExtIsAtLocation::AcceptableRadius' has a wrong offset!");
static_assert(offsetof(UBTDecorator_ExtIsAtLocation, IncludeAgentRadius) == 0x000108, "Member 'UBTDecorator_ExtIsAtLocation::IncludeAgentRadius' has a wrong offset!");

// Class DBDBots.AISkill_BardicInspiration
// 0x0018 (0x0130 - 0x0118)
class UAISkill_BardicInspiration final : public UAISkill
{
public:
	class FName                                   BBGeneratorLocationKey;                            // 0x0118(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDistanceFromGenerator;                          // 0x0124(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDistanceFromSurvivorDuringSkill;                // 0x0128(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12C[0x4];                                      // 0x012C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_BardicInspiration">();
	}
	static class UAISkill_BardicInspiration* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_BardicInspiration>();
	}
};
static_assert(alignof(UAISkill_BardicInspiration) == 0x000008, "Wrong alignment on UAISkill_BardicInspiration");
static_assert(sizeof(UAISkill_BardicInspiration) == 0x000130, "Wrong size on UAISkill_BardicInspiration");
static_assert(offsetof(UAISkill_BardicInspiration, BBGeneratorLocationKey) == 0x000118, "Member 'UAISkill_BardicInspiration::BBGeneratorLocationKey' has a wrong offset!");
static_assert(offsetof(UAISkill_BardicInspiration, MaxDistanceFromGenerator) == 0x000124, "Member 'UAISkill_BardicInspiration::MaxDistanceFromGenerator' has a wrong offset!");
static_assert(offsetof(UAISkill_BardicInspiration, MaxDistanceFromSurvivorDuringSkill) == 0x000128, "Member 'UAISkill_BardicInspiration::MaxDistanceFromSurvivorDuringSkill' has a wrong offset!");

// Class DBDBots.BTDecorator_IsExitOpened
// 0x0030 (0x00A0 - 0x0070)
class UBTDecorator_IsExitOpened final : public UBTDecorator_TickableBase
{
public:
	struct FBlackboardKeySelector                 BBExitObj;                                         // 0x0070(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_IsExitOpened">();
	}
	static class UBTDecorator_IsExitOpened* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_IsExitOpened>();
	}
};
static_assert(alignof(UBTDecorator_IsExitOpened) == 0x000008, "Wrong alignment on UBTDecorator_IsExitOpened");
static_assert(sizeof(UBTDecorator_IsExitOpened) == 0x0000A0, "Wrong size on UBTDecorator_IsExitOpened");
static_assert(offsetof(UBTDecorator_IsExitOpened, BBExitObj) == 0x000070, "Member 'UBTDecorator_IsExitOpened::BBExitObj' has a wrong offset!");

// Class DBDBots.AISkill_InteractionTarget
// 0x00C8 (0x0348 - 0x0280)
class UAISkill_InteractionTarget : public UAISkill_Interaction
{
public:
	EInteractionTargetRequirements                TargetRequirement;                                 // 0x0280(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_281[0x3];                                      // 0x0281(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   BBOnlyFromActor;                                   // 0x0284(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AutoSwapBestStimulusWithBestTarget;                // 0x0290(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_291[0x3];                                      // 0x0291(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StartMinRange;                                     // 0x0294(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartMaxRange;                                     // 0x0298(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StopMinRange;                                      // 0x029C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StopMaxRange;                                      // 0x02A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartMaxHalfAngle;                                 // 0x02A4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StopMaxHalfAngle;                                  // 0x02A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsMaxHalfAngle2D;                                  // 0x02AC(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TestMaxHalfAngleOnPath;                            // 0x02AD(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AE[0x2];                                      // 0x02AE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UNavigationQueryFilter>     MaxAngleFilterClass;                               // 0x02B0(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInteractionTargetInSightModes                InSightMode;                                       // 0x02B8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B9[0x3];                                      // 0x02B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OutOfSightModeDelay;                               // 0x02BC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetMoveAwayTooFastStopDelay;                    // 0x02C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetMoveAwayTooFastCooldown;                     // 0x02C4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NearEvadeInteractableDistThreshold;                // 0x02C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinRangeModifierWhenObstacleIsPredicted;           // 0x02CC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CheckTargetIsNotOnOtherSideOfEvadeInteractable;    // 0x02D0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AlwaysStrafeAroundTarget;                          // 0x02D1(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D2[0x6];                                      // 0x02D2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAIDetectedStimulus>            _unfilteredTargets;                                // 0x02D8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FAIDetectedStimulus>            _filteredTargets;                                  // 0x02E8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TMap<class AActor*, struct FTargetMoveAwayToFastInfo> _targetsMoveAwayTooFastInfo;                       // 0x02F8(0x0050)(Transient, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_InteractionTarget">();
	}
	static class UAISkill_InteractionTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_InteractionTarget>();
	}
};
static_assert(alignof(UAISkill_InteractionTarget) == 0x000008, "Wrong alignment on UAISkill_InteractionTarget");
static_assert(sizeof(UAISkill_InteractionTarget) == 0x000348, "Wrong size on UAISkill_InteractionTarget");
static_assert(offsetof(UAISkill_InteractionTarget, TargetRequirement) == 0x000280, "Member 'UAISkill_InteractionTarget::TargetRequirement' has a wrong offset!");
static_assert(offsetof(UAISkill_InteractionTarget, BBOnlyFromActor) == 0x000284, "Member 'UAISkill_InteractionTarget::BBOnlyFromActor' has a wrong offset!");
static_assert(offsetof(UAISkill_InteractionTarget, AutoSwapBestStimulusWithBestTarget) == 0x000290, "Member 'UAISkill_InteractionTarget::AutoSwapBestStimulusWithBestTarget' has a wrong offset!");
static_assert(offsetof(UAISkill_InteractionTarget, StartMinRange) == 0x000294, "Member 'UAISkill_InteractionTarget::StartMinRange' has a wrong offset!");
static_assert(offsetof(UAISkill_InteractionTarget, StartMaxRange) == 0x000298, "Member 'UAISkill_InteractionTarget::StartMaxRange' has a wrong offset!");
static_assert(offsetof(UAISkill_InteractionTarget, StopMinRange) == 0x00029C, "Member 'UAISkill_InteractionTarget::StopMinRange' has a wrong offset!");
static_assert(offsetof(UAISkill_InteractionTarget, StopMaxRange) == 0x0002A0, "Member 'UAISkill_InteractionTarget::StopMaxRange' has a wrong offset!");
static_assert(offsetof(UAISkill_InteractionTarget, StartMaxHalfAngle) == 0x0002A4, "Member 'UAISkill_InteractionTarget::StartMaxHalfAngle' has a wrong offset!");
static_assert(offsetof(UAISkill_InteractionTarget, StopMaxHalfAngle) == 0x0002A8, "Member 'UAISkill_InteractionTarget::StopMaxHalfAngle' has a wrong offset!");
static_assert(offsetof(UAISkill_InteractionTarget, IsMaxHalfAngle2D) == 0x0002AC, "Member 'UAISkill_InteractionTarget::IsMaxHalfAngle2D' has a wrong offset!");
static_assert(offsetof(UAISkill_InteractionTarget, TestMaxHalfAngleOnPath) == 0x0002AD, "Member 'UAISkill_InteractionTarget::TestMaxHalfAngleOnPath' has a wrong offset!");
static_assert(offsetof(UAISkill_InteractionTarget, MaxAngleFilterClass) == 0x0002B0, "Member 'UAISkill_InteractionTarget::MaxAngleFilterClass' has a wrong offset!");
static_assert(offsetof(UAISkill_InteractionTarget, InSightMode) == 0x0002B8, "Member 'UAISkill_InteractionTarget::InSightMode' has a wrong offset!");
static_assert(offsetof(UAISkill_InteractionTarget, OutOfSightModeDelay) == 0x0002BC, "Member 'UAISkill_InteractionTarget::OutOfSightModeDelay' has a wrong offset!");
static_assert(offsetof(UAISkill_InteractionTarget, TargetMoveAwayTooFastStopDelay) == 0x0002C0, "Member 'UAISkill_InteractionTarget::TargetMoveAwayTooFastStopDelay' has a wrong offset!");
static_assert(offsetof(UAISkill_InteractionTarget, TargetMoveAwayTooFastCooldown) == 0x0002C4, "Member 'UAISkill_InteractionTarget::TargetMoveAwayTooFastCooldown' has a wrong offset!");
static_assert(offsetof(UAISkill_InteractionTarget, NearEvadeInteractableDistThreshold) == 0x0002C8, "Member 'UAISkill_InteractionTarget::NearEvadeInteractableDistThreshold' has a wrong offset!");
static_assert(offsetof(UAISkill_InteractionTarget, MinRangeModifierWhenObstacleIsPredicted) == 0x0002CC, "Member 'UAISkill_InteractionTarget::MinRangeModifierWhenObstacleIsPredicted' has a wrong offset!");
static_assert(offsetof(UAISkill_InteractionTarget, CheckTargetIsNotOnOtherSideOfEvadeInteractable) == 0x0002D0, "Member 'UAISkill_InteractionTarget::CheckTargetIsNotOnOtherSideOfEvadeInteractable' has a wrong offset!");
static_assert(offsetof(UAISkill_InteractionTarget, AlwaysStrafeAroundTarget) == 0x0002D1, "Member 'UAISkill_InteractionTarget::AlwaysStrafeAroundTarget' has a wrong offset!");
static_assert(offsetof(UAISkill_InteractionTarget, _unfilteredTargets) == 0x0002D8, "Member 'UAISkill_InteractionTarget::_unfilteredTargets' has a wrong offset!");
static_assert(offsetof(UAISkill_InteractionTarget, _filteredTargets) == 0x0002E8, "Member 'UAISkill_InteractionTarget::_filteredTargets' has a wrong offset!");
static_assert(offsetof(UAISkill_InteractionTarget, _targetsMoveAwayTooFastInfo) == 0x0002F8, "Member 'UAISkill_InteractionTarget::_targetsMoveAwayTooFastInfo' has a wrong offset!");

// Class DBDBots.AISkill_InteractionTarget_Stalk
// 0x0000 (0x0348 - 0x0348)
class UAISkill_InteractionTarget_Stalk : public UAISkill_InteractionTarget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_InteractionTarget_Stalk">();
	}
	static class UAISkill_InteractionTarget_Stalk* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_InteractionTarget_Stalk>();
	}
};
static_assert(alignof(UAISkill_InteractionTarget_Stalk) == 0x000008, "Wrong alignment on UAISkill_InteractionTarget_Stalk");
static_assert(sizeof(UAISkill_InteractionTarget_Stalk) == 0x000348, "Wrong size on UAISkill_InteractionTarget_Stalk");

// Class DBDBots.AISkill_InteractionTarget_StalkShape
// 0x0008 (0x0350 - 0x0348)
class UAISkill_InteractionTarget_StalkShape final : public UAISkill_InteractionTarget_Stalk
{
public:
	int32                                         StalkRangeLimitedAtEvilTier;                       // 0x0348(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxStalkRangeWhenLimitedByEvilTier;                // 0x034C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_InteractionTarget_StalkShape">();
	}
	static class UAISkill_InteractionTarget_StalkShape* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_InteractionTarget_StalkShape>();
	}
};
static_assert(alignof(UAISkill_InteractionTarget_StalkShape) == 0x000008, "Wrong alignment on UAISkill_InteractionTarget_StalkShape");
static_assert(sizeof(UAISkill_InteractionTarget_StalkShape) == 0x000350, "Wrong size on UAISkill_InteractionTarget_StalkShape");
static_assert(offsetof(UAISkill_InteractionTarget_StalkShape, StalkRangeLimitedAtEvilTier) == 0x000348, "Member 'UAISkill_InteractionTarget_StalkShape::StalkRangeLimitedAtEvilTier' has a wrong offset!");
static_assert(offsetof(UAISkill_InteractionTarget_StalkShape, MaxStalkRangeWhenLimitedByEvilTier) == 0x00034C, "Member 'UAISkill_InteractionTarget_StalkShape::MaxStalkRangeWhenLimitedByEvilTier' has a wrong offset!");

// Class DBDBots.DBDAIBTController
// 0x01D0 (0x0A20 - 0x0850)
class ADBDAIBTController : public ADBDAIController
{
public:
	class UBehaviorTree*                          BehaviorTree;                                      // 0x0850(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UAISkill*>                       BaseSkills;                                        // 0x0858(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UAISkill*>                       RoleSkills;                                        // 0x0868(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FAISkillCharacterClass>         CharacterClassSkills;                              // 0x0878(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FAISkillPerk>                   PerkSkills;                                        // 0x0888(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FAISkillEvent>                  EventSkills;                                       // 0x0898(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          ListenToAttackEvents;                              // 0x08A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8A9[0x7];                                      // 0x08A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UDBDAIPerceptionComponent*              _dbdPerception;                                    // 0x08B0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDBDBlackboardComponent*                _dbdBlackboard;                                    // 0x08B8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDBDPathFollowingComponent*             _dbdPathFollowing;                                 // 0x08C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDBDBehaviorTreeComponent*              _dbdBehaviorTree;                                  // 0x08C8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDBDNavMeshExplorerComponent*           _navMeshExplorer;                                  // 0x08D0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDBDAIStateComponent*                   _aiState;                                          // 0x08D8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDBDAIGoalComponent*                    _aiGoal;                                           // 0x08E0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDBDAIPassiveCameraComponent*           _aiPassiveCamera;                                  // 0x08E8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDBDAIEnemyTrackerComponent*            _enemyTracker;                                     // 0x08F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDBDNavObstacleAnalysisComponent*       _obstacleAnalysis;                                 // 0x08F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_900[0x8];                                      // 0x0900(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FGameplayTag, struct FAISkillDynamicSubtreeStruct> _setDynamicSubtrees;                               // 0x0908(0x0050)(Transient, NativeAccessSpecifierPrivate)
	bool                                          _areAISkillsInitialized;                           // 0x0958(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_959[0x7];                                      // 0x0959(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UAISkill*>                       _aiSkills;                                         // 0x0960(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TMap<class UObject*, struct FAISkillPausingAISkills> _pausingAISkills;                                  // 0x0970(0x0050)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_9C0[0x60];                                     // 0x09C0(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_FinishedPlaying();
	void OnPawnBump(class AActor* SelfActor, class AActor* OtherActor, const struct FVector& NormalImpulse, const struct FHitResult& Hit);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDAIBTController">();
	}
	static class ADBDAIBTController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDAIBTController>();
	}
};
static_assert(alignof(ADBDAIBTController) == 0x000008, "Wrong alignment on ADBDAIBTController");
static_assert(sizeof(ADBDAIBTController) == 0x000A20, "Wrong size on ADBDAIBTController");
static_assert(offsetof(ADBDAIBTController, BehaviorTree) == 0x000850, "Member 'ADBDAIBTController::BehaviorTree' has a wrong offset!");
static_assert(offsetof(ADBDAIBTController, BaseSkills) == 0x000858, "Member 'ADBDAIBTController::BaseSkills' has a wrong offset!");
static_assert(offsetof(ADBDAIBTController, RoleSkills) == 0x000868, "Member 'ADBDAIBTController::RoleSkills' has a wrong offset!");
static_assert(offsetof(ADBDAIBTController, CharacterClassSkills) == 0x000878, "Member 'ADBDAIBTController::CharacterClassSkills' has a wrong offset!");
static_assert(offsetof(ADBDAIBTController, PerkSkills) == 0x000888, "Member 'ADBDAIBTController::PerkSkills' has a wrong offset!");
static_assert(offsetof(ADBDAIBTController, EventSkills) == 0x000898, "Member 'ADBDAIBTController::EventSkills' has a wrong offset!");
static_assert(offsetof(ADBDAIBTController, ListenToAttackEvents) == 0x0008A8, "Member 'ADBDAIBTController::ListenToAttackEvents' has a wrong offset!");
static_assert(offsetof(ADBDAIBTController, _dbdPerception) == 0x0008B0, "Member 'ADBDAIBTController::_dbdPerception' has a wrong offset!");
static_assert(offsetof(ADBDAIBTController, _dbdBlackboard) == 0x0008B8, "Member 'ADBDAIBTController::_dbdBlackboard' has a wrong offset!");
static_assert(offsetof(ADBDAIBTController, _dbdPathFollowing) == 0x0008C0, "Member 'ADBDAIBTController::_dbdPathFollowing' has a wrong offset!");
static_assert(offsetof(ADBDAIBTController, _dbdBehaviorTree) == 0x0008C8, "Member 'ADBDAIBTController::_dbdBehaviorTree' has a wrong offset!");
static_assert(offsetof(ADBDAIBTController, _navMeshExplorer) == 0x0008D0, "Member 'ADBDAIBTController::_navMeshExplorer' has a wrong offset!");
static_assert(offsetof(ADBDAIBTController, _aiState) == 0x0008D8, "Member 'ADBDAIBTController::_aiState' has a wrong offset!");
static_assert(offsetof(ADBDAIBTController, _aiGoal) == 0x0008E0, "Member 'ADBDAIBTController::_aiGoal' has a wrong offset!");
static_assert(offsetof(ADBDAIBTController, _aiPassiveCamera) == 0x0008E8, "Member 'ADBDAIBTController::_aiPassiveCamera' has a wrong offset!");
static_assert(offsetof(ADBDAIBTController, _enemyTracker) == 0x0008F0, "Member 'ADBDAIBTController::_enemyTracker' has a wrong offset!");
static_assert(offsetof(ADBDAIBTController, _obstacleAnalysis) == 0x0008F8, "Member 'ADBDAIBTController::_obstacleAnalysis' has a wrong offset!");
static_assert(offsetof(ADBDAIBTController, _setDynamicSubtrees) == 0x000908, "Member 'ADBDAIBTController::_setDynamicSubtrees' has a wrong offset!");
static_assert(offsetof(ADBDAIBTController, _areAISkillsInitialized) == 0x000958, "Member 'ADBDAIBTController::_areAISkillsInitialized' has a wrong offset!");
static_assert(offsetof(ADBDAIBTController, _aiSkills) == 0x000960, "Member 'ADBDAIBTController::_aiSkills' has a wrong offset!");
static_assert(offsetof(ADBDAIBTController, _pausingAISkills) == 0x000970, "Member 'ADBDAIBTController::_pausingAISkills' has a wrong offset!");

// Class DBDBots.AISkill_InteractionTarget_Throw
// 0x00E8 (0x0430 - 0x0348)
class UAISkill_InteractionTarget_Throw : public UAISkill_InteractionTarget
{
public:
	EAIThrowPredictionModes                       ThrowPredictionMode;                               // 0x0348(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_349[0x3];                                      // 0x0349(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxAddPitchAngle;                                  // 0x034C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAIThrowProjectileModes                       ThrowProjectileMode;                               // 0x0350(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_351[0x7];                                      // 0x0351(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAITunableParameter                    PitchAngleRandDeviation;                           // 0x0358(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         MaxHeightPredictionOffset;                         // 0x03B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxThrowPowerRatioRange;                           // 0x03BC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinThrowPowerRatioRange;                           // 0x03C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C4[0x6C];                                     // 0x03C4(0x006C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_InteractionTarget_Throw">();
	}
	static class UAISkill_InteractionTarget_Throw* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_InteractionTarget_Throw>();
	}
};
static_assert(alignof(UAISkill_InteractionTarget_Throw) == 0x000008, "Wrong alignment on UAISkill_InteractionTarget_Throw");
static_assert(sizeof(UAISkill_InteractionTarget_Throw) == 0x000430, "Wrong size on UAISkill_InteractionTarget_Throw");
static_assert(offsetof(UAISkill_InteractionTarget_Throw, ThrowPredictionMode) == 0x000348, "Member 'UAISkill_InteractionTarget_Throw::ThrowPredictionMode' has a wrong offset!");
static_assert(offsetof(UAISkill_InteractionTarget_Throw, MaxAddPitchAngle) == 0x00034C, "Member 'UAISkill_InteractionTarget_Throw::MaxAddPitchAngle' has a wrong offset!");
static_assert(offsetof(UAISkill_InteractionTarget_Throw, ThrowProjectileMode) == 0x000350, "Member 'UAISkill_InteractionTarget_Throw::ThrowProjectileMode' has a wrong offset!");
static_assert(offsetof(UAISkill_InteractionTarget_Throw, PitchAngleRandDeviation) == 0x000358, "Member 'UAISkill_InteractionTarget_Throw::PitchAngleRandDeviation' has a wrong offset!");
static_assert(offsetof(UAISkill_InteractionTarget_Throw, MaxHeightPredictionOffset) == 0x0003B8, "Member 'UAISkill_InteractionTarget_Throw::MaxHeightPredictionOffset' has a wrong offset!");
static_assert(offsetof(UAISkill_InteractionTarget_Throw, MaxThrowPowerRatioRange) == 0x0003BC, "Member 'UAISkill_InteractionTarget_Throw::MaxThrowPowerRatioRange' has a wrong offset!");
static_assert(offsetof(UAISkill_InteractionTarget_Throw, MinThrowPowerRatioRange) == 0x0003C0, "Member 'UAISkill_InteractionTarget_Throw::MinThrowPowerRatioRange' has a wrong offset!");

// Class DBDBots.EnvQueryContext_PinLocation
// 0x0000 (0x0030 - 0x0030)
class UEnvQueryContext_PinLocation final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryContext_PinLocation">();
	}
	static class UEnvQueryContext_PinLocation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryContext_PinLocation>();
	}
};
static_assert(alignof(UEnvQueryContext_PinLocation) == 0x000008, "Wrong alignment on UEnvQueryContext_PinLocation");
static_assert(sizeof(UEnvQueryContext_PinLocation) == 0x000030, "Wrong size on UEnvQueryContext_PinLocation");

// Class DBDBots.AISkill_InteractionTarget_ShockTherapy
// 0x0008 (0x0350 - 0x0348)
class UAISkill_InteractionTarget_ShockTherapy final : public UAISkill_InteractionTarget
{
public:
	float                                         TargetToEvadePointMaxDistance;                     // 0x0348(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CastShockTimeBuffer;                               // 0x034C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_InteractionTarget_ShockTherapy">();
	}
	static class UAISkill_InteractionTarget_ShockTherapy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_InteractionTarget_ShockTherapy>();
	}
};
static_assert(alignof(UAISkill_InteractionTarget_ShockTherapy) == 0x000008, "Wrong alignment on UAISkill_InteractionTarget_ShockTherapy");
static_assert(sizeof(UAISkill_InteractionTarget_ShockTherapy) == 0x000350, "Wrong size on UAISkill_InteractionTarget_ShockTherapy");
static_assert(offsetof(UAISkill_InteractionTarget_ShockTherapy, TargetToEvadePointMaxDistance) == 0x000348, "Member 'UAISkill_InteractionTarget_ShockTherapy::TargetToEvadePointMaxDistance' has a wrong offset!");
static_assert(offsetof(UAISkill_InteractionTarget_ShockTherapy, CastShockTimeBuffer) == 0x00034C, "Member 'UAISkill_InteractionTarget_ShockTherapy::CastShockTimeBuffer' has a wrong offset!");

// Class DBDBots.AISkill_Interaction_KillerPower
// 0x0030 (0x02B0 - 0x0280)
class UAISkill_Interaction_KillerPower : public UAISkill_Interaction
{
public:
	class FName                                   BBHostileStimulusActor;                            // 0x0280(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BBInvestigateLocation;                             // 0x028C(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BBPatrolLocation;                                  // 0x0298(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EvadeActorMaxDistance;                             // 0x02A4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EvadeLoopPathMaxDistance;                          // 0x02A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AC[0x4];                                      // 0x02AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_Interaction_KillerPower">();
	}
	static class UAISkill_Interaction_KillerPower* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_Interaction_KillerPower>();
	}
};
static_assert(alignof(UAISkill_Interaction_KillerPower) == 0x000008, "Wrong alignment on UAISkill_Interaction_KillerPower");
static_assert(sizeof(UAISkill_Interaction_KillerPower) == 0x0002B0, "Wrong size on UAISkill_Interaction_KillerPower");
static_assert(offsetof(UAISkill_Interaction_KillerPower, BBHostileStimulusActor) == 0x000280, "Member 'UAISkill_Interaction_KillerPower::BBHostileStimulusActor' has a wrong offset!");
static_assert(offsetof(UAISkill_Interaction_KillerPower, BBInvestigateLocation) == 0x00028C, "Member 'UAISkill_Interaction_KillerPower::BBInvestigateLocation' has a wrong offset!");
static_assert(offsetof(UAISkill_Interaction_KillerPower, BBPatrolLocation) == 0x000298, "Member 'UAISkill_Interaction_KillerPower::BBPatrolLocation' has a wrong offset!");
static_assert(offsetof(UAISkill_Interaction_KillerPower, EvadeActorMaxDistance) == 0x0002A4, "Member 'UAISkill_Interaction_KillerPower::EvadeActorMaxDistance' has a wrong offset!");
static_assert(offsetof(UAISkill_Interaction_KillerPower, EvadeLoopPathMaxDistance) == 0x0002A8, "Member 'UAISkill_Interaction_KillerPower::EvadeLoopPathMaxDistance' has a wrong offset!");

// Class DBDBots.BTService_OnRelevantBase
// 0x0008 (0x0080 - 0x0078)
class UBTService_OnRelevantBase : public UBTService
{
public:
	EAINodeRelevancyOptions                       When;                                              // 0x0078(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_OnRelevantBase">();
	}
	static class UBTService_OnRelevantBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_OnRelevantBase>();
	}
};
static_assert(alignof(UBTService_OnRelevantBase) == 0x000008, "Wrong alignment on UBTService_OnRelevantBase");
static_assert(sizeof(UBTService_OnRelevantBase) == 0x000080, "Wrong size on UBTService_OnRelevantBase");
static_assert(offsetof(UBTService_OnRelevantBase, When) == 0x000078, "Member 'UBTService_OnRelevantBase::When' has a wrong offset!");

// Class DBDBots.BTService_CopyBBEntry
// 0x0068 (0x00E8 - 0x0080)
class UBTService_CopyBBEntry final : public UBTService_OnRelevantBase
{
public:
	struct FBlackboardKeySelector                 BBFrom;                                            // 0x0080(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBTo;                                              // 0x00B0(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	bool                                          CopyOnlyValidKeyValue;                             // 0x00E0(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E1[0x7];                                       // 0x00E1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_CopyBBEntry">();
	}
	static class UBTService_CopyBBEntry* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_CopyBBEntry>();
	}
};
static_assert(alignof(UBTService_CopyBBEntry) == 0x000008, "Wrong alignment on UBTService_CopyBBEntry");
static_assert(sizeof(UBTService_CopyBBEntry) == 0x0000E8, "Wrong size on UBTService_CopyBBEntry");
static_assert(offsetof(UBTService_CopyBBEntry, BBFrom) == 0x000080, "Member 'UBTService_CopyBBEntry::BBFrom' has a wrong offset!");
static_assert(offsetof(UBTService_CopyBBEntry, BBTo) == 0x0000B0, "Member 'UBTService_CopyBBEntry::BBTo' has a wrong offset!");
static_assert(offsetof(UBTService_CopyBBEntry, CopyOnlyValidKeyValue) == 0x0000E0, "Member 'UBTService_CopyBBEntry::CopyOnlyValidKeyValue' has a wrong offset!");

// Class DBDBots.AISkill_FindInteractable_SolveSickness
// 0x0120 (0x0428 - 0x0308)
class UAISkill_FindInteractable_SolveSickness final : public UAISkill_FindInteractable
{
public:
	struct FAITunableParameter                    BaseGoalWeight;                                    // 0x0308(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    UrgencyGoalWeight;                                 // 0x0368(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    InteractingGoalPenaltyWeight;                      // 0x03C8(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_FindInteractable_SolveSickness">();
	}
	static class UAISkill_FindInteractable_SolveSickness* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_FindInteractable_SolveSickness>();
	}
};
static_assert(alignof(UAISkill_FindInteractable_SolveSickness) == 0x000008, "Wrong alignment on UAISkill_FindInteractable_SolveSickness");
static_assert(sizeof(UAISkill_FindInteractable_SolveSickness) == 0x000428, "Wrong size on UAISkill_FindInteractable_SolveSickness");
static_assert(offsetof(UAISkill_FindInteractable_SolveSickness, BaseGoalWeight) == 0x000308, "Member 'UAISkill_FindInteractable_SolveSickness::BaseGoalWeight' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_SolveSickness, UrgencyGoalWeight) == 0x000368, "Member 'UAISkill_FindInteractable_SolveSickness::UrgencyGoalWeight' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_SolveSickness, InteractingGoalPenaltyWeight) == 0x0003C8, "Member 'UAISkill_FindInteractable_SolveSickness::InteractingGoalPenaltyWeight' has a wrong offset!");

// Class DBDBots.AISkill_InteractionTarget_Dash
// 0x0000 (0x0348 - 0x0348)
class UAISkill_InteractionTarget_Dash : public UAISkill_InteractionTarget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_InteractionTarget_Dash">();
	}
	static class UAISkill_InteractionTarget_Dash* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_InteractionTarget_Dash>();
	}
};
static_assert(alignof(UAISkill_InteractionTarget_Dash) == 0x000008, "Wrong alignment on UAISkill_InteractionTarget_Dash");
static_assert(sizeof(UAISkill_InteractionTarget_Dash) == 0x000348, "Wrong size on UAISkill_InteractionTarget_Dash");

// Class DBDBots.BTTask_ExtMoveTo
// 0x01A0 (0x0260 - 0x00C0)
class UBTTask_ExtMoveTo : public UBTTask_MoveTo
{
public:
	struct FBlackboardKeySelector                 BBStrafeFocus;                                     // 0x00C0(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	EExtMoveToStrafeFocusOptions                  StrafeFocus;                                       // 0x00F0(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          StrafeFocusPitch;                                  // 0x00F1(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F2[0x2];                                       // 0x00F2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StrafeNearFocusModeUnderDistance;                  // 0x00F4(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IntermittentOnStrafeFocusInterval;                 // 0x00F8(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IntermittentOnStrafeFocusDeviation;                // 0x00FC(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IntermittentOffStrafeFocusInterval;                // 0x0100(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IntermittentOffStrafeFocusDeviation;               // 0x0104(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndMoveStrafeFocusPrecisionAngle;                  // 0x0108(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          StrafeFocusOwnerOnComponentBBKey;                  // 0x010C(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECharacterMovementTypes                       ToGoalMovementMode;                                // 0x010D(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECharacterMovementTypes                       NearGoalMovementMode;                              // 0x010E(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10F[0x1];                                      // 0x010F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NearGoalModeUnderDistance;                         // 0x0110(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NormalMoveUnderNavLinkDistance;                    // 0x0114(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBIgnoreGroupAvoidance;                            // 0x0118(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	float                                         BlockedCheckInterval;                              // 0x0148(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BlockedContinueTimes;                              // 0x014C(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlockedSpeedPercent;                               // 0x0150(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         MaxTriesToRepathAroundBlocker;                     // 0x0154(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_155[0x3];                                      // 0x0155(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMovementModeNearActor>         MovementModesNearActors;                           // 0x0158(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	float                                         RepathInterval;                                    // 0x0168(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseAccelerationForPaths;                           // 0x016C(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16D[0x3];                                      // 0x016D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PathReachedPointRadius;                            // 0x0170(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NearPathFilterRadius;                              // 0x0174(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   UseContextualAcceptableRadius;                     // 0x0178(0x000C)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FindRelevantDangerInterval;                        // 0x0184(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpdateTraverseStatesInterval;                      // 0x0188(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          FailTaskOnUndodgeableDangerObject;                 // 0x018C(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IgnoreDangerObjects;                               // 0x018D(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDangerTraversePriority                       MinimumDangerTraversePriority;                     // 0x018E(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18F[0x29];                                     // 0x018F(0x0029)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class AActor*, bool>                     _seenActorsMap;                                    // 0x01B8(0x0050)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_208[0x58];                                     // 0x0208(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_ExtMoveTo">();
	}
	static class UBTTask_ExtMoveTo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_ExtMoveTo>();
	}
};
static_assert(alignof(UBTTask_ExtMoveTo) == 0x000008, "Wrong alignment on UBTTask_ExtMoveTo");
static_assert(sizeof(UBTTask_ExtMoveTo) == 0x000260, "Wrong size on UBTTask_ExtMoveTo");
static_assert(offsetof(UBTTask_ExtMoveTo, BBStrafeFocus) == 0x0000C0, "Member 'UBTTask_ExtMoveTo::BBStrafeFocus' has a wrong offset!");
static_assert(offsetof(UBTTask_ExtMoveTo, StrafeFocus) == 0x0000F0, "Member 'UBTTask_ExtMoveTo::StrafeFocus' has a wrong offset!");
static_assert(offsetof(UBTTask_ExtMoveTo, StrafeFocusPitch) == 0x0000F1, "Member 'UBTTask_ExtMoveTo::StrafeFocusPitch' has a wrong offset!");
static_assert(offsetof(UBTTask_ExtMoveTo, StrafeNearFocusModeUnderDistance) == 0x0000F4, "Member 'UBTTask_ExtMoveTo::StrafeNearFocusModeUnderDistance' has a wrong offset!");
static_assert(offsetof(UBTTask_ExtMoveTo, IntermittentOnStrafeFocusInterval) == 0x0000F8, "Member 'UBTTask_ExtMoveTo::IntermittentOnStrafeFocusInterval' has a wrong offset!");
static_assert(offsetof(UBTTask_ExtMoveTo, IntermittentOnStrafeFocusDeviation) == 0x0000FC, "Member 'UBTTask_ExtMoveTo::IntermittentOnStrafeFocusDeviation' has a wrong offset!");
static_assert(offsetof(UBTTask_ExtMoveTo, IntermittentOffStrafeFocusInterval) == 0x000100, "Member 'UBTTask_ExtMoveTo::IntermittentOffStrafeFocusInterval' has a wrong offset!");
static_assert(offsetof(UBTTask_ExtMoveTo, IntermittentOffStrafeFocusDeviation) == 0x000104, "Member 'UBTTask_ExtMoveTo::IntermittentOffStrafeFocusDeviation' has a wrong offset!");
static_assert(offsetof(UBTTask_ExtMoveTo, EndMoveStrafeFocusPrecisionAngle) == 0x000108, "Member 'UBTTask_ExtMoveTo::EndMoveStrafeFocusPrecisionAngle' has a wrong offset!");
static_assert(offsetof(UBTTask_ExtMoveTo, StrafeFocusOwnerOnComponentBBKey) == 0x00010C, "Member 'UBTTask_ExtMoveTo::StrafeFocusOwnerOnComponentBBKey' has a wrong offset!");
static_assert(offsetof(UBTTask_ExtMoveTo, ToGoalMovementMode) == 0x00010D, "Member 'UBTTask_ExtMoveTo::ToGoalMovementMode' has a wrong offset!");
static_assert(offsetof(UBTTask_ExtMoveTo, NearGoalMovementMode) == 0x00010E, "Member 'UBTTask_ExtMoveTo::NearGoalMovementMode' has a wrong offset!");
static_assert(offsetof(UBTTask_ExtMoveTo, NearGoalModeUnderDistance) == 0x000110, "Member 'UBTTask_ExtMoveTo::NearGoalModeUnderDistance' has a wrong offset!");
static_assert(offsetof(UBTTask_ExtMoveTo, NormalMoveUnderNavLinkDistance) == 0x000114, "Member 'UBTTask_ExtMoveTo::NormalMoveUnderNavLinkDistance' has a wrong offset!");
static_assert(offsetof(UBTTask_ExtMoveTo, BBIgnoreGroupAvoidance) == 0x000118, "Member 'UBTTask_ExtMoveTo::BBIgnoreGroupAvoidance' has a wrong offset!");
static_assert(offsetof(UBTTask_ExtMoveTo, BlockedCheckInterval) == 0x000148, "Member 'UBTTask_ExtMoveTo::BlockedCheckInterval' has a wrong offset!");
static_assert(offsetof(UBTTask_ExtMoveTo, BlockedContinueTimes) == 0x00014C, "Member 'UBTTask_ExtMoveTo::BlockedContinueTimes' has a wrong offset!");
static_assert(offsetof(UBTTask_ExtMoveTo, BlockedSpeedPercent) == 0x000150, "Member 'UBTTask_ExtMoveTo::BlockedSpeedPercent' has a wrong offset!");
static_assert(offsetof(UBTTask_ExtMoveTo, MaxTriesToRepathAroundBlocker) == 0x000154, "Member 'UBTTask_ExtMoveTo::MaxTriesToRepathAroundBlocker' has a wrong offset!");
static_assert(offsetof(UBTTask_ExtMoveTo, MovementModesNearActors) == 0x000158, "Member 'UBTTask_ExtMoveTo::MovementModesNearActors' has a wrong offset!");
static_assert(offsetof(UBTTask_ExtMoveTo, RepathInterval) == 0x000168, "Member 'UBTTask_ExtMoveTo::RepathInterval' has a wrong offset!");
static_assert(offsetof(UBTTask_ExtMoveTo, UseAccelerationForPaths) == 0x00016C, "Member 'UBTTask_ExtMoveTo::UseAccelerationForPaths' has a wrong offset!");
static_assert(offsetof(UBTTask_ExtMoveTo, PathReachedPointRadius) == 0x000170, "Member 'UBTTask_ExtMoveTo::PathReachedPointRadius' has a wrong offset!");
static_assert(offsetof(UBTTask_ExtMoveTo, NearPathFilterRadius) == 0x000174, "Member 'UBTTask_ExtMoveTo::NearPathFilterRadius' has a wrong offset!");
static_assert(offsetof(UBTTask_ExtMoveTo, UseContextualAcceptableRadius) == 0x000178, "Member 'UBTTask_ExtMoveTo::UseContextualAcceptableRadius' has a wrong offset!");
static_assert(offsetof(UBTTask_ExtMoveTo, FindRelevantDangerInterval) == 0x000184, "Member 'UBTTask_ExtMoveTo::FindRelevantDangerInterval' has a wrong offset!");
static_assert(offsetof(UBTTask_ExtMoveTo, UpdateTraverseStatesInterval) == 0x000188, "Member 'UBTTask_ExtMoveTo::UpdateTraverseStatesInterval' has a wrong offset!");
static_assert(offsetof(UBTTask_ExtMoveTo, FailTaskOnUndodgeableDangerObject) == 0x00018C, "Member 'UBTTask_ExtMoveTo::FailTaskOnUndodgeableDangerObject' has a wrong offset!");
static_assert(offsetof(UBTTask_ExtMoveTo, IgnoreDangerObjects) == 0x00018D, "Member 'UBTTask_ExtMoveTo::IgnoreDangerObjects' has a wrong offset!");
static_assert(offsetof(UBTTask_ExtMoveTo, MinimumDangerTraversePriority) == 0x00018E, "Member 'UBTTask_ExtMoveTo::MinimumDangerTraversePriority' has a wrong offset!");
static_assert(offsetof(UBTTask_ExtMoveTo, _seenActorsMap) == 0x0001B8, "Member 'UBTTask_ExtMoveTo::_seenActorsMap' has a wrong offset!");

// Class DBDBots.AISkill_FindInteractable_Waker
// 0x0060 (0x0368 - 0x0308)
class UAISkill_FindInteractable_Waker final : public UAISkill_FindInteractable
{
public:
	struct FAITunableParameter                    FixedGoalWeight;                                   // 0x0308(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_FindInteractable_Waker">();
	}
	static class UAISkill_FindInteractable_Waker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_FindInteractable_Waker>();
	}
};
static_assert(alignof(UAISkill_FindInteractable_Waker) == 0x000008, "Wrong alignment on UAISkill_FindInteractable_Waker");
static_assert(sizeof(UAISkill_FindInteractable_Waker) == 0x000368, "Wrong size on UAISkill_FindInteractable_Waker");
static_assert(offsetof(UAISkill_FindInteractable_Waker, FixedGoalWeight) == 0x000308, "Member 'UAISkill_FindInteractable_Waker::FixedGoalWeight' has a wrong offset!");

// Class DBDBots.NavArea_Vault
// 0x0000 (0x0050 - 0x0050)
class UNavArea_Vault final : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavArea_Vault">();
	}
	static class UNavArea_Vault* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavArea_Vault>();
	}
};
static_assert(alignof(UNavArea_Vault) == 0x000008, "Wrong alignment on UNavArea_Vault");
static_assert(sizeof(UNavArea_Vault) == 0x000050, "Wrong size on UNavArea_Vault");

// Class DBDBots.AISkill_FindCollectable_Searchable
// 0x0018 (0x0390 - 0x0378)
class UAISkill_FindCollectable_Searchable : public UAISkill_FindCollectable
{
public:
	float                                         SearchIntervalAfterOpenSearchable;                 // 0x0378(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OpenSearchableRelevancyDuration;                   // 0x037C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_380[0x8];                                      // 0x0380(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ASearchable*                            _relevantSearchable;                               // 0x0388(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_FindCollectable_Searchable">();
	}
	static class UAISkill_FindCollectable_Searchable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_FindCollectable_Searchable>();
	}
};
static_assert(alignof(UAISkill_FindCollectable_Searchable) == 0x000008, "Wrong alignment on UAISkill_FindCollectable_Searchable");
static_assert(sizeof(UAISkill_FindCollectable_Searchable) == 0x000390, "Wrong size on UAISkill_FindCollectable_Searchable");
static_assert(offsetof(UAISkill_FindCollectable_Searchable, SearchIntervalAfterOpenSearchable) == 0x000378, "Member 'UAISkill_FindCollectable_Searchable::SearchIntervalAfterOpenSearchable' has a wrong offset!");
static_assert(offsetof(UAISkill_FindCollectable_Searchable, OpenSearchableRelevancyDuration) == 0x00037C, "Member 'UAISkill_FindCollectable_Searchable::OpenSearchableRelevancyDuration' has a wrong offset!");
static_assert(offsetof(UAISkill_FindCollectable_Searchable, _relevantSearchable) == 0x000388, "Member 'UAISkill_FindCollectable_Searchable::_relevantSearchable' has a wrong offset!");

// Class DBDBots.BTService_AroundEQS
// 0x00A0 (0x01B0 - 0x0110)
class UBTService_AroundEQS final : public UBTService_RunEQS
{
public:
	struct FBlackboardKeySelector                 BBAroundObj;                                       // 0x0110(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	bool                                          UsesObjectLocation;                                // 0x0140(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_141[0x7];                                      // 0x0141(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlackboardKeySelector                 BBAroundLocation;                                  // 0x0148(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	float                                         ValidLocationRefreshInterval;                      // 0x0178(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InvalidLocationRefreshInterval;                    // 0x017C(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InvalidateLocationUnderTargetDistance;             // 0x0180(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          KeepResultWhileValid;                              // 0x0184(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_185[0x3];                                      // 0x0185(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   NavDataAgentName;                                  // 0x0188(0x000C)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_194[0x4];                                      // 0x0194(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                NavMeshProjectionBoxExtent;                        // 0x0198(0x0018)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_AroundEQS">();
	}
	static class UBTService_AroundEQS* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_AroundEQS>();
	}
};
static_assert(alignof(UBTService_AroundEQS) == 0x000008, "Wrong alignment on UBTService_AroundEQS");
static_assert(sizeof(UBTService_AroundEQS) == 0x0001B0, "Wrong size on UBTService_AroundEQS");
static_assert(offsetof(UBTService_AroundEQS, BBAroundObj) == 0x000110, "Member 'UBTService_AroundEQS::BBAroundObj' has a wrong offset!");
static_assert(offsetof(UBTService_AroundEQS, UsesObjectLocation) == 0x000140, "Member 'UBTService_AroundEQS::UsesObjectLocation' has a wrong offset!");
static_assert(offsetof(UBTService_AroundEQS, BBAroundLocation) == 0x000148, "Member 'UBTService_AroundEQS::BBAroundLocation' has a wrong offset!");
static_assert(offsetof(UBTService_AroundEQS, ValidLocationRefreshInterval) == 0x000178, "Member 'UBTService_AroundEQS::ValidLocationRefreshInterval' has a wrong offset!");
static_assert(offsetof(UBTService_AroundEQS, InvalidLocationRefreshInterval) == 0x00017C, "Member 'UBTService_AroundEQS::InvalidLocationRefreshInterval' has a wrong offset!");
static_assert(offsetof(UBTService_AroundEQS, InvalidateLocationUnderTargetDistance) == 0x000180, "Member 'UBTService_AroundEQS::InvalidateLocationUnderTargetDistance' has a wrong offset!");
static_assert(offsetof(UBTService_AroundEQS, KeepResultWhileValid) == 0x000184, "Member 'UBTService_AroundEQS::KeepResultWhileValid' has a wrong offset!");
static_assert(offsetof(UBTService_AroundEQS, NavDataAgentName) == 0x000188, "Member 'UBTService_AroundEQS::NavDataAgentName' has a wrong offset!");
static_assert(offsetof(UBTService_AroundEQS, NavMeshProjectionBoxExtent) == 0x000198, "Member 'UBTService_AroundEQS::NavMeshProjectionBoxExtent' has a wrong offset!");

// Class DBDBots.AISkill_InteractionTarget_AmbushAttack
// 0x0000 (0x0348 - 0x0348)
class UAISkill_InteractionTarget_AmbushAttack final : public UAISkill_InteractionTarget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_InteractionTarget_AmbushAttack">();
	}
	static class UAISkill_InteractionTarget_AmbushAttack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_InteractionTarget_AmbushAttack>();
	}
};
static_assert(alignof(UAISkill_InteractionTarget_AmbushAttack) == 0x000008, "Wrong alignment on UAISkill_InteractionTarget_AmbushAttack");
static_assert(sizeof(UAISkill_InteractionTarget_AmbushAttack) == 0x000348, "Wrong size on UAISkill_InteractionTarget_AmbushAttack");

// Class DBDBots.BTService_FindObject
// 0x01A8 (0x0220 - 0x0078)
class UBTService_FindObject : public UBTService
{
public:
	TArray<EKillerAbilities>                      KillerAbilities;                                   // 0x0078(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBObject;                                          // 0x0088(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBObjectLocation;                                  // 0x00B8(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	bool                                          RunEQSWhenFoundObject;                             // 0x00E8(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E9[0x7];                                       // 0x00E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FEQSParametrizedQueryExecutionRequest  EQSRequest;                                        // 0x00F0(0x0050)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBEQSResultLocation;                               // 0x0140(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	bool                                          RunDynamicSubtreeWhenFoundObject;                  // 0x0170(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_171[0x3];                                      // 0x0171(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           DynamicSubtreeTag;                                 // 0x0174(0x000C)(Edit, DisableEditOnTemplate, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBehaviorTree*                          DynamicSubtree;                                    // 0x0180(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ADBDAIBTController*                     _aiOwner;                                          // 0x0188(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ASlasherPlayer*                         _killer;                                           // 0x0190(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_198[0x88];                                     // 0x0198(0x0088)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_FindObject">();
	}
	static class UBTService_FindObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_FindObject>();
	}
};
static_assert(alignof(UBTService_FindObject) == 0x000008, "Wrong alignment on UBTService_FindObject");
static_assert(sizeof(UBTService_FindObject) == 0x000220, "Wrong size on UBTService_FindObject");
static_assert(offsetof(UBTService_FindObject, KillerAbilities) == 0x000078, "Member 'UBTService_FindObject::KillerAbilities' has a wrong offset!");
static_assert(offsetof(UBTService_FindObject, BBObject) == 0x000088, "Member 'UBTService_FindObject::BBObject' has a wrong offset!");
static_assert(offsetof(UBTService_FindObject, BBObjectLocation) == 0x0000B8, "Member 'UBTService_FindObject::BBObjectLocation' has a wrong offset!");
static_assert(offsetof(UBTService_FindObject, RunEQSWhenFoundObject) == 0x0000E8, "Member 'UBTService_FindObject::RunEQSWhenFoundObject' has a wrong offset!");
static_assert(offsetof(UBTService_FindObject, EQSRequest) == 0x0000F0, "Member 'UBTService_FindObject::EQSRequest' has a wrong offset!");
static_assert(offsetof(UBTService_FindObject, BBEQSResultLocation) == 0x000140, "Member 'UBTService_FindObject::BBEQSResultLocation' has a wrong offset!");
static_assert(offsetof(UBTService_FindObject, RunDynamicSubtreeWhenFoundObject) == 0x000170, "Member 'UBTService_FindObject::RunDynamicSubtreeWhenFoundObject' has a wrong offset!");
static_assert(offsetof(UBTService_FindObject, DynamicSubtreeTag) == 0x000174, "Member 'UBTService_FindObject::DynamicSubtreeTag' has a wrong offset!");
static_assert(offsetof(UBTService_FindObject, DynamicSubtree) == 0x000180, "Member 'UBTService_FindObject::DynamicSubtree' has a wrong offset!");
static_assert(offsetof(UBTService_FindObject, _aiOwner) == 0x000188, "Member 'UBTService_FindObject::_aiOwner' has a wrong offset!");
static_assert(offsetof(UBTService_FindObject, _killer) == 0x000190, "Member 'UBTService_FindObject::_killer' has a wrong offset!");

// Class DBDBots.AISkill_InteractionSetTrap
// 0x0010 (0x0290 - 0x0280)
class UAISkill_InteractionSetTrap : public UAISkill_Interaction
{
public:
	TSubclassOf<class AActor>                     TrapClass;                                         // 0x0280(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDistanceFromPointOfInterest;                    // 0x0288(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDistanceFromAnotherSetTrap;                     // 0x028C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_InteractionSetTrap">();
	}
	static class UAISkill_InteractionSetTrap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_InteractionSetTrap>();
	}
};
static_assert(alignof(UAISkill_InteractionSetTrap) == 0x000008, "Wrong alignment on UAISkill_InteractionSetTrap");
static_assert(sizeof(UAISkill_InteractionSetTrap) == 0x000290, "Wrong size on UAISkill_InteractionSetTrap");
static_assert(offsetof(UAISkill_InteractionSetTrap, TrapClass) == 0x000280, "Member 'UAISkill_InteractionSetTrap::TrapClass' has a wrong offset!");
static_assert(offsetof(UAISkill_InteractionSetTrap, MaxDistanceFromPointOfInterest) == 0x000288, "Member 'UAISkill_InteractionSetTrap::MaxDistanceFromPointOfInterest' has a wrong offset!");
static_assert(offsetof(UAISkill_InteractionSetTrap, MaxDistanceFromAnotherSetTrap) == 0x00028C, "Member 'UAISkill_InteractionSetTrap::MaxDistanceFromAnotherSetTrap' has a wrong offset!");

// Class DBDBots.AISkill_InteractionSetTrap_Demogorgon
// 0x0000 (0x0290 - 0x0290)
class UAISkill_InteractionSetTrap_Demogorgon final : public UAISkill_InteractionSetTrap
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_InteractionSetTrap_Demogorgon">();
	}
	static class UAISkill_InteractionSetTrap_Demogorgon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_InteractionSetTrap_Demogorgon>();
	}
};
static_assert(alignof(UAISkill_InteractionSetTrap_Demogorgon) == 0x000008, "Wrong alignment on UAISkill_InteractionSetTrap_Demogorgon");
static_assert(sizeof(UAISkill_InteractionSetTrap_Demogorgon) == 0x000290, "Wrong size on UAISkill_InteractionSetTrap_Demogorgon");

// Class DBDBots.NavigationQueryFilter_Player
// 0x0020 (0x0070 - 0x0050)
class UNavigationQueryFilter_Player : public UNavigationQueryFilter
{
public:
	int32                                         MaxSearchNodes;                                    // 0x0050(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x1C];                                      // 0x0054(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavigationQueryFilter_Player">();
	}
	static class UNavigationQueryFilter_Player* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavigationQueryFilter_Player>();
	}
};
static_assert(alignof(UNavigationQueryFilter_Player) == 0x000008, "Wrong alignment on UNavigationQueryFilter_Player");
static_assert(sizeof(UNavigationQueryFilter_Player) == 0x000070, "Wrong size on UNavigationQueryFilter_Player");
static_assert(offsetof(UNavigationQueryFilter_Player, MaxSearchNodes) == 0x000050, "Member 'UNavigationQueryFilter_Player::MaxSearchNodes' has a wrong offset!");

// Class DBDBots.PathStrategy
// 0x0098 (0x00C8 - 0x0030)
class UPathStrategy : public UObject
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UPathBuilder*>                   DefaultPathBuilders;                               // 0x0040(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         RefreshPartialPathDelay;                           // 0x0050(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartNextBranchBuildDelay;                         // 0x0054(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxActiveTimeSeconds;                              // 0x0058(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StrategyEndCooldownSeconds;                        // 0x005C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ADBDAIBTController*                     _aiOwner;                                          // 0x0060(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UPathBuilder*>                   _pathBuilders;                                     // 0x0068(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_78[0x50];                                      // 0x0078(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PathStrategy">();
	}
	static class UPathStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPathStrategy>();
	}
};
static_assert(alignof(UPathStrategy) == 0x000008, "Wrong alignment on UPathStrategy");
static_assert(sizeof(UPathStrategy) == 0x0000C8, "Wrong size on UPathStrategy");
static_assert(offsetof(UPathStrategy, DefaultPathBuilders) == 0x000040, "Member 'UPathStrategy::DefaultPathBuilders' has a wrong offset!");
static_assert(offsetof(UPathStrategy, RefreshPartialPathDelay) == 0x000050, "Member 'UPathStrategy::RefreshPartialPathDelay' has a wrong offset!");
static_assert(offsetof(UPathStrategy, StartNextBranchBuildDelay) == 0x000054, "Member 'UPathStrategy::StartNextBranchBuildDelay' has a wrong offset!");
static_assert(offsetof(UPathStrategy, MaxActiveTimeSeconds) == 0x000058, "Member 'UPathStrategy::MaxActiveTimeSeconds' has a wrong offset!");
static_assert(offsetof(UPathStrategy, StrategyEndCooldownSeconds) == 0x00005C, "Member 'UPathStrategy::StrategyEndCooldownSeconds' has a wrong offset!");
static_assert(offsetof(UPathStrategy, _aiOwner) == 0x000060, "Member 'UPathStrategy::_aiOwner' has a wrong offset!");
static_assert(offsetof(UPathStrategy, _pathBuilders) == 0x000068, "Member 'UPathStrategy::_pathBuilders' has a wrong offset!");

// Class DBDBots.PathStrategy_Flee
// 0x0000 (0x00C8 - 0x00C8)
class UPathStrategy_Flee : public UPathStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PathStrategy_Flee">();
	}
	static class UPathStrategy_Flee* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPathStrategy_Flee>();
	}
};
static_assert(alignof(UPathStrategy_Flee) == 0x000008, "Wrong alignment on UPathStrategy_Flee");
static_assert(sizeof(UPathStrategy_Flee) == 0x0000C8, "Wrong size on UPathStrategy_Flee");

// Class DBDBots.PathStrategy_FleeLOS
// 0x0000 (0x00C8 - 0x00C8)
class UPathStrategy_FleeLOS final : public UPathStrategy_Flee
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PathStrategy_FleeLOS">();
	}
	static class UPathStrategy_FleeLOS* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPathStrategy_FleeLOS>();
	}
};
static_assert(alignof(UPathStrategy_FleeLOS) == 0x000008, "Wrong alignment on UPathStrategy_FleeLOS");
static_assert(sizeof(UPathStrategy_FleeLOS) == 0x0000C8, "Wrong size on UPathStrategy_FleeLOS");

// Class DBDBots.AIDisplayDebugInterface
// 0x0000 (0x0030 - 0x0030)
class IAIDisplayDebugInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIDisplayDebugInterface">();
	}
	static class IAIDisplayDebugInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IAIDisplayDebugInterface>();
	}
};
static_assert(alignof(IAIDisplayDebugInterface) == 0x000008, "Wrong alignment on IAIDisplayDebugInterface");
static_assert(sizeof(IAIDisplayDebugInterface) == 0x000030, "Wrong size on IAIDisplayDebugInterface");

// Class DBDBots.AIEnemyTargetPrediction
// 0x0188 (0x01B8 - 0x0030)
class UAIEnemyTargetPrediction final : public UObject
{
public:
	struct FAITunableParameter                    DistanceToTargetScore;                             // 0x0030(0x0060)(Edit, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    SpeedToTargetScore;                                // 0x0090(0x0060)(Edit, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    PredictedTargetValidTime;                          // 0x00F0(0x0060)(Edit, NativeAccessSpecifierPublic)
	uint8                                         Pad_150[0x68];                                     // 0x0150(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIEnemyTargetPrediction">();
	}
	static class UAIEnemyTargetPrediction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIEnemyTargetPrediction>();
	}
};
static_assert(alignof(UAIEnemyTargetPrediction) == 0x000008, "Wrong alignment on UAIEnemyTargetPrediction");
static_assert(sizeof(UAIEnemyTargetPrediction) == 0x0001B8, "Wrong size on UAIEnemyTargetPrediction");
static_assert(offsetof(UAIEnemyTargetPrediction, DistanceToTargetScore) == 0x000030, "Member 'UAIEnemyTargetPrediction::DistanceToTargetScore' has a wrong offset!");
static_assert(offsetof(UAIEnemyTargetPrediction, SpeedToTargetScore) == 0x000090, "Member 'UAIEnemyTargetPrediction::SpeedToTargetScore' has a wrong offset!");
static_assert(offsetof(UAIEnemyTargetPrediction, PredictedTargetValidTime) == 0x0000F0, "Member 'UAIEnemyTargetPrediction::PredictedTargetValidTime' has a wrong offset!");

// Class DBDBots.AIEnemyTracker
// 0x0020 (0x0050 - 0x0030)
class UAIEnemyTracker : public UObject
{
public:
	uint8                                         Pad_30[0x20];                                      // 0x0030(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIEnemyTracker">();
	}
	static class UAIEnemyTracker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIEnemyTracker>();
	}
};
static_assert(alignof(UAIEnemyTracker) == 0x000008, "Wrong alignment on UAIEnemyTracker");
static_assert(sizeof(UAIEnemyTracker) == 0x000050, "Wrong size on UAIEnemyTracker");

// Class DBDBots.BTDecorator_IsLocationInPressureZone
// 0x0030 (0x00A0 - 0x0070)
class UBTDecorator_IsLocationInPressureZone final : public UBTDecorator_TickableBase
{
public:
	struct FBlackboardKeySelector                 BBAtLocation;                                      // 0x0070(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_IsLocationInPressureZone">();
	}
	static class UBTDecorator_IsLocationInPressureZone* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_IsLocationInPressureZone>();
	}
};
static_assert(alignof(UBTDecorator_IsLocationInPressureZone) == 0x000008, "Wrong alignment on UBTDecorator_IsLocationInPressureZone");
static_assert(sizeof(UBTDecorator_IsLocationInPressureZone) == 0x0000A0, "Wrong size on UBTDecorator_IsLocationInPressureZone");
static_assert(offsetof(UBTDecorator_IsLocationInPressureZone, BBAtLocation) == 0x000070, "Member 'UBTDecorator_IsLocationInPressureZone::BBAtLocation' has a wrong offset!");

// Class DBDBots.AIEnemyTracker_Killer
// 0x0530 (0x0580 - 0x0050)
class UAIEnemyTracker_Killer final : public UAIEnemyTracker
{
public:
	float                                         MinimumLoudNoiseBubbleRange;                       // 0x0050(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAITunableParameter                    GeneratorRepairNoiseAudibleRange;                  // 0x0058(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    RunningFootstepsAudibleRange;                      // 0x00B8(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    RunningFootstepDistanceRangeMultiplier;            // 0x0118(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    InjuredGruntsAudibleRange;                         // 0x0178(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    InjuredGruntsDistanceRangeMultiplier;              // 0x01D8(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    NormalBreathAudibleRange;                          // 0x0238(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    NormalBreathDistanceRangeMultiplier;               // 0x0298(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    PredictedLocationResetRange;                       // 0x02F8(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FVector                                PredictedNavMeshLocationExtent;                    // 0x0358(0x0018)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PredictionBorderAdjustDistance;                    // 0x0370(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PredictionStuckRadius;                             // 0x0374(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    MinimumFootstepVisibility;                         // 0x0378(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    MaximumFootstepRange;                              // 0x03D8(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	float                                         FootstepSightTestOffset;                           // 0x0438(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_43C[0x4];                                      // 0x043C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAITunableParameter                    FootstepDistanceRangeMargin;                       // 0x0440(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	float                                         FootstepSightCheckMargin;                          // 0x04A0(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A4[0x4];                                      // 0x04A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAITunableParameter                    SoundDirectionVarianceSpeed;                       // 0x04A8(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    SoundDirectionMaxAngle;                            // 0x0508(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	uint8                                         Pad_568[0x18];                                     // 0x0568(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIEnemyTracker_Killer">();
	}
	static class UAIEnemyTracker_Killer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIEnemyTracker_Killer>();
	}
};
static_assert(alignof(UAIEnemyTracker_Killer) == 0x000008, "Wrong alignment on UAIEnemyTracker_Killer");
static_assert(sizeof(UAIEnemyTracker_Killer) == 0x000580, "Wrong size on UAIEnemyTracker_Killer");
static_assert(offsetof(UAIEnemyTracker_Killer, MinimumLoudNoiseBubbleRange) == 0x000050, "Member 'UAIEnemyTracker_Killer::MinimumLoudNoiseBubbleRange' has a wrong offset!");
static_assert(offsetof(UAIEnemyTracker_Killer, GeneratorRepairNoiseAudibleRange) == 0x000058, "Member 'UAIEnemyTracker_Killer::GeneratorRepairNoiseAudibleRange' has a wrong offset!");
static_assert(offsetof(UAIEnemyTracker_Killer, RunningFootstepsAudibleRange) == 0x0000B8, "Member 'UAIEnemyTracker_Killer::RunningFootstepsAudibleRange' has a wrong offset!");
static_assert(offsetof(UAIEnemyTracker_Killer, RunningFootstepDistanceRangeMultiplier) == 0x000118, "Member 'UAIEnemyTracker_Killer::RunningFootstepDistanceRangeMultiplier' has a wrong offset!");
static_assert(offsetof(UAIEnemyTracker_Killer, InjuredGruntsAudibleRange) == 0x000178, "Member 'UAIEnemyTracker_Killer::InjuredGruntsAudibleRange' has a wrong offset!");
static_assert(offsetof(UAIEnemyTracker_Killer, InjuredGruntsDistanceRangeMultiplier) == 0x0001D8, "Member 'UAIEnemyTracker_Killer::InjuredGruntsDistanceRangeMultiplier' has a wrong offset!");
static_assert(offsetof(UAIEnemyTracker_Killer, NormalBreathAudibleRange) == 0x000238, "Member 'UAIEnemyTracker_Killer::NormalBreathAudibleRange' has a wrong offset!");
static_assert(offsetof(UAIEnemyTracker_Killer, NormalBreathDistanceRangeMultiplier) == 0x000298, "Member 'UAIEnemyTracker_Killer::NormalBreathDistanceRangeMultiplier' has a wrong offset!");
static_assert(offsetof(UAIEnemyTracker_Killer, PredictedLocationResetRange) == 0x0002F8, "Member 'UAIEnemyTracker_Killer::PredictedLocationResetRange' has a wrong offset!");
static_assert(offsetof(UAIEnemyTracker_Killer, PredictedNavMeshLocationExtent) == 0x000358, "Member 'UAIEnemyTracker_Killer::PredictedNavMeshLocationExtent' has a wrong offset!");
static_assert(offsetof(UAIEnemyTracker_Killer, PredictionBorderAdjustDistance) == 0x000370, "Member 'UAIEnemyTracker_Killer::PredictionBorderAdjustDistance' has a wrong offset!");
static_assert(offsetof(UAIEnemyTracker_Killer, PredictionStuckRadius) == 0x000374, "Member 'UAIEnemyTracker_Killer::PredictionStuckRadius' has a wrong offset!");
static_assert(offsetof(UAIEnemyTracker_Killer, MinimumFootstepVisibility) == 0x000378, "Member 'UAIEnemyTracker_Killer::MinimumFootstepVisibility' has a wrong offset!");
static_assert(offsetof(UAIEnemyTracker_Killer, MaximumFootstepRange) == 0x0003D8, "Member 'UAIEnemyTracker_Killer::MaximumFootstepRange' has a wrong offset!");
static_assert(offsetof(UAIEnemyTracker_Killer, FootstepSightTestOffset) == 0x000438, "Member 'UAIEnemyTracker_Killer::FootstepSightTestOffset' has a wrong offset!");
static_assert(offsetof(UAIEnemyTracker_Killer, FootstepDistanceRangeMargin) == 0x000440, "Member 'UAIEnemyTracker_Killer::FootstepDistanceRangeMargin' has a wrong offset!");
static_assert(offsetof(UAIEnemyTracker_Killer, FootstepSightCheckMargin) == 0x0004A0, "Member 'UAIEnemyTracker_Killer::FootstepSightCheckMargin' has a wrong offset!");
static_assert(offsetof(UAIEnemyTracker_Killer, SoundDirectionVarianceSpeed) == 0x0004A8, "Member 'UAIEnemyTracker_Killer::SoundDirectionVarianceSpeed' has a wrong offset!");
static_assert(offsetof(UAIEnemyTracker_Killer, SoundDirectionMaxAngle) == 0x000508, "Member 'UAIEnemyTracker_Killer::SoundDirectionMaxAngle' has a wrong offset!");

// Class DBDBots.AIEnemyTracker_Survivor
// 0x0078 (0x00C8 - 0x0050)
class UAIEnemyTracker_Survivor final : public UAIEnemyTracker
{
public:
	float                                         TerrorRadiusDistanceRange;                         // 0x0050(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChaseDistanceRange;                                // 0x0054(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DownedAllyDistanceRange;                           // 0x0058(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x6C];                                      // 0x005C(0x006C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIEnemyTracker_Survivor">();
	}
	static class UAIEnemyTracker_Survivor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIEnemyTracker_Survivor>();
	}
};
static_assert(alignof(UAIEnemyTracker_Survivor) == 0x000008, "Wrong alignment on UAIEnemyTracker_Survivor");
static_assert(sizeof(UAIEnemyTracker_Survivor) == 0x0000C8, "Wrong size on UAIEnemyTracker_Survivor");
static_assert(offsetof(UAIEnemyTracker_Survivor, TerrorRadiusDistanceRange) == 0x000050, "Member 'UAIEnemyTracker_Survivor::TerrorRadiusDistanceRange' has a wrong offset!");
static_assert(offsetof(UAIEnemyTracker_Survivor, ChaseDistanceRange) == 0x000054, "Member 'UAIEnemyTracker_Survivor::ChaseDistanceRange' has a wrong offset!");
static_assert(offsetof(UAIEnemyTracker_Survivor, DownedAllyDistanceRange) == 0x000058, "Member 'UAIEnemyTracker_Survivor::DownedAllyDistanceRange' has a wrong offset!");

// Class DBDBots.BTDecorator_HasPerk
// 0x0028 (0x0098 - 0x0070)
class UBTDecorator_HasPerk final : public UBTDecorator_TickableBase
{
public:
	EPlayerFilter                                 PlayerFilter;                                      // 0x0070(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAIHasPerkCondition>            Perks;                                             // 0x0078(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	TArray<class ADBDPlayer*>                     _players;                                          // 0x0088(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_HasPerk">();
	}
	static class UBTDecorator_HasPerk* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_HasPerk>();
	}
};
static_assert(alignof(UBTDecorator_HasPerk) == 0x000008, "Wrong alignment on UBTDecorator_HasPerk");
static_assert(sizeof(UBTDecorator_HasPerk) == 0x000098, "Wrong size on UBTDecorator_HasPerk");
static_assert(offsetof(UBTDecorator_HasPerk, PlayerFilter) == 0x000070, "Member 'UBTDecorator_HasPerk::PlayerFilter' has a wrong offset!");
static_assert(offsetof(UBTDecorator_HasPerk, Perks) == 0x000078, "Member 'UBTDecorator_HasPerk::Perks' has a wrong offset!");
static_assert(offsetof(UBTDecorator_HasPerk, _players) == 0x000088, "Member 'UBTDecorator_HasPerk::_players' has a wrong offset!");

// Class DBDBots.AIEvadeLoopModifierInterface
// 0x0000 (0x0030 - 0x0030)
class IAIEvadeLoopModifierInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIEvadeLoopModifierInterface">();
	}
	static class IAIEvadeLoopModifierInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IAIEvadeLoopModifierInterface>();
	}
};
static_assert(alignof(IAIEvadeLoopModifierInterface) == 0x000008, "Wrong alignment on IAIEvadeLoopModifierInterface");
static_assert(sizeof(IAIEvadeLoopModifierInterface) == 0x000030, "Wrong size on IAIEvadeLoopModifierInterface");

// Class DBDBots.AIGoalGeneratorInterface
// 0x0000 (0x0030 - 0x0030)
class IAIGoalGeneratorInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIGoalGeneratorInterface">();
	}
	static class IAIGoalGeneratorInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IAIGoalGeneratorInterface>();
	}
};
static_assert(alignof(IAIGoalGeneratorInterface) == 0x000008, "Wrong alignment on IAIGoalGeneratorInterface");
static_assert(sizeof(IAIGoalGeneratorInterface) == 0x000030, "Wrong size on IAIGoalGeneratorInterface");

// Class DBDBots.BTDecorator_ItemType
// 0x0038 (0x00A8 - 0x0070)
class UBTDecorator_ItemType final : public UBTDecorator_TickableBase
{
public:
	struct FBlackboardKeySelector                 BBTargetObject;                                    // 0x0070(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	EItemType                                     ItemType;                                          // 0x00A0(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_ItemType">();
	}
	static class UBTDecorator_ItemType* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_ItemType>();
	}
};
static_assert(alignof(UBTDecorator_ItemType) == 0x000008, "Wrong alignment on UBTDecorator_ItemType");
static_assert(sizeof(UBTDecorator_ItemType) == 0x0000A8, "Wrong size on UBTDecorator_ItemType");
static_assert(offsetof(UBTDecorator_ItemType, BBTargetObject) == 0x000070, "Member 'UBTDecorator_ItemType::BBTargetObject' has a wrong offset!");
static_assert(offsetof(UBTDecorator_ItemType, ItemType) == 0x0000A0, "Member 'UBTDecorator_ItemType::ItemType' has a wrong offset!");

// Class DBDBots.AIIntentionValidatorInterface
// 0x0000 (0x0030 - 0x0030)
class IAIIntentionValidatorInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIIntentionValidatorInterface">();
	}
	static class IAIIntentionValidatorInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IAIIntentionValidatorInterface>();
	}
};
static_assert(alignof(IAIIntentionValidatorInterface) == 0x000008, "Wrong alignment on IAIIntentionValidatorInterface");
static_assert(sizeof(IAIIntentionValidatorInterface) == 0x000030, "Wrong size on IAIIntentionValidatorInterface");

// Class DBDBots.AISkill_ChemicalTrapInChase
// 0x0000 (0x0280 - 0x0280)
class UAISkill_ChemicalTrapInChase final : public UAISkill_Interaction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_ChemicalTrapInChase">();
	}
	static class UAISkill_ChemicalTrapInChase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_ChemicalTrapInChase>();
	}
};
static_assert(alignof(UAISkill_ChemicalTrapInChase) == 0x000008, "Wrong alignment on UAISkill_ChemicalTrapInChase");
static_assert(sizeof(UAISkill_ChemicalTrapInChase) == 0x000280, "Wrong size on UAISkill_ChemicalTrapInChase");

// Class DBDBots.BTDecorator_IsInteractionAvailable
// 0x0088 (0x00F8 - 0x0070)
class UBTDecorator_IsInteractionAvailable final : public UBTDecorator_TickableBase
{
public:
	EInteractionCheckType                         InteractionCheckType;                              // 0x0070(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInputInteractionType                         InputType;                                         // 0x0071(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_72[0x6];                                       // 0x0072(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         InteractionIds;                                    // 0x0078(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	EIsInteractionAvailableOnFilter               OnFilter;                                          // 0x0088(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlackboardKeySelector                 BBInteractor;                                      // 0x0090(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBInputType;                                       // 0x00C0(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	bool                                          FailIfAnotherOngoingInteraction;                   // 0x00F0(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          FailIfNotPerformingInteraction;                    // 0x00F1(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F2[0x6];                                       // 0x00F2(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_IsInteractionAvailable">();
	}
	static class UBTDecorator_IsInteractionAvailable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_IsInteractionAvailable>();
	}
};
static_assert(alignof(UBTDecorator_IsInteractionAvailable) == 0x000008, "Wrong alignment on UBTDecorator_IsInteractionAvailable");
static_assert(sizeof(UBTDecorator_IsInteractionAvailable) == 0x0000F8, "Wrong size on UBTDecorator_IsInteractionAvailable");
static_assert(offsetof(UBTDecorator_IsInteractionAvailable, InteractionCheckType) == 0x000070, "Member 'UBTDecorator_IsInteractionAvailable::InteractionCheckType' has a wrong offset!");
static_assert(offsetof(UBTDecorator_IsInteractionAvailable, InputType) == 0x000071, "Member 'UBTDecorator_IsInteractionAvailable::InputType' has a wrong offset!");
static_assert(offsetof(UBTDecorator_IsInteractionAvailable, InteractionIds) == 0x000078, "Member 'UBTDecorator_IsInteractionAvailable::InteractionIds' has a wrong offset!");
static_assert(offsetof(UBTDecorator_IsInteractionAvailable, OnFilter) == 0x000088, "Member 'UBTDecorator_IsInteractionAvailable::OnFilter' has a wrong offset!");
static_assert(offsetof(UBTDecorator_IsInteractionAvailable, BBInteractor) == 0x000090, "Member 'UBTDecorator_IsInteractionAvailable::BBInteractor' has a wrong offset!");
static_assert(offsetof(UBTDecorator_IsInteractionAvailable, BBInputType) == 0x0000C0, "Member 'UBTDecorator_IsInteractionAvailable::BBInputType' has a wrong offset!");
static_assert(offsetof(UBTDecorator_IsInteractionAvailable, FailIfAnotherOngoingInteraction) == 0x0000F0, "Member 'UBTDecorator_IsInteractionAvailable::FailIfAnotherOngoingInteraction' has a wrong offset!");
static_assert(offsetof(UBTDecorator_IsInteractionAvailable, FailIfNotPerformingInteraction) == 0x0000F1, "Member 'UBTDecorator_IsInteractionAvailable::FailIfNotPerformingInteraction' has a wrong offset!");

// Class DBDBots.AISkill_DirectionalMinigame
// 0x01A8 (0x02C0 - 0x0118)
class UAISkill_DirectionalMinigame final : public UAISkill
{
public:
	struct FAIRoll                                InputRoll;                                         // 0x0118(0x00C8)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    InputTimeMinimum;                                  // 0x01E0(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    InputTimeVariance;                                 // 0x0240(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A0[0x20];                                     // 0x02A0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnMinigameEnd(EDirectionalMinigameResult Result);
	void OnMinigameStart(const TArray<EDirectionalInputKey>& Sequence, int32 CurrentIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_DirectionalMinigame">();
	}
	static class UAISkill_DirectionalMinigame* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_DirectionalMinigame>();
	}
};
static_assert(alignof(UAISkill_DirectionalMinigame) == 0x000008, "Wrong alignment on UAISkill_DirectionalMinigame");
static_assert(sizeof(UAISkill_DirectionalMinigame) == 0x0002C0, "Wrong size on UAISkill_DirectionalMinigame");
static_assert(offsetof(UAISkill_DirectionalMinigame, InputRoll) == 0x000118, "Member 'UAISkill_DirectionalMinigame::InputRoll' has a wrong offset!");
static_assert(offsetof(UAISkill_DirectionalMinigame, InputTimeMinimum) == 0x0001E0, "Member 'UAISkill_DirectionalMinigame::InputTimeMinimum' has a wrong offset!");
static_assert(offsetof(UAISkill_DirectionalMinigame, InputTimeVariance) == 0x000240, "Member 'UAISkill_DirectionalMinigame::InputTimeVariance' has a wrong offset!");

// Class DBDBots.AISkill_Diversion
// 0x0070 (0x0188 - 0x0118)
class UAISkill_Diversion final : public UAISkill
{
public:
	class FName                                   PerkId;                                            // 0x0118(0x000C)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_124[0x4];                                      // 0x0124(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class AActor>>             DiversionFromGoalClasses;                          // 0x0128(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, UObjectWrapper, NativeAccessSpecifierPublic)
	EAIDifficultyLevel                            ThrowOnInteractablesAtDifficultyLevel;             // 0x0138(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_139[0x3];                                      // 0x0139(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxThrowOnInteractableHalfAngle;                   // 0x013C(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxMoveToTargetDistance;                           // 0x0140(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_144[0x4];                                      // 0x0144(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                NavMeshFindLocationExtents;                        // 0x0148(0x0018)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlanInterval;                                      // 0x0160(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_164[0x24];                                     // 0x0164(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_Diversion">();
	}
	static class UAISkill_Diversion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_Diversion>();
	}
};
static_assert(alignof(UAISkill_Diversion) == 0x000008, "Wrong alignment on UAISkill_Diversion");
static_assert(sizeof(UAISkill_Diversion) == 0x000188, "Wrong size on UAISkill_Diversion");
static_assert(offsetof(UAISkill_Diversion, PerkId) == 0x000118, "Member 'UAISkill_Diversion::PerkId' has a wrong offset!");
static_assert(offsetof(UAISkill_Diversion, DiversionFromGoalClasses) == 0x000128, "Member 'UAISkill_Diversion::DiversionFromGoalClasses' has a wrong offset!");
static_assert(offsetof(UAISkill_Diversion, ThrowOnInteractablesAtDifficultyLevel) == 0x000138, "Member 'UAISkill_Diversion::ThrowOnInteractablesAtDifficultyLevel' has a wrong offset!");
static_assert(offsetof(UAISkill_Diversion, MaxThrowOnInteractableHalfAngle) == 0x00013C, "Member 'UAISkill_Diversion::MaxThrowOnInteractableHalfAngle' has a wrong offset!");
static_assert(offsetof(UAISkill_Diversion, MaxMoveToTargetDistance) == 0x000140, "Member 'UAISkill_Diversion::MaxMoveToTargetDistance' has a wrong offset!");
static_assert(offsetof(UAISkill_Diversion, NavMeshFindLocationExtents) == 0x000148, "Member 'UAISkill_Diversion::NavMeshFindLocationExtents' has a wrong offset!");
static_assert(offsetof(UAISkill_Diversion, PlanInterval) == 0x000160, "Member 'UAISkill_Diversion::PlanInterval' has a wrong offset!");

// Class DBDBots.AISkill_Interaction_SendToDeathBed
// 0x0000 (0x0280 - 0x0280)
class UAISkill_Interaction_SendToDeathBed final : public UAISkill_Interaction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_Interaction_SendToDeathBed">();
	}
	static class UAISkill_Interaction_SendToDeathBed* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_Interaction_SendToDeathBed>();
	}
};
static_assert(alignof(UAISkill_Interaction_SendToDeathBed) == 0x000008, "Wrong alignment on UAISkill_Interaction_SendToDeathBed");
static_assert(sizeof(UAISkill_Interaction_SendToDeathBed) == 0x000280, "Wrong size on UAISkill_Interaction_SendToDeathBed");

// Class DBDBots.AISkill_DummySkill
// 0x0010 (0x0128 - 0x0118)
class UAISkill_DummySkill final : public UAISkill
{
public:
	TArray<class FString>                         DummyProperty;                                     // 0x0118(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_DummySkill">();
	}
	static class UAISkill_DummySkill* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_DummySkill>();
	}
};
static_assert(alignof(UAISkill_DummySkill) == 0x000008, "Wrong alignment on UAISkill_DummySkill");
static_assert(sizeof(UAISkill_DummySkill) == 0x000128, "Wrong size on UAISkill_DummySkill");
static_assert(offsetof(UAISkill_DummySkill, DummyProperty) == 0x000118, "Member 'UAISkill_DummySkill::DummyProperty' has a wrong offset!");

// Class DBDBots.BTDecorator_HasBetterItemValue
// 0x0038 (0x00A8 - 0x0070)
class UBTDecorator_HasBetterItemValue final : public UBTDecorator_TickableBase
{
public:
	struct FBlackboardKeySelector                 BBTargetObject;                                    // 0x0070(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	float                                         CollectUnderItemWeight;                            // 0x00A0(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CollectOverWeightRatioDifference;                  // 0x00A4(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_HasBetterItemValue">();
	}
	static class UBTDecorator_HasBetterItemValue* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_HasBetterItemValue>();
	}
};
static_assert(alignof(UBTDecorator_HasBetterItemValue) == 0x000008, "Wrong alignment on UBTDecorator_HasBetterItemValue");
static_assert(sizeof(UBTDecorator_HasBetterItemValue) == 0x0000A8, "Wrong size on UBTDecorator_HasBetterItemValue");
static_assert(offsetof(UBTDecorator_HasBetterItemValue, BBTargetObject) == 0x000070, "Member 'UBTDecorator_HasBetterItemValue::BBTargetObject' has a wrong offset!");
static_assert(offsetof(UBTDecorator_HasBetterItemValue, CollectUnderItemWeight) == 0x0000A0, "Member 'UBTDecorator_HasBetterItemValue::CollectUnderItemWeight' has a wrong offset!");
static_assert(offsetof(UBTDecorator_HasBetterItemValue, CollectOverWeightRatioDifference) == 0x0000A4, "Member 'UBTDecorator_HasBetterItemValue::CollectOverWeightRatioDifference' has a wrong offset!");

// Class DBDBots.AISkill_FindCollectable_Trap
// 0x0000 (0x0378 - 0x0378)
class UAISkill_FindCollectable_Trap final : public UAISkill_FindCollectable
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_FindCollectable_Trap">();
	}
	static class UAISkill_FindCollectable_Trap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_FindCollectable_Trap>();
	}
};
static_assert(alignof(UAISkill_FindCollectable_Trap) == 0x000008, "Wrong alignment on UAISkill_FindCollectable_Trap");
static_assert(sizeof(UAISkill_FindCollectable_Trap) == 0x000378, "Wrong size on UAISkill_FindCollectable_Trap");

// Class DBDBots.AISkill_FindInteractable_CloseTelevisionNearGenerator
// 0x0240 (0x0548 - 0x0308)
class UAISkill_FindInteractable_CloseTelevisionNearGenerator final : public UAISkill_FindInteractable
{
public:
	struct FAITunableParameter                    MaximumCondemnedPercentToCloseTelevision;          // 0x0308(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    DistanceBetweenGeneratorAndTelevisionThreshold;    // 0x0368(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    BaseValue;                                         // 0x03C8(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    CloseTelevisionDistanceLinearWeight;               // 0x0428(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    CloseTelevisionMaximumDistanceFromCamper;          // 0x0488(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    MaxHeightDifferenceToCloseTelevisions;             // 0x04E8(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_FindInteractable_CloseTelevisionNearGenerator">();
	}
	static class UAISkill_FindInteractable_CloseTelevisionNearGenerator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_FindInteractable_CloseTelevisionNearGenerator>();
	}
};
static_assert(alignof(UAISkill_FindInteractable_CloseTelevisionNearGenerator) == 0x000008, "Wrong alignment on UAISkill_FindInteractable_CloseTelevisionNearGenerator");
static_assert(sizeof(UAISkill_FindInteractable_CloseTelevisionNearGenerator) == 0x000548, "Wrong size on UAISkill_FindInteractable_CloseTelevisionNearGenerator");
static_assert(offsetof(UAISkill_FindInteractable_CloseTelevisionNearGenerator, MaximumCondemnedPercentToCloseTelevision) == 0x000308, "Member 'UAISkill_FindInteractable_CloseTelevisionNearGenerator::MaximumCondemnedPercentToCloseTelevision' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_CloseTelevisionNearGenerator, DistanceBetweenGeneratorAndTelevisionThreshold) == 0x000368, "Member 'UAISkill_FindInteractable_CloseTelevisionNearGenerator::DistanceBetweenGeneratorAndTelevisionThreshold' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_CloseTelevisionNearGenerator, BaseValue) == 0x0003C8, "Member 'UAISkill_FindInteractable_CloseTelevisionNearGenerator::BaseValue' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_CloseTelevisionNearGenerator, CloseTelevisionDistanceLinearWeight) == 0x000428, "Member 'UAISkill_FindInteractable_CloseTelevisionNearGenerator::CloseTelevisionDistanceLinearWeight' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_CloseTelevisionNearGenerator, CloseTelevisionMaximumDistanceFromCamper) == 0x000488, "Member 'UAISkill_FindInteractable_CloseTelevisionNearGenerator::CloseTelevisionMaximumDistanceFromCamper' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_CloseTelevisionNearGenerator, MaxHeightDifferenceToCloseTelevisions) == 0x0004E8, "Member 'UAISkill_FindInteractable_CloseTelevisionNearGenerator::MaxHeightDifferenceToCloseTelevisions' has a wrong offset!");

// Class DBDBots.AISkill_K33UseTurret
// 0x0010 (0x0128 - 0x0118)
class UAISkill_K33UseTurret final : public UAISkill
{
public:
	class FName                                   TurretItemID;                                      // 0x0118(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_124[0x4];                                      // 0x0124(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_K33UseTurret">();
	}
	static class UAISkill_K33UseTurret* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_K33UseTurret>();
	}
};
static_assert(alignof(UAISkill_K33UseTurret) == 0x000008, "Wrong alignment on UAISkill_K33UseTurret");
static_assert(sizeof(UAISkill_K33UseTurret) == 0x000128, "Wrong size on UAISkill_K33UseTurret");
static_assert(offsetof(UAISkill_K33UseTurret, TurretItemID) == 0x000118, "Member 'UAISkill_K33UseTurret::TurretItemID' has a wrong offset!");

// Class DBDBots.AISkill_FindInteractable_Drone
// 0x00F0 (0x03F8 - 0x0308)
class UAISkill_FindInteractable_Drone final : public UAISkill_FindInteractable
{
public:
	struct FAITunableParameter                    BaseActiveWeight;                                  // 0x0308(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    BaseScoutingWeight;                                // 0x0368(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class AActor>>             ValidGoalObjectClasses;                            // 0x03C8(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, UObjectWrapper, NativeAccessSpecifierPublic)
	float                                         DroneRadiusMargin;                                 // 0x03D8(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DroneScoutingAutoDiscoverRange;                    // 0x03DC(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DroneStealthAutoDiscoverRange;                     // 0x03E0(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E4[0x14];                                     // 0x03E4(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_FindInteractable_Drone">();
	}
	static class UAISkill_FindInteractable_Drone* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_FindInteractable_Drone>();
	}
};
static_assert(alignof(UAISkill_FindInteractable_Drone) == 0x000008, "Wrong alignment on UAISkill_FindInteractable_Drone");
static_assert(sizeof(UAISkill_FindInteractable_Drone) == 0x0003F8, "Wrong size on UAISkill_FindInteractable_Drone");
static_assert(offsetof(UAISkill_FindInteractable_Drone, BaseActiveWeight) == 0x000308, "Member 'UAISkill_FindInteractable_Drone::BaseActiveWeight' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_Drone, BaseScoutingWeight) == 0x000368, "Member 'UAISkill_FindInteractable_Drone::BaseScoutingWeight' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_Drone, ValidGoalObjectClasses) == 0x0003C8, "Member 'UAISkill_FindInteractable_Drone::ValidGoalObjectClasses' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_Drone, DroneRadiusMargin) == 0x0003D8, "Member 'UAISkill_FindInteractable_Drone::DroneRadiusMargin' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_Drone, DroneScoutingAutoDiscoverRange) == 0x0003DC, "Member 'UAISkill_FindInteractable_Drone::DroneScoutingAutoDiscoverRange' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_Drone, DroneStealthAutoDiscoverRange) == 0x0003E0, "Member 'UAISkill_FindInteractable_Drone::DroneStealthAutoDiscoverRange' has a wrong offset!");

// Class DBDBots.AISkill_FindInteractable_K33ControlStation
// 0x0180 (0x0488 - 0x0308)
class UAISkill_FindInteractable_K33ControlStation final : public UAISkill_FindInteractable
{
public:
	struct FAITunableParameter                    GeneratorMaxRange;                                 // 0x0308(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    TurretProximityPenaltyMaxRange;                    // 0x0368(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    TurretsRemainingWeightBonus;                       // 0x03C8(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    TurretProximityWeightPenalty;                      // 0x0428(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_FindInteractable_K33ControlStation">();
	}
	static class UAISkill_FindInteractable_K33ControlStation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_FindInteractable_K33ControlStation>();
	}
};
static_assert(alignof(UAISkill_FindInteractable_K33ControlStation) == 0x000008, "Wrong alignment on UAISkill_FindInteractable_K33ControlStation");
static_assert(sizeof(UAISkill_FindInteractable_K33ControlStation) == 0x000488, "Wrong size on UAISkill_FindInteractable_K33ControlStation");
static_assert(offsetof(UAISkill_FindInteractable_K33ControlStation, GeneratorMaxRange) == 0x000308, "Member 'UAISkill_FindInteractable_K33ControlStation::GeneratorMaxRange' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_K33ControlStation, TurretProximityPenaltyMaxRange) == 0x000368, "Member 'UAISkill_FindInteractable_K33ControlStation::TurretProximityPenaltyMaxRange' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_K33ControlStation, TurretsRemainingWeightBonus) == 0x0003C8, "Member 'UAISkill_FindInteractable_K33ControlStation::TurretsRemainingWeightBonus' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_K33ControlStation, TurretProximityWeightPenalty) == 0x000428, "Member 'UAISkill_FindInteractable_K33ControlStation::TurretProximityWeightPenalty' has a wrong offset!");

// Class DBDBots.AISkill_PossessTheKiller
// 0x0000 (0x0280 - 0x0280)
class UAISkill_PossessTheKiller final : public UAISkill_Interaction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_PossessTheKiller">();
	}
	static class UAISkill_PossessTheKiller* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_PossessTheKiller>();
	}
};
static_assert(alignof(UAISkill_PossessTheKiller) == 0x000008, "Wrong alignment on UAISkill_PossessTheKiller");
static_assert(sizeof(UAISkill_PossessTheKiller) == 0x000280, "Wrong size on UAISkill_PossessTheKiller");

// Class DBDBots.AISkill_FindInteractable_K33Turret
// 0x0120 (0x0428 - 0x0308)
class UAISkill_FindInteractable_K33Turret final : public UAISkill_FindInteractable
{
public:
	struct FAITunableParameter                    RedeployGeneratorMaxRange;                         // 0x0308(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    UndeployGeneratorMaxRange;                         // 0x0368(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    UndeployCharacterMaxRange;                         // 0x03C8(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_FindInteractable_K33Turret">();
	}
	static class UAISkill_FindInteractable_K33Turret* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_FindInteractable_K33Turret>();
	}
};
static_assert(alignof(UAISkill_FindInteractable_K33Turret) == 0x000008, "Wrong alignment on UAISkill_FindInteractable_K33Turret");
static_assert(sizeof(UAISkill_FindInteractable_K33Turret) == 0x000428, "Wrong size on UAISkill_FindInteractable_K33Turret");
static_assert(offsetof(UAISkill_FindInteractable_K33Turret, RedeployGeneratorMaxRange) == 0x000308, "Member 'UAISkill_FindInteractable_K33Turret::RedeployGeneratorMaxRange' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_K33Turret, UndeployGeneratorMaxRange) == 0x000368, "Member 'UAISkill_FindInteractable_K33Turret::UndeployGeneratorMaxRange' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_K33Turret, UndeployCharacterMaxRange) == 0x0003C8, "Member 'UAISkill_FindInteractable_K33Turret::UndeployCharacterMaxRange' has a wrong offset!");

// Class DBDBots.AISkill_FindInteractable_K35Husk
// 0x00C0 (0x03C8 - 0x0308)
class UAISkill_FindInteractable_K35Husk final : public UAISkill_FindInteractable
{
public:
	struct FAITunableParameter                    KillerToHuskWeightPenaltyAtMinDistance;            // 0x0308(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    KillerToHuskWeightMaxDistance;                     // 0x0368(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_FindInteractable_K35Husk">();
	}
	static class UAISkill_FindInteractable_K35Husk* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_FindInteractable_K35Husk>();
	}
};
static_assert(alignof(UAISkill_FindInteractable_K35Husk) == 0x000008, "Wrong alignment on UAISkill_FindInteractable_K35Husk");
static_assert(sizeof(UAISkill_FindInteractable_K35Husk) == 0x0003C8, "Wrong size on UAISkill_FindInteractable_K35Husk");
static_assert(offsetof(UAISkill_FindInteractable_K35Husk, KillerToHuskWeightPenaltyAtMinDistance) == 0x000308, "Member 'UAISkill_FindInteractable_K35Husk::KillerToHuskWeightPenaltyAtMinDistance' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_K35Husk, KillerToHuskWeightMaxDistance) == 0x000368, "Member 'UAISkill_FindInteractable_K35Husk::KillerToHuskWeightMaxDistance' has a wrong offset!");

// Class DBDBots.BTDecorator_IsBeforeTimerExpiration
// 0x0090 (0x0100 - 0x0070)
class UBTDecorator_IsBeforeTimerExpiration final : public UBTDecorator
{
public:
	struct FAITunableParameter                    AdditionalTime;                                    // 0x0070(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBFilterKey;                                       // 0x00D0(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_IsBeforeTimerExpiration">();
	}
	static class UBTDecorator_IsBeforeTimerExpiration* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_IsBeforeTimerExpiration>();
	}
};
static_assert(alignof(UBTDecorator_IsBeforeTimerExpiration) == 0x000008, "Wrong alignment on UBTDecorator_IsBeforeTimerExpiration");
static_assert(sizeof(UBTDecorator_IsBeforeTimerExpiration) == 0x000100, "Wrong size on UBTDecorator_IsBeforeTimerExpiration");
static_assert(offsetof(UBTDecorator_IsBeforeTimerExpiration, AdditionalTime) == 0x000070, "Member 'UBTDecorator_IsBeforeTimerExpiration::AdditionalTime' has a wrong offset!");
static_assert(offsetof(UBTDecorator_IsBeforeTimerExpiration, BBFilterKey) == 0x0000D0, "Member 'UBTDecorator_IsBeforeTimerExpiration::BBFilterKey' has a wrong offset!");

// Class DBDBots.AISkill_FindInteractable_Reassurance
// 0x0368 (0x0670 - 0x0308)
class UAISkill_FindInteractable_Reassurance final : public UAISkill_FindInteractable
{
public:
	TSubclassOf<class UStatusEffect>              ReassuranceStatusEffect;                           // 0x0308(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    AllyDangerStateGoalWeight;                         // 0x0310(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    MaxHookTimeGoalWeight;                             // 0x0370(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    HumanAllyHookedGoalWeight;                         // 0x03D0(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    IdealKillerDistanceFromHook;                       // 0x0430(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    MaxKillerProximityWeight;                          // 0x0490(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    BotDangerStateGoalWeight;                          // 0x04F0(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    IncapacitatedAlliesGoalWeight;                     // 0x0550(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    BotInjuredStateGoalWeight;                         // 0x05B0(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<TWeakObjectPtr<class ACamperPlayer>>   _hookedAndNotReassuredSurvivors;                   // 0x0610(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_620[0x50];                                     // 0x0620(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_FindInteractable_Reassurance">();
	}
	static class UAISkill_FindInteractable_Reassurance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_FindInteractable_Reassurance>();
	}
};
static_assert(alignof(UAISkill_FindInteractable_Reassurance) == 0x000008, "Wrong alignment on UAISkill_FindInteractable_Reassurance");
static_assert(sizeof(UAISkill_FindInteractable_Reassurance) == 0x000670, "Wrong size on UAISkill_FindInteractable_Reassurance");
static_assert(offsetof(UAISkill_FindInteractable_Reassurance, ReassuranceStatusEffect) == 0x000308, "Member 'UAISkill_FindInteractable_Reassurance::ReassuranceStatusEffect' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_Reassurance, AllyDangerStateGoalWeight) == 0x000310, "Member 'UAISkill_FindInteractable_Reassurance::AllyDangerStateGoalWeight' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_Reassurance, MaxHookTimeGoalWeight) == 0x000370, "Member 'UAISkill_FindInteractable_Reassurance::MaxHookTimeGoalWeight' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_Reassurance, HumanAllyHookedGoalWeight) == 0x0003D0, "Member 'UAISkill_FindInteractable_Reassurance::HumanAllyHookedGoalWeight' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_Reassurance, IdealKillerDistanceFromHook) == 0x000430, "Member 'UAISkill_FindInteractable_Reassurance::IdealKillerDistanceFromHook' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_Reassurance, MaxKillerProximityWeight) == 0x000490, "Member 'UAISkill_FindInteractable_Reassurance::MaxKillerProximityWeight' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_Reassurance, BotDangerStateGoalWeight) == 0x0004F0, "Member 'UAISkill_FindInteractable_Reassurance::BotDangerStateGoalWeight' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_Reassurance, IncapacitatedAlliesGoalWeight) == 0x000550, "Member 'UAISkill_FindInteractable_Reassurance::IncapacitatedAlliesGoalWeight' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_Reassurance, BotInjuredStateGoalWeight) == 0x0005B0, "Member 'UAISkill_FindInteractable_Reassurance::BotInjuredStateGoalWeight' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_Reassurance, _hookedAndNotReassuredSurvivors) == 0x000610, "Member 'UAISkill_FindInteractable_Reassurance::_hookedAndNotReassuredSurvivors' has a wrong offset!");

// Class DBDBots.AISkill_FindInteractable_SeanceSpot
// 0x0628 (0x0930 - 0x0308)
class UAISkill_FindInteractable_SeanceSpot final : public UAISkill_FindInteractable
{
public:
	TArray<struct FKillerFilterItem>              LowerExposedValueKillers;                          // 0x0308(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FKillerFilterItem>              DirectTeleportKillers;                             // 0x0318(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class AActor>>             TeleportInteractables;                             // 0x0328(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	struct FPerkIdDropdown                        NoMitherPerk;                                      // 0x0338(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    PerHookWeight;                                     // 0x0348(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    LowerExposedValueWeight;                           // 0x03A8(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    TeleportKillerWeightPenalty;                       // 0x0408(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    KillerDistanceMaxWeight;                           // 0x0468(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    KillerMaxDistance;                                 // 0x04C8(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    KillerInChaseWeight;                               // 0x0528(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    KillerMovingAwayWeight;                            // 0x0588(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    KillerMovingAwayMaxAngle;                          // 0x05E8(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    LastSeenWeightPenalty;                             // 0x0648(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    LastSeenMaxTime;                                   // 0x06A8(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    LastVisitedWeightPenalty;                          // 0x0708(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    LastVisitedMaxTime;                                // 0x0768(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    JoinBaseWeight;                                    // 0x07C8(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    JoinWithPerkWeight;                                // 0x0828(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    SeanceOriginatorWeight;                            // 0x0888(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         Pad_8E8[0x48];                                     // 0x08E8(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnLevelReadyToPlay();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_FindInteractable_SeanceSpot">();
	}
	static class UAISkill_FindInteractable_SeanceSpot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_FindInteractable_SeanceSpot>();
	}
};
static_assert(alignof(UAISkill_FindInteractable_SeanceSpot) == 0x000008, "Wrong alignment on UAISkill_FindInteractable_SeanceSpot");
static_assert(sizeof(UAISkill_FindInteractable_SeanceSpot) == 0x000930, "Wrong size on UAISkill_FindInteractable_SeanceSpot");
static_assert(offsetof(UAISkill_FindInteractable_SeanceSpot, LowerExposedValueKillers) == 0x000308, "Member 'UAISkill_FindInteractable_SeanceSpot::LowerExposedValueKillers' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_SeanceSpot, DirectTeleportKillers) == 0x000318, "Member 'UAISkill_FindInteractable_SeanceSpot::DirectTeleportKillers' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_SeanceSpot, TeleportInteractables) == 0x000328, "Member 'UAISkill_FindInteractable_SeanceSpot::TeleportInteractables' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_SeanceSpot, NoMitherPerk) == 0x000338, "Member 'UAISkill_FindInteractable_SeanceSpot::NoMitherPerk' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_SeanceSpot, PerHookWeight) == 0x000348, "Member 'UAISkill_FindInteractable_SeanceSpot::PerHookWeight' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_SeanceSpot, LowerExposedValueWeight) == 0x0003A8, "Member 'UAISkill_FindInteractable_SeanceSpot::LowerExposedValueWeight' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_SeanceSpot, TeleportKillerWeightPenalty) == 0x000408, "Member 'UAISkill_FindInteractable_SeanceSpot::TeleportKillerWeightPenalty' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_SeanceSpot, KillerDistanceMaxWeight) == 0x000468, "Member 'UAISkill_FindInteractable_SeanceSpot::KillerDistanceMaxWeight' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_SeanceSpot, KillerMaxDistance) == 0x0004C8, "Member 'UAISkill_FindInteractable_SeanceSpot::KillerMaxDistance' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_SeanceSpot, KillerInChaseWeight) == 0x000528, "Member 'UAISkill_FindInteractable_SeanceSpot::KillerInChaseWeight' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_SeanceSpot, KillerMovingAwayWeight) == 0x000588, "Member 'UAISkill_FindInteractable_SeanceSpot::KillerMovingAwayWeight' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_SeanceSpot, KillerMovingAwayMaxAngle) == 0x0005E8, "Member 'UAISkill_FindInteractable_SeanceSpot::KillerMovingAwayMaxAngle' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_SeanceSpot, LastSeenWeightPenalty) == 0x000648, "Member 'UAISkill_FindInteractable_SeanceSpot::LastSeenWeightPenalty' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_SeanceSpot, LastSeenMaxTime) == 0x0006A8, "Member 'UAISkill_FindInteractable_SeanceSpot::LastSeenMaxTime' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_SeanceSpot, LastVisitedWeightPenalty) == 0x000708, "Member 'UAISkill_FindInteractable_SeanceSpot::LastVisitedWeightPenalty' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_SeanceSpot, LastVisitedMaxTime) == 0x000768, "Member 'UAISkill_FindInteractable_SeanceSpot::LastVisitedMaxTime' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_SeanceSpot, JoinBaseWeight) == 0x0007C8, "Member 'UAISkill_FindInteractable_SeanceSpot::JoinBaseWeight' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_SeanceSpot, JoinWithPerkWeight) == 0x000828, "Member 'UAISkill_FindInteractable_SeanceSpot::JoinWithPerkWeight' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_SeanceSpot, SeanceOriginatorWeight) == 0x000888, "Member 'UAISkill_FindInteractable_SeanceSpot::SeanceOriginatorWeight' has a wrong offset!");

// Class DBDBots.BTService_FindGoalObject
// 0x02D0 (0x0348 - 0x0078)
class UBTService_FindGoalObject : public UBTService
{
public:
	uint8                                         Pad_78[0x10];                                      // 0x0078(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlackboardKeySelector                 BBSearchAround;                                    // 0x0088(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	float                                         SearchInterval;                                    // 0x00B8(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SearchHeightAmplifierActivationHeight;             // 0x00BC(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SearchHeightAmplifier;                             // 0x00C0(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C4[0x4];                                       // 0x00C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UNavigationQueryFilter>     FilterClass;                                       // 0x00C8(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBObjectLocation;                                  // 0x00D0(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBObject;                                          // 0x0100(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    GoalBasicWeight;                                   // 0x0130(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    GoalWeightMaxDistance;                             // 0x0190(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    GoalWeightAtMinDistance;                           // 0x01F0(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    GoalWeightAtEndgameStart;                          // 0x0250(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    GoalWeightAtEndgameEnd;                            // 0x02B0(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FVector                                ProjectGoalLocationToNavigationExtent;             // 0x0310(0x0018)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ADBDAIBTController*                     _aiOwner;                                          // 0x0328(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_330[0x10];                                     // 0x0330(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          ShouldHideBBKeysInEditor;                          // 0x0340(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_341[0x7];                                      // 0x0341(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_FindGoalObject">();
	}
	static class UBTService_FindGoalObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_FindGoalObject>();
	}
};
static_assert(alignof(UBTService_FindGoalObject) == 0x000008, "Wrong alignment on UBTService_FindGoalObject");
static_assert(sizeof(UBTService_FindGoalObject) == 0x000348, "Wrong size on UBTService_FindGoalObject");
static_assert(offsetof(UBTService_FindGoalObject, BBSearchAround) == 0x000088, "Member 'UBTService_FindGoalObject::BBSearchAround' has a wrong offset!");
static_assert(offsetof(UBTService_FindGoalObject, SearchInterval) == 0x0000B8, "Member 'UBTService_FindGoalObject::SearchInterval' has a wrong offset!");
static_assert(offsetof(UBTService_FindGoalObject, SearchHeightAmplifierActivationHeight) == 0x0000BC, "Member 'UBTService_FindGoalObject::SearchHeightAmplifierActivationHeight' has a wrong offset!");
static_assert(offsetof(UBTService_FindGoalObject, SearchHeightAmplifier) == 0x0000C0, "Member 'UBTService_FindGoalObject::SearchHeightAmplifier' has a wrong offset!");
static_assert(offsetof(UBTService_FindGoalObject, FilterClass) == 0x0000C8, "Member 'UBTService_FindGoalObject::FilterClass' has a wrong offset!");
static_assert(offsetof(UBTService_FindGoalObject, BBObjectLocation) == 0x0000D0, "Member 'UBTService_FindGoalObject::BBObjectLocation' has a wrong offset!");
static_assert(offsetof(UBTService_FindGoalObject, BBObject) == 0x000100, "Member 'UBTService_FindGoalObject::BBObject' has a wrong offset!");
static_assert(offsetof(UBTService_FindGoalObject, GoalBasicWeight) == 0x000130, "Member 'UBTService_FindGoalObject::GoalBasicWeight' has a wrong offset!");
static_assert(offsetof(UBTService_FindGoalObject, GoalWeightMaxDistance) == 0x000190, "Member 'UBTService_FindGoalObject::GoalWeightMaxDistance' has a wrong offset!");
static_assert(offsetof(UBTService_FindGoalObject, GoalWeightAtMinDistance) == 0x0001F0, "Member 'UBTService_FindGoalObject::GoalWeightAtMinDistance' has a wrong offset!");
static_assert(offsetof(UBTService_FindGoalObject, GoalWeightAtEndgameStart) == 0x000250, "Member 'UBTService_FindGoalObject::GoalWeightAtEndgameStart' has a wrong offset!");
static_assert(offsetof(UBTService_FindGoalObject, GoalWeightAtEndgameEnd) == 0x0002B0, "Member 'UBTService_FindGoalObject::GoalWeightAtEndgameEnd' has a wrong offset!");
static_assert(offsetof(UBTService_FindGoalObject, ProjectGoalLocationToNavigationExtent) == 0x000310, "Member 'UBTService_FindGoalObject::ProjectGoalLocationToNavigationExtent' has a wrong offset!");
static_assert(offsetof(UBTService_FindGoalObject, _aiOwner) == 0x000328, "Member 'UBTService_FindGoalObject::_aiOwner' has a wrong offset!");
static_assert(offsetof(UBTService_FindGoalObject, ShouldHideBBKeysInEditor) == 0x000340, "Member 'UBTService_FindGoalObject::ShouldHideBBKeysInEditor' has a wrong offset!");

// Class DBDBots.BTService_FindInteractor
// 0x0310 (0x0658 - 0x0348)
class UBTService_FindInteractor : public UBTService_FindGoalObject
{
public:
	bool                                          RegisterAsDiscoveredWhenFound;                     // 0x0348(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_349[0x7];                                      // 0x0349(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlackboardKeySelector                 BBOnlyFromActor;                                   // 0x0350(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	TArray<class FString>                         OnlyWithInteractorIDs;                             // 0x0380(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	float                                         RejectIfTerrorIsCloserThanSelfMargin;              // 0x0390(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RejectIfInTerrorRadius;                            // 0x0394(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RejectIfInPressureZone;                            // 0x0398(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseLastKnownPositionForTerrorRejects;              // 0x0399(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RejectIfWasInCooldownAndFocusedOnAnotherObject;    // 0x039A(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39B[0x1];                                      // 0x039B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   RejectCooldownContextName;                         // 0x039C(0x000C)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IgnoreMindFocusCooldown;                           // 0x03A8(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RejectIfAnySiblingInteractorHasCooldown;           // 0x03A9(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AbandonIfInChase;                                  // 0x03AA(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RejectIfFocusedByOther;                            // 0x03AB(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RejectIfInteractableFocusedByOther;                // 0x03AC(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RejectIfNotFocusedBySelf;                          // 0x03AD(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IgnoreFocusFilterInEndgameCollapse;                // 0x03AE(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RejectIfNotInSight;                                // 0x03AF(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IgnoreSightFilterIfDiscovered;                     // 0x03B0(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IgnoreSightFilterIfInRange;                        // 0x03B1(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B2[0x2];                                      // 0x03B2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RejectAboveRange;                                  // 0x03B4(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IgnoreRangeFilterIfDiscovered;                     // 0x03B8(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IgnoreRangeFilterIfInSight;                        // 0x03B9(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3BA[0x6];                                      // 0x03BA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlackboardKeySelector                 BBInteractLocation;                                // 0x03C0(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBInteractorObj;                                   // 0x03F0(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	bool                                          UsesActorLocation;                                 // 0x0420(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_421[0x7];                                      // 0x0421(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAITunableParameter                    CantInterruptGoalInteractionUnderRemainingTime;    // 0x0428(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    GoalWeightBonusWhileInteracting;                   // 0x0488(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	class FName                                   InteractionSpeedStatusEffectID;                    // 0x04E8(0x000C)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4F4[0x4];                                      // 0x04F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAITunableParameter                    GoalWeightInteractionSpeedVariance;                // 0x04F8(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	bool                                          IsUnsafeAction;                                    // 0x0558(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_559[0x7];                                      // 0x0559(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlackboardKeySelector                 BBUnsafeActionID;                                  // 0x0560(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBUnsafeActionUsesItemAddons;                      // 0x0590(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBUnsafeActionIsSelfInteraction;                   // 0x05C0(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBUnsafeActionRange;                               // 0x05F0(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	class FString                                 UnsafeInteractionID;                               // 0x0620(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UnsafeActionUsesItemAddons;                        // 0x0630(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UnsafeActionIsSelfInteraction;                     // 0x0631(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_632[0x2];                                      // 0x0632(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UnsafeActionRange;                                 // 0x0634(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           WeightSkillContext;                                // 0x0638(0x000C)(Edit, DisableEditOnTemplate, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_644[0x4];                                      // 0x0644(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UInteractor*                            _goalInteractor;                                   // 0x0648(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_650[0x8];                                      // 0x0650(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_FindInteractor">();
	}
	static class UBTService_FindInteractor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_FindInteractor>();
	}
};
static_assert(alignof(UBTService_FindInteractor) == 0x000008, "Wrong alignment on UBTService_FindInteractor");
static_assert(sizeof(UBTService_FindInteractor) == 0x000658, "Wrong size on UBTService_FindInteractor");
static_assert(offsetof(UBTService_FindInteractor, RegisterAsDiscoveredWhenFound) == 0x000348, "Member 'UBTService_FindInteractor::RegisterAsDiscoveredWhenFound' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor, BBOnlyFromActor) == 0x000350, "Member 'UBTService_FindInteractor::BBOnlyFromActor' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor, OnlyWithInteractorIDs) == 0x000380, "Member 'UBTService_FindInteractor::OnlyWithInteractorIDs' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor, RejectIfTerrorIsCloserThanSelfMargin) == 0x000390, "Member 'UBTService_FindInteractor::RejectIfTerrorIsCloserThanSelfMargin' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor, RejectIfInTerrorRadius) == 0x000394, "Member 'UBTService_FindInteractor::RejectIfInTerrorRadius' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor, RejectIfInPressureZone) == 0x000398, "Member 'UBTService_FindInteractor::RejectIfInPressureZone' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor, UseLastKnownPositionForTerrorRejects) == 0x000399, "Member 'UBTService_FindInteractor::UseLastKnownPositionForTerrorRejects' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor, RejectIfWasInCooldownAndFocusedOnAnotherObject) == 0x00039A, "Member 'UBTService_FindInteractor::RejectIfWasInCooldownAndFocusedOnAnotherObject' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor, RejectCooldownContextName) == 0x00039C, "Member 'UBTService_FindInteractor::RejectCooldownContextName' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor, IgnoreMindFocusCooldown) == 0x0003A8, "Member 'UBTService_FindInteractor::IgnoreMindFocusCooldown' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor, RejectIfAnySiblingInteractorHasCooldown) == 0x0003A9, "Member 'UBTService_FindInteractor::RejectIfAnySiblingInteractorHasCooldown' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor, AbandonIfInChase) == 0x0003AA, "Member 'UBTService_FindInteractor::AbandonIfInChase' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor, RejectIfFocusedByOther) == 0x0003AB, "Member 'UBTService_FindInteractor::RejectIfFocusedByOther' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor, RejectIfInteractableFocusedByOther) == 0x0003AC, "Member 'UBTService_FindInteractor::RejectIfInteractableFocusedByOther' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor, RejectIfNotFocusedBySelf) == 0x0003AD, "Member 'UBTService_FindInteractor::RejectIfNotFocusedBySelf' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor, IgnoreFocusFilterInEndgameCollapse) == 0x0003AE, "Member 'UBTService_FindInteractor::IgnoreFocusFilterInEndgameCollapse' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor, RejectIfNotInSight) == 0x0003AF, "Member 'UBTService_FindInteractor::RejectIfNotInSight' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor, IgnoreSightFilterIfDiscovered) == 0x0003B0, "Member 'UBTService_FindInteractor::IgnoreSightFilterIfDiscovered' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor, IgnoreSightFilterIfInRange) == 0x0003B1, "Member 'UBTService_FindInteractor::IgnoreSightFilterIfInRange' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor, RejectAboveRange) == 0x0003B4, "Member 'UBTService_FindInteractor::RejectAboveRange' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor, IgnoreRangeFilterIfDiscovered) == 0x0003B8, "Member 'UBTService_FindInteractor::IgnoreRangeFilterIfDiscovered' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor, IgnoreRangeFilterIfInSight) == 0x0003B9, "Member 'UBTService_FindInteractor::IgnoreRangeFilterIfInSight' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor, BBInteractLocation) == 0x0003C0, "Member 'UBTService_FindInteractor::BBInteractLocation' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor, BBInteractorObj) == 0x0003F0, "Member 'UBTService_FindInteractor::BBInteractorObj' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor, UsesActorLocation) == 0x000420, "Member 'UBTService_FindInteractor::UsesActorLocation' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor, CantInterruptGoalInteractionUnderRemainingTime) == 0x000428, "Member 'UBTService_FindInteractor::CantInterruptGoalInteractionUnderRemainingTime' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor, GoalWeightBonusWhileInteracting) == 0x000488, "Member 'UBTService_FindInteractor::GoalWeightBonusWhileInteracting' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor, InteractionSpeedStatusEffectID) == 0x0004E8, "Member 'UBTService_FindInteractor::InteractionSpeedStatusEffectID' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor, GoalWeightInteractionSpeedVariance) == 0x0004F8, "Member 'UBTService_FindInteractor::GoalWeightInteractionSpeedVariance' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor, IsUnsafeAction) == 0x000558, "Member 'UBTService_FindInteractor::IsUnsafeAction' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor, BBUnsafeActionID) == 0x000560, "Member 'UBTService_FindInteractor::BBUnsafeActionID' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor, BBUnsafeActionUsesItemAddons) == 0x000590, "Member 'UBTService_FindInteractor::BBUnsafeActionUsesItemAddons' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor, BBUnsafeActionIsSelfInteraction) == 0x0005C0, "Member 'UBTService_FindInteractor::BBUnsafeActionIsSelfInteraction' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor, BBUnsafeActionRange) == 0x0005F0, "Member 'UBTService_FindInteractor::BBUnsafeActionRange' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor, UnsafeInteractionID) == 0x000620, "Member 'UBTService_FindInteractor::UnsafeInteractionID' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor, UnsafeActionUsesItemAddons) == 0x000630, "Member 'UBTService_FindInteractor::UnsafeActionUsesItemAddons' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor, UnsafeActionIsSelfInteraction) == 0x000631, "Member 'UBTService_FindInteractor::UnsafeActionIsSelfInteraction' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor, UnsafeActionRange) == 0x000634, "Member 'UBTService_FindInteractor::UnsafeActionRange' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor, WeightSkillContext) == 0x000638, "Member 'UBTService_FindInteractor::WeightSkillContext' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor, _goalInteractor) == 0x000648, "Member 'UBTService_FindInteractor::_goalInteractor' has a wrong offset!");

// Class DBDBots.BTService_FindInteractor_Exit
// 0x0108 (0x0760 - 0x0658)
class UBTService_FindInteractor_Exit final : public UBTService_FindInteractor
{
public:
	EFindInteractorExitOptions                    Filter;                                            // 0x0658(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFindInteractorOpenConditions                 OpenCondition;                                     // 0x0659(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_65A[0x6];                                      // 0x065A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlackboardKeySelector                 BBFinalExitLocation;                               // 0x0660(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	float                                         ClosedDoorOffset;                                  // 0x0690(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OpenDoorOffset;                                    // 0x0694(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AbortOnBlockedExitSwitch;                          // 0x0698(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_699[0x7];                                      // 0x0699(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAITunableParameter                    OpenedExitGoalWeight;                              // 0x06A0(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    HatchBonusGoalWeight;                              // 0x0700(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_FindInteractor_Exit">();
	}
	static class UBTService_FindInteractor_Exit* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_FindInteractor_Exit>();
	}
};
static_assert(alignof(UBTService_FindInteractor_Exit) == 0x000008, "Wrong alignment on UBTService_FindInteractor_Exit");
static_assert(sizeof(UBTService_FindInteractor_Exit) == 0x000760, "Wrong size on UBTService_FindInteractor_Exit");
static_assert(offsetof(UBTService_FindInteractor_Exit, Filter) == 0x000658, "Member 'UBTService_FindInteractor_Exit::Filter' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_Exit, OpenCondition) == 0x000659, "Member 'UBTService_FindInteractor_Exit::OpenCondition' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_Exit, BBFinalExitLocation) == 0x000660, "Member 'UBTService_FindInteractor_Exit::BBFinalExitLocation' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_Exit, ClosedDoorOffset) == 0x000690, "Member 'UBTService_FindInteractor_Exit::ClosedDoorOffset' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_Exit, OpenDoorOffset) == 0x000694, "Member 'UBTService_FindInteractor_Exit::OpenDoorOffset' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_Exit, AbortOnBlockedExitSwitch) == 0x000698, "Member 'UBTService_FindInteractor_Exit::AbortOnBlockedExitSwitch' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_Exit, OpenedExitGoalWeight) == 0x0006A0, "Member 'UBTService_FindInteractor_Exit::OpenedExitGoalWeight' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_Exit, HatchBonusGoalWeight) == 0x000700, "Member 'UBTService_FindInteractor_Exit::HatchBonusGoalWeight' has a wrong offset!");

// Class DBDBots.AISkill_FindInteractable_SolveCondemned
// 0x01E0 (0x04E8 - 0x0308)
class UAISkill_FindInteractable_SolveCondemned final : public UAISkill_FindInteractable
{
public:
	struct FAITunableParameter                    NearCondemnedWeight;                               // 0x0308(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    HighCondemnedThreshold;                            // 0x0368(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    MaxLockedCondemnThreshold;                         // 0x03C8(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    SolveCondemnedBasicWeight;                         // 0x0428(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    CondemnedLevelProportionalWeight;                  // 0x0488(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_FindInteractable_SolveCondemned">();
	}
	static class UAISkill_FindInteractable_SolveCondemned* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_FindInteractable_SolveCondemned>();
	}
};
static_assert(alignof(UAISkill_FindInteractable_SolveCondemned) == 0x000008, "Wrong alignment on UAISkill_FindInteractable_SolveCondemned");
static_assert(sizeof(UAISkill_FindInteractable_SolveCondemned) == 0x0004E8, "Wrong size on UAISkill_FindInteractable_SolveCondemned");
static_assert(offsetof(UAISkill_FindInteractable_SolveCondemned, NearCondemnedWeight) == 0x000308, "Member 'UAISkill_FindInteractable_SolveCondemned::NearCondemnedWeight' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_SolveCondemned, HighCondemnedThreshold) == 0x000368, "Member 'UAISkill_FindInteractable_SolveCondemned::HighCondemnedThreshold' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_SolveCondemned, MaxLockedCondemnThreshold) == 0x0003C8, "Member 'UAISkill_FindInteractable_SolveCondemned::MaxLockedCondemnThreshold' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_SolveCondemned, SolveCondemnedBasicWeight) == 0x000428, "Member 'UAISkill_FindInteractable_SolveCondemned::SolveCondemnedBasicWeight' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_SolveCondemned, CondemnedLevelProportionalWeight) == 0x000488, "Member 'UAISkill_FindInteractable_SolveCondemned::CondemnedLevelProportionalWeight' has a wrong offset!");

// Class DBDBots.AISkill_FindInteractable_SolveRBT
// 0x00C0 (0x03C8 - 0x0308)
class UAISkill_FindInteractable_SolveRBT final : public UAISkill_FindInteractable
{
public:
	struct FAITunableParameter                    UrgencyGoalWeight;                                 // 0x0308(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    PriorityGoalWeight;                                // 0x0368(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_FindInteractable_SolveRBT">();
	}
	static class UAISkill_FindInteractable_SolveRBT* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_FindInteractable_SolveRBT>();
	}
};
static_assert(alignof(UAISkill_FindInteractable_SolveRBT) == 0x000008, "Wrong alignment on UAISkill_FindInteractable_SolveRBT");
static_assert(sizeof(UAISkill_FindInteractable_SolveRBT) == 0x0003C8, "Wrong size on UAISkill_FindInteractable_SolveRBT");
static_assert(offsetof(UAISkill_FindInteractable_SolveRBT, UrgencyGoalWeight) == 0x000308, "Member 'UAISkill_FindInteractable_SolveRBT::UrgencyGoalWeight' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_SolveRBT, PriorityGoalWeight) == 0x000368, "Member 'UAISkill_FindInteractable_SolveRBT::PriorityGoalWeight' has a wrong offset!");

// Class DBDBots.AISkill_FindInteractable_StatusEffect
// 0x0010 (0x0318 - 0x0308)
class UAISkill_FindInteractable_StatusEffect : public UAISkill_FindInteractable
{
public:
	struct FGameplayTag                           RequiredPerkFlag;                                  // 0x0308(0x000C)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InvertCondition;                                   // 0x0314(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_315[0x3];                                      // 0x0315(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_FindInteractable_StatusEffect">();
	}
	static class UAISkill_FindInteractable_StatusEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_FindInteractable_StatusEffect>();
	}
};
static_assert(alignof(UAISkill_FindInteractable_StatusEffect) == 0x000008, "Wrong alignment on UAISkill_FindInteractable_StatusEffect");
static_assert(sizeof(UAISkill_FindInteractable_StatusEffect) == 0x000318, "Wrong size on UAISkill_FindInteractable_StatusEffect");
static_assert(offsetof(UAISkill_FindInteractable_StatusEffect, RequiredPerkFlag) == 0x000308, "Member 'UAISkill_FindInteractable_StatusEffect::RequiredPerkFlag' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_StatusEffect, InvertCondition) == 0x000314, "Member 'UAISkill_FindInteractable_StatusEffect::InvertCondition' has a wrong offset!");

// Class DBDBots.BTService_FindInteractor_Pallet
// 0x0480 (0x0AD8 - 0x0658)
class UBTService_FindInteractor_Pallet final : public UBTService_FindInteractor
{
public:
	EFindInteractablePalletIntentions             IntentionFilter;                                   // 0x0658(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_659[0x7];                                      // 0x0659(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                InteractableLocationOffset;                        // 0x0660(0x0018)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGameplayTag>                   RestorePalletGameplayTags;                         // 0x0678(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    BrokenGeneratorGoalMaxDistance;                    // 0x0688(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    BrokenGeneratorGoalMaxDistanceWeight;              // 0x06E8(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    MaxSafetyRatingWeight;                             // 0x0748(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    SpawnInSurvivorLOSPenalty;                         // 0x07A8(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    SpawnNearSurvivorMinDistanceSquared;               // 0x0808(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    SpawnNearSurvivorPenalty;                          // 0x0868(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    PlacedNearGamePalletMinDistanceSquared;            // 0x08C8(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    PlacedNearGamePalletPenalty;                       // 0x0928(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    ConvincingFactorTolerance;                         // 0x0988(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	bool                                          SkipSafetyCheck;                                   // 0x09E8(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9E9[0x7];                                      // 0x09E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlackboardKeySelector                 BBPickSideRelativelyFrom;                          // 0x09F0(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FVector                                AcceptablePalletDropExtent;                        // 0x0A20(0x0018)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBEvadePointCrossingDest;                          // 0x0A38(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	float                                         ExtraHealthySurvivorActionTime;                    // 0x0A68(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExtraInjuredSurvivorActionTime;                    // 0x0A6C(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PalletInteractorLocationOffset;                    // 0x0A70(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AcceptableEvadePointCrossingDestDist;              // 0x0A74(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A78[0x60];                                     // 0x0A78(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_FindInteractor_Pallet">();
	}
	static class UBTService_FindInteractor_Pallet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_FindInteractor_Pallet>();
	}
};
static_assert(alignof(UBTService_FindInteractor_Pallet) == 0x000008, "Wrong alignment on UBTService_FindInteractor_Pallet");
static_assert(sizeof(UBTService_FindInteractor_Pallet) == 0x000AD8, "Wrong size on UBTService_FindInteractor_Pallet");
static_assert(offsetof(UBTService_FindInteractor_Pallet, IntentionFilter) == 0x000658, "Member 'UBTService_FindInteractor_Pallet::IntentionFilter' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_Pallet, InteractableLocationOffset) == 0x000660, "Member 'UBTService_FindInteractor_Pallet::InteractableLocationOffset' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_Pallet, RestorePalletGameplayTags) == 0x000678, "Member 'UBTService_FindInteractor_Pallet::RestorePalletGameplayTags' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_Pallet, BrokenGeneratorGoalMaxDistance) == 0x000688, "Member 'UBTService_FindInteractor_Pallet::BrokenGeneratorGoalMaxDistance' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_Pallet, BrokenGeneratorGoalMaxDistanceWeight) == 0x0006E8, "Member 'UBTService_FindInteractor_Pallet::BrokenGeneratorGoalMaxDistanceWeight' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_Pallet, MaxSafetyRatingWeight) == 0x000748, "Member 'UBTService_FindInteractor_Pallet::MaxSafetyRatingWeight' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_Pallet, SpawnInSurvivorLOSPenalty) == 0x0007A8, "Member 'UBTService_FindInteractor_Pallet::SpawnInSurvivorLOSPenalty' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_Pallet, SpawnNearSurvivorMinDistanceSquared) == 0x000808, "Member 'UBTService_FindInteractor_Pallet::SpawnNearSurvivorMinDistanceSquared' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_Pallet, SpawnNearSurvivorPenalty) == 0x000868, "Member 'UBTService_FindInteractor_Pallet::SpawnNearSurvivorPenalty' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_Pallet, PlacedNearGamePalletMinDistanceSquared) == 0x0008C8, "Member 'UBTService_FindInteractor_Pallet::PlacedNearGamePalletMinDistanceSquared' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_Pallet, PlacedNearGamePalletPenalty) == 0x000928, "Member 'UBTService_FindInteractor_Pallet::PlacedNearGamePalletPenalty' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_Pallet, ConvincingFactorTolerance) == 0x000988, "Member 'UBTService_FindInteractor_Pallet::ConvincingFactorTolerance' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_Pallet, SkipSafetyCheck) == 0x0009E8, "Member 'UBTService_FindInteractor_Pallet::SkipSafetyCheck' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_Pallet, BBPickSideRelativelyFrom) == 0x0009F0, "Member 'UBTService_FindInteractor_Pallet::BBPickSideRelativelyFrom' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_Pallet, AcceptablePalletDropExtent) == 0x000A20, "Member 'UBTService_FindInteractor_Pallet::AcceptablePalletDropExtent' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_Pallet, BBEvadePointCrossingDest) == 0x000A38, "Member 'UBTService_FindInteractor_Pallet::BBEvadePointCrossingDest' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_Pallet, ExtraHealthySurvivorActionTime) == 0x000A68, "Member 'UBTService_FindInteractor_Pallet::ExtraHealthySurvivorActionTime' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_Pallet, ExtraInjuredSurvivorActionTime) == 0x000A6C, "Member 'UBTService_FindInteractor_Pallet::ExtraInjuredSurvivorActionTime' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_Pallet, PalletInteractorLocationOffset) == 0x000A70, "Member 'UBTService_FindInteractor_Pallet::PalletInteractorLocationOffset' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_Pallet, AcceptableEvadePointCrossingDestDist) == 0x000A74, "Member 'UBTService_FindInteractor_Pallet::AcceptableEvadePointCrossingDestDist' has a wrong offset!");

// Class DBDBots.AISkill_FindInteractable_StatusEffect_Plague
// 0x0000 (0x0318 - 0x0318)
class UAISkill_FindInteractable_StatusEffect_Plague final : public UAISkill_FindInteractable_StatusEffect
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_FindInteractable_StatusEffect_Plague">();
	}
	static class UAISkill_FindInteractable_StatusEffect_Plague* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_FindInteractable_StatusEffect_Plague>();
	}
};
static_assert(alignof(UAISkill_FindInteractable_StatusEffect_Plague) == 0x000008, "Wrong alignment on UAISkill_FindInteractable_StatusEffect_Plague");
static_assert(sizeof(UAISkill_FindInteractable_StatusEffect_Plague) == 0x000318, "Wrong size on UAISkill_FindInteractable_StatusEffect_Plague");

// Class DBDBots.AISkill_FindInteractable_TeleportInteractable
// 0x00D8 (0x03E0 - 0x0308)
class UAISkill_FindInteractable_TeleportInteractable final : public UAISkill_FindInteractable
{
public:
	struct FAITunableParameter                    GoalValidDistance;                                 // 0x0308(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    TeleportFixedWeight;                               // 0x0368(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         CacheActorsInterval;                               // 0x03C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3CC[0x14];                                     // 0x03CC(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_FindInteractable_TeleportInteractable">();
	}
	static class UAISkill_FindInteractable_TeleportInteractable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_FindInteractable_TeleportInteractable>();
	}
};
static_assert(alignof(UAISkill_FindInteractable_TeleportInteractable) == 0x000008, "Wrong alignment on UAISkill_FindInteractable_TeleportInteractable");
static_assert(sizeof(UAISkill_FindInteractable_TeleportInteractable) == 0x0003E0, "Wrong size on UAISkill_FindInteractable_TeleportInteractable");
static_assert(offsetof(UAISkill_FindInteractable_TeleportInteractable, GoalValidDistance) == 0x000308, "Member 'UAISkill_FindInteractable_TeleportInteractable::GoalValidDistance' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_TeleportInteractable, TeleportFixedWeight) == 0x000368, "Member 'UAISkill_FindInteractable_TeleportInteractable::TeleportFixedWeight' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_TeleportInteractable, CacheActorsInterval) == 0x0003C8, "Member 'UAISkill_FindInteractable_TeleportInteractable::CacheActorsInterval' has a wrong offset!");

// Class DBDBots.AISkill_Find_StrengthInShadows
// 0x0120 (0x0410 - 0x02F0)
class UAISkill_Find_StrengthInShadows final : public UAISkill_Find
{
public:
	struct FAITunableParameter                    KillerDistanceMaxWeightPenalty;                    // 0x02F0(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    KillerMaxDistance;                                 // 0x0350(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         BasementVerticalOffset;                            // 0x03B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B4[0x5C];                                     // 0x03B4(0x005C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnLevelReadyToPlay();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_Find_StrengthInShadows">();
	}
	static class UAISkill_Find_StrengthInShadows* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_Find_StrengthInShadows>();
	}
};
static_assert(alignof(UAISkill_Find_StrengthInShadows) == 0x000008, "Wrong alignment on UAISkill_Find_StrengthInShadows");
static_assert(sizeof(UAISkill_Find_StrengthInShadows) == 0x000410, "Wrong size on UAISkill_Find_StrengthInShadows");
static_assert(offsetof(UAISkill_Find_StrengthInShadows, KillerDistanceMaxWeightPenalty) == 0x0002F0, "Member 'UAISkill_Find_StrengthInShadows::KillerDistanceMaxWeightPenalty' has a wrong offset!");
static_assert(offsetof(UAISkill_Find_StrengthInShadows, KillerMaxDistance) == 0x000350, "Member 'UAISkill_Find_StrengthInShadows::KillerMaxDistance' has a wrong offset!");
static_assert(offsetof(UAISkill_Find_StrengthInShadows, BasementVerticalOffset) == 0x0003B0, "Member 'UAISkill_Find_StrengthInShadows::BasementVerticalOffset' has a wrong offset!");

// Class DBDBots.BTService_FindInteractor_Totem
// 0x0100 (0x0758 - 0x0658)
class UBTService_FindInteractor_Totem final : public UBTService_FindInteractor
{
public:
	struct FAITunableParameter                    InactiveGoalWeightMaxDistance;                     // 0x0658(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    InactiveGoalWeightAtMinDistance;                   // 0x06B8(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FAIPerkTunableWeightArray              GoalPerkWeight;                                    // 0x0718(0x0010)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	TArray<struct FAICleansePerkCondition>        CleansePerks;                                      // 0x0728(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	bool                                          SearchUsingBoundPerks;                             // 0x0738(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_739[0x7];                                      // 0x0739(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           BoundPerkIds;                                      // 0x0740(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	bool                                          OnlyWhenInjured;                                   // 0x0750(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_751[0x7];                                      // 0x0751(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_FindInteractor_Totem">();
	}
	static class UBTService_FindInteractor_Totem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_FindInteractor_Totem>();
	}
};
static_assert(alignof(UBTService_FindInteractor_Totem) == 0x000008, "Wrong alignment on UBTService_FindInteractor_Totem");
static_assert(sizeof(UBTService_FindInteractor_Totem) == 0x000758, "Wrong size on UBTService_FindInteractor_Totem");
static_assert(offsetof(UBTService_FindInteractor_Totem, InactiveGoalWeightMaxDistance) == 0x000658, "Member 'UBTService_FindInteractor_Totem::InactiveGoalWeightMaxDistance' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_Totem, InactiveGoalWeightAtMinDistance) == 0x0006B8, "Member 'UBTService_FindInteractor_Totem::InactiveGoalWeightAtMinDistance' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_Totem, GoalPerkWeight) == 0x000718, "Member 'UBTService_FindInteractor_Totem::GoalPerkWeight' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_Totem, CleansePerks) == 0x000728, "Member 'UBTService_FindInteractor_Totem::CleansePerks' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_Totem, SearchUsingBoundPerks) == 0x000738, "Member 'UBTService_FindInteractor_Totem::SearchUsingBoundPerks' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_Totem, BoundPerkIds) == 0x000740, "Member 'UBTService_FindInteractor_Totem::BoundPerkIds' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_Totem, OnlyWhenInjured) == 0x000750, "Member 'UBTService_FindInteractor_Totem::OnlyWhenInjured' has a wrong offset!");

// Class DBDBots.AISkill_InteractionSetTrap_DreamPallet
// 0x0000 (0x0290 - 0x0290)
class UAISkill_InteractionSetTrap_DreamPallet final : public UAISkill_InteractionSetTrap
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_InteractionSetTrap_DreamPallet">();
	}
	static class UAISkill_InteractionSetTrap_DreamPallet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_InteractionSetTrap_DreamPallet>();
	}
};
static_assert(alignof(UAISkill_InteractionSetTrap_DreamPallet) == 0x000008, "Wrong alignment on UAISkill_InteractionSetTrap_DreamPallet");
static_assert(sizeof(UAISkill_InteractionSetTrap_DreamPallet) == 0x000290, "Wrong size on UAISkill_InteractionSetTrap_DreamPallet");

// Class DBDBots.AISkill_InteractionSetTrap_DreamSnare
// 0x0000 (0x0290 - 0x0290)
class UAISkill_InteractionSetTrap_DreamSnare final : public UAISkill_InteractionSetTrap
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_InteractionSetTrap_DreamSnare">();
	}
	static class UAISkill_InteractionSetTrap_DreamSnare* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_InteractionSetTrap_DreamSnare>();
	}
};
static_assert(alignof(UAISkill_InteractionSetTrap_DreamSnare) == 0x000008, "Wrong alignment on UAISkill_InteractionSetTrap_DreamSnare");
static_assert(sizeof(UAISkill_InteractionSetTrap_DreamSnare) == 0x000290, "Wrong size on UAISkill_InteractionSetTrap_DreamSnare");

// Class DBDBots.BTService_FindObject_K32EmpTarget
// 0x00A8 (0x02C8 - 0x0220)
class UBTService_FindObject_K32EmpTarget final : public UBTService_FindObject
{
public:
	TArray<TSubclassOf<class AActor>>             ValidGoalObjectClasses;                            // 0x0220(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, UObjectWrapper, NativeAccessSpecifierPublic)
	float                                         NearGoalPodHorizontalDistance;                     // 0x0230(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NearGoalPodVerticalDistance;                       // 0x0234(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NearGoalSurvivorHorizontalDistance;                // 0x0238(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NearGoalSurvivorVerticalDistance;                  // 0x023C(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OtherSurvivorNearTargetDistance;                   // 0x0240(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_244[0x4];                                      // 0x0244(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                NavMeshTargetLocationExtents;                      // 0x0248(0x0018)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CheckDynamicSubtreeInterval;                       // 0x0260(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_264[0x4];                                      // 0x0264(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlackboardKeySelector                 BBOriginalFocusedActor;                            // 0x0268(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	uint8                                         Pad_298[0x30];                                     // 0x0298(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_FindObject_K32EmpTarget">();
	}
	static class UBTService_FindObject_K32EmpTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_FindObject_K32EmpTarget>();
	}
};
static_assert(alignof(UBTService_FindObject_K32EmpTarget) == 0x000008, "Wrong alignment on UBTService_FindObject_K32EmpTarget");
static_assert(sizeof(UBTService_FindObject_K32EmpTarget) == 0x0002C8, "Wrong size on UBTService_FindObject_K32EmpTarget");
static_assert(offsetof(UBTService_FindObject_K32EmpTarget, ValidGoalObjectClasses) == 0x000220, "Member 'UBTService_FindObject_K32EmpTarget::ValidGoalObjectClasses' has a wrong offset!");
static_assert(offsetof(UBTService_FindObject_K32EmpTarget, NearGoalPodHorizontalDistance) == 0x000230, "Member 'UBTService_FindObject_K32EmpTarget::NearGoalPodHorizontalDistance' has a wrong offset!");
static_assert(offsetof(UBTService_FindObject_K32EmpTarget, NearGoalPodVerticalDistance) == 0x000234, "Member 'UBTService_FindObject_K32EmpTarget::NearGoalPodVerticalDistance' has a wrong offset!");
static_assert(offsetof(UBTService_FindObject_K32EmpTarget, NearGoalSurvivorHorizontalDistance) == 0x000238, "Member 'UBTService_FindObject_K32EmpTarget::NearGoalSurvivorHorizontalDistance' has a wrong offset!");
static_assert(offsetof(UBTService_FindObject_K32EmpTarget, NearGoalSurvivorVerticalDistance) == 0x00023C, "Member 'UBTService_FindObject_K32EmpTarget::NearGoalSurvivorVerticalDistance' has a wrong offset!");
static_assert(offsetof(UBTService_FindObject_K32EmpTarget, OtherSurvivorNearTargetDistance) == 0x000240, "Member 'UBTService_FindObject_K32EmpTarget::OtherSurvivorNearTargetDistance' has a wrong offset!");
static_assert(offsetof(UBTService_FindObject_K32EmpTarget, NavMeshTargetLocationExtents) == 0x000248, "Member 'UBTService_FindObject_K32EmpTarget::NavMeshTargetLocationExtents' has a wrong offset!");
static_assert(offsetof(UBTService_FindObject_K32EmpTarget, CheckDynamicSubtreeInterval) == 0x000260, "Member 'UBTService_FindObject_K32EmpTarget::CheckDynamicSubtreeInterval' has a wrong offset!");
static_assert(offsetof(UBTService_FindObject_K32EmpTarget, BBOriginalFocusedActor) == 0x000268, "Member 'UBTService_FindObject_K32EmpTarget::BBOriginalFocusedActor' has a wrong offset!");

// Class DBDBots.AISkill_InteractionSetTrap_Phantom
// 0x0000 (0x0290 - 0x0290)
class UAISkill_InteractionSetTrap_Phantom final : public UAISkill_InteractionSetTrap
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_InteractionSetTrap_Phantom">();
	}
	static class UAISkill_InteractionSetTrap_Phantom* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_InteractionSetTrap_Phantom>();
	}
};
static_assert(alignof(UAISkill_InteractionSetTrap_Phantom) == 0x000008, "Wrong alignment on UAISkill_InteractionSetTrap_Phantom");
static_assert(sizeof(UAISkill_InteractionSetTrap_Phantom) == 0x000290, "Wrong size on UAISkill_InteractionSetTrap_Phantom");

// Class DBDBots.AISkill_InteractionTarget_Aim
// 0x0000 (0x0348 - 0x0348)
class UAISkill_InteractionTarget_Aim final : public UAISkill_InteractionTarget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_InteractionTarget_Aim">();
	}
	static class UAISkill_InteractionTarget_Aim* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_InteractionTarget_Aim>();
	}
};
static_assert(alignof(UAISkill_InteractionTarget_Aim) == 0x000008, "Wrong alignment on UAISkill_InteractionTarget_Aim");
static_assert(sizeof(UAISkill_InteractionTarget_Aim) == 0x000348, "Wrong size on UAISkill_InteractionTarget_Aim");

// Class DBDBots.AISkill_InteractionTarget_AmbushMode
// 0x0000 (0x0348 - 0x0348)
class UAISkill_InteractionTarget_AmbushMode final : public UAISkill_InteractionTarget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_InteractionTarget_AmbushMode">();
	}
	static class UAISkill_InteractionTarget_AmbushMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_InteractionTarget_AmbushMode>();
	}
};
static_assert(alignof(UAISkill_InteractionTarget_AmbushMode) == 0x000008, "Wrong alignment on UAISkill_InteractionTarget_AmbushMode");
static_assert(sizeof(UAISkill_InteractionTarget_AmbushMode) == 0x000348, "Wrong size on UAISkill_InteractionTarget_AmbushMode");

// Class DBDBots.EnvQueryContext_FriendlyDangerObjects
// 0x0000 (0x0030 - 0x0030)
class UEnvQueryContext_FriendlyDangerObjects final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryContext_FriendlyDangerObjects">();
	}
	static class UEnvQueryContext_FriendlyDangerObjects* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryContext_FriendlyDangerObjects>();
	}
};
static_assert(alignof(UEnvQueryContext_FriendlyDangerObjects) == 0x000008, "Wrong alignment on UEnvQueryContext_FriendlyDangerObjects");
static_assert(sizeof(UEnvQueryContext_FriendlyDangerObjects) == 0x000030, "Wrong size on UEnvQueryContext_FriendlyDangerObjects");

// Class DBDBots.AISkill_InteractionTarget_DashAttack
// 0x0010 (0x0358 - 0x0348)
class UAISkill_InteractionTarget_DashAttack : public UAISkill_InteractionTarget_Dash
{
public:
	float                                         DashAttackUnderMaxRange;                           // 0x0348(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DashAttackUnderMaxHalfAngle;                       // 0x034C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttackType                                   ExpectedAttackType;                                // 0x0350(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_351[0x7];                                      // 0x0351(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_InteractionTarget_DashAttack">();
	}
	static class UAISkill_InteractionTarget_DashAttack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_InteractionTarget_DashAttack>();
	}
};
static_assert(alignof(UAISkill_InteractionTarget_DashAttack) == 0x000008, "Wrong alignment on UAISkill_InteractionTarget_DashAttack");
static_assert(sizeof(UAISkill_InteractionTarget_DashAttack) == 0x000358, "Wrong size on UAISkill_InteractionTarget_DashAttack");
static_assert(offsetof(UAISkill_InteractionTarget_DashAttack, DashAttackUnderMaxRange) == 0x000348, "Member 'UAISkill_InteractionTarget_DashAttack::DashAttackUnderMaxRange' has a wrong offset!");
static_assert(offsetof(UAISkill_InteractionTarget_DashAttack, DashAttackUnderMaxHalfAngle) == 0x00034C, "Member 'UAISkill_InteractionTarget_DashAttack::DashAttackUnderMaxHalfAngle' has a wrong offset!");
static_assert(offsetof(UAISkill_InteractionTarget_DashAttack, ExpectedAttackType) == 0x000350, "Member 'UAISkill_InteractionTarget_DashAttack::ExpectedAttackType' has a wrong offset!");

// Class DBDBots.AISkill_InteractionTarget_DashAttack_Cannibal
// 0x0000 (0x0358 - 0x0358)
class UAISkill_InteractionTarget_DashAttack_Cannibal final : public UAISkill_InteractionTarget_DashAttack
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_InteractionTarget_DashAttack_Cannibal">();
	}
	static class UAISkill_InteractionTarget_DashAttack_Cannibal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_InteractionTarget_DashAttack_Cannibal>();
	}
};
static_assert(alignof(UAISkill_InteractionTarget_DashAttack_Cannibal) == 0x000008, "Wrong alignment on UAISkill_InteractionTarget_DashAttack_Cannibal");
static_assert(sizeof(UAISkill_InteractionTarget_DashAttack_Cannibal) == 0x000358, "Wrong size on UAISkill_InteractionTarget_DashAttack_Cannibal");

// Class DBDBots.BTService_FindInteractor_SearchLocker
// 0x0380 (0x09D8 - 0x0658)
class UBTService_FindInteractor_SearchLocker final : public UBTService_FindInteractor
{
public:
	struct FBlackboardKeySelector                 BBLockerInteractable;                              // 0x0658(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    SlowEnterAudibleDistance;                          // 0x0688(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    RushedEnterAudibleDistance;                        // 0x06E8(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    MaxNoisePrecisionRange;                            // 0x0748(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    InjuredAudibleRange;                               // 0x07A8(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    ConvincedWeight;                                   // 0x0808(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    PotentialLockerWeight;                             // 0x0868(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    RandomToDistanceWeightRatio;                       // 0x08C8(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        LineOfSightOffsets;                                // 0x0928(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	uint8                                         Pad_938[0x50];                                     // 0x0938(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<TWeakObjectPtr<class ALocker>, struct FAISearchLockerInfo> _potentialLockers;                                 // 0x0988(0x0050)(NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_FindInteractor_SearchLocker">();
	}
	static class UBTService_FindInteractor_SearchLocker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_FindInteractor_SearchLocker>();
	}
};
static_assert(alignof(UBTService_FindInteractor_SearchLocker) == 0x000008, "Wrong alignment on UBTService_FindInteractor_SearchLocker");
static_assert(sizeof(UBTService_FindInteractor_SearchLocker) == 0x0009D8, "Wrong size on UBTService_FindInteractor_SearchLocker");
static_assert(offsetof(UBTService_FindInteractor_SearchLocker, BBLockerInteractable) == 0x000658, "Member 'UBTService_FindInteractor_SearchLocker::BBLockerInteractable' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_SearchLocker, SlowEnterAudibleDistance) == 0x000688, "Member 'UBTService_FindInteractor_SearchLocker::SlowEnterAudibleDistance' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_SearchLocker, RushedEnterAudibleDistance) == 0x0006E8, "Member 'UBTService_FindInteractor_SearchLocker::RushedEnterAudibleDistance' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_SearchLocker, MaxNoisePrecisionRange) == 0x000748, "Member 'UBTService_FindInteractor_SearchLocker::MaxNoisePrecisionRange' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_SearchLocker, InjuredAudibleRange) == 0x0007A8, "Member 'UBTService_FindInteractor_SearchLocker::InjuredAudibleRange' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_SearchLocker, ConvincedWeight) == 0x000808, "Member 'UBTService_FindInteractor_SearchLocker::ConvincedWeight' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_SearchLocker, PotentialLockerWeight) == 0x000868, "Member 'UBTService_FindInteractor_SearchLocker::PotentialLockerWeight' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_SearchLocker, RandomToDistanceWeightRatio) == 0x0008C8, "Member 'UBTService_FindInteractor_SearchLocker::RandomToDistanceWeightRatio' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_SearchLocker, LineOfSightOffsets) == 0x000928, "Member 'UBTService_FindInteractor_SearchLocker::LineOfSightOffsets' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_SearchLocker, _potentialLockers) == 0x000988, "Member 'UBTService_FindInteractor_SearchLocker::_potentialLockers' has a wrong offset!");

// Class DBDBots.AISkill_InteractionTarget_DashAttack_Chainsaw
// 0x0000 (0x0358 - 0x0358)
class UAISkill_InteractionTarget_DashAttack_Chainsaw final : public UAISkill_InteractionTarget_DashAttack
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_InteractionTarget_DashAttack_Chainsaw">();
	}
	static class UAISkill_InteractionTarget_DashAttack_Chainsaw* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_InteractionTarget_DashAttack_Chainsaw>();
	}
};
static_assert(alignof(UAISkill_InteractionTarget_DashAttack_Chainsaw) == 0x000008, "Wrong alignment on UAISkill_InteractionTarget_DashAttack_Chainsaw");
static_assert(sizeof(UAISkill_InteractionTarget_DashAttack_Chainsaw) == 0x000358, "Wrong size on UAISkill_InteractionTarget_DashAttack_Chainsaw");

// Class DBDBots.AISkill_InteractionTarget_DashAttack_Demogorgon
// 0x0000 (0x0358 - 0x0358)
class UAISkill_InteractionTarget_DashAttack_Demogorgon final : public UAISkill_InteractionTarget_DashAttack
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_InteractionTarget_DashAttack_Demogorgon">();
	}
	static class UAISkill_InteractionTarget_DashAttack_Demogorgon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_InteractionTarget_DashAttack_Demogorgon>();
	}
};
static_assert(alignof(UAISkill_InteractionTarget_DashAttack_Demogorgon) == 0x000008, "Wrong alignment on UAISkill_InteractionTarget_DashAttack_Demogorgon");
static_assert(sizeof(UAISkill_InteractionTarget_DashAttack_Demogorgon) == 0x000358, "Wrong size on UAISkill_InteractionTarget_DashAttack_Demogorgon");

// Class DBDBots.EnvQueryContext_InvestigationLocation
// 0x0000 (0x0030 - 0x0030)
class UEnvQueryContext_InvestigationLocation final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryContext_InvestigationLocation">();
	}
	static class UEnvQueryContext_InvestigationLocation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryContext_InvestigationLocation>();
	}
};
static_assert(alignof(UEnvQueryContext_InvestigationLocation) == 0x000008, "Wrong alignment on UEnvQueryContext_InvestigationLocation");
static_assert(sizeof(UEnvQueryContext_InvestigationLocation) == 0x000030, "Wrong size on UEnvQueryContext_InvestigationLocation");

// Class DBDBots.AISkill_InteractionTarget_DeadHard
// 0x0000 (0x0348 - 0x0348)
class UAISkill_InteractionTarget_DeadHard final : public UAISkill_InteractionTarget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_InteractionTarget_DeadHard">();
	}
	static class UAISkill_InteractionTarget_DeadHard* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_InteractionTarget_DeadHard>();
	}
};
static_assert(alignof(UAISkill_InteractionTarget_DeadHard) == 0x000008, "Wrong alignment on UAISkill_InteractionTarget_DeadHard");
static_assert(sizeof(UAISkill_InteractionTarget_DeadHard) == 0x000348, "Wrong size on UAISkill_InteractionTarget_DeadHard");

// Class DBDBots.AISkill_InteractionTarget_Frenzy
// 0x0000 (0x0348 - 0x0348)
class UAISkill_InteractionTarget_Frenzy final : public UAISkill_InteractionTarget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_InteractionTarget_Frenzy">();
	}
	static class UAISkill_InteractionTarget_Frenzy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_InteractionTarget_Frenzy>();
	}
};
static_assert(alignof(UAISkill_InteractionTarget_Frenzy) == 0x000008, "Wrong alignment on UAISkill_InteractionTarget_Frenzy");
static_assert(sizeof(UAISkill_InteractionTarget_Frenzy) == 0x000348, "Wrong size on UAISkill_InteractionTarget_Frenzy");

// Class DBDBots.BTService_FindFootsteps
// 0x0028 (0x0370 - 0x0348)
class UBTService_FindFootsteps final : public UBTService_FindGoalObject
{
public:
	float                                         InChaseMultiplier;                                 // 0x0348(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FootstepSeenMinWeight;                             // 0x034C(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AcceptableRadius;                                  // 0x0350(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_354[0x4];                                      // 0x0354(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                NavMeshProjectionBoxExtent;                        // 0x0358(0x0018)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_FindFootsteps">();
	}
	static class UBTService_FindFootsteps* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_FindFootsteps>();
	}
};
static_assert(alignof(UBTService_FindFootsteps) == 0x000008, "Wrong alignment on UBTService_FindFootsteps");
static_assert(sizeof(UBTService_FindFootsteps) == 0x000370, "Wrong size on UBTService_FindFootsteps");
static_assert(offsetof(UBTService_FindFootsteps, InChaseMultiplier) == 0x000348, "Member 'UBTService_FindFootsteps::InChaseMultiplier' has a wrong offset!");
static_assert(offsetof(UBTService_FindFootsteps, FootstepSeenMinWeight) == 0x00034C, "Member 'UBTService_FindFootsteps::FootstepSeenMinWeight' has a wrong offset!");
static_assert(offsetof(UBTService_FindFootsteps, AcceptableRadius) == 0x000350, "Member 'UBTService_FindFootsteps::AcceptableRadius' has a wrong offset!");
static_assert(offsetof(UBTService_FindFootsteps, NavMeshProjectionBoxExtent) == 0x000358, "Member 'UBTService_FindFootsteps::NavMeshProjectionBoxExtent' has a wrong offset!");

// Class DBDBots.AISkill_InteractionTarget_LungeAttack
// 0x0018 (0x0360 - 0x0348)
class UAISkill_InteractionTarget_LungeAttack final : public UAISkill_InteractionTarget
{
public:
	float                                         MaxRangeModifierWhenNavigationBlocked;             // 0x0348(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34C[0x4];                                      // 0x034C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameplayTag>                   ExceptionStateTags;                                // 0x0350(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_InteractionTarget_LungeAttack">();
	}
	static class UAISkill_InteractionTarget_LungeAttack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_InteractionTarget_LungeAttack>();
	}
};
static_assert(alignof(UAISkill_InteractionTarget_LungeAttack) == 0x000008, "Wrong alignment on UAISkill_InteractionTarget_LungeAttack");
static_assert(sizeof(UAISkill_InteractionTarget_LungeAttack) == 0x000360, "Wrong size on UAISkill_InteractionTarget_LungeAttack");
static_assert(offsetof(UAISkill_InteractionTarget_LungeAttack, MaxRangeModifierWhenNavigationBlocked) == 0x000348, "Member 'UAISkill_InteractionTarget_LungeAttack::MaxRangeModifierWhenNavigationBlocked' has a wrong offset!");
static_assert(offsetof(UAISkill_InteractionTarget_LungeAttack, ExceptionStateTags) == 0x000350, "Member 'UAISkill_InteractionTarget_LungeAttack::ExceptionStateTags' has a wrong offset!");

// Class DBDBots.AISkill_InteractionTarget_ReloadDeathSlinger
// 0x0000 (0x0348 - 0x0348)
class UAISkill_InteractionTarget_ReloadDeathSlinger final : public UAISkill_InteractionTarget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_InteractionTarget_ReloadDeathSlinger">();
	}
	static class UAISkill_InteractionTarget_ReloadDeathSlinger* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_InteractionTarget_ReloadDeathSlinger>();
	}
};
static_assert(alignof(UAISkill_InteractionTarget_ReloadDeathSlinger) == 0x000008, "Wrong alignment on UAISkill_InteractionTarget_ReloadDeathSlinger");
static_assert(sizeof(UAISkill_InteractionTarget_ReloadDeathSlinger) == 0x000348, "Wrong size on UAISkill_InteractionTarget_ReloadDeathSlinger");

// Class DBDBots.BTService_Flee
// 0x0228 (0x02A0 - 0x0078)
class UBTService_Flee final : public UBTService
{
public:
	uint8                                         Pad_78[0x8];                                       // 0x0078(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlackboardKeySelector                 BBFleePath;                                        // 0x0080(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBShouldFallPallet;                                // 0x00B0(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBEvadePointCrossingDest;                          // 0x00E0(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBEvadePointInteractable;                          // 0x0110(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBIgnoreHostileStimulusInCooldown;                 // 0x0140(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	TSubclassOf<class UPathStrategySelector>      PathStrategySelectorClass;                         // 0x0170(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UClass*>                         IgnoreOnEndObjectInFocusCooldownTypes;             // 0x0178(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	float                                         OnEndObjectInFocusCooldown;                        // 0x0188(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18C[0x4];                                      // 0x018C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAITunableParameter                    ShouldFallPalletUnderHostileHorizontalRange;       // 0x0190(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	float                                         ShouldFallPalletUnderHostileVerticalRange;         // 0x01F0(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F4[0x4];                                      // 0x01F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAITunableParameter                    ShouldFallFragilePalletHorizontalRange;            // 0x01F8(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	float                                         ClearFleePathBBKeyDelay;                           // 0x0258(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25C[0x1C];                                     // 0x025C(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	class UNavMovePath*                           _activePath;                                       // 0x0278(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UObject*>                        _lostFocusedObjects;                               // 0x0280(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class UPathStrategySelector*                  _strategySelector;                                 // 0x0290(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_298[0x8];                                      // 0x0298(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_Flee">();
	}
	static class UBTService_Flee* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_Flee>();
	}
};
static_assert(alignof(UBTService_Flee) == 0x000008, "Wrong alignment on UBTService_Flee");
static_assert(sizeof(UBTService_Flee) == 0x0002A0, "Wrong size on UBTService_Flee");
static_assert(offsetof(UBTService_Flee, BBFleePath) == 0x000080, "Member 'UBTService_Flee::BBFleePath' has a wrong offset!");
static_assert(offsetof(UBTService_Flee, BBShouldFallPallet) == 0x0000B0, "Member 'UBTService_Flee::BBShouldFallPallet' has a wrong offset!");
static_assert(offsetof(UBTService_Flee, BBEvadePointCrossingDest) == 0x0000E0, "Member 'UBTService_Flee::BBEvadePointCrossingDest' has a wrong offset!");
static_assert(offsetof(UBTService_Flee, BBEvadePointInteractable) == 0x000110, "Member 'UBTService_Flee::BBEvadePointInteractable' has a wrong offset!");
static_assert(offsetof(UBTService_Flee, BBIgnoreHostileStimulusInCooldown) == 0x000140, "Member 'UBTService_Flee::BBIgnoreHostileStimulusInCooldown' has a wrong offset!");
static_assert(offsetof(UBTService_Flee, PathStrategySelectorClass) == 0x000170, "Member 'UBTService_Flee::PathStrategySelectorClass' has a wrong offset!");
static_assert(offsetof(UBTService_Flee, IgnoreOnEndObjectInFocusCooldownTypes) == 0x000178, "Member 'UBTService_Flee::IgnoreOnEndObjectInFocusCooldownTypes' has a wrong offset!");
static_assert(offsetof(UBTService_Flee, OnEndObjectInFocusCooldown) == 0x000188, "Member 'UBTService_Flee::OnEndObjectInFocusCooldown' has a wrong offset!");
static_assert(offsetof(UBTService_Flee, ShouldFallPalletUnderHostileHorizontalRange) == 0x000190, "Member 'UBTService_Flee::ShouldFallPalletUnderHostileHorizontalRange' has a wrong offset!");
static_assert(offsetof(UBTService_Flee, ShouldFallPalletUnderHostileVerticalRange) == 0x0001F0, "Member 'UBTService_Flee::ShouldFallPalletUnderHostileVerticalRange' has a wrong offset!");
static_assert(offsetof(UBTService_Flee, ShouldFallFragilePalletHorizontalRange) == 0x0001F8, "Member 'UBTService_Flee::ShouldFallFragilePalletHorizontalRange' has a wrong offset!");
static_assert(offsetof(UBTService_Flee, ClearFleePathBBKeyDelay) == 0x000258, "Member 'UBTService_Flee::ClearFleePathBBKeyDelay' has a wrong offset!");
static_assert(offsetof(UBTService_Flee, _activePath) == 0x000278, "Member 'UBTService_Flee::_activePath' has a wrong offset!");
static_assert(offsetof(UBTService_Flee, _lostFocusedObjects) == 0x000280, "Member 'UBTService_Flee::_lostFocusedObjects' has a wrong offset!");
static_assert(offsetof(UBTService_Flee, _strategySelector) == 0x000290, "Member 'UBTService_Flee::_strategySelector' has a wrong offset!");

// Class DBDBots.AISkill_InteractionTarget_StalkGhost
// 0x0010 (0x0358 - 0x0348)
class UAISkill_InteractionTarget_StalkGhost final : public UAISkill_InteractionTarget_Stalk
{
public:
	float                                         CautiousModeUnderTargetRange;                      // 0x0348(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CautiousModeSpeedFactor;                           // 0x034C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BackFromCautiousDelay;                             // 0x0350(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_354[0x4];                                      // 0x0354(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_InteractionTarget_StalkGhost">();
	}
	static class UAISkill_InteractionTarget_StalkGhost* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_InteractionTarget_StalkGhost>();
	}
};
static_assert(alignof(UAISkill_InteractionTarget_StalkGhost) == 0x000008, "Wrong alignment on UAISkill_InteractionTarget_StalkGhost");
static_assert(sizeof(UAISkill_InteractionTarget_StalkGhost) == 0x000358, "Wrong size on UAISkill_InteractionTarget_StalkGhost");
static_assert(offsetof(UAISkill_InteractionTarget_StalkGhost, CautiousModeUnderTargetRange) == 0x000348, "Member 'UAISkill_InteractionTarget_StalkGhost::CautiousModeUnderTargetRange' has a wrong offset!");
static_assert(offsetof(UAISkill_InteractionTarget_StalkGhost, CautiousModeSpeedFactor) == 0x00034C, "Member 'UAISkill_InteractionTarget_StalkGhost::CautiousModeSpeedFactor' has a wrong offset!");
static_assert(offsetof(UAISkill_InteractionTarget_StalkGhost, BackFromCautiousDelay) == 0x000350, "Member 'UAISkill_InteractionTarget_StalkGhost::BackFromCautiousDelay' has a wrong offset!");

// Class DBDBots.EnvQueryTest_ApproachLureableDangerObject
// 0x0018 (0x0250 - 0x0238)
class UEnvQueryTest_ApproachLureableDangerObject final : public UEnvQueryTest
{
public:
	TSubclassOf<class UEnvQueryContext>           QuerierContext;                                    // 0x0238(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UEnvQueryContext>           TargetContext;                                     // 0x0240(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TowardDangerObjectMaxAngle;                        // 0x0248(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24C[0x4];                                      // 0x024C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryTest_ApproachLureableDangerObject">();
	}
	static class UEnvQueryTest_ApproachLureableDangerObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryTest_ApproachLureableDangerObject>();
	}
};
static_assert(alignof(UEnvQueryTest_ApproachLureableDangerObject) == 0x000008, "Wrong alignment on UEnvQueryTest_ApproachLureableDangerObject");
static_assert(sizeof(UEnvQueryTest_ApproachLureableDangerObject) == 0x000250, "Wrong size on UEnvQueryTest_ApproachLureableDangerObject");
static_assert(offsetof(UEnvQueryTest_ApproachLureableDangerObject, QuerierContext) == 0x000238, "Member 'UEnvQueryTest_ApproachLureableDangerObject::QuerierContext' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_ApproachLureableDangerObject, TargetContext) == 0x000240, "Member 'UEnvQueryTest_ApproachLureableDangerObject::TargetContext' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_ApproachLureableDangerObject, TowardDangerObjectMaxAngle) == 0x000248, "Member 'UEnvQueryTest_ApproachLureableDangerObject::TowardDangerObjectMaxAngle' has a wrong offset!");

// Class DBDBots.AISkill_InteractionTarget_StealthGhost
// 0x0008 (0x0350 - 0x0348)
class UAISkill_InteractionTarget_StealthGhost final : public UAISkill_InteractionTarget
{
public:
	float                                         CrouchSwapDelay;                                   // 0x0348(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34C[0x4];                                      // 0x034C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_InteractionTarget_StealthGhost">();
	}
	static class UAISkill_InteractionTarget_StealthGhost* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_InteractionTarget_StealthGhost>();
	}
};
static_assert(alignof(UAISkill_InteractionTarget_StealthGhost) == 0x000008, "Wrong alignment on UAISkill_InteractionTarget_StealthGhost");
static_assert(sizeof(UAISkill_InteractionTarget_StealthGhost) == 0x000350, "Wrong size on UAISkill_InteractionTarget_StealthGhost");
static_assert(offsetof(UAISkill_InteractionTarget_StealthGhost, CrouchSwapDelay) == 0x000348, "Member 'UAISkill_InteractionTarget_StealthGhost::CrouchSwapDelay' has a wrong offset!");

// Class DBDBots.AISkill_InteractionTarget_ThrowHatchet
// 0x0000 (0x0430 - 0x0430)
class UAISkill_InteractionTarget_ThrowHatchet final : public UAISkill_InteractionTarget_Throw
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_InteractionTarget_ThrowHatchet">();
	}
	static class UAISkill_InteractionTarget_ThrowHatchet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_InteractionTarget_ThrowHatchet>();
	}
};
static_assert(alignof(UAISkill_InteractionTarget_ThrowHatchet) == 0x000008, "Wrong alignment on UAISkill_InteractionTarget_ThrowHatchet");
static_assert(sizeof(UAISkill_InteractionTarget_ThrowHatchet) == 0x000430, "Wrong size on UAISkill_InteractionTarget_ThrowHatchet");

// Class DBDBots.BTService_FindInteractor_Locker
// 0x0028 (0x0680 - 0x0658)
class UBTService_FindInteractor_Locker final : public UBTService_FindInteractor
{
public:
	EFindInteractableLockerStatusFilter           StatusFilter;                                      // 0x0658(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          LockerNeedsToBeOpenable;                           // 0x0659(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_65A[0x6];                                      // 0x065A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FInLockerPerk>                  PerksToRunInLocker;                                // 0x0660(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	uint8                                         Pad_670[0x10];                                     // 0x0670(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_FindInteractor_Locker">();
	}
	static class UBTService_FindInteractor_Locker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_FindInteractor_Locker>();
	}
};
static_assert(alignof(UBTService_FindInteractor_Locker) == 0x000008, "Wrong alignment on UBTService_FindInteractor_Locker");
static_assert(sizeof(UBTService_FindInteractor_Locker) == 0x000680, "Wrong size on UBTService_FindInteractor_Locker");
static_assert(offsetof(UBTService_FindInteractor_Locker, StatusFilter) == 0x000658, "Member 'UBTService_FindInteractor_Locker::StatusFilter' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_Locker, LockerNeedsToBeOpenable) == 0x000659, "Member 'UBTService_FindInteractor_Locker::LockerNeedsToBeOpenable' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_Locker, PerksToRunInLocker) == 0x000660, "Member 'UBTService_FindInteractor_Locker::PerksToRunInLocker' has a wrong offset!");

// Class DBDBots.AISkill_InteractionTarget_ThrowPlague
// 0x0010 (0x0440 - 0x0430)
class UAISkill_InteractionTarget_ThrowPlague final : public UAISkill_InteractionTarget_Throw
{
public:
	struct FGameplayTag                           ProjectileDamageSickTargetTag;                     // 0x0430(0x000C)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_43C[0x4];                                      // 0x043C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_InteractionTarget_ThrowPlague">();
	}
	static class UAISkill_InteractionTarget_ThrowPlague* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_InteractionTarget_ThrowPlague>();
	}
};
static_assert(alignof(UAISkill_InteractionTarget_ThrowPlague) == 0x000008, "Wrong alignment on UAISkill_InteractionTarget_ThrowPlague");
static_assert(sizeof(UAISkill_InteractionTarget_ThrowPlague) == 0x000440, "Wrong size on UAISkill_InteractionTarget_ThrowPlague");
static_assert(offsetof(UAISkill_InteractionTarget_ThrowPlague, ProjectileDamageSickTargetTag) == 0x000430, "Member 'UAISkill_InteractionTarget_ThrowPlague::ProjectileDamageSickTargetTag' has a wrong offset!");

// Class DBDBots.AISkill_InteractionTarget_TormentAttack
// 0x00D8 (0x0420 - 0x0348)
class UAISkill_InteractionTarget_TormentAttack final : public UAISkill_InteractionTarget
{
public:
	int32                                         AdvancedAtNbDetectedTargets;                       // 0x0348(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34C[0x4];                                      // 0x034C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAIRoll                                AdvancedStartRoll;                                 // 0x0350(0x00C8)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         Pad_418[0x8];                                      // 0x0418(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_InteractionTarget_TormentAttack">();
	}
	static class UAISkill_InteractionTarget_TormentAttack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_InteractionTarget_TormentAttack>();
	}
};
static_assert(alignof(UAISkill_InteractionTarget_TormentAttack) == 0x000008, "Wrong alignment on UAISkill_InteractionTarget_TormentAttack");
static_assert(sizeof(UAISkill_InteractionTarget_TormentAttack) == 0x000420, "Wrong size on UAISkill_InteractionTarget_TormentAttack");
static_assert(offsetof(UAISkill_InteractionTarget_TormentAttack, AdvancedAtNbDetectedTargets) == 0x000348, "Member 'UAISkill_InteractionTarget_TormentAttack::AdvancedAtNbDetectedTargets' has a wrong offset!");
static_assert(offsetof(UAISkill_InteractionTarget_TormentAttack, AdvancedStartRoll) == 0x000350, "Member 'UAISkill_InteractionTarget_TormentAttack::AdvancedStartRoll' has a wrong offset!");

// Class DBDBots.BTService_StateMonitor
// 0x0060 (0x00D8 - 0x0078)
class UBTService_StateMonitor : public UBTService
{
public:
	struct FBlackboardKeySelector                 BBIsIntroCompleted;                                // 0x0078(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBDifficultyLevel;                                 // 0x00A8(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_StateMonitor">();
	}
	static class UBTService_StateMonitor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_StateMonitor>();
	}
};
static_assert(alignof(UBTService_StateMonitor) == 0x000008, "Wrong alignment on UBTService_StateMonitor");
static_assert(sizeof(UBTService_StateMonitor) == 0x0000D8, "Wrong size on UBTService_StateMonitor");
static_assert(offsetof(UBTService_StateMonitor, BBIsIntroCompleted) == 0x000078, "Member 'UBTService_StateMonitor::BBIsIntroCompleted' has a wrong offset!");
static_assert(offsetof(UBTService_StateMonitor, BBDifficultyLevel) == 0x0000A8, "Member 'UBTService_StateMonitor::BBDifficultyLevel' has a wrong offset!");

// Class DBDBots.AISkill_InteractionTarget_TormentMode
// 0x0010 (0x0358 - 0x0348)
class UAISkill_InteractionTarget_TormentMode final : public UAISkill_InteractionTarget
{
public:
	float                                         ChasedTargetToEvadePointMaxDistance;               // 0x0348(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartTormentInPatrolAboveChargeRatio;              // 0x034C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartTormentInChaseAboveChargeRatio;               // 0x0350(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_354[0x4];                                      // 0x0354(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_InteractionTarget_TormentMode">();
	}
	static class UAISkill_InteractionTarget_TormentMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_InteractionTarget_TormentMode>();
	}
};
static_assert(alignof(UAISkill_InteractionTarget_TormentMode) == 0x000008, "Wrong alignment on UAISkill_InteractionTarget_TormentMode");
static_assert(sizeof(UAISkill_InteractionTarget_TormentMode) == 0x000358, "Wrong size on UAISkill_InteractionTarget_TormentMode");
static_assert(offsetof(UAISkill_InteractionTarget_TormentMode, ChasedTargetToEvadePointMaxDistance) == 0x000348, "Member 'UAISkill_InteractionTarget_TormentMode::ChasedTargetToEvadePointMaxDistance' has a wrong offset!");
static_assert(offsetof(UAISkill_InteractionTarget_TormentMode, StartTormentInPatrolAboveChargeRatio) == 0x00034C, "Member 'UAISkill_InteractionTarget_TormentMode::StartTormentInPatrolAboveChargeRatio' has a wrong offset!");
static_assert(offsetof(UAISkill_InteractionTarget_TormentMode, StartTormentInChaseAboveChargeRatio) == 0x000350, "Member 'UAISkill_InteractionTarget_TormentMode::StartTormentInChaseAboveChargeRatio' has a wrong offset!");

// Class DBDBots.AISkill_InteractionTeleport
// 0x0008 (0x0288 - 0x0280)
class UAISkill_InteractionTeleport : public UAISkill_Interaction
{
public:
	float                                         BlockTeleportWhenPathGoalUnderRange;               // 0x0280(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_284[0x4];                                      // 0x0284(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_InteractionTeleport">();
	}
	static class UAISkill_InteractionTeleport* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_InteractionTeleport>();
	}
};
static_assert(alignof(UAISkill_InteractionTeleport) == 0x000008, "Wrong alignment on UAISkill_InteractionTeleport");
static_assert(sizeof(UAISkill_InteractionTeleport) == 0x000288, "Wrong size on UAISkill_InteractionTeleport");
static_assert(offsetof(UAISkill_InteractionTeleport, BlockTeleportWhenPathGoalUnderRange) == 0x000280, "Member 'UAISkill_InteractionTeleport::BlockTeleportWhenPathGoalUnderRange' has a wrong offset!");

// Class DBDBots.BTService_PushObjectFocus
// 0x0030 (0x00A8 - 0x0078)
class UBTService_PushObjectFocus final : public UBTService
{
public:
	struct FBlackboardKeySelector                 BBFocusObj;                                        // 0x0078(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_PushObjectFocus">();
	}
	static class UBTService_PushObjectFocus* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_PushObjectFocus>();
	}
};
static_assert(alignof(UBTService_PushObjectFocus) == 0x000008, "Wrong alignment on UBTService_PushObjectFocus");
static_assert(sizeof(UBTService_PushObjectFocus) == 0x0000A8, "Wrong size on UBTService_PushObjectFocus");
static_assert(offsetof(UBTService_PushObjectFocus, BBFocusObj) == 0x000078, "Member 'UBTService_PushObjectFocus::BBFocusObj' has a wrong offset!");

// Class DBDBots.AISkill_InteractionTeleportEthereal
// 0x0080 (0x0308 - 0x0288)
class UAISkill_InteractionTeleportEthereal : public UAISkill_InteractionTeleport
{
public:
	float                                         TeleportPlanInterval;                              // 0x0288(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxTeleportAlignHalfAngle;                         // 0x028C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AbortNotWorkingTeleportDelay;                      // 0x0290(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AbortAddRunCooldownPenaltyTime;                    // 0x0294(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_298[0x30];                                     // 0x0298(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 _onStimulusInstigator;                             // 0x02C8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D0[0x38];                                     // 0x02D0(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_InteractionTeleportEthereal">();
	}
	static class UAISkill_InteractionTeleportEthereal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_InteractionTeleportEthereal>();
	}
};
static_assert(alignof(UAISkill_InteractionTeleportEthereal) == 0x000008, "Wrong alignment on UAISkill_InteractionTeleportEthereal");
static_assert(sizeof(UAISkill_InteractionTeleportEthereal) == 0x000308, "Wrong size on UAISkill_InteractionTeleportEthereal");
static_assert(offsetof(UAISkill_InteractionTeleportEthereal, TeleportPlanInterval) == 0x000288, "Member 'UAISkill_InteractionTeleportEthereal::TeleportPlanInterval' has a wrong offset!");
static_assert(offsetof(UAISkill_InteractionTeleportEthereal, MaxTeleportAlignHalfAngle) == 0x00028C, "Member 'UAISkill_InteractionTeleportEthereal::MaxTeleportAlignHalfAngle' has a wrong offset!");
static_assert(offsetof(UAISkill_InteractionTeleportEthereal, AbortNotWorkingTeleportDelay) == 0x000290, "Member 'UAISkill_InteractionTeleportEthereal::AbortNotWorkingTeleportDelay' has a wrong offset!");
static_assert(offsetof(UAISkill_InteractionTeleportEthereal, AbortAddRunCooldownPenaltyTime) == 0x000294, "Member 'UAISkill_InteractionTeleportEthereal::AbortAddRunCooldownPenaltyTime' has a wrong offset!");
static_assert(offsetof(UAISkill_InteractionTeleportEthereal, _onStimulusInstigator) == 0x0002C8, "Member 'UAISkill_InteractionTeleportEthereal::_onStimulusInstigator' has a wrong offset!");

// Class DBDBots.AISkill_InteractionTeleportEthereal_Blink
// 0x0010 (0x0318 - 0x0308)
class UAISkill_InteractionTeleportEthereal_Blink final : public UAISkill_InteractionTeleportEthereal
{
public:
	float                                         StartBlinkAtWarpLocationRange;                     // 0x0308(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ValidateBlinkWarpRange;                            // 0x030C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlinkAboveSavedPathLength;                         // 0x0310(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlinkIfTargetWillBeInRange;                        // 0x0314(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_InteractionTeleportEthereal_Blink">();
	}
	static class UAISkill_InteractionTeleportEthereal_Blink* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_InteractionTeleportEthereal_Blink>();
	}
};
static_assert(alignof(UAISkill_InteractionTeleportEthereal_Blink) == 0x000008, "Wrong alignment on UAISkill_InteractionTeleportEthereal_Blink");
static_assert(sizeof(UAISkill_InteractionTeleportEthereal_Blink) == 0x000318, "Wrong size on UAISkill_InteractionTeleportEthereal_Blink");
static_assert(offsetof(UAISkill_InteractionTeleportEthereal_Blink, StartBlinkAtWarpLocationRange) == 0x000308, "Member 'UAISkill_InteractionTeleportEthereal_Blink::StartBlinkAtWarpLocationRange' has a wrong offset!");
static_assert(offsetof(UAISkill_InteractionTeleportEthereal_Blink, ValidateBlinkWarpRange) == 0x00030C, "Member 'UAISkill_InteractionTeleportEthereal_Blink::ValidateBlinkWarpRange' has a wrong offset!");
static_assert(offsetof(UAISkill_InteractionTeleportEthereal_Blink, BlinkAboveSavedPathLength) == 0x000310, "Member 'UAISkill_InteractionTeleportEthereal_Blink::BlinkAboveSavedPathLength' has a wrong offset!");
static_assert(offsetof(UAISkill_InteractionTeleportEthereal_Blink, BlinkIfTargetWillBeInRange) == 0x000314, "Member 'UAISkill_InteractionTeleportEthereal_Blink::BlinkIfTargetWillBeInRange' has a wrong offset!");

// Class DBDBots.BTService_StimuliMonitor
// 0x01D0 (0x0248 - 0x0078)
class UBTService_StimuliMonitor : public UBTService
{
public:
	struct FBlackboardKeySelector                 BBStimulusOriginLocation;                          // 0x0078(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBStimulusNavLocation;                             // 0x00A8(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBStimulusActor;                                   // 0x00D8(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBStimulusInSight;                                 // 0x0108(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBStimulusWasInSight;                              // 0x0138(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	float                                         StimulusWasInSightDuration;                        // 0x0168(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16C[0x4];                                      // 0x016C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAITunableParameter                    StimuliRefreshInterval;                            // 0x0170(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	float                                         ExtrapolateLoseSightDuration;                      // 0x01D0(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D4[0x4];                                      // 0x01D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                NavMeshFindLocationExtents;                        // 0x01D8(0x0018)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SeenFriendlyStimuliExpiryInSeconds;                // 0x01F0(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ForcedStimulusInSightDistance;                     // 0x01F4(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class AActor*, float>                    _seenFriendlyStimuli;                              // 0x01F8(0x0050)(Transient, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_StimuliMonitor">();
	}
	static class UBTService_StimuliMonitor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_StimuliMonitor>();
	}
};
static_assert(alignof(UBTService_StimuliMonitor) == 0x000008, "Wrong alignment on UBTService_StimuliMonitor");
static_assert(sizeof(UBTService_StimuliMonitor) == 0x000248, "Wrong size on UBTService_StimuliMonitor");
static_assert(offsetof(UBTService_StimuliMonitor, BBStimulusOriginLocation) == 0x000078, "Member 'UBTService_StimuliMonitor::BBStimulusOriginLocation' has a wrong offset!");
static_assert(offsetof(UBTService_StimuliMonitor, BBStimulusNavLocation) == 0x0000A8, "Member 'UBTService_StimuliMonitor::BBStimulusNavLocation' has a wrong offset!");
static_assert(offsetof(UBTService_StimuliMonitor, BBStimulusActor) == 0x0000D8, "Member 'UBTService_StimuliMonitor::BBStimulusActor' has a wrong offset!");
static_assert(offsetof(UBTService_StimuliMonitor, BBStimulusInSight) == 0x000108, "Member 'UBTService_StimuliMonitor::BBStimulusInSight' has a wrong offset!");
static_assert(offsetof(UBTService_StimuliMonitor, BBStimulusWasInSight) == 0x000138, "Member 'UBTService_StimuliMonitor::BBStimulusWasInSight' has a wrong offset!");
static_assert(offsetof(UBTService_StimuliMonitor, StimulusWasInSightDuration) == 0x000168, "Member 'UBTService_StimuliMonitor::StimulusWasInSightDuration' has a wrong offset!");
static_assert(offsetof(UBTService_StimuliMonitor, StimuliRefreshInterval) == 0x000170, "Member 'UBTService_StimuliMonitor::StimuliRefreshInterval' has a wrong offset!");
static_assert(offsetof(UBTService_StimuliMonitor, ExtrapolateLoseSightDuration) == 0x0001D0, "Member 'UBTService_StimuliMonitor::ExtrapolateLoseSightDuration' has a wrong offset!");
static_assert(offsetof(UBTService_StimuliMonitor, NavMeshFindLocationExtents) == 0x0001D8, "Member 'UBTService_StimuliMonitor::NavMeshFindLocationExtents' has a wrong offset!");
static_assert(offsetof(UBTService_StimuliMonitor, SeenFriendlyStimuliExpiryInSeconds) == 0x0001F0, "Member 'UBTService_StimuliMonitor::SeenFriendlyStimuliExpiryInSeconds' has a wrong offset!");
static_assert(offsetof(UBTService_StimuliMonitor, ForcedStimulusInSightDistance) == 0x0001F4, "Member 'UBTService_StimuliMonitor::ForcedStimulusInSightDistance' has a wrong offset!");
static_assert(offsetof(UBTService_StimuliMonitor, _seenFriendlyStimuli) == 0x0001F8, "Member 'UBTService_StimuliMonitor::_seenFriendlyStimuli' has a wrong offset!");

// Class DBDBots.BTService_StimuliMonitor_Camper
// 0x0068 (0x02B0 - 0x0248)
class UBTService_StimuliMonitor_Camper final : public UBTService_StimuliMonitor
{
public:
	struct FBlackboardKeySelector                 BBTerrorPressure;                                  // 0x0248(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBIsFleeing;                                       // 0x0278(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	float                                         LastValidTerrorRadiusStimulusMemoryLifeTime;       // 0x02A8(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IgnoreNonKillerStimulusWhileInSprintDistanceSquared; // 0x02AC(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_StimuliMonitor_Camper">();
	}
	static class UBTService_StimuliMonitor_Camper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_StimuliMonitor_Camper>();
	}
};
static_assert(alignof(UBTService_StimuliMonitor_Camper) == 0x000008, "Wrong alignment on UBTService_StimuliMonitor_Camper");
static_assert(sizeof(UBTService_StimuliMonitor_Camper) == 0x0002B0, "Wrong size on UBTService_StimuliMonitor_Camper");
static_assert(offsetof(UBTService_StimuliMonitor_Camper, BBTerrorPressure) == 0x000248, "Member 'UBTService_StimuliMonitor_Camper::BBTerrorPressure' has a wrong offset!");
static_assert(offsetof(UBTService_StimuliMonitor_Camper, BBIsFleeing) == 0x000278, "Member 'UBTService_StimuliMonitor_Camper::BBIsFleeing' has a wrong offset!");
static_assert(offsetof(UBTService_StimuliMonitor_Camper, LastValidTerrorRadiusStimulusMemoryLifeTime) == 0x0002A8, "Member 'UBTService_StimuliMonitor_Camper::LastValidTerrorRadiusStimulusMemoryLifeTime' has a wrong offset!");
static_assert(offsetof(UBTService_StimuliMonitor_Camper, IgnoreNonKillerStimulusWhileInSprintDistanceSquared) == 0x0002AC, "Member 'UBTService_StimuliMonitor_Camper::IgnoreNonKillerStimulusWhileInSprintDistanceSquared' has a wrong offset!");

// Class DBDBots.AISkill_InteractionTeleportEthereal_Demogorgon
// 0x0018 (0x0320 - 0x0308)
class UAISkill_InteractionTeleportEthereal_Demogorgon final : public UAISkill_InteractionTeleportEthereal
{
public:
	float                                         MaxRangeFromFirstPortal;                           // 0x0308(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30C[0x4];                                      // 0x030C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ADemogorgonPortal*                      _firstPortal;                                      // 0x0310(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ADemogorgonPortal*                      _secondPortal;                                     // 0x0318(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_InteractionTeleportEthereal_Demogorgon">();
	}
	static class UAISkill_InteractionTeleportEthereal_Demogorgon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_InteractionTeleportEthereal_Demogorgon>();
	}
};
static_assert(alignof(UAISkill_InteractionTeleportEthereal_Demogorgon) == 0x000008, "Wrong alignment on UAISkill_InteractionTeleportEthereal_Demogorgon");
static_assert(sizeof(UAISkill_InteractionTeleportEthereal_Demogorgon) == 0x000320, "Wrong size on UAISkill_InteractionTeleportEthereal_Demogorgon");
static_assert(offsetof(UAISkill_InteractionTeleportEthereal_Demogorgon, MaxRangeFromFirstPortal) == 0x000308, "Member 'UAISkill_InteractionTeleportEthereal_Demogorgon::MaxRangeFromFirstPortal' has a wrong offset!");
static_assert(offsetof(UAISkill_InteractionTeleportEthereal_Demogorgon, _firstPortal) == 0x000310, "Member 'UAISkill_InteractionTeleportEthereal_Demogorgon::_firstPortal' has a wrong offset!");
static_assert(offsetof(UAISkill_InteractionTeleportEthereal_Demogorgon, _secondPortal) == 0x000318, "Member 'UAISkill_InteractionTeleportEthereal_Demogorgon::_secondPortal' has a wrong offset!");

// Class DBDBots.AISkill_InteractionTeleportEthereal_Nightmare
// 0x0010 (0x0318 - 0x0308)
class UAISkill_InteractionTeleportEthereal_Nightmare final : public UAISkill_InteractionTeleportEthereal
{
public:
	float                                         TeleportIfPathLengthSavedAboveRange;               // 0x0308(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30C[0x4];                                      // 0x030C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AGenerator*                             _toGenerator;                                      // 0x0310(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_InteractionTeleportEthereal_Nightmare">();
	}
	static class UAISkill_InteractionTeleportEthereal_Nightmare* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_InteractionTeleportEthereal_Nightmare>();
	}
};
static_assert(alignof(UAISkill_InteractionTeleportEthereal_Nightmare) == 0x000008, "Wrong alignment on UAISkill_InteractionTeleportEthereal_Nightmare");
static_assert(sizeof(UAISkill_InteractionTeleportEthereal_Nightmare) == 0x000318, "Wrong size on UAISkill_InteractionTeleportEthereal_Nightmare");
static_assert(offsetof(UAISkill_InteractionTeleportEthereal_Nightmare, TeleportIfPathLengthSavedAboveRange) == 0x000308, "Member 'UAISkill_InteractionTeleportEthereal_Nightmare::TeleportIfPathLengthSavedAboveRange' has a wrong offset!");
static_assert(offsetof(UAISkill_InteractionTeleportEthereal_Nightmare, _toGenerator) == 0x000310, "Member 'UAISkill_InteractionTeleportEthereal_Nightmare::_toGenerator' has a wrong offset!");

// Class DBDBots.BTDecorator_CanRunSkill
// 0x0010 (0x0080 - 0x0070)
class UBTDecorator_CanRunSkill final : public UBTDecorator_TickableBase
{
public:
	struct FGameplayTag                           Context;                                           // 0x0070(0x000C)(Edit, DisableEditOnTemplate, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_CanRunSkill">();
	}
	static class UBTDecorator_CanRunSkill* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_CanRunSkill>();
	}
};
static_assert(alignof(UBTDecorator_CanRunSkill) == 0x000008, "Wrong alignment on UBTDecorator_CanRunSkill");
static_assert(sizeof(UBTDecorator_CanRunSkill) == 0x000080, "Wrong size on UBTDecorator_CanRunSkill");
static_assert(offsetof(UBTDecorator_CanRunSkill, Context) == 0x000070, "Member 'UBTDecorator_CanRunSkill::Context' has a wrong offset!");

// Class DBDBots.AISkill_InteractionUseItem_FirecrackerLike
// 0x0068 (0x02F8 - 0x0290)
class UAISkill_InteractionUseItem_FirecrackerLike : public UAISkill_InteractionUseItem
{
public:
	struct FAITunableParameter                    StartMaxRange;                                     // 0x0290(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         TargetFaceMeMaxHalfAngle;                          // 0x02F0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F4[0x4];                                      // 0x02F4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_InteractionUseItem_FirecrackerLike">();
	}
	static class UAISkill_InteractionUseItem_FirecrackerLike* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_InteractionUseItem_FirecrackerLike>();
	}
};
static_assert(alignof(UAISkill_InteractionUseItem_FirecrackerLike) == 0x000008, "Wrong alignment on UAISkill_InteractionUseItem_FirecrackerLike");
static_assert(sizeof(UAISkill_InteractionUseItem_FirecrackerLike) == 0x0002F8, "Wrong size on UAISkill_InteractionUseItem_FirecrackerLike");
static_assert(offsetof(UAISkill_InteractionUseItem_FirecrackerLike, StartMaxRange) == 0x000290, "Member 'UAISkill_InteractionUseItem_FirecrackerLike::StartMaxRange' has a wrong offset!");
static_assert(offsetof(UAISkill_InteractionUseItem_FirecrackerLike, TargetFaceMeMaxHalfAngle) == 0x0002F0, "Member 'UAISkill_InteractionUseItem_FirecrackerLike::TargetFaceMeMaxHalfAngle' has a wrong offset!");

// Class DBDBots.AISkill_InteractionUseItem_Firecracker
// 0x0000 (0x02F8 - 0x02F8)
class UAISkill_InteractionUseItem_Firecracker final : public UAISkill_InteractionUseItem_FirecrackerLike
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_InteractionUseItem_Firecracker">();
	}
	static class UAISkill_InteractionUseItem_Firecracker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_InteractionUseItem_Firecracker>();
	}
};
static_assert(alignof(UAISkill_InteractionUseItem_Firecracker) == 0x000008, "Wrong alignment on UAISkill_InteractionUseItem_Firecracker");
static_assert(sizeof(UAISkill_InteractionUseItem_Firecracker) == 0x0002F8, "Wrong size on UAISkill_InteractionUseItem_Firecracker");

// Class DBDBots.AISkill_InteractionUseItem_Flashbang
// 0x0000 (0x02F8 - 0x02F8)
class UAISkill_InteractionUseItem_Flashbang final : public UAISkill_InteractionUseItem_FirecrackerLike
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_InteractionUseItem_Flashbang">();
	}
	static class UAISkill_InteractionUseItem_Flashbang* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_InteractionUseItem_Flashbang>();
	}
};
static_assert(alignof(UAISkill_InteractionUseItem_Flashbang) == 0x000008, "Wrong alignment on UAISkill_InteractionUseItem_Flashbang");
static_assert(sizeof(UAISkill_InteractionUseItem_Flashbang) == 0x0002F8, "Wrong size on UAISkill_InteractionUseItem_Flashbang");

// Class DBDBots.AISkill_InteractionUseItem_Flashlight
// 0x0110 (0x03A0 - 0x0290)
class UAISkill_InteractionUseItem_Flashlight final : public UAISkill_InteractionUseItem
{
public:
	struct FAIRoll                                VulnerableTargetStartRoll;                         // 0x0290(0x00C8)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         TargetFaceMeMaxHalfAngle;                          // 0x0358(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35C[0x4];                                      // 0x035C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 _targetActor;                                      // 0x0360(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_368[0x38];                                     // 0x0368(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_InteractionUseItem_Flashlight">();
	}
	static class UAISkill_InteractionUseItem_Flashlight* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_InteractionUseItem_Flashlight>();
	}
};
static_assert(alignof(UAISkill_InteractionUseItem_Flashlight) == 0x000008, "Wrong alignment on UAISkill_InteractionUseItem_Flashlight");
static_assert(sizeof(UAISkill_InteractionUseItem_Flashlight) == 0x0003A0, "Wrong size on UAISkill_InteractionUseItem_Flashlight");
static_assert(offsetof(UAISkill_InteractionUseItem_Flashlight, VulnerableTargetStartRoll) == 0x000290, "Member 'UAISkill_InteractionUseItem_Flashlight::VulnerableTargetStartRoll' has a wrong offset!");
static_assert(offsetof(UAISkill_InteractionUseItem_Flashlight, TargetFaceMeMaxHalfAngle) == 0x000358, "Member 'UAISkill_InteractionUseItem_Flashlight::TargetFaceMeMaxHalfAngle' has a wrong offset!");
static_assert(offsetof(UAISkill_InteractionUseItem_Flashlight, _targetActor) == 0x000360, "Member 'UAISkill_InteractionUseItem_Flashlight::_targetActor' has a wrong offset!");

// Class DBDBots.BTService_SetPathSpeedFactor
// 0x0008 (0x0080 - 0x0078)
class UBTService_SetPathSpeedFactor final : public UBTService
{
public:
	float                                         SpeedFactor;                                       // 0x0078(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_SetPathSpeedFactor">();
	}
	static class UBTService_SetPathSpeedFactor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_SetPathSpeedFactor>();
	}
};
static_assert(alignof(UBTService_SetPathSpeedFactor) == 0x000008, "Wrong alignment on UBTService_SetPathSpeedFactor");
static_assert(sizeof(UBTService_SetPathSpeedFactor) == 0x000080, "Wrong size on UBTService_SetPathSpeedFactor");
static_assert(offsetof(UBTService_SetPathSpeedFactor, SpeedFactor) == 0x000078, "Member 'UBTService_SetPathSpeedFactor::SpeedFactor' has a wrong offset!");

// Class DBDBots.AISkill_InteractionUseItem_K32Emp
// 0x0038 (0x02C8 - 0x0290)
class UAISkill_InteractionUseItem_K32Emp final : public UAISkill_InteractionUseItem
{
public:
	float                                         NearPodDistance;                                   // 0x0290(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BBIsFleeing;                                       // 0x0294(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SurvivorHeight;                                    // 0x02A0(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DoNotUseEmpUnderNavLinkDistance;                   // 0x02A4(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxTimeToUseEmpAfterLockonCooldown;                // 0x02A8(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AC[0x1C];                                     // 0x02AC(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_InteractionUseItem_K32Emp">();
	}
	static class UAISkill_InteractionUseItem_K32Emp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_InteractionUseItem_K32Emp>();
	}
};
static_assert(alignof(UAISkill_InteractionUseItem_K32Emp) == 0x000008, "Wrong alignment on UAISkill_InteractionUseItem_K32Emp");
static_assert(sizeof(UAISkill_InteractionUseItem_K32Emp) == 0x0002C8, "Wrong size on UAISkill_InteractionUseItem_K32Emp");
static_assert(offsetof(UAISkill_InteractionUseItem_K32Emp, NearPodDistance) == 0x000290, "Member 'UAISkill_InteractionUseItem_K32Emp::NearPodDistance' has a wrong offset!");
static_assert(offsetof(UAISkill_InteractionUseItem_K32Emp, BBIsFleeing) == 0x000294, "Member 'UAISkill_InteractionUseItem_K32Emp::BBIsFleeing' has a wrong offset!");
static_assert(offsetof(UAISkill_InteractionUseItem_K32Emp, SurvivorHeight) == 0x0002A0, "Member 'UAISkill_InteractionUseItem_K32Emp::SurvivorHeight' has a wrong offset!");
static_assert(offsetof(UAISkill_InteractionUseItem_K32Emp, DoNotUseEmpUnderNavLinkDistance) == 0x0002A4, "Member 'UAISkill_InteractionUseItem_K32Emp::DoNotUseEmpUnderNavLinkDistance' has a wrong offset!");
static_assert(offsetof(UAISkill_InteractionUseItem_K32Emp, MaxTimeToUseEmpAfterLockonCooldown) == 0x0002A8, "Member 'UAISkill_InteractionUseItem_K32Emp::MaxTimeToUseEmpAfterLockonCooldown' has a wrong offset!");

// Class DBDBots.AISkill_InteractionUseItem_Key_Addon
// 0x0008 (0x0298 - 0x0290)
class UAISkill_InteractionUseItem_Key_Addon final : public UAISkill_InteractionUseItem
{
public:
	float                                         RemainingPercentChargeToKeep;                      // 0x0290(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_294[0x4];                                      // 0x0294(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_InteractionUseItem_Key_Addon">();
	}
	static class UAISkill_InteractionUseItem_Key_Addon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_InteractionUseItem_Key_Addon>();
	}
};
static_assert(alignof(UAISkill_InteractionUseItem_Key_Addon) == 0x000008, "Wrong alignment on UAISkill_InteractionUseItem_Key_Addon");
static_assert(sizeof(UAISkill_InteractionUseItem_Key_Addon) == 0x000298, "Wrong size on UAISkill_InteractionUseItem_Key_Addon");
static_assert(offsetof(UAISkill_InteractionUseItem_Key_Addon, RemainingPercentChargeToKeep) == 0x000290, "Member 'UAISkill_InteractionUseItem_Key_Addon::RemainingPercentChargeToKeep' has a wrong offset!");

// Class DBDBots.BTTask_ExtWait
// 0x00C0 (0x0140 - 0x0080)
class UBTTask_ExtWait final : public UBTTask_Wait
{
public:
	struct FAITunableParameter                    WaitTimeInterval;                                  // 0x0080(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    WaitRandomDeviation;                               // 0x00E0(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_ExtWait">();
	}
	static class UBTTask_ExtWait* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_ExtWait>();
	}
};
static_assert(alignof(UBTTask_ExtWait) == 0x000008, "Wrong alignment on UBTTask_ExtWait");
static_assert(sizeof(UBTTask_ExtWait) == 0x000140, "Wrong size on UBTTask_ExtWait");
static_assert(offsetof(UBTTask_ExtWait, WaitTimeInterval) == 0x000080, "Member 'UBTTask_ExtWait::WaitTimeInterval' has a wrong offset!");
static_assert(offsetof(UBTTask_ExtWait, WaitRandomDeviation) == 0x0000E0, "Member 'UBTTask_ExtWait::WaitRandomDeviation' has a wrong offset!");

// Class DBDBots.AISkill_InteractionUseItem_Map
// 0x0000 (0x0290 - 0x0290)
class UAISkill_InteractionUseItem_Map final : public UAISkill_InteractionUseItem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_InteractionUseItem_Map">();
	}
	static class UAISkill_InteractionUseItem_Map* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_InteractionUseItem_Map>();
	}
};
static_assert(alignof(UAISkill_InteractionUseItem_Map) == 0x000008, "Wrong alignment on UAISkill_InteractionUseItem_Map");
static_assert(sizeof(UAISkill_InteractionUseItem_Map) == 0x000290, "Wrong size on UAISkill_InteractionUseItem_Map");

// Class DBDBots.AISkill_InteractionUseItem_Medkit_Addon
// 0x0008 (0x0298 - 0x0290)
class UAISkill_InteractionUseItem_Medkit_Addon final : public UAISkill_InteractionUseItem
{
public:
	float                                         RemainingChargeThreshold;                          // 0x0290(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_294[0x4];                                      // 0x0294(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_InteractionUseItem_Medkit_Addon">();
	}
	static class UAISkill_InteractionUseItem_Medkit_Addon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_InteractionUseItem_Medkit_Addon>();
	}
};
static_assert(alignof(UAISkill_InteractionUseItem_Medkit_Addon) == 0x000008, "Wrong alignment on UAISkill_InteractionUseItem_Medkit_Addon");
static_assert(sizeof(UAISkill_InteractionUseItem_Medkit_Addon) == 0x000298, "Wrong size on UAISkill_InteractionUseItem_Medkit_Addon");
static_assert(offsetof(UAISkill_InteractionUseItem_Medkit_Addon, RemainingChargeThreshold) == 0x000290, "Member 'UAISkill_InteractionUseItem_Medkit_Addon::RemainingChargeThreshold' has a wrong offset!");

// Class DBDBots.BTService_InputAtTiming
// 0x0008 (0x0088 - 0x0080)
class UBTService_InputAtTiming final : public UBTService_OnRelevantBase
{
public:
	EPawnInputPressTypes                          InputType;                                         // 0x0080(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0x7];                                       // 0x0081(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_InputAtTiming">();
	}
	static class UBTService_InputAtTiming* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_InputAtTiming>();
	}
};
static_assert(alignof(UBTService_InputAtTiming) == 0x000008, "Wrong alignment on UBTService_InputAtTiming");
static_assert(sizeof(UBTService_InputAtTiming) == 0x000088, "Wrong size on UBTService_InputAtTiming");
static_assert(offsetof(UBTService_InputAtTiming, InputType) == 0x000080, "Member 'UBTService_InputAtTiming::InputType' has a wrong offset!");

// Class DBDBots.AISkill_Interaction_AttachRBT
// 0x0000 (0x0280 - 0x0280)
class UAISkill_Interaction_AttachRBT final : public UAISkill_Interaction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_Interaction_AttachRBT">();
	}
	static class UAISkill_Interaction_AttachRBT* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_Interaction_AttachRBT>();
	}
};
static_assert(alignof(UAISkill_Interaction_AttachRBT) == 0x000008, "Wrong alignment on UAISkill_Interaction_AttachRBT");
static_assert(sizeof(UAISkill_Interaction_AttachRBT) == 0x000280, "Wrong size on UAISkill_Interaction_AttachRBT");

// Class DBDBots.AISkill_Interaction_Blink
// 0x0150 (0x03D0 - 0x0280)
class UAISkill_Interaction_Blink final : public UAISkill_Interaction
{
public:
	float                                         MinimumPatrolBlinkRange;                           // 0x0280(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaximumChaseSingleBlinkRange;                      // 0x0284(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinimumBlinkRange;                                 // 0x0288(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaximumConsecutiveBlinkRange;                      // 0x028C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PostBlinkMaxChargeTime;                            // 0x0290(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VerticalDistanceMultiplier;                        // 0x0294(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxBlinkTargetVerticalDistance;                    // 0x0298(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29C[0x4];                                      // 0x029C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAITunableParameter                    MaxBlinkDistanceInaccuracy;                        // 0x02A0(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    BlinkDistanceInaccuracyMaxDistance;                // 0x0300(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FName                                   BBBlinkDestination;                                // 0x0360(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BBHostileStimulusActor;                            // 0x036C(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BBWasHostileStimulusInSight;                       // 0x0378(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BBInvestigateLocation;                             // 0x0384(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BBPatrolLocation;                                  // 0x0390(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39C[0x34];                                     // 0x039C(0x0034)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_Interaction_Blink">();
	}
	static class UAISkill_Interaction_Blink* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_Interaction_Blink>();
	}
};
static_assert(alignof(UAISkill_Interaction_Blink) == 0x000008, "Wrong alignment on UAISkill_Interaction_Blink");
static_assert(sizeof(UAISkill_Interaction_Blink) == 0x0003D0, "Wrong size on UAISkill_Interaction_Blink");
static_assert(offsetof(UAISkill_Interaction_Blink, MinimumPatrolBlinkRange) == 0x000280, "Member 'UAISkill_Interaction_Blink::MinimumPatrolBlinkRange' has a wrong offset!");
static_assert(offsetof(UAISkill_Interaction_Blink, MaximumChaseSingleBlinkRange) == 0x000284, "Member 'UAISkill_Interaction_Blink::MaximumChaseSingleBlinkRange' has a wrong offset!");
static_assert(offsetof(UAISkill_Interaction_Blink, MinimumBlinkRange) == 0x000288, "Member 'UAISkill_Interaction_Blink::MinimumBlinkRange' has a wrong offset!");
static_assert(offsetof(UAISkill_Interaction_Blink, MaximumConsecutiveBlinkRange) == 0x00028C, "Member 'UAISkill_Interaction_Blink::MaximumConsecutiveBlinkRange' has a wrong offset!");
static_assert(offsetof(UAISkill_Interaction_Blink, PostBlinkMaxChargeTime) == 0x000290, "Member 'UAISkill_Interaction_Blink::PostBlinkMaxChargeTime' has a wrong offset!");
static_assert(offsetof(UAISkill_Interaction_Blink, VerticalDistanceMultiplier) == 0x000294, "Member 'UAISkill_Interaction_Blink::VerticalDistanceMultiplier' has a wrong offset!");
static_assert(offsetof(UAISkill_Interaction_Blink, MaxBlinkTargetVerticalDistance) == 0x000298, "Member 'UAISkill_Interaction_Blink::MaxBlinkTargetVerticalDistance' has a wrong offset!");
static_assert(offsetof(UAISkill_Interaction_Blink, MaxBlinkDistanceInaccuracy) == 0x0002A0, "Member 'UAISkill_Interaction_Blink::MaxBlinkDistanceInaccuracy' has a wrong offset!");
static_assert(offsetof(UAISkill_Interaction_Blink, BlinkDistanceInaccuracyMaxDistance) == 0x000300, "Member 'UAISkill_Interaction_Blink::BlinkDistanceInaccuracyMaxDistance' has a wrong offset!");
static_assert(offsetof(UAISkill_Interaction_Blink, BBBlinkDestination) == 0x000360, "Member 'UAISkill_Interaction_Blink::BBBlinkDestination' has a wrong offset!");
static_assert(offsetof(UAISkill_Interaction_Blink, BBHostileStimulusActor) == 0x00036C, "Member 'UAISkill_Interaction_Blink::BBHostileStimulusActor' has a wrong offset!");
static_assert(offsetof(UAISkill_Interaction_Blink, BBWasHostileStimulusInSight) == 0x000378, "Member 'UAISkill_Interaction_Blink::BBWasHostileStimulusInSight' has a wrong offset!");
static_assert(offsetof(UAISkill_Interaction_Blink, BBInvestigateLocation) == 0x000384, "Member 'UAISkill_Interaction_Blink::BBInvestigateLocation' has a wrong offset!");
static_assert(offsetof(UAISkill_Interaction_Blink, BBPatrolLocation) == 0x000390, "Member 'UAISkill_Interaction_Blink::BBPatrolLocation' has a wrong offset!");

// Class DBDBots.AISkill_Interaction_BloodRush
// 0x0040 (0x02C0 - 0x0280)
class UAISkill_Interaction_BloodRush final : public UAISkill_Interaction
{
public:
	float                                         AfterExhaustionMinimumDelaySeconds;                // 0x0280(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ForceUseAtRemainingPercent;                        // 0x0284(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDataTableDropdown                     PerkId;                                            // 0x0288(0x0030)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B8[0x8];                                      // 0x02B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_Interaction_BloodRush">();
	}
	static class UAISkill_Interaction_BloodRush* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_Interaction_BloodRush>();
	}
};
static_assert(alignof(UAISkill_Interaction_BloodRush) == 0x000008, "Wrong alignment on UAISkill_Interaction_BloodRush");
static_assert(sizeof(UAISkill_Interaction_BloodRush) == 0x0002C0, "Wrong size on UAISkill_Interaction_BloodRush");
static_assert(offsetof(UAISkill_Interaction_BloodRush, AfterExhaustionMinimumDelaySeconds) == 0x000280, "Member 'UAISkill_Interaction_BloodRush::AfterExhaustionMinimumDelaySeconds' has a wrong offset!");
static_assert(offsetof(UAISkill_Interaction_BloodRush, ForceUseAtRemainingPercent) == 0x000284, "Member 'UAISkill_Interaction_BloodRush::ForceUseAtRemainingPercent' has a wrong offset!");
static_assert(offsetof(UAISkill_Interaction_BloodRush, PerkId) == 0x000288, "Member 'UAISkill_Interaction_BloodRush::PerkId' has a wrong offset!");

// Class DBDBots.AISkill_Interaction_Clairvoyance
// 0x0018 (0x0298 - 0x0280)
class UAISkill_Interaction_Clairvoyance final : public UAISkill_Interaction
{
public:
	struct FGameplayTag                           DropCooldownTag;                                   // 0x0280(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DropCooldownDuration;                              // 0x028C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAddToExistingDuration;                            // 0x0290(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_291[0x7];                                      // 0x0291(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_Interaction_Clairvoyance">();
	}
	static class UAISkill_Interaction_Clairvoyance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_Interaction_Clairvoyance>();
	}
};
static_assert(alignof(UAISkill_Interaction_Clairvoyance) == 0x000008, "Wrong alignment on UAISkill_Interaction_Clairvoyance");
static_assert(sizeof(UAISkill_Interaction_Clairvoyance) == 0x000298, "Wrong size on UAISkill_Interaction_Clairvoyance");
static_assert(offsetof(UAISkill_Interaction_Clairvoyance, DropCooldownTag) == 0x000280, "Member 'UAISkill_Interaction_Clairvoyance::DropCooldownTag' has a wrong offset!");
static_assert(offsetof(UAISkill_Interaction_Clairvoyance, DropCooldownDuration) == 0x00028C, "Member 'UAISkill_Interaction_Clairvoyance::DropCooldownDuration' has a wrong offset!");
static_assert(offsetof(UAISkill_Interaction_Clairvoyance, bAddToExistingDuration) == 0x000290, "Member 'UAISkill_Interaction_Clairvoyance::bAddToExistingDuration' has a wrong offset!");

// Class DBDBots.BTTask_ClearBBEntry
// 0x0030 (0x00A8 - 0x0078)
class UBTTask_ClearBBEntry final : public UBTTaskNode
{
public:
	struct FBlackboardKeySelector                 BBToResetKey;                                      // 0x0078(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_ClearBBEntry">();
	}
	static class UBTTask_ClearBBEntry* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_ClearBBEntry>();
	}
};
static_assert(alignof(UBTTask_ClearBBEntry) == 0x000008, "Wrong alignment on UBTTask_ClearBBEntry");
static_assert(sizeof(UBTTask_ClearBBEntry) == 0x0000A8, "Wrong size on UBTTask_ClearBBEntry");
static_assert(offsetof(UBTTask_ClearBBEntry, BBToResetKey) == 0x000078, "Member 'UBTTask_ClearBBEntry::BBToResetKey' has a wrong offset!");

// Class DBDBots.AISkill_Interaction_Cloak
// 0x0028 (0x02A8 - 0x0280)
class UAISkill_Interaction_Cloak final : public UAISkill_Interaction
{
public:
	float                                         StartUncloakDistance;                              // 0x0280(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StopUncloakDistance;                               // 0x0284(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartUncloakForPickupDistance;                     // 0x0288(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BBHostileStimulusActor;                            // 0x028C(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BBDyingSurvivorLocation;                           // 0x0298(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A4[0x4];                                      // 0x02A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_Interaction_Cloak">();
	}
	static class UAISkill_Interaction_Cloak* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_Interaction_Cloak>();
	}
};
static_assert(alignof(UAISkill_Interaction_Cloak) == 0x000008, "Wrong alignment on UAISkill_Interaction_Cloak");
static_assert(sizeof(UAISkill_Interaction_Cloak) == 0x0002A8, "Wrong size on UAISkill_Interaction_Cloak");
static_assert(offsetof(UAISkill_Interaction_Cloak, StartUncloakDistance) == 0x000280, "Member 'UAISkill_Interaction_Cloak::StartUncloakDistance' has a wrong offset!");
static_assert(offsetof(UAISkill_Interaction_Cloak, StopUncloakDistance) == 0x000284, "Member 'UAISkill_Interaction_Cloak::StopUncloakDistance' has a wrong offset!");
static_assert(offsetof(UAISkill_Interaction_Cloak, StartUncloakForPickupDistance) == 0x000288, "Member 'UAISkill_Interaction_Cloak::StartUncloakForPickupDistance' has a wrong offset!");
static_assert(offsetof(UAISkill_Interaction_Cloak, BBHostileStimulusActor) == 0x00028C, "Member 'UAISkill_Interaction_Cloak::BBHostileStimulusActor' has a wrong offset!");
static_assert(offsetof(UAISkill_Interaction_Cloak, BBDyingSurvivorLocation) == 0x000298, "Member 'UAISkill_Interaction_Cloak::BBDyingSurvivorLocation' has a wrong offset!");

// Class DBDBots.AISkill_Interaction_CreateFragilePallet
// 0x0018 (0x0298 - 0x0280)
class UAISkill_Interaction_CreateFragilePallet final : public UAISkill_Interaction
{
public:
	uint8                                         Pad_280[0x8];                                      // 0x0280(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   BBEvadePointInteractable;                          // 0x0288(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FragilePalletLoopSafetyRatingPenalty;              // 0x0294(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_Interaction_CreateFragilePallet">();
	}
	static class UAISkill_Interaction_CreateFragilePallet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_Interaction_CreateFragilePallet>();
	}
};
static_assert(alignof(UAISkill_Interaction_CreateFragilePallet) == 0x000008, "Wrong alignment on UAISkill_Interaction_CreateFragilePallet");
static_assert(sizeof(UAISkill_Interaction_CreateFragilePallet) == 0x000298, "Wrong size on UAISkill_Interaction_CreateFragilePallet");
static_assert(offsetof(UAISkill_Interaction_CreateFragilePallet, BBEvadePointInteractable) == 0x000288, "Member 'UAISkill_Interaction_CreateFragilePallet::BBEvadePointInteractable' has a wrong offset!");
static_assert(offsetof(UAISkill_Interaction_CreateFragilePallet, FragilePalletLoopSafetyRatingPenalty) == 0x000294, "Member 'UAISkill_Interaction_CreateFragilePallet::FragilePalletLoopSafetyRatingPenalty' has a wrong offset!");

// Class DBDBots.BTService_ClearBBEntry
// 0x0030 (0x00B0 - 0x0080)
class UBTService_ClearBBEntry final : public UBTService_OnRelevantBase
{
public:
	struct FBlackboardKeySelector                 BBToResetKey;                                      // 0x0080(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_ClearBBEntry">();
	}
	static class UBTService_ClearBBEntry* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_ClearBBEntry>();
	}
};
static_assert(alignof(UBTService_ClearBBEntry) == 0x000008, "Wrong alignment on UBTService_ClearBBEntry");
static_assert(sizeof(UBTService_ClearBBEntry) == 0x0000B0, "Wrong size on UBTService_ClearBBEntry");
static_assert(offsetof(UBTService_ClearBBEntry, BBToResetKey) == 0x000080, "Member 'UBTService_ClearBBEntry::BBToResetKey' has a wrong offset!");

// Class DBDBots.AISkill_Interaction_DismissCrow
// 0x0010 (0x0290 - 0x0280)
class UAISkill_Interaction_DismissCrow final : public UAISkill_Interaction
{
public:
	class FName                                   BBShouldFallPallet;                                // 0x0280(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StopAtPalletDistance;                              // 0x028C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_Interaction_DismissCrow">();
	}
	static class UAISkill_Interaction_DismissCrow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_Interaction_DismissCrow>();
	}
};
static_assert(alignof(UAISkill_Interaction_DismissCrow) == 0x000008, "Wrong alignment on UAISkill_Interaction_DismissCrow");
static_assert(sizeof(UAISkill_Interaction_DismissCrow) == 0x000290, "Wrong size on UAISkill_Interaction_DismissCrow");
static_assert(offsetof(UAISkill_Interaction_DismissCrow, BBShouldFallPallet) == 0x000280, "Member 'UAISkill_Interaction_DismissCrow::BBShouldFallPallet' has a wrong offset!");
static_assert(offsetof(UAISkill_Interaction_DismissCrow, StopAtPalletDistance) == 0x00028C, "Member 'UAISkill_Interaction_DismissCrow::StopAtPalletDistance' has a wrong offset!");

// Class DBDBots.AISkill_Interaction_Dramaturgy
// 0x0060 (0x02E0 - 0x0280)
class UAISkill_Interaction_Dramaturgy final : public UAISkill_Interaction
{
public:
	struct FAITunableParameter                    UseDramaturgyUnderNavLinkDistance;                 // 0x0280(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_Interaction_Dramaturgy">();
	}
	static class UAISkill_Interaction_Dramaturgy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_Interaction_Dramaturgy>();
	}
};
static_assert(alignof(UAISkill_Interaction_Dramaturgy) == 0x000008, "Wrong alignment on UAISkill_Interaction_Dramaturgy");
static_assert(sizeof(UAISkill_Interaction_Dramaturgy) == 0x0002E0, "Wrong size on UAISkill_Interaction_Dramaturgy");
static_assert(offsetof(UAISkill_Interaction_Dramaturgy, UseDramaturgyUnderNavLinkDistance) == 0x000280, "Member 'UAISkill_Interaction_Dramaturgy::UseDramaturgyUnderNavLinkDistance' has a wrong offset!");

// Class DBDBots.BTService_SetCameraFocus
// 0x0030 (0x00A8 - 0x0078)
class UBTService_SetCameraFocus final : public UBTService
{
public:
	struct FBlackboardKeySelector                 BBFocalPoint;                                      // 0x0078(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_SetCameraFocus">();
	}
	static class UBTService_SetCameraFocus* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_SetCameraFocus>();
	}
};
static_assert(alignof(UBTService_SetCameraFocus) == 0x000008, "Wrong alignment on UBTService_SetCameraFocus");
static_assert(sizeof(UBTService_SetCameraFocus) == 0x0000A8, "Wrong size on UBTService_SetCameraFocus");
static_assert(offsetof(UBTService_SetCameraFocus, BBFocalPoint) == 0x000078, "Member 'UBTService_SetCameraFocus::BBFocalPoint' has a wrong offset!");

// Class DBDBots.AISkill_Interaction_ForThePeople
// 0x0018 (0x0298 - 0x0280)
class UAISkill_Interaction_ForThePeople final : public UAISkill_Interaction
{
public:
	uint8                                         Pad_280[0x8];                                      // 0x0280(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 BlockInteractionId;                                // 0x0288(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_Interaction_ForThePeople">();
	}
	static class UAISkill_Interaction_ForThePeople* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_Interaction_ForThePeople>();
	}
};
static_assert(alignof(UAISkill_Interaction_ForThePeople) == 0x000008, "Wrong alignment on UAISkill_Interaction_ForThePeople");
static_assert(sizeof(UAISkill_Interaction_ForThePeople) == 0x000298, "Wrong size on UAISkill_Interaction_ForThePeople");
static_assert(offsetof(UAISkill_Interaction_ForThePeople, BlockInteractionId) == 0x000288, "Member 'UAISkill_Interaction_ForThePeople::BlockInteractionId' has a wrong offset!");

// Class DBDBots.AISkill_Interaction_GeneratorSecondaryInteraction
// 0x0020 (0x02A0 - 0x0280)
class UAISkill_Interaction_GeneratorSecondaryInteraction : public UAISkill_Interaction
{
public:
	TArray<struct FPerkIdDropdown>                Perks;                                             // 0x0280(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           GeneratorSecondaryInteractionIds;                  // 0x0290(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_Interaction_GeneratorSecondaryInteraction">();
	}
	static class UAISkill_Interaction_GeneratorSecondaryInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_Interaction_GeneratorSecondaryInteraction>();
	}
};
static_assert(alignof(UAISkill_Interaction_GeneratorSecondaryInteraction) == 0x000008, "Wrong alignment on UAISkill_Interaction_GeneratorSecondaryInteraction");
static_assert(sizeof(UAISkill_Interaction_GeneratorSecondaryInteraction) == 0x0002A0, "Wrong size on UAISkill_Interaction_GeneratorSecondaryInteraction");
static_assert(offsetof(UAISkill_Interaction_GeneratorSecondaryInteraction, Perks) == 0x000280, "Member 'UAISkill_Interaction_GeneratorSecondaryInteraction::Perks' has a wrong offset!");
static_assert(offsetof(UAISkill_Interaction_GeneratorSecondaryInteraction, GeneratorSecondaryInteractionIds) == 0x000290, "Member 'UAISkill_Interaction_GeneratorSecondaryInteraction::GeneratorSecondaryInteractionIds' has a wrong offset!");

// Class DBDBots.BTService_FindActor
// 0x0018 (0x0360 - 0x0348)
class UBTService_FindActor : public UBTService_FindGoalObject
{
public:
	struct FVector                                ActorLocationOffset;                               // 0x0348(0x0018)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_FindActor">();
	}
	static class UBTService_FindActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_FindActor>();
	}
};
static_assert(alignof(UBTService_FindActor) == 0x000008, "Wrong alignment on UBTService_FindActor");
static_assert(sizeof(UBTService_FindActor) == 0x000360, "Wrong size on UBTService_FindActor");
static_assert(offsetof(UBTService_FindActor, ActorLocationOffset) == 0x000348, "Member 'UBTService_FindActor::ActorLocationOffset' has a wrong offset!");

// Class DBDBots.AISkill_Interaction_InLocker
// 0x0050 (0x02D0 - 0x0280)
class UAISkill_Interaction_InLocker : public UAISkill_Interaction
{
public:
	struct FDataTableDropdown                     PerkId;                                            // 0x0280(0x0030)(Edit, NativeAccessSpecifierPublic)
	struct FGameplayTag                           CooldownTag;                                       // 0x02B0(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialRunningTime;                                // 0x02BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          StartRefreshingTime;                               // 0x02C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C1[0x3];                                      // 0x02C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RefreshTimeMargin;                                 // 0x02C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RefreshTimeAmount;                                 // 0x02C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CC[0x4];                                      // 0x02CC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_Interaction_InLocker">();
	}
	static class UAISkill_Interaction_InLocker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_Interaction_InLocker>();
	}
};
static_assert(alignof(UAISkill_Interaction_InLocker) == 0x000008, "Wrong alignment on UAISkill_Interaction_InLocker");
static_assert(sizeof(UAISkill_Interaction_InLocker) == 0x0002D0, "Wrong size on UAISkill_Interaction_InLocker");
static_assert(offsetof(UAISkill_Interaction_InLocker, PerkId) == 0x000280, "Member 'UAISkill_Interaction_InLocker::PerkId' has a wrong offset!");
static_assert(offsetof(UAISkill_Interaction_InLocker, CooldownTag) == 0x0002B0, "Member 'UAISkill_Interaction_InLocker::CooldownTag' has a wrong offset!");
static_assert(offsetof(UAISkill_Interaction_InLocker, InitialRunningTime) == 0x0002BC, "Member 'UAISkill_Interaction_InLocker::InitialRunningTime' has a wrong offset!");
static_assert(offsetof(UAISkill_Interaction_InLocker, StartRefreshingTime) == 0x0002C0, "Member 'UAISkill_Interaction_InLocker::StartRefreshingTime' has a wrong offset!");
static_assert(offsetof(UAISkill_Interaction_InLocker, RefreshTimeMargin) == 0x0002C4, "Member 'UAISkill_Interaction_InLocker::RefreshTimeMargin' has a wrong offset!");
static_assert(offsetof(UAISkill_Interaction_InLocker, RefreshTimeAmount) == 0x0002C8, "Member 'UAISkill_Interaction_InLocker::RefreshTimeAmount' has a wrong offset!");

// Class DBDBots.AISkill_Interaction_InLocker_BuiltToLast
// 0x0000 (0x02D0 - 0x02D0)
class UAISkill_Interaction_InLocker_BuiltToLast final : public UAISkill_Interaction_InLocker
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_Interaction_InLocker_BuiltToLast">();
	}
	static class UAISkill_Interaction_InLocker_BuiltToLast* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_Interaction_InLocker_BuiltToLast>();
	}
};
static_assert(alignof(UAISkill_Interaction_InLocker_BuiltToLast) == 0x000008, "Wrong alignment on UAISkill_Interaction_InLocker_BuiltToLast");
static_assert(sizeof(UAISkill_Interaction_InLocker_BuiltToLast) == 0x0002D0, "Wrong size on UAISkill_Interaction_InLocker_BuiltToLast");

// Class DBDBots.BTTask_InputPress
// 0x0070 (0x00E8 - 0x0078)
class UBTTask_InputPress final : public UBTTaskNode
{
public:
	EPawnInputPressTypes                          Input;                                             // 0x0078(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETaskInputPressModes                          InputMode;                                         // 0x0079(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7A[0x6];                                       // 0x007A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAITunableParameter                    InputPressLoopInterval;                            // 0x0080(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	bool                                          LockInput;                                         // 0x00E0(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E1[0x7];                                       // 0x00E1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_InputPress">();
	}
	static class UBTTask_InputPress* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_InputPress>();
	}
};
static_assert(alignof(UBTTask_InputPress) == 0x000008, "Wrong alignment on UBTTask_InputPress");
static_assert(sizeof(UBTTask_InputPress) == 0x0000E8, "Wrong size on UBTTask_InputPress");
static_assert(offsetof(UBTTask_InputPress, Input) == 0x000078, "Member 'UBTTask_InputPress::Input' has a wrong offset!");
static_assert(offsetof(UBTTask_InputPress, InputMode) == 0x000079, "Member 'UBTTask_InputPress::InputMode' has a wrong offset!");
static_assert(offsetof(UBTTask_InputPress, InputPressLoopInterval) == 0x000080, "Member 'UBTTask_InputPress::InputPressLoopInterval' has a wrong offset!");
static_assert(offsetof(UBTTask_InputPress, LockInput) == 0x0000E0, "Member 'UBTTask_InputPress::LockInput' has a wrong offset!");

// Class DBDBots.AISkill_Interaction_InLocker_Flashbang
// 0x0000 (0x02D0 - 0x02D0)
class UAISkill_Interaction_InLocker_Flashbang final : public UAISkill_Interaction_InLocker
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_Interaction_InLocker_Flashbang">();
	}
	static class UAISkill_Interaction_InLocker_Flashbang* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_Interaction_InLocker_Flashbang>();
	}
};
static_assert(alignof(UAISkill_Interaction_InLocker_Flashbang) == 0x000008, "Wrong alignment on UAISkill_Interaction_InLocker_Flashbang");
static_assert(sizeof(UAISkill_Interaction_InLocker_Flashbang) == 0x0002D0, "Wrong size on UAISkill_Interaction_InLocker_Flashbang");

// Class DBDBots.AISkill_Interaction_InLocker_HeadOn
// 0x0060 (0x0330 - 0x02D0)
class UAISkill_Interaction_InLocker_HeadOn final : public UAISkill_Interaction_InLocker
{
public:
	struct FAITunableParameter                    MaxKillerNearbyDistance;                           // 0x02D0(0x0060)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_Interaction_InLocker_HeadOn">();
	}
	static class UAISkill_Interaction_InLocker_HeadOn* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_Interaction_InLocker_HeadOn>();
	}
};
static_assert(alignof(UAISkill_Interaction_InLocker_HeadOn) == 0x000008, "Wrong alignment on UAISkill_Interaction_InLocker_HeadOn");
static_assert(sizeof(UAISkill_Interaction_InLocker_HeadOn) == 0x000330, "Wrong size on UAISkill_Interaction_InLocker_HeadOn");
static_assert(offsetof(UAISkill_Interaction_InLocker_HeadOn, MaxKillerNearbyDistance) == 0x0002D0, "Member 'UAISkill_Interaction_InLocker_HeadOn::MaxKillerNearbyDistance' has a wrong offset!");

// Class DBDBots.BTService_FindInteractable
// 0x02A0 (0x0318 - 0x0078)
class UBTService_FindInteractable : public UBTService
{
public:
	uint8                                         Pad_78[0x10];                                      // 0x0078(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlackboardKeySelector                 BBSearchAround;                                    // 0x0088(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	float                                         SearchInterval;                                    // 0x00B8(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SearchHeightAmplifierActivationHeight;             // 0x00BC(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SearchHeightAmplifier;                             // 0x00C0(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C4[0x4];                                       // 0x00C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UNavigationQueryFilter>     FilterClass;                                       // 0x00C8(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RegisterAsDiscoveredWhenFound;                     // 0x00D0(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D1[0x7];                                       // 0x00D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlackboardKeySelector                 BBOnlyFromActor;                                   // 0x00D8(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	bool                                          RejectIfInPressureZone;                            // 0x0108(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_109[0x3];                                      // 0x0109(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   RejectCooldownContextName;                         // 0x010C(0x000C)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AbandonIfInChase;                                  // 0x0118(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RejectIfFocusedByOther;                            // 0x0119(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RejectIfNotFocusedBySelf;                          // 0x011A(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IgnoreFocusFilterInEndgameCollapse;                // 0x011B(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReverseKnownFilter;                                // 0x011C(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RejectIfNotInSight;                                // 0x011D(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IgnoreSightFilterIfDiscovered;                     // 0x011E(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IgnoreSightFilterIfInRange;                        // 0x011F(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RejectAboveRange;                                  // 0x0120(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IgnoreRangeFilterIfDiscovered;                     // 0x0124(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IgnoreRangeFilterIfInSight;                        // 0x0125(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_126[0x2];                                      // 0x0126(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlackboardKeySelector                 BBInteractableLocation;                            // 0x0128(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBInteractableObj;                                 // 0x0158(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBOwnerObj;                                        // 0x0188(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    GoalBasicWeight;                                   // 0x01B8(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    GoalWeightMaxDistance;                             // 0x0218(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    GoalWeightAtMinDistance;                           // 0x0278(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FGameplayTag                           WeightSkillContext;                                // 0x02D8(0x000C)(Edit, DisableEditOnTemplate, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E4[0x4];                                      // 0x02E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ProjectGoalLocationToNavigationExtent;             // 0x02E8(0x0018)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AInteractable*                          _goalInteractable;                                 // 0x0300(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ADBDAIBTController*                     _aiOwner;                                          // 0x0308(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_310[0x8];                                      // 0x0310(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_FindInteractable">();
	}
	static class UBTService_FindInteractable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_FindInteractable>();
	}
};
static_assert(alignof(UBTService_FindInteractable) == 0x000008, "Wrong alignment on UBTService_FindInteractable");
static_assert(sizeof(UBTService_FindInteractable) == 0x000318, "Wrong size on UBTService_FindInteractable");
static_assert(offsetof(UBTService_FindInteractable, BBSearchAround) == 0x000088, "Member 'UBTService_FindInteractable::BBSearchAround' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractable, SearchInterval) == 0x0000B8, "Member 'UBTService_FindInteractable::SearchInterval' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractable, SearchHeightAmplifierActivationHeight) == 0x0000BC, "Member 'UBTService_FindInteractable::SearchHeightAmplifierActivationHeight' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractable, SearchHeightAmplifier) == 0x0000C0, "Member 'UBTService_FindInteractable::SearchHeightAmplifier' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractable, FilterClass) == 0x0000C8, "Member 'UBTService_FindInteractable::FilterClass' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractable, RegisterAsDiscoveredWhenFound) == 0x0000D0, "Member 'UBTService_FindInteractable::RegisterAsDiscoveredWhenFound' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractable, BBOnlyFromActor) == 0x0000D8, "Member 'UBTService_FindInteractable::BBOnlyFromActor' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractable, RejectIfInPressureZone) == 0x000108, "Member 'UBTService_FindInteractable::RejectIfInPressureZone' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractable, RejectCooldownContextName) == 0x00010C, "Member 'UBTService_FindInteractable::RejectCooldownContextName' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractable, AbandonIfInChase) == 0x000118, "Member 'UBTService_FindInteractable::AbandonIfInChase' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractable, RejectIfFocusedByOther) == 0x000119, "Member 'UBTService_FindInteractable::RejectIfFocusedByOther' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractable, RejectIfNotFocusedBySelf) == 0x00011A, "Member 'UBTService_FindInteractable::RejectIfNotFocusedBySelf' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractable, IgnoreFocusFilterInEndgameCollapse) == 0x00011B, "Member 'UBTService_FindInteractable::IgnoreFocusFilterInEndgameCollapse' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractable, ReverseKnownFilter) == 0x00011C, "Member 'UBTService_FindInteractable::ReverseKnownFilter' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractable, RejectIfNotInSight) == 0x00011D, "Member 'UBTService_FindInteractable::RejectIfNotInSight' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractable, IgnoreSightFilterIfDiscovered) == 0x00011E, "Member 'UBTService_FindInteractable::IgnoreSightFilterIfDiscovered' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractable, IgnoreSightFilterIfInRange) == 0x00011F, "Member 'UBTService_FindInteractable::IgnoreSightFilterIfInRange' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractable, RejectAboveRange) == 0x000120, "Member 'UBTService_FindInteractable::RejectAboveRange' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractable, IgnoreRangeFilterIfDiscovered) == 0x000124, "Member 'UBTService_FindInteractable::IgnoreRangeFilterIfDiscovered' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractable, IgnoreRangeFilterIfInSight) == 0x000125, "Member 'UBTService_FindInteractable::IgnoreRangeFilterIfInSight' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractable, BBInteractableLocation) == 0x000128, "Member 'UBTService_FindInteractable::BBInteractableLocation' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractable, BBInteractableObj) == 0x000158, "Member 'UBTService_FindInteractable::BBInteractableObj' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractable, BBOwnerObj) == 0x000188, "Member 'UBTService_FindInteractable::BBOwnerObj' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractable, GoalBasicWeight) == 0x0001B8, "Member 'UBTService_FindInteractable::GoalBasicWeight' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractable, GoalWeightMaxDistance) == 0x000218, "Member 'UBTService_FindInteractable::GoalWeightMaxDistance' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractable, GoalWeightAtMinDistance) == 0x000278, "Member 'UBTService_FindInteractable::GoalWeightAtMinDistance' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractable, WeightSkillContext) == 0x0002D8, "Member 'UBTService_FindInteractable::WeightSkillContext' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractable, ProjectGoalLocationToNavigationExtent) == 0x0002E8, "Member 'UBTService_FindInteractable::ProjectGoalLocationToNavigationExtent' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractable, _goalInteractable) == 0x000300, "Member 'UBTService_FindInteractable::_goalInteractable' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractable, _aiOwner) == 0x000308, "Member 'UBTService_FindInteractable::_aiOwner' has a wrong offset!");

// Class DBDBots.BTService_FindInteractable_EnemySurvivor
// 0x0510 (0x0828 - 0x0318)
class UBTService_FindInteractable_EnemySurvivor final : public UBTService_FindInteractable
{
public:
	EFindEnemySurvivorPurpose                     PurposeFilter;                                     // 0x0318(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_319[0x7];                                      // 0x0319(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAITunableParameter                    LastSeenMaximumTime;                               // 0x0320(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	float                                         ReachedLastSeenLocationDistance;                   // 0x0380(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDistanceToLoopInteractable;                     // 0x0384(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDistanceToLoopPath;                             // 0x0388(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38C[0x4];                                      // 0x038C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAITunableParameter                    CrawlingRecoveryProgressGoalWeight;                // 0x0390(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    BestTargetWeight;                                  // 0x03F0(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    MeleeRangeWeight;                                  // 0x0450(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    MeleeRangeDistance;                                // 0x04B0(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    CurrentTargetWeight;                               // 0x0510(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    LastSurvivorWeight;                                // 0x0570(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    ActiveTimeWeightPenalty;                           // 0x05D0(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    LoopSafetyRatingWeightPenalty;                     // 0x0630(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBStimulusActor;                                   // 0x0690(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBStimulusNavLocation;                             // 0x06C0(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBIsStimulusInSight;                               // 0x06F0(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBWasInSight;                                      // 0x0720(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBPredictedLocation;                               // 0x0750(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBWasBlind;                                        // 0x0780(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	uint8                                         Pad_7B0[0x78];                                     // 0x07B0(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_FindInteractable_EnemySurvivor">();
	}
	static class UBTService_FindInteractable_EnemySurvivor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_FindInteractable_EnemySurvivor>();
	}
};
static_assert(alignof(UBTService_FindInteractable_EnemySurvivor) == 0x000008, "Wrong alignment on UBTService_FindInteractable_EnemySurvivor");
static_assert(sizeof(UBTService_FindInteractable_EnemySurvivor) == 0x000828, "Wrong size on UBTService_FindInteractable_EnemySurvivor");
static_assert(offsetof(UBTService_FindInteractable_EnemySurvivor, PurposeFilter) == 0x000318, "Member 'UBTService_FindInteractable_EnemySurvivor::PurposeFilter' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractable_EnemySurvivor, LastSeenMaximumTime) == 0x000320, "Member 'UBTService_FindInteractable_EnemySurvivor::LastSeenMaximumTime' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractable_EnemySurvivor, ReachedLastSeenLocationDistance) == 0x000380, "Member 'UBTService_FindInteractable_EnemySurvivor::ReachedLastSeenLocationDistance' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractable_EnemySurvivor, MaxDistanceToLoopInteractable) == 0x000384, "Member 'UBTService_FindInteractable_EnemySurvivor::MaxDistanceToLoopInteractable' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractable_EnemySurvivor, MaxDistanceToLoopPath) == 0x000388, "Member 'UBTService_FindInteractable_EnemySurvivor::MaxDistanceToLoopPath' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractable_EnemySurvivor, CrawlingRecoveryProgressGoalWeight) == 0x000390, "Member 'UBTService_FindInteractable_EnemySurvivor::CrawlingRecoveryProgressGoalWeight' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractable_EnemySurvivor, BestTargetWeight) == 0x0003F0, "Member 'UBTService_FindInteractable_EnemySurvivor::BestTargetWeight' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractable_EnemySurvivor, MeleeRangeWeight) == 0x000450, "Member 'UBTService_FindInteractable_EnemySurvivor::MeleeRangeWeight' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractable_EnemySurvivor, MeleeRangeDistance) == 0x0004B0, "Member 'UBTService_FindInteractable_EnemySurvivor::MeleeRangeDistance' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractable_EnemySurvivor, CurrentTargetWeight) == 0x000510, "Member 'UBTService_FindInteractable_EnemySurvivor::CurrentTargetWeight' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractable_EnemySurvivor, LastSurvivorWeight) == 0x000570, "Member 'UBTService_FindInteractable_EnemySurvivor::LastSurvivorWeight' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractable_EnemySurvivor, ActiveTimeWeightPenalty) == 0x0005D0, "Member 'UBTService_FindInteractable_EnemySurvivor::ActiveTimeWeightPenalty' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractable_EnemySurvivor, LoopSafetyRatingWeightPenalty) == 0x000630, "Member 'UBTService_FindInteractable_EnemySurvivor::LoopSafetyRatingWeightPenalty' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractable_EnemySurvivor, BBStimulusActor) == 0x000690, "Member 'UBTService_FindInteractable_EnemySurvivor::BBStimulusActor' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractable_EnemySurvivor, BBStimulusNavLocation) == 0x0006C0, "Member 'UBTService_FindInteractable_EnemySurvivor::BBStimulusNavLocation' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractable_EnemySurvivor, BBIsStimulusInSight) == 0x0006F0, "Member 'UBTService_FindInteractable_EnemySurvivor::BBIsStimulusInSight' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractable_EnemySurvivor, BBWasInSight) == 0x000720, "Member 'UBTService_FindInteractable_EnemySurvivor::BBWasInSight' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractable_EnemySurvivor, BBPredictedLocation) == 0x000750, "Member 'UBTService_FindInteractable_EnemySurvivor::BBPredictedLocation' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractable_EnemySurvivor, BBWasBlind) == 0x000780, "Member 'UBTService_FindInteractable_EnemySurvivor::BBWasBlind' has a wrong offset!");

// Class DBDBots.AISkill_Interaction_InLocker_InnerHealing
// 0x0000 (0x02D0 - 0x02D0)
class UAISkill_Interaction_InLocker_InnerHealing final : public UAISkill_Interaction_InLocker
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_Interaction_InLocker_InnerHealing">();
	}
	static class UAISkill_Interaction_InLocker_InnerHealing* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_Interaction_InLocker_InnerHealing>();
	}
};
static_assert(alignof(UAISkill_Interaction_InLocker_InnerHealing) == 0x000008, "Wrong alignment on UAISkill_Interaction_InLocker_InnerHealing");
static_assert(sizeof(UAISkill_Interaction_InLocker_InnerHealing) == 0x0002D0, "Wrong size on UAISkill_Interaction_InLocker_InnerHealing");

// Class DBDBots.AISkill_Interaction_Kill
// 0x0000 (0x0280 - 0x0280)
class UAISkill_Interaction_Kill final : public UAISkill_Interaction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_Interaction_Kill">();
	}
	static class UAISkill_Interaction_Kill* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_Interaction_Kill>();
	}
};
static_assert(alignof(UAISkill_Interaction_Kill) == 0x000008, "Wrong alignment on UAISkill_Interaction_Kill");
static_assert(sizeof(UAISkill_Interaction_Kill) == 0x000280, "Wrong size on UAISkill_Interaction_Kill");

// Class DBDBots.BTService_StateMonitor_Slasher
// 0x0030 (0x0108 - 0x00D8)
class UBTService_StateMonitor_Slasher final : public UBTService_StateMonitor
{
public:
	struct FBlackboardKeySelector                 BBIsCarrying;                                      // 0x00D8(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_StateMonitor_Slasher">();
	}
	static class UBTService_StateMonitor_Slasher* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_StateMonitor_Slasher>();
	}
};
static_assert(alignof(UBTService_StateMonitor_Slasher) == 0x000008, "Wrong alignment on UBTService_StateMonitor_Slasher");
static_assert(sizeof(UBTService_StateMonitor_Slasher) == 0x000108, "Wrong size on UBTService_StateMonitor_Slasher");
static_assert(offsetof(UBTService_StateMonitor_Slasher, BBIsCarrying) == 0x0000D8, "Member 'UBTService_StateMonitor_Slasher::BBIsCarrying' has a wrong offset!");

// Class DBDBots.AISkill_Interaction_MirroredIllusion
// 0x0000 (0x0280 - 0x0280)
class UAISkill_Interaction_MirroredIllusion final : public UAISkill_Interaction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_Interaction_MirroredIllusion">();
	}
	static class UAISkill_Interaction_MirroredIllusion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_Interaction_MirroredIllusion>();
	}
};
static_assert(alignof(UAISkill_Interaction_MirroredIllusion) == 0x000008, "Wrong alignment on UAISkill_Interaction_MirroredIllusion");
static_assert(sizeof(UAISkill_Interaction_MirroredIllusion) == 0x000280, "Wrong size on UAISkill_Interaction_MirroredIllusion");

// Class DBDBots.AISkill_Interaction_OutOfChase
// 0x0000 (0x0280 - 0x0280)
class UAISkill_Interaction_OutOfChase final : public UAISkill_Interaction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_Interaction_OutOfChase">();
	}
	static class UAISkill_Interaction_OutOfChase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_Interaction_OutOfChase>();
	}
};
static_assert(alignof(UAISkill_Interaction_OutOfChase) == 0x000008, "Wrong alignment on UAISkill_Interaction_OutOfChase");
static_assert(sizeof(UAISkill_Interaction_OutOfChase) == 0x000280, "Wrong size on UAISkill_Interaction_OutOfChase");

// Class DBDBots.AISkill_Interaction_PotentialEnergy
// 0x0060 (0x0300 - 0x02A0)
class UAISkill_Interaction_PotentialEnergy final : public UAISkill_Interaction_GeneratorSecondaryInteraction
{
public:
	float                                         DangerousGeneratorsRatio;                          // 0x02A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SafeGeneratorsRatio;                               // 0x02A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxGeneratorRepairPercentToUseTokens;              // 0x02A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AC[0x54];                                     // 0x02AC(0x0054)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_Interaction_PotentialEnergy">();
	}
	static class UAISkill_Interaction_PotentialEnergy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_Interaction_PotentialEnergy>();
	}
};
static_assert(alignof(UAISkill_Interaction_PotentialEnergy) == 0x000008, "Wrong alignment on UAISkill_Interaction_PotentialEnergy");
static_assert(sizeof(UAISkill_Interaction_PotentialEnergy) == 0x000300, "Wrong size on UAISkill_Interaction_PotentialEnergy");
static_assert(offsetof(UAISkill_Interaction_PotentialEnergy, DangerousGeneratorsRatio) == 0x0002A0, "Member 'UAISkill_Interaction_PotentialEnergy::DangerousGeneratorsRatio' has a wrong offset!");
static_assert(offsetof(UAISkill_Interaction_PotentialEnergy, SafeGeneratorsRatio) == 0x0002A4, "Member 'UAISkill_Interaction_PotentialEnergy::SafeGeneratorsRatio' has a wrong offset!");
static_assert(offsetof(UAISkill_Interaction_PotentialEnergy, MaxGeneratorRepairPercentToUseTokens) == 0x0002A8, "Member 'UAISkill_Interaction_PotentialEnergy::MaxGeneratorRepairPercentToUseTokens' has a wrong offset!");

// Class DBDBots.AISkill_Interaction_RecoverWhileCrawling
// 0x0010 (0x0290 - 0x0280)
class UAISkill_Interaction_RecoverWhileCrawling final : public UAISkill_Interaction
{
public:
	TArray<struct FPerkIdDropdown>                Perks;                                             // 0x0280(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_Interaction_RecoverWhileCrawling">();
	}
	static class UAISkill_Interaction_RecoverWhileCrawling* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_Interaction_RecoverWhileCrawling>();
	}
};
static_assert(alignof(UAISkill_Interaction_RecoverWhileCrawling) == 0x000008, "Wrong alignment on UAISkill_Interaction_RecoverWhileCrawling");
static_assert(sizeof(UAISkill_Interaction_RecoverWhileCrawling) == 0x000290, "Wrong size on UAISkill_Interaction_RecoverWhileCrawling");
static_assert(offsetof(UAISkill_Interaction_RecoverWhileCrawling, Perks) == 0x000280, "Member 'UAISkill_Interaction_RecoverWhileCrawling::Perks' has a wrong offset!");

// Class DBDBots.AISkill_Interaction_Reel
// 0x0000 (0x0280 - 0x0280)
class UAISkill_Interaction_Reel final : public UAISkill_Interaction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_Interaction_Reel">();
	}
	static class UAISkill_Interaction_Reel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_Interaction_Reel>();
	}
};
static_assert(alignof(UAISkill_Interaction_Reel) == 0x000008, "Wrong alignment on UAISkill_Interaction_Reel");
static_assert(sizeof(UAISkill_Interaction_Reel) == 0x000280, "Wrong size on UAISkill_Interaction_Reel");

// Class DBDBots.AISkill_Interaction_ReverseBamboozle
// 0x00D0 (0x0350 - 0x0280)
class UAISkill_Interaction_ReverseBamboozle final : public UAISkill_Interaction
{
public:
	struct FAITunableParameter                    MaxKillerDistanceFromVault;                        // 0x0280(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    MinVaultSafetyRating;                              // 0x02E0(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FName                                   BBEvadePointInteractable;                          // 0x0340(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34C[0x4];                                      // 0x034C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_Interaction_ReverseBamboozle">();
	}
	static class UAISkill_Interaction_ReverseBamboozle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_Interaction_ReverseBamboozle>();
	}
};
static_assert(alignof(UAISkill_Interaction_ReverseBamboozle) == 0x000008, "Wrong alignment on UAISkill_Interaction_ReverseBamboozle");
static_assert(sizeof(UAISkill_Interaction_ReverseBamboozle) == 0x000350, "Wrong size on UAISkill_Interaction_ReverseBamboozle");
static_assert(offsetof(UAISkill_Interaction_ReverseBamboozle, MaxKillerDistanceFromVault) == 0x000280, "Member 'UAISkill_Interaction_ReverseBamboozle::MaxKillerDistanceFromVault' has a wrong offset!");
static_assert(offsetof(UAISkill_Interaction_ReverseBamboozle, MinVaultSafetyRating) == 0x0002E0, "Member 'UAISkill_Interaction_ReverseBamboozle::MinVaultSafetyRating' has a wrong offset!");
static_assert(offsetof(UAISkill_Interaction_ReverseBamboozle, BBEvadePointInteractable) == 0x000340, "Member 'UAISkill_Interaction_ReverseBamboozle::BBEvadePointInteractable' has a wrong offset!");

// Class DBDBots.AISkill_Interaction_SetGeneratorTrap
// 0x0010 (0x02B0 - 0x02A0)
class UAISkill_Interaction_SetGeneratorTrap final : public UAISkill_Interaction_GeneratorSecondaryInteraction
{
public:
	float                                         MinGeneratorRepairPercentToSetTrap;                // 0x02A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAITerrorLevel                                TerrorLevelToSetTrap;                              // 0x02A4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAITerrorLevel                                TerrorLevelToSetTrapImmediately;                   // 0x02A5(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A6[0x2];                                      // 0x02A6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TerrorLevelCloseRange;                             // 0x02A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AC[0x4];                                      // 0x02AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_Interaction_SetGeneratorTrap">();
	}
	static class UAISkill_Interaction_SetGeneratorTrap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_Interaction_SetGeneratorTrap>();
	}
};
static_assert(alignof(UAISkill_Interaction_SetGeneratorTrap) == 0x000008, "Wrong alignment on UAISkill_Interaction_SetGeneratorTrap");
static_assert(sizeof(UAISkill_Interaction_SetGeneratorTrap) == 0x0002B0, "Wrong size on UAISkill_Interaction_SetGeneratorTrap");
static_assert(offsetof(UAISkill_Interaction_SetGeneratorTrap, MinGeneratorRepairPercentToSetTrap) == 0x0002A0, "Member 'UAISkill_Interaction_SetGeneratorTrap::MinGeneratorRepairPercentToSetTrap' has a wrong offset!");
static_assert(offsetof(UAISkill_Interaction_SetGeneratorTrap, TerrorLevelToSetTrap) == 0x0002A4, "Member 'UAISkill_Interaction_SetGeneratorTrap::TerrorLevelToSetTrap' has a wrong offset!");
static_assert(offsetof(UAISkill_Interaction_SetGeneratorTrap, TerrorLevelToSetTrapImmediately) == 0x0002A5, "Member 'UAISkill_Interaction_SetGeneratorTrap::TerrorLevelToSetTrapImmediately' has a wrong offset!");
static_assert(offsetof(UAISkill_Interaction_SetGeneratorTrap, TerrorLevelCloseRange) == 0x0002A8, "Member 'UAISkill_Interaction_SetGeneratorTrap::TerrorLevelCloseRange' has a wrong offset!");

// Class DBDBots.AISkill_Interaction_StaticBlast
// 0x0000 (0x0280 - 0x0280)
class UAISkill_Interaction_StaticBlast final : public UAISkill_Interaction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_Interaction_StaticBlast">();
	}
	static class UAISkill_Interaction_StaticBlast* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_Interaction_StaticBlast>();
	}
};
static_assert(alignof(UAISkill_Interaction_StaticBlast) == 0x000008, "Wrong alignment on UAISkill_Interaction_StaticBlast");
static_assert(sizeof(UAISkill_Interaction_StaticBlast) == 0x000280, "Wrong size on UAISkill_Interaction_StaticBlast");

// Class DBDBots.AISkill_Invisible
// 0x0020 (0x0138 - 0x0118)
class UAISkill_Invisible final : public UAISkill
{
public:
	TArray<struct FGameplayTag>                   InvisiblePerkFlags;                                // 0x0118(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class FString>                         ExtendDurationInteractions;                        // 0x0128(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_Invisible">();
	}
	static class UAISkill_Invisible* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_Invisible>();
	}
};
static_assert(alignof(UAISkill_Invisible) == 0x000008, "Wrong alignment on UAISkill_Invisible");
static_assert(sizeof(UAISkill_Invisible) == 0x000138, "Wrong size on UAISkill_Invisible");
static_assert(offsetof(UAISkill_Invisible, InvisiblePerkFlags) == 0x000118, "Member 'UAISkill_Invisible::InvisiblePerkFlags' has a wrong offset!");
static_assert(offsetof(UAISkill_Invisible, ExtendDurationInteractions) == 0x000128, "Member 'UAISkill_Invisible::ExtendDurationInteractions' has a wrong offset!");

// Class DBDBots.AISkill_LeaveGeneratorInteraction
// 0x0020 (0x0138 - 0x0118)
class UAISkill_LeaveGeneratorInteraction : public UAISkill
{
public:
	TArray<struct FPerkIdDropdown>                Perks;                                             // 0x0118(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   BBIsDoingLeaveGeneratorInteraction;                // 0x0128(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_134[0x4];                                      // 0x0134(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_LeaveGeneratorInteraction">();
	}
	static class UAISkill_LeaveGeneratorInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_LeaveGeneratorInteraction>();
	}
};
static_assert(alignof(UAISkill_LeaveGeneratorInteraction) == 0x000008, "Wrong alignment on UAISkill_LeaveGeneratorInteraction");
static_assert(sizeof(UAISkill_LeaveGeneratorInteraction) == 0x000138, "Wrong size on UAISkill_LeaveGeneratorInteraction");
static_assert(offsetof(UAISkill_LeaveGeneratorInteraction, Perks) == 0x000118, "Member 'UAISkill_LeaveGeneratorInteraction::Perks' has a wrong offset!");
static_assert(offsetof(UAISkill_LeaveGeneratorInteraction, BBIsDoingLeaveGeneratorInteraction) == 0x000128, "Member 'UAISkill_LeaveGeneratorInteraction::BBIsDoingLeaveGeneratorInteraction' has a wrong offset!");

// Class DBDBots.AISkill_LeaveGenerator_SetGeneratorTrap
// 0x0010 (0x0148 - 0x0138)
class UAISkill_LeaveGenerator_SetGeneratorTrap final : public UAISkill_LeaveGeneratorInteraction
{
public:
	float                                         MinGeneratorRepairPercentToSetTrap;                // 0x0138(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAITerrorLevel                                TerrorLevelToSetTrap;                              // 0x013C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAITerrorLevel                                TerrorLevelToSetTrapImmediately;                   // 0x013D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13E[0x2];                                      // 0x013E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TerrorLevelCloseRange;                             // 0x0140(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_144[0x4];                                      // 0x0144(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_LeaveGenerator_SetGeneratorTrap">();
	}
	static class UAISkill_LeaveGenerator_SetGeneratorTrap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_LeaveGenerator_SetGeneratorTrap>();
	}
};
static_assert(alignof(UAISkill_LeaveGenerator_SetGeneratorTrap) == 0x000008, "Wrong alignment on UAISkill_LeaveGenerator_SetGeneratorTrap");
static_assert(sizeof(UAISkill_LeaveGenerator_SetGeneratorTrap) == 0x000148, "Wrong size on UAISkill_LeaveGenerator_SetGeneratorTrap");
static_assert(offsetof(UAISkill_LeaveGenerator_SetGeneratorTrap, MinGeneratorRepairPercentToSetTrap) == 0x000138, "Member 'UAISkill_LeaveGenerator_SetGeneratorTrap::MinGeneratorRepairPercentToSetTrap' has a wrong offset!");
static_assert(offsetof(UAISkill_LeaveGenerator_SetGeneratorTrap, TerrorLevelToSetTrap) == 0x00013C, "Member 'UAISkill_LeaveGenerator_SetGeneratorTrap::TerrorLevelToSetTrap' has a wrong offset!");
static_assert(offsetof(UAISkill_LeaveGenerator_SetGeneratorTrap, TerrorLevelToSetTrapImmediately) == 0x00013D, "Member 'UAISkill_LeaveGenerator_SetGeneratorTrap::TerrorLevelToSetTrapImmediately' has a wrong offset!");
static_assert(offsetof(UAISkill_LeaveGenerator_SetGeneratorTrap, TerrorLevelCloseRange) == 0x000140, "Member 'UAISkill_LeaveGenerator_SetGeneratorTrap::TerrorLevelCloseRange' has a wrong offset!");

// Class DBDBots.AISkill_PlotTwist
// 0x00D0 (0x01E8 - 0x0118)
class UAISkill_PlotTwist final : public UAISkill
{
public:
	struct FPerkIdDropdown                        Perk;                                              // 0x0118(0x0010)(Edit, DisableEditOnTemplate, NoDestructor, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    MinimumDistanceFromKiller;                         // 0x0128(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    MinimumDistanceFromOtherSurvivor;                  // 0x0188(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_PlotTwist">();
	}
	static class UAISkill_PlotTwist* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_PlotTwist>();
	}
};
static_assert(alignof(UAISkill_PlotTwist) == 0x000008, "Wrong alignment on UAISkill_PlotTwist");
static_assert(sizeof(UAISkill_PlotTwist) == 0x0001E8, "Wrong size on UAISkill_PlotTwist");
static_assert(offsetof(UAISkill_PlotTwist, Perk) == 0x000118, "Member 'UAISkill_PlotTwist::Perk' has a wrong offset!");
static_assert(offsetof(UAISkill_PlotTwist, MinimumDistanceFromKiller) == 0x000128, "Member 'UAISkill_PlotTwist::MinimumDistanceFromKiller' has a wrong offset!");
static_assert(offsetof(UAISkill_PlotTwist, MinimumDistanceFromOtherSurvivor) == 0x000188, "Member 'UAISkill_PlotTwist::MinimumDistanceFromOtherSurvivor' has a wrong offset!");

// Class DBDBots.AISkill_Scavenger
// 0x0000 (0x0118 - 0x0118)
class UAISkill_Scavenger final : public UAISkill
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_Scavenger">();
	}
	static class UAISkill_Scavenger* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_Scavenger>();
	}
};
static_assert(alignof(UAISkill_Scavenger) == 0x000008, "Wrong alignment on UAISkill_Scavenger");
static_assert(sizeof(UAISkill_Scavenger) == 0x000118, "Wrong size on UAISkill_Scavenger");

// Class DBDBots.AISkill_SetBearTrap
// 0x0038 (0x0150 - 0x0118)
class UAISkill_SetBearTrap final : public UAISkill
{
public:
	class FName                                   BBTrapDestination;                                 // 0x0118(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDistanceFromAnotherSetTrap;                     // 0x0124(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDistanceFromPointOfInterest;                    // 0x0128(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CalculationTimeInterval;                           // 0x012C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_130[0x20];                                     // 0x0130(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_SetBearTrap">();
	}
	static class UAISkill_SetBearTrap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_SetBearTrap>();
	}
};
static_assert(alignof(UAISkill_SetBearTrap) == 0x000008, "Wrong alignment on UAISkill_SetBearTrap");
static_assert(sizeof(UAISkill_SetBearTrap) == 0x000150, "Wrong size on UAISkill_SetBearTrap");
static_assert(offsetof(UAISkill_SetBearTrap, BBTrapDestination) == 0x000118, "Member 'UAISkill_SetBearTrap::BBTrapDestination' has a wrong offset!");
static_assert(offsetof(UAISkill_SetBearTrap, MaxDistanceFromAnotherSetTrap) == 0x000124, "Member 'UAISkill_SetBearTrap::MaxDistanceFromAnotherSetTrap' has a wrong offset!");
static_assert(offsetof(UAISkill_SetBearTrap, MaxDistanceFromPointOfInterest) == 0x000128, "Member 'UAISkill_SetBearTrap::MaxDistanceFromPointOfInterest' has a wrong offset!");
static_assert(offsetof(UAISkill_SetBearTrap, CalculationTimeInterval) == 0x00012C, "Member 'UAISkill_SetBearTrap::CalculationTimeInterval' has a wrong offset!");

// Class DBDBots.AISkill_SkillCheck
// 0x0318 (0x0430 - 0x0118)
class UAISkill_SkillCheck final : public UAISkill
{
public:
	struct FAITunableParameter                    MaxSuccessLength;                                  // 0x0118(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    HalfSuccessLength;                                 // 0x0178(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    SkillCheckDifficultyCurve;                         // 0x01D8(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    SkillCheckUndesiredZonePenalty;                    // 0x0238(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    SkillCheckDifficultyModifierReversed;              // 0x0298(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    SkillCheckDifficultyModifierOffCenter;             // 0x02F8(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    SkillCheckDifficultyModifierSpeed;                 // 0x0358(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    SkillCheckDifficultyModifierWarningSound;          // 0x03B8(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         Pad_418[0x18];                                     // 0x0418(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_SkillCheck">();
	}
	static class UAISkill_SkillCheck* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_SkillCheck>();
	}
};
static_assert(alignof(UAISkill_SkillCheck) == 0x000008, "Wrong alignment on UAISkill_SkillCheck");
static_assert(sizeof(UAISkill_SkillCheck) == 0x000430, "Wrong size on UAISkill_SkillCheck");
static_assert(offsetof(UAISkill_SkillCheck, MaxSuccessLength) == 0x000118, "Member 'UAISkill_SkillCheck::MaxSuccessLength' has a wrong offset!");
static_assert(offsetof(UAISkill_SkillCheck, HalfSuccessLength) == 0x000178, "Member 'UAISkill_SkillCheck::HalfSuccessLength' has a wrong offset!");
static_assert(offsetof(UAISkill_SkillCheck, SkillCheckDifficultyCurve) == 0x0001D8, "Member 'UAISkill_SkillCheck::SkillCheckDifficultyCurve' has a wrong offset!");
static_assert(offsetof(UAISkill_SkillCheck, SkillCheckUndesiredZonePenalty) == 0x000238, "Member 'UAISkill_SkillCheck::SkillCheckUndesiredZonePenalty' has a wrong offset!");
static_assert(offsetof(UAISkill_SkillCheck, SkillCheckDifficultyModifierReversed) == 0x000298, "Member 'UAISkill_SkillCheck::SkillCheckDifficultyModifierReversed' has a wrong offset!");
static_assert(offsetof(UAISkill_SkillCheck, SkillCheckDifficultyModifierOffCenter) == 0x0002F8, "Member 'UAISkill_SkillCheck::SkillCheckDifficultyModifierOffCenter' has a wrong offset!");
static_assert(offsetof(UAISkill_SkillCheck, SkillCheckDifficultyModifierSpeed) == 0x000358, "Member 'UAISkill_SkillCheck::SkillCheckDifficultyModifierSpeed' has a wrong offset!");
static_assert(offsetof(UAISkill_SkillCheck, SkillCheckDifficultyModifierWarningSound) == 0x0003B8, "Member 'UAISkill_SkillCheck::SkillCheckDifficultyModifierWarningSound' has a wrong offset!");

// Class DBDBots.AISkill_Strafe
// 0x01D8 (0x02F0 - 0x0118)
class UAISkill_Strafe : public UAISkill
{
public:
	float                                         StartMaxRange;                                     // 0x0118(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StopMaxRange;                                      // 0x011C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartMaxRangeAgainstRangedHostileStimulus;         // 0x0120(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StopMaxRangeAgainstRangedHostileStimulus;          // 0x0124(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StrafeBackwardRange;                               // 0x0128(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StrafeFowardRange;                                 // 0x012C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DodgeDirectionSweepTestStartMultiplier;            // 0x0130(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DodgeDirectionSweepTestEndMultiplier;              // 0x0134(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DynamicDodgeDirectionAngleInterval;                // 0x0138(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IgnoreUnderNavLinkStartRange;                      // 0x013C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          PauseStrafeOnAnimation;                            // 0x0140(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_141[0x7];                                      // 0x0141(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAITunableParameter                    StrafeHoldInterval;                                // 0x0148(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    StrafeHoldDeviation;                               // 0x01A8(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    StrafePauseInterval;                               // 0x0208(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    StrafePauseDeviation;                              // 0x0268(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C8[0x28];                                     // 0x02C8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_Strafe">();
	}
	static class UAISkill_Strafe* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_Strafe>();
	}
};
static_assert(alignof(UAISkill_Strafe) == 0x000008, "Wrong alignment on UAISkill_Strafe");
static_assert(sizeof(UAISkill_Strafe) == 0x0002F0, "Wrong size on UAISkill_Strafe");
static_assert(offsetof(UAISkill_Strafe, StartMaxRange) == 0x000118, "Member 'UAISkill_Strafe::StartMaxRange' has a wrong offset!");
static_assert(offsetof(UAISkill_Strafe, StopMaxRange) == 0x00011C, "Member 'UAISkill_Strafe::StopMaxRange' has a wrong offset!");
static_assert(offsetof(UAISkill_Strafe, StartMaxRangeAgainstRangedHostileStimulus) == 0x000120, "Member 'UAISkill_Strafe::StartMaxRangeAgainstRangedHostileStimulus' has a wrong offset!");
static_assert(offsetof(UAISkill_Strafe, StopMaxRangeAgainstRangedHostileStimulus) == 0x000124, "Member 'UAISkill_Strafe::StopMaxRangeAgainstRangedHostileStimulus' has a wrong offset!");
static_assert(offsetof(UAISkill_Strafe, StrafeBackwardRange) == 0x000128, "Member 'UAISkill_Strafe::StrafeBackwardRange' has a wrong offset!");
static_assert(offsetof(UAISkill_Strafe, StrafeFowardRange) == 0x00012C, "Member 'UAISkill_Strafe::StrafeFowardRange' has a wrong offset!");
static_assert(offsetof(UAISkill_Strafe, DodgeDirectionSweepTestStartMultiplier) == 0x000130, "Member 'UAISkill_Strafe::DodgeDirectionSweepTestStartMultiplier' has a wrong offset!");
static_assert(offsetof(UAISkill_Strafe, DodgeDirectionSweepTestEndMultiplier) == 0x000134, "Member 'UAISkill_Strafe::DodgeDirectionSweepTestEndMultiplier' has a wrong offset!");
static_assert(offsetof(UAISkill_Strafe, DynamicDodgeDirectionAngleInterval) == 0x000138, "Member 'UAISkill_Strafe::DynamicDodgeDirectionAngleInterval' has a wrong offset!");
static_assert(offsetof(UAISkill_Strafe, IgnoreUnderNavLinkStartRange) == 0x00013C, "Member 'UAISkill_Strafe::IgnoreUnderNavLinkStartRange' has a wrong offset!");
static_assert(offsetof(UAISkill_Strafe, PauseStrafeOnAnimation) == 0x000140, "Member 'UAISkill_Strafe::PauseStrafeOnAnimation' has a wrong offset!");
static_assert(offsetof(UAISkill_Strafe, StrafeHoldInterval) == 0x000148, "Member 'UAISkill_Strafe::StrafeHoldInterval' has a wrong offset!");
static_assert(offsetof(UAISkill_Strafe, StrafeHoldDeviation) == 0x0001A8, "Member 'UAISkill_Strafe::StrafeHoldDeviation' has a wrong offset!");
static_assert(offsetof(UAISkill_Strafe, StrafePauseInterval) == 0x000208, "Member 'UAISkill_Strafe::StrafePauseInterval' has a wrong offset!");
static_assert(offsetof(UAISkill_Strafe, StrafePauseDeviation) == 0x000268, "Member 'UAISkill_Strafe::StrafePauseDeviation' has a wrong offset!");

// Class DBDBots.AISkill_StrafeChained
// 0x0000 (0x02F0 - 0x02F0)
class UAISkill_StrafeChained final : public UAISkill_Strafe
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_StrafeChained">();
	}
	static class UAISkill_StrafeChained* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_StrafeChained>();
	}
};
static_assert(alignof(UAISkill_StrafeChained) == 0x000008, "Wrong alignment on UAISkill_StrafeChained");
static_assert(sizeof(UAISkill_StrafeChained) == 0x0002F0, "Wrong size on UAISkill_StrafeChained");

// Class DBDBots.AISkill_StrafeDodge
// 0x00C8 (0x03B8 - 0x02F0)
class UAISkill_StrafeDodge final : public UAISkill_Strafe
{
public:
	struct FAIRoll                                StartRoll;                                         // 0x02F0(0x00C8)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_StrafeDodge">();
	}
	static class UAISkill_StrafeDodge* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_StrafeDodge>();
	}
};
static_assert(alignof(UAISkill_StrafeDodge) == 0x000008, "Wrong alignment on UAISkill_StrafeDodge");
static_assert(sizeof(UAISkill_StrafeDodge) == 0x0003B8, "Wrong size on UAISkill_StrafeDodge");
static_assert(offsetof(UAISkill_StrafeDodge, StartRoll) == 0x0002F0, "Member 'UAISkill_StrafeDodge::StartRoll' has a wrong offset!");

// Class DBDBots.AISkill_SuppressFootsteps
// 0x0000 (0x0118 - 0x0118)
class UAISkill_SuppressFootsteps final : public UAISkill
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_SuppressFootsteps">();
	}
	static class UAISkill_SuppressFootsteps* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_SuppressFootsteps>();
	}
};
static_assert(alignof(UAISkill_SuppressFootsteps) == 0x000008, "Wrong alignment on UAISkill_SuppressFootsteps");
static_assert(sizeof(UAISkill_SuppressFootsteps) == 0x000118, "Wrong size on UAISkill_SuppressFootsteps");

// Class DBDBots.AISkill_ThroughTorment
// 0x0010 (0x0128 - 0x0118)
class UAISkill_ThroughTorment final : public UAISkill
{
public:
	EAITerrorLevel                                ToleratedTerrorPressure;                           // 0x0118(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_119[0xF];                                      // 0x0119(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_ThroughTorment">();
	}
	static class UAISkill_ThroughTorment* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_ThroughTorment>();
	}
};
static_assert(alignof(UAISkill_ThroughTorment) == 0x000008, "Wrong alignment on UAISkill_ThroughTorment");
static_assert(sizeof(UAISkill_ThroughTorment) == 0x000128, "Wrong size on UAISkill_ThroughTorment");
static_assert(offsetof(UAISkill_ThroughTorment, ToleratedTerrorPressure) == 0x000118, "Member 'UAISkill_ThroughTorment::ToleratedTerrorPressure' has a wrong offset!");

// Class DBDBots.AISkill_UrbanEvasion
// 0x0000 (0x0118 - 0x0118)
class UAISkill_UrbanEvasion final : public UAISkill
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_UrbanEvasion">();
	}
	static class UAISkill_UrbanEvasion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_UrbanEvasion>();
	}
};
static_assert(alignof(UAISkill_UrbanEvasion) == 0x000008, "Wrong alignment on UAISkill_UrbanEvasion");
static_assert(sizeof(UAISkill_UrbanEvasion) == 0x000118, "Wrong size on UAISkill_UrbanEvasion");

// Class DBDBots.BTDecorator_CanRecoverMore
// 0x0000 (0x0070 - 0x0070)
class UBTDecorator_CanRecoverMore final : public UBTDecorator_TickableBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_CanRecoverMore">();
	}
	static class UBTDecorator_CanRecoverMore* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_CanRecoverMore>();
	}
};
static_assert(alignof(UBTDecorator_CanRecoverMore) == 0x000008, "Wrong alignment on UBTDecorator_CanRecoverMore");
static_assert(sizeof(UBTDecorator_CanRecoverMore) == 0x000070, "Wrong size on UBTDecorator_CanRecoverMore");

// Class DBDBots.BTDecorator_CanRecoverTo
// 0x0008 (0x0078 - 0x0070)
class UBTDecorator_CanRecoverTo final : public UBTDecorator_TickableBase
{
public:
	float                                         CanRecoverTo;                                      // 0x0070(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_CanRecoverTo">();
	}
	static class UBTDecorator_CanRecoverTo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_CanRecoverTo>();
	}
};
static_assert(alignof(UBTDecorator_CanRecoverTo) == 0x000008, "Wrong alignment on UBTDecorator_CanRecoverTo");
static_assert(sizeof(UBTDecorator_CanRecoverTo) == 0x000078, "Wrong size on UBTDecorator_CanRecoverTo");
static_assert(offsetof(UBTDecorator_CanRecoverTo, CanRecoverTo) == 0x000070, "Member 'UBTDecorator_CanRecoverTo::CanRecoverTo' has a wrong offset!");

// Class DBDBots.BTDecorator_CanUnsafeAction
// 0x0100 (0x0170 - 0x0070)
class UBTDecorator_CanUnsafeAction final : public UBTDecorator_TickableBase
{
public:
	struct FBlackboardKeySelector                 BBUnsafeActionID;                                  // 0x0070(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBUnsafeActionUsesItemAddons;                      // 0x00A0(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBUnsafeActionIsSelfInteraction;                   // 0x00D0(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBUnsafeActionRange;                               // 0x0100(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBGoalInteractor;                                  // 0x0130(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	float                                         ExtraHealthyTime;                                  // 0x0160(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExtraInjuredTime;                                  // 0x0164(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CommitDistance;                                    // 0x0168(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16C[0x4];                                      // 0x016C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_CanUnsafeAction">();
	}
	static class UBTDecorator_CanUnsafeAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_CanUnsafeAction>();
	}
};
static_assert(alignof(UBTDecorator_CanUnsafeAction) == 0x000008, "Wrong alignment on UBTDecorator_CanUnsafeAction");
static_assert(sizeof(UBTDecorator_CanUnsafeAction) == 0x000170, "Wrong size on UBTDecorator_CanUnsafeAction");
static_assert(offsetof(UBTDecorator_CanUnsafeAction, BBUnsafeActionID) == 0x000070, "Member 'UBTDecorator_CanUnsafeAction::BBUnsafeActionID' has a wrong offset!");
static_assert(offsetof(UBTDecorator_CanUnsafeAction, BBUnsafeActionUsesItemAddons) == 0x0000A0, "Member 'UBTDecorator_CanUnsafeAction::BBUnsafeActionUsesItemAddons' has a wrong offset!");
static_assert(offsetof(UBTDecorator_CanUnsafeAction, BBUnsafeActionIsSelfInteraction) == 0x0000D0, "Member 'UBTDecorator_CanUnsafeAction::BBUnsafeActionIsSelfInteraction' has a wrong offset!");
static_assert(offsetof(UBTDecorator_CanUnsafeAction, BBUnsafeActionRange) == 0x000100, "Member 'UBTDecorator_CanUnsafeAction::BBUnsafeActionRange' has a wrong offset!");
static_assert(offsetof(UBTDecorator_CanUnsafeAction, BBGoalInteractor) == 0x000130, "Member 'UBTDecorator_CanUnsafeAction::BBGoalInteractor' has a wrong offset!");
static_assert(offsetof(UBTDecorator_CanUnsafeAction, ExtraHealthyTime) == 0x000160, "Member 'UBTDecorator_CanUnsafeAction::ExtraHealthyTime' has a wrong offset!");
static_assert(offsetof(UBTDecorator_CanUnsafeAction, ExtraInjuredTime) == 0x000164, "Member 'UBTDecorator_CanUnsafeAction::ExtraInjuredTime' has a wrong offset!");
static_assert(offsetof(UBTDecorator_CanUnsafeAction, CommitDistance) == 0x000168, "Member 'UBTDecorator_CanUnsafeAction::CommitDistance' has a wrong offset!");

// Class DBDBots.BTDecorator_CompareInteractorCharge
// 0x0038 (0x00A8 - 0x0070)
class UBTDecorator_CompareInteractorCharge final : public UBTDecorator_TickableBase
{
public:
	EArithmeticKeyOperation                       ChargePercentQuery;                                // 0x0070(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x3];                                       // 0x0071(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ChargePercentValue;                                // 0x0074(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBInteractorObj;                                   // 0x0078(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_CompareInteractorCharge">();
	}
	static class UBTDecorator_CompareInteractorCharge* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_CompareInteractorCharge>();
	}
};
static_assert(alignof(UBTDecorator_CompareInteractorCharge) == 0x000008, "Wrong alignment on UBTDecorator_CompareInteractorCharge");
static_assert(sizeof(UBTDecorator_CompareInteractorCharge) == 0x0000A8, "Wrong size on UBTDecorator_CompareInteractorCharge");
static_assert(offsetof(UBTDecorator_CompareInteractorCharge, ChargePercentQuery) == 0x000070, "Member 'UBTDecorator_CompareInteractorCharge::ChargePercentQuery' has a wrong offset!");
static_assert(offsetof(UBTDecorator_CompareInteractorCharge, ChargePercentValue) == 0x000074, "Member 'UBTDecorator_CompareInteractorCharge::ChargePercentValue' has a wrong offset!");
static_assert(offsetof(UBTDecorator_CompareInteractorCharge, BBInteractorObj) == 0x000078, "Member 'UBTDecorator_CompareInteractorCharge::BBInteractorObj' has a wrong offset!");

// Class DBDBots.BTDecorator_CompareModifierValues
// 0x0048 (0x00B8 - 0x0070)
class UBTDecorator_CompareModifierValues final : public UBTDecorator_TickableBase
{
public:
	struct FModifierValueData                     ModifierValueData1;                                // 0x0070(0x0020)(Edit, DisableEditOnTemplate, NoDestructor, NativeAccessSpecifierPublic)
	EArithmeticKeyOperation                       ArithmeticOperation;                               // 0x0090(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x3];                                       // 0x0091(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FModifierValueData                     ModifierValueData2;                                // 0x0094(0x0020)(Edit, DisableEditOnTemplate, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_B4[0x4];                                       // 0x00B4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_CompareModifierValues">();
	}
	static class UBTDecorator_CompareModifierValues* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_CompareModifierValues>();
	}
};
static_assert(alignof(UBTDecorator_CompareModifierValues) == 0x000008, "Wrong alignment on UBTDecorator_CompareModifierValues");
static_assert(sizeof(UBTDecorator_CompareModifierValues) == 0x0000B8, "Wrong size on UBTDecorator_CompareModifierValues");
static_assert(offsetof(UBTDecorator_CompareModifierValues, ModifierValueData1) == 0x000070, "Member 'UBTDecorator_CompareModifierValues::ModifierValueData1' has a wrong offset!");
static_assert(offsetof(UBTDecorator_CompareModifierValues, ArithmeticOperation) == 0x000090, "Member 'UBTDecorator_CompareModifierValues::ArithmeticOperation' has a wrong offset!");
static_assert(offsetof(UBTDecorator_CompareModifierValues, ModifierValueData2) == 0x000094, "Member 'UBTDecorator_CompareModifierValues::ModifierValueData2' has a wrong offset!");

// Class DBDBots.BTDecorator_ContainsInteraction
// 0x0040 (0x00B0 - 0x0070)
class UBTDecorator_ContainsInteraction final : public UBTDecorator_TickableBase
{
public:
	struct FBlackboardKeySelector                 BBInteractorObj;                                   // 0x0070(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	TArray<class FString>                         InteractionIds;                                    // 0x00A0(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_ContainsInteraction">();
	}
	static class UBTDecorator_ContainsInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_ContainsInteraction>();
	}
};
static_assert(alignof(UBTDecorator_ContainsInteraction) == 0x000008, "Wrong alignment on UBTDecorator_ContainsInteraction");
static_assert(sizeof(UBTDecorator_ContainsInteraction) == 0x0000B0, "Wrong size on UBTDecorator_ContainsInteraction");
static_assert(offsetof(UBTDecorator_ContainsInteraction, BBInteractorObj) == 0x000070, "Member 'UBTDecorator_ContainsInteraction::BBInteractorObj' has a wrong offset!");
static_assert(offsetof(UBTDecorator_ContainsInteraction, InteractionIds) == 0x0000A0, "Member 'UBTDecorator_ContainsInteraction::InteractionIds' has a wrong offset!");

// Class DBDBots.BTDecorator_ExtCompareBBEntries
// 0x0008 (0x00E0 - 0x00D8)
class UBTDecorator_ExtCompareBBEntries final : public UBTDecorator_CompareBBEntries
{
public:
	float                                         Tolerance;                                         // 0x00D8(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DC[0x4];                                       // 0x00DC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_ExtCompareBBEntries">();
	}
	static class UBTDecorator_ExtCompareBBEntries* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_ExtCompareBBEntries>();
	}
};
static_assert(alignof(UBTDecorator_ExtCompareBBEntries) == 0x000008, "Wrong alignment on UBTDecorator_ExtCompareBBEntries");
static_assert(sizeof(UBTDecorator_ExtCompareBBEntries) == 0x0000E0, "Wrong size on UBTDecorator_ExtCompareBBEntries");
static_assert(offsetof(UBTDecorator_ExtCompareBBEntries, Tolerance) == 0x0000D8, "Member 'UBTDecorator_ExtCompareBBEntries::Tolerance' has a wrong offset!");

// Class DBDBots.BTDecorator_ExtConeCheck
// 0x00F0 (0x0160 - 0x0070)
class UBTDecorator_ExtConeCheck final : public UBTDecorator_TickableBase
{
public:
	struct FBlackboardKeySelector                 BBConeOrigin;                                      // 0x0070(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBConeDirection;                                   // 0x00A0(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBWith;                                            // 0x00D0(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    ConeHalfAngle;                                     // 0x0100(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_ExtConeCheck">();
	}
	static class UBTDecorator_ExtConeCheck* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_ExtConeCheck>();
	}
};
static_assert(alignof(UBTDecorator_ExtConeCheck) == 0x000008, "Wrong alignment on UBTDecorator_ExtConeCheck");
static_assert(sizeof(UBTDecorator_ExtConeCheck) == 0x000160, "Wrong size on UBTDecorator_ExtConeCheck");
static_assert(offsetof(UBTDecorator_ExtConeCheck, BBConeOrigin) == 0x000070, "Member 'UBTDecorator_ExtConeCheck::BBConeOrigin' has a wrong offset!");
static_assert(offsetof(UBTDecorator_ExtConeCheck, BBConeDirection) == 0x0000A0, "Member 'UBTDecorator_ExtConeCheck::BBConeDirection' has a wrong offset!");
static_assert(offsetof(UBTDecorator_ExtConeCheck, BBWith) == 0x0000D0, "Member 'UBTDecorator_ExtConeCheck::BBWith' has a wrong offset!");
static_assert(offsetof(UBTDecorator_ExtConeCheck, ConeHalfAngle) == 0x000100, "Member 'UBTDecorator_ExtConeCheck::ConeHalfAngle' has a wrong offset!");

// Class DBDBots.BTDecorator_ExtIsBBEntryOfClass
// 0x0008 (0x00B0 - 0x00A8)
class UBTDecorator_ExtIsBBEntryOfClass final : public UBTDecorator_IsBBEntryOfClass
{
public:
	bool                                          InvertConditition;                                 // 0x00A8(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_ExtIsBBEntryOfClass">();
	}
	static class UBTDecorator_ExtIsBBEntryOfClass* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_ExtIsBBEntryOfClass>();
	}
};
static_assert(alignof(UBTDecorator_ExtIsBBEntryOfClass) == 0x000008, "Wrong alignment on UBTDecorator_ExtIsBBEntryOfClass");
static_assert(sizeof(UBTDecorator_ExtIsBBEntryOfClass) == 0x0000B0, "Wrong size on UBTDecorator_ExtIsBBEntryOfClass");
static_assert(offsetof(UBTDecorator_ExtIsBBEntryOfClass, InvertConditition) == 0x0000A8, "Member 'UBTDecorator_ExtIsBBEntryOfClass::InvertConditition' has a wrong offset!");

// Class DBDBots.BTDecorator_ExtTimeLimit
// 0x00A0 (0x0118 - 0x0078)
class UBTDecorator_ExtTimeLimit final : public UBTDecorator_TimeLimit
{
public:
	uint8                                         Pad_78[0x8];                                       // 0x0078(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAITunableParameter                    MaxTimeLimit;                                      // 0x0080(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBFilterKey;                                       // 0x00E0(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	EBasicKeyOperation                            FilterOperation;                                   // 0x0110(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_111[0x7];                                      // 0x0111(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_ExtTimeLimit">();
	}
	static class UBTDecorator_ExtTimeLimit* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_ExtTimeLimit>();
	}
};
static_assert(alignof(UBTDecorator_ExtTimeLimit) == 0x000008, "Wrong alignment on UBTDecorator_ExtTimeLimit");
static_assert(sizeof(UBTDecorator_ExtTimeLimit) == 0x000118, "Wrong size on UBTDecorator_ExtTimeLimit");
static_assert(offsetof(UBTDecorator_ExtTimeLimit, MaxTimeLimit) == 0x000080, "Member 'UBTDecorator_ExtTimeLimit::MaxTimeLimit' has a wrong offset!");
static_assert(offsetof(UBTDecorator_ExtTimeLimit, BBFilterKey) == 0x0000E0, "Member 'UBTDecorator_ExtTimeLimit::BBFilterKey' has a wrong offset!");
static_assert(offsetof(UBTDecorator_ExtTimeLimit, FilterOperation) == 0x000110, "Member 'UBTDecorator_ExtTimeLimit::FilterOperation' has a wrong offset!");

// Class DBDBots.BTDecorator_GameplayModifierValue
// 0x0028 (0x0098 - 0x0070)
class UBTDecorator_GameplayModifierValue final : public UBTDecorator_TickableBase
{
public:
	EArithmeticKeyOperation                       ArithmeticOperation;                               // 0x0070(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x3];                                       // 0x0071(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FModifierValueData                     ModifierValueData;                                 // 0x0074(0x0020)(Edit, DisableEditOnTemplate, NoDestructor, NativeAccessSpecifierPublic)
	float                                         CompareToValue;                                    // 0x0094(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_GameplayModifierValue">();
	}
	static class UBTDecorator_GameplayModifierValue* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_GameplayModifierValue>();
	}
};
static_assert(alignof(UBTDecorator_GameplayModifierValue) == 0x000008, "Wrong alignment on UBTDecorator_GameplayModifierValue");
static_assert(sizeof(UBTDecorator_GameplayModifierValue) == 0x000098, "Wrong size on UBTDecorator_GameplayModifierValue");
static_assert(offsetof(UBTDecorator_GameplayModifierValue, ArithmeticOperation) == 0x000070, "Member 'UBTDecorator_GameplayModifierValue::ArithmeticOperation' has a wrong offset!");
static_assert(offsetof(UBTDecorator_GameplayModifierValue, ModifierValueData) == 0x000074, "Member 'UBTDecorator_GameplayModifierValue::ModifierValueData' has a wrong offset!");
static_assert(offsetof(UBTDecorator_GameplayModifierValue, CompareToValue) == 0x000094, "Member 'UBTDecorator_GameplayModifierValue::CompareToValue' has a wrong offset!");

// Class DBDBots.BTDecorator_HasActivatedBoonPerk
// 0x0000 (0x0070 - 0x0070)
class UBTDecorator_HasActivatedBoonPerk final : public UBTDecorator_TickableBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_HasActivatedBoonPerk">();
	}
	static class UBTDecorator_HasActivatedBoonPerk* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_HasActivatedBoonPerk>();
	}
};
static_assert(alignof(UBTDecorator_HasActivatedBoonPerk) == 0x000008, "Wrong alignment on UBTDecorator_HasActivatedBoonPerk");
static_assert(sizeof(UBTDecorator_HasActivatedBoonPerk) == 0x000070, "Wrong size on UBTDecorator_HasActivatedBoonPerk");

// Class DBDBots.BTDecorator_HasDynamicSubtree
// 0x0010 (0x0080 - 0x0070)
class UBTDecorator_HasDynamicSubtree final : public UBTDecorator_TickableBase
{
public:
	struct FGameplayTag                           InjectTag;                                         // 0x0070(0x000C)(Edit, DisableEditOnTemplate, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_HasDynamicSubtree">();
	}
	static class UBTDecorator_HasDynamicSubtree* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_HasDynamicSubtree>();
	}
};
static_assert(alignof(UBTDecorator_HasDynamicSubtree) == 0x000008, "Wrong alignment on UBTDecorator_HasDynamicSubtree");
static_assert(sizeof(UBTDecorator_HasDynamicSubtree) == 0x000080, "Wrong size on UBTDecorator_HasDynamicSubtree");
static_assert(offsetof(UBTDecorator_HasDynamicSubtree, InjectTag) == 0x000070, "Member 'UBTDecorator_HasDynamicSubtree::InjectTag' has a wrong offset!");

// Class DBDBots.BTDecorator_HasGoodHookEscapeChance
// 0x0008 (0x0078 - 0x0070)
class UBTDecorator_HasGoodHookEscapeChance final : public UBTDecorator_TickableBase
{
public:
	float                                         GoodHookEscapeProbability;                         // 0x0070(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_HasGoodHookEscapeChance">();
	}
	static class UBTDecorator_HasGoodHookEscapeChance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_HasGoodHookEscapeChance>();
	}
};
static_assert(alignof(UBTDecorator_HasGoodHookEscapeChance) == 0x000008, "Wrong alignment on UBTDecorator_HasGoodHookEscapeChance");
static_assert(sizeof(UBTDecorator_HasGoodHookEscapeChance) == 0x000078, "Wrong size on UBTDecorator_HasGoodHookEscapeChance");
static_assert(offsetof(UBTDecorator_HasGoodHookEscapeChance, GoodHookEscapeProbability) == 0x000070, "Member 'UBTDecorator_HasGoodHookEscapeChance::GoodHookEscapeProbability' has a wrong offset!");

// Class DBDBots.BTDecorator_HasItemAddon
// 0x0010 (0x0080 - 0x0070)
class UBTDecorator_HasItemAddon final : public UBTDecorator_TickableBase
{
public:
	TArray<struct FAIHasItemAddonCondition>       ItemAddOns;                                        // 0x0070(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_HasItemAddon">();
	}
	static class UBTDecorator_HasItemAddon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_HasItemAddon>();
	}
};
static_assert(alignof(UBTDecorator_HasItemAddon) == 0x000008, "Wrong alignment on UBTDecorator_HasItemAddon");
static_assert(sizeof(UBTDecorator_HasItemAddon) == 0x000080, "Wrong size on UBTDecorator_HasItemAddon");
static_assert(offsetof(UBTDecorator_HasItemAddon, ItemAddOns) == 0x000070, "Member 'UBTDecorator_HasItemAddon::ItemAddOns' has a wrong offset!");

// Class DBDBots.BTDecorator_HasPerkFlag
// 0x0010 (0x0080 - 0x0070)
class UBTDecorator_HasPerkFlag final : public UBTDecorator_TickableBase
{
public:
	TArray<struct FGameplayTag>                   GameplayTags;                                      // 0x0070(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_HasPerkFlag">();
	}
	static class UBTDecorator_HasPerkFlag* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_HasPerkFlag>();
	}
};
static_assert(alignof(UBTDecorator_HasPerkFlag) == 0x000008, "Wrong alignment on UBTDecorator_HasPerkFlag");
static_assert(sizeof(UBTDecorator_HasPerkFlag) == 0x000080, "Wrong size on UBTDecorator_HasPerkFlag");
static_assert(offsetof(UBTDecorator_HasPerkFlag, GameplayTags) == 0x000070, "Member 'UBTDecorator_HasPerkFlag::GameplayTags' has a wrong offset!");

// Class DBDBots.BTDecorator_HasStateTag
// 0x0010 (0x0080 - 0x0070)
class UBTDecorator_HasStateTag final : public UBTDecorator_TickableBase
{
public:
	TArray<struct FGameplayTag>                   StateTags;                                         // 0x0070(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_HasStateTag">();
	}
	static class UBTDecorator_HasStateTag* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_HasStateTag>();
	}
};
static_assert(alignof(UBTDecorator_HasStateTag) == 0x000008, "Wrong alignment on UBTDecorator_HasStateTag");
static_assert(sizeof(UBTDecorator_HasStateTag) == 0x000080, "Wrong size on UBTDecorator_HasStateTag");
static_assert(offsetof(UBTDecorator_HasStateTag, StateTags) == 0x000070, "Member 'UBTDecorator_HasStateTag::StateTags' has a wrong offset!");

// Class DBDBots.BTDecorator_HasStatusEffect
// 0x0010 (0x0080 - 0x0070)
class UBTDecorator_HasStatusEffect final : public UBTDecorator_TickableBase
{
public:
	TArray<class FName>                           StatusEffectIds;                                   // 0x0070(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_HasStatusEffect">();
	}
	static class UBTDecorator_HasStatusEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_HasStatusEffect>();
	}
};
static_assert(alignof(UBTDecorator_HasStatusEffect) == 0x000008, "Wrong alignment on UBTDecorator_HasStatusEffect");
static_assert(sizeof(UBTDecorator_HasStatusEffect) == 0x000080, "Wrong size on UBTDecorator_HasStatusEffect");
static_assert(offsetof(UBTDecorator_HasStatusEffect, StatusEffectIds) == 0x000070, "Member 'UBTDecorator_HasStatusEffect::StatusEffectIds' has a wrong offset!");

// Class DBDBots.BTDecorator_IsCamperState
// 0x0040 (0x00B0 - 0x0070)
class UBTDecorator_IsCamperState final : public UBTDecorator_TickableBase
{
public:
	struct FBlackboardKeySelector                 BBCamper;                                          // 0x0070(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	ECamperDamageState                            DamageState;                                       // 0x00A0(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EArithmeticKeyOperation                       DamageOp;                                          // 0x00A1(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EImmobilizedState                             ImmobilizeState;                                   // 0x00A2(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EArithmeticKeyOperation                       ImmobilizeOp;                                      // 0x00A3(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EIsCamperStateOnFilter                        OnFilter;                                          // 0x00A4(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EArithmeticKeyOperation                       OnOthersFilterOp;                                  // 0x00A5(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A6[0x2];                                       // 0x00A6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NbOnOthersCampers;                                 // 0x00A8(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_IsCamperState">();
	}
	static class UBTDecorator_IsCamperState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_IsCamperState>();
	}
};
static_assert(alignof(UBTDecorator_IsCamperState) == 0x000008, "Wrong alignment on UBTDecorator_IsCamperState");
static_assert(sizeof(UBTDecorator_IsCamperState) == 0x0000B0, "Wrong size on UBTDecorator_IsCamperState");
static_assert(offsetof(UBTDecorator_IsCamperState, BBCamper) == 0x000070, "Member 'UBTDecorator_IsCamperState::BBCamper' has a wrong offset!");
static_assert(offsetof(UBTDecorator_IsCamperState, DamageState) == 0x0000A0, "Member 'UBTDecorator_IsCamperState::DamageState' has a wrong offset!");
static_assert(offsetof(UBTDecorator_IsCamperState, DamageOp) == 0x0000A1, "Member 'UBTDecorator_IsCamperState::DamageOp' has a wrong offset!");
static_assert(offsetof(UBTDecorator_IsCamperState, ImmobilizeState) == 0x0000A2, "Member 'UBTDecorator_IsCamperState::ImmobilizeState' has a wrong offset!");
static_assert(offsetof(UBTDecorator_IsCamperState, ImmobilizeOp) == 0x0000A3, "Member 'UBTDecorator_IsCamperState::ImmobilizeOp' has a wrong offset!");
static_assert(offsetof(UBTDecorator_IsCamperState, OnFilter) == 0x0000A4, "Member 'UBTDecorator_IsCamperState::OnFilter' has a wrong offset!");
static_assert(offsetof(UBTDecorator_IsCamperState, OnOthersFilterOp) == 0x0000A5, "Member 'UBTDecorator_IsCamperState::OnOthersFilterOp' has a wrong offset!");
static_assert(offsetof(UBTDecorator_IsCamperState, NbOnOthersCampers) == 0x0000A8, "Member 'UBTDecorator_IsCamperState::NbOnOthersCampers' has a wrong offset!");

// Class DBDBots.BTDecorator_IsGameState
// 0x0010 (0x0080 - 0x0070)
class UBTDecorator_IsGameState final : public UBTDecorator_TickableBase
{
public:
	EArithmeticKeyOperation                       RemainingObjectiveOp;                              // 0x0070(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x3];                                       // 0x0071(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NbRemainingObjectives;                             // 0x0074(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EArithmeticKeyOperation                       SurvivorsLeftOp;                                   // 0x0078(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x3];                                       // 0x0079(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NbSurvivorsLeft;                                   // 0x007C(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_IsGameState">();
	}
	static class UBTDecorator_IsGameState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_IsGameState>();
	}
};
static_assert(alignof(UBTDecorator_IsGameState) == 0x000008, "Wrong alignment on UBTDecorator_IsGameState");
static_assert(sizeof(UBTDecorator_IsGameState) == 0x000080, "Wrong size on UBTDecorator_IsGameState");
static_assert(offsetof(UBTDecorator_IsGameState, RemainingObjectiveOp) == 0x000070, "Member 'UBTDecorator_IsGameState::RemainingObjectiveOp' has a wrong offset!");
static_assert(offsetof(UBTDecorator_IsGameState, NbRemainingObjectives) == 0x000074, "Member 'UBTDecorator_IsGameState::NbRemainingObjectives' has a wrong offset!");
static_assert(offsetof(UBTDecorator_IsGameState, SurvivorsLeftOp) == 0x000078, "Member 'UBTDecorator_IsGameState::SurvivorsLeftOp' has a wrong offset!");
static_assert(offsetof(UBTDecorator_IsGameState, NbSurvivorsLeft) == 0x00007C, "Member 'UBTDecorator_IsGameState::NbSurvivorsLeft' has a wrong offset!");

// Class DBDBots.BTDecorator_IsInteractorAvailable
// 0x0030 (0x00A0 - 0x0070)
class UBTDecorator_IsInteractorAvailable final : public UBTDecorator_TickableBase
{
public:
	struct FBlackboardKeySelector                 BBInteractorObj;                                   // 0x0070(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_IsInteractorAvailable">();
	}
	static class UBTDecorator_IsInteractorAvailable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_IsInteractorAvailable>();
	}
};
static_assert(alignof(UBTDecorator_IsInteractorAvailable) == 0x000008, "Wrong alignment on UBTDecorator_IsInteractorAvailable");
static_assert(sizeof(UBTDecorator_IsInteractorAvailable) == 0x0000A0, "Wrong size on UBTDecorator_IsInteractorAvailable");
static_assert(offsetof(UBTDecorator_IsInteractorAvailable, BBInteractorObj) == 0x000070, "Member 'UBTDecorator_IsInteractorAvailable::BBInteractorObj' has a wrong offset!");

// Class DBDBots.BTDecorator_IsNearestThan
// 0x0070 (0x00E0 - 0x0070)
class UBTDecorator_IsNearestThan final : public UBTDecorator_TickableBase
{
public:
	struct FBlackboardKeySelector                 BBFrom;                                            // 0x0070(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	bool                                          CompareWithConstantDistance;                       // 0x00A0(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x3];                                       // 0x00A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ThanDistance;                                      // 0x00A4(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBThan;                                            // 0x00A8(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	float                                         AddDistanceBuffer;                                 // 0x00D8(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DC[0x4];                                       // 0x00DC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_IsNearestThan">();
	}
	static class UBTDecorator_IsNearestThan* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_IsNearestThan>();
	}
};
static_assert(alignof(UBTDecorator_IsNearestThan) == 0x000008, "Wrong alignment on UBTDecorator_IsNearestThan");
static_assert(sizeof(UBTDecorator_IsNearestThan) == 0x0000E0, "Wrong size on UBTDecorator_IsNearestThan");
static_assert(offsetof(UBTDecorator_IsNearestThan, BBFrom) == 0x000070, "Member 'UBTDecorator_IsNearestThan::BBFrom' has a wrong offset!");
static_assert(offsetof(UBTDecorator_IsNearestThan, CompareWithConstantDistance) == 0x0000A0, "Member 'UBTDecorator_IsNearestThan::CompareWithConstantDistance' has a wrong offset!");
static_assert(offsetof(UBTDecorator_IsNearestThan, ThanDistance) == 0x0000A4, "Member 'UBTDecorator_IsNearestThan::ThanDistance' has a wrong offset!");
static_assert(offsetof(UBTDecorator_IsNearestThan, BBThan) == 0x0000A8, "Member 'UBTDecorator_IsNearestThan::BBThan' has a wrong offset!");
static_assert(offsetof(UBTDecorator_IsNearestThan, AddDistanceBuffer) == 0x0000D8, "Member 'UBTDecorator_IsNearestThan::AddDistanceBuffer' has a wrong offset!");

// Class DBDBots.BTDecorator_IsObjectFocused
// 0x0038 (0x00A8 - 0x0070)
class UBTDecorator_IsObjectFocused final : public UBTDecorator_TickableBase
{
public:
	struct FBlackboardKeySelector                 BBObj;                                             // 0x0070(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	EDecoratorIsObjFocusedFilter                  Filter;                                            // 0x00A0(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_IsObjectFocused">();
	}
	static class UBTDecorator_IsObjectFocused* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_IsObjectFocused>();
	}
};
static_assert(alignof(UBTDecorator_IsObjectFocused) == 0x000008, "Wrong alignment on UBTDecorator_IsObjectFocused");
static_assert(sizeof(UBTDecorator_IsObjectFocused) == 0x0000A8, "Wrong size on UBTDecorator_IsObjectFocused");
static_assert(offsetof(UBTDecorator_IsObjectFocused, BBObj) == 0x000070, "Member 'UBTDecorator_IsObjectFocused::BBObj' has a wrong offset!");
static_assert(offsetof(UBTDecorator_IsObjectFocused, Filter) == 0x0000A0, "Member 'UBTDecorator_IsObjectFocused::Filter' has a wrong offset!");

// Class DBDBots.BTDecorator_IsTunable
// 0x0070 (0x00E0 - 0x0070)
class UBTDecorator_IsTunable final : public UBTDecorator_TickableBase
{
public:
	ETunableComparison                            Operator;                                          // 0x0070(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAITunableParameter                    TunableValue;                                      // 0x0078(0x0060)(Edit, NativeAccessSpecifierPublic)
	float                                         CompareToValue;                                    // 0x00D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DC[0x4];                                       // 0x00DC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_IsTunable">();
	}
	static class UBTDecorator_IsTunable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_IsTunable>();
	}
};
static_assert(alignof(UBTDecorator_IsTunable) == 0x000008, "Wrong alignment on UBTDecorator_IsTunable");
static_assert(sizeof(UBTDecorator_IsTunable) == 0x0000E0, "Wrong size on UBTDecorator_IsTunable");
static_assert(offsetof(UBTDecorator_IsTunable, Operator) == 0x000070, "Member 'UBTDecorator_IsTunable::Operator' has a wrong offset!");
static_assert(offsetof(UBTDecorator_IsTunable, TunableValue) == 0x000078, "Member 'UBTDecorator_IsTunable::TunableValue' has a wrong offset!");
static_assert(offsetof(UBTDecorator_IsTunable, CompareToValue) == 0x0000D8, "Member 'UBTDecorator_IsTunable::CompareToValue' has a wrong offset!");

// Class DBDBots.BTDecorator_Random
// 0x0060 (0x00D0 - 0x0070)
class UBTDecorator_Random final : public UBTDecorator_TickableBase
{
public:
	struct FAITunableParameter                    PercentageRatio;                                   // 0x0070(0x0060)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_Random">();
	}
	static class UBTDecorator_Random* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_Random>();
	}
};
static_assert(alignof(UBTDecorator_Random) == 0x000008, "Wrong alignment on UBTDecorator_Random");
static_assert(sizeof(UBTDecorator_Random) == 0x0000D0, "Wrong size on UBTDecorator_Random");
static_assert(offsetof(UBTDecorator_Random, PercentageRatio) == 0x000070, "Member 'UBTDecorator_Random::PercentageRatio' has a wrong offset!");

// Class DBDBots.BTDecorator_RandomByRetry
// 0x0130 (0x01A0 - 0x0070)
class UBTDecorator_RandomByRetry final : public UBTDecorator_TickableBase
{
public:
	struct FAITunableParameter                    BaseSuccessRate;                                   // 0x0070(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    PerRetrySuccessRate;                               // 0x00D0(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	bool                                          ResetWhenValue;                                    // 0x0130(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_131[0x7];                                      // 0x0131(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAITunableParameter                    ResetAfterTime;                                    // 0x0138(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	bool                                          ResetOnCeaseRelevant;                              // 0x0198(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_199[0x7];                                      // 0x0199(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_RandomByRetry">();
	}
	static class UBTDecorator_RandomByRetry* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_RandomByRetry>();
	}
};
static_assert(alignof(UBTDecorator_RandomByRetry) == 0x000008, "Wrong alignment on UBTDecorator_RandomByRetry");
static_assert(sizeof(UBTDecorator_RandomByRetry) == 0x0001A0, "Wrong size on UBTDecorator_RandomByRetry");
static_assert(offsetof(UBTDecorator_RandomByRetry, BaseSuccessRate) == 0x000070, "Member 'UBTDecorator_RandomByRetry::BaseSuccessRate' has a wrong offset!");
static_assert(offsetof(UBTDecorator_RandomByRetry, PerRetrySuccessRate) == 0x0000D0, "Member 'UBTDecorator_RandomByRetry::PerRetrySuccessRate' has a wrong offset!");
static_assert(offsetof(UBTDecorator_RandomByRetry, ResetWhenValue) == 0x000130, "Member 'UBTDecorator_RandomByRetry::ResetWhenValue' has a wrong offset!");
static_assert(offsetof(UBTDecorator_RandomByRetry, ResetAfterTime) == 0x000138, "Member 'UBTDecorator_RandomByRetry::ResetAfterTime' has a wrong offset!");
static_assert(offsetof(UBTDecorator_RandomByRetry, ResetOnCeaseRelevant) == 0x000198, "Member 'UBTDecorator_RandomByRetry::ResetOnCeaseRelevant' has a wrong offset!");

// Class DBDBots.BTService_ClosestNavMeshLocation
// 0x0070 (0x0118 - 0x00A8)
class UBTService_ClosestNavMeshLocation final : public UBTService_BlackboardBase
{
public:
	struct FBlackboardKeySelector                 BBAroundLocation;                                  // 0x00A8(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	float                                         ValidLocationRefreshInterval;                      // 0x00D8(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InvalidLocationRefreshInterval;                    // 0x00DC(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NavDataAgentName;                                  // 0x00E0(0x000C)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EC[0x4];                                       // 0x00EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                NavMeshProjectionBoxExtent;                        // 0x00F0(0x0018)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNavigationSystemV1*                    _navigationSystem;                                 // 0x0108(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ANavigationData*                        _navigationData;                                   // 0x0110(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_ClosestNavMeshLocation">();
	}
	static class UBTService_ClosestNavMeshLocation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_ClosestNavMeshLocation>();
	}
};
static_assert(alignof(UBTService_ClosestNavMeshLocation) == 0x000008, "Wrong alignment on UBTService_ClosestNavMeshLocation");
static_assert(sizeof(UBTService_ClosestNavMeshLocation) == 0x000118, "Wrong size on UBTService_ClosestNavMeshLocation");
static_assert(offsetof(UBTService_ClosestNavMeshLocation, BBAroundLocation) == 0x0000A8, "Member 'UBTService_ClosestNavMeshLocation::BBAroundLocation' has a wrong offset!");
static_assert(offsetof(UBTService_ClosestNavMeshLocation, ValidLocationRefreshInterval) == 0x0000D8, "Member 'UBTService_ClosestNavMeshLocation::ValidLocationRefreshInterval' has a wrong offset!");
static_assert(offsetof(UBTService_ClosestNavMeshLocation, InvalidLocationRefreshInterval) == 0x0000DC, "Member 'UBTService_ClosestNavMeshLocation::InvalidLocationRefreshInterval' has a wrong offset!");
static_assert(offsetof(UBTService_ClosestNavMeshLocation, NavDataAgentName) == 0x0000E0, "Member 'UBTService_ClosestNavMeshLocation::NavDataAgentName' has a wrong offset!");
static_assert(offsetof(UBTService_ClosestNavMeshLocation, NavMeshProjectionBoxExtent) == 0x0000F0, "Member 'UBTService_ClosestNavMeshLocation::NavMeshProjectionBoxExtent' has a wrong offset!");
static_assert(offsetof(UBTService_ClosestNavMeshLocation, _navigationSystem) == 0x000108, "Member 'UBTService_ClosestNavMeshLocation::_navigationSystem' has a wrong offset!");
static_assert(offsetof(UBTService_ClosestNavMeshLocation, _navigationData) == 0x000110, "Member 'UBTService_ClosestNavMeshLocation::_navigationData' has a wrong offset!");

// Class DBDBots.BTService_FindActor_WishList
// 0x0010 (0x0370 - 0x0360)
class UBTService_FindActor_WishList final : public UBTService_FindActor
{
public:
	struct FGameplayTag                           WishListTag;                                       // 0x0360(0x000C)(Edit, DisableEditOnTemplate, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_36C[0x4];                                      // 0x036C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_FindActor_WishList">();
	}
	static class UBTService_FindActor_WishList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_FindActor_WishList>();
	}
};
static_assert(alignof(UBTService_FindActor_WishList) == 0x000008, "Wrong alignment on UBTService_FindActor_WishList");
static_assert(sizeof(UBTService_FindActor_WishList) == 0x000370, "Wrong size on UBTService_FindActor_WishList");
static_assert(offsetof(UBTService_FindActor_WishList, WishListTag) == 0x000360, "Member 'UBTService_FindActor_WishList::WishListTag' has a wrong offset!");

// Class DBDBots.BTService_FindInteractable_Totem
// 0x0028 (0x0340 - 0x0318)
class UBTService_FindInteractable_Totem final : public UBTService_FindInteractable
{
public:
	uint8                                         Pad_318[0x28];                                     // 0x0318(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_FindInteractable_Totem">();
	}
	static class UBTService_FindInteractable_Totem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_FindInteractable_Totem>();
	}
};
static_assert(alignof(UBTService_FindInteractable_Totem) == 0x000008, "Wrong alignment on UBTService_FindInteractable_Totem");
static_assert(sizeof(UBTService_FindInteractable_Totem) == 0x000340, "Wrong size on UBTService_FindInteractable_Totem");

// Class DBDBots.BTService_FindInteractor_Camper
// 0x0320 (0x0978 - 0x0658)
class UBTService_FindInteractor_Camper final : public UBTService_FindInteractor
{
public:
	EFindInteractableCamperFilter                 StatusFilter;                                      // 0x0658(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_659[0x7];                                      // 0x0659(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UStatusEffect>>      IgnoreWhenTargetStatusEffects;                     // 0x0660(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, UObjectWrapper, NativeAccessSpecifierPublic)
	float                                         RequiredAttentionMovementFrequency;                // 0x0670(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttentionMovementFrequencyLerp;                    // 0x0674(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttentionValidTime;                                // 0x0678(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttentionValidDistance;                            // 0x067C(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttentionCooldownReduction;                        // 0x0680(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_684[0x4];                                      // 0x0684(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAITunableParameter                    AllyDangerStateGoalWeight;                         // 0x0688(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    IncapacitatedAlliesGoalWeight;                     // 0x06E8(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    CrawlingRecoveryProgressGoalWeight;                // 0x0748(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    CrawlingDeathTimerGoalWeight;                      // 0x07A8(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    IdealKillerDistanceFromCrawling;                   // 0x0808(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    MaxKillerProximityWeight;                          // 0x0868(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    AttentionWeight;                                   // 0x08C8(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	uint8                                         Pad_928[0x50];                                     // 0x0928(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_FindInteractor_Camper">();
	}
	static class UBTService_FindInteractor_Camper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_FindInteractor_Camper>();
	}
};
static_assert(alignof(UBTService_FindInteractor_Camper) == 0x000008, "Wrong alignment on UBTService_FindInteractor_Camper");
static_assert(sizeof(UBTService_FindInteractor_Camper) == 0x000978, "Wrong size on UBTService_FindInteractor_Camper");
static_assert(offsetof(UBTService_FindInteractor_Camper, StatusFilter) == 0x000658, "Member 'UBTService_FindInteractor_Camper::StatusFilter' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_Camper, IgnoreWhenTargetStatusEffects) == 0x000660, "Member 'UBTService_FindInteractor_Camper::IgnoreWhenTargetStatusEffects' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_Camper, RequiredAttentionMovementFrequency) == 0x000670, "Member 'UBTService_FindInteractor_Camper::RequiredAttentionMovementFrequency' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_Camper, AttentionMovementFrequencyLerp) == 0x000674, "Member 'UBTService_FindInteractor_Camper::AttentionMovementFrequencyLerp' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_Camper, AttentionValidTime) == 0x000678, "Member 'UBTService_FindInteractor_Camper::AttentionValidTime' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_Camper, AttentionValidDistance) == 0x00067C, "Member 'UBTService_FindInteractor_Camper::AttentionValidDistance' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_Camper, AttentionCooldownReduction) == 0x000680, "Member 'UBTService_FindInteractor_Camper::AttentionCooldownReduction' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_Camper, AllyDangerStateGoalWeight) == 0x000688, "Member 'UBTService_FindInteractor_Camper::AllyDangerStateGoalWeight' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_Camper, IncapacitatedAlliesGoalWeight) == 0x0006E8, "Member 'UBTService_FindInteractor_Camper::IncapacitatedAlliesGoalWeight' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_Camper, CrawlingRecoveryProgressGoalWeight) == 0x000748, "Member 'UBTService_FindInteractor_Camper::CrawlingRecoveryProgressGoalWeight' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_Camper, CrawlingDeathTimerGoalWeight) == 0x0007A8, "Member 'UBTService_FindInteractor_Camper::CrawlingDeathTimerGoalWeight' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_Camper, IdealKillerDistanceFromCrawling) == 0x000808, "Member 'UBTService_FindInteractor_Camper::IdealKillerDistanceFromCrawling' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_Camper, MaxKillerProximityWeight) == 0x000868, "Member 'UBTService_FindInteractor_Camper::MaxKillerProximityWeight' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_Camper, AttentionWeight) == 0x0008C8, "Member 'UBTService_FindInteractor_Camper::AttentionWeight' has a wrong offset!");

// Class DBDBots.BTService_FindInteractor_Generator
// 0x01A0 (0x07F8 - 0x0658)
class UBTService_FindInteractor_Generator final : public UBTService_FindInteractor
{
public:
	EFindInteractableGeneratorStatusFilter        StatusFilter;                                      // 0x0658(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_659[0x7];                                      // 0x0659(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAITunableParameter                    MinRepairRatioFilter;                              // 0x0660(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	bool                                          UsePerceptionToGetRepairRatio;                     // 0x06C0(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C1[0x7];                                      // 0x06C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAITunableParameter                    MaxRepairGoalWeight;                               // 0x06C8(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    InfectedStateGoalWeight;                           // 0x0728(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    HexRuinGoalWeight;                                 // 0x0788(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	class FName                                   HexRuinPerkId;                                     // 0x07E8(0x000C)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7F4[0x4];                                      // 0x07F4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_FindInteractor_Generator">();
	}
	static class UBTService_FindInteractor_Generator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_FindInteractor_Generator>();
	}
};
static_assert(alignof(UBTService_FindInteractor_Generator) == 0x000008, "Wrong alignment on UBTService_FindInteractor_Generator");
static_assert(sizeof(UBTService_FindInteractor_Generator) == 0x0007F8, "Wrong size on UBTService_FindInteractor_Generator");
static_assert(offsetof(UBTService_FindInteractor_Generator, StatusFilter) == 0x000658, "Member 'UBTService_FindInteractor_Generator::StatusFilter' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_Generator, MinRepairRatioFilter) == 0x000660, "Member 'UBTService_FindInteractor_Generator::MinRepairRatioFilter' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_Generator, UsePerceptionToGetRepairRatio) == 0x0006C0, "Member 'UBTService_FindInteractor_Generator::UsePerceptionToGetRepairRatio' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_Generator, MaxRepairGoalWeight) == 0x0006C8, "Member 'UBTService_FindInteractor_Generator::MaxRepairGoalWeight' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_Generator, InfectedStateGoalWeight) == 0x000728, "Member 'UBTService_FindInteractor_Generator::InfectedStateGoalWeight' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_Generator, HexRuinGoalWeight) == 0x000788, "Member 'UBTService_FindInteractor_Generator::HexRuinGoalWeight' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_Generator, HexRuinPerkId) == 0x0007E8, "Member 'UBTService_FindInteractor_Generator::HexRuinPerkId' has a wrong offset!");

// Class DBDBots.BTService_FindInteractor_MeatHook
// 0x0460 (0x0AB8 - 0x0658)
class UBTService_FindInteractor_MeatHook final : public UBTService_FindInteractor
{
public:
	EFindInteractableMeatHookStatus               StatusFilter;                                      // 0x0658(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_659[0x3];                                      // 0x0659(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         KeepInteractionValidForTime;                       // 0x065C(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    AllyDangerStateGoalWeight;                         // 0x0660(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    BotDangerStateGoalWeight;                          // 0x06C0(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    BotInjuredStateGoalWeight;                         // 0x0720(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    HumanAllyHookedGoalWeight;                         // 0x0780(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    MaxHookTimeGoalWeight;                             // 0x07E0(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    IncapacitatedAlliesGoalWeight;                     // 0x0840(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    IdealKillerDistanceFromHook;                       // 0x08A0(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    MaxKillerProximityWeight;                          // 0x0900(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    SabotageKillerDistanceToHookScore;                 // 0x0960(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    SabotageKillerSpeedToHookScore;                    // 0x09C0(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    SabotageHookValidTargetTime;                       // 0x0A20(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	float                                         KillerTargetUpdateInterval;                        // 0x0A80(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UnsafeSabotageHealthyMarginTime;                   // 0x0A84(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UnsafeSabotageInjuredMarginTime;                   // 0x0A88(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A8C[0x4];                                      // 0x0A8C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 NoToolboxInteractionID;                            // 0x0A90(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UnsafeCommitDistance;                              // 0x0AA0(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AA4[0x14];                                     // 0x0AA4(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_FindInteractor_MeatHook">();
	}
	static class UBTService_FindInteractor_MeatHook* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_FindInteractor_MeatHook>();
	}
};
static_assert(alignof(UBTService_FindInteractor_MeatHook) == 0x000008, "Wrong alignment on UBTService_FindInteractor_MeatHook");
static_assert(sizeof(UBTService_FindInteractor_MeatHook) == 0x000AB8, "Wrong size on UBTService_FindInteractor_MeatHook");
static_assert(offsetof(UBTService_FindInteractor_MeatHook, StatusFilter) == 0x000658, "Member 'UBTService_FindInteractor_MeatHook::StatusFilter' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_MeatHook, KeepInteractionValidForTime) == 0x00065C, "Member 'UBTService_FindInteractor_MeatHook::KeepInteractionValidForTime' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_MeatHook, AllyDangerStateGoalWeight) == 0x000660, "Member 'UBTService_FindInteractor_MeatHook::AllyDangerStateGoalWeight' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_MeatHook, BotDangerStateGoalWeight) == 0x0006C0, "Member 'UBTService_FindInteractor_MeatHook::BotDangerStateGoalWeight' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_MeatHook, BotInjuredStateGoalWeight) == 0x000720, "Member 'UBTService_FindInteractor_MeatHook::BotInjuredStateGoalWeight' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_MeatHook, HumanAllyHookedGoalWeight) == 0x000780, "Member 'UBTService_FindInteractor_MeatHook::HumanAllyHookedGoalWeight' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_MeatHook, MaxHookTimeGoalWeight) == 0x0007E0, "Member 'UBTService_FindInteractor_MeatHook::MaxHookTimeGoalWeight' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_MeatHook, IncapacitatedAlliesGoalWeight) == 0x000840, "Member 'UBTService_FindInteractor_MeatHook::IncapacitatedAlliesGoalWeight' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_MeatHook, IdealKillerDistanceFromHook) == 0x0008A0, "Member 'UBTService_FindInteractor_MeatHook::IdealKillerDistanceFromHook' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_MeatHook, MaxKillerProximityWeight) == 0x000900, "Member 'UBTService_FindInteractor_MeatHook::MaxKillerProximityWeight' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_MeatHook, SabotageKillerDistanceToHookScore) == 0x000960, "Member 'UBTService_FindInteractor_MeatHook::SabotageKillerDistanceToHookScore' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_MeatHook, SabotageKillerSpeedToHookScore) == 0x0009C0, "Member 'UBTService_FindInteractor_MeatHook::SabotageKillerSpeedToHookScore' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_MeatHook, SabotageHookValidTargetTime) == 0x000A20, "Member 'UBTService_FindInteractor_MeatHook::SabotageHookValidTargetTime' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_MeatHook, KillerTargetUpdateInterval) == 0x000A80, "Member 'UBTService_FindInteractor_MeatHook::KillerTargetUpdateInterval' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_MeatHook, UnsafeSabotageHealthyMarginTime) == 0x000A84, "Member 'UBTService_FindInteractor_MeatHook::UnsafeSabotageHealthyMarginTime' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_MeatHook, UnsafeSabotageInjuredMarginTime) == 0x000A88, "Member 'UBTService_FindInteractor_MeatHook::UnsafeSabotageInjuredMarginTime' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_MeatHook, NoToolboxInteractionID) == 0x000A90, "Member 'UBTService_FindInteractor_MeatHook::NoToolboxInteractionID' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_MeatHook, UnsafeCommitDistance) == 0x000AA0, "Member 'UBTService_FindInteractor_MeatHook::UnsafeCommitDistance' has a wrong offset!");

// Class DBDBots.BTService_FindInteractor_Searchable
// 0x0080 (0x06D8 - 0x0658)
class UBTService_FindInteractor_Searchable final : public UBTService_FindInteractor
{
public:
	struct FAITunableParameter                    WantToKeepEmptyItemPenalty;                        // 0x0658(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FAIPerkTunableWeightArray              GoalPerkWeight;                                    // 0x06B8(0x0010)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FAIHasPerkConditionArray               CanSearchWhileHoldingItemConditions;               // 0x06C8(0x0010)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_FindInteractor_Searchable">();
	}
	static class UBTService_FindInteractor_Searchable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_FindInteractor_Searchable>();
	}
};
static_assert(alignof(UBTService_FindInteractor_Searchable) == 0x000008, "Wrong alignment on UBTService_FindInteractor_Searchable");
static_assert(sizeof(UBTService_FindInteractor_Searchable) == 0x0006D8, "Wrong size on UBTService_FindInteractor_Searchable");
static_assert(offsetof(UBTService_FindInteractor_Searchable, WantToKeepEmptyItemPenalty) == 0x000658, "Member 'UBTService_FindInteractor_Searchable::WantToKeepEmptyItemPenalty' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_Searchable, GoalPerkWeight) == 0x0006B8, "Member 'UBTService_FindInteractor_Searchable::GoalPerkWeight' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_Searchable, CanSearchWhileHoldingItemConditions) == 0x0006C8, "Member 'UBTService_FindInteractor_Searchable::CanSearchWhileHoldingItemConditions' has a wrong offset!");

// Class DBDBots.BTService_FindInteractor_Self
// 0x0140 (0x0798 - 0x0658)
class UBTService_FindInteractor_Self final : public UBTService_FindInteractor
{
public:
	struct FBlackboardKeySelector                 BBInputType;                                       // 0x0658(0x0030)(Edit, DisableEditOnTemplate, Protected, NativeAccessSpecifierProtected)
	struct FBlackboardKeySelector                 BBIsSkillSelfInteraction;                          // 0x0688(0x0030)(Edit, DisableEditOnTemplate, Protected, NativeAccessSpecifierProtected)
	TArray<struct FAISelfHelpInteraction>         SelfHelpInteractions;                              // 0x06B8(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTag                           SelfInteractionContext;                            // 0x06C8(0x000C)(Edit, DisableEditOnTemplate, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SurvivorProximityRange;                            // 0x06D4(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FAITunableParameter                    SurvivorProximityWeightPenalty;                    // 0x06D8(0x0060)(Edit, DisableEditOnTemplate, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_738[0x60];                                     // 0x0738(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_FindInteractor_Self">();
	}
	static class UBTService_FindInteractor_Self* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_FindInteractor_Self>();
	}
};
static_assert(alignof(UBTService_FindInteractor_Self) == 0x000008, "Wrong alignment on UBTService_FindInteractor_Self");
static_assert(sizeof(UBTService_FindInteractor_Self) == 0x000798, "Wrong size on UBTService_FindInteractor_Self");
static_assert(offsetof(UBTService_FindInteractor_Self, BBInputType) == 0x000658, "Member 'UBTService_FindInteractor_Self::BBInputType' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_Self, BBIsSkillSelfInteraction) == 0x000688, "Member 'UBTService_FindInteractor_Self::BBIsSkillSelfInteraction' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_Self, SelfHelpInteractions) == 0x0006B8, "Member 'UBTService_FindInteractor_Self::SelfHelpInteractions' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_Self, SelfInteractionContext) == 0x0006C8, "Member 'UBTService_FindInteractor_Self::SelfInteractionContext' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_Self, SurvivorProximityRange) == 0x0006D4, "Member 'UBTService_FindInteractor_Self::SurvivorProximityRange' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_Self, SurvivorProximityWeightPenalty) == 0x0006D8, "Member 'UBTService_FindInteractor_Self::SurvivorProximityWeightPenalty' has a wrong offset!");

// Class DBDBots.BTService_FindInteractor_Trap
// 0x0140 (0x0798 - 0x0658)
class UBTService_FindInteractor_Trap final : public UBTService_FindInteractor
{
public:
	struct FAITunableParameter                    HelpDestroyDemoPortal;                             // 0x0658(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FAIRoll                                SeeStandardTrapRoll;                               // 0x06B8(0x00C8)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         TrapGroundLocationOffset;                          // 0x0780(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_784[0x4];                                      // 0x0784(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FInteractableWithInteractionId> InteractableOnlyWithInteractionId;                 // 0x0788(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_FindInteractor_Trap">();
	}
	static class UBTService_FindInteractor_Trap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_FindInteractor_Trap>();
	}
};
static_assert(alignof(UBTService_FindInteractor_Trap) == 0x000008, "Wrong alignment on UBTService_FindInteractor_Trap");
static_assert(sizeof(UBTService_FindInteractor_Trap) == 0x000798, "Wrong size on UBTService_FindInteractor_Trap");
static_assert(offsetof(UBTService_FindInteractor_Trap, HelpDestroyDemoPortal) == 0x000658, "Member 'UBTService_FindInteractor_Trap::HelpDestroyDemoPortal' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_Trap, SeeStandardTrapRoll) == 0x0006B8, "Member 'UBTService_FindInteractor_Trap::SeeStandardTrapRoll' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_Trap, TrapGroundLocationOffset) == 0x000780, "Member 'UBTService_FindInteractor_Trap::TrapGroundLocationOffset' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_Trap, InteractableOnlyWithInteractionId) == 0x000788, "Member 'UBTService_FindInteractor_Trap::InteractableOnlyWithInteractionId' has a wrong offset!");

// Class DBDBots.BTService_FindInteractor_WishList
// 0x0018 (0x0670 - 0x0658)
class UBTService_FindInteractor_WishList final : public UBTService_FindInteractor
{
public:
	struct FGameplayTag                           WishListTag;                                       // 0x0658(0x000C)(Edit, DisableEditOnTemplate, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_664[0xC];                                      // 0x0664(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_FindInteractor_WishList">();
	}
	static class UBTService_FindInteractor_WishList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_FindInteractor_WishList>();
	}
};
static_assert(alignof(UBTService_FindInteractor_WishList) == 0x000008, "Wrong alignment on UBTService_FindInteractor_WishList");
static_assert(sizeof(UBTService_FindInteractor_WishList) == 0x000670, "Wrong size on UBTService_FindInteractor_WishList");
static_assert(offsetof(UBTService_FindInteractor_WishList, WishListTag) == 0x000658, "Member 'UBTService_FindInteractor_WishList::WishListTag' has a wrong offset!");

// Class DBDBots.BTService_FindObject_DangerObject
// 0x01B8 (0x03D8 - 0x0220)
class UBTService_FindObject_DangerObject final : public UBTService_FindObject
{
public:
	bool                                          GetDangerObjectsFromHostileStimulus;               // 0x0220(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_221[0x3];                                      // 0x0221(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HideFromLosCooldown;                               // 0x0224(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    NotSensedReactionDelay;                            // 0x0228(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    SensedReactionDelay;                               // 0x0288(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBIsInChase;                                       // 0x02E8(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBIsInPressureZone;                                // 0x0318(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBIgnoreDangerObjects;                             // 0x0348(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	uint8                                         Pad_378[0x10];                                     // 0x0378(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class UDBDDangerPredictionComponent*, struct FDangerObjectData> _lastDangerObjectsMap;                             // 0x0388(0x0050)(Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_FindObject_DangerObject">();
	}
	static class UBTService_FindObject_DangerObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_FindObject_DangerObject>();
	}
};
static_assert(alignof(UBTService_FindObject_DangerObject) == 0x000008, "Wrong alignment on UBTService_FindObject_DangerObject");
static_assert(sizeof(UBTService_FindObject_DangerObject) == 0x0003D8, "Wrong size on UBTService_FindObject_DangerObject");
static_assert(offsetof(UBTService_FindObject_DangerObject, GetDangerObjectsFromHostileStimulus) == 0x000220, "Member 'UBTService_FindObject_DangerObject::GetDangerObjectsFromHostileStimulus' has a wrong offset!");
static_assert(offsetof(UBTService_FindObject_DangerObject, HideFromLosCooldown) == 0x000224, "Member 'UBTService_FindObject_DangerObject::HideFromLosCooldown' has a wrong offset!");
static_assert(offsetof(UBTService_FindObject_DangerObject, NotSensedReactionDelay) == 0x000228, "Member 'UBTService_FindObject_DangerObject::NotSensedReactionDelay' has a wrong offset!");
static_assert(offsetof(UBTService_FindObject_DangerObject, SensedReactionDelay) == 0x000288, "Member 'UBTService_FindObject_DangerObject::SensedReactionDelay' has a wrong offset!");
static_assert(offsetof(UBTService_FindObject_DangerObject, BBIsInChase) == 0x0002E8, "Member 'UBTService_FindObject_DangerObject::BBIsInChase' has a wrong offset!");
static_assert(offsetof(UBTService_FindObject_DangerObject, BBIsInPressureZone) == 0x000318, "Member 'UBTService_FindObject_DangerObject::BBIsInPressureZone' has a wrong offset!");
static_assert(offsetof(UBTService_FindObject_DangerObject, BBIgnoreDangerObjects) == 0x000348, "Member 'UBTService_FindObject_DangerObject::BBIgnoreDangerObjects' has a wrong offset!");
static_assert(offsetof(UBTService_FindObject_DangerObject, _lastDangerObjectsMap) == 0x000388, "Member 'UBTService_FindObject_DangerObject::_lastDangerObjectsMap' has a wrong offset!");

// Class DBDBots.BTService_Find_Character
// 0x0048 (0x00C0 - 0x0078)
class UBTService_Find_Character final : public UBTService
{
public:
	EPawnType                                     CharacterFilter;                                   // 0x0078(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EKillerAbilities                              KillerAbility;                                     // 0x0079(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7A[0x6];                                       // 0x007A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlackboardKeySelector                 BBCharacterLocation;                               // 0x0080(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	class ADBDAIBTController*                     _aiOwner;                                          // 0x00B0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_Find_Character">();
	}
	static class UBTService_Find_Character* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_Find_Character>();
	}
};
static_assert(alignof(UBTService_Find_Character) == 0x000008, "Wrong alignment on UBTService_Find_Character");
static_assert(sizeof(UBTService_Find_Character) == 0x0000C0, "Wrong size on UBTService_Find_Character");
static_assert(offsetof(UBTService_Find_Character, CharacterFilter) == 0x000078, "Member 'UBTService_Find_Character::CharacterFilter' has a wrong offset!");
static_assert(offsetof(UBTService_Find_Character, KillerAbility) == 0x000079, "Member 'UBTService_Find_Character::KillerAbility' has a wrong offset!");
static_assert(offsetof(UBTService_Find_Character, BBCharacterLocation) == 0x000080, "Member 'UBTService_Find_Character::BBCharacterLocation' has a wrong offset!");
static_assert(offsetof(UBTService_Find_Character, _aiOwner) == 0x0000B0, "Member 'UBTService_Find_Character::_aiOwner' has a wrong offset!");

// Class DBDBots.BTService_GetPinLocation
// 0x0040 (0x00C0 - 0x0080)
class UBTService_GetPinLocation final : public UBTService_OnRelevantBase
{
public:
	struct FBlackboardKeySelector                 BBToSetKey;                                        // 0x0080(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FGameplayTag                           PinTag;                                            // 0x00B0(0x000C)(Edit, DisableEditOnTemplate, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_GetPinLocation">();
	}
	static class UBTService_GetPinLocation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_GetPinLocation>();
	}
};
static_assert(alignof(UBTService_GetPinLocation) == 0x000008, "Wrong alignment on UBTService_GetPinLocation");
static_assert(sizeof(UBTService_GetPinLocation) == 0x0000C0, "Wrong size on UBTService_GetPinLocation");
static_assert(offsetof(UBTService_GetPinLocation, BBToSetKey) == 0x000080, "Member 'UBTService_GetPinLocation::BBToSetKey' has a wrong offset!");
static_assert(offsetof(UBTService_GetPinLocation, PinTag) == 0x0000B0, "Member 'UBTService_GetPinLocation::PinTag' has a wrong offset!");

// Class DBDBots.BTService_GetPinObject
// 0x0040 (0x00C0 - 0x0080)
class UBTService_GetPinObject final : public UBTService_OnRelevantBase
{
public:
	struct FBlackboardKeySelector                 BBToSetKey;                                        // 0x0080(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FGameplayTag                           PinTag;                                            // 0x00B0(0x000C)(Edit, DisableEditOnTemplate, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_GetPinObject">();
	}
	static class UBTService_GetPinObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_GetPinObject>();
	}
};
static_assert(alignof(UBTService_GetPinObject) == 0x000008, "Wrong alignment on UBTService_GetPinObject");
static_assert(sizeof(UBTService_GetPinObject) == 0x0000C0, "Wrong size on UBTService_GetPinObject");
static_assert(offsetof(UBTService_GetPinObject, BBToSetKey) == 0x000080, "Member 'UBTService_GetPinObject::BBToSetKey' has a wrong offset!");
static_assert(offsetof(UBTService_GetPinObject, PinTag) == 0x0000B0, "Member 'UBTService_GetPinObject::PinTag' has a wrong offset!");

// Class DBDBots.BTService_GoalCoordinator
// 0x00F8 (0x0170 - 0x0078)
class UBTService_GoalCoordinator final : public UBTService
{
public:
	struct FAITunableParameter                    GoalChangeWeightBuffer;                            // 0x0078(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBLockedIntoGoal;                                  // 0x00D8(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AISkillFindContext;                                // 0x0108(0x000C)(Edit, DisableEditOnTemplate, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_114[0xC];                                      // 0x0114(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class UObject*, struct FAIGoalWeightContainer> _managedGoals;                                     // 0x0120(0x0050)(Transient, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_GoalCoordinator">();
	}
	static class UBTService_GoalCoordinator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_GoalCoordinator>();
	}
};
static_assert(alignof(UBTService_GoalCoordinator) == 0x000008, "Wrong alignment on UBTService_GoalCoordinator");
static_assert(sizeof(UBTService_GoalCoordinator) == 0x000170, "Wrong size on UBTService_GoalCoordinator");
static_assert(offsetof(UBTService_GoalCoordinator, GoalChangeWeightBuffer) == 0x000078, "Member 'UBTService_GoalCoordinator::GoalChangeWeightBuffer' has a wrong offset!");
static_assert(offsetof(UBTService_GoalCoordinator, BBLockedIntoGoal) == 0x0000D8, "Member 'UBTService_GoalCoordinator::BBLockedIntoGoal' has a wrong offset!");
static_assert(offsetof(UBTService_GoalCoordinator, AISkillFindContext) == 0x000108, "Member 'UBTService_GoalCoordinator::AISkillFindContext' has a wrong offset!");
static_assert(offsetof(UBTService_GoalCoordinator, _managedGoals) == 0x000120, "Member 'UBTService_GoalCoordinator::_managedGoals' has a wrong offset!");

// Class DBDBots.BTService_Patrol
// 0x00F0 (0x0168 - 0x0078)
class UBTService_Patrol : public UBTService
{
public:
	struct FBlackboardKeySelector                 BBFilterKey;                                       // 0x0078(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	EBasicKeyOperation                            FilterOperation;                                   // 0x00A8(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                NavMeshFindLocationExtents;                        // 0x00B0(0x0018)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinPatrolInvestigationDistance;                    // 0x00C8(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PatrolPointsValidityCheckInterval;                 // 0x00CC(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBPatrolPointOwner;                                // 0x00D0(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBPatrolLocation;                                  // 0x0100(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBGoToNextPatrolLocation;                          // 0x0130(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	uint8                                         Pad_160[0x8];                                      // 0x0160(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_Patrol">();
	}
	static class UBTService_Patrol* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_Patrol>();
	}
};
static_assert(alignof(UBTService_Patrol) == 0x000008, "Wrong alignment on UBTService_Patrol");
static_assert(sizeof(UBTService_Patrol) == 0x000168, "Wrong size on UBTService_Patrol");
static_assert(offsetof(UBTService_Patrol, BBFilterKey) == 0x000078, "Member 'UBTService_Patrol::BBFilterKey' has a wrong offset!");
static_assert(offsetof(UBTService_Patrol, FilterOperation) == 0x0000A8, "Member 'UBTService_Patrol::FilterOperation' has a wrong offset!");
static_assert(offsetof(UBTService_Patrol, NavMeshFindLocationExtents) == 0x0000B0, "Member 'UBTService_Patrol::NavMeshFindLocationExtents' has a wrong offset!");
static_assert(offsetof(UBTService_Patrol, MinPatrolInvestigationDistance) == 0x0000C8, "Member 'UBTService_Patrol::MinPatrolInvestigationDistance' has a wrong offset!");
static_assert(offsetof(UBTService_Patrol, PatrolPointsValidityCheckInterval) == 0x0000CC, "Member 'UBTService_Patrol::PatrolPointsValidityCheckInterval' has a wrong offset!");
static_assert(offsetof(UBTService_Patrol, BBPatrolPointOwner) == 0x0000D0, "Member 'UBTService_Patrol::BBPatrolPointOwner' has a wrong offset!");
static_assert(offsetof(UBTService_Patrol, BBPatrolLocation) == 0x000100, "Member 'UBTService_Patrol::BBPatrolLocation' has a wrong offset!");
static_assert(offsetof(UBTService_Patrol, BBGoToNextPatrolLocation) == 0x000130, "Member 'UBTService_Patrol::BBGoToNextPatrolLocation' has a wrong offset!");

// Class DBDBots.BTService_Patrol_Discovery
// 0x0010 (0x0178 - 0x0168)
class UBTService_Patrol_Discovery final : public UBTService_Patrol
{
public:
	bool                                          RejectPatrolPointIfInPressureZone;                 // 0x0168(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_169[0x3];                                      // 0x0169(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxFindRandomLocationOnTileAttempts;               // 0x016C(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FirstFindOnNbNeighborTiles;                        // 0x0170(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_174[0x4];                                      // 0x0174(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_Patrol_Discovery">();
	}
	static class UBTService_Patrol_Discovery* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_Patrol_Discovery>();
	}
};
static_assert(alignof(UBTService_Patrol_Discovery) == 0x000008, "Wrong alignment on UBTService_Patrol_Discovery");
static_assert(sizeof(UBTService_Patrol_Discovery) == 0x000178, "Wrong size on UBTService_Patrol_Discovery");
static_assert(offsetof(UBTService_Patrol_Discovery, RejectPatrolPointIfInPressureZone) == 0x000168, "Member 'UBTService_Patrol_Discovery::RejectPatrolPointIfInPressureZone' has a wrong offset!");
static_assert(offsetof(UBTService_Patrol_Discovery, MaxFindRandomLocationOnTileAttempts) == 0x00016C, "Member 'UBTService_Patrol_Discovery::MaxFindRandomLocationOnTileAttempts' has a wrong offset!");
static_assert(offsetof(UBTService_Patrol_Discovery, FirstFindOnNbNeighborTiles) == 0x000170, "Member 'UBTService_Patrol_Discovery::FirstFindOnNbNeighborTiles' has a wrong offset!");

// Class DBDBots.BTService_Patrol_PointOfInterest
// 0x0040 (0x01A8 - 0x0168)
class UBTService_Patrol_PointOfInterest final : public UBTService_Patrol
{
public:
	float                                         OnEnterPatrolRefreshPointsDelay;                   // 0x0168(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16C[0x4];                                      // 0x016C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlackboardKeySelector                 BBMoveAroundPatrolLocation;                        // 0x0170(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	float                                         MoveAroundPatrolPointAboveStimulusStrength;        // 0x01A0(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A4[0x4];                                      // 0x01A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_Patrol_PointOfInterest">();
	}
	static class UBTService_Patrol_PointOfInterest* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_Patrol_PointOfInterest>();
	}
};
static_assert(alignof(UBTService_Patrol_PointOfInterest) == 0x000008, "Wrong alignment on UBTService_Patrol_PointOfInterest");
static_assert(sizeof(UBTService_Patrol_PointOfInterest) == 0x0001A8, "Wrong size on UBTService_Patrol_PointOfInterest");
static_assert(offsetof(UBTService_Patrol_PointOfInterest, OnEnterPatrolRefreshPointsDelay) == 0x000168, "Member 'UBTService_Patrol_PointOfInterest::OnEnterPatrolRefreshPointsDelay' has a wrong offset!");
static_assert(offsetof(UBTService_Patrol_PointOfInterest, BBMoveAroundPatrolLocation) == 0x000170, "Member 'UBTService_Patrol_PointOfInterest::BBMoveAroundPatrolLocation' has a wrong offset!");
static_assert(offsetof(UBTService_Patrol_PointOfInterest, MoveAroundPatrolPointAboveStimulusStrength) == 0x0001A0, "Member 'UBTService_Patrol_PointOfInterest::MoveAroundPatrolPointAboveStimulusStrength' has a wrong offset!");

// Class DBDBots.BTService_RunSkills
// 0x0048 (0x00C0 - 0x0078)
class UBTService_RunSkills final : public UBTService
{
public:
	struct FGameplayTag                           Context;                                           // 0x0078(0x000C)(Edit, DisableEditOnTemplate, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_84[0x4];                                       // 0x0084(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlackboardKeySelector                 BBFilterKey;                                       // 0x0088(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	EBasicKeyOperation                            FilterOperation;                                   // 0x00B8(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RunEveryFrame;                                     // 0x00B9(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BA[0x6];                                       // 0x00BA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_RunSkills">();
	}
	static class UBTService_RunSkills* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_RunSkills>();
	}
};
static_assert(alignof(UBTService_RunSkills) == 0x000008, "Wrong alignment on UBTService_RunSkills");
static_assert(sizeof(UBTService_RunSkills) == 0x0000C0, "Wrong size on UBTService_RunSkills");
static_assert(offsetof(UBTService_RunSkills, Context) == 0x000078, "Member 'UBTService_RunSkills::Context' has a wrong offset!");
static_assert(offsetof(UBTService_RunSkills, BBFilterKey) == 0x000088, "Member 'UBTService_RunSkills::BBFilterKey' has a wrong offset!");
static_assert(offsetof(UBTService_RunSkills, FilterOperation) == 0x0000B8, "Member 'UBTService_RunSkills::FilterOperation' has a wrong offset!");
static_assert(offsetof(UBTService_RunSkills, RunEveryFrame) == 0x0000B9, "Member 'UBTService_RunSkills::RunEveryFrame' has a wrong offset!");

// Class DBDBots.BTService_SetBBEntry
// 0x00A0 (0x0120 - 0x0080)
class UBTService_SetBBEntry final : public UBTService_OnRelevantBase
{
public:
	struct FBlackboardKeySelector                 BBToSetKey;                                        // 0x0080(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	class FString                                 ToSetValue;                                        // 0x00B0(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    RandomSetChance;                                   // 0x00C0(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_SetBBEntry">();
	}
	static class UBTService_SetBBEntry* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_SetBBEntry>();
	}
};
static_assert(alignof(UBTService_SetBBEntry) == 0x000008, "Wrong alignment on UBTService_SetBBEntry");
static_assert(sizeof(UBTService_SetBBEntry) == 0x000120, "Wrong size on UBTService_SetBBEntry");
static_assert(offsetof(UBTService_SetBBEntry, BBToSetKey) == 0x000080, "Member 'UBTService_SetBBEntry::BBToSetKey' has a wrong offset!");
static_assert(offsetof(UBTService_SetBBEntry, ToSetValue) == 0x0000B0, "Member 'UBTService_SetBBEntry::ToSetValue' has a wrong offset!");
static_assert(offsetof(UBTService_SetBBEntry, RandomSetChance) == 0x0000C0, "Member 'UBTService_SetBBEntry::RandomSetChance' has a wrong offset!");

// Class DBDBots.BTService_SetBBEntryTime
// 0x0030 (0x00B0 - 0x0080)
class UBTService_SetBBEntryTime final : public UBTService_OnRelevantBase
{
public:
	struct FBlackboardKeySelector                 BBToSetKey;                                        // 0x0080(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_SetBBEntryTime">();
	}
	static class UBTService_SetBBEntryTime* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_SetBBEntryTime>();
	}
};
static_assert(alignof(UBTService_SetBBEntryTime) == 0x000008, "Wrong alignment on UBTService_SetBBEntryTime");
static_assert(sizeof(UBTService_SetBBEntryTime) == 0x0000B0, "Wrong size on UBTService_SetBBEntryTime");
static_assert(offsetof(UBTService_SetBBEntryTime, BBToSetKey) == 0x000080, "Member 'UBTService_SetBBEntryTime::BBToSetKey' has a wrong offset!");

// Class DBDBots.BTService_SetFocusCooldown
// 0x0048 (0x00C8 - 0x0080)
class UBTService_SetFocusCooldown final : public UBTService_OnRelevantBase
{
public:
	struct FBlackboardKeySelector                 BBOnObject;                                        // 0x0080(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	class FName                                   ContextName;                                       // 0x00B0(0x000C)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InfiniteDuration;                                  // 0x00BC(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BD[0x3];                                       // 0x00BD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Duration;                                          // 0x00C0(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C4[0x4];                                       // 0x00C4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_SetFocusCooldown">();
	}
	static class UBTService_SetFocusCooldown* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_SetFocusCooldown>();
	}
};
static_assert(alignof(UBTService_SetFocusCooldown) == 0x000008, "Wrong alignment on UBTService_SetFocusCooldown");
static_assert(sizeof(UBTService_SetFocusCooldown) == 0x0000C8, "Wrong size on UBTService_SetFocusCooldown");
static_assert(offsetof(UBTService_SetFocusCooldown, BBOnObject) == 0x000080, "Member 'UBTService_SetFocusCooldown::BBOnObject' has a wrong offset!");
static_assert(offsetof(UBTService_SetFocusCooldown, ContextName) == 0x0000B0, "Member 'UBTService_SetFocusCooldown::ContextName' has a wrong offset!");
static_assert(offsetof(UBTService_SetFocusCooldown, InfiniteDuration) == 0x0000BC, "Member 'UBTService_SetFocusCooldown::InfiniteDuration' has a wrong offset!");
static_assert(offsetof(UBTService_SetFocusCooldown, Duration) == 0x0000C0, "Member 'UBTService_SetFocusCooldown::Duration' has a wrong offset!");

// Class DBDBots.BTService_SetMovementConversion
// 0x0008 (0x0080 - 0x0078)
class UBTService_SetMovementConversion final : public UBTService
{
public:
	ECharacterMovementTypes                       FromMovementMode;                                  // 0x0078(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECharacterMovementTypes                       ToMovementMode;                                    // 0x0079(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAIMovementPriority                           ApplyOrder;                                        // 0x007A(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7B[0x5];                                       // 0x007B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_SetMovementConversion">();
	}
	static class UBTService_SetMovementConversion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_SetMovementConversion>();
	}
};
static_assert(alignof(UBTService_SetMovementConversion) == 0x000008, "Wrong alignment on UBTService_SetMovementConversion");
static_assert(sizeof(UBTService_SetMovementConversion) == 0x000080, "Wrong size on UBTService_SetMovementConversion");
static_assert(offsetof(UBTService_SetMovementConversion, FromMovementMode) == 0x000078, "Member 'UBTService_SetMovementConversion::FromMovementMode' has a wrong offset!");
static_assert(offsetof(UBTService_SetMovementConversion, ToMovementMode) == 0x000079, "Member 'UBTService_SetMovementConversion::ToMovementMode' has a wrong offset!");
static_assert(offsetof(UBTService_SetMovementConversion, ApplyOrder) == 0x00007A, "Member 'UBTService_SetMovementConversion::ApplyOrder' has a wrong offset!");

// Class DBDBots.BTService_SetMovementMode
// 0x0008 (0x0080 - 0x0078)
class UBTService_SetMovementMode final : public UBTService
{
public:
	ECharacterMovementTypes                       OnEnterMovementMode;                               // 0x0078(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECharacterMovementTypes                       OnExitMovementMode;                                // 0x0079(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7A[0x6];                                       // 0x007A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_SetMovementMode">();
	}
	static class UBTService_SetMovementMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_SetMovementMode>();
	}
};
static_assert(alignof(UBTService_SetMovementMode) == 0x000008, "Wrong alignment on UBTService_SetMovementMode");
static_assert(sizeof(UBTService_SetMovementMode) == 0x000080, "Wrong size on UBTService_SetMovementMode");
static_assert(offsetof(UBTService_SetMovementMode, OnEnterMovementMode) == 0x000078, "Member 'UBTService_SetMovementMode::OnEnterMovementMode' has a wrong offset!");
static_assert(offsetof(UBTService_SetMovementMode, OnExitMovementMode) == 0x000079, "Member 'UBTService_SetMovementMode::OnExitMovementMode' has a wrong offset!");

// Class DBDBots.BTService_SetTagCooldown
// 0x0018 (0x0098 - 0x0080)
class UBTService_SetTagCooldown final : public UBTService_OnRelevantBase
{
public:
	struct FGameplayTag                           CooldownTag;                                       // 0x0080(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CooldownDuration;                                  // 0x008C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAddToExistingDuration;                            // 0x0090(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_SetTagCooldown">();
	}
	static class UBTService_SetTagCooldown* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_SetTagCooldown>();
	}
};
static_assert(alignof(UBTService_SetTagCooldown) == 0x000008, "Wrong alignment on UBTService_SetTagCooldown");
static_assert(sizeof(UBTService_SetTagCooldown) == 0x000098, "Wrong size on UBTService_SetTagCooldown");
static_assert(offsetof(UBTService_SetTagCooldown, CooldownTag) == 0x000080, "Member 'UBTService_SetTagCooldown::CooldownTag' has a wrong offset!");
static_assert(offsetof(UBTService_SetTagCooldown, CooldownDuration) == 0x00008C, "Member 'UBTService_SetTagCooldown::CooldownDuration' has a wrong offset!");
static_assert(offsetof(UBTService_SetTagCooldown, bAddToExistingDuration) == 0x000090, "Member 'UBTService_SetTagCooldown::bAddToExistingDuration' has a wrong offset!");

// Class DBDBots.BTService_StateMonitor_Camper
// 0x0C80 (0x0D58 - 0x00D8)
class UBTService_StateMonitor_Camper final : public UBTService_StateMonitor
{
public:
	struct FBlackboardKeySelector                 BBDamageState;                                     // 0x00D8(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBImmoblizedState;                                 // 0x0108(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBGuidedState;                                     // 0x0138(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBEscapedState;                                    // 0x0168(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBIsInInjuredBleedout;                             // 0x0198(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBDyingTimerPercentLeft;                           // 0x01C8(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBHookTimerPercentLeft;                            // 0x01F8(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBHookDrainStage;                                  // 0x0228(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBItemType;                                        // 0x0258(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBItemCharge;                                      // 0x0288(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBIsHoldingEmptyItem;                              // 0x02B8(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBSpecialItemID;                                   // 0x02E8(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBIsChased;                                        // 0x0318(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBWasInStimulusSight;                              // 0x0348(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBWasBeingAimedAt;                                 // 0x0378(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBIsBeingAimedAt;                                  // 0x03A8(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBIsBeingAttacked;                                 // 0x03D8(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBIsChained;                                       // 0x0408(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBIsInPressureZone;                                // 0x0438(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBIsInActivatedRBT;                                // 0x0468(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBIsInDeathTimer;                                  // 0x0498(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBHasCrowAttached;                                 // 0x04C8(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBLastTrapSideStepExpirationTime;                  // 0x04F8(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBLastAskedToMoveTime;                             // 0x0528(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBPreventDroppingEmptyItems;                       // 0x0558(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBIgnoreGoalPressure;                              // 0x0588(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	float                                         EmptyItemChargeThreshold;                          // 0x05B8(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeathTimerEndGamePercent;                          // 0x05BC(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChaseUnseenMinimumKillerRange;                     // 0x05C0(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChaseSeenMinimumKillerRange;                       // 0x05C4(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChasedMinimumScore;                                // 0x05C8(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeightAmplifier;                                   // 0x05CC(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeightAmplifierActivationHeight;                   // 0x05D0(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D4[0x4];                                      // 0x05D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAITunableParameter                    ChasedScoreKillerAtMinimumDistance;                // 0x05D8(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    ChasedScoreKillerDistanceMaxRange;                 // 0x0638(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    ChasedScoreKillerWhenUnknownLocation;              // 0x0698(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    ChasedScorePredictedTarget;                        // 0x06F8(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    ChasedScoreKillerLastKnownDirection;               // 0x0758(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    ChasedScoreKillerMaxDirectionAngle;                // 0x07B8(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    ChasedScoreSurvivorWhenVisible;                    // 0x0818(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    ChasedScoreSurvivorVisibilityTime;                 // 0x0878(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    ChasedScoreKillerUndetectable;                     // 0x08D8(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    ChasedScoreKillerRangedAndDash;                    // 0x0938(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    ChasedScoreKillerChaseTarget;                      // 0x0998(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    PressureScoreDistanceWhenUnknownLocation;          // 0x09F8(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    PressureScorePredictedTargetMultiplier;            // 0x0A58(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    PressureScoreKillerMaxDirectionAngle;              // 0x0AB8(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    PressureScoreKillerDirectionMaxMultiplier;         // 0x0B18(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    PressureScoreSurvivorVisibilityTime;               // 0x0B78(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    PressureScoreMaxMultiplierWhenSurvivorVisible;     // 0x0BD8(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    PressureScoreKillerRangedAndDashDistancePenalty;   // 0x0C38(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    PressureScoreChaseTargetMultiplier;                // 0x0C98(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    PressureScoreMaxScore;                             // 0x0CF8(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_StateMonitor_Camper">();
	}
	static class UBTService_StateMonitor_Camper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_StateMonitor_Camper>();
	}
};
static_assert(alignof(UBTService_StateMonitor_Camper) == 0x000008, "Wrong alignment on UBTService_StateMonitor_Camper");
static_assert(sizeof(UBTService_StateMonitor_Camper) == 0x000D58, "Wrong size on UBTService_StateMonitor_Camper");
static_assert(offsetof(UBTService_StateMonitor_Camper, BBDamageState) == 0x0000D8, "Member 'UBTService_StateMonitor_Camper::BBDamageState' has a wrong offset!");
static_assert(offsetof(UBTService_StateMonitor_Camper, BBImmoblizedState) == 0x000108, "Member 'UBTService_StateMonitor_Camper::BBImmoblizedState' has a wrong offset!");
static_assert(offsetof(UBTService_StateMonitor_Camper, BBGuidedState) == 0x000138, "Member 'UBTService_StateMonitor_Camper::BBGuidedState' has a wrong offset!");
static_assert(offsetof(UBTService_StateMonitor_Camper, BBEscapedState) == 0x000168, "Member 'UBTService_StateMonitor_Camper::BBEscapedState' has a wrong offset!");
static_assert(offsetof(UBTService_StateMonitor_Camper, BBIsInInjuredBleedout) == 0x000198, "Member 'UBTService_StateMonitor_Camper::BBIsInInjuredBleedout' has a wrong offset!");
static_assert(offsetof(UBTService_StateMonitor_Camper, BBDyingTimerPercentLeft) == 0x0001C8, "Member 'UBTService_StateMonitor_Camper::BBDyingTimerPercentLeft' has a wrong offset!");
static_assert(offsetof(UBTService_StateMonitor_Camper, BBHookTimerPercentLeft) == 0x0001F8, "Member 'UBTService_StateMonitor_Camper::BBHookTimerPercentLeft' has a wrong offset!");
static_assert(offsetof(UBTService_StateMonitor_Camper, BBHookDrainStage) == 0x000228, "Member 'UBTService_StateMonitor_Camper::BBHookDrainStage' has a wrong offset!");
static_assert(offsetof(UBTService_StateMonitor_Camper, BBItemType) == 0x000258, "Member 'UBTService_StateMonitor_Camper::BBItemType' has a wrong offset!");
static_assert(offsetof(UBTService_StateMonitor_Camper, BBItemCharge) == 0x000288, "Member 'UBTService_StateMonitor_Camper::BBItemCharge' has a wrong offset!");
static_assert(offsetof(UBTService_StateMonitor_Camper, BBIsHoldingEmptyItem) == 0x0002B8, "Member 'UBTService_StateMonitor_Camper::BBIsHoldingEmptyItem' has a wrong offset!");
static_assert(offsetof(UBTService_StateMonitor_Camper, BBSpecialItemID) == 0x0002E8, "Member 'UBTService_StateMonitor_Camper::BBSpecialItemID' has a wrong offset!");
static_assert(offsetof(UBTService_StateMonitor_Camper, BBIsChased) == 0x000318, "Member 'UBTService_StateMonitor_Camper::BBIsChased' has a wrong offset!");
static_assert(offsetof(UBTService_StateMonitor_Camper, BBWasInStimulusSight) == 0x000348, "Member 'UBTService_StateMonitor_Camper::BBWasInStimulusSight' has a wrong offset!");
static_assert(offsetof(UBTService_StateMonitor_Camper, BBWasBeingAimedAt) == 0x000378, "Member 'UBTService_StateMonitor_Camper::BBWasBeingAimedAt' has a wrong offset!");
static_assert(offsetof(UBTService_StateMonitor_Camper, BBIsBeingAimedAt) == 0x0003A8, "Member 'UBTService_StateMonitor_Camper::BBIsBeingAimedAt' has a wrong offset!");
static_assert(offsetof(UBTService_StateMonitor_Camper, BBIsBeingAttacked) == 0x0003D8, "Member 'UBTService_StateMonitor_Camper::BBIsBeingAttacked' has a wrong offset!");
static_assert(offsetof(UBTService_StateMonitor_Camper, BBIsChained) == 0x000408, "Member 'UBTService_StateMonitor_Camper::BBIsChained' has a wrong offset!");
static_assert(offsetof(UBTService_StateMonitor_Camper, BBIsInPressureZone) == 0x000438, "Member 'UBTService_StateMonitor_Camper::BBIsInPressureZone' has a wrong offset!");
static_assert(offsetof(UBTService_StateMonitor_Camper, BBIsInActivatedRBT) == 0x000468, "Member 'UBTService_StateMonitor_Camper::BBIsInActivatedRBT' has a wrong offset!");
static_assert(offsetof(UBTService_StateMonitor_Camper, BBIsInDeathTimer) == 0x000498, "Member 'UBTService_StateMonitor_Camper::BBIsInDeathTimer' has a wrong offset!");
static_assert(offsetof(UBTService_StateMonitor_Camper, BBHasCrowAttached) == 0x0004C8, "Member 'UBTService_StateMonitor_Camper::BBHasCrowAttached' has a wrong offset!");
static_assert(offsetof(UBTService_StateMonitor_Camper, BBLastTrapSideStepExpirationTime) == 0x0004F8, "Member 'UBTService_StateMonitor_Camper::BBLastTrapSideStepExpirationTime' has a wrong offset!");
static_assert(offsetof(UBTService_StateMonitor_Camper, BBLastAskedToMoveTime) == 0x000528, "Member 'UBTService_StateMonitor_Camper::BBLastAskedToMoveTime' has a wrong offset!");
static_assert(offsetof(UBTService_StateMonitor_Camper, BBPreventDroppingEmptyItems) == 0x000558, "Member 'UBTService_StateMonitor_Camper::BBPreventDroppingEmptyItems' has a wrong offset!");
static_assert(offsetof(UBTService_StateMonitor_Camper, BBIgnoreGoalPressure) == 0x000588, "Member 'UBTService_StateMonitor_Camper::BBIgnoreGoalPressure' has a wrong offset!");
static_assert(offsetof(UBTService_StateMonitor_Camper, EmptyItemChargeThreshold) == 0x0005B8, "Member 'UBTService_StateMonitor_Camper::EmptyItemChargeThreshold' has a wrong offset!");
static_assert(offsetof(UBTService_StateMonitor_Camper, DeathTimerEndGamePercent) == 0x0005BC, "Member 'UBTService_StateMonitor_Camper::DeathTimerEndGamePercent' has a wrong offset!");
static_assert(offsetof(UBTService_StateMonitor_Camper, ChaseUnseenMinimumKillerRange) == 0x0005C0, "Member 'UBTService_StateMonitor_Camper::ChaseUnseenMinimumKillerRange' has a wrong offset!");
static_assert(offsetof(UBTService_StateMonitor_Camper, ChaseSeenMinimumKillerRange) == 0x0005C4, "Member 'UBTService_StateMonitor_Camper::ChaseSeenMinimumKillerRange' has a wrong offset!");
static_assert(offsetof(UBTService_StateMonitor_Camper, ChasedMinimumScore) == 0x0005C8, "Member 'UBTService_StateMonitor_Camper::ChasedMinimumScore' has a wrong offset!");
static_assert(offsetof(UBTService_StateMonitor_Camper, HeightAmplifier) == 0x0005CC, "Member 'UBTService_StateMonitor_Camper::HeightAmplifier' has a wrong offset!");
static_assert(offsetof(UBTService_StateMonitor_Camper, HeightAmplifierActivationHeight) == 0x0005D0, "Member 'UBTService_StateMonitor_Camper::HeightAmplifierActivationHeight' has a wrong offset!");
static_assert(offsetof(UBTService_StateMonitor_Camper, ChasedScoreKillerAtMinimumDistance) == 0x0005D8, "Member 'UBTService_StateMonitor_Camper::ChasedScoreKillerAtMinimumDistance' has a wrong offset!");
static_assert(offsetof(UBTService_StateMonitor_Camper, ChasedScoreKillerDistanceMaxRange) == 0x000638, "Member 'UBTService_StateMonitor_Camper::ChasedScoreKillerDistanceMaxRange' has a wrong offset!");
static_assert(offsetof(UBTService_StateMonitor_Camper, ChasedScoreKillerWhenUnknownLocation) == 0x000698, "Member 'UBTService_StateMonitor_Camper::ChasedScoreKillerWhenUnknownLocation' has a wrong offset!");
static_assert(offsetof(UBTService_StateMonitor_Camper, ChasedScorePredictedTarget) == 0x0006F8, "Member 'UBTService_StateMonitor_Camper::ChasedScorePredictedTarget' has a wrong offset!");
static_assert(offsetof(UBTService_StateMonitor_Camper, ChasedScoreKillerLastKnownDirection) == 0x000758, "Member 'UBTService_StateMonitor_Camper::ChasedScoreKillerLastKnownDirection' has a wrong offset!");
static_assert(offsetof(UBTService_StateMonitor_Camper, ChasedScoreKillerMaxDirectionAngle) == 0x0007B8, "Member 'UBTService_StateMonitor_Camper::ChasedScoreKillerMaxDirectionAngle' has a wrong offset!");
static_assert(offsetof(UBTService_StateMonitor_Camper, ChasedScoreSurvivorWhenVisible) == 0x000818, "Member 'UBTService_StateMonitor_Camper::ChasedScoreSurvivorWhenVisible' has a wrong offset!");
static_assert(offsetof(UBTService_StateMonitor_Camper, ChasedScoreSurvivorVisibilityTime) == 0x000878, "Member 'UBTService_StateMonitor_Camper::ChasedScoreSurvivorVisibilityTime' has a wrong offset!");
static_assert(offsetof(UBTService_StateMonitor_Camper, ChasedScoreKillerUndetectable) == 0x0008D8, "Member 'UBTService_StateMonitor_Camper::ChasedScoreKillerUndetectable' has a wrong offset!");
static_assert(offsetof(UBTService_StateMonitor_Camper, ChasedScoreKillerRangedAndDash) == 0x000938, "Member 'UBTService_StateMonitor_Camper::ChasedScoreKillerRangedAndDash' has a wrong offset!");
static_assert(offsetof(UBTService_StateMonitor_Camper, ChasedScoreKillerChaseTarget) == 0x000998, "Member 'UBTService_StateMonitor_Camper::ChasedScoreKillerChaseTarget' has a wrong offset!");
static_assert(offsetof(UBTService_StateMonitor_Camper, PressureScoreDistanceWhenUnknownLocation) == 0x0009F8, "Member 'UBTService_StateMonitor_Camper::PressureScoreDistanceWhenUnknownLocation' has a wrong offset!");
static_assert(offsetof(UBTService_StateMonitor_Camper, PressureScorePredictedTargetMultiplier) == 0x000A58, "Member 'UBTService_StateMonitor_Camper::PressureScorePredictedTargetMultiplier' has a wrong offset!");
static_assert(offsetof(UBTService_StateMonitor_Camper, PressureScoreKillerMaxDirectionAngle) == 0x000AB8, "Member 'UBTService_StateMonitor_Camper::PressureScoreKillerMaxDirectionAngle' has a wrong offset!");
static_assert(offsetof(UBTService_StateMonitor_Camper, PressureScoreKillerDirectionMaxMultiplier) == 0x000B18, "Member 'UBTService_StateMonitor_Camper::PressureScoreKillerDirectionMaxMultiplier' has a wrong offset!");
static_assert(offsetof(UBTService_StateMonitor_Camper, PressureScoreSurvivorVisibilityTime) == 0x000B78, "Member 'UBTService_StateMonitor_Camper::PressureScoreSurvivorVisibilityTime' has a wrong offset!");
static_assert(offsetof(UBTService_StateMonitor_Camper, PressureScoreMaxMultiplierWhenSurvivorVisible) == 0x000BD8, "Member 'UBTService_StateMonitor_Camper::PressureScoreMaxMultiplierWhenSurvivorVisible' has a wrong offset!");
static_assert(offsetof(UBTService_StateMonitor_Camper, PressureScoreKillerRangedAndDashDistancePenalty) == 0x000C38, "Member 'UBTService_StateMonitor_Camper::PressureScoreKillerRangedAndDashDistancePenalty' has a wrong offset!");
static_assert(offsetof(UBTService_StateMonitor_Camper, PressureScoreChaseTargetMultiplier) == 0x000C98, "Member 'UBTService_StateMonitor_Camper::PressureScoreChaseTargetMultiplier' has a wrong offset!");
static_assert(offsetof(UBTService_StateMonitor_Camper, PressureScoreMaxScore) == 0x000CF8, "Member 'UBTService_StateMonitor_Camper::PressureScoreMaxScore' has a wrong offset!");

// Class DBDBots.BTService_StimuliMonitor_Slasher
// 0x0208 (0x0450 - 0x0248)
class UBTService_StimuliMonitor_Slasher final : public UBTService_StimuliMonitor
{
public:
	struct FBlackboardKeySelector                 BBInvestigateStimulusLocation;                     // 0x0248(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBInvestigateStimulusActor;                        // 0x0278(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBInBehaviorInvestigationStep;                     // 0x02A8(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBIsBlind;                                         // 0x02D8(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBWasBlind;                                        // 0x0308(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBChasedActor;                                     // 0x0338(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    UseNextStimulusInvestigationAfterChaseDelay;       // 0x0368(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	float                                         IgnorePreviousChasedStimulusActorDelay;            // 0x03C8(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultStimulusToInvestigateMaxAge;                // 0x03CC(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KOStimulusToInvestigateMaxAge;                     // 0x03D0(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NextStimulusInvestigationMinRange;                 // 0x03D4(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NearAroundSquaredDistance;                         // 0x03D8(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CantSeeOverBlindRatio;                             // 0x03DC(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FavorizeStandingTargetInRange;                     // 0x03E0(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FavorizeStandingTargetOutRange;                    // 0x03E4(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    WasBlindExpireTime;                                // 0x03E8(0x0060)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	uint8                                         Pad_448[0x8];                                      // 0x0448(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_StimuliMonitor_Slasher">();
	}
	static class UBTService_StimuliMonitor_Slasher* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_StimuliMonitor_Slasher>();
	}
};
static_assert(alignof(UBTService_StimuliMonitor_Slasher) == 0x000008, "Wrong alignment on UBTService_StimuliMonitor_Slasher");
static_assert(sizeof(UBTService_StimuliMonitor_Slasher) == 0x000450, "Wrong size on UBTService_StimuliMonitor_Slasher");
static_assert(offsetof(UBTService_StimuliMonitor_Slasher, BBInvestigateStimulusLocation) == 0x000248, "Member 'UBTService_StimuliMonitor_Slasher::BBInvestigateStimulusLocation' has a wrong offset!");
static_assert(offsetof(UBTService_StimuliMonitor_Slasher, BBInvestigateStimulusActor) == 0x000278, "Member 'UBTService_StimuliMonitor_Slasher::BBInvestigateStimulusActor' has a wrong offset!");
static_assert(offsetof(UBTService_StimuliMonitor_Slasher, BBInBehaviorInvestigationStep) == 0x0002A8, "Member 'UBTService_StimuliMonitor_Slasher::BBInBehaviorInvestigationStep' has a wrong offset!");
static_assert(offsetof(UBTService_StimuliMonitor_Slasher, BBIsBlind) == 0x0002D8, "Member 'UBTService_StimuliMonitor_Slasher::BBIsBlind' has a wrong offset!");
static_assert(offsetof(UBTService_StimuliMonitor_Slasher, BBWasBlind) == 0x000308, "Member 'UBTService_StimuliMonitor_Slasher::BBWasBlind' has a wrong offset!");
static_assert(offsetof(UBTService_StimuliMonitor_Slasher, BBChasedActor) == 0x000338, "Member 'UBTService_StimuliMonitor_Slasher::BBChasedActor' has a wrong offset!");
static_assert(offsetof(UBTService_StimuliMonitor_Slasher, UseNextStimulusInvestigationAfterChaseDelay) == 0x000368, "Member 'UBTService_StimuliMonitor_Slasher::UseNextStimulusInvestigationAfterChaseDelay' has a wrong offset!");
static_assert(offsetof(UBTService_StimuliMonitor_Slasher, IgnorePreviousChasedStimulusActorDelay) == 0x0003C8, "Member 'UBTService_StimuliMonitor_Slasher::IgnorePreviousChasedStimulusActorDelay' has a wrong offset!");
static_assert(offsetof(UBTService_StimuliMonitor_Slasher, DefaultStimulusToInvestigateMaxAge) == 0x0003CC, "Member 'UBTService_StimuliMonitor_Slasher::DefaultStimulusToInvestigateMaxAge' has a wrong offset!");
static_assert(offsetof(UBTService_StimuliMonitor_Slasher, KOStimulusToInvestigateMaxAge) == 0x0003D0, "Member 'UBTService_StimuliMonitor_Slasher::KOStimulusToInvestigateMaxAge' has a wrong offset!");
static_assert(offsetof(UBTService_StimuliMonitor_Slasher, NextStimulusInvestigationMinRange) == 0x0003D4, "Member 'UBTService_StimuliMonitor_Slasher::NextStimulusInvestigationMinRange' has a wrong offset!");
static_assert(offsetof(UBTService_StimuliMonitor_Slasher, NearAroundSquaredDistance) == 0x0003D8, "Member 'UBTService_StimuliMonitor_Slasher::NearAroundSquaredDistance' has a wrong offset!");
static_assert(offsetof(UBTService_StimuliMonitor_Slasher, CantSeeOverBlindRatio) == 0x0003DC, "Member 'UBTService_StimuliMonitor_Slasher::CantSeeOverBlindRatio' has a wrong offset!");
static_assert(offsetof(UBTService_StimuliMonitor_Slasher, FavorizeStandingTargetInRange) == 0x0003E0, "Member 'UBTService_StimuliMonitor_Slasher::FavorizeStandingTargetInRange' has a wrong offset!");
static_assert(offsetof(UBTService_StimuliMonitor_Slasher, FavorizeStandingTargetOutRange) == 0x0003E4, "Member 'UBTService_StimuliMonitor_Slasher::FavorizeStandingTargetOutRange' has a wrong offset!");
static_assert(offsetof(UBTService_StimuliMonitor_Slasher, WasBlindExpireTime) == 0x0003E8, "Member 'UBTService_StimuliMonitor_Slasher::WasBlindExpireTime' has a wrong offset!");

// Class DBDBots.BTTask_CopyBBEntry
// 0x0068 (0x00E0 - 0x0078)
class UBTTask_CopyBBEntry final : public UBTTaskNode
{
public:
	struct FBlackboardKeySelector                 BBFrom;                                            // 0x0078(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBTo;                                              // 0x00A8(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	bool                                          CopyOnlyValidKeyValue;                             // 0x00D8(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D9[0x7];                                       // 0x00D9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_CopyBBEntry">();
	}
	static class UBTTask_CopyBBEntry* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_CopyBBEntry>();
	}
};
static_assert(alignof(UBTTask_CopyBBEntry) == 0x000008, "Wrong alignment on UBTTask_CopyBBEntry");
static_assert(sizeof(UBTTask_CopyBBEntry) == 0x0000E0, "Wrong size on UBTTask_CopyBBEntry");
static_assert(offsetof(UBTTask_CopyBBEntry, BBFrom) == 0x000078, "Member 'UBTTask_CopyBBEntry::BBFrom' has a wrong offset!");
static_assert(offsetof(UBTTask_CopyBBEntry, BBTo) == 0x0000A8, "Member 'UBTTask_CopyBBEntry::BBTo' has a wrong offset!");
static_assert(offsetof(UBTTask_CopyBBEntry, CopyOnlyValidKeyValue) == 0x0000D8, "Member 'UBTTask_CopyBBEntry::CopyOnlyValidKeyValue' has a wrong offset!");

// Class DBDBots.BTTask_ExtMoveDirecltyToward
// 0x0008 (0x00D0 - 0x00C8)
class UBTTask_ExtMoveDirecltyToward final : public UBTTask_MoveDirectlyToward
{
public:
	ECharacterMovementTypes                       MovementMode;                                      // 0x00C8(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C9[0x7];                                       // 0x00C9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_ExtMoveDirecltyToward">();
	}
	static class UBTTask_ExtMoveDirecltyToward* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_ExtMoveDirecltyToward>();
	}
};
static_assert(alignof(UBTTask_ExtMoveDirecltyToward) == 0x000008, "Wrong alignment on UBTTask_ExtMoveDirecltyToward");
static_assert(sizeof(UBTTask_ExtMoveDirecltyToward) == 0x0000D0, "Wrong size on UBTTask_ExtMoveDirecltyToward");
static_assert(offsetof(UBTTask_ExtMoveDirecltyToward, MovementMode) == 0x0000C8, "Member 'UBTTask_ExtMoveDirecltyToward::MovementMode' has a wrong offset!");

// Class DBDBots.BTTask_FleeMoveTo
// 0x0018 (0x0278 - 0x0260)
class UBTTask_FleeMoveTo final : public UBTTask_ExtMoveTo
{
public:
	float                                         InScrambleMovementMinDistance;                     // 0x0260(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutScrambleMovementMinDistance;                    // 0x0264(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InScrambleMovementInterval;                        // 0x0268(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LoopScrambleMovementInterval;                      // 0x026C(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LoopScrambleMovementRandomDeviation;               // 0x0270(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CrouchWithinLastEvadeLoopPointRadius;              // 0x0274(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_FleeMoveTo">();
	}
	static class UBTTask_FleeMoveTo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_FleeMoveTo>();
	}
};
static_assert(alignof(UBTTask_FleeMoveTo) == 0x000008, "Wrong alignment on UBTTask_FleeMoveTo");
static_assert(sizeof(UBTTask_FleeMoveTo) == 0x000278, "Wrong size on UBTTask_FleeMoveTo");
static_assert(offsetof(UBTTask_FleeMoveTo, InScrambleMovementMinDistance) == 0x000260, "Member 'UBTTask_FleeMoveTo::InScrambleMovementMinDistance' has a wrong offset!");
static_assert(offsetof(UBTTask_FleeMoveTo, OutScrambleMovementMinDistance) == 0x000264, "Member 'UBTTask_FleeMoveTo::OutScrambleMovementMinDistance' has a wrong offset!");
static_assert(offsetof(UBTTask_FleeMoveTo, InScrambleMovementInterval) == 0x000268, "Member 'UBTTask_FleeMoveTo::InScrambleMovementInterval' has a wrong offset!");
static_assert(offsetof(UBTTask_FleeMoveTo, LoopScrambleMovementInterval) == 0x00026C, "Member 'UBTTask_FleeMoveTo::LoopScrambleMovementInterval' has a wrong offset!");
static_assert(offsetof(UBTTask_FleeMoveTo, LoopScrambleMovementRandomDeviation) == 0x000270, "Member 'UBTTask_FleeMoveTo::LoopScrambleMovementRandomDeviation' has a wrong offset!");
static_assert(offsetof(UBTTask_FleeMoveTo, CrouchWithinLastEvadeLoopPointRadius) == 0x000274, "Member 'UBTTask_FleeMoveTo::CrouchWithinLastEvadeLoopPointRadius' has a wrong offset!");

// Class DBDBots.BTTask_Interact
// 0x0040 (0x00B8 - 0x0078)
class UBTTask_Interact final : public UBTTaskNode
{
public:
	struct FBlackboardKeySelector                 BBInteractorObj;                                   // 0x0078(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	EPawnInputPressTypes                          Input;                                             // 0x00A8(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x3];                                       // 0x00A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OnFailFocusCooldownDuration;                       // 0x00AC(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          PropagateCooldownOnInteractable;                   // 0x00B0(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0x3];                                       // 0x00B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FailStartInteractTimeLimit;                        // 0x00B4(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_Interact">();
	}
	static class UBTTask_Interact* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_Interact>();
	}
};
static_assert(alignof(UBTTask_Interact) == 0x000008, "Wrong alignment on UBTTask_Interact");
static_assert(sizeof(UBTTask_Interact) == 0x0000B8, "Wrong size on UBTTask_Interact");
static_assert(offsetof(UBTTask_Interact, BBInteractorObj) == 0x000078, "Member 'UBTTask_Interact::BBInteractorObj' has a wrong offset!");
static_assert(offsetof(UBTTask_Interact, Input) == 0x0000A8, "Member 'UBTTask_Interact::Input' has a wrong offset!");
static_assert(offsetof(UBTTask_Interact, OnFailFocusCooldownDuration) == 0x0000AC, "Member 'UBTTask_Interact::OnFailFocusCooldownDuration' has a wrong offset!");
static_assert(offsetof(UBTTask_Interact, PropagateCooldownOnInteractable) == 0x0000B0, "Member 'UBTTask_Interact::PropagateCooldownOnInteractable' has a wrong offset!");
static_assert(offsetof(UBTTask_Interact, FailStartInteractTimeLimit) == 0x0000B4, "Member 'UBTTask_Interact::FailStartInteractTimeLimit' has a wrong offset!");

// Class DBDBots.BTTask_RotateToBBInteractor
// 0x0040 (0x00F0 - 0x00B0)
class UBTTask_RotateToBBInteractor final : public UBTTask_BlueprintBase
{
public:
	struct FBlackboardKeySelector                 BBInteractorObj;                                   // 0x00B0(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	TArray<class FString>                         InteractionIds;                                    // 0x00E0(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_RotateToBBInteractor">();
	}
	static class UBTTask_RotateToBBInteractor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_RotateToBBInteractor>();
	}
};
static_assert(alignof(UBTTask_RotateToBBInteractor) == 0x000008, "Wrong alignment on UBTTask_RotateToBBInteractor");
static_assert(sizeof(UBTTask_RotateToBBInteractor) == 0x0000F0, "Wrong size on UBTTask_RotateToBBInteractor");
static_assert(offsetof(UBTTask_RotateToBBInteractor, BBInteractorObj) == 0x0000B0, "Member 'UBTTask_RotateToBBInteractor::BBInteractorObj' has a wrong offset!");
static_assert(offsetof(UBTTask_RotateToBBInteractor, InteractionIds) == 0x0000E0, "Member 'UBTTask_RotateToBBInteractor::InteractionIds' has a wrong offset!");

// Class DBDBots.BTTask_RunSkills
// 0x0010 (0x0088 - 0x0078)
class UBTTask_RunSkills final : public UBTTaskNode
{
public:
	struct FGameplayTag                           Context;                                           // 0x0078(0x000C)(Edit, DisableEditOnTemplate, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_84[0x4];                                       // 0x0084(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_RunSkills">();
	}
	static class UBTTask_RunSkills* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_RunSkills>();
	}
};
static_assert(alignof(UBTTask_RunSkills) == 0x000008, "Wrong alignment on UBTTask_RunSkills");
static_assert(sizeof(UBTTask_RunSkills) == 0x000088, "Wrong size on UBTTask_RunSkills");
static_assert(offsetof(UBTTask_RunSkills, Context) == 0x000078, "Member 'UBTTask_RunSkills::Context' has a wrong offset!");

// Class DBDBots.BTTask_SetBBEntry
// 0x0040 (0x00B8 - 0x0078)
class UBTTask_SetBBEntry final : public UBTTaskNode
{
public:
	struct FBlackboardKeySelector                 BBToSetKey;                                        // 0x0078(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	class FString                                 ToSetValue;                                        // 0x00A8(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_SetBBEntry">();
	}
	static class UBTTask_SetBBEntry* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_SetBBEntry>();
	}
};
static_assert(alignof(UBTTask_SetBBEntry) == 0x000008, "Wrong alignment on UBTTask_SetBBEntry");
static_assert(sizeof(UBTTask_SetBBEntry) == 0x0000B8, "Wrong size on UBTTask_SetBBEntry");
static_assert(offsetof(UBTTask_SetBBEntry, BBToSetKey) == 0x000078, "Member 'UBTTask_SetBBEntry::BBToSetKey' has a wrong offset!");
static_assert(offsetof(UBTTask_SetBBEntry, ToSetValue) == 0x0000A8, "Member 'UBTTask_SetBBEntry::ToSetValue' has a wrong offset!");

// Class DBDBots.BTTask_SetBBEntryTime
// 0x0030 (0x00A8 - 0x0078)
class UBTTask_SetBBEntryTime final : public UBTTaskNode
{
public:
	struct FBlackboardKeySelector                 BBToSetKey;                                        // 0x0078(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_SetBBEntryTime">();
	}
	static class UBTTask_SetBBEntryTime* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_SetBBEntryTime>();
	}
};
static_assert(alignof(UBTTask_SetBBEntryTime) == 0x000008, "Wrong alignment on UBTTask_SetBBEntryTime");
static_assert(sizeof(UBTTask_SetBBEntryTime) == 0x0000A8, "Wrong size on UBTTask_SetBBEntryTime");
static_assert(offsetof(UBTTask_SetBBEntryTime, BBToSetKey) == 0x000078, "Member 'UBTTask_SetBBEntryTime::BBToSetKey' has a wrong offset!");

// Class DBDBots.BTTask_SetFleeLoopCooldown
// 0x0008 (0x0080 - 0x0078)
class UBTTask_SetFleeLoopCooldown final : public UBTTaskNode
{
public:
	float                                         Duration;                                          // 0x0078(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_SetFleeLoopCooldown">();
	}
	static class UBTTask_SetFleeLoopCooldown* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_SetFleeLoopCooldown>();
	}
};
static_assert(alignof(UBTTask_SetFleeLoopCooldown) == 0x000008, "Wrong alignment on UBTTask_SetFleeLoopCooldown");
static_assert(sizeof(UBTTask_SetFleeLoopCooldown) == 0x000080, "Wrong size on UBTTask_SetFleeLoopCooldown");
static_assert(offsetof(UBTTask_SetFleeLoopCooldown, Duration) == 0x000078, "Member 'UBTTask_SetFleeLoopCooldown::Duration' has a wrong offset!");

// Class DBDBots.BTTask_SetFocusCooldown
// 0x0048 (0x00C0 - 0x0078)
class UBTTask_SetFocusCooldown final : public UBTTaskNode
{
public:
	struct FBlackboardKeySelector                 BBOnObject;                                        // 0x0078(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	class FName                                   ContextName;                                       // 0x00A8(0x000C)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InfiniteDuration;                                  // 0x00B4(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B5[0x3];                                       // 0x00B5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Duration;                                          // 0x00B8(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_SetFocusCooldown">();
	}
	static class UBTTask_SetFocusCooldown* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_SetFocusCooldown>();
	}
};
static_assert(alignof(UBTTask_SetFocusCooldown) == 0x000008, "Wrong alignment on UBTTask_SetFocusCooldown");
static_assert(sizeof(UBTTask_SetFocusCooldown) == 0x0000C0, "Wrong size on UBTTask_SetFocusCooldown");
static_assert(offsetof(UBTTask_SetFocusCooldown, BBOnObject) == 0x000078, "Member 'UBTTask_SetFocusCooldown::BBOnObject' has a wrong offset!");
static_assert(offsetof(UBTTask_SetFocusCooldown, ContextName) == 0x0000A8, "Member 'UBTTask_SetFocusCooldown::ContextName' has a wrong offset!");
static_assert(offsetof(UBTTask_SetFocusCooldown, InfiniteDuration) == 0x0000B4, "Member 'UBTTask_SetFocusCooldown::InfiniteDuration' has a wrong offset!");
static_assert(offsetof(UBTTask_SetFocusCooldown, Duration) == 0x0000B8, "Member 'UBTTask_SetFocusCooldown::Duration' has a wrong offset!");

// Class DBDBots.BTTask_SetIsChased
// 0x0008 (0x0080 - 0x0078)
class UBTTask_SetIsChased final : public UBTTaskNode
{
public:
	bool                                          ToSetValue;                                        // 0x0078(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_SetIsChased">();
	}
	static class UBTTask_SetIsChased* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_SetIsChased>();
	}
};
static_assert(alignof(UBTTask_SetIsChased) == 0x000008, "Wrong alignment on UBTTask_SetIsChased");
static_assert(sizeof(UBTTask_SetIsChased) == 0x000080, "Wrong size on UBTTask_SetIsChased");
static_assert(offsetof(UBTTask_SetIsChased, ToSetValue) == 0x000078, "Member 'UBTTask_SetIsChased::ToSetValue' has a wrong offset!");

// Class DBDBots.BTTask_SetMovementMode
// 0x0008 (0x0080 - 0x0078)
class UBTTask_SetMovementMode final : public UBTTaskNode
{
public:
	ECharacterMovementTypes                       MovementMode;                                      // 0x0078(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_SetMovementMode">();
	}
	static class UBTTask_SetMovementMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_SetMovementMode>();
	}
};
static_assert(alignof(UBTTask_SetMovementMode) == 0x000008, "Wrong alignment on UBTTask_SetMovementMode");
static_assert(sizeof(UBTTask_SetMovementMode) == 0x000080, "Wrong size on UBTTask_SetMovementMode");
static_assert(offsetof(UBTTask_SetMovementMode, MovementMode) == 0x000078, "Member 'UBTTask_SetMovementMode::MovementMode' has a wrong offset!");

// Class DBDBots.BTTask_SetRandomNavPoint
// 0x0078 (0x00F0 - 0x0078)
class UBTTask_SetRandomNavPoint final : public UBTTaskNode
{
public:
	struct FBlackboardKeySelector                 BBFromLocation;                                    // 0x0078(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBToLocation;                                      // 0x00A8(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	float                                         MinAroundRadius;                                   // 0x00D8(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAroundRadius;                                   // 0x00DC(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxNbAttempts;                                     // 0x00E0(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxSafeNbAttempts;                                 // 0x00E4(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UNavigationQueryFilter>     FilterClass;                                       // 0x00E8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_SetRandomNavPoint">();
	}
	static class UBTTask_SetRandomNavPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_SetRandomNavPoint>();
	}
};
static_assert(alignof(UBTTask_SetRandomNavPoint) == 0x000008, "Wrong alignment on UBTTask_SetRandomNavPoint");
static_assert(sizeof(UBTTask_SetRandomNavPoint) == 0x0000F0, "Wrong size on UBTTask_SetRandomNavPoint");
static_assert(offsetof(UBTTask_SetRandomNavPoint, BBFromLocation) == 0x000078, "Member 'UBTTask_SetRandomNavPoint::BBFromLocation' has a wrong offset!");
static_assert(offsetof(UBTTask_SetRandomNavPoint, BBToLocation) == 0x0000A8, "Member 'UBTTask_SetRandomNavPoint::BBToLocation' has a wrong offset!");
static_assert(offsetof(UBTTask_SetRandomNavPoint, MinAroundRadius) == 0x0000D8, "Member 'UBTTask_SetRandomNavPoint::MinAroundRadius' has a wrong offset!");
static_assert(offsetof(UBTTask_SetRandomNavPoint, MaxAroundRadius) == 0x0000DC, "Member 'UBTTask_SetRandomNavPoint::MaxAroundRadius' has a wrong offset!");
static_assert(offsetof(UBTTask_SetRandomNavPoint, MaxNbAttempts) == 0x0000E0, "Member 'UBTTask_SetRandomNavPoint::MaxNbAttempts' has a wrong offset!");
static_assert(offsetof(UBTTask_SetRandomNavPoint, MaxSafeNbAttempts) == 0x0000E4, "Member 'UBTTask_SetRandomNavPoint::MaxSafeNbAttempts' has a wrong offset!");
static_assert(offsetof(UBTTask_SetRandomNavPoint, FilterClass) == 0x0000E8, "Member 'UBTTask_SetRandomNavPoint::FilterClass' has a wrong offset!");

// Class DBDBots.BTTask_StealthMoveTo
// 0x0000 (0x0260 - 0x0260)
class UBTTask_StealthMoveTo final : public UBTTask_ExtMoveTo
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_StealthMoveTo">();
	}
	static class UBTTask_StealthMoveTo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_StealthMoveTo>();
	}
};
static_assert(alignof(UBTTask_StealthMoveTo) == 0x000008, "Wrong alignment on UBTTask_StealthMoveTo");
static_assert(sizeof(UBTTask_StealthMoveTo) == 0x000260, "Wrong size on UBTTask_StealthMoveTo");

// Class DBDBots.DBDAIBTUtilities
// 0x0000 (0x0030 - 0x0030)
class UDBDAIBTUtilities final : public UDBDAIUtilities
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDAIBTUtilities">();
	}
	static class UDBDAIBTUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDAIBTUtilities>();
	}
};
static_assert(alignof(UDBDAIBTUtilities) == 0x000008, "Wrong alignment on UDBDAIBTUtilities");
static_assert(sizeof(UDBDAIBTUtilities) == 0x000030, "Wrong size on UDBDAIBTUtilities");

// Class DBDBots.DBDAIEnemyTrackerComponent
// 0x00E0 (0x0188 - 0x00A8)
class UDBDAIEnemyTrackerComponent final : public UActorComponent
{
public:
	class UAIEnemyTracker*                        EnemyTracker;                                      // 0x00A8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAIEnemyTargetPrediction*               EnemyTargetPrediction;                             // 0x00B0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DataUpdateInterval;                                // 0x00B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetPredictionUpdateInterval;                    // 0x00BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IndirectUpdateDelay;                               // 0x00C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C4[0x4];                                       // 0x00C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAITunableParameter                    PotentialTargetedLocationRange;                    // 0x00C8(0x0060)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         BaseKnownInfoExpirationTime;                       // 0x0128(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceInfoExpirationTime;                        // 0x012C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<TWeakObjectPtr<class ACharacter>, struct FAITrackedEnemyData> _trackedEnemiesData;                               // 0x0130(0x0050)(Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_180[0x8];                                      // 0x0180(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnLevelReadyToPlay();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDAIEnemyTrackerComponent">();
	}
	static class UDBDAIEnemyTrackerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDAIEnemyTrackerComponent>();
	}
};
static_assert(alignof(UDBDAIEnemyTrackerComponent) == 0x000008, "Wrong alignment on UDBDAIEnemyTrackerComponent");
static_assert(sizeof(UDBDAIEnemyTrackerComponent) == 0x000188, "Wrong size on UDBDAIEnemyTrackerComponent");
static_assert(offsetof(UDBDAIEnemyTrackerComponent, EnemyTracker) == 0x0000A8, "Member 'UDBDAIEnemyTrackerComponent::EnemyTracker' has a wrong offset!");
static_assert(offsetof(UDBDAIEnemyTrackerComponent, EnemyTargetPrediction) == 0x0000B0, "Member 'UDBDAIEnemyTrackerComponent::EnemyTargetPrediction' has a wrong offset!");
static_assert(offsetof(UDBDAIEnemyTrackerComponent, DataUpdateInterval) == 0x0000B8, "Member 'UDBDAIEnemyTrackerComponent::DataUpdateInterval' has a wrong offset!");
static_assert(offsetof(UDBDAIEnemyTrackerComponent, TargetPredictionUpdateInterval) == 0x0000BC, "Member 'UDBDAIEnemyTrackerComponent::TargetPredictionUpdateInterval' has a wrong offset!");
static_assert(offsetof(UDBDAIEnemyTrackerComponent, IndirectUpdateDelay) == 0x0000C0, "Member 'UDBDAIEnemyTrackerComponent::IndirectUpdateDelay' has a wrong offset!");
static_assert(offsetof(UDBDAIEnemyTrackerComponent, PotentialTargetedLocationRange) == 0x0000C8, "Member 'UDBDAIEnemyTrackerComponent::PotentialTargetedLocationRange' has a wrong offset!");
static_assert(offsetof(UDBDAIEnemyTrackerComponent, BaseKnownInfoExpirationTime) == 0x000128, "Member 'UDBDAIEnemyTrackerComponent::BaseKnownInfoExpirationTime' has a wrong offset!");
static_assert(offsetof(UDBDAIEnemyTrackerComponent, DistanceInfoExpirationTime) == 0x00012C, "Member 'UDBDAIEnemyTrackerComponent::DistanceInfoExpirationTime' has a wrong offset!");
static_assert(offsetof(UDBDAIEnemyTrackerComponent, _trackedEnemiesData) == 0x000130, "Member 'UDBDAIEnemyTrackerComponent::_trackedEnemiesData' has a wrong offset!");

// Class DBDBots.DBDAIGoalComponent
// 0x00A8 (0x0150 - 0x00A8)
class UDBDAIGoalComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class UObject*, struct FAIGoal>          _activeGoals;                                      // 0x00B0(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMap<class UObject*, struct FAIGoalWeightContainer> _foundWeightedGoals;                               // 0x0100(0x0050)(Transient, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDAIGoalComponent">();
	}
	static class UDBDAIGoalComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDAIGoalComponent>();
	}
};
static_assert(alignof(UDBDAIGoalComponent) == 0x000008, "Wrong alignment on UDBDAIGoalComponent");
static_assert(sizeof(UDBDAIGoalComponent) == 0x000150, "Wrong size on UDBDAIGoalComponent");
static_assert(offsetof(UDBDAIGoalComponent, _activeGoals) == 0x0000B0, "Member 'UDBDAIGoalComponent::_activeGoals' has a wrong offset!");
static_assert(offsetof(UDBDAIGoalComponent, _foundWeightedGoals) == 0x000100, "Member 'UDBDAIGoalComponent::_foundWeightedGoals' has a wrong offset!");

// Class DBDBots.DBDAIPassiveCameraComponent
// 0x0178 (0x0220 - 0x00A8)
class UDBDAIPassiveCameraComponent final : public UActorComponent
{
public:
	float                                         RotateCameraOnStationaryWaitTime;                  // 0x00A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotateCameraOnStationaryDegreePerSecond;           // 0x00AC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    CameraRotationFullRotationDelay;                   // 0x00B0(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    CameraRotationBetweenTargetDelay;                  // 0x0110(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    CameraRotationMinimumInteractionTime;              // 0x0170(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         CameraRotationTotalRaycasts;                       // 0x01D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ForwardViewHalfAngle;                              // 0x01D4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FocusPointCandidateRemoveOppositeHalfAngle;        // 0x01D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FocusPointCandidateForceKeepDistance;              // 0x01DC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FocusPointCandidateMinDistance;                    // 0x01E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InvalidKillerLocationRangeRatio;                   // 0x01E4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E8[0x38];                                     // 0x01E8(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDAIPassiveCameraComponent">();
	}
	static class UDBDAIPassiveCameraComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDAIPassiveCameraComponent>();
	}
};
static_assert(alignof(UDBDAIPassiveCameraComponent) == 0x000008, "Wrong alignment on UDBDAIPassiveCameraComponent");
static_assert(sizeof(UDBDAIPassiveCameraComponent) == 0x000220, "Wrong size on UDBDAIPassiveCameraComponent");
static_assert(offsetof(UDBDAIPassiveCameraComponent, RotateCameraOnStationaryWaitTime) == 0x0000A8, "Member 'UDBDAIPassiveCameraComponent::RotateCameraOnStationaryWaitTime' has a wrong offset!");
static_assert(offsetof(UDBDAIPassiveCameraComponent, RotateCameraOnStationaryDegreePerSecond) == 0x0000AC, "Member 'UDBDAIPassiveCameraComponent::RotateCameraOnStationaryDegreePerSecond' has a wrong offset!");
static_assert(offsetof(UDBDAIPassiveCameraComponent, CameraRotationFullRotationDelay) == 0x0000B0, "Member 'UDBDAIPassiveCameraComponent::CameraRotationFullRotationDelay' has a wrong offset!");
static_assert(offsetof(UDBDAIPassiveCameraComponent, CameraRotationBetweenTargetDelay) == 0x000110, "Member 'UDBDAIPassiveCameraComponent::CameraRotationBetweenTargetDelay' has a wrong offset!");
static_assert(offsetof(UDBDAIPassiveCameraComponent, CameraRotationMinimumInteractionTime) == 0x000170, "Member 'UDBDAIPassiveCameraComponent::CameraRotationMinimumInteractionTime' has a wrong offset!");
static_assert(offsetof(UDBDAIPassiveCameraComponent, CameraRotationTotalRaycasts) == 0x0001D0, "Member 'UDBDAIPassiveCameraComponent::CameraRotationTotalRaycasts' has a wrong offset!");
static_assert(offsetof(UDBDAIPassiveCameraComponent, ForwardViewHalfAngle) == 0x0001D4, "Member 'UDBDAIPassiveCameraComponent::ForwardViewHalfAngle' has a wrong offset!");
static_assert(offsetof(UDBDAIPassiveCameraComponent, FocusPointCandidateRemoveOppositeHalfAngle) == 0x0001D8, "Member 'UDBDAIPassiveCameraComponent::FocusPointCandidateRemoveOppositeHalfAngle' has a wrong offset!");
static_assert(offsetof(UDBDAIPassiveCameraComponent, FocusPointCandidateForceKeepDistance) == 0x0001DC, "Member 'UDBDAIPassiveCameraComponent::FocusPointCandidateForceKeepDistance' has a wrong offset!");
static_assert(offsetof(UDBDAIPassiveCameraComponent, FocusPointCandidateMinDistance) == 0x0001E0, "Member 'UDBDAIPassiveCameraComponent::FocusPointCandidateMinDistance' has a wrong offset!");
static_assert(offsetof(UDBDAIPassiveCameraComponent, InvalidKillerLocationRangeRatio) == 0x0001E4, "Member 'UDBDAIPassiveCameraComponent::InvalidKillerLocationRangeRatio' has a wrong offset!");

// Class DBDBots.DBDAIPerceptionComponent
// 0x03A8 (0x0540 - 0x0198)
class UDBDAIPerceptionComponent final : public UAIPerceptionComponent
{
public:
	uint8                                         Pad_198[0x20];                                     // 0x0198(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EAttackType>                           RangedAttackTypes;                                 // 0x01B8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<EKillerAbilities>                      RangedKillerAbilities;                             // 0x01C8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<EKillerAbilities>                      FastVaultKillerAbilities;                          // 0x01D8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<EKillerAbilities>                      AntiPalletKillerAbilities;                         // 0x01E8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         HostileStimulusRelevancyMaxTimeToReach;            // 0x01F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HostileStimulusRelevancySpeedBonus;                // 0x01FC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FleeFromStimuliActorMaxDistance;                   // 0x0200(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FleeFromStimuliEscapePointMaxDistance;             // 0x0204(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseSimulatedCameraLocationForStimulusReceiverLocation; // 0x0208(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_209[0x3];                                      // 0x0209(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CameraOffset;                                      // 0x020C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StimulusHalfFOV;                                   // 0x0210(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutOfChaseFullPeripheralVisionRange;               // 0x0214(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InChaseFullPeripheralVisionRange;                  // 0x0218(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21C[0x4];                                      // 0x021C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class UClass*, class UObject*>           _objOverridingSenses;                              // 0x0220(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TArray<class UAISenseConfig*>                 _originalSenseConfigs;                             // 0x0270(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<struct FAIDetectedStimulus>            _detectedHostileStimuli;                           // 0x0280(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	struct FAIDetectedStimulus                    _bestDetectedHostileStimulus;                      // 0x0290(0x00E8)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
	struct FAIDetectedStimulus                    _lastBestDetectedHostileStimulusInMemory;          // 0x0378(0x00E8)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_460[0x70];                                     // 0x0460(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAITunableParameter                    _activePhaseWalkingNoiseMaxRange;                  // 0x04D0(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	float                                         ThreatDividerForNonControlledActor;                // 0x0530(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         HighThreatDistanceForNonControlledActor;           // 0x0534(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CurrentThreatDivider;                              // 0x0538(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         TerrorDistanceMultiplierForNonControlledActor;     // 0x053C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDAIPerceptionComponent">();
	}
	static class UDBDAIPerceptionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDAIPerceptionComponent>();
	}
};
static_assert(alignof(UDBDAIPerceptionComponent) == 0x000008, "Wrong alignment on UDBDAIPerceptionComponent");
static_assert(sizeof(UDBDAIPerceptionComponent) == 0x000540, "Wrong size on UDBDAIPerceptionComponent");
static_assert(offsetof(UDBDAIPerceptionComponent, RangedAttackTypes) == 0x0001B8, "Member 'UDBDAIPerceptionComponent::RangedAttackTypes' has a wrong offset!");
static_assert(offsetof(UDBDAIPerceptionComponent, RangedKillerAbilities) == 0x0001C8, "Member 'UDBDAIPerceptionComponent::RangedKillerAbilities' has a wrong offset!");
static_assert(offsetof(UDBDAIPerceptionComponent, FastVaultKillerAbilities) == 0x0001D8, "Member 'UDBDAIPerceptionComponent::FastVaultKillerAbilities' has a wrong offset!");
static_assert(offsetof(UDBDAIPerceptionComponent, AntiPalletKillerAbilities) == 0x0001E8, "Member 'UDBDAIPerceptionComponent::AntiPalletKillerAbilities' has a wrong offset!");
static_assert(offsetof(UDBDAIPerceptionComponent, HostileStimulusRelevancyMaxTimeToReach) == 0x0001F8, "Member 'UDBDAIPerceptionComponent::HostileStimulusRelevancyMaxTimeToReach' has a wrong offset!");
static_assert(offsetof(UDBDAIPerceptionComponent, HostileStimulusRelevancySpeedBonus) == 0x0001FC, "Member 'UDBDAIPerceptionComponent::HostileStimulusRelevancySpeedBonus' has a wrong offset!");
static_assert(offsetof(UDBDAIPerceptionComponent, FleeFromStimuliActorMaxDistance) == 0x000200, "Member 'UDBDAIPerceptionComponent::FleeFromStimuliActorMaxDistance' has a wrong offset!");
static_assert(offsetof(UDBDAIPerceptionComponent, FleeFromStimuliEscapePointMaxDistance) == 0x000204, "Member 'UDBDAIPerceptionComponent::FleeFromStimuliEscapePointMaxDistance' has a wrong offset!");
static_assert(offsetof(UDBDAIPerceptionComponent, UseSimulatedCameraLocationForStimulusReceiverLocation) == 0x000208, "Member 'UDBDAIPerceptionComponent::UseSimulatedCameraLocationForStimulusReceiverLocation' has a wrong offset!");
static_assert(offsetof(UDBDAIPerceptionComponent, CameraOffset) == 0x00020C, "Member 'UDBDAIPerceptionComponent::CameraOffset' has a wrong offset!");
static_assert(offsetof(UDBDAIPerceptionComponent, StimulusHalfFOV) == 0x000210, "Member 'UDBDAIPerceptionComponent::StimulusHalfFOV' has a wrong offset!");
static_assert(offsetof(UDBDAIPerceptionComponent, OutOfChaseFullPeripheralVisionRange) == 0x000214, "Member 'UDBDAIPerceptionComponent::OutOfChaseFullPeripheralVisionRange' has a wrong offset!");
static_assert(offsetof(UDBDAIPerceptionComponent, InChaseFullPeripheralVisionRange) == 0x000218, "Member 'UDBDAIPerceptionComponent::InChaseFullPeripheralVisionRange' has a wrong offset!");
static_assert(offsetof(UDBDAIPerceptionComponent, _objOverridingSenses) == 0x000220, "Member 'UDBDAIPerceptionComponent::_objOverridingSenses' has a wrong offset!");
static_assert(offsetof(UDBDAIPerceptionComponent, _originalSenseConfigs) == 0x000270, "Member 'UDBDAIPerceptionComponent::_originalSenseConfigs' has a wrong offset!");
static_assert(offsetof(UDBDAIPerceptionComponent, _detectedHostileStimuli) == 0x000280, "Member 'UDBDAIPerceptionComponent::_detectedHostileStimuli' has a wrong offset!");
static_assert(offsetof(UDBDAIPerceptionComponent, _bestDetectedHostileStimulus) == 0x000290, "Member 'UDBDAIPerceptionComponent::_bestDetectedHostileStimulus' has a wrong offset!");
static_assert(offsetof(UDBDAIPerceptionComponent, _lastBestDetectedHostileStimulusInMemory) == 0x000378, "Member 'UDBDAIPerceptionComponent::_lastBestDetectedHostileStimulusInMemory' has a wrong offset!");
static_assert(offsetof(UDBDAIPerceptionComponent, _activePhaseWalkingNoiseMaxRange) == 0x0004D0, "Member 'UDBDAIPerceptionComponent::_activePhaseWalkingNoiseMaxRange' has a wrong offset!");
static_assert(offsetof(UDBDAIPerceptionComponent, ThreatDividerForNonControlledActor) == 0x000530, "Member 'UDBDAIPerceptionComponent::ThreatDividerForNonControlledActor' has a wrong offset!");
static_assert(offsetof(UDBDAIPerceptionComponent, HighThreatDistanceForNonControlledActor) == 0x000534, "Member 'UDBDAIPerceptionComponent::HighThreatDistanceForNonControlledActor' has a wrong offset!");
static_assert(offsetof(UDBDAIPerceptionComponent, CurrentThreatDivider) == 0x000538, "Member 'UDBDAIPerceptionComponent::CurrentThreatDivider' has a wrong offset!");
static_assert(offsetof(UDBDAIPerceptionComponent, TerrorDistanceMultiplierForNonControlledActor) == 0x00053C, "Member 'UDBDAIPerceptionComponent::TerrorDistanceMultiplierForNonControlledActor' has a wrong offset!");

// Class DBDBots.DBDAIStateComponent
// 0x03A0 (0x0448 - 0x00A8)
class UDBDAIStateComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         UnsafeStateAtHookedCount;                          // 0x00B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DireStateAtHookedCount;                            // 0x00B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MidObjectiveStateProgressionRatio;                 // 0x00B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EAIObjectiveState, struct FDangerStateGameStateMapContainer> GameStateTable;                                    // 0x00C0(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<EAIDifficultyLevel, struct FGameStatePressureZoneLevelMapContainer> PressureZoneLevelTable;                            // 0x0110(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<EAIDifficultyLevel, float>               MinRadiusPressureZoneHabituation;                  // 0x0160(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<EAIPressureZoneLevel, float>             PressureZoneHighToLowRangeLerpRatios;              // 0x01B0(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         DefaultChasedPhaseOutDuration;                     // 0x0200(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InjuredChasedPhaseOutDuration;                     // 0x0204(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultBeingAimedAtPhaseOutDuration;               // 0x0208(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InjuredBeingAimedAtPhaseOutDuration;               // 0x020C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StimulusWasInSightDuration;                        // 0x0210(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LoSFoVToStimulusCheckPeriod;                       // 0x0214(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LoSToStimulusValidDuration;                        // 0x0218(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FoVToStimulusValidDuration;                        // 0x021C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlockingSurvivorLocationLifetime;                  // 0x0220(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlockingSurvivorLocationAcceptableDistSq;          // 0x0224(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaximumBlockingSurvivorLocationDist;               // 0x0228(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NotMovingCheckInterval;                            // 0x022C(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NotMovingSpeedPercent;                             // 0x0230(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         NotMovingContinuousTimes;                          // 0x0234(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_235[0x3];                                      // 0x0235(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PrimaryChaseTargetDirectionDistanceMultiplier;     // 0x0238(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23C[0x4];                                      // 0x023C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAITunableParameter                    SpecialAttackReactionTimeMultiplier;               // 0x0240(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FGameplayTag>                   BlindPowerStateTags;                               // 0x02A0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B0[0x198];                                    // 0x02B0(0x0198)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnSpecialAttackEventDispatched(const struct FGameplayTag& GameEventType, const struct FGameEventData& GameEventData);
	void OnStartAimingEventDispatched(const struct FGameplayTag& GameEventType, const struct FGameEventData& GameEventData);
	void OnUniqueGameplayEvent(EDBDScoreTypes EventType, float Amount, class AActor* Instigator, class AActor* Target);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDAIStateComponent">();
	}
	static class UDBDAIStateComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDAIStateComponent>();
	}
};
static_assert(alignof(UDBDAIStateComponent) == 0x000008, "Wrong alignment on UDBDAIStateComponent");
static_assert(sizeof(UDBDAIStateComponent) == 0x000448, "Wrong size on UDBDAIStateComponent");
static_assert(offsetof(UDBDAIStateComponent, UnsafeStateAtHookedCount) == 0x0000B0, "Member 'UDBDAIStateComponent::UnsafeStateAtHookedCount' has a wrong offset!");
static_assert(offsetof(UDBDAIStateComponent, DireStateAtHookedCount) == 0x0000B4, "Member 'UDBDAIStateComponent::DireStateAtHookedCount' has a wrong offset!");
static_assert(offsetof(UDBDAIStateComponent, MidObjectiveStateProgressionRatio) == 0x0000B8, "Member 'UDBDAIStateComponent::MidObjectiveStateProgressionRatio' has a wrong offset!");
static_assert(offsetof(UDBDAIStateComponent, GameStateTable) == 0x0000C0, "Member 'UDBDAIStateComponent::GameStateTable' has a wrong offset!");
static_assert(offsetof(UDBDAIStateComponent, PressureZoneLevelTable) == 0x000110, "Member 'UDBDAIStateComponent::PressureZoneLevelTable' has a wrong offset!");
static_assert(offsetof(UDBDAIStateComponent, MinRadiusPressureZoneHabituation) == 0x000160, "Member 'UDBDAIStateComponent::MinRadiusPressureZoneHabituation' has a wrong offset!");
static_assert(offsetof(UDBDAIStateComponent, PressureZoneHighToLowRangeLerpRatios) == 0x0001B0, "Member 'UDBDAIStateComponent::PressureZoneHighToLowRangeLerpRatios' has a wrong offset!");
static_assert(offsetof(UDBDAIStateComponent, DefaultChasedPhaseOutDuration) == 0x000200, "Member 'UDBDAIStateComponent::DefaultChasedPhaseOutDuration' has a wrong offset!");
static_assert(offsetof(UDBDAIStateComponent, InjuredChasedPhaseOutDuration) == 0x000204, "Member 'UDBDAIStateComponent::InjuredChasedPhaseOutDuration' has a wrong offset!");
static_assert(offsetof(UDBDAIStateComponent, DefaultBeingAimedAtPhaseOutDuration) == 0x000208, "Member 'UDBDAIStateComponent::DefaultBeingAimedAtPhaseOutDuration' has a wrong offset!");
static_assert(offsetof(UDBDAIStateComponent, InjuredBeingAimedAtPhaseOutDuration) == 0x00020C, "Member 'UDBDAIStateComponent::InjuredBeingAimedAtPhaseOutDuration' has a wrong offset!");
static_assert(offsetof(UDBDAIStateComponent, StimulusWasInSightDuration) == 0x000210, "Member 'UDBDAIStateComponent::StimulusWasInSightDuration' has a wrong offset!");
static_assert(offsetof(UDBDAIStateComponent, LoSFoVToStimulusCheckPeriod) == 0x000214, "Member 'UDBDAIStateComponent::LoSFoVToStimulusCheckPeriod' has a wrong offset!");
static_assert(offsetof(UDBDAIStateComponent, LoSToStimulusValidDuration) == 0x000218, "Member 'UDBDAIStateComponent::LoSToStimulusValidDuration' has a wrong offset!");
static_assert(offsetof(UDBDAIStateComponent, FoVToStimulusValidDuration) == 0x00021C, "Member 'UDBDAIStateComponent::FoVToStimulusValidDuration' has a wrong offset!");
static_assert(offsetof(UDBDAIStateComponent, BlockingSurvivorLocationLifetime) == 0x000220, "Member 'UDBDAIStateComponent::BlockingSurvivorLocationLifetime' has a wrong offset!");
static_assert(offsetof(UDBDAIStateComponent, BlockingSurvivorLocationAcceptableDistSq) == 0x000224, "Member 'UDBDAIStateComponent::BlockingSurvivorLocationAcceptableDistSq' has a wrong offset!");
static_assert(offsetof(UDBDAIStateComponent, MaximumBlockingSurvivorLocationDist) == 0x000228, "Member 'UDBDAIStateComponent::MaximumBlockingSurvivorLocationDist' has a wrong offset!");
static_assert(offsetof(UDBDAIStateComponent, NotMovingCheckInterval) == 0x00022C, "Member 'UDBDAIStateComponent::NotMovingCheckInterval' has a wrong offset!");
static_assert(offsetof(UDBDAIStateComponent, NotMovingSpeedPercent) == 0x000230, "Member 'UDBDAIStateComponent::NotMovingSpeedPercent' has a wrong offset!");
static_assert(offsetof(UDBDAIStateComponent, NotMovingContinuousTimes) == 0x000234, "Member 'UDBDAIStateComponent::NotMovingContinuousTimes' has a wrong offset!");
static_assert(offsetof(UDBDAIStateComponent, PrimaryChaseTargetDirectionDistanceMultiplier) == 0x000238, "Member 'UDBDAIStateComponent::PrimaryChaseTargetDirectionDistanceMultiplier' has a wrong offset!");
static_assert(offsetof(UDBDAIStateComponent, SpecialAttackReactionTimeMultiplier) == 0x000240, "Member 'UDBDAIStateComponent::SpecialAttackReactionTimeMultiplier' has a wrong offset!");
static_assert(offsetof(UDBDAIStateComponent, BlindPowerStateTags) == 0x0002A0, "Member 'UDBDAIStateComponent::BlindPowerStateTags' has a wrong offset!");

// Class DBDBots.DBDBehaviorTreeComponent
// 0x0068 (0x0300 - 0x0298)
class UDBDBehaviorTreeComponent final : public UBehaviorTreeComponent
{
public:
	uint8                                         Pad_298[0x8];                                      // 0x0298(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class UClass*, struct FRelevantNodeMemory> _lastRelevantNodeMemories;                         // 0x02A0(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TArray<class UObject*>                        _createdObjects;                                   // 0x02F0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDBehaviorTreeComponent">();
	}
	static class UDBDBehaviorTreeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDBehaviorTreeComponent>();
	}
};
static_assert(alignof(UDBDBehaviorTreeComponent) == 0x000008, "Wrong alignment on UDBDBehaviorTreeComponent");
static_assert(sizeof(UDBDBehaviorTreeComponent) == 0x000300, "Wrong size on UDBDBehaviorTreeComponent");
static_assert(offsetof(UDBDBehaviorTreeComponent, _lastRelevantNodeMemories) == 0x0002A0, "Member 'UDBDBehaviorTreeComponent::_lastRelevantNodeMemories' has a wrong offset!");
static_assert(offsetof(UDBDBehaviorTreeComponent, _createdObjects) == 0x0002F0, "Member 'UDBDBehaviorTreeComponent::_createdObjects' has a wrong offset!");

// Class DBDBots.DBDBlackboardComponent
// 0x0298 (0x0448 - 0x01B0)
class UDBDBlackboardComponent final : public UBlackboardComponent
{
public:
	uint8                                         Pad_1B0[0x8];                                      // 0x01B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class UObject*, struct FMindFocusObjectEntry> _mindFocusEntries;                                 // 0x01B8(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMap<struct FGameplayTag, struct FVector>     _pinLocations;                                     // 0x0208(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMap<struct FGameplayTag, class UObject*>     _pinObjects;                                       // 0x0258(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMap<class UObject*, float>                   _lostMindFocusEntries;                             // 0x02A8(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMap<struct FGameplayTag, struct FWeightedWishedObjectMapContainer> _objectWishListMap;                                // 0x02F8(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TSet<class UObject*>                          _discoveredObjects;                                // 0x0348(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TSet<class UObject*>                          _intentionValidators;                              // 0x0398(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TSet<class APallet*>                          _convincingDreamPallets;                           // 0x03E8(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TArray<class UAISkill*>                       _dropItemLocks;                                    // 0x0438(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDBlackboardComponent">();
	}
	static class UDBDBlackboardComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDBlackboardComponent>();
	}
};
static_assert(alignof(UDBDBlackboardComponent) == 0x000008, "Wrong alignment on UDBDBlackboardComponent");
static_assert(sizeof(UDBDBlackboardComponent) == 0x000448, "Wrong size on UDBDBlackboardComponent");
static_assert(offsetof(UDBDBlackboardComponent, _mindFocusEntries) == 0x0001B8, "Member 'UDBDBlackboardComponent::_mindFocusEntries' has a wrong offset!");
static_assert(offsetof(UDBDBlackboardComponent, _pinLocations) == 0x000208, "Member 'UDBDBlackboardComponent::_pinLocations' has a wrong offset!");
static_assert(offsetof(UDBDBlackboardComponent, _pinObjects) == 0x000258, "Member 'UDBDBlackboardComponent::_pinObjects' has a wrong offset!");
static_assert(offsetof(UDBDBlackboardComponent, _lostMindFocusEntries) == 0x0002A8, "Member 'UDBDBlackboardComponent::_lostMindFocusEntries' has a wrong offset!");
static_assert(offsetof(UDBDBlackboardComponent, _objectWishListMap) == 0x0002F8, "Member 'UDBDBlackboardComponent::_objectWishListMap' has a wrong offset!");
static_assert(offsetof(UDBDBlackboardComponent, _discoveredObjects) == 0x000348, "Member 'UDBDBlackboardComponent::_discoveredObjects' has a wrong offset!");
static_assert(offsetof(UDBDBlackboardComponent, _intentionValidators) == 0x000398, "Member 'UDBDBlackboardComponent::_intentionValidators' has a wrong offset!");
static_assert(offsetof(UDBDBlackboardComponent, _convincingDreamPallets) == 0x0003E8, "Member 'UDBDBlackboardComponent::_convincingDreamPallets' has a wrong offset!");
static_assert(offsetof(UDBDBlackboardComponent, _dropItemLocks) == 0x000438, "Member 'UDBDBlackboardComponent::_dropItemLocks' has a wrong offset!");

// Class DBDBots.DBDNavLinkCustomComponent
// 0x00A8 (0x0280 - 0x01D8)
class UDBDNavLinkCustomComponent final : public UNavLinkCustomComponent
{
public:
	bool                                          UseRelativeLinkEndPoint;                           // 0x01D8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D9[0x7];                                      // 0x01D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                BaseLinkRelativeStart;                             // 0x01E0(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BaseLinkRelativeEnd;                               // 0x01F8(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BaseLinkWorldEnd;                                  // 0x0210(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ENavLinkDirection                             BaseLinkDirection;                                 // 0x0228(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_229[0x3];                                      // 0x0229(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AutoSnapSmartLinkPointsUpHeight;                   // 0x022C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoSnapSmartLinkPointsDownHeight;                 // 0x0230(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             AutoSnapCollisionChannel;                          // 0x0234(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_235[0x3];                                      // 0x0235(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AutoSmartLinkDirectionMaxHeight;                   // 0x0238(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DisableSmartLinkOnPathObstruction;                 // 0x023C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23D[0x3];                                      // 0x023D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PathObstructionTestDistance;                       // 0x0240(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PathObstructionTestShapeRadius;                    // 0x0244(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PathObstructionTestHeightOffset;                   // 0x0248(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             PathObstructionCollisionChannel;                   // 0x024C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DisableOtherSmartLinkInProximityOnEnable;          // 0x024D(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnableOtherSmartLinkInProximityOnDisable;          // 0x024E(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24F[0x1];                                      // 0x024F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OtherSmartLinkInProximitySearchDistance;           // 0x0250(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShowDebugInfo;                                     // 0x0254(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_255[0x1B];                                     // 0x0255(0x001B)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ANavLinkProxy*>                  _navLinkProxyInProximity;                          // 0x0270(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	void OnLevelReadyToPlay();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDNavLinkCustomComponent">();
	}
	static class UDBDNavLinkCustomComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDNavLinkCustomComponent>();
	}
};
static_assert(alignof(UDBDNavLinkCustomComponent) == 0x000008, "Wrong alignment on UDBDNavLinkCustomComponent");
static_assert(sizeof(UDBDNavLinkCustomComponent) == 0x000280, "Wrong size on UDBDNavLinkCustomComponent");
static_assert(offsetof(UDBDNavLinkCustomComponent, UseRelativeLinkEndPoint) == 0x0001D8, "Member 'UDBDNavLinkCustomComponent::UseRelativeLinkEndPoint' has a wrong offset!");
static_assert(offsetof(UDBDNavLinkCustomComponent, BaseLinkRelativeStart) == 0x0001E0, "Member 'UDBDNavLinkCustomComponent::BaseLinkRelativeStart' has a wrong offset!");
static_assert(offsetof(UDBDNavLinkCustomComponent, BaseLinkRelativeEnd) == 0x0001F8, "Member 'UDBDNavLinkCustomComponent::BaseLinkRelativeEnd' has a wrong offset!");
static_assert(offsetof(UDBDNavLinkCustomComponent, BaseLinkWorldEnd) == 0x000210, "Member 'UDBDNavLinkCustomComponent::BaseLinkWorldEnd' has a wrong offset!");
static_assert(offsetof(UDBDNavLinkCustomComponent, BaseLinkDirection) == 0x000228, "Member 'UDBDNavLinkCustomComponent::BaseLinkDirection' has a wrong offset!");
static_assert(offsetof(UDBDNavLinkCustomComponent, AutoSnapSmartLinkPointsUpHeight) == 0x00022C, "Member 'UDBDNavLinkCustomComponent::AutoSnapSmartLinkPointsUpHeight' has a wrong offset!");
static_assert(offsetof(UDBDNavLinkCustomComponent, AutoSnapSmartLinkPointsDownHeight) == 0x000230, "Member 'UDBDNavLinkCustomComponent::AutoSnapSmartLinkPointsDownHeight' has a wrong offset!");
static_assert(offsetof(UDBDNavLinkCustomComponent, AutoSnapCollisionChannel) == 0x000234, "Member 'UDBDNavLinkCustomComponent::AutoSnapCollisionChannel' has a wrong offset!");
static_assert(offsetof(UDBDNavLinkCustomComponent, AutoSmartLinkDirectionMaxHeight) == 0x000238, "Member 'UDBDNavLinkCustomComponent::AutoSmartLinkDirectionMaxHeight' has a wrong offset!");
static_assert(offsetof(UDBDNavLinkCustomComponent, DisableSmartLinkOnPathObstruction) == 0x00023C, "Member 'UDBDNavLinkCustomComponent::DisableSmartLinkOnPathObstruction' has a wrong offset!");
static_assert(offsetof(UDBDNavLinkCustomComponent, PathObstructionTestDistance) == 0x000240, "Member 'UDBDNavLinkCustomComponent::PathObstructionTestDistance' has a wrong offset!");
static_assert(offsetof(UDBDNavLinkCustomComponent, PathObstructionTestShapeRadius) == 0x000244, "Member 'UDBDNavLinkCustomComponent::PathObstructionTestShapeRadius' has a wrong offset!");
static_assert(offsetof(UDBDNavLinkCustomComponent, PathObstructionTestHeightOffset) == 0x000248, "Member 'UDBDNavLinkCustomComponent::PathObstructionTestHeightOffset' has a wrong offset!");
static_assert(offsetof(UDBDNavLinkCustomComponent, PathObstructionCollisionChannel) == 0x00024C, "Member 'UDBDNavLinkCustomComponent::PathObstructionCollisionChannel' has a wrong offset!");
static_assert(offsetof(UDBDNavLinkCustomComponent, DisableOtherSmartLinkInProximityOnEnable) == 0x00024D, "Member 'UDBDNavLinkCustomComponent::DisableOtherSmartLinkInProximityOnEnable' has a wrong offset!");
static_assert(offsetof(UDBDNavLinkCustomComponent, EnableOtherSmartLinkInProximityOnDisable) == 0x00024E, "Member 'UDBDNavLinkCustomComponent::EnableOtherSmartLinkInProximityOnDisable' has a wrong offset!");
static_assert(offsetof(UDBDNavLinkCustomComponent, OtherSmartLinkInProximitySearchDistance) == 0x000250, "Member 'UDBDNavLinkCustomComponent::OtherSmartLinkInProximitySearchDistance' has a wrong offset!");
static_assert(offsetof(UDBDNavLinkCustomComponent, ShowDebugInfo) == 0x000254, "Member 'UDBDNavLinkCustomComponent::ShowDebugInfo' has a wrong offset!");
static_assert(offsetof(UDBDNavLinkCustomComponent, _navLinkProxyInProximity) == 0x000270, "Member 'UDBDNavLinkCustomComponent::_navLinkProxyInProximity' has a wrong offset!");

// Class DBDBots.DBDNavMeshExplorerComponent
// 0x00E8 (0x0190 - 0x00A8)
class UDBDNavMeshExplorerComponent final : public UActorComponent
{
public:
	float                                         ExploreAtAgentMoveDistance;                        // 0x00A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExploreAtInterval;                                 // 0x00AC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    ExplorationBoxHalfExtent;                          // 0x00B0(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         FullyAutoExploredAtGameTime;                       // 0x0110(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_114[0x4];                                      // 0x0114(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UDBDPathFollowingComponent*             _pathFollowingComponent;                           // 0x0118(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_120[0x70];                                     // 0x0120(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDNavMeshExplorerComponent">();
	}
	static class UDBDNavMeshExplorerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDNavMeshExplorerComponent>();
	}
};
static_assert(alignof(UDBDNavMeshExplorerComponent) == 0x000008, "Wrong alignment on UDBDNavMeshExplorerComponent");
static_assert(sizeof(UDBDNavMeshExplorerComponent) == 0x000190, "Wrong size on UDBDNavMeshExplorerComponent");
static_assert(offsetof(UDBDNavMeshExplorerComponent, ExploreAtAgentMoveDistance) == 0x0000A8, "Member 'UDBDNavMeshExplorerComponent::ExploreAtAgentMoveDistance' has a wrong offset!");
static_assert(offsetof(UDBDNavMeshExplorerComponent, ExploreAtInterval) == 0x0000AC, "Member 'UDBDNavMeshExplorerComponent::ExploreAtInterval' has a wrong offset!");
static_assert(offsetof(UDBDNavMeshExplorerComponent, ExplorationBoxHalfExtent) == 0x0000B0, "Member 'UDBDNavMeshExplorerComponent::ExplorationBoxHalfExtent' has a wrong offset!");
static_assert(offsetof(UDBDNavMeshExplorerComponent, FullyAutoExploredAtGameTime) == 0x000110, "Member 'UDBDNavMeshExplorerComponent::FullyAutoExploredAtGameTime' has a wrong offset!");
static_assert(offsetof(UDBDNavMeshExplorerComponent, _pathFollowingComponent) == 0x000118, "Member 'UDBDNavMeshExplorerComponent::_pathFollowingComponent' has a wrong offset!");

// Class DBDBots.DBDNavObstacle
// 0x0068 (0x0098 - 0x0030)
class UDBDNavObstacle final : public UObject
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FNavObstacleEdge>               _edges;                                            // 0x0038(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<struct FNavObstacleEdgeRow>            _edgeMatrix;                                       // 0x0048(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_58[0x40];                                      // 0x0058(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDNavObstacle">();
	}
	static class UDBDNavObstacle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDNavObstacle>();
	}
};
static_assert(alignof(UDBDNavObstacle) == 0x000008, "Wrong alignment on UDBDNavObstacle");
static_assert(sizeof(UDBDNavObstacle) == 0x000098, "Wrong size on UDBDNavObstacle");
static_assert(offsetof(UDBDNavObstacle, _edges) == 0x000038, "Member 'UDBDNavObstacle::_edges' has a wrong offset!");
static_assert(offsetof(UDBDNavObstacle, _edgeMatrix) == 0x000048, "Member 'UDBDNavObstacle::_edgeMatrix' has a wrong offset!");

// Class DBDBots.DBDNavObstacleAnalysisComponent
// 0x0098 (0x0140 - 0x00A8)
class UDBDNavObstacleAnalysisComponent final : public UActorComponent
{
public:
	bool                                          IsSupported;                                       // 0x00A8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x3];                                       // 0x00A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CloseLoopRadius;                                   // 0x00AC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialMergeObstacleRadius;                        // 0x00B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxMergeObstacleRadius;                            // 0x00B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MergeObstacleRadiusMultiplierPerStep;              // 0x00B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ObstacleMatrixCellSize;                            // 0x00BC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        _edgeVertices;                                     // 0x00C0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D0[0x8];                                       // 0x00D0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UDBDNavObstacle*>                _incompleteNavObstacles;                           // 0x00D8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class UDBDNavObstacle*>                _navObstacles;                                     // 0x00E8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class UNavObstacleMatrix*                     _navObstacleMatrix;                                // 0x00F8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_100[0x40];                                     // 0x0100(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnLevelReadyToPlay();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDNavObstacleAnalysisComponent">();
	}
	static class UDBDNavObstacleAnalysisComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDNavObstacleAnalysisComponent>();
	}
};
static_assert(alignof(UDBDNavObstacleAnalysisComponent) == 0x000008, "Wrong alignment on UDBDNavObstacleAnalysisComponent");
static_assert(sizeof(UDBDNavObstacleAnalysisComponent) == 0x000140, "Wrong size on UDBDNavObstacleAnalysisComponent");
static_assert(offsetof(UDBDNavObstacleAnalysisComponent, IsSupported) == 0x0000A8, "Member 'UDBDNavObstacleAnalysisComponent::IsSupported' has a wrong offset!");
static_assert(offsetof(UDBDNavObstacleAnalysisComponent, CloseLoopRadius) == 0x0000AC, "Member 'UDBDNavObstacleAnalysisComponent::CloseLoopRadius' has a wrong offset!");
static_assert(offsetof(UDBDNavObstacleAnalysisComponent, InitialMergeObstacleRadius) == 0x0000B0, "Member 'UDBDNavObstacleAnalysisComponent::InitialMergeObstacleRadius' has a wrong offset!");
static_assert(offsetof(UDBDNavObstacleAnalysisComponent, MaxMergeObstacleRadius) == 0x0000B4, "Member 'UDBDNavObstacleAnalysisComponent::MaxMergeObstacleRadius' has a wrong offset!");
static_assert(offsetof(UDBDNavObstacleAnalysisComponent, MergeObstacleRadiusMultiplierPerStep) == 0x0000B8, "Member 'UDBDNavObstacleAnalysisComponent::MergeObstacleRadiusMultiplierPerStep' has a wrong offset!");
static_assert(offsetof(UDBDNavObstacleAnalysisComponent, ObstacleMatrixCellSize) == 0x0000BC, "Member 'UDBDNavObstacleAnalysisComponent::ObstacleMatrixCellSize' has a wrong offset!");
static_assert(offsetof(UDBDNavObstacleAnalysisComponent, _edgeVertices) == 0x0000C0, "Member 'UDBDNavObstacleAnalysisComponent::_edgeVertices' has a wrong offset!");
static_assert(offsetof(UDBDNavObstacleAnalysisComponent, _incompleteNavObstacles) == 0x0000D8, "Member 'UDBDNavObstacleAnalysisComponent::_incompleteNavObstacles' has a wrong offset!");
static_assert(offsetof(UDBDNavObstacleAnalysisComponent, _navObstacles) == 0x0000E8, "Member 'UDBDNavObstacleAnalysisComponent::_navObstacles' has a wrong offset!");
static_assert(offsetof(UDBDNavObstacleAnalysisComponent, _navObstacleMatrix) == 0x0000F8, "Member 'UDBDNavObstacleAnalysisComponent::_navObstacleMatrix' has a wrong offset!");

// Class DBDBots.DBDPathFollowingComponent
// 0x0270 (0x0540 - 0x02D0)
class UDBDPathFollowingComponent final : public UPathFollowingComponent
{
public:
	uint8                                         Pad_2D0[0x10];                                     // 0x02D0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UnblockPathDeviationRadius;                        // 0x02E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UnblockPathTimeLimit;                              // 0x02E4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UnblockPathReachDistance;                          // 0x02E8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2EC[0x164];                                    // 0x02EC(0x0164)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class ANavLinkProxy*>                    _onNavLinkProxies;                                 // 0x0450(0x0050)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4A0[0xA0];                                     // 0x04A0(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDPathFollowingComponent">();
	}
	static class UDBDPathFollowingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDPathFollowingComponent>();
	}
};
static_assert(alignof(UDBDPathFollowingComponent) == 0x000008, "Wrong alignment on UDBDPathFollowingComponent");
static_assert(sizeof(UDBDPathFollowingComponent) == 0x000540, "Wrong size on UDBDPathFollowingComponent");
static_assert(offsetof(UDBDPathFollowingComponent, UnblockPathDeviationRadius) == 0x0002E0, "Member 'UDBDPathFollowingComponent::UnblockPathDeviationRadius' has a wrong offset!");
static_assert(offsetof(UDBDPathFollowingComponent, UnblockPathTimeLimit) == 0x0002E4, "Member 'UDBDPathFollowingComponent::UnblockPathTimeLimit' has a wrong offset!");
static_assert(offsetof(UDBDPathFollowingComponent, UnblockPathReachDistance) == 0x0002E8, "Member 'UDBDPathFollowingComponent::UnblockPathReachDistance' has a wrong offset!");
static_assert(offsetof(UDBDPathFollowingComponent, _onNavLinkProxies) == 0x000450, "Member 'UDBDPathFollowingComponent::_onNavLinkProxies' has a wrong offset!");

// Class DBDBots.EnvQueryContext_CenterOfMap
// 0x0000 (0x0030 - 0x0030)
class UEnvQueryContext_CenterOfMap final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryContext_CenterOfMap">();
	}
	static class UEnvQueryContext_CenterOfMap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryContext_CenterOfMap>();
	}
};
static_assert(alignof(UEnvQueryContext_CenterOfMap) == 0x000008, "Wrong alignment on UEnvQueryContext_CenterOfMap");
static_assert(sizeof(UEnvQueryContext_CenterOfMap) == 0x000030, "Wrong size on UEnvQueryContext_CenterOfMap");

// Class DBDBots.EnvQueryContext_EscapeDoors
// 0x0000 (0x0030 - 0x0030)
class UEnvQueryContext_EscapeDoors final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryContext_EscapeDoors">();
	}
	static class UEnvQueryContext_EscapeDoors* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryContext_EscapeDoors>();
	}
};
static_assert(alignof(UEnvQueryContext_EscapeDoors) == 0x000008, "Wrong alignment on UEnvQueryContext_EscapeDoors");
static_assert(sizeof(UEnvQueryContext_EscapeDoors) == 0x000030, "Wrong size on UEnvQueryContext_EscapeDoors");

// Class DBDBots.EnvQueryContext_Generators
// 0x0000 (0x0030 - 0x0030)
class UEnvQueryContext_Generators final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryContext_Generators">();
	}
	static class UEnvQueryContext_Generators* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryContext_Generators>();
	}
};
static_assert(alignof(UEnvQueryContext_Generators) == 0x000008, "Wrong alignment on UEnvQueryContext_Generators");
static_assert(sizeof(UEnvQueryContext_Generators) == 0x000030, "Wrong size on UEnvQueryContext_Generators");

// Class DBDBots.EnvQueryContext_Hooks
// 0x0000 (0x0030 - 0x0030)
class UEnvQueryContext_Hooks final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryContext_Hooks">();
	}
	static class UEnvQueryContext_Hooks* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryContext_Hooks>();
	}
};
static_assert(alignof(UEnvQueryContext_Hooks) == 0x000008, "Wrong alignment on UEnvQueryContext_Hooks");
static_assert(sizeof(UEnvQueryContext_Hooks) == 0x000030, "Wrong size on UEnvQueryContext_Hooks");

// Class DBDBots.EnvQueryContext_IncompleteGenerators
// 0x0000 (0x0030 - 0x0030)
class UEnvQueryContext_IncompleteGenerators final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryContext_IncompleteGenerators">();
	}
	static class UEnvQueryContext_IncompleteGenerators* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryContext_IncompleteGenerators>();
	}
};
static_assert(alignof(UEnvQueryContext_IncompleteGenerators) == 0x000008, "Wrong alignment on UEnvQueryContext_IncompleteGenerators");
static_assert(sizeof(UEnvQueryContext_IncompleteGenerators) == 0x000030, "Wrong size on UEnvQueryContext_IncompleteGenerators");

// Class DBDBots.EnvQueryContext_K33ControlStations
// 0x0000 (0x0030 - 0x0030)
class UEnvQueryContext_K33ControlStations final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryContext_K33ControlStations">();
	}
	static class UEnvQueryContext_K33ControlStations* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryContext_K33ControlStations>();
	}
};
static_assert(alignof(UEnvQueryContext_K33ControlStations) == 0x000008, "Wrong alignment on UEnvQueryContext_K33ControlStations");
static_assert(sizeof(UEnvQueryContext_K33ControlStations) == 0x000030, "Wrong size on UEnvQueryContext_K33ControlStations");

// Class DBDBots.EnvQueryContext_Lockers
// 0x0000 (0x0030 - 0x0030)
class UEnvQueryContext_Lockers final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryContext_Lockers">();
	}
	static class UEnvQueryContext_Lockers* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryContext_Lockers>();
	}
};
static_assert(alignof(UEnvQueryContext_Lockers) == 0x000008, "Wrong alignment on UEnvQueryContext_Lockers");
static_assert(sizeof(UEnvQueryContext_Lockers) == 0x000030, "Wrong size on UEnvQueryContext_Lockers");

// Class DBDBots.EnvQueryContext_PinActor
// 0x0000 (0x0030 - 0x0030)
class UEnvQueryContext_PinActor final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryContext_PinActor">();
	}
	static class UEnvQueryContext_PinActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryContext_PinActor>();
	}
};
static_assert(alignof(UEnvQueryContext_PinActor) == 0x000008, "Wrong alignment on UEnvQueryContext_PinActor");
static_assert(sizeof(UEnvQueryContext_PinActor) == 0x000030, "Wrong size on UEnvQueryContext_PinActor");

// Class DBDBots.EnvQueryContext_TerrorRadius
// 0x0000 (0x0030 - 0x0030)
class UEnvQueryContext_TerrorRadius final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryContext_TerrorRadius">();
	}
	static class UEnvQueryContext_TerrorRadius* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryContext_TerrorRadius>();
	}
};
static_assert(alignof(UEnvQueryContext_TerrorRadius) == 0x000008, "Wrong alignment on UEnvQueryContext_TerrorRadius");
static_assert(sizeof(UEnvQueryContext_TerrorRadius) == 0x000030, "Wrong size on UEnvQueryContext_TerrorRadius");

// Class DBDBots.EnvQueryTest_AwayFromHostileStimuli
// 0x0088 (0x02C0 - 0x0238)
class UEnvQueryTest_AwayFromHostileStimuli final : public UEnvQueryTest
{
public:
	TSubclassOf<class UEnvQueryContext>           QuerierContext;                                    // 0x0238(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAIDataProviderBoolValue               Invert;                                            // 0x0240(0x0040)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIDataProviderFloatValue              MaxFleeDirectionAngle;                             // 0x0280(0x0040)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryTest_AwayFromHostileStimuli">();
	}
	static class UEnvQueryTest_AwayFromHostileStimuli* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryTest_AwayFromHostileStimuli>();
	}
};
static_assert(alignof(UEnvQueryTest_AwayFromHostileStimuli) == 0x000008, "Wrong alignment on UEnvQueryTest_AwayFromHostileStimuli");
static_assert(sizeof(UEnvQueryTest_AwayFromHostileStimuli) == 0x0002C0, "Wrong size on UEnvQueryTest_AwayFromHostileStimuli");
static_assert(offsetof(UEnvQueryTest_AwayFromHostileStimuli, QuerierContext) == 0x000238, "Member 'UEnvQueryTest_AwayFromHostileStimuli::QuerierContext' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_AwayFromHostileStimuli, Invert) == 0x000240, "Member 'UEnvQueryTest_AwayFromHostileStimuli::Invert' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_AwayFromHostileStimuli, MaxFleeDirectionAngle) == 0x000280, "Member 'UEnvQueryTest_AwayFromHostileStimuli::MaxFleeDirectionAngle' has a wrong offset!");

// Class DBDBots.EnvQueryTest_Basement
// 0x0180 (0x03B8 - 0x0238)
class UEnvQueryTest_Basement final : public UEnvQueryTest
{
public:
	TSubclassOf<class UEnvQueryContext>           QuerierContext;                                    // 0x0238(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAIDataProviderFloatValue              BasementBottomPenalty;                             // 0x0240(0x0040)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIDataProviderBoolValue               ApplyEnteringPenaltyIfAlreadyInside;               // 0x0280(0x0040)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIDataProviderFloatValue              EnteringBasementFixedPenalty;                      // 0x02C0(0x0040)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIDataProviderBoolValue               Invert;                                            // 0x0300(0x0040)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIDataProviderFloatValue              BasementBoxExtentShrink;                           // 0x0340(0x0040)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_380[0x38];                                     // 0x0380(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryTest_Basement">();
	}
	static class UEnvQueryTest_Basement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryTest_Basement>();
	}
};
static_assert(alignof(UEnvQueryTest_Basement) == 0x000008, "Wrong alignment on UEnvQueryTest_Basement");
static_assert(sizeof(UEnvQueryTest_Basement) == 0x0003B8, "Wrong size on UEnvQueryTest_Basement");
static_assert(offsetof(UEnvQueryTest_Basement, QuerierContext) == 0x000238, "Member 'UEnvQueryTest_Basement::QuerierContext' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_Basement, BasementBottomPenalty) == 0x000240, "Member 'UEnvQueryTest_Basement::BasementBottomPenalty' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_Basement, ApplyEnteringPenaltyIfAlreadyInside) == 0x000280, "Member 'UEnvQueryTest_Basement::ApplyEnteringPenaltyIfAlreadyInside' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_Basement, EnteringBasementFixedPenalty) == 0x0002C0, "Member 'UEnvQueryTest_Basement::EnteringBasementFixedPenalty' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_Basement, Invert) == 0x000300, "Member 'UEnvQueryTest_Basement::Invert' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_Basement, BasementBoxExtentShrink) == 0x000340, "Member 'UEnvQueryTest_Basement::BasementBoxExtentShrink' has a wrong offset!");

// Class DBDBots.EnvQueryTest_IsInDangerObjectRange
// 0x01C8 (0x0400 - 0x0238)
class UEnvQueryTest_IsInDangerObjectRange final : public UEnvQueryTest
{
public:
	TSubclassOf<class UEnvQueryContext>           QuerierContext;                                    // 0x0238(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAIDataProviderBoolValue               Invert;                                            // 0x0240(0x0040)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIDataProviderBoolValue               MustHaveDangerVision;                              // 0x0280(0x0040)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIDataProviderBoolValue               CheckIfAnyBodyPartInDangerArea;                    // 0x02C0(0x0040)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIDataProviderBoolValue               UseCrouchHeight;                                   // 0x0300(0x0040)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIDataProviderFloatValue              SurvivorStandHeight;                               // 0x0340(0x0040)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIDataProviderFloatValue              SurvivorCrouchHeight;                              // 0x0380(0x0040)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIDataProviderFloatValue              SurvivorRadius;                                    // 0x03C0(0x0040)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryTest_IsInDangerObjectRange">();
	}
	static class UEnvQueryTest_IsInDangerObjectRange* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryTest_IsInDangerObjectRange>();
	}
};
static_assert(alignof(UEnvQueryTest_IsInDangerObjectRange) == 0x000008, "Wrong alignment on UEnvQueryTest_IsInDangerObjectRange");
static_assert(sizeof(UEnvQueryTest_IsInDangerObjectRange) == 0x000400, "Wrong size on UEnvQueryTest_IsInDangerObjectRange");
static_assert(offsetof(UEnvQueryTest_IsInDangerObjectRange, QuerierContext) == 0x000238, "Member 'UEnvQueryTest_IsInDangerObjectRange::QuerierContext' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_IsInDangerObjectRange, Invert) == 0x000240, "Member 'UEnvQueryTest_IsInDangerObjectRange::Invert' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_IsInDangerObjectRange, MustHaveDangerVision) == 0x000280, "Member 'UEnvQueryTest_IsInDangerObjectRange::MustHaveDangerVision' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_IsInDangerObjectRange, CheckIfAnyBodyPartInDangerArea) == 0x0002C0, "Member 'UEnvQueryTest_IsInDangerObjectRange::CheckIfAnyBodyPartInDangerArea' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_IsInDangerObjectRange, UseCrouchHeight) == 0x000300, "Member 'UEnvQueryTest_IsInDangerObjectRange::UseCrouchHeight' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_IsInDangerObjectRange, SurvivorStandHeight) == 0x000340, "Member 'UEnvQueryTest_IsInDangerObjectRange::SurvivorStandHeight' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_IsInDangerObjectRange, SurvivorCrouchHeight) == 0x000380, "Member 'UEnvQueryTest_IsInDangerObjectRange::SurvivorCrouchHeight' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_IsInDangerObjectRange, SurvivorRadius) == 0x0003C0, "Member 'UEnvQueryTest_IsInDangerObjectRange::SurvivorRadius' has a wrong offset!");

// Class DBDBots.EnvQueryTest_IsValidDestination
// 0x0100 (0x0338 - 0x0238)
class UEnvQueryTest_IsValidDestination final : public UEnvQueryTest
{
public:
	TSubclassOf<class UEnvQueryContext>           QuerierContext;                                    // 0x0238(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAIDataProviderBoolValue               Invert;                                            // 0x0240(0x0040)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIDataProviderBoolValue               ExcludeEscapeZoneIfReverseBearTrapIsActivated;     // 0x0280(0x0040)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIDataProviderBoolValue               CheckDestinationOnDifferentNavMesh;                // 0x02C0(0x0040)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class FName                                   NavDataAgentName;                                  // 0x0300(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30C[0x4];                                      // 0x030C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                NavMeshProjectionBoxExtent;                        // 0x0310(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_328[0x10];                                     // 0x0328(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryTest_IsValidDestination">();
	}
	static class UEnvQueryTest_IsValidDestination* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryTest_IsValidDestination>();
	}
};
static_assert(alignof(UEnvQueryTest_IsValidDestination) == 0x000008, "Wrong alignment on UEnvQueryTest_IsValidDestination");
static_assert(sizeof(UEnvQueryTest_IsValidDestination) == 0x000338, "Wrong size on UEnvQueryTest_IsValidDestination");
static_assert(offsetof(UEnvQueryTest_IsValidDestination, QuerierContext) == 0x000238, "Member 'UEnvQueryTest_IsValidDestination::QuerierContext' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_IsValidDestination, Invert) == 0x000240, "Member 'UEnvQueryTest_IsValidDestination::Invert' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_IsValidDestination, ExcludeEscapeZoneIfReverseBearTrapIsActivated) == 0x000280, "Member 'UEnvQueryTest_IsValidDestination::ExcludeEscapeZoneIfReverseBearTrapIsActivated' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_IsValidDestination, CheckDestinationOnDifferentNavMesh) == 0x0002C0, "Member 'UEnvQueryTest_IsValidDestination::CheckDestinationOnDifferentNavMesh' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_IsValidDestination, NavDataAgentName) == 0x000300, "Member 'UEnvQueryTest_IsValidDestination::NavDataAgentName' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_IsValidDestination, NavMeshProjectionBoxExtent) == 0x000310, "Member 'UEnvQueryTest_IsValidDestination::NavMeshProjectionBoxExtent' has a wrong offset!");

// Class DBDBots.EnvQueryTest_LineOfSight
// 0x0120 (0x0358 - 0x0238)
class UEnvQueryTest_LineOfSight final : public UEnvQueryTest
{
public:
	TSubclassOf<class UEnvQueryContext>           QuerierContext;                                    // 0x0238(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UEnvQueryContext>           ToContext;                                         // 0x0240(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAIDataProviderFloatValue              ItemHeightOffset;                                  // 0x0248(0x0040)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIDataProviderBoolValue               Invert;                                            // 0x0288(0x0040)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIDataProviderBoolValue               EnableToContextAttachParent;                       // 0x02C8(0x0040)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_308[0x50];                                     // 0x0308(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryTest_LineOfSight">();
	}
	static class UEnvQueryTest_LineOfSight* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryTest_LineOfSight>();
	}
};
static_assert(alignof(UEnvQueryTest_LineOfSight) == 0x000008, "Wrong alignment on UEnvQueryTest_LineOfSight");
static_assert(sizeof(UEnvQueryTest_LineOfSight) == 0x000358, "Wrong size on UEnvQueryTest_LineOfSight");
static_assert(offsetof(UEnvQueryTest_LineOfSight, QuerierContext) == 0x000238, "Member 'UEnvQueryTest_LineOfSight::QuerierContext' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_LineOfSight, ToContext) == 0x000240, "Member 'UEnvQueryTest_LineOfSight::ToContext' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_LineOfSight, ItemHeightOffset) == 0x000248, "Member 'UEnvQueryTest_LineOfSight::ItemHeightOffset' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_LineOfSight, Invert) == 0x000288, "Member 'UEnvQueryTest_LineOfSight::Invert' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_LineOfSight, EnableToContextAttachParent) == 0x0002C8, "Member 'UEnvQueryTest_LineOfSight::EnableToContextAttachParent' has a wrong offset!");

// Class DBDBots.EnvQueryTest_Loop
// 0x0168 (0x03A0 - 0x0238)
class UEnvQueryTest_Loop final : public UEnvQueryTest
{
public:
	TSubclassOf<class UEnvQueryContext>           QuerierContext;                                    // 0x0238(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAIDataProviderFloatValue              TowardLoopAngle;                                   // 0x0240(0x0040)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    MinSafetyRatingAgainstMeleeHostileStimulus;        // 0x0280(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    MinSafetyRatingAgainstRangedHostileStimulus;       // 0x02E0(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    ExtraMinSafetyRatingAgainstFastVaultHostileStimulus; // 0x0340(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryTest_Loop">();
	}
	static class UEnvQueryTest_Loop* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryTest_Loop>();
	}
};
static_assert(alignof(UEnvQueryTest_Loop) == 0x000008, "Wrong alignment on UEnvQueryTest_Loop");
static_assert(sizeof(UEnvQueryTest_Loop) == 0x0003A0, "Wrong size on UEnvQueryTest_Loop");
static_assert(offsetof(UEnvQueryTest_Loop, QuerierContext) == 0x000238, "Member 'UEnvQueryTest_Loop::QuerierContext' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_Loop, TowardLoopAngle) == 0x000240, "Member 'UEnvQueryTest_Loop::TowardLoopAngle' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_Loop, MinSafetyRatingAgainstMeleeHostileStimulus) == 0x000280, "Member 'UEnvQueryTest_Loop::MinSafetyRatingAgainstMeleeHostileStimulus' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_Loop, MinSafetyRatingAgainstRangedHostileStimulus) == 0x0002E0, "Member 'UEnvQueryTest_Loop::MinSafetyRatingAgainstRangedHostileStimulus' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_Loop, ExtraMinSafetyRatingAgainstFastVaultHostileStimulus) == 0x000340, "Member 'UEnvQueryTest_Loop::ExtraMinSafetyRatingAgainstFastVaultHostileStimulus' has a wrong offset!");

// Class DBDBots.EnvQueryTest_LureToDangerObject
// 0x0010 (0x0248 - 0x0238)
class UEnvQueryTest_LureToDangerObject final : public UEnvQueryTest
{
public:
	TSubclassOf<class UEnvQueryContext>           QuerierContext;                                    // 0x0238(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UEnvQueryContext>           TargetContext;                                     // 0x0240(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryTest_LureToDangerObject">();
	}
	static class UEnvQueryTest_LureToDangerObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryTest_LureToDangerObject>();
	}
};
static_assert(alignof(UEnvQueryTest_LureToDangerObject) == 0x000008, "Wrong alignment on UEnvQueryTest_LureToDangerObject");
static_assert(sizeof(UEnvQueryTest_LureToDangerObject) == 0x000248, "Wrong size on UEnvQueryTest_LureToDangerObject");
static_assert(offsetof(UEnvQueryTest_LureToDangerObject, QuerierContext) == 0x000238, "Member 'UEnvQueryTest_LureToDangerObject::QuerierContext' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_LureToDangerObject, TargetContext) == 0x000240, "Member 'UEnvQueryTest_LureToDangerObject::TargetContext' has a wrong offset!");

// Class DBDBots.EnvQueryTest_PathfindingBatchExt
// 0x0188 (0x0458 - 0x02D0)
class UEnvQueryTest_PathfindingBatchExt final : public UEnvQueryTest_Pathfinding
{
public:
	struct FAIDataProviderFloatValue              ScanRangeMultiplier;                               // 0x02D0(0x0040)(Edit, DisableEditOnInstance, ContainsInstancedReference, AdvancedDisplay, NativeAccessSpecifierPublic)
	struct FAIDataProviderFloatValue              BadPathingPenaltyMultiplier;                       // 0x0310(0x0040)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIDataProviderFloatValue              MaxPenaltyAngle;                                   // 0x0350(0x0040)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIDataProviderFloatValue              MinPenaltyAngle;                                   // 0x0390(0x0040)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIDataProviderFloatValue              HeightMultiplier;                                  // 0x03D0(0x0040)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIDataProviderFloatValue              PlayerLocationHeight;                              // 0x0410(0x0040)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TSubclassOf<class UEnvQueryContext>           TargetContext;                                     // 0x0450(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryTest_PathfindingBatchExt">();
	}
	static class UEnvQueryTest_PathfindingBatchExt* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryTest_PathfindingBatchExt>();
	}
};
static_assert(alignof(UEnvQueryTest_PathfindingBatchExt) == 0x000008, "Wrong alignment on UEnvQueryTest_PathfindingBatchExt");
static_assert(sizeof(UEnvQueryTest_PathfindingBatchExt) == 0x000458, "Wrong size on UEnvQueryTest_PathfindingBatchExt");
static_assert(offsetof(UEnvQueryTest_PathfindingBatchExt, ScanRangeMultiplier) == 0x0002D0, "Member 'UEnvQueryTest_PathfindingBatchExt::ScanRangeMultiplier' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_PathfindingBatchExt, BadPathingPenaltyMultiplier) == 0x000310, "Member 'UEnvQueryTest_PathfindingBatchExt::BadPathingPenaltyMultiplier' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_PathfindingBatchExt, MaxPenaltyAngle) == 0x000350, "Member 'UEnvQueryTest_PathfindingBatchExt::MaxPenaltyAngle' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_PathfindingBatchExt, MinPenaltyAngle) == 0x000390, "Member 'UEnvQueryTest_PathfindingBatchExt::MinPenaltyAngle' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_PathfindingBatchExt, HeightMultiplier) == 0x0003D0, "Member 'UEnvQueryTest_PathfindingBatchExt::HeightMultiplier' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_PathfindingBatchExt, PlayerLocationHeight) == 0x000410, "Member 'UEnvQueryTest_PathfindingBatchExt::PlayerLocationHeight' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_PathfindingBatchExt, TargetContext) == 0x000450, "Member 'UEnvQueryTest_PathfindingBatchExt::TargetContext' has a wrong offset!");

// Class DBDBots.NavArea_Blink
// 0x0000 (0x0050 - 0x0050)
class UNavArea_Blink final : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavArea_Blink">();
	}
	static class UNavArea_Blink* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavArea_Blink>();
	}
};
static_assert(alignof(UNavArea_Blink) == 0x000008, "Wrong alignment on UNavArea_Blink");
static_assert(sizeof(UNavArea_Blink) == 0x000050, "Wrong size on UNavArea_Blink");

// Class DBDBots.NavArea_Breakable
// 0x0000 (0x0050 - 0x0050)
class UNavArea_Breakable final : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavArea_Breakable">();
	}
	static class UNavArea_Breakable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavArea_Breakable>();
	}
};
static_assert(alignof(UNavArea_Breakable) == 0x000008, "Wrong alignment on UNavArea_Breakable");
static_assert(sizeof(UNavArea_Breakable) == 0x000050, "Wrong size on UNavArea_Breakable");

// Class DBDBots.NavigationQueryFilter_Camper
// 0x0028 (0x0098 - 0x0070)
class UNavigationQueryFilter_Camper : public UNavigationQueryFilter_Player
{
public:
	bool                                          IgnoreOnAttackCooldown;                            // 0x0070(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x3];                                       // 0x0071(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SlasherAreaBoundsLimit;                            // 0x0074(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlasherAreaPenetrationCost;                        // 0x0078(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlasherInSightCost;                                // 0x007C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlasherAreaExcludeUnderRange;                      // 0x0080(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlasherAreaUnwalkableRange;                        // 0x0084(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlasherInExcludeAreaCost;                          // 0x0088(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C[0xC];                                       // 0x008C(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavigationQueryFilter_Camper">();
	}
	static class UNavigationQueryFilter_Camper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavigationQueryFilter_Camper>();
	}
};
static_assert(alignof(UNavigationQueryFilter_Camper) == 0x000008, "Wrong alignment on UNavigationQueryFilter_Camper");
static_assert(sizeof(UNavigationQueryFilter_Camper) == 0x000098, "Wrong size on UNavigationQueryFilter_Camper");
static_assert(offsetof(UNavigationQueryFilter_Camper, IgnoreOnAttackCooldown) == 0x000070, "Member 'UNavigationQueryFilter_Camper::IgnoreOnAttackCooldown' has a wrong offset!");
static_assert(offsetof(UNavigationQueryFilter_Camper, SlasherAreaBoundsLimit) == 0x000074, "Member 'UNavigationQueryFilter_Camper::SlasherAreaBoundsLimit' has a wrong offset!");
static_assert(offsetof(UNavigationQueryFilter_Camper, SlasherAreaPenetrationCost) == 0x000078, "Member 'UNavigationQueryFilter_Camper::SlasherAreaPenetrationCost' has a wrong offset!");
static_assert(offsetof(UNavigationQueryFilter_Camper, SlasherInSightCost) == 0x00007C, "Member 'UNavigationQueryFilter_Camper::SlasherInSightCost' has a wrong offset!");
static_assert(offsetof(UNavigationQueryFilter_Camper, SlasherAreaExcludeUnderRange) == 0x000080, "Member 'UNavigationQueryFilter_Camper::SlasherAreaExcludeUnderRange' has a wrong offset!");
static_assert(offsetof(UNavigationQueryFilter_Camper, SlasherAreaUnwalkableRange) == 0x000084, "Member 'UNavigationQueryFilter_Camper::SlasherAreaUnwalkableRange' has a wrong offset!");
static_assert(offsetof(UNavigationQueryFilter_Camper, SlasherInExcludeAreaCost) == 0x000088, "Member 'UNavigationQueryFilter_Camper::SlasherInExcludeAreaCost' has a wrong offset!");

// Class DBDBots.NavigationQueryFilter_CamperStealth
// 0x0000 (0x0098 - 0x0098)
class UNavigationQueryFilter_CamperStealth final : public UNavigationQueryFilter_Camper
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavigationQueryFilter_CamperStealth">();
	}
	static class UNavigationQueryFilter_CamperStealth* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavigationQueryFilter_CamperStealth>();
	}
};
static_assert(alignof(UNavigationQueryFilter_CamperStealth) == 0x000008, "Wrong alignment on UNavigationQueryFilter_CamperStealth");
static_assert(sizeof(UNavigationQueryFilter_CamperStealth) == 0x000098, "Wrong size on UNavigationQueryFilter_CamperStealth");

// Class DBDBots.NavigationQueryFilter_Camper_Cheap
// 0x0000 (0x0098 - 0x0098)
class UNavigationQueryFilter_Camper_Cheap final : public UNavigationQueryFilter_Camper
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavigationQueryFilter_Camper_Cheap">();
	}
	static class UNavigationQueryFilter_Camper_Cheap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavigationQueryFilter_Camper_Cheap>();
	}
};
static_assert(alignof(UNavigationQueryFilter_Camper_Cheap) == 0x000008, "Wrong alignment on UNavigationQueryFilter_Camper_Cheap");
static_assert(sizeof(UNavigationQueryFilter_Camper_Cheap) == 0x000098, "Wrong size on UNavigationQueryFilter_Camper_Cheap");

// Class DBDBots.NavigationQueryFilter_Camper_NoCost
// 0x0000 (0x0070 - 0x0070)
class UNavigationQueryFilter_Camper_NoCost final : public UNavigationQueryFilter_Player
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavigationQueryFilter_Camper_NoCost">();
	}
	static class UNavigationQueryFilter_Camper_NoCost* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavigationQueryFilter_Camper_NoCost>();
	}
};
static_assert(alignof(UNavigationQueryFilter_Camper_NoCost) == 0x000008, "Wrong alignment on UNavigationQueryFilter_Camper_NoCost");
static_assert(sizeof(UNavigationQueryFilter_Camper_NoCost) == 0x000070, "Wrong size on UNavigationQueryFilter_Camper_NoCost");

// Class DBDBots.NavigationQueryFilter_ReachableMesh
// 0x0000 (0x0070 - 0x0070)
class UNavigationQueryFilter_ReachableMesh final : public UNavigationQueryFilter_Player
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavigationQueryFilter_ReachableMesh">();
	}
	static class UNavigationQueryFilter_ReachableMesh* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavigationQueryFilter_ReachableMesh>();
	}
};
static_assert(alignof(UNavigationQueryFilter_ReachableMesh) == 0x000008, "Wrong alignment on UNavigationQueryFilter_ReachableMesh");
static_assert(sizeof(UNavigationQueryFilter_ReachableMesh) == 0x000070, "Wrong size on UNavigationQueryFilter_ReachableMesh");

// Class DBDBots.NavigationQueryFilter_Slasher
// 0x00A0 (0x0110 - 0x0070)
class UNavigationQueryFilter_Slasher : public UNavigationQueryFilter_Player
{
public:
	TMap<class FString, float>                    DefaultInteractionsTimeCost;                       // 0x0070(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<class FString, float>                    FrenzyInteractionsTimeCost;                        // 0x00C0(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavigationQueryFilter_Slasher">();
	}
	static class UNavigationQueryFilter_Slasher* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavigationQueryFilter_Slasher>();
	}
};
static_assert(alignof(UNavigationQueryFilter_Slasher) == 0x000008, "Wrong alignment on UNavigationQueryFilter_Slasher");
static_assert(sizeof(UNavigationQueryFilter_Slasher) == 0x000110, "Wrong size on UNavigationQueryFilter_Slasher");
static_assert(offsetof(UNavigationQueryFilter_Slasher, DefaultInteractionsTimeCost) == 0x000070, "Member 'UNavigationQueryFilter_Slasher::DefaultInteractionsTimeCost' has a wrong offset!");
static_assert(offsetof(UNavigationQueryFilter_Slasher, FrenzyInteractionsTimeCost) == 0x0000C0, "Member 'UNavigationQueryFilter_Slasher::FrenzyInteractionsTimeCost' has a wrong offset!");

// Class DBDBots.NavigationQueryFilter_Slasher_Limited
// 0x0000 (0x0070 - 0x0070)
class UNavigationQueryFilter_Slasher_Limited final : public UNavigationQueryFilter_Player
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavigationQueryFilter_Slasher_Limited">();
	}
	static class UNavigationQueryFilter_Slasher_Limited* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavigationQueryFilter_Slasher_Limited>();
	}
};
static_assert(alignof(UNavigationQueryFilter_Slasher_Limited) == 0x000008, "Wrong alignment on UNavigationQueryFilter_Slasher_Limited");
static_assert(sizeof(UNavigationQueryFilter_Slasher_Limited) == 0x000070, "Wrong size on UNavigationQueryFilter_Slasher_Limited");

// Class DBDBots.NavLinkProxy_Base
// 0x0090 (0x0380 - 0x02F0)
class ANavLinkProxy_Base : public ANavLinkProxy
{
public:
	float                                         WaitLinkOffset;                                    // 0x02F0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveOnEndPointTimeLimit;                           // 0x02F4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NbMaxLinkUsers;                                    // 0x02F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          OverrideMovementMode;                              // 0x02FC(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECharacterMovementTypes                       MovementMode;                                      // 0x02FD(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2FE[0x2];                                      // 0x02FE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReachedRadius;                                     // 0x0300(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReachedHeight;                                     // 0x0304(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DisableSmartLinkPointInverting;                    // 0x0308(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_309[0x7];                                      // 0x0309(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class ADBDPlayer*, struct FMoveLinkPlayerInfo> _players;                                          // 0x0310(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TArray<class ADBDPlayer*>                     _nonPausedBots;                                    // 0x0360(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class ADBDPlayer*>                     _linkUsedByPlayers;                                // 0x0370(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	void AutoAdjustSmartLinkPoints();
	void OnSmartLinkReachedCallback(class AActor* MovingActor, const struct FVector& DestinationPoint);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavLinkProxy_Base">();
	}
	static class ANavLinkProxy_Base* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANavLinkProxy_Base>();
	}
};
static_assert(alignof(ANavLinkProxy_Base) == 0x000008, "Wrong alignment on ANavLinkProxy_Base");
static_assert(sizeof(ANavLinkProxy_Base) == 0x000380, "Wrong size on ANavLinkProxy_Base");
static_assert(offsetof(ANavLinkProxy_Base, WaitLinkOffset) == 0x0002F0, "Member 'ANavLinkProxy_Base::WaitLinkOffset' has a wrong offset!");
static_assert(offsetof(ANavLinkProxy_Base, MoveOnEndPointTimeLimit) == 0x0002F4, "Member 'ANavLinkProxy_Base::MoveOnEndPointTimeLimit' has a wrong offset!");
static_assert(offsetof(ANavLinkProxy_Base, NbMaxLinkUsers) == 0x0002F8, "Member 'ANavLinkProxy_Base::NbMaxLinkUsers' has a wrong offset!");
static_assert(offsetof(ANavLinkProxy_Base, OverrideMovementMode) == 0x0002FC, "Member 'ANavLinkProxy_Base::OverrideMovementMode' has a wrong offset!");
static_assert(offsetof(ANavLinkProxy_Base, MovementMode) == 0x0002FD, "Member 'ANavLinkProxy_Base::MovementMode' has a wrong offset!");
static_assert(offsetof(ANavLinkProxy_Base, ReachedRadius) == 0x000300, "Member 'ANavLinkProxy_Base::ReachedRadius' has a wrong offset!");
static_assert(offsetof(ANavLinkProxy_Base, ReachedHeight) == 0x000304, "Member 'ANavLinkProxy_Base::ReachedHeight' has a wrong offset!");
static_assert(offsetof(ANavLinkProxy_Base, DisableSmartLinkPointInverting) == 0x000308, "Member 'ANavLinkProxy_Base::DisableSmartLinkPointInverting' has a wrong offset!");
static_assert(offsetof(ANavLinkProxy_Base, _players) == 0x000310, "Member 'ANavLinkProxy_Base::_players' has a wrong offset!");
static_assert(offsetof(ANavLinkProxy_Base, _nonPausedBots) == 0x000360, "Member 'ANavLinkProxy_Base::_nonPausedBots' has a wrong offset!");
static_assert(offsetof(ANavLinkProxy_Base, _linkUsedByPlayers) == 0x000370, "Member 'ANavLinkProxy_Base::_linkUsedByPlayers' has a wrong offset!");

// Class DBDBots.NavLinkProxy_DirectMove
// 0x0068 (0x03E8 - 0x0380)
class ANavLinkProxy_DirectMove : public ANavLinkProxy_Base
{
public:
	TArray<struct FVector>                        CustomPathPoints;                                  // 0x0380(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         MoveToPathPointTimeLimit;                          // 0x0390(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_394[0x4];                                      // 0x0394(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class ADBDPlayer*, class UNavMovePath*>  _playersOnPath;                                    // 0x0398(0x0050)(Transient, NativeAccessSpecifierPrivate)

public:
	void OnDisplayDebugInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavLinkProxy_DirectMove">();
	}
	static class ANavLinkProxy_DirectMove* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANavLinkProxy_DirectMove>();
	}
};
static_assert(alignof(ANavLinkProxy_DirectMove) == 0x000008, "Wrong alignment on ANavLinkProxy_DirectMove");
static_assert(sizeof(ANavLinkProxy_DirectMove) == 0x0003E8, "Wrong size on ANavLinkProxy_DirectMove");
static_assert(offsetof(ANavLinkProxy_DirectMove, CustomPathPoints) == 0x000380, "Member 'ANavLinkProxy_DirectMove::CustomPathPoints' has a wrong offset!");
static_assert(offsetof(ANavLinkProxy_DirectMove, MoveToPathPointTimeLimit) == 0x000390, "Member 'ANavLinkProxy_DirectMove::MoveToPathPointTimeLimit' has a wrong offset!");
static_assert(offsetof(ANavLinkProxy_DirectMove, _playersOnPath) == 0x000398, "Member 'ANavLinkProxy_DirectMove::_playersOnPath' has a wrong offset!");

// Class DBDBots.NavLinkProxy_Interaction
// 0x00A8 (0x0428 - 0x0380)
class ANavLinkProxy_Interaction : public ANavLinkProxy_Base
{
public:
	TMap<EPlayerRole, struct FNavLinkInteractPlayerSetup> PlayerSetups;                                      // 0x0380(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         InteractionStartTimeLimit;                         // 0x03D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D4[0x4];                                      // 0x03D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class ADBDPlayer*, float>                _playersInteractionInputAtTime;                    // 0x03D8(0x0050)(Transient, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavLinkProxy_Interaction">();
	}
	static class ANavLinkProxy_Interaction* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANavLinkProxy_Interaction>();
	}
};
static_assert(alignof(ANavLinkProxy_Interaction) == 0x000008, "Wrong alignment on ANavLinkProxy_Interaction");
static_assert(sizeof(ANavLinkProxy_Interaction) == 0x000428, "Wrong size on ANavLinkProxy_Interaction");
static_assert(offsetof(ANavLinkProxy_Interaction, PlayerSetups) == 0x000380, "Member 'ANavLinkProxy_Interaction::PlayerSetups' has a wrong offset!");
static_assert(offsetof(ANavLinkProxy_Interaction, InteractionStartTimeLimit) == 0x0003D0, "Member 'ANavLinkProxy_Interaction::InteractionStartTimeLimit' has a wrong offset!");
static_assert(offsetof(ANavLinkProxy_Interaction, _playersInteractionInputAtTime) == 0x0003D8, "Member 'ANavLinkProxy_Interaction::_playersInteractionInputAtTime' has a wrong offset!");

// Class DBDBots.NavLinkProxy_InteractionTeleport
// 0x0008 (0x0430 - 0x0428)
class ANavLinkProxy_InteractionTeleport final : public ANavLinkProxy_Interaction
{
public:
	uint8                                         Pad_428[0x8];                                      // 0x0428(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnLevelReadyToPlay();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavLinkProxy_InteractionTeleport">();
	}
	static class ANavLinkProxy_InteractionTeleport* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANavLinkProxy_InteractionTeleport>();
	}
};
static_assert(alignof(ANavLinkProxy_InteractionTeleport) == 0x000008, "Wrong alignment on ANavLinkProxy_InteractionTeleport");
static_assert(sizeof(ANavLinkProxy_InteractionTeleport) == 0x000430, "Wrong size on ANavLinkProxy_InteractionTeleport");

// Class DBDBots.NavMovePath
// 0x0038 (0x0068 - 0x0030)
class UNavMovePath final : public UObject
{
public:
	uint8                                         Pad_30[0x38];                                      // 0x0030(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavMovePath">();
	}
	static class UNavMovePath* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavMovePath>();
	}
};
static_assert(alignof(UNavMovePath) == 0x000008, "Wrong alignment on UNavMovePath");
static_assert(sizeof(UNavMovePath) == 0x000068, "Wrong size on UNavMovePath");

// Class DBDBots.NavObstacleMatrix
// 0x0048 (0x0078 - 0x0030)
class UNavObstacleMatrix final : public UObject
{
public:
	TArray<struct FNavObstacleRow>                _matrix;                                           // 0x0030(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class UDBDNavObstacle*>                _navObstacles;                                     // 0x0040(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_50[0x28];                                      // 0x0050(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavObstacleMatrix">();
	}
	static class UNavObstacleMatrix* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavObstacleMatrix>();
	}
};
static_assert(alignof(UNavObstacleMatrix) == 0x000008, "Wrong alignment on UNavObstacleMatrix");
static_assert(sizeof(UNavObstacleMatrix) == 0x000078, "Wrong size on UNavObstacleMatrix");
static_assert(offsetof(UNavObstacleMatrix, _matrix) == 0x000030, "Member 'UNavObstacleMatrix::_matrix' has a wrong offset!");
static_assert(offsetof(UNavObstacleMatrix, _navObstacles) == 0x000040, "Member 'UNavObstacleMatrix::_navObstacles' has a wrong offset!");

// Class DBDBots.PathBuilder
// 0x0028 (0x0058 - 0x0030)
class UPathBuilder : public UObject
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PathReachedPointRadius;                            // 0x0038(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAITerrorLevel                                ToleratedTerrorPressure;                           // 0x003C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          OverridePreviousPathStrategy;                      // 0x003D(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E[0x2];                                       // 0x003E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinimumValidPathTimeWhenPathReached;               // 0x0040(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UNavMovePath*                           _path;                                             // 0x0048(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ADBDAIBTController*                     _aiOwner;                                          // 0x0050(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PathBuilder">();
	}
	static class UPathBuilder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPathBuilder>();
	}
};
static_assert(alignof(UPathBuilder) == 0x000008, "Wrong alignment on UPathBuilder");
static_assert(sizeof(UPathBuilder) == 0x000058, "Wrong size on UPathBuilder");
static_assert(offsetof(UPathBuilder, PathReachedPointRadius) == 0x000038, "Member 'UPathBuilder::PathReachedPointRadius' has a wrong offset!");
static_assert(offsetof(UPathBuilder, ToleratedTerrorPressure) == 0x00003C, "Member 'UPathBuilder::ToleratedTerrorPressure' has a wrong offset!");
static_assert(offsetof(UPathBuilder, OverridePreviousPathStrategy) == 0x00003D, "Member 'UPathBuilder::OverridePreviousPathStrategy' has a wrong offset!");
static_assert(offsetof(UPathBuilder, MinimumValidPathTimeWhenPathReached) == 0x000040, "Member 'UPathBuilder::MinimumValidPathTimeWhenPathReached' has a wrong offset!");
static_assert(offsetof(UPathBuilder, _path) == 0x000048, "Member 'UPathBuilder::_path' has a wrong offset!");
static_assert(offsetof(UPathBuilder, _aiOwner) == 0x000050, "Member 'UPathBuilder::_aiOwner' has a wrong offset!");

// Class DBDBots.PathBuilder_EQS
// 0x0080 (0x00D8 - 0x0058)
class UPathBuilder_EQS final : public UPathBuilder
{
public:
	struct FEQSParametrizedQueryExecutionRequest  EQSRequest;                                        // 0x0058(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         NbMaxEQSRequests;                                  // 0x00A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MergeToSinglePathPoint;                            // 0x00AC(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AD[0x23];                                      // 0x00AD(0x0023)(Fixing Size After Last Property [ Dumper-7 ])
	class UPathBuilder_EQS*                       _pendingEQSRequestBuilder;                         // 0x00D0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PathBuilder_EQS">();
	}
	static class UPathBuilder_EQS* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPathBuilder_EQS>();
	}
};
static_assert(alignof(UPathBuilder_EQS) == 0x000008, "Wrong alignment on UPathBuilder_EQS");
static_assert(sizeof(UPathBuilder_EQS) == 0x0000D8, "Wrong size on UPathBuilder_EQS");
static_assert(offsetof(UPathBuilder_EQS, EQSRequest) == 0x000058, "Member 'UPathBuilder_EQS::EQSRequest' has a wrong offset!");
static_assert(offsetof(UPathBuilder_EQS, NbMaxEQSRequests) == 0x0000A8, "Member 'UPathBuilder_EQS::NbMaxEQSRequests' has a wrong offset!");
static_assert(offsetof(UPathBuilder_EQS, MergeToSinglePathPoint) == 0x0000AC, "Member 'UPathBuilder_EQS::MergeToSinglePathPoint' has a wrong offset!");
static_assert(offsetof(UPathBuilder_EQS, _pendingEQSRequestBuilder) == 0x0000D0, "Member 'UPathBuilder_EQS::_pendingEQSRequestBuilder' has a wrong offset!");

// Class DBDBots.PathBuilder_EvadeLoop
// 0x0260 (0x02B8 - 0x0058)
class UPathBuilder_EvadeLoop final : public UPathBuilder
{
public:
	float                                         ChaserMeleeAttackRange;                            // 0x0058(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ForceEvadePointUnderDistance;                      // 0x005C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChaserCrossingVaultTimePenalty;                    // 0x0060(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChaserCrossingPalletTimePenalty;                   // 0x0064(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActivePathTimeBonus;                               // 0x0068(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InactivePathTimePenalty;                           // 0x006C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SwapPathTimePenalty;                               // 0x0070(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 BreakPalletInteractionId;                          // 0x0078(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OnPathRadius;                                      // 0x0088(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClosePathPointRadius;                              // 0x008C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxEvadeInteractableWeightDistance;                // 0x0090(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeightAtMaxDistance;                               // 0x0094(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MaxWeightAtNearestDistanceIfHostileHasRangedAbility; // 0x0098(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x3];                                       // 0x0099(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WeightAtMaxSafety;                                 // 0x009C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxNearAllyPenaltyPathPointDistance;               // 0x00A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeightWhenNearAlly;                                // 0x00A4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeightWhenNearLureableDangerObject;                // 0x00A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LureableDangerObjectWeightDropoffPerDistance;      // 0x00AC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    MinSafetyRatingAgainstMeleeHostileStimulus;        // 0x00B0(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    MinSafetyRatingAgainstRangedHostileStimulus;       // 0x0110(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    ExtraMinSafetyRatingAgainstFastVaultHostileStimulus; // 0x0170(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    ExtraMinSafetyRatingAgainstAntiPalletHostileStimulus; // 0x01D0(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         SidekickToLoopInvalidateDistance;                  // 0x0230(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TrapToLoopInvalidateDistance;                      // 0x0234(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EvadeInteractableHeightAmplifierActivationHeight;  // 0x0238(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EvadeInteractableHeightAmplifier;                  // 0x023C(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         QuerierReachFallEndBeforeChaserBufferTime;         // 0x0240(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChaserReachFallStartTimeBeforeQuerierFall;         // 0x0244(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNavMovePath*                           _originalEvadeLoopWorkPath;                        // 0x0248(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNavMovePath*                           _querierWorkPathA;                                 // 0x0250(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNavMovePath*                           _querierWorkPathB;                                 // 0x0258(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNavMovePath*                           _chaserWorkPath;                                   // 0x0260(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDBDNavEvadeLoopComponent*              _pickedEvadeLoopComponent;                         // 0x0268(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_270[0x48];                                     // 0x0270(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PathBuilder_EvadeLoop">();
	}
	static class UPathBuilder_EvadeLoop* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPathBuilder_EvadeLoop>();
	}
};
static_assert(alignof(UPathBuilder_EvadeLoop) == 0x000008, "Wrong alignment on UPathBuilder_EvadeLoop");
static_assert(sizeof(UPathBuilder_EvadeLoop) == 0x0002B8, "Wrong size on UPathBuilder_EvadeLoop");
static_assert(offsetof(UPathBuilder_EvadeLoop, ChaserMeleeAttackRange) == 0x000058, "Member 'UPathBuilder_EvadeLoop::ChaserMeleeAttackRange' has a wrong offset!");
static_assert(offsetof(UPathBuilder_EvadeLoop, ForceEvadePointUnderDistance) == 0x00005C, "Member 'UPathBuilder_EvadeLoop::ForceEvadePointUnderDistance' has a wrong offset!");
static_assert(offsetof(UPathBuilder_EvadeLoop, ChaserCrossingVaultTimePenalty) == 0x000060, "Member 'UPathBuilder_EvadeLoop::ChaserCrossingVaultTimePenalty' has a wrong offset!");
static_assert(offsetof(UPathBuilder_EvadeLoop, ChaserCrossingPalletTimePenalty) == 0x000064, "Member 'UPathBuilder_EvadeLoop::ChaserCrossingPalletTimePenalty' has a wrong offset!");
static_assert(offsetof(UPathBuilder_EvadeLoop, ActivePathTimeBonus) == 0x000068, "Member 'UPathBuilder_EvadeLoop::ActivePathTimeBonus' has a wrong offset!");
static_assert(offsetof(UPathBuilder_EvadeLoop, InactivePathTimePenalty) == 0x00006C, "Member 'UPathBuilder_EvadeLoop::InactivePathTimePenalty' has a wrong offset!");
static_assert(offsetof(UPathBuilder_EvadeLoop, SwapPathTimePenalty) == 0x000070, "Member 'UPathBuilder_EvadeLoop::SwapPathTimePenalty' has a wrong offset!");
static_assert(offsetof(UPathBuilder_EvadeLoop, BreakPalletInteractionId) == 0x000078, "Member 'UPathBuilder_EvadeLoop::BreakPalletInteractionId' has a wrong offset!");
static_assert(offsetof(UPathBuilder_EvadeLoop, OnPathRadius) == 0x000088, "Member 'UPathBuilder_EvadeLoop::OnPathRadius' has a wrong offset!");
static_assert(offsetof(UPathBuilder_EvadeLoop, ClosePathPointRadius) == 0x00008C, "Member 'UPathBuilder_EvadeLoop::ClosePathPointRadius' has a wrong offset!");
static_assert(offsetof(UPathBuilder_EvadeLoop, MaxEvadeInteractableWeightDistance) == 0x000090, "Member 'UPathBuilder_EvadeLoop::MaxEvadeInteractableWeightDistance' has a wrong offset!");
static_assert(offsetof(UPathBuilder_EvadeLoop, WeightAtMaxDistance) == 0x000094, "Member 'UPathBuilder_EvadeLoop::WeightAtMaxDistance' has a wrong offset!");
static_assert(offsetof(UPathBuilder_EvadeLoop, MaxWeightAtNearestDistanceIfHostileHasRangedAbility) == 0x000098, "Member 'UPathBuilder_EvadeLoop::MaxWeightAtNearestDistanceIfHostileHasRangedAbility' has a wrong offset!");
static_assert(offsetof(UPathBuilder_EvadeLoop, WeightAtMaxSafety) == 0x00009C, "Member 'UPathBuilder_EvadeLoop::WeightAtMaxSafety' has a wrong offset!");
static_assert(offsetof(UPathBuilder_EvadeLoop, MaxNearAllyPenaltyPathPointDistance) == 0x0000A0, "Member 'UPathBuilder_EvadeLoop::MaxNearAllyPenaltyPathPointDistance' has a wrong offset!");
static_assert(offsetof(UPathBuilder_EvadeLoop, WeightWhenNearAlly) == 0x0000A4, "Member 'UPathBuilder_EvadeLoop::WeightWhenNearAlly' has a wrong offset!");
static_assert(offsetof(UPathBuilder_EvadeLoop, WeightWhenNearLureableDangerObject) == 0x0000A8, "Member 'UPathBuilder_EvadeLoop::WeightWhenNearLureableDangerObject' has a wrong offset!");
static_assert(offsetof(UPathBuilder_EvadeLoop, LureableDangerObjectWeightDropoffPerDistance) == 0x0000AC, "Member 'UPathBuilder_EvadeLoop::LureableDangerObjectWeightDropoffPerDistance' has a wrong offset!");
static_assert(offsetof(UPathBuilder_EvadeLoop, MinSafetyRatingAgainstMeleeHostileStimulus) == 0x0000B0, "Member 'UPathBuilder_EvadeLoop::MinSafetyRatingAgainstMeleeHostileStimulus' has a wrong offset!");
static_assert(offsetof(UPathBuilder_EvadeLoop, MinSafetyRatingAgainstRangedHostileStimulus) == 0x000110, "Member 'UPathBuilder_EvadeLoop::MinSafetyRatingAgainstRangedHostileStimulus' has a wrong offset!");
static_assert(offsetof(UPathBuilder_EvadeLoop, ExtraMinSafetyRatingAgainstFastVaultHostileStimulus) == 0x000170, "Member 'UPathBuilder_EvadeLoop::ExtraMinSafetyRatingAgainstFastVaultHostileStimulus' has a wrong offset!");
static_assert(offsetof(UPathBuilder_EvadeLoop, ExtraMinSafetyRatingAgainstAntiPalletHostileStimulus) == 0x0001D0, "Member 'UPathBuilder_EvadeLoop::ExtraMinSafetyRatingAgainstAntiPalletHostileStimulus' has a wrong offset!");
static_assert(offsetof(UPathBuilder_EvadeLoop, SidekickToLoopInvalidateDistance) == 0x000230, "Member 'UPathBuilder_EvadeLoop::SidekickToLoopInvalidateDistance' has a wrong offset!");
static_assert(offsetof(UPathBuilder_EvadeLoop, TrapToLoopInvalidateDistance) == 0x000234, "Member 'UPathBuilder_EvadeLoop::TrapToLoopInvalidateDistance' has a wrong offset!");
static_assert(offsetof(UPathBuilder_EvadeLoop, EvadeInteractableHeightAmplifierActivationHeight) == 0x000238, "Member 'UPathBuilder_EvadeLoop::EvadeInteractableHeightAmplifierActivationHeight' has a wrong offset!");
static_assert(offsetof(UPathBuilder_EvadeLoop, EvadeInteractableHeightAmplifier) == 0x00023C, "Member 'UPathBuilder_EvadeLoop::EvadeInteractableHeightAmplifier' has a wrong offset!");
static_assert(offsetof(UPathBuilder_EvadeLoop, QuerierReachFallEndBeforeChaserBufferTime) == 0x000240, "Member 'UPathBuilder_EvadeLoop::QuerierReachFallEndBeforeChaserBufferTime' has a wrong offset!");
static_assert(offsetof(UPathBuilder_EvadeLoop, ChaserReachFallStartTimeBeforeQuerierFall) == 0x000244, "Member 'UPathBuilder_EvadeLoop::ChaserReachFallStartTimeBeforeQuerierFall' has a wrong offset!");
static_assert(offsetof(UPathBuilder_EvadeLoop, _originalEvadeLoopWorkPath) == 0x000248, "Member 'UPathBuilder_EvadeLoop::_originalEvadeLoopWorkPath' has a wrong offset!");
static_assert(offsetof(UPathBuilder_EvadeLoop, _querierWorkPathA) == 0x000250, "Member 'UPathBuilder_EvadeLoop::_querierWorkPathA' has a wrong offset!");
static_assert(offsetof(UPathBuilder_EvadeLoop, _querierWorkPathB) == 0x000258, "Member 'UPathBuilder_EvadeLoop::_querierWorkPathB' has a wrong offset!");
static_assert(offsetof(UPathBuilder_EvadeLoop, _chaserWorkPath) == 0x000260, "Member 'UPathBuilder_EvadeLoop::_chaserWorkPath' has a wrong offset!");
static_assert(offsetof(UPathBuilder_EvadeLoop, _pickedEvadeLoopComponent) == 0x000268, "Member 'UPathBuilder_EvadeLoop::_pickedEvadeLoopComponent' has a wrong offset!");

// Class DBDBots.PathBuilder_LastGoal
// 0x0000 (0x0058 - 0x0058)
class UPathBuilder_LastGoal final : public UPathBuilder
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PathBuilder_LastGoal">();
	}
	static class UPathBuilder_LastGoal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPathBuilder_LastGoal>();
	}
};
static_assert(alignof(UPathBuilder_LastGoal) == 0x000008, "Wrong alignment on UPathBuilder_LastGoal");
static_assert(sizeof(UPathBuilder_LastGoal) == 0x000058, "Wrong size on UPathBuilder_LastGoal");

// Class DBDBots.PathBuilder_TowardActor
// 0x0030 (0x0088 - 0x0058)
class UPathBuilder_TowardActor final : public UPathBuilder
{
public:
	TSubclassOf<class AActor>                     FindClass;                                         // 0x0058(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseClosestEscapePointIfAvailable;                  // 0x0060(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x3];                                       // 0x0061(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OpenDoorOffset;                                    // 0x0064(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinimumDistance;                                   // 0x0068(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaximumDistance;                                   // 0x006C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AwayFromEnemyAngleMultiplier;                      // 0x0070(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AwayFromEnemyMinimumDistance;                      // 0x0074(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AwayFromEnemyMaximumDistance;                      // 0x0078(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SearchForClosestActor;                             // 0x007C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7D[0x3];                                       // 0x007D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UNavigationQueryFilter>     FilterClass;                                       // 0x0080(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PathBuilder_TowardActor">();
	}
	static class UPathBuilder_TowardActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPathBuilder_TowardActor>();
	}
};
static_assert(alignof(UPathBuilder_TowardActor) == 0x000008, "Wrong alignment on UPathBuilder_TowardActor");
static_assert(sizeof(UPathBuilder_TowardActor) == 0x000088, "Wrong size on UPathBuilder_TowardActor");
static_assert(offsetof(UPathBuilder_TowardActor, FindClass) == 0x000058, "Member 'UPathBuilder_TowardActor::FindClass' has a wrong offset!");
static_assert(offsetof(UPathBuilder_TowardActor, UseClosestEscapePointIfAvailable) == 0x000060, "Member 'UPathBuilder_TowardActor::UseClosestEscapePointIfAvailable' has a wrong offset!");
static_assert(offsetof(UPathBuilder_TowardActor, OpenDoorOffset) == 0x000064, "Member 'UPathBuilder_TowardActor::OpenDoorOffset' has a wrong offset!");
static_assert(offsetof(UPathBuilder_TowardActor, MinimumDistance) == 0x000068, "Member 'UPathBuilder_TowardActor::MinimumDistance' has a wrong offset!");
static_assert(offsetof(UPathBuilder_TowardActor, MaximumDistance) == 0x00006C, "Member 'UPathBuilder_TowardActor::MaximumDistance' has a wrong offset!");
static_assert(offsetof(UPathBuilder_TowardActor, AwayFromEnemyAngleMultiplier) == 0x000070, "Member 'UPathBuilder_TowardActor::AwayFromEnemyAngleMultiplier' has a wrong offset!");
static_assert(offsetof(UPathBuilder_TowardActor, AwayFromEnemyMinimumDistance) == 0x000074, "Member 'UPathBuilder_TowardActor::AwayFromEnemyMinimumDistance' has a wrong offset!");
static_assert(offsetof(UPathBuilder_TowardActor, AwayFromEnemyMaximumDistance) == 0x000078, "Member 'UPathBuilder_TowardActor::AwayFromEnemyMaximumDistance' has a wrong offset!");
static_assert(offsetof(UPathBuilder_TowardActor, SearchForClosestActor) == 0x00007C, "Member 'UPathBuilder_TowardActor::SearchForClosestActor' has a wrong offset!");
static_assert(offsetof(UPathBuilder_TowardActor, FilterClass) == 0x000080, "Member 'UPathBuilder_TowardActor::FilterClass' has a wrong offset!");

// Class DBDBots.PathStrategySelector
// 0x0040 (0x0070 - 0x0030)
class UPathStrategySelector : public UObject
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ADBDAIBTController*                     _aiOwner;                                          // 0x0038(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UPathStrategy*>                  _activePathStrategies;                             // 0x0040(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class UPathStrategy*>                  _nextPathStrategies;                               // 0x0050(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_60[0x10];                                      // 0x0060(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PathStrategySelector">();
	}
	static class UPathStrategySelector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPathStrategySelector>();
	}
};
static_assert(alignof(UPathStrategySelector) == 0x000008, "Wrong alignment on UPathStrategySelector");
static_assert(sizeof(UPathStrategySelector) == 0x000070, "Wrong size on UPathStrategySelector");
static_assert(offsetof(UPathStrategySelector, _aiOwner) == 0x000038, "Member 'UPathStrategySelector::_aiOwner' has a wrong offset!");
static_assert(offsetof(UPathStrategySelector, _activePathStrategies) == 0x000040, "Member 'UPathStrategySelector::_activePathStrategies' has a wrong offset!");
static_assert(offsetof(UPathStrategySelector, _nextPathStrategies) == 0x000050, "Member 'UPathStrategySelector::_nextPathStrategies' has a wrong offset!");

// Class DBDBots.PathStrategySelector_Flee
// 0x00A8 (0x0118 - 0x0070)
class UPathStrategySelector_Flee : public UPathStrategySelector
{
public:
	TMap<EAIFleePathStrategy, class UPathStrategy*> FleePathStrategies;                                // 0x0070(0x0050)(Edit, ExportObject, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_C0[0x8];                                       // 0x00C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EAIFleePathStrategy, class UPathStrategy*> _activeFleePathStrategiesMap;                      // 0x00C8(0x0050)(Transient, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PathStrategySelector_Flee">();
	}
	static class UPathStrategySelector_Flee* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPathStrategySelector_Flee>();
	}
};
static_assert(alignof(UPathStrategySelector_Flee) == 0x000008, "Wrong alignment on UPathStrategySelector_Flee");
static_assert(sizeof(UPathStrategySelector_Flee) == 0x000118, "Wrong size on UPathStrategySelector_Flee");
static_assert(offsetof(UPathStrategySelector_Flee, FleePathStrategies) == 0x000070, "Member 'UPathStrategySelector_Flee::FleePathStrategies' has a wrong offset!");
static_assert(offsetof(UPathStrategySelector_Flee, _activeFleePathStrategiesMap) == 0x0000C8, "Member 'UPathStrategySelector_Flee::_activeFleePathStrategiesMap' has a wrong offset!");

// Class DBDBots.PathStrategy_FleeLoop
// 0x0160 (0x0228 - 0x00C8)
class UPathStrategy_FleeLoop final : public UPathStrategy_Flee
{
public:
	TMap<EAIDifficultyLevel, struct FGameStateEvadeLoopStrategyMapContainer> GameStateFleeLoopStrategyTable;                    // 0x00C8(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<EAIFleeLoopStrategy, class UPathBuilder_EvadeLoop*> FleeLoopStrategyPathBuilders;                      // 0x0118(0x0050)(Edit, ExportObject, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         CanBranchUnderEndPathDistance;                     // 0x0168(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16C[0x4];                                      // 0x016C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EAIFleeLoopStrategy, struct FAIRoll>     BranchRolls;                                       // 0x0170(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         RejectLoopBranchUnderEndPointsDistance;            // 0x01C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RejectBranchPointNearerHostileSourceDistance;      // 0x01C4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RejectBranchUnderNavLinkDistance;                  // 0x01C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AddDistanceToRequiredBranchEvadeGap;               // 0x01CC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RelevantHostileStimuliTimeToReach;                 // 0x01D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D4[0x54];                                     // 0x01D4(0x0054)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PathStrategy_FleeLoop">();
	}
	static class UPathStrategy_FleeLoop* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPathStrategy_FleeLoop>();
	}
};
static_assert(alignof(UPathStrategy_FleeLoop) == 0x000008, "Wrong alignment on UPathStrategy_FleeLoop");
static_assert(sizeof(UPathStrategy_FleeLoop) == 0x000228, "Wrong size on UPathStrategy_FleeLoop");
static_assert(offsetof(UPathStrategy_FleeLoop, GameStateFleeLoopStrategyTable) == 0x0000C8, "Member 'UPathStrategy_FleeLoop::GameStateFleeLoopStrategyTable' has a wrong offset!");
static_assert(offsetof(UPathStrategy_FleeLoop, FleeLoopStrategyPathBuilders) == 0x000118, "Member 'UPathStrategy_FleeLoop::FleeLoopStrategyPathBuilders' has a wrong offset!");
static_assert(offsetof(UPathStrategy_FleeLoop, CanBranchUnderEndPathDistance) == 0x000168, "Member 'UPathStrategy_FleeLoop::CanBranchUnderEndPathDistance' has a wrong offset!");
static_assert(offsetof(UPathStrategy_FleeLoop, BranchRolls) == 0x000170, "Member 'UPathStrategy_FleeLoop::BranchRolls' has a wrong offset!");
static_assert(offsetof(UPathStrategy_FleeLoop, RejectLoopBranchUnderEndPointsDistance) == 0x0001C0, "Member 'UPathStrategy_FleeLoop::RejectLoopBranchUnderEndPointsDistance' has a wrong offset!");
static_assert(offsetof(UPathStrategy_FleeLoop, RejectBranchPointNearerHostileSourceDistance) == 0x0001C4, "Member 'UPathStrategy_FleeLoop::RejectBranchPointNearerHostileSourceDistance' has a wrong offset!");
static_assert(offsetof(UPathStrategy_FleeLoop, RejectBranchUnderNavLinkDistance) == 0x0001C8, "Member 'UPathStrategy_FleeLoop::RejectBranchUnderNavLinkDistance' has a wrong offset!");
static_assert(offsetof(UPathStrategy_FleeLoop, AddDistanceToRequiredBranchEvadeGap) == 0x0001CC, "Member 'UPathStrategy_FleeLoop::AddDistanceToRequiredBranchEvadeGap' has a wrong offset!");
static_assert(offsetof(UPathStrategy_FleeLoop, RelevantHostileStimuliTimeToReach) == 0x0001D0, "Member 'UPathStrategy_FleeLoop::RelevantHostileStimuliTimeToReach' has a wrong offset!");

// Class DBDBots.PathStrategy_FleeLure
// 0x0018 (0x00E0 - 0x00C8)
class UPathStrategy_FleeLure final : public UPathStrategy_Flee
{
public:
	float                                         MaximumRangeToLureableDangerObject;                // 0x00C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxActiveTimeSecondsEndgame;                       // 0x00CC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         LostFocusInteractionIds;                           // 0x00D0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PathStrategy_FleeLure">();
	}
	static class UPathStrategy_FleeLure* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPathStrategy_FleeLure>();
	}
};
static_assert(alignof(UPathStrategy_FleeLure) == 0x000008, "Wrong alignment on UPathStrategy_FleeLure");
static_assert(sizeof(UPathStrategy_FleeLure) == 0x0000E0, "Wrong size on UPathStrategy_FleeLure");
static_assert(offsetof(UPathStrategy_FleeLure, MaximumRangeToLureableDangerObject) == 0x0000C8, "Member 'UPathStrategy_FleeLure::MaximumRangeToLureableDangerObject' has a wrong offset!");
static_assert(offsetof(UPathStrategy_FleeLure, MaxActiveTimeSecondsEndgame) == 0x0000CC, "Member 'UPathStrategy_FleeLure::MaxActiveTimeSecondsEndgame' has a wrong offset!");
static_assert(offsetof(UPathStrategy_FleeLure, LostFocusInteractionIds) == 0x0000D0, "Member 'UPathStrategy_FleeLure::LostFocusInteractionIds' has a wrong offset!");

// Class DBDBots.PathStrategy_FleeReposition
// 0x0008 (0x00D0 - 0x00C8)
class UPathStrategy_FleeReposition final : public UPathStrategy_Flee
{
public:
	float                                         WiggleOutRangeToKiller;                            // 0x00C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CC[0x4];                                       // 0x00CC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PathStrategy_FleeReposition">();
	}
	static class UPathStrategy_FleeReposition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPathStrategy_FleeReposition>();
	}
};
static_assert(alignof(UPathStrategy_FleeReposition) == 0x000008, "Wrong alignment on UPathStrategy_FleeReposition");
static_assert(sizeof(UPathStrategy_FleeReposition) == 0x0000D0, "Wrong size on UPathStrategy_FleeReposition");
static_assert(offsetof(UPathStrategy_FleeReposition, WiggleOutRangeToKiller) == 0x0000C8, "Member 'UPathStrategy_FleeReposition::WiggleOutRangeToKiller' has a wrong offset!");

}

