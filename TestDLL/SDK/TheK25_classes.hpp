#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: TheK25

#include "Basic.hpp"

#include "SystemUtilities_structs.hpp"
#include "DeadByDaylight_structs.hpp"
#include "DeadByDaylight_classes.hpp"
#include "DBDBots_classes.hpp"
#include "DataTableUtilities_structs.hpp"
#include "DBDCompetence_classes.hpp"
#include "DBDAnimation_classes.hpp"
#include "Competence_classes.hpp"
#include "Projectile_structs.hpp"
#include "Projectile_classes.hpp"
#include "DBDSharedTypes_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "TheK25_structs.hpp"
#include "FiniteStateMachine_classes.hpp"
#include "GameplayUtilities_classes.hpp"
#include "DBDInteraction_classes.hpp"
#include "StatSystem_structs.hpp"
#include "DBDAttack_classes.hpp"
#include "DBDGameplay_structs.hpp"
#include "AnimationUtilities_structs.hpp"
#include "GameplayTags_structs.hpp"


namespace SDK
{

// Class TheK25.K25Projectile
// 0x0118 (0x04C0 - 0x03A8)
class AK25Projectile : public AKillerProjectile
{
public:
	uint8                                         Pad_3A8[0x48];                                     // 0x03A8(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   _staticMesh;                                       // 0x03F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPrimitiveComponent*                    _characterCollider;                                // 0x03F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPrimitiveComponent*                    _environmentCollider;                              // 0x0400(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UKillerProjectileDodgeComponent*        _projectileDodgeComponent;                         // 0x0408(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLaunchInfo                            _launchInfo;                                       // 0x0410(0x0038)(Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class AK25Chain*                              _attachedChain;                                    // 0x0448(0x0008)(Net, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _timeIgnoreSlasherCollision;                       // 0x0450(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isActive;                                         // 0x0454(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_455[0x3];                                      // 0x0455(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FK25ProjectileDeactivationData         _lastDeactivationData;                             // 0x0458(0x0020)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_478[0x48];                                     // 0x0478(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_OnProjectileActivated();
	void Cosmetic_OnProjectileDeactivated(const struct FK25ProjectileDeactivationData& DeactivationData);
	void OnProjectileStopped(const struct FHitResult& Result);
	void Server_RequestDisableProjectile(EK25ProjectileDeactivateReason DeactivateReason);

	struct FVector GetChainAttachmentLocation() const;
	class UDBDProjectileMovementComponent* GetMovementComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K25Projectile">();
	}
	static class AK25Projectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK25Projectile>();
	}
};
static_assert(alignof(AK25Projectile) == 0x000008, "Wrong alignment on AK25Projectile");
static_assert(sizeof(AK25Projectile) == 0x0004C0, "Wrong size on AK25Projectile");
static_assert(offsetof(AK25Projectile, _staticMesh) == 0x0003F0, "Member 'AK25Projectile::_staticMesh' has a wrong offset!");
static_assert(offsetof(AK25Projectile, _characterCollider) == 0x0003F8, "Member 'AK25Projectile::_characterCollider' has a wrong offset!");
static_assert(offsetof(AK25Projectile, _environmentCollider) == 0x000400, "Member 'AK25Projectile::_environmentCollider' has a wrong offset!");
static_assert(offsetof(AK25Projectile, _projectileDodgeComponent) == 0x000408, "Member 'AK25Projectile::_projectileDodgeComponent' has a wrong offset!");
static_assert(offsetof(AK25Projectile, _launchInfo) == 0x000410, "Member 'AK25Projectile::_launchInfo' has a wrong offset!");
static_assert(offsetof(AK25Projectile, _attachedChain) == 0x000448, "Member 'AK25Projectile::_attachedChain' has a wrong offset!");
static_assert(offsetof(AK25Projectile, _timeIgnoreSlasherCollision) == 0x000450, "Member 'AK25Projectile::_timeIgnoreSlasherCollision' has a wrong offset!");
static_assert(offsetof(AK25Projectile, _isActive) == 0x000454, "Member 'AK25Projectile::_isActive' has a wrong offset!");
static_assert(offsetof(AK25Projectile, _lastDeactivationData) == 0x000458, "Member 'AK25Projectile::_lastDeactivationData' has a wrong offset!");

// Class TheK25.K25UncontrolledProjectile
// 0x0188 (0x0648 - 0x04C0)
class AK25UncontrolledProjectile final : public AK25Projectile
{
public:
	uint8                                         Pad_4C0[0x8];                                      // 0x04C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnAcquiredChanged;                                 // 0x04C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FDBDTunableRowHandle                   _minimumTimeBeforeProjectileLaunch;                // 0x04D8(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FDBDTunableRowHandle                   _maximumTimeBeforeProjectileLaunch;                // 0x0500(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FDBDTunableRowHandle                   _projectileSpeed;                                  // 0x0528(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FDBDTunableRowHandle                   _projectileMaximumTravelDistance;                  // 0x0550(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FDBDTunableRowHandle                   _maximumInactiveProjectileTime;                    // 0x0578(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          _isAcquiredFromPool;                               // 0x05A0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5A1[0x67];                                     // 0x05A1(0x0067)(Fixing Size After Last Property [ Dumper-7 ])
	class ACamperPlayer*                          _targetSurvivor;                                   // 0x0608(0x0008)(Net, ZeroConstructor, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_610[0x38];                                     // 0x0610(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnDamageStateChanged(ECamperDamageState OldDamageState, ECamperDamageState CurrentDamageState);
	void Cosmetic_TriggerUncontrolledProjectileSpawnSFX();
	void OnRep_TargetSurvivor();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K25UncontrolledProjectile">();
	}
	static class AK25UncontrolledProjectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK25UncontrolledProjectile>();
	}
};
static_assert(alignof(AK25UncontrolledProjectile) == 0x000008, "Wrong alignment on AK25UncontrolledProjectile");
static_assert(sizeof(AK25UncontrolledProjectile) == 0x000648, "Wrong size on AK25UncontrolledProjectile");
static_assert(offsetof(AK25UncontrolledProjectile, OnAcquiredChanged) == 0x0004C8, "Member 'AK25UncontrolledProjectile::OnAcquiredChanged' has a wrong offset!");
static_assert(offsetof(AK25UncontrolledProjectile, _minimumTimeBeforeProjectileLaunch) == 0x0004D8, "Member 'AK25UncontrolledProjectile::_minimumTimeBeforeProjectileLaunch' has a wrong offset!");
static_assert(offsetof(AK25UncontrolledProjectile, _maximumTimeBeforeProjectileLaunch) == 0x000500, "Member 'AK25UncontrolledProjectile::_maximumTimeBeforeProjectileLaunch' has a wrong offset!");
static_assert(offsetof(AK25UncontrolledProjectile, _projectileSpeed) == 0x000528, "Member 'AK25UncontrolledProjectile::_projectileSpeed' has a wrong offset!");
static_assert(offsetof(AK25UncontrolledProjectile, _projectileMaximumTravelDistance) == 0x000550, "Member 'AK25UncontrolledProjectile::_projectileMaximumTravelDistance' has a wrong offset!");
static_assert(offsetof(AK25UncontrolledProjectile, _maximumInactiveProjectileTime) == 0x000578, "Member 'AK25UncontrolledProjectile::_maximumInactiveProjectileTime' has a wrong offset!");
static_assert(offsetof(AK25UncontrolledProjectile, _isAcquiredFromPool) == 0x0005A0, "Member 'AK25UncontrolledProjectile::_isAcquiredFromPool' has a wrong offset!");
static_assert(offsetof(AK25UncontrolledProjectile, _targetSurvivor) == 0x000608, "Member 'AK25UncontrolledProjectile::_targetSurvivor' has a wrong offset!");

// Class TheK25.Addon_K25Power_16
// 0x0010 (0x02F8 - 0x02E8)
class UAddon_K25Power_16 final : public UItemAddon
{
public:
	uint8                                         Pad_2E8[0x10];                                     // 0x02E8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Addon_K25Power_16">();
	}
	static class UAddon_K25Power_16* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAddon_K25Power_16>();
	}
};
static_assert(alignof(UAddon_K25Power_16) == 0x000008, "Wrong alignment on UAddon_K25Power_16");
static_assert(sizeof(UAddon_K25Power_16) == 0x0002F8, "Wrong size on UAddon_K25Power_16");

// Class TheK25.K25AttackSubAnimInstance
// 0x0010 (0x06D0 - 0x06C0)
class UK25AttackSubAnimInstance final : public UKillerAttackSubAnimInstance
{
public:
	bool                                          _hasDownedTargetHoldingLamentConfiguration;        // 0x06B8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6B9[0x17];                                     // 0x06B9(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAttackStart(const EAttackType AttackType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K25AttackSubAnimInstance">();
	}
	static class UK25AttackSubAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK25AttackSubAnimInstance>();
	}
};
static_assert(alignof(UK25AttackSubAnimInstance) == 0x000010, "Wrong alignment on UK25AttackSubAnimInstance");
static_assert(sizeof(UK25AttackSubAnimInstance) == 0x0006D0, "Wrong size on UK25AttackSubAnimInstance");
static_assert(offsetof(UK25AttackSubAnimInstance, _hasDownedTargetHoldingLamentConfiguration) == 0x0006B8, "Member 'UK25AttackSubAnimInstance::_hasDownedTargetHoldingLamentConfiguration' has a wrong offset!");

// Class TheK25.K25ProjectileReplicationComponent
// 0x0000 (0x00A8 - 0x00A8)
class UK25ProjectileReplicationComponent : public UBaseProjectileReplicationComponent
{
public:
	void Multicast_DeactivateProjectile(class AK25Projectile* Projectile, const struct FK25ProjectileDeactivationData& DeactivationData);
	void Multicast_SetAttachedChain(class AK25Projectile* Projectile, class AK25Chain* ChainToAttach, const struct FLaunchInfo& LaunchInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K25ProjectileReplicationComponent">();
	}
	static class UK25ProjectileReplicationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK25ProjectileReplicationComponent>();
	}
};
static_assert(alignof(UK25ProjectileReplicationComponent) == 0x000008, "Wrong alignment on UK25ProjectileReplicationComponent");
static_assert(sizeof(UK25ProjectileReplicationComponent) == 0x0000A8, "Wrong size on UK25ProjectileReplicationComponent");

// Class TheK25.K25UncontrolledProjectileReplicationComponent
// 0x0000 (0x00A8 - 0x00A8)
class UK25UncontrolledProjectileReplicationComponent final : public UK25ProjectileReplicationComponent
{
public:
	void Multicast_LaunchProjectile(class AK25UncontrolledProjectile* Projectile, const struct FLaunchInfo& LaunchInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K25UncontrolledProjectileReplicationComponent">();
	}
	static class UK25UncontrolledProjectileReplicationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK25UncontrolledProjectileReplicationComponent>();
	}
};
static_assert(alignof(UK25UncontrolledProjectileReplicationComponent) == 0x000008, "Wrong alignment on UK25UncontrolledProjectileReplicationComponent");
static_assert(sizeof(UK25UncontrolledProjectileReplicationComponent) == 0x0000A8, "Wrong size on UK25UncontrolledProjectileReplicationComponent");

// Class TheK25.AISkill_FindCollectable_LamentConfiguration
// 0x00C0 (0x0438 - 0x0378)
class UAISkill_FindCollectable_LamentConfiguration final : public UAISkill_FindCollectable
{
public:
	struct FAITunableParameter                    StopChainHuntGoalWeight;                           // 0x0378(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    PreemptiveFindLamentGoalWeight;                    // 0x03D8(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_FindCollectable_LamentConfiguration">();
	}
	static class UAISkill_FindCollectable_LamentConfiguration* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_FindCollectable_LamentConfiguration>();
	}
};
static_assert(alignof(UAISkill_FindCollectable_LamentConfiguration) == 0x000008, "Wrong alignment on UAISkill_FindCollectable_LamentConfiguration");
static_assert(sizeof(UAISkill_FindCollectable_LamentConfiguration) == 0x000438, "Wrong size on UAISkill_FindCollectable_LamentConfiguration");
static_assert(offsetof(UAISkill_FindCollectable_LamentConfiguration, StopChainHuntGoalWeight) == 0x000378, "Member 'UAISkill_FindCollectable_LamentConfiguration::StopChainHuntGoalWeight' has a wrong offset!");
static_assert(offsetof(UAISkill_FindCollectable_LamentConfiguration, PreemptiveFindLamentGoalWeight) == 0x0003D8, "Member 'UAISkill_FindCollectable_LamentConfiguration::PreemptiveFindLamentGoalWeight' has a wrong offset!");

// Class TheK25.K25Utilities
// 0x0000 (0x0030 - 0x0030)
class UK25Utilities final : public UBlueprintFunctionLibrary
{
public:
	static class AK25ControlledProjectile* GetK25ControlledProjectile(const class UObject* WorldContextObject);
	static class AK25Gateway* GetK25Gateway(const class UObject* WorldContextObject);
	static class AK25Husk* GetK25Husk(const class UObject* WorldContextObject);
	static class AK25Power* GetK25Power(const class UObject* WorldContextObject);
	static class ALamentConfiguration* GetLamentConfiguration(const class UObject* WorldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K25Utilities">();
	}
	static class UK25Utilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK25Utilities>();
	}
};
static_assert(alignof(UK25Utilities) == 0x000008, "Wrong alignment on UK25Utilities");
static_assert(sizeof(UK25Utilities) == 0x000030, "Wrong size on UK25Utilities");

// Class TheK25.AISkill_InteractionBreakFreeFromChains
// 0x0028 (0x02A8 - 0x0280)
class UAISkill_InteractionBreakFreeFromChains final : public UAISkill_Interaction
{
public:
	struct FDBDTunableRowHandle                   _breakFreeFromChainsMaxCharge;                     // 0x0280(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_InteractionBreakFreeFromChains">();
	}
	static class UAISkill_InteractionBreakFreeFromChains* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_InteractionBreakFreeFromChains>();
	}
};
static_assert(alignof(UAISkill_InteractionBreakFreeFromChains) == 0x000008, "Wrong alignment on UAISkill_InteractionBreakFreeFromChains");
static_assert(sizeof(UAISkill_InteractionBreakFreeFromChains) == 0x0002A8, "Wrong size on UAISkill_InteractionBreakFreeFromChains");
static_assert(offsetof(UAISkill_InteractionBreakFreeFromChains, _breakFreeFromChainsMaxCharge) == 0x000280, "Member 'UAISkill_InteractionBreakFreeFromChains::_breakFreeFromChainsMaxCharge' has a wrong offset!");

// Class TheK25.AISkill_InteractionUseItem_LamentConfiguration
// 0x0088 (0x0318 - 0x0290)
class UAISkill_InteractionUseItem_LamentConfiguration final : public UAISkill_InteractionUseItem
{
public:
	struct FAITunableParameter                    SolveLamentThreshold;                              // 0x0290(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FDBDTunableRowHandle                   _solveLamentMaxCharge;                             // 0x02F0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_InteractionUseItem_LamentConfiguration">();
	}
	static class UAISkill_InteractionUseItem_LamentConfiguration* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_InteractionUseItem_LamentConfiguration>();
	}
};
static_assert(alignof(UAISkill_InteractionUseItem_LamentConfiguration) == 0x000008, "Wrong alignment on UAISkill_InteractionUseItem_LamentConfiguration");
static_assert(sizeof(UAISkill_InteractionUseItem_LamentConfiguration) == 0x000318, "Wrong size on UAISkill_InteractionUseItem_LamentConfiguration");
static_assert(offsetof(UAISkill_InteractionUseItem_LamentConfiguration, SolveLamentThreshold) == 0x000290, "Member 'UAISkill_InteractionUseItem_LamentConfiguration::SolveLamentThreshold' has a wrong offset!");
static_assert(offsetof(UAISkill_InteractionUseItem_LamentConfiguration, _solveLamentMaxCharge) == 0x0002F0, "Member 'UAISkill_InteractionUseItem_LamentConfiguration::_solveLamentMaxCharge' has a wrong offset!");

// Class TheK25.LamentConfiguration
// 0x02E8 (0x0838 - 0x0550)
class ALamentConfiguration final : public ACollectable
{
public:
	uint8                                         Pad_550[0x30];                                     // 0x0550(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class USpherePlayerOverlapComponent*          _interactable;                                     // 0x0580(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractor*                            _collectableInteractor;                            // 0x0588(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UK25CollectLamentConfigurationInteraction* _survivorCollectItemInteraction;                   // 0x0590(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UK25CollectLamentConfigurationInteraction* _killerCollectItemInteraction;                     // 0x0598(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDBDOutlineComponent*                   _outlineComponent;                                 // 0x05A0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialHelper*                        _materialHelper;                                   // 0x05A8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULamentConfigurationOutlineStrategy*    _outlineStrategy;                                  // 0x05B0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULamentConfigurationSpawnStrategy*      _spawnStrategy;                                    // 0x05B8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULamentConfigurationChainHuntComponent* _chainHuntComponent;                               // 0x05C0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _dotProductMinValue;                               // 0x05C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAttachToSocketNameEnum                       _survivorAttachmentSocket;                         // 0x05CC(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAttachToSocketNameEnum                       _killerAttachmentSocket;                           // 0x05CD(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5CE[0x2];                                      // 0x05CE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimationMontageSlave*                 _montageFollower;                                  // 0x05D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMontagePlayer*                         _montagePlayer;                                    // 0x05D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AAnimationFollowerActor>    _chainAnimationActorClass;                         // 0x05E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AK25LamentConfigurationTeleportIndicator> _lamentConfigurationTeleportIndicatorClass;        // 0x05E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _chainAnimationFollowerAttachmentSocketName;       // 0x05F0(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5FC[0x4];                                      // 0x05FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAkObservedPlayerSoundLoop             _possessionSoundLoop;                              // 0x0600(0x0040)(Edit, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _respawnTimeAfterLamentConfigurationSolved;        // 0x0640(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _respawnTimeAfterKillerPickUp;                     // 0x0668(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _respawnTimeAfterSurvivorFreeBySelf;               // 0x0690(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _respawnTimeAfterSurvivorFreeByAttack;             // 0x06B8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _numberChainsToLaunchUponKillerPickUpLamentConfiguration; // 0x06E0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _hostageInteractionTime;                           // 0x0708(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_730[0x8];                                      // 0x0730(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	ELamentConfigurationState                     _localLamentConfigurationState;                    // 0x0738(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ELamentConfigurationState                     _lamentconfigurationState;                         // 0x0739(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_73A[0x6];                                      // 0x073A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class AAnimationFollowerActor*                _chainAnimationActor;                              // 0x0740(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_748[0x40];                                     // 0x0748(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	class ACamperPlayer*                          _survivorHeldHostage;                              // 0x0788(0x0008)(Net, ZeroConstructor, Transient, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_790[0x88];                                     // 0x0790(0x0088)(Fixing Size After Last Property [ Dumper-7 ])
	class UBoxComponent*                          _standingOnLamentConfigurationCollisionChecker;    // 0x0818(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _timeAllowedToStandOnCubeBeforeTeleport;           // 0x0820(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _solvedLamentConfigurationDropDistanceToCollectorCentimeters; // 0x0824(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _failedLamentConfigurationSolveDropDistanceToCollectorCentimeters; // 0x0828(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _solved;                                           // 0x082C(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _releasedByAttack;                                 // 0x082D(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_82E[0x2];                                      // 0x082E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class AK25LamentConfigurationTeleportIndicator* _lamentConfigurationTeleportIndicator;             // 0x0830(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Authority_OnEndGameOver(const struct FGameplayTag& GameEventType, const struct FGameEventData& GameEventData);
	void Authority_OnGameEnded(const struct FGameplayTag& GameEventType, const struct FGameEventData& GameEventData);
	void Authority_OnIntroCompletedOrLevelReadyToPlay();
	void Authority_OnOverlapBegin(class UPrimitiveComponent* OverlappedComponent, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void Authority_OnOverlapEnd(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void Authority_OnSurvivorHitByControlledProjectile(const struct FGameplayTag& GameEventType, const struct FGameEventData& GameEventData);
	void Authority_RespawnLamentConfiguration(bool TriggerChainHuntUponSpawning);
	void Cosmetic_BeginSolvingCube();
	void Cosmetic_EndSolvingCube(bool HasBeenSolved);
	void Cosmetic_OnChainHuntChargeEnd();
	void Cosmetic_OnChainHuntChargeStart(float ChargeTime);
	void Cosmetic_OnChainHuntEndedEffects();
	void Cosmetic_OnChainHuntStartedEffects();
	void Cosmetic_OnHoldingSurvivorHostageEnd(bool HasEndedThroughKillerAttack);
	void Cosmetic_OnHoldingSurvivorHostageStart(float HostageDuration);
	void Cosmetic_OnKillerDownedSurvivorHoldingLamentConfiguration(class ASlasherPlayer* Killer, class ACamperPlayer* SurvivorDowned);
	void Cosmetic_TriggerDisappearsSFX();
	void Cosmetic_TriggerOnSurvivorEscapedWithLamentConfigurationSFX();
	void Cosmetic_TriggerRespawnDuringChainHuntSFX();
	void Cosmetic_TriggerSolvedSFX();
	void Cosmetic_TriggerSpawnedSFX();
	void Cosmetic_TriggerSurvivorPickUpSFX();
	void Multicast_CorrectLamentConfigurationPosition(const struct FVector& NewPosition);
	void Multicast_DownedSurvivorHoldingLamentConfiguration(class ACamperPlayer* Survivor);
	void Multicast_TriggerKillerPickUpSFX(const TArray<class ACamperPlayer*>& AffectedSurvivors);
	void Multicast_TriggerSolvedSFX();
	void OnCamperEscaped(const struct FGameplayTag& GameEventType, const struct FGameEventData& GameEventData);
	void OnRep_LamentConfigurationState();
	void OnRep_SurvivorHeldHostage(class ACamperPlayer* OldSurvivorHeldHostage);
	void TriggerKillerPickUpSFX(const TArray<class ACamperPlayer*>& AffectedSurvivors);

	float GetChainHuntProgressPercentage() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LamentConfiguration">();
	}
	static class ALamentConfiguration* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALamentConfiguration>();
	}
};
static_assert(alignof(ALamentConfiguration) == 0x000008, "Wrong alignment on ALamentConfiguration");
static_assert(sizeof(ALamentConfiguration) == 0x000838, "Wrong size on ALamentConfiguration");
static_assert(offsetof(ALamentConfiguration, _interactable) == 0x000580, "Member 'ALamentConfiguration::_interactable' has a wrong offset!");
static_assert(offsetof(ALamentConfiguration, _collectableInteractor) == 0x000588, "Member 'ALamentConfiguration::_collectableInteractor' has a wrong offset!");
static_assert(offsetof(ALamentConfiguration, _survivorCollectItemInteraction) == 0x000590, "Member 'ALamentConfiguration::_survivorCollectItemInteraction' has a wrong offset!");
static_assert(offsetof(ALamentConfiguration, _killerCollectItemInteraction) == 0x000598, "Member 'ALamentConfiguration::_killerCollectItemInteraction' has a wrong offset!");
static_assert(offsetof(ALamentConfiguration, _outlineComponent) == 0x0005A0, "Member 'ALamentConfiguration::_outlineComponent' has a wrong offset!");
static_assert(offsetof(ALamentConfiguration, _materialHelper) == 0x0005A8, "Member 'ALamentConfiguration::_materialHelper' has a wrong offset!");
static_assert(offsetof(ALamentConfiguration, _outlineStrategy) == 0x0005B0, "Member 'ALamentConfiguration::_outlineStrategy' has a wrong offset!");
static_assert(offsetof(ALamentConfiguration, _spawnStrategy) == 0x0005B8, "Member 'ALamentConfiguration::_spawnStrategy' has a wrong offset!");
static_assert(offsetof(ALamentConfiguration, _chainHuntComponent) == 0x0005C0, "Member 'ALamentConfiguration::_chainHuntComponent' has a wrong offset!");
static_assert(offsetof(ALamentConfiguration, _dotProductMinValue) == 0x0005C8, "Member 'ALamentConfiguration::_dotProductMinValue' has a wrong offset!");
static_assert(offsetof(ALamentConfiguration, _survivorAttachmentSocket) == 0x0005CC, "Member 'ALamentConfiguration::_survivorAttachmentSocket' has a wrong offset!");
static_assert(offsetof(ALamentConfiguration, _killerAttachmentSocket) == 0x0005CD, "Member 'ALamentConfiguration::_killerAttachmentSocket' has a wrong offset!");
static_assert(offsetof(ALamentConfiguration, _montageFollower) == 0x0005D0, "Member 'ALamentConfiguration::_montageFollower' has a wrong offset!");
static_assert(offsetof(ALamentConfiguration, _montagePlayer) == 0x0005D8, "Member 'ALamentConfiguration::_montagePlayer' has a wrong offset!");
static_assert(offsetof(ALamentConfiguration, _chainAnimationActorClass) == 0x0005E0, "Member 'ALamentConfiguration::_chainAnimationActorClass' has a wrong offset!");
static_assert(offsetof(ALamentConfiguration, _lamentConfigurationTeleportIndicatorClass) == 0x0005E8, "Member 'ALamentConfiguration::_lamentConfigurationTeleportIndicatorClass' has a wrong offset!");
static_assert(offsetof(ALamentConfiguration, _chainAnimationFollowerAttachmentSocketName) == 0x0005F0, "Member 'ALamentConfiguration::_chainAnimationFollowerAttachmentSocketName' has a wrong offset!");
static_assert(offsetof(ALamentConfiguration, _possessionSoundLoop) == 0x000600, "Member 'ALamentConfiguration::_possessionSoundLoop' has a wrong offset!");
static_assert(offsetof(ALamentConfiguration, _respawnTimeAfterLamentConfigurationSolved) == 0x000640, "Member 'ALamentConfiguration::_respawnTimeAfterLamentConfigurationSolved' has a wrong offset!");
static_assert(offsetof(ALamentConfiguration, _respawnTimeAfterKillerPickUp) == 0x000668, "Member 'ALamentConfiguration::_respawnTimeAfterKillerPickUp' has a wrong offset!");
static_assert(offsetof(ALamentConfiguration, _respawnTimeAfterSurvivorFreeBySelf) == 0x000690, "Member 'ALamentConfiguration::_respawnTimeAfterSurvivorFreeBySelf' has a wrong offset!");
static_assert(offsetof(ALamentConfiguration, _respawnTimeAfterSurvivorFreeByAttack) == 0x0006B8, "Member 'ALamentConfiguration::_respawnTimeAfterSurvivorFreeByAttack' has a wrong offset!");
static_assert(offsetof(ALamentConfiguration, _numberChainsToLaunchUponKillerPickUpLamentConfiguration) == 0x0006E0, "Member 'ALamentConfiguration::_numberChainsToLaunchUponKillerPickUpLamentConfiguration' has a wrong offset!");
static_assert(offsetof(ALamentConfiguration, _hostageInteractionTime) == 0x000708, "Member 'ALamentConfiguration::_hostageInteractionTime' has a wrong offset!");
static_assert(offsetof(ALamentConfiguration, _localLamentConfigurationState) == 0x000738, "Member 'ALamentConfiguration::_localLamentConfigurationState' has a wrong offset!");
static_assert(offsetof(ALamentConfiguration, _lamentconfigurationState) == 0x000739, "Member 'ALamentConfiguration::_lamentconfigurationState' has a wrong offset!");
static_assert(offsetof(ALamentConfiguration, _chainAnimationActor) == 0x000740, "Member 'ALamentConfiguration::_chainAnimationActor' has a wrong offset!");
static_assert(offsetof(ALamentConfiguration, _survivorHeldHostage) == 0x000788, "Member 'ALamentConfiguration::_survivorHeldHostage' has a wrong offset!");
static_assert(offsetof(ALamentConfiguration, _standingOnLamentConfigurationCollisionChecker) == 0x000818, "Member 'ALamentConfiguration::_standingOnLamentConfigurationCollisionChecker' has a wrong offset!");
static_assert(offsetof(ALamentConfiguration, _timeAllowedToStandOnCubeBeforeTeleport) == 0x000820, "Member 'ALamentConfiguration::_timeAllowedToStandOnCubeBeforeTeleport' has a wrong offset!");
static_assert(offsetof(ALamentConfiguration, _solvedLamentConfigurationDropDistanceToCollectorCentimeters) == 0x000824, "Member 'ALamentConfiguration::_solvedLamentConfigurationDropDistanceToCollectorCentimeters' has a wrong offset!");
static_assert(offsetof(ALamentConfiguration, _failedLamentConfigurationSolveDropDistanceToCollectorCentimeters) == 0x000828, "Member 'ALamentConfiguration::_failedLamentConfigurationSolveDropDistanceToCollectorCentimeters' has a wrong offset!");
static_assert(offsetof(ALamentConfiguration, _solved) == 0x00082C, "Member 'ALamentConfiguration::_solved' has a wrong offset!");
static_assert(offsetof(ALamentConfiguration, _releasedByAttack) == 0x00082D, "Member 'ALamentConfiguration::_releasedByAttack' has a wrong offset!");
static_assert(offsetof(ALamentConfiguration, _lamentConfigurationTeleportIndicator) == 0x000830, "Member 'ALamentConfiguration::_lamentConfigurationTeleportIndicator' has a wrong offset!");

// Class TheK25.ChainAttachedGateBlockerEffect
// 0x0028 (0x03E0 - 0x03B8)
class UChainAttachedGateBlockerEffect final : public UGateBlockerEffect
{
public:
	struct FDBDTunableRowHandle                   _blockGateLingeringTimeDyingState;                 // 0x03B8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	void OnSurvivorDamageStateChanged(const ECamperDamageState OldState, const ECamperDamageState NewState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChainAttachedGateBlockerEffect">();
	}
	static class UChainAttachedGateBlockerEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChainAttachedGateBlockerEffect>();
	}
};
static_assert(alignof(UChainAttachedGateBlockerEffect) == 0x000008, "Wrong alignment on UChainAttachedGateBlockerEffect");
static_assert(sizeof(UChainAttachedGateBlockerEffect) == 0x0003E0, "Wrong size on UChainAttachedGateBlockerEffect");
static_assert(offsetof(UChainAttachedGateBlockerEffect, _blockGateLingeringTimeDyingState) == 0x0003B8, "Member 'UChainAttachedGateBlockerEffect::_blockGateLingeringTimeDyingState' has a wrong offset!");

// Class TheK25.LamentConfigurationAnalyticsComponent
// 0x0030 (0x00D8 - 0x00A8)
class ULamentConfigurationAnalyticsComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x30];                                      // 0x00A8(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LamentConfigurationAnalyticsComponent">();
	}
	static class ULamentConfigurationAnalyticsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULamentConfigurationAnalyticsComponent>();
	}
};
static_assert(alignof(ULamentConfigurationAnalyticsComponent) == 0x000008, "Wrong alignment on ULamentConfigurationAnalyticsComponent");
static_assert(sizeof(ULamentConfigurationAnalyticsComponent) == 0x0000D8, "Wrong size on ULamentConfigurationAnalyticsComponent");

// Class TheK25.IsChainHuntActive
// 0x0028 (0x0108 - 0x00E0)
class UIsChainHuntActive final : public UEventDrivenModifierCondition
{
public:
	uint8                                         Pad_E0[0x28];                                      // 0x00E0(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IsChainHuntActive">();
	}
	static class UIsChainHuntActive* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIsChainHuntActive>();
	}
};
static_assert(alignof(UIsChainHuntActive) == 0x000008, "Wrong alignment on UIsChainHuntActive");
static_assert(sizeof(UIsChainHuntActive) == 0x000108, "Wrong size on UIsChainHuntActive");

// Class TheK25.LamentConfigurationChainHuntComponent
// 0x01C8 (0x0270 - 0x00A8)
class ULamentConfigurationChainHuntComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x78];                                      // 0x00A8(0x0078)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _floorChainHuntTimeBetweenChainStrikes;            // 0x0120(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_124[0x4];                                      // 0x0124(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTunableStat                           _chainHuntChargeTime;                              // 0x0128(0x0080)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UCurveFloat*                            _chainNumberPerChainHuntCluster;                   // 0x01A8(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            _timeBetweenChainHuntClusterStrikes;               // 0x01B0(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UK25KillerChainHuntEffectsComponent> _killerChainHuntEffectsComponentClass;             // 0x01B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UK25SurvivorChainHuntEffectsComponent> _survivorChainHuntEffectsComponentClass;           // 0x01C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UK25KillerChainHuntEffectsComponent*    _killerChainHuntEffectsComponent;                  // 0x01C8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UK25SurvivorChainHuntEffectsComponent*> _chainHuntEffectsComponents;                       // 0x01D0(0x0010)(ExportObject, Net, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1E0[0x30];                                     // 0x01E0(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _cachedAdditiveChainStrikeDelayTime;               // 0x0210(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_214[0x34];                                     // 0x0214(0x0034)(Fixing Size After Last Property [ Dumper-7 ])
	struct FChainHuntStateData                    _chainHuntStateData;                               // 0x0248(0x0010)(Net, Transient, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)
	EChainHuntState                               _oldChainHuntState;                                // 0x0258(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_259[0x17];                                     // 0x0259(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_ChainHuntStateData();

	float GetChainHuntProgressPercentage() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LamentConfigurationChainHuntComponent">();
	}
	static class ULamentConfigurationChainHuntComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULamentConfigurationChainHuntComponent>();
	}
};
static_assert(alignof(ULamentConfigurationChainHuntComponent) == 0x000008, "Wrong alignment on ULamentConfigurationChainHuntComponent");
static_assert(sizeof(ULamentConfigurationChainHuntComponent) == 0x000270, "Wrong size on ULamentConfigurationChainHuntComponent");
static_assert(offsetof(ULamentConfigurationChainHuntComponent, _floorChainHuntTimeBetweenChainStrikes) == 0x000120, "Member 'ULamentConfigurationChainHuntComponent::_floorChainHuntTimeBetweenChainStrikes' has a wrong offset!");
static_assert(offsetof(ULamentConfigurationChainHuntComponent, _chainHuntChargeTime) == 0x000128, "Member 'ULamentConfigurationChainHuntComponent::_chainHuntChargeTime' has a wrong offset!");
static_assert(offsetof(ULamentConfigurationChainHuntComponent, _chainNumberPerChainHuntCluster) == 0x0001A8, "Member 'ULamentConfigurationChainHuntComponent::_chainNumberPerChainHuntCluster' has a wrong offset!");
static_assert(offsetof(ULamentConfigurationChainHuntComponent, _timeBetweenChainHuntClusterStrikes) == 0x0001B0, "Member 'ULamentConfigurationChainHuntComponent::_timeBetweenChainHuntClusterStrikes' has a wrong offset!");
static_assert(offsetof(ULamentConfigurationChainHuntComponent, _killerChainHuntEffectsComponentClass) == 0x0001B8, "Member 'ULamentConfigurationChainHuntComponent::_killerChainHuntEffectsComponentClass' has a wrong offset!");
static_assert(offsetof(ULamentConfigurationChainHuntComponent, _survivorChainHuntEffectsComponentClass) == 0x0001C0, "Member 'ULamentConfigurationChainHuntComponent::_survivorChainHuntEffectsComponentClass' has a wrong offset!");
static_assert(offsetof(ULamentConfigurationChainHuntComponent, _killerChainHuntEffectsComponent) == 0x0001C8, "Member 'ULamentConfigurationChainHuntComponent::_killerChainHuntEffectsComponent' has a wrong offset!");
static_assert(offsetof(ULamentConfigurationChainHuntComponent, _chainHuntEffectsComponents) == 0x0001D0, "Member 'ULamentConfigurationChainHuntComponent::_chainHuntEffectsComponents' has a wrong offset!");
static_assert(offsetof(ULamentConfigurationChainHuntComponent, _cachedAdditiveChainStrikeDelayTime) == 0x000210, "Member 'ULamentConfigurationChainHuntComponent::_cachedAdditiveChainStrikeDelayTime' has a wrong offset!");
static_assert(offsetof(ULamentConfigurationChainHuntComponent, _chainHuntStateData) == 0x000248, "Member 'ULamentConfigurationChainHuntComponent::_chainHuntStateData' has a wrong offset!");
static_assert(offsetof(ULamentConfigurationChainHuntComponent, _oldChainHuntState) == 0x000258, "Member 'ULamentConfigurationChainHuntComponent::_oldChainHuntState' has a wrong offset!");

// Class TheK25.K25AnimInstance
// 0x0010 (0x0730 - 0x0720)
class UK25AnimInstance final : public UKillerAnimInstance
{
public:
	bool                                          _isTeleporting;                                    // 0x0720(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isPossessingGateway;                              // 0x0721(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isSelectingGatewayLocation;                       // 0x0722(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_723[0xD];                                      // 0x0723(0x000D)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K25AnimInstance">();
	}
	static class UK25AnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK25AnimInstance>();
	}
};
static_assert(alignof(UK25AnimInstance) == 0x000010, "Wrong alignment on UK25AnimInstance");
static_assert(sizeof(UK25AnimInstance) == 0x000730, "Wrong size on UK25AnimInstance");
static_assert(offsetof(UK25AnimInstance, _isTeleporting) == 0x000720, "Member 'UK25AnimInstance::_isTeleporting' has a wrong offset!");
static_assert(offsetof(UK25AnimInstance, _isPossessingGateway) == 0x000721, "Member 'UK25AnimInstance::_isPossessingGateway' has a wrong offset!");
static_assert(offsetof(UK25AnimInstance, _isSelectingGatewayLocation) == 0x000722, "Member 'UK25AnimInstance::_isSelectingGatewayLocation' has a wrong offset!");

// Class TheK25.K25Chain
// 0x0240 (0x04E0 - 0x02A0)
class AK25Chain final : public AActor
{
public:
	uint8                                         Pad_2A0[0x8];                                      // 0x02A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnAcquiredChanged;                                 // 0x02A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UCurveFloat*                            _attachedToProjectileInfluenceCurve;               // 0x02B8(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            _reelbackInfluenceCurve;                           // 0x02C0(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            _offsetMultiplierInfluenceCurve;                   // 0x02C8(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D0[0x50];                                     // 0x02D0(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _reelingBackSpeed;                                 // 0x0320(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	float                                         _chainOffsetMinValue;                              // 0x0348(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _chainOffsetMaxValue;                              // 0x034C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _reelbackChainOffsetMinValue;                      // 0x0350(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _reelbackChainOffsetMaxValue;                      // 0x0354(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _chainInstanceSpacing;                             // 0x0358(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _quickChainOffsetTimerLength;                      // 0x035C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _reachingSurvivorAnchorTime;                       // 0x0360(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_364[0x4];                                      // 0x0364(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                _chainScale;                                       // 0x0368(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _chainOffsetTimerLength;                           // 0x0380(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_384[0x4];                                      // 0x0384(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        _currentChainPoints;                               // 0x0388(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	bool                                          _isAcquiredFromPool;                               // 0x0398(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_399[0x3];                                      // 0x0399(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _sphereTraceRadius;                                // 0x039C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                _chainStartPosition;                               // 0x03A0(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                _reelBackPosition;                                 // 0x03B8(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                _reelbackStartPosition;                            // 0x03D0(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AK25Projectile*                         _projectileAttachedTo;                             // 0x03E8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class AK25SurvivorChainAttachmentAnchor> _survivorAnchorAttachedTo;                         // 0x03F0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class AK25SurvivorChainAttachmentAnchor> _targetAnchorToReach;                              // 0x03F8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USplineComponent*                       _chainSplineComponent;                             // 0x0400(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInstancedStaticMeshComponent*          _chainInstancedMesh;                               // 0x0408(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _currentInfluenceCurve;                            // 0x0410(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                _chainCurveOffset;                                 // 0x0418(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EK25ChainState                                _chainState;                                       // 0x0430(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_431[0x7];                                      // 0x0431(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFastTimer                             _curveOffsetStrengthTimer;                         // 0x0438(0x0030)(Transient, NativeAccessSpecifierPrivate)
	struct FFastTimer                             _reelbackTimer;                                    // 0x0468(0x0030)(Transient, NativeAccessSpecifierPrivate)
	struct FFastTimer                             _reachSurvivorAnchorPositionTimer;                 // 0x0498(0x0030)(Transient, NativeAccessSpecifierPrivate)
	TArray<struct FVector>                        _forcedPositions;                                  // 0x04C8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	EK25ChainCreationStrategy                     _chainCreationStrategy;                            // 0x04D8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4D9[0x7];                                      // 0x04D9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_OnChainAppears();
	void Cosmetic_OnChainAttachedToSurvivor(bool WasReachingSurvivorAnchorPoint);
	void Cosmetic_OnChainDetachedFromSurvivor(EK25ChainDetachmentReason DetachmentReason);
	void Cosmetic_OnChainDisappears();
	void Cosmetic_OnChainStartedToReelback();
	void Cosmetic_OnChainUnleashedWithProjectile();
	void Cosmetic_OnInstantChainUnleashedTowardsAttachmentPointFX();
	void Cosmetic_OnSurvivorStartedRemovingChainSFX();
	void Cosmetic_OnSurvivorStoppedRemovingChainSFX(bool HasRemovedChainDueToInteraction);
	void SetInstancedMeshComponent(class UInstancedStaticMeshComponent* InstancedMesh);
	void SetSplineComponent(class USplineComponent* Component);

	struct FVector GetChainEndLocation() const;
	struct FVector GetChainStartLocation() const;
	class AK25SurvivorChainAttachmentAnchor* GetSurvivorChainAttachmentAnchor() const;
	bool IsAttachedToControlledProjectile() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K25Chain">();
	}
	static class AK25Chain* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK25Chain>();
	}
};
static_assert(alignof(AK25Chain) == 0x000008, "Wrong alignment on AK25Chain");
static_assert(sizeof(AK25Chain) == 0x0004E0, "Wrong size on AK25Chain");
static_assert(offsetof(AK25Chain, OnAcquiredChanged) == 0x0002A8, "Member 'AK25Chain::OnAcquiredChanged' has a wrong offset!");
static_assert(offsetof(AK25Chain, _attachedToProjectileInfluenceCurve) == 0x0002B8, "Member 'AK25Chain::_attachedToProjectileInfluenceCurve' has a wrong offset!");
static_assert(offsetof(AK25Chain, _reelbackInfluenceCurve) == 0x0002C0, "Member 'AK25Chain::_reelbackInfluenceCurve' has a wrong offset!");
static_assert(offsetof(AK25Chain, _offsetMultiplierInfluenceCurve) == 0x0002C8, "Member 'AK25Chain::_offsetMultiplierInfluenceCurve' has a wrong offset!");
static_assert(offsetof(AK25Chain, _reelingBackSpeed) == 0x000320, "Member 'AK25Chain::_reelingBackSpeed' has a wrong offset!");
static_assert(offsetof(AK25Chain, _chainOffsetMinValue) == 0x000348, "Member 'AK25Chain::_chainOffsetMinValue' has a wrong offset!");
static_assert(offsetof(AK25Chain, _chainOffsetMaxValue) == 0x00034C, "Member 'AK25Chain::_chainOffsetMaxValue' has a wrong offset!");
static_assert(offsetof(AK25Chain, _reelbackChainOffsetMinValue) == 0x000350, "Member 'AK25Chain::_reelbackChainOffsetMinValue' has a wrong offset!");
static_assert(offsetof(AK25Chain, _reelbackChainOffsetMaxValue) == 0x000354, "Member 'AK25Chain::_reelbackChainOffsetMaxValue' has a wrong offset!");
static_assert(offsetof(AK25Chain, _chainInstanceSpacing) == 0x000358, "Member 'AK25Chain::_chainInstanceSpacing' has a wrong offset!");
static_assert(offsetof(AK25Chain, _quickChainOffsetTimerLength) == 0x00035C, "Member 'AK25Chain::_quickChainOffsetTimerLength' has a wrong offset!");
static_assert(offsetof(AK25Chain, _reachingSurvivorAnchorTime) == 0x000360, "Member 'AK25Chain::_reachingSurvivorAnchorTime' has a wrong offset!");
static_assert(offsetof(AK25Chain, _chainScale) == 0x000368, "Member 'AK25Chain::_chainScale' has a wrong offset!");
static_assert(offsetof(AK25Chain, _chainOffsetTimerLength) == 0x000380, "Member 'AK25Chain::_chainOffsetTimerLength' has a wrong offset!");
static_assert(offsetof(AK25Chain, _currentChainPoints) == 0x000388, "Member 'AK25Chain::_currentChainPoints' has a wrong offset!");
static_assert(offsetof(AK25Chain, _isAcquiredFromPool) == 0x000398, "Member 'AK25Chain::_isAcquiredFromPool' has a wrong offset!");
static_assert(offsetof(AK25Chain, _sphereTraceRadius) == 0x00039C, "Member 'AK25Chain::_sphereTraceRadius' has a wrong offset!");
static_assert(offsetof(AK25Chain, _chainStartPosition) == 0x0003A0, "Member 'AK25Chain::_chainStartPosition' has a wrong offset!");
static_assert(offsetof(AK25Chain, _reelBackPosition) == 0x0003B8, "Member 'AK25Chain::_reelBackPosition' has a wrong offset!");
static_assert(offsetof(AK25Chain, _reelbackStartPosition) == 0x0003D0, "Member 'AK25Chain::_reelbackStartPosition' has a wrong offset!");
static_assert(offsetof(AK25Chain, _projectileAttachedTo) == 0x0003E8, "Member 'AK25Chain::_projectileAttachedTo' has a wrong offset!");
static_assert(offsetof(AK25Chain, _survivorAnchorAttachedTo) == 0x0003F0, "Member 'AK25Chain::_survivorAnchorAttachedTo' has a wrong offset!");
static_assert(offsetof(AK25Chain, _targetAnchorToReach) == 0x0003F8, "Member 'AK25Chain::_targetAnchorToReach' has a wrong offset!");
static_assert(offsetof(AK25Chain, _chainSplineComponent) == 0x000400, "Member 'AK25Chain::_chainSplineComponent' has a wrong offset!");
static_assert(offsetof(AK25Chain, _chainInstancedMesh) == 0x000408, "Member 'AK25Chain::_chainInstancedMesh' has a wrong offset!");
static_assert(offsetof(AK25Chain, _currentInfluenceCurve) == 0x000410, "Member 'AK25Chain::_currentInfluenceCurve' has a wrong offset!");
static_assert(offsetof(AK25Chain, _chainCurveOffset) == 0x000418, "Member 'AK25Chain::_chainCurveOffset' has a wrong offset!");
static_assert(offsetof(AK25Chain, _chainState) == 0x000430, "Member 'AK25Chain::_chainState' has a wrong offset!");
static_assert(offsetof(AK25Chain, _curveOffsetStrengthTimer) == 0x000438, "Member 'AK25Chain::_curveOffsetStrengthTimer' has a wrong offset!");
static_assert(offsetof(AK25Chain, _reelbackTimer) == 0x000468, "Member 'AK25Chain::_reelbackTimer' has a wrong offset!");
static_assert(offsetof(AK25Chain, _reachSurvivorAnchorPositionTimer) == 0x000498, "Member 'AK25Chain::_reachSurvivorAnchorPositionTimer' has a wrong offset!");
static_assert(offsetof(AK25Chain, _forcedPositions) == 0x0004C8, "Member 'AK25Chain::_forcedPositions' has a wrong offset!");
static_assert(offsetof(AK25Chain, _chainCreationStrategy) == 0x0004D8, "Member 'AK25Chain::_chainCreationStrategy' has a wrong offset!");

// Class TheK25.K25ChainAttachedStatusEffect
// 0x0018 (0x0398 - 0x0380)
class UK25ChainAttachedStatusEffect final : public UStatusEffect
{
public:
	class UCurveFloat*                            _percentageReductionSpeedPerChainCurve;            // 0x0380(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UK25SurvivorChainAttachmentComponent*   _chainAttachmentComponent;                         // 0x0388(0x0008)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         _cachedNumberOfChainsAttached;                     // 0x0390(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_394[0x4];                                      // 0x0394(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_ChainAttachementComponent();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K25ChainAttachedStatusEffect">();
	}
	static class UK25ChainAttachedStatusEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK25ChainAttachedStatusEffect>();
	}
};
static_assert(alignof(UK25ChainAttachedStatusEffect) == 0x000008, "Wrong alignment on UK25ChainAttachedStatusEffect");
static_assert(sizeof(UK25ChainAttachedStatusEffect) == 0x000398, "Wrong size on UK25ChainAttachedStatusEffect");
static_assert(offsetof(UK25ChainAttachedStatusEffect, _percentageReductionSpeedPerChainCurve) == 0x000380, "Member 'UK25ChainAttachedStatusEffect::_percentageReductionSpeedPerChainCurve' has a wrong offset!");
static_assert(offsetof(UK25ChainAttachedStatusEffect, _chainAttachmentComponent) == 0x000388, "Member 'UK25ChainAttachedStatusEffect::_chainAttachmentComponent' has a wrong offset!");
static_assert(offsetof(UK25ChainAttachedStatusEffect, _cachedNumberOfChainsAttached) == 0x000390, "Member 'UK25ChainAttachedStatusEffect::_cachedNumberOfChainsAttached' has a wrong offset!");

// Class TheK25.K25ChainAttachmentReplicationComponent
// 0x0000 (0x00A8 - 0x00A8)
class UK25ChainAttachmentReplicationComponent final : public UActorComponent
{
public:
	void Multicast_AttachChainToAnchor(class UK25SurvivorChainAttachmentComponent* ChainAttachementComponent, class AK25Chain* ChainToAttach, class AK25SurvivorChainAttachmentAnchor* AnchorPoint);
	void Multicast_DetachChains(class UK25SurvivorChainAttachmentComponent* ChainAttachementComponent, const TArray<class AK25Chain*>& ChainsToDetach, EK25ChainDetachmentReason DetachmentReason, const TArray<class AK25Chain*>& ChainsAttached);
	void Multicast_LaunchInstantHitChainTowardsSurvivor(class AK25Chain* NewChainToAttach, class AK25SurvivorChainAttachmentAnchor* TargetAnchor, const struct FVector& StartPosition);
	void Multicast_StartChainReelback(class AK25Chain* ChainToAttach);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K25ChainAttachmentReplicationComponent">();
	}
	static class UK25ChainAttachmentReplicationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK25ChainAttachmentReplicationComponent>();
	}
};
static_assert(alignof(UK25ChainAttachmentReplicationComponent) == 0x000008, "Wrong alignment on UK25ChainAttachmentReplicationComponent");
static_assert(sizeof(UK25ChainAttachmentReplicationComponent) == 0x0000A8, "Wrong size on UK25ChainAttachmentReplicationComponent");

// Class TheK25.K25ChainHuntEffectsComponent
// 0x0060 (0x0108 - 0x00A8)
class UK25ChainHuntEffectsComponent : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x60];                                      // 0x00A8(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_ActivateChainHuntEffects(const bool HasChainHuntStarted);
	void Cosmetic_DeactivateChainHuntEffects();
	void Cosmetic_TriggerChainHuntActivationSFX();

	class ADBDPlayer* GetOwningPlayer() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K25ChainHuntEffectsComponent">();
	}
	static class UK25ChainHuntEffectsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK25ChainHuntEffectsComponent>();
	}
};
static_assert(alignof(UK25ChainHuntEffectsComponent) == 0x000008, "Wrong alignment on UK25ChainHuntEffectsComponent");
static_assert(sizeof(UK25ChainHuntEffectsComponent) == 0x000108, "Wrong size on UK25ChainHuntEffectsComponent");

// Class TheK25.K25ChainLocomotionSurvivorAnimInstance
// 0x0190 (0x0770 - 0x05E0)
class UK25ChainLocomotionSurvivorAnimInstance final : public UBaseSurvivorAnimInstance
{
public:
	uint8                                         Pad_5E0[0x8];                                      // 0x05E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _hasChainsAttached;                                // 0x05E8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isPerformingBreakChainInteraction;                // 0x05E9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5EA[0x2];                                      // 0x05EA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _forwardDirectionDotProductResult;                 // 0x05EC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _lateralDirectionDotProductResult;                 // 0x05F0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5F4[0x4];                                      // 0x05F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AK25Chain*                              _currentChainBeingDetached;                        // 0x05F8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FK25ChainAnchorAnimationData           _leftHandAttachmentData;                           // 0x0600(0x0018)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FK25ChainAnchorAnimationData           _rightHandAttachmentData;                          // 0x0618(0x0018)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FK25ChainAnchorAnimationData           _leftShoulderAttachmentData;                       // 0x0630(0x0018)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FK25ChainAnchorAnimationData           _rightShoulderAttachmentData;                      // 0x0648(0x0018)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FK25ChainAnchorAnimationData           _stomachAttachmentData;                            // 0x0660(0x0018)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FK25ChainAnchorAnimationData           _backAttachmentData;                               // 0x0678(0x0018)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	EK25ChainAnchorPointDirection                 _chainDirection;                                   // 0x0690(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _hasBrokenFreeFromChain;                           // 0x0691(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_692[0x2];                                      // 0x0692(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _hasBrokenFreeTime;                                // 0x0694(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _hasBeenHitByChain;                                // 0x0698(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isIdle;                                           // 0x0699(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isCrouched;                                       // 0x069A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isMale;                                           // 0x069B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isBeingCarried;                                   // 0x069C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_69D[0x3];                                      // 0x069D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _hasBeenHitByChainTime;                            // 0x06A0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _hitChainName;                                     // 0x06A4(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _detachedChainAnchorName;                          // 0x06B0(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6BC[0xB4];                                     // 0x06BC(0x00B4)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnChainAttached(class AK25Chain* Chain, class AK25SurvivorChainAttachmentAnchor* ChainAttachmentAnchor);
	void OnChainDetached(class AK25Chain* Chain, class AK25SurvivorChainAttachmentAnchor* ChainAttachmentAnchor, EK25ChainDetachmentReason DetachmentReason);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K25ChainLocomotionSurvivorAnimInstance">();
	}
	static class UK25ChainLocomotionSurvivorAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK25ChainLocomotionSurvivorAnimInstance>();
	}
};
static_assert(alignof(UK25ChainLocomotionSurvivorAnimInstance) == 0x000010, "Wrong alignment on UK25ChainLocomotionSurvivorAnimInstance");
static_assert(sizeof(UK25ChainLocomotionSurvivorAnimInstance) == 0x000770, "Wrong size on UK25ChainLocomotionSurvivorAnimInstance");
static_assert(offsetof(UK25ChainLocomotionSurvivorAnimInstance, _hasChainsAttached) == 0x0005E8, "Member 'UK25ChainLocomotionSurvivorAnimInstance::_hasChainsAttached' has a wrong offset!");
static_assert(offsetof(UK25ChainLocomotionSurvivorAnimInstance, _isPerformingBreakChainInteraction) == 0x0005E9, "Member 'UK25ChainLocomotionSurvivorAnimInstance::_isPerformingBreakChainInteraction' has a wrong offset!");
static_assert(offsetof(UK25ChainLocomotionSurvivorAnimInstance, _forwardDirectionDotProductResult) == 0x0005EC, "Member 'UK25ChainLocomotionSurvivorAnimInstance::_forwardDirectionDotProductResult' has a wrong offset!");
static_assert(offsetof(UK25ChainLocomotionSurvivorAnimInstance, _lateralDirectionDotProductResult) == 0x0005F0, "Member 'UK25ChainLocomotionSurvivorAnimInstance::_lateralDirectionDotProductResult' has a wrong offset!");
static_assert(offsetof(UK25ChainLocomotionSurvivorAnimInstance, _currentChainBeingDetached) == 0x0005F8, "Member 'UK25ChainLocomotionSurvivorAnimInstance::_currentChainBeingDetached' has a wrong offset!");
static_assert(offsetof(UK25ChainLocomotionSurvivorAnimInstance, _leftHandAttachmentData) == 0x000600, "Member 'UK25ChainLocomotionSurvivorAnimInstance::_leftHandAttachmentData' has a wrong offset!");
static_assert(offsetof(UK25ChainLocomotionSurvivorAnimInstance, _rightHandAttachmentData) == 0x000618, "Member 'UK25ChainLocomotionSurvivorAnimInstance::_rightHandAttachmentData' has a wrong offset!");
static_assert(offsetof(UK25ChainLocomotionSurvivorAnimInstance, _leftShoulderAttachmentData) == 0x000630, "Member 'UK25ChainLocomotionSurvivorAnimInstance::_leftShoulderAttachmentData' has a wrong offset!");
static_assert(offsetof(UK25ChainLocomotionSurvivorAnimInstance, _rightShoulderAttachmentData) == 0x000648, "Member 'UK25ChainLocomotionSurvivorAnimInstance::_rightShoulderAttachmentData' has a wrong offset!");
static_assert(offsetof(UK25ChainLocomotionSurvivorAnimInstance, _stomachAttachmentData) == 0x000660, "Member 'UK25ChainLocomotionSurvivorAnimInstance::_stomachAttachmentData' has a wrong offset!");
static_assert(offsetof(UK25ChainLocomotionSurvivorAnimInstance, _backAttachmentData) == 0x000678, "Member 'UK25ChainLocomotionSurvivorAnimInstance::_backAttachmentData' has a wrong offset!");
static_assert(offsetof(UK25ChainLocomotionSurvivorAnimInstance, _chainDirection) == 0x000690, "Member 'UK25ChainLocomotionSurvivorAnimInstance::_chainDirection' has a wrong offset!");
static_assert(offsetof(UK25ChainLocomotionSurvivorAnimInstance, _hasBrokenFreeFromChain) == 0x000691, "Member 'UK25ChainLocomotionSurvivorAnimInstance::_hasBrokenFreeFromChain' has a wrong offset!");
static_assert(offsetof(UK25ChainLocomotionSurvivorAnimInstance, _hasBrokenFreeTime) == 0x000694, "Member 'UK25ChainLocomotionSurvivorAnimInstance::_hasBrokenFreeTime' has a wrong offset!");
static_assert(offsetof(UK25ChainLocomotionSurvivorAnimInstance, _hasBeenHitByChain) == 0x000698, "Member 'UK25ChainLocomotionSurvivorAnimInstance::_hasBeenHitByChain' has a wrong offset!");
static_assert(offsetof(UK25ChainLocomotionSurvivorAnimInstance, _isIdle) == 0x000699, "Member 'UK25ChainLocomotionSurvivorAnimInstance::_isIdle' has a wrong offset!");
static_assert(offsetof(UK25ChainLocomotionSurvivorAnimInstance, _isCrouched) == 0x00069A, "Member 'UK25ChainLocomotionSurvivorAnimInstance::_isCrouched' has a wrong offset!");
static_assert(offsetof(UK25ChainLocomotionSurvivorAnimInstance, _isMale) == 0x00069B, "Member 'UK25ChainLocomotionSurvivorAnimInstance::_isMale' has a wrong offset!");
static_assert(offsetof(UK25ChainLocomotionSurvivorAnimInstance, _isBeingCarried) == 0x00069C, "Member 'UK25ChainLocomotionSurvivorAnimInstance::_isBeingCarried' has a wrong offset!");
static_assert(offsetof(UK25ChainLocomotionSurvivorAnimInstance, _hasBeenHitByChainTime) == 0x0006A0, "Member 'UK25ChainLocomotionSurvivorAnimInstance::_hasBeenHitByChainTime' has a wrong offset!");
static_assert(offsetof(UK25ChainLocomotionSurvivorAnimInstance, _hitChainName) == 0x0006A4, "Member 'UK25ChainLocomotionSurvivorAnimInstance::_hitChainName' has a wrong offset!");
static_assert(offsetof(UK25ChainLocomotionSurvivorAnimInstance, _detachedChainAnchorName) == 0x0006B0, "Member 'UK25ChainLocomotionSurvivorAnimInstance::_detachedChainAnchorName' has a wrong offset!");

// Class TheK25.K25ChainPool
// 0x0000 (0x0108 - 0x0108)
class UK25ChainPool final : public UAuthoritativeActorPoolComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K25ChainPool">();
	}
	static class UK25ChainPool* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK25ChainPool>();
	}
};
static_assert(alignof(UK25ChainPool) == 0x000008, "Wrong alignment on UK25ChainPool");
static_assert(sizeof(UK25ChainPool) == 0x000108, "Wrong size on UK25ChainPool");

// Class TheK25.K25ChainStrikeBaseState
// 0x0050 (0x00C8 - 0x0078)
class UK25ChainStrikeBaseState : public UFSM_State
{
public:
	TSet<class FName>                             _secondaryInteractionIDs;                          // 0x0078(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	class AK25Gateway* GetK25Gateway() const;
	class AK25Power* GetK25Power() const;
	class ADBDPlayer* GetPlayerOwner() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K25ChainStrikeBaseState">();
	}
	static class UK25ChainStrikeBaseState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK25ChainStrikeBaseState>();
	}
};
static_assert(alignof(UK25ChainStrikeBaseState) == 0x000008, "Wrong alignment on UK25ChainStrikeBaseState");
static_assert(sizeof(UK25ChainStrikeBaseState) == 0x0000C8, "Wrong size on UK25ChainStrikeBaseState");
static_assert(offsetof(UK25ChainStrikeBaseState, _secondaryInteractionIDs) == 0x000078, "Member 'UK25ChainStrikeBaseState::_secondaryInteractionIDs' has a wrong offset!");

// Class TheK25.K25ChainStrikeImmunityEffect
// 0x0028 (0x03D8 - 0x03B0)
class UK25ChainStrikeImmunityEffect final : public UActivateOnEventTimedStatusEffect
{
public:
	struct FDBDTunableRowHandle                   _chainStrikeImmunityDuration;                      // 0x03B0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K25ChainStrikeImmunityEffect">();
	}
	static class UK25ChainStrikeImmunityEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK25ChainStrikeImmunityEffect>();
	}
};
static_assert(alignof(UK25ChainStrikeImmunityEffect) == 0x000008, "Wrong alignment on UK25ChainStrikeImmunityEffect");
static_assert(sizeof(UK25ChainStrikeImmunityEffect) == 0x0003D8, "Wrong size on UK25ChainStrikeImmunityEffect");
static_assert(offsetof(UK25ChainStrikeImmunityEffect, _chainStrikeImmunityDuration) == 0x0003B0, "Member 'UK25ChainStrikeImmunityEffect::_chainStrikeImmunityDuration' has a wrong offset!");

// Class TheK25.K25ChainStrikeInteraction
// 0x0200 (0x0AC0 - 0x08C0)
class UK25ChainStrikeInteraction final : public UChargeableInteractionDefinition
{
public:
	TSubclassOf<class UFiniteStateMachine>        _chainStrikeStateMachineclass;                     // 0x08C0(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _repossessFadeOutTime;                             // 0x08C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8CC[0x4];                                      // 0x08CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _repossessFadeInTime;                              // 0x08D0(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UCurveFloat*                            _gatewayPossessionFovModifierCurve;                // 0x08F8(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _chargeTimeAfterGatewayPlacementCancelled;         // 0x0900(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _chargeTimeAfterGatewayPossessionCancelled;        // 0x0928(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _chargeTimeAfterControlledChainShot;               // 0x0950(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _gatewayPossessionFovChangeDuration;               // 0x0978(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _gatewayPossessionCameraPanTime;                   // 0x09A0(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _controlledProjectilePossessionCameraPanTime;      // 0x09C8(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	class UFiniteStateMachine*                    _stateMachine;                                     // 0x09F0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _authority_shouldIncrementChargeableComponent;     // 0x09F8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_9F9[0x68];                                     // 0x09F9(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	EChainStrikeCameraViewTarget                  _chainStrikeCameraViewTarget;                      // 0x0A61(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _hasHitSurvivor;                                   // 0x0A62(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A63[0x5D];                                     // 0x0A63(0x005D)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_ResetAllVignetteValues(class ASlasherPlayer* Killer);
	void Cosmetic_TriggerGatewayPossessionEffects(const float TransitionTime);
	void Cosmetic_TriggerKillerRepossessionFadeInEffects(class ASlasherPlayer* Killer, const bool HasHitSurvivor, const bool PreventAudioTriggers);
	void Cosmetic_TriggerKillerRepossessionFadeOutEffects(class ASlasherPlayer* Killer, const bool PreventAudioTriggers);
	void Multicast_AddStateTagToPlayer(const struct FGameplayTag& Tag);
	void Multicast_RemoveStateTagFromPlayer(const struct FGameplayTag& Tag);
	void Multicast_SetFallbackEndReason(EChainStrikeEndReason ChainStrikeEndReason);
	void OnRep_ChainStrikeCameraViewTarget();
	void Server_AddStateTagToPlayer(const struct FGameplayTag& Tag);
	void Server_RemoveStateTagFromPlayer(const struct FGameplayTag& Tag);
	void Server_SetFallbackEndReason(EChainStrikeEndReason ChainStrikeEndReason);
	void Server_SetShouldIncrementChargeableComponent(bool ShouldIncrement);
	void Server_UpdateCameraViewTargetForObservers(EChainStrikeCameraViewTarget NewViewTarget);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K25ChainStrikeInteraction">();
	}
	static class UK25ChainStrikeInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK25ChainStrikeInteraction>();
	}
};
static_assert(alignof(UK25ChainStrikeInteraction) == 0x000010, "Wrong alignment on UK25ChainStrikeInteraction");
static_assert(sizeof(UK25ChainStrikeInteraction) == 0x000AC0, "Wrong size on UK25ChainStrikeInteraction");
static_assert(offsetof(UK25ChainStrikeInteraction, _chainStrikeStateMachineclass) == 0x0008C0, "Member 'UK25ChainStrikeInteraction::_chainStrikeStateMachineclass' has a wrong offset!");
static_assert(offsetof(UK25ChainStrikeInteraction, _repossessFadeOutTime) == 0x0008C8, "Member 'UK25ChainStrikeInteraction::_repossessFadeOutTime' has a wrong offset!");
static_assert(offsetof(UK25ChainStrikeInteraction, _repossessFadeInTime) == 0x0008D0, "Member 'UK25ChainStrikeInteraction::_repossessFadeInTime' has a wrong offset!");
static_assert(offsetof(UK25ChainStrikeInteraction, _gatewayPossessionFovModifierCurve) == 0x0008F8, "Member 'UK25ChainStrikeInteraction::_gatewayPossessionFovModifierCurve' has a wrong offset!");
static_assert(offsetof(UK25ChainStrikeInteraction, _chargeTimeAfterGatewayPlacementCancelled) == 0x000900, "Member 'UK25ChainStrikeInteraction::_chargeTimeAfterGatewayPlacementCancelled' has a wrong offset!");
static_assert(offsetof(UK25ChainStrikeInteraction, _chargeTimeAfterGatewayPossessionCancelled) == 0x000928, "Member 'UK25ChainStrikeInteraction::_chargeTimeAfterGatewayPossessionCancelled' has a wrong offset!");
static_assert(offsetof(UK25ChainStrikeInteraction, _chargeTimeAfterControlledChainShot) == 0x000950, "Member 'UK25ChainStrikeInteraction::_chargeTimeAfterControlledChainShot' has a wrong offset!");
static_assert(offsetof(UK25ChainStrikeInteraction, _gatewayPossessionFovChangeDuration) == 0x000978, "Member 'UK25ChainStrikeInteraction::_gatewayPossessionFovChangeDuration' has a wrong offset!");
static_assert(offsetof(UK25ChainStrikeInteraction, _gatewayPossessionCameraPanTime) == 0x0009A0, "Member 'UK25ChainStrikeInteraction::_gatewayPossessionCameraPanTime' has a wrong offset!");
static_assert(offsetof(UK25ChainStrikeInteraction, _controlledProjectilePossessionCameraPanTime) == 0x0009C8, "Member 'UK25ChainStrikeInteraction::_controlledProjectilePossessionCameraPanTime' has a wrong offset!");
static_assert(offsetof(UK25ChainStrikeInteraction, _stateMachine) == 0x0009F0, "Member 'UK25ChainStrikeInteraction::_stateMachine' has a wrong offset!");
static_assert(offsetof(UK25ChainStrikeInteraction, _authority_shouldIncrementChargeableComponent) == 0x0009F8, "Member 'UK25ChainStrikeInteraction::_authority_shouldIncrementChargeableComponent' has a wrong offset!");
static_assert(offsetof(UK25ChainStrikeInteraction, _chainStrikeCameraViewTarget) == 0x000A61, "Member 'UK25ChainStrikeInteraction::_chainStrikeCameraViewTarget' has a wrong offset!");
static_assert(offsetof(UK25ChainStrikeInteraction, _hasHitSurvivor) == 0x000A62, "Member 'UK25ChainStrikeInteraction::_hasHitSurvivor' has a wrong offset!");

// Class TheK25.K25ChainStrikeReplicationComponent
// 0x0000 (0x00A8 - 0x00A8)
class UK25ChainStrikeReplicationComponent final : public UActorComponent
{
public:
	void Multicast_EndChainStrike(class UK25ChainStrikeInteraction* Interaction, EChainStrikeEndReason EndReason);
	void Server_EndChainStrike(class UK25ChainStrikeInteraction* Interaction, EChainStrikeEndReason EndReason);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K25ChainStrikeReplicationComponent">();
	}
	static class UK25ChainStrikeReplicationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK25ChainStrikeReplicationComponent>();
	}
};
static_assert(alignof(UK25ChainStrikeReplicationComponent) == 0x000008, "Wrong alignment on UK25ChainStrikeReplicationComponent");
static_assert(sizeof(UK25ChainStrikeReplicationComponent) == 0x0000A8, "Wrong size on UK25ChainStrikeReplicationComponent");

// Class TheK25.K25ChainStrikeState_EndChainStrike
// 0x0008 (0x00D0 - 0x00C8)
class UK25ChainStrikeState_EndChainStrike final : public UK25ChainStrikeBaseState
{
public:
	EChainStrikeEndReason                         _chainStrikeEndReason;                             // 0x00C8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C9[0x7];                                       // 0x00C9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K25ChainStrikeState_EndChainStrike">();
	}
	static class UK25ChainStrikeState_EndChainStrike* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK25ChainStrikeState_EndChainStrike>();
	}
};
static_assert(alignof(UK25ChainStrikeState_EndChainStrike) == 0x000008, "Wrong alignment on UK25ChainStrikeState_EndChainStrike");
static_assert(sizeof(UK25ChainStrikeState_EndChainStrike) == 0x0000D0, "Wrong size on UK25ChainStrikeState_EndChainStrike");
static_assert(offsetof(UK25ChainStrikeState_EndChainStrike, _chainStrikeEndReason) == 0x0000C8, "Member 'UK25ChainStrikeState_EndChainStrike::_chainStrikeEndReason' has a wrong offset!");

// Class TheK25.K25ChainStrikeState_GatewayPlacement
// 0x0000 (0x00C8 - 0x00C8)
class UK25ChainStrikeState_GatewayPlacement final : public UK25ChainStrikeBaseState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K25ChainStrikeState_GatewayPlacement">();
	}
	static class UK25ChainStrikeState_GatewayPlacement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK25ChainStrikeState_GatewayPlacement>();
	}
};
static_assert(alignof(UK25ChainStrikeState_GatewayPlacement) == 0x000008, "Wrong alignment on UK25ChainStrikeState_GatewayPlacement");
static_assert(sizeof(UK25ChainStrikeState_GatewayPlacement) == 0x0000C8, "Wrong size on UK25ChainStrikeState_GatewayPlacement");

// Class TheK25.K25ChainStrikeState_OutOfBodyState
// 0x0028 (0x00F0 - 0x00C8)
class UK25ChainStrikeState_OutOfBodyState final : public UK25ChainStrikeBaseState
{
public:
	struct FDBDTunableRowHandle                   _fovTimeChangeDuration;                            // 0x00C8(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K25ChainStrikeState_OutOfBodyState">();
	}
	static class UK25ChainStrikeState_OutOfBodyState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK25ChainStrikeState_OutOfBodyState>();
	}
};
static_assert(alignof(UK25ChainStrikeState_OutOfBodyState) == 0x000008, "Wrong alignment on UK25ChainStrikeState_OutOfBodyState");
static_assert(sizeof(UK25ChainStrikeState_OutOfBodyState) == 0x0000F0, "Wrong size on UK25ChainStrikeState_OutOfBodyState");
static_assert(offsetof(UK25ChainStrikeState_OutOfBodyState, _fovTimeChangeDuration) == 0x0000C8, "Member 'UK25ChainStrikeState_OutOfBodyState::_fovTimeChangeDuration' has a wrong offset!");

// Class TheK25.K25ChainStrikeState_PossessGateway
// 0x0010 (0x00D8 - 0x00C8)
class UK25ChainStrikeState_PossessGateway final : public UK25ChainStrikeBaseState
{
public:
	uint8                                         Pad_C8[0x10];                                      // 0x00C8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K25ChainStrikeState_PossessGateway">();
	}
	static class UK25ChainStrikeState_PossessGateway* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK25ChainStrikeState_PossessGateway>();
	}
};
static_assert(alignof(UK25ChainStrikeState_PossessGateway) == 0x000008, "Wrong alignment on UK25ChainStrikeState_PossessGateway");
static_assert(sizeof(UK25ChainStrikeState_PossessGateway) == 0x0000D8, "Wrong size on UK25ChainStrikeState_PossessGateway");

// Class TheK25.K25ChainStrikeState_SelectGatewayOrientation
// 0x0018 (0x00E0 - 0x00C8)
class UK25ChainStrikeState_SelectGatewayOrientation final : public UK25ChainStrikeBaseState
{
public:
	uint8                                         Pad_C8[0x18];                                      // 0x00C8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K25ChainStrikeState_SelectGatewayOrientation">();
	}
	static class UK25ChainStrikeState_SelectGatewayOrientation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK25ChainStrikeState_SelectGatewayOrientation>();
	}
};
static_assert(alignof(UK25ChainStrikeState_SelectGatewayOrientation) == 0x000008, "Wrong alignment on UK25ChainStrikeState_SelectGatewayOrientation");
static_assert(sizeof(UK25ChainStrikeState_SelectGatewayOrientation) == 0x0000E0, "Wrong size on UK25ChainStrikeState_SelectGatewayOrientation");

// Class TheK25.K25ChainStrikeState_ShootControlledProjectile
// 0x0048 (0x0110 - 0x00C8)
class UK25ChainStrikeState_ShootControlledProjectile final : public UK25ChainStrikeBaseState
{
public:
	float                                         _minimumThrottleTimeForInputServerCall;            // 0x00C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _inputResetSpeed;                                  // 0x00CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D0[0x34];                                      // 0x00D0(0x0034)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _minDistToLookAtChain;                             // 0x0104(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_108[0x8];                                      // 0x0108(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K25ChainStrikeState_ShootControlledProjectile">();
	}
	static class UK25ChainStrikeState_ShootControlledProjectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK25ChainStrikeState_ShootControlledProjectile>();
	}
};
static_assert(alignof(UK25ChainStrikeState_ShootControlledProjectile) == 0x000008, "Wrong alignment on UK25ChainStrikeState_ShootControlledProjectile");
static_assert(sizeof(UK25ChainStrikeState_ShootControlledProjectile) == 0x000110, "Wrong size on UK25ChainStrikeState_ShootControlledProjectile");
static_assert(offsetof(UK25ChainStrikeState_ShootControlledProjectile, _minimumThrottleTimeForInputServerCall) == 0x0000C8, "Member 'UK25ChainStrikeState_ShootControlledProjectile::_minimumThrottleTimeForInputServerCall' has a wrong offset!");
static_assert(offsetof(UK25ChainStrikeState_ShootControlledProjectile, _inputResetSpeed) == 0x0000CC, "Member 'UK25ChainStrikeState_ShootControlledProjectile::_inputResetSpeed' has a wrong offset!");
static_assert(offsetof(UK25ChainStrikeState_ShootControlledProjectile, _minDistToLookAtChain) == 0x000104, "Member 'UK25ChainStrikeState_ShootControlledProjectile::_minDistToLookAtChain' has a wrong offset!");

// Class TheK25.K25ChainStrike_IsGatewayOrientationTimerExpired
// 0x0000 (0x0038 - 0x0038)
class UK25ChainStrike_IsGatewayOrientationTimerExpired final : public UFSM_Condition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K25ChainStrike_IsGatewayOrientationTimerExpired">();
	}
	static class UK25ChainStrike_IsGatewayOrientationTimerExpired* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK25ChainStrike_IsGatewayOrientationTimerExpired>();
	}
};
static_assert(alignof(UK25ChainStrike_IsGatewayOrientationTimerExpired) == 0x000008, "Wrong alignment on UK25ChainStrike_IsGatewayOrientationTimerExpired");
static_assert(sizeof(UK25ChainStrike_IsGatewayOrientationTimerExpired) == 0x000038, "Wrong size on UK25ChainStrike_IsGatewayOrientationTimerExpired");

// Class TheK25.K25ChainStrike_IsGatewayPlacementValidCondition
// 0x0000 (0x0038 - 0x0038)
class UK25ChainStrike_IsGatewayPlacementValidCondition final : public UFSM_Condition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K25ChainStrike_IsGatewayPlacementValidCondition">();
	}
	static class UK25ChainStrike_IsGatewayPlacementValidCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK25ChainStrike_IsGatewayPlacementValidCondition>();
	}
};
static_assert(alignof(UK25ChainStrike_IsGatewayPlacementValidCondition) == 0x000008, "Wrong alignment on UK25ChainStrike_IsGatewayPlacementValidCondition");
static_assert(sizeof(UK25ChainStrike_IsGatewayPlacementValidCondition) == 0x000038, "Wrong size on UK25ChainStrike_IsGatewayPlacementValidCondition");

// Class TheK25.K25ChainStrike_IsPlayerPressingInputCondition
// 0x0008 (0x0040 - 0x0038)
class UK25ChainStrike_IsPlayerPressingInputCondition final : public UFSM_Condition
{
public:
	EInputInteractionType                         _inputType;                                        // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K25ChainStrike_IsPlayerPressingInputCondition">();
	}
	static class UK25ChainStrike_IsPlayerPressingInputCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK25ChainStrike_IsPlayerPressingInputCondition>();
	}
};
static_assert(alignof(UK25ChainStrike_IsPlayerPressingInputCondition) == 0x000008, "Wrong alignment on UK25ChainStrike_IsPlayerPressingInputCondition");
static_assert(sizeof(UK25ChainStrike_IsPlayerPressingInputCondition) == 0x000040, "Wrong size on UK25ChainStrike_IsPlayerPressingInputCondition");
static_assert(offsetof(UK25ChainStrike_IsPlayerPressingInputCondition, _inputType) == 0x000038, "Member 'UK25ChainStrike_IsPlayerPressingInputCondition::_inputType' has a wrong offset!");

// Class TheK25.K25CheatComponent
// 0x0000 (0x00A8 - 0x00A8)
class UK25CheatComponent final : public UActorComponent
{
public:
	void DBD_K25ComeToMeLamentConfiguration();
	void DBD_K25ComeToPositionLamentConfiguration(float X, float Y, float Z);
	void DBD_K25ForceRemoveAllChainsOnAllSurvivors();
	void DBD_K25ForceRemoveAllChainsOnClosestsSurvivorToPosition(float X, float Y, float Z);
	void DBD_K25ForceRemoveAllChainsOnLocalSurvivor();
	void DBD_K25ForceRespawnLamentConfiguration();
	void DBD_K25RevealLamentConfigurationLocation(float TimeDisplayed);
	void DBD_K25SetPowerNoCooldown(bool NoCooldown);
	void DBD_K25ShowAllLamentConfigurationSpawnPoints(float TimeDisplayed);
	void DBD_K25TriggerUncontrolledChainsOnAllSurvivors(const int32 NumbChains);
	void DBD_K25TriggerUncontrolledChainsOnClosestsSurvivorToPosition(float X, float Y, float Z, const int32 NumbChains);
	void DBD_K25TriggerUncontrolledChainsOnLocalSurvivor(const int32 NumbChains);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K25CheatComponent">();
	}
	static class UK25CheatComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK25CheatComponent>();
	}
};
static_assert(alignof(UK25CheatComponent) == 0x000008, "Wrong alignment on UK25CheatComponent");
static_assert(sizeof(UK25CheatComponent) == 0x0000A8, "Wrong size on UK25CheatComponent");

// Class TheK25.K25CollectLamentConfigurationInteraction
// 0x0000 (0x07B0 - 0x07B0)
class UK25CollectLamentConfigurationInteraction final : public UCollectItemInteraction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K25CollectLamentConfigurationInteraction">();
	}
	static class UK25CollectLamentConfigurationInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK25CollectLamentConfigurationInteraction>();
	}
};
static_assert(alignof(UK25CollectLamentConfigurationInteraction) == 0x000010, "Wrong alignment on UK25CollectLamentConfigurationInteraction");
static_assert(sizeof(UK25CollectLamentConfigurationInteraction) == 0x0007B0, "Wrong size on UK25CollectLamentConfigurationInteraction");

// Class TheK25.K25ControlledProjectile
// 0x0280 (0x0740 - 0x04C0)
class AK25ControlledProjectile final : public AK25Projectile
{
public:
	uint8                                         Pad_4C0[0x8];                                      // 0x04C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   _killerViewProjectileStaticMesh;                   // 0x04C8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USpringArmComponent*                    _killerSpringArm;                                  // 0x04D0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCameraComponent*                       _killerCameraPlacement;                            // 0x04D8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _pitchClampAngle;                                  // 0x04E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4E4[0x4];                                      // 0x04E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTunableStat                           _maximumYawTurnRate;                               // 0x04E8(0x0080)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FTunableStat                           _maximumPitchTurnRate;                             // 0x0568(0x0080)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _cameraRollSpeedMultiplier;                        // 0x05E8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _cameraRollGoBackSpeedMultiplier;                  // 0x0610(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _cameraMaximumRollDegree;                          // 0x0638(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FTunableStat                           _numbExtraChainsOnControlledProjectileHit;         // 0x0660(0x0080)(Edit, Protected, NativeAccessSpecifierProtected)
	class UK25ControlledProjectileMovementComponent* _controlledProjectileMovementComponent;            // 0x06E0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _currentRoll;                                      // 0x06E8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _targetRoll;                                       // 0x06EC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6F0[0x30];                                     // 0x06F0(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector_NetQuantize                    _lastAppliedAngularVelocity;                       // 0x0720(0x0018)(Net, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_738[0x8];                                      // 0x0738(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_OnKillerPossessProjectileEffects();
	void OnRep_AngularVelocity();
	void Server_ProcessPitchInput(float DeltaTime, float ScaledInput);
	void Server_ProcessYawInput(float DeltaTime, float ScaledInput);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K25ControlledProjectile">();
	}
	static class AK25ControlledProjectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK25ControlledProjectile>();
	}
};
static_assert(alignof(AK25ControlledProjectile) == 0x000008, "Wrong alignment on AK25ControlledProjectile");
static_assert(sizeof(AK25ControlledProjectile) == 0x000740, "Wrong size on AK25ControlledProjectile");
static_assert(offsetof(AK25ControlledProjectile, _killerViewProjectileStaticMesh) == 0x0004C8, "Member 'AK25ControlledProjectile::_killerViewProjectileStaticMesh' has a wrong offset!");
static_assert(offsetof(AK25ControlledProjectile, _killerSpringArm) == 0x0004D0, "Member 'AK25ControlledProjectile::_killerSpringArm' has a wrong offset!");
static_assert(offsetof(AK25ControlledProjectile, _killerCameraPlacement) == 0x0004D8, "Member 'AK25ControlledProjectile::_killerCameraPlacement' has a wrong offset!");
static_assert(offsetof(AK25ControlledProjectile, _pitchClampAngle) == 0x0004E0, "Member 'AK25ControlledProjectile::_pitchClampAngle' has a wrong offset!");
static_assert(offsetof(AK25ControlledProjectile, _maximumYawTurnRate) == 0x0004E8, "Member 'AK25ControlledProjectile::_maximumYawTurnRate' has a wrong offset!");
static_assert(offsetof(AK25ControlledProjectile, _maximumPitchTurnRate) == 0x000568, "Member 'AK25ControlledProjectile::_maximumPitchTurnRate' has a wrong offset!");
static_assert(offsetof(AK25ControlledProjectile, _cameraRollSpeedMultiplier) == 0x0005E8, "Member 'AK25ControlledProjectile::_cameraRollSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(AK25ControlledProjectile, _cameraRollGoBackSpeedMultiplier) == 0x000610, "Member 'AK25ControlledProjectile::_cameraRollGoBackSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(AK25ControlledProjectile, _cameraMaximumRollDegree) == 0x000638, "Member 'AK25ControlledProjectile::_cameraMaximumRollDegree' has a wrong offset!");
static_assert(offsetof(AK25ControlledProjectile, _numbExtraChainsOnControlledProjectileHit) == 0x000660, "Member 'AK25ControlledProjectile::_numbExtraChainsOnControlledProjectileHit' has a wrong offset!");
static_assert(offsetof(AK25ControlledProjectile, _controlledProjectileMovementComponent) == 0x0006E0, "Member 'AK25ControlledProjectile::_controlledProjectileMovementComponent' has a wrong offset!");
static_assert(offsetof(AK25ControlledProjectile, _currentRoll) == 0x0006E8, "Member 'AK25ControlledProjectile::_currentRoll' has a wrong offset!");
static_assert(offsetof(AK25ControlledProjectile, _targetRoll) == 0x0006EC, "Member 'AK25ControlledProjectile::_targetRoll' has a wrong offset!");
static_assert(offsetof(AK25ControlledProjectile, _lastAppliedAngularVelocity) == 0x000720, "Member 'AK25ControlledProjectile::_lastAppliedAngularVelocity' has a wrong offset!");

// Class TheK25.K25ControlledProjectileMovementComponent
// 0x0140 (0x0420 - 0x02E0)
class UK25ControlledProjectileMovementComponent final : public UPhysicsBasedProjectileMovementComponent
{
public:
	struct FDBDTunableRowHandle                   _projectileBaseSpeed;                              // 0x02E0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _baseProjectileMaximumDistance;                    // 0x0308(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _projectileSpeedIncreaseTime;                      // 0x0330(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FTunableStat                           _maximumTravelDistanceStat;                        // 0x0358(0x0080)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class UCurveFloat*                            _projectileSpeedIncreaseMultiplier;                // 0x03D8(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _totalDistanceTravelled;                           // 0x03E0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3E4[0x3C];                                     // 0x03E4(0x003C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K25ControlledProjectileMovementComponent">();
	}
	static class UK25ControlledProjectileMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK25ControlledProjectileMovementComponent>();
	}
};
static_assert(alignof(UK25ControlledProjectileMovementComponent) == 0x000010, "Wrong alignment on UK25ControlledProjectileMovementComponent");
static_assert(sizeof(UK25ControlledProjectileMovementComponent) == 0x000420, "Wrong size on UK25ControlledProjectileMovementComponent");
static_assert(offsetof(UK25ControlledProjectileMovementComponent, _projectileBaseSpeed) == 0x0002E0, "Member 'UK25ControlledProjectileMovementComponent::_projectileBaseSpeed' has a wrong offset!");
static_assert(offsetof(UK25ControlledProjectileMovementComponent, _baseProjectileMaximumDistance) == 0x000308, "Member 'UK25ControlledProjectileMovementComponent::_baseProjectileMaximumDistance' has a wrong offset!");
static_assert(offsetof(UK25ControlledProjectileMovementComponent, _projectileSpeedIncreaseTime) == 0x000330, "Member 'UK25ControlledProjectileMovementComponent::_projectileSpeedIncreaseTime' has a wrong offset!");
static_assert(offsetof(UK25ControlledProjectileMovementComponent, _maximumTravelDistanceStat) == 0x000358, "Member 'UK25ControlledProjectileMovementComponent::_maximumTravelDistanceStat' has a wrong offset!");
static_assert(offsetof(UK25ControlledProjectileMovementComponent, _projectileSpeedIncreaseMultiplier) == 0x0003D8, "Member 'UK25ControlledProjectileMovementComponent::_projectileSpeedIncreaseMultiplier' has a wrong offset!");
static_assert(offsetof(UK25ControlledProjectileMovementComponent, _totalDistanceTravelled) == 0x0003E0, "Member 'UK25ControlledProjectileMovementComponent::_totalDistanceTravelled' has a wrong offset!");

// Class TheK25.K25EscapeLamentConfigurationGrasp
// 0x0000 (0x08C0 - 0x08C0)
class UK25EscapeLamentConfigurationGrasp final : public UChargeableInteractionDefinition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K25EscapeLamentConfigurationGrasp">();
	}
	static class UK25EscapeLamentConfigurationGrasp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK25EscapeLamentConfigurationGrasp>();
	}
};
static_assert(alignof(UK25EscapeLamentConfigurationGrasp) == 0x000010, "Wrong alignment on UK25EscapeLamentConfigurationGrasp");
static_assert(sizeof(UK25EscapeLamentConfigurationGrasp) == 0x0008C0, "Wrong size on UK25EscapeLamentConfigurationGrasp");

// Class TheK25.K25Gateway
// 0x02B8 (0x0558 - 0x02A0)
class AK25Gateway final : public AActor
{
public:
	uint8                                         Pad_2A0[0x20];                                     // 0x02A0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _rayCastZOffet;                                    // 0x02C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _rayCastLength;                                    // 0x02C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<float>                                 _distancePercentLocations;                         // 0x02C8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	float                                         _survivorGatewayRotationSpeed;                     // 0x02D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _minimumIndicatorVelocity;                         // 0x02DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _indicatorVelocityEasingFactor;                    // 0x02E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _minimumTimeBeforeTargetLocationMulticast;         // 0x02E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E8[0x8];                                      // 0x02E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _gatewayNoiseEventTimeInterval;                    // 0x02F0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _gatewayNoiseEventRange;                           // 0x02F4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _minDistanceFromPlayer;                            // 0x02F8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FTunableStat                           _maxDistanceFromPlayer;                            // 0x0320(0x0080)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _gatewayPlacementSpeed;                            // 0x03A0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _pitchLevelChangeAngleThreshold;                   // 0x03C8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _pitchLevelChangeZoneThreshold;                    // 0x03F0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _maximumCameraPitchOrientationAngle;               // 0x0418(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _minimumCameraPitchOrientationAngle;               // 0x0440(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _maxGatewayPossessionDuration;                     // 0x0468(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class UActorComponent*                        _visualComponent;                                  // 0x0490(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                _targetLocation;                                   // 0x0498(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4B0[0x10];                                     // 0x04B0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UCameraComponent*                       _cameraPlacementComponent;                         // 0x04C0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isGatewayPossessed;                               // 0x04C8(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4C9[0x1B];                                     // 0x04C9(0x001B)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _isBeingPositionned;                               // 0x04E4(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4E5[0x2B];                                     // 0x04E5(0x002B)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFastTimer                             _possessionTimer;                                  // 0x0510(0x0030)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_540[0x10];                                     // 0x0540(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UAIPerceptionStimuliSourceComponent*    _perceptionStimuliComponent;                       // 0x0550(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Cosmetic_SetIsGatewayPositionValid(bool IsGatewayPlacementValid);
	void Cosmetic_SetKillerVisualVisibility(bool IsVisible);
	void Cosmetic_TriggerGatewayPlacementCancel();
	void Cosmetic_TriggerGatewayPlacementStart();
	void Cosmetic_TriggerGatewayPlacementStop();
	void Cosmetic_TriggerGatewayPossessedEffects(const float TransitionTime);
	void Cosmetic_TriggerGatewayPossessionCancel();
	void Cosmetic_TriggerGatewayUnpossessedEffects();
	void Cosmetic_TriggerInvalidGatewayPlacementSFX();
	void Multicast_SetGatewayLocation(const struct FVector& PossessionLocation);
	void Multicast_SetGatewayOrientation(const struct FRotator& Rotation);
	void Multicast_SetGatewayTargetLocation(const struct FVector& TargetLocation, bool IsValidLocation);
	void OnRep_IsBeingPositionned();
	void OnRep_IsGatewayPossessed();
	void Server_EndGatewayPossession();
	void Server_SetGatewayOrientation(const struct FRotator& Rotation);
	void Server_SetGatewayTargetLocation(const struct FVector& TargetLocation, bool IsValidLocation);
	void Server_SetIsGatewayBeingPositionned(bool IsBeingPositionned);
	void Server_StartGatewayPossession(const struct FVector& PossessionLocation, const struct FRotator& GatewayRotation);

	class UCameraComponent* GetCameraComponent() const;
	bool IsGatewayPossessed() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K25Gateway">();
	}
	static class AK25Gateway* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK25Gateway>();
	}
};
static_assert(alignof(AK25Gateway) == 0x000008, "Wrong alignment on AK25Gateway");
static_assert(sizeof(AK25Gateway) == 0x000558, "Wrong size on AK25Gateway");
static_assert(offsetof(AK25Gateway, _rayCastZOffet) == 0x0002C0, "Member 'AK25Gateway::_rayCastZOffet' has a wrong offset!");
static_assert(offsetof(AK25Gateway, _rayCastLength) == 0x0002C4, "Member 'AK25Gateway::_rayCastLength' has a wrong offset!");
static_assert(offsetof(AK25Gateway, _distancePercentLocations) == 0x0002C8, "Member 'AK25Gateway::_distancePercentLocations' has a wrong offset!");
static_assert(offsetof(AK25Gateway, _survivorGatewayRotationSpeed) == 0x0002D8, "Member 'AK25Gateway::_survivorGatewayRotationSpeed' has a wrong offset!");
static_assert(offsetof(AK25Gateway, _minimumIndicatorVelocity) == 0x0002DC, "Member 'AK25Gateway::_minimumIndicatorVelocity' has a wrong offset!");
static_assert(offsetof(AK25Gateway, _indicatorVelocityEasingFactor) == 0x0002E0, "Member 'AK25Gateway::_indicatorVelocityEasingFactor' has a wrong offset!");
static_assert(offsetof(AK25Gateway, _minimumTimeBeforeTargetLocationMulticast) == 0x0002E4, "Member 'AK25Gateway::_minimumTimeBeforeTargetLocationMulticast' has a wrong offset!");
static_assert(offsetof(AK25Gateway, _gatewayNoiseEventTimeInterval) == 0x0002F0, "Member 'AK25Gateway::_gatewayNoiseEventTimeInterval' has a wrong offset!");
static_assert(offsetof(AK25Gateway, _gatewayNoiseEventRange) == 0x0002F4, "Member 'AK25Gateway::_gatewayNoiseEventRange' has a wrong offset!");
static_assert(offsetof(AK25Gateway, _minDistanceFromPlayer) == 0x0002F8, "Member 'AK25Gateway::_minDistanceFromPlayer' has a wrong offset!");
static_assert(offsetof(AK25Gateway, _maxDistanceFromPlayer) == 0x000320, "Member 'AK25Gateway::_maxDistanceFromPlayer' has a wrong offset!");
static_assert(offsetof(AK25Gateway, _gatewayPlacementSpeed) == 0x0003A0, "Member 'AK25Gateway::_gatewayPlacementSpeed' has a wrong offset!");
static_assert(offsetof(AK25Gateway, _pitchLevelChangeAngleThreshold) == 0x0003C8, "Member 'AK25Gateway::_pitchLevelChangeAngleThreshold' has a wrong offset!");
static_assert(offsetof(AK25Gateway, _pitchLevelChangeZoneThreshold) == 0x0003F0, "Member 'AK25Gateway::_pitchLevelChangeZoneThreshold' has a wrong offset!");
static_assert(offsetof(AK25Gateway, _maximumCameraPitchOrientationAngle) == 0x000418, "Member 'AK25Gateway::_maximumCameraPitchOrientationAngle' has a wrong offset!");
static_assert(offsetof(AK25Gateway, _minimumCameraPitchOrientationAngle) == 0x000440, "Member 'AK25Gateway::_minimumCameraPitchOrientationAngle' has a wrong offset!");
static_assert(offsetof(AK25Gateway, _maxGatewayPossessionDuration) == 0x000468, "Member 'AK25Gateway::_maxGatewayPossessionDuration' has a wrong offset!");
static_assert(offsetof(AK25Gateway, _visualComponent) == 0x000490, "Member 'AK25Gateway::_visualComponent' has a wrong offset!");
static_assert(offsetof(AK25Gateway, _targetLocation) == 0x000498, "Member 'AK25Gateway::_targetLocation' has a wrong offset!");
static_assert(offsetof(AK25Gateway, _cameraPlacementComponent) == 0x0004C0, "Member 'AK25Gateway::_cameraPlacementComponent' has a wrong offset!");
static_assert(offsetof(AK25Gateway, _isGatewayPossessed) == 0x0004C8, "Member 'AK25Gateway::_isGatewayPossessed' has a wrong offset!");
static_assert(offsetof(AK25Gateway, _isBeingPositionned) == 0x0004E4, "Member 'AK25Gateway::_isBeingPositionned' has a wrong offset!");
static_assert(offsetof(AK25Gateway, _possessionTimer) == 0x000510, "Member 'AK25Gateway::_possessionTimer' has a wrong offset!");
static_assert(offsetof(AK25Gateway, _perceptionStimuliComponent) == 0x000550, "Member 'AK25Gateway::_perceptionStimuliComponent' has a wrong offset!");

// Class TheK25.K25Husk
// 0x0030 (0x0760 - 0x0730)
class AK25Husk final : public ADBDBasePlayer
{
public:
	class UCustomizedSkeletalMesh*                _customizedSkeletalMeshComponent;                  // 0x0728(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimationMontageSlave*                 _montageFollower;                                  // 0x0730(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _k25CharacterOverrideID;                           // 0x0738(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_73C[0x24];                                     // 0x073C(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_HideHusk();
	void Cosmetic_StartAppearing();
	void Cosmetic_StartDisappearing();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K25Husk">();
	}
	static class AK25Husk* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK25Husk>();
	}
};
static_assert(alignof(AK25Husk) == 0x000010, "Wrong alignment on AK25Husk");
static_assert(sizeof(AK25Husk) == 0x000760, "Wrong size on AK25Husk");
static_assert(offsetof(AK25Husk, _customizedSkeletalMeshComponent) == 0x000728, "Member 'AK25Husk::_customizedSkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(AK25Husk, _montageFollower) == 0x000730, "Member 'AK25Husk::_montageFollower' has a wrong offset!");
static_assert(offsetof(AK25Husk, _k25CharacterOverrideID) == 0x000738, "Member 'AK25Husk::_k25CharacterOverrideID' has a wrong offset!");

// Class TheK25.K25KillerChainHuntEffectsComponent
// 0x0000 (0x0108 - 0x0108)
class UK25KillerChainHuntEffectsComponent final : public UK25ChainHuntEffectsComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K25KillerChainHuntEffectsComponent">();
	}
	static class UK25KillerChainHuntEffectsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK25KillerChainHuntEffectsComponent>();
	}
};
static_assert(alignof(UK25KillerChainHuntEffectsComponent) == 0x000008, "Wrong alignment on UK25KillerChainHuntEffectsComponent");
static_assert(sizeof(UK25KillerChainHuntEffectsComponent) == 0x000108, "Wrong size on UK25KillerChainHuntEffectsComponent");

// Class TheK25.K25KillerTeleportationPositionFinderComponent
// 0x0148 (0x01F0 - 0x00A8)
class UK25KillerTeleportationPositionFinderComponent final : public UActorComponent
{
public:
	float                                         _rayCastZOffet;                                    // 0x00A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _rayCastLength;                                    // 0x00AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _killerInRangeMinimumDistanceCheck;                // 0x00B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _killerInRangeMaxRangePercentage;                  // 0x00B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _deltaHeightThreshold;                             // 0x00B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _minDistanceFromLamentConfiguration;               // 0x00C0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _maxDistanceFromLamentConfiguration;               // 0x00E8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_110[0x20];                                     // 0x0110(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _timeBetweenFailsafeChecks;                        // 0x0130(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_134[0x44];                                     // 0x0134(0x0044)(Fixing Size After Last Property [ Dumper-7 ])
	EK25TeleportLocationStatus                    _teleportLocationStatus;                           // 0x0178(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_179[0x7];                                      // 0x0179(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                _bestTeleportLocation;                             // 0x0180(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_198[0x20];                                     // 0x0198(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _minDistanceNeededFromEscapeBlockers;              // 0x01B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1BC[0x34];                                     // 0x01BC(0x0034)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K25KillerTeleportationPositionFinderComponent">();
	}
	static class UK25KillerTeleportationPositionFinderComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK25KillerTeleportationPositionFinderComponent>();
	}
};
static_assert(alignof(UK25KillerTeleportationPositionFinderComponent) == 0x000008, "Wrong alignment on UK25KillerTeleportationPositionFinderComponent");
static_assert(sizeof(UK25KillerTeleportationPositionFinderComponent) == 0x0001F0, "Wrong size on UK25KillerTeleportationPositionFinderComponent");
static_assert(offsetof(UK25KillerTeleportationPositionFinderComponent, _rayCastZOffet) == 0x0000A8, "Member 'UK25KillerTeleportationPositionFinderComponent::_rayCastZOffet' has a wrong offset!");
static_assert(offsetof(UK25KillerTeleportationPositionFinderComponent, _rayCastLength) == 0x0000AC, "Member 'UK25KillerTeleportationPositionFinderComponent::_rayCastLength' has a wrong offset!");
static_assert(offsetof(UK25KillerTeleportationPositionFinderComponent, _killerInRangeMinimumDistanceCheck) == 0x0000B0, "Member 'UK25KillerTeleportationPositionFinderComponent::_killerInRangeMinimumDistanceCheck' has a wrong offset!");
static_assert(offsetof(UK25KillerTeleportationPositionFinderComponent, _killerInRangeMaxRangePercentage) == 0x0000B4, "Member 'UK25KillerTeleportationPositionFinderComponent::_killerInRangeMaxRangePercentage' has a wrong offset!");
static_assert(offsetof(UK25KillerTeleportationPositionFinderComponent, _deltaHeightThreshold) == 0x0000B8, "Member 'UK25KillerTeleportationPositionFinderComponent::_deltaHeightThreshold' has a wrong offset!");
static_assert(offsetof(UK25KillerTeleportationPositionFinderComponent, _minDistanceFromLamentConfiguration) == 0x0000C0, "Member 'UK25KillerTeleportationPositionFinderComponent::_minDistanceFromLamentConfiguration' has a wrong offset!");
static_assert(offsetof(UK25KillerTeleportationPositionFinderComponent, _maxDistanceFromLamentConfiguration) == 0x0000E8, "Member 'UK25KillerTeleportationPositionFinderComponent::_maxDistanceFromLamentConfiguration' has a wrong offset!");
static_assert(offsetof(UK25KillerTeleportationPositionFinderComponent, _timeBetweenFailsafeChecks) == 0x000130, "Member 'UK25KillerTeleportationPositionFinderComponent::_timeBetweenFailsafeChecks' has a wrong offset!");
static_assert(offsetof(UK25KillerTeleportationPositionFinderComponent, _teleportLocationStatus) == 0x000178, "Member 'UK25KillerTeleportationPositionFinderComponent::_teleportLocationStatus' has a wrong offset!");
static_assert(offsetof(UK25KillerTeleportationPositionFinderComponent, _bestTeleportLocation) == 0x000180, "Member 'UK25KillerTeleportationPositionFinderComponent::_bestTeleportLocation' has a wrong offset!");
static_assert(offsetof(UK25KillerTeleportationPositionFinderComponent, _minDistanceNeededFromEscapeBlockers) == 0x0001B8, "Member 'UK25KillerTeleportationPositionFinderComponent::_minDistanceNeededFromEscapeBlockers' has a wrong offset!");

// Class TheK25.K25LamentConfigurationPossessionChainAttacksEffect
// 0x0098 (0x0418 - 0x0380)
class UK25LamentConfigurationPossessionChainAttacksEffect final : public UStatusEffect
{
public:
	struct FDBDTunableRowHandle                   _timeBetweenChainTargettingAttempt;                // 0x0380(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _numberOfChainsToTriggerTowardsSurvivor;           // 0x03A8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_3D0[0x48];                                     // 0x03D0(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K25LamentConfigurationPossessionChainAttacksEffect">();
	}
	static class UK25LamentConfigurationPossessionChainAttacksEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK25LamentConfigurationPossessionChainAttacksEffect>();
	}
};
static_assert(alignof(UK25LamentConfigurationPossessionChainAttacksEffect) == 0x000008, "Wrong alignment on UK25LamentConfigurationPossessionChainAttacksEffect");
static_assert(sizeof(UK25LamentConfigurationPossessionChainAttacksEffect) == 0x000418, "Wrong size on UK25LamentConfigurationPossessionChainAttacksEffect");
static_assert(offsetof(UK25LamentConfigurationPossessionChainAttacksEffect, _timeBetweenChainTargettingAttempt) == 0x000380, "Member 'UK25LamentConfigurationPossessionChainAttacksEffect::_timeBetweenChainTargettingAttempt' has a wrong offset!");
static_assert(offsetof(UK25LamentConfigurationPossessionChainAttacksEffect, _numberOfChainsToTriggerTowardsSurvivor) == 0x0003A8, "Member 'UK25LamentConfigurationPossessionChainAttacksEffect::_numberOfChainsToTriggerTowardsSurvivor' has a wrong offset!");

// Class TheK25.K25LamentConfigurationTeleportIndicator
// 0x0008 (0x02A8 - 0x02A0)
class AK25LamentConfigurationTeleportIndicator final : public AActor
{
public:
	uint8                                         Pad_2A0[0x8];                                      // 0x02A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_UpdateIndicatorVisibility(bool IsVisible);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K25LamentConfigurationTeleportIndicator">();
	}
	static class AK25LamentConfigurationTeleportIndicator* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK25LamentConfigurationTeleportIndicator>();
	}
};
static_assert(alignof(AK25LamentConfigurationTeleportIndicator) == 0x000008, "Wrong alignment on AK25LamentConfigurationTeleportIndicator");
static_assert(sizeof(AK25LamentConfigurationTeleportIndicator) == 0x0002A8, "Wrong size on AK25LamentConfigurationTeleportIndicator");

// Class TheK25.K25P01
// 0x0050 (0x0470 - 0x0420)
class UK25P01 final : public UPerk
{
public:
	float                                         _generatorBlockDuration[0x3];                      // 0x0420(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _allowPerkToBlockZeroProgressionGenerators;        // 0x042C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_42D[0x3];                                      // 0x042D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           _generatorAuraColorForKiller;                      // 0x0430(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FFastTimer>                     _generatorBlockingTimers;                          // 0x0440(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class AGenerator*>                     _generatorsBlocked;                                // 0x0450(0x0010)(Net, ZeroConstructor, Transient, RepNotify, NativeAccessSpecifierPrivate)
	TArray<class AGenerator*>                     _local_generatorsBlocked;                          // 0x0460(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	void Authority_OnBlockTimerDone(class AGenerator* Generator);
	void OnRep_GeneratorsBlocked();

	float GetGeneratorBlockDuration() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K25P01">();
	}
	static class UK25P01* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK25P01>();
	}
};
static_assert(alignof(UK25P01) == 0x000008, "Wrong alignment on UK25P01");
static_assert(sizeof(UK25P01) == 0x000470, "Wrong size on UK25P01");
static_assert(offsetof(UK25P01, _generatorBlockDuration) == 0x000420, "Member 'UK25P01::_generatorBlockDuration' has a wrong offset!");
static_assert(offsetof(UK25P01, _allowPerkToBlockZeroProgressionGenerators) == 0x00042C, "Member 'UK25P01::_allowPerkToBlockZeroProgressionGenerators' has a wrong offset!");
static_assert(offsetof(UK25P01, _generatorAuraColorForKiller) == 0x000430, "Member 'UK25P01::_generatorAuraColorForKiller' has a wrong offset!");
static_assert(offsetof(UK25P01, _generatorBlockingTimers) == 0x000440, "Member 'UK25P01::_generatorBlockingTimers' has a wrong offset!");
static_assert(offsetof(UK25P01, _generatorsBlocked) == 0x000450, "Member 'UK25P01::_generatorsBlocked' has a wrong offset!");
static_assert(offsetof(UK25P01, _local_generatorsBlocked) == 0x000460, "Member 'UK25P01::_local_generatorsBlocked' has a wrong offset!");

// Class TheK25.K25P02
// 0x0090 (0x0530 - 0x04A0)
class UK25P02 final : public UHexPerk
{
public:
	float                                         _totemAuraRevealRadius[0x3];                       // 0x04A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _totemBlockerHasLifetime;                          // 0x04AC(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4AD[0x3];                                      // 0x04AD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _totemBlockerDuration[0x3];                        // 0x04B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4BC[0x4];                                      // 0x04BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UStatusEffect>              _obliviousStatusEffectClass;                       // 0x04C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4C8[0x8];                                      // 0x04C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FDBDPlayerTotemPair>            _cursedSurvivors;                                  // 0x04D0(0x0010)(Net, ZeroConstructor, Transient, RepNotify, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4E0[0x10];                                     // 0x04E0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ADBDPlayer*>                     _hookedSurvivors;                                  // 0x04F0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class ATotem*>                         _previouslyBoundTotems;                            // 0x0500(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	struct FDBDPlayerTotemPair                    _lastPlayerTotemPair;                              // 0x0510(0x0010)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
	TArray<class UStatusEffect*>                  _obliviousStatusEffects;                           // 0x0520(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	void OnRep_CursedSurvivors();

	float GetTotemAuraRevealRadius() const;
	float GetTotemBlockerDuration() const;
	bool GetTotemBlockerHasLifetime() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K25P02">();
	}
	static class UK25P02* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK25P02>();
	}
};
static_assert(alignof(UK25P02) == 0x000008, "Wrong alignment on UK25P02");
static_assert(sizeof(UK25P02) == 0x000530, "Wrong size on UK25P02");
static_assert(offsetof(UK25P02, _totemAuraRevealRadius) == 0x0004A0, "Member 'UK25P02::_totemAuraRevealRadius' has a wrong offset!");
static_assert(offsetof(UK25P02, _totemBlockerHasLifetime) == 0x0004AC, "Member 'UK25P02::_totemBlockerHasLifetime' has a wrong offset!");
static_assert(offsetof(UK25P02, _totemBlockerDuration) == 0x0004B0, "Member 'UK25P02::_totemBlockerDuration' has a wrong offset!");
static_assert(offsetof(UK25P02, _obliviousStatusEffectClass) == 0x0004C0, "Member 'UK25P02::_obliviousStatusEffectClass' has a wrong offset!");
static_assert(offsetof(UK25P02, _cursedSurvivors) == 0x0004D0, "Member 'UK25P02::_cursedSurvivors' has a wrong offset!");
static_assert(offsetof(UK25P02, _hookedSurvivors) == 0x0004F0, "Member 'UK25P02::_hookedSurvivors' has a wrong offset!");
static_assert(offsetof(UK25P02, _previouslyBoundTotems) == 0x000500, "Member 'UK25P02::_previouslyBoundTotems' has a wrong offset!");
static_assert(offsetof(UK25P02, _lastPlayerTotemPair) == 0x000510, "Member 'UK25P02::_lastPlayerTotemPair' has a wrong offset!");
static_assert(offsetof(UK25P02, _obliviousStatusEffects) == 0x000520, "Member 'UK25P02::_obliviousStatusEffects' has a wrong offset!");

// Class TheK25.K25P03
// 0x0040 (0x0460 - 0x0420)
class UK25P03 final : public UPerk
{
public:
	TSubclassOf<class UStatusEffect>              _hemorrhageEffect;                                 // 0x0420(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _mangledEffect;                                    // 0x0428(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _K25P03SurvivorStateTwoEffect;                     // 0x0430(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_438[0x8];                                      // 0x0438(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _numberOfSurvivorsWaitingForDamageStateChange;     // 0x0440(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _state2ActionSpeedDebuffPercentage[0x3];           // 0x0444(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _mangledHemorrhageEffectLifetime[0x3];             // 0x0450(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_45C[0x4];                                      // 0x045C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCamperUnhookedFromScourgeHook(const struct FGameEventData& GameEventData);
	void OnDamageStateChanged(const struct FGameplayTag& GameplayTag, const struct FGameEventData& GameEventData);
	void OnSurvivorRemoved(class ACamperPlayer* Survivor);

	float GetActionSpeedDebuffPercentageAtLevel() const;
	float GetMangledHemorrhageEffectLifetimeAtLevel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K25P03">();
	}
	static class UK25P03* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK25P03>();
	}
};
static_assert(alignof(UK25P03) == 0x000008, "Wrong alignment on UK25P03");
static_assert(sizeof(UK25P03) == 0x000460, "Wrong size on UK25P03");
static_assert(offsetof(UK25P03, _hemorrhageEffect) == 0x000420, "Member 'UK25P03::_hemorrhageEffect' has a wrong offset!");
static_assert(offsetof(UK25P03, _mangledEffect) == 0x000428, "Member 'UK25P03::_mangledEffect' has a wrong offset!");
static_assert(offsetof(UK25P03, _K25P03SurvivorStateTwoEffect) == 0x000430, "Member 'UK25P03::_K25P03SurvivorStateTwoEffect' has a wrong offset!");
static_assert(offsetof(UK25P03, _numberOfSurvivorsWaitingForDamageStateChange) == 0x000440, "Member 'UK25P03::_numberOfSurvivorsWaitingForDamageStateChange' has a wrong offset!");
static_assert(offsetof(UK25P03, _state2ActionSpeedDebuffPercentage) == 0x000444, "Member 'UK25P03::_state2ActionSpeedDebuffPercentage' has a wrong offset!");
static_assert(offsetof(UK25P03, _mangledHemorrhageEffectLifetime) == 0x000450, "Member 'UK25P03::_mangledHemorrhageEffectLifetime' has a wrong offset!");

// Class TheK25.K25PounceAttack
// 0x0030 (0x0450 - 0x0420)
class UK25PounceAttack final : public UPounceAttack
{
public:
	uint8                                         Pad_420[0x30];                                     // 0x0420(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Client_InvalidateDownedTargetHoldingLamentConfiguration();
	void Multicast_DownedTargetHoldingLamentConfiguration();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K25PounceAttack">();
	}
	static class UK25PounceAttack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK25PounceAttack>();
	}
};
static_assert(alignof(UK25PounceAttack) == 0x000010, "Wrong alignment on UK25PounceAttack");
static_assert(sizeof(UK25PounceAttack) == 0x000450, "Wrong size on UK25PounceAttack");

// Class TheK25.K25PounceAttackHittingSubstate
// 0x0000 (0x01A0 - 0x01A0)
class UK25PounceAttackHittingSubstate final : public UPounceAttackHittingSubstate
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K25PounceAttackHittingSubstate">();
	}
	static class UK25PounceAttackHittingSubstate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK25PounceAttackHittingSubstate>();
	}
};
static_assert(alignof(UK25PounceAttackHittingSubstate) == 0x000008, "Wrong alignment on UK25PounceAttackHittingSubstate");
static_assert(sizeof(UK25PounceAttackHittingSubstate) == 0x0001A0, "Wrong size on UK25PounceAttackHittingSubstate");

// Class TheK25.K25Power
// 0x0160 (0x06B0 - 0x0550)
class AK25Power final : public ACollectable
{
public:
	uint8                                         Pad_550[0x18];                                     // 0x0550(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UChargeableComponent*                   _k25ChainStrikeInteractionChargeableComponent;     // 0x0568(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UChargeableComponent*                   _k25TeleportChargeableComponent;                   // 0x0570(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FCustomKillerInstinctData>      _customKillerInstinctDatas;                        // 0x0578(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<TSubclassOf<class UStatusEffect>>      _survivorStatusEffectClasses;                      // 0x0588(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<TSubclassOf<class UStatusEffect>>      _killerStatusEffectClasses;                        // 0x0598(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TSubclassOf<class UK25SurvivorChainAttachmentComponent> _survivorChainAttachmentComponentClass;            // 0x05A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UK25SurvivorChainTargetterComponent> _survivorChainTargetterComponentClass;             // 0x05B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AK25Gateway>                _k25GatewayClass;                                  // 0x05B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AK25ControlledProjectile>   _controlledProjectileClass;                        // 0x05C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ALamentConfiguration>       _lamentConfigurationClass;                         // 0x05C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AK25Husk>                   _k25HuskClass;                                     // 0x05D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UK25KillerTeleportationPositionFinderComponent> _killerTeleportFinderComponentClass;               // 0x05D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AAnimationFollowerActor>    _chainAnimationActorClass;                         // 0x05E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UDataTable*>                     _chainAnimationMappingsTables;                     // 0x05E8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class AAnimationFollowerActor>    _pillarAnimationActorClass;                        // 0x05F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UStatusEffect>              _chainsAttachedStatusEffectClass;                  // 0x0600(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UK25ProjectileLauncher*                 _k25ProjectileLauncher;                            // 0x0608(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAuthoritativeActorPoolComponent*       _k25ProjectilePool;                                // 0x0610(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAuthoritativeActorPoolComponent*       _k25ChainPool;                                     // 0x0618(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPowerChargeComponent*                  _k25PowerChargeComponent;                          // 0x0620(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAuthoritativePoolProjectileProviderAdapter* _k25ProjectileProvider;                            // 0x0628(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UK25PowerChargePresentationItemProgressComponent* _k25PowerPresentationItemProgressComponent;        // 0x0630(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AK25Gateway*                            _gateway;                                          // 0x0638(0x0008)(Net, ZeroConstructor, Transient, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AK25ControlledProjectile*               _controlledProjectileInstance;                     // 0x0640(0x0008)(Net, ZeroConstructor, Transient, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ALamentConfiguration*                   _lamentConfiguration;                              // 0x0648(0x0008)(Net, ZeroConstructor, Transient, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AK25Husk*                               _k25Husk;                                          // 0x0650(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UK25ChainAttachmentReplicationComponent* _chainAttachmentReplicationComponent;              // 0x0658(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInteractionAttacherComponent*          _interactionAttacherComponent;                     // 0x0660(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_668[0x40];                                     // 0x0668(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _isPowerCharged;                                   // 0x06A8(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6A9[0x7];                                      // 0x06A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_OnKillerInterruptOpenHatchSFX(class ASlasherPlayer* Killer);
	void Cosmetic_OnKillerInterruptSFX(class ASlasherPlayer* Killer);
	void OnKillerAdded(class ASlasherPlayer* Killer);
	void OnRep_K25ControlledProjectile();
	void OnRep_K25Gateway();
	void OnRep_LamentConfiguration();
	void OnSurvivorAdded(class ACamperPlayer* Survivor, class ASlasherPlayer* Killer);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K25Power">();
	}
	static class AK25Power* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK25Power>();
	}
};
static_assert(alignof(AK25Power) == 0x000008, "Wrong alignment on AK25Power");
static_assert(sizeof(AK25Power) == 0x0006B0, "Wrong size on AK25Power");
static_assert(offsetof(AK25Power, _k25ChainStrikeInteractionChargeableComponent) == 0x000568, "Member 'AK25Power::_k25ChainStrikeInteractionChargeableComponent' has a wrong offset!");
static_assert(offsetof(AK25Power, _k25TeleportChargeableComponent) == 0x000570, "Member 'AK25Power::_k25TeleportChargeableComponent' has a wrong offset!");
static_assert(offsetof(AK25Power, _customKillerInstinctDatas) == 0x000578, "Member 'AK25Power::_customKillerInstinctDatas' has a wrong offset!");
static_assert(offsetof(AK25Power, _survivorStatusEffectClasses) == 0x000588, "Member 'AK25Power::_survivorStatusEffectClasses' has a wrong offset!");
static_assert(offsetof(AK25Power, _killerStatusEffectClasses) == 0x000598, "Member 'AK25Power::_killerStatusEffectClasses' has a wrong offset!");
static_assert(offsetof(AK25Power, _survivorChainAttachmentComponentClass) == 0x0005A8, "Member 'AK25Power::_survivorChainAttachmentComponentClass' has a wrong offset!");
static_assert(offsetof(AK25Power, _survivorChainTargetterComponentClass) == 0x0005B0, "Member 'AK25Power::_survivorChainTargetterComponentClass' has a wrong offset!");
static_assert(offsetof(AK25Power, _k25GatewayClass) == 0x0005B8, "Member 'AK25Power::_k25GatewayClass' has a wrong offset!");
static_assert(offsetof(AK25Power, _controlledProjectileClass) == 0x0005C0, "Member 'AK25Power::_controlledProjectileClass' has a wrong offset!");
static_assert(offsetof(AK25Power, _lamentConfigurationClass) == 0x0005C8, "Member 'AK25Power::_lamentConfigurationClass' has a wrong offset!");
static_assert(offsetof(AK25Power, _k25HuskClass) == 0x0005D0, "Member 'AK25Power::_k25HuskClass' has a wrong offset!");
static_assert(offsetof(AK25Power, _killerTeleportFinderComponentClass) == 0x0005D8, "Member 'AK25Power::_killerTeleportFinderComponentClass' has a wrong offset!");
static_assert(offsetof(AK25Power, _chainAnimationActorClass) == 0x0005E0, "Member 'AK25Power::_chainAnimationActorClass' has a wrong offset!");
static_assert(offsetof(AK25Power, _chainAnimationMappingsTables) == 0x0005E8, "Member 'AK25Power::_chainAnimationMappingsTables' has a wrong offset!");
static_assert(offsetof(AK25Power, _pillarAnimationActorClass) == 0x0005F8, "Member 'AK25Power::_pillarAnimationActorClass' has a wrong offset!");
static_assert(offsetof(AK25Power, _chainsAttachedStatusEffectClass) == 0x000600, "Member 'AK25Power::_chainsAttachedStatusEffectClass' has a wrong offset!");
static_assert(offsetof(AK25Power, _k25ProjectileLauncher) == 0x000608, "Member 'AK25Power::_k25ProjectileLauncher' has a wrong offset!");
static_assert(offsetof(AK25Power, _k25ProjectilePool) == 0x000610, "Member 'AK25Power::_k25ProjectilePool' has a wrong offset!");
static_assert(offsetof(AK25Power, _k25ChainPool) == 0x000618, "Member 'AK25Power::_k25ChainPool' has a wrong offset!");
static_assert(offsetof(AK25Power, _k25PowerChargeComponent) == 0x000620, "Member 'AK25Power::_k25PowerChargeComponent' has a wrong offset!");
static_assert(offsetof(AK25Power, _k25ProjectileProvider) == 0x000628, "Member 'AK25Power::_k25ProjectileProvider' has a wrong offset!");
static_assert(offsetof(AK25Power, _k25PowerPresentationItemProgressComponent) == 0x000630, "Member 'AK25Power::_k25PowerPresentationItemProgressComponent' has a wrong offset!");
static_assert(offsetof(AK25Power, _gateway) == 0x000638, "Member 'AK25Power::_gateway' has a wrong offset!");
static_assert(offsetof(AK25Power, _controlledProjectileInstance) == 0x000640, "Member 'AK25Power::_controlledProjectileInstance' has a wrong offset!");
static_assert(offsetof(AK25Power, _lamentConfiguration) == 0x000648, "Member 'AK25Power::_lamentConfiguration' has a wrong offset!");
static_assert(offsetof(AK25Power, _k25Husk) == 0x000650, "Member 'AK25Power::_k25Husk' has a wrong offset!");
static_assert(offsetof(AK25Power, _chainAttachmentReplicationComponent) == 0x000658, "Member 'AK25Power::_chainAttachmentReplicationComponent' has a wrong offset!");
static_assert(offsetof(AK25Power, _interactionAttacherComponent) == 0x000660, "Member 'AK25Power::_interactionAttacherComponent' has a wrong offset!");
static_assert(offsetof(AK25Power, _isPowerCharged) == 0x0006A8, "Member 'AK25Power::_isPowerCharged' has a wrong offset!");

// Class TheK25.K25PowerChargePresentationItemProgressComponent
// 0x0010 (0x00C0 - 0x00B0)
class UK25PowerChargePresentationItemProgressComponent final : public UPresentationItemProgressComponent
{
public:
	class UPowerChargeComponent*                  _powerChargeComponent;                             // 0x00B0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AK25Power*                              _k25Power;                                         // 0x00B8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K25PowerChargePresentationItemProgressComponent">();
	}
	static class UK25PowerChargePresentationItemProgressComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK25PowerChargePresentationItemProgressComponent>();
	}
};
static_assert(alignof(UK25PowerChargePresentationItemProgressComponent) == 0x000008, "Wrong alignment on UK25PowerChargePresentationItemProgressComponent");
static_assert(sizeof(UK25PowerChargePresentationItemProgressComponent) == 0x0000C0, "Wrong size on UK25PowerChargePresentationItemProgressComponent");
static_assert(offsetof(UK25PowerChargePresentationItemProgressComponent, _powerChargeComponent) == 0x0000B0, "Member 'UK25PowerChargePresentationItemProgressComponent::_powerChargeComponent' has a wrong offset!");
static_assert(offsetof(UK25PowerChargePresentationItemProgressComponent, _k25Power) == 0x0000B8, "Member 'UK25PowerChargePresentationItemProgressComponent::_k25Power' has a wrong offset!");

// Class TheK25.K25ProjectileLauncher
// 0x0038 (0x01D0 - 0x0198)
class UK25ProjectileLauncher final : public UBaseProjectileLauncher
{
public:
	struct FDBDTunableRowHandle                   _controlledProjectileInitialSpeed;                 // 0x0198(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	bool                                          _isControlledProjectileRequested;                  // 0x01C0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1C1[0x7];                                      // 0x01C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AK25ControlledProjectile*               _controlledProjectile;                             // 0x01C8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K25ProjectileLauncher">();
	}
	static class UK25ProjectileLauncher* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK25ProjectileLauncher>();
	}
};
static_assert(alignof(UK25ProjectileLauncher) == 0x000008, "Wrong alignment on UK25ProjectileLauncher");
static_assert(sizeof(UK25ProjectileLauncher) == 0x0001D0, "Wrong size on UK25ProjectileLauncher");
static_assert(offsetof(UK25ProjectileLauncher, _controlledProjectileInitialSpeed) == 0x000198, "Member 'UK25ProjectileLauncher::_controlledProjectileInitialSpeed' has a wrong offset!");
static_assert(offsetof(UK25ProjectileLauncher, _isControlledProjectileRequested) == 0x0001C0, "Member 'UK25ProjectileLauncher::_isControlledProjectileRequested' has a wrong offset!");
static_assert(offsetof(UK25ProjectileLauncher, _controlledProjectile) == 0x0001C8, "Member 'UK25ProjectileLauncher::_controlledProjectile' has a wrong offset!");

// Class TheK25.K25ProjectilePool
// 0x0000 (0x0108 - 0x0108)
class UK25ProjectilePool final : public UAuthoritativeActorPoolComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K25ProjectilePool">();
	}
	static class UK25ProjectilePool* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK25ProjectilePool>();
	}
};
static_assert(alignof(UK25ProjectilePool) == 0x000008, "Wrong alignment on UK25ProjectilePool");
static_assert(sizeof(UK25ProjectilePool) == 0x000108, "Wrong size on UK25ProjectilePool");

// Class TheK25.K25RemoveChainInteraction
// 0x0060 (0x0920 - 0x08C0)
class UK25RemoveChainInteraction : public UChargeableInteractionDefinition
{
public:
	uint8                                         Pad_8C0[0x18];                                     // 0x08C0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _interactionTimePerChainsAttached;                 // 0x08D8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class UK25SurvivorChainAttachmentComponent*   _cachedSurvivorChainAttachmentComponent;           // 0x0900(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class AK25Chain>               _chainBeingRemoved;                                // 0x0908(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class UK25SurvivorChainAttachmentComponent> _chainAttachmentComponent;                         // 0x0910(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_918[0x8];                                      // 0x0918(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K25RemoveChainInteraction">();
	}
	static class UK25RemoveChainInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK25RemoveChainInteraction>();
	}
};
static_assert(alignof(UK25RemoveChainInteraction) == 0x000010, "Wrong alignment on UK25RemoveChainInteraction");
static_assert(sizeof(UK25RemoveChainInteraction) == 0x000920, "Wrong size on UK25RemoveChainInteraction");
static_assert(offsetof(UK25RemoveChainInteraction, _interactionTimePerChainsAttached) == 0x0008D8, "Member 'UK25RemoveChainInteraction::_interactionTimePerChainsAttached' has a wrong offset!");
static_assert(offsetof(UK25RemoveChainInteraction, _cachedSurvivorChainAttachmentComponent) == 0x000900, "Member 'UK25RemoveChainInteraction::_cachedSurvivorChainAttachmentComponent' has a wrong offset!");
static_assert(offsetof(UK25RemoveChainInteraction, _chainBeingRemoved) == 0x000908, "Member 'UK25RemoveChainInteraction::_chainBeingRemoved' has a wrong offset!");
static_assert(offsetof(UK25RemoveChainInteraction, _chainAttachmentComponent) == 0x000910, "Member 'UK25RemoveChainInteraction::_chainAttachmentComponent' has a wrong offset!");

// Class TheK25.K25SolveLamentConfigurationInteraction
// 0x00E0 (0x09A0 - 0x08C0)
class UK25SolveLamentConfigurationInteraction final : public UChargeableInteractionDefinition
{
public:
	float                                         _timeBufferBeforeAllowedToUseInteractionAgain;     // 0x08C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8C4[0x4];                                      // 0x08C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _failSkillCheckTimePenalty;                        // 0x08C8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FAnimationMontageDescriptor            _failMontage;                                      // 0x08F0(0x0020)(Edit, NativeAccessSpecifierPrivate)
	uint8                                         Pad_910[0x90];                                     // 0x0910(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnSkillCheckResponseAuthority(bool Success, bool Bonus, class ADBDPlayer* Player, bool TriggerLoudNoise, ESkillCheckCustomType Type);
	void Cosmetic_TriggerKillerStoppedInteractionViaAttackSFX(class ASlasherPlayer* Killer);
	void Multicast_TriggerKillerStoppedInteractionViaAttackSFX(class ASlasherPlayer* Killer);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K25SolveLamentConfigurationInteraction">();
	}
	static class UK25SolveLamentConfigurationInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK25SolveLamentConfigurationInteraction>();
	}
};
static_assert(alignof(UK25SolveLamentConfigurationInteraction) == 0x000010, "Wrong alignment on UK25SolveLamentConfigurationInteraction");
static_assert(sizeof(UK25SolveLamentConfigurationInteraction) == 0x0009A0, "Wrong size on UK25SolveLamentConfigurationInteraction");
static_assert(offsetof(UK25SolveLamentConfigurationInteraction, _timeBufferBeforeAllowedToUseInteractionAgain) == 0x0008C0, "Member 'UK25SolveLamentConfigurationInteraction::_timeBufferBeforeAllowedToUseInteractionAgain' has a wrong offset!");
static_assert(offsetof(UK25SolveLamentConfigurationInteraction, _failSkillCheckTimePenalty) == 0x0008C8, "Member 'UK25SolveLamentConfigurationInteraction::_failSkillCheckTimePenalty' has a wrong offset!");
static_assert(offsetof(UK25SolveLamentConfigurationInteraction, _failMontage) == 0x0008F0, "Member 'UK25SolveLamentConfigurationInteraction::_failMontage' has a wrong offset!");

// Class TheK25.K25SurvivorChainAttachmentAnchor
// 0x00E8 (0x0388 - 0x02A0)
class AK25SurvivorChainAttachmentAnchor final : public AActor
{
public:
	uint8                                         Pad_2A0[0x18];                                     // 0x02A0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _chainMaxBreakingLength;                           // 0x02B8(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	float                                         _timeBetweenTrace;                                 // 0x02E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2E4[0x4];                                      // 0x02E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FK25SurvivorChainAttachmentData        _attachmentData;                                   // 0x02E8(0x0038)(Net, Transient, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class ACamperPlayer>           _owningSurvivor;                                   // 0x0320(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class AK25Chain>               _attachedChain;                                    // 0x0328(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_330[0x30];                                     // 0x0330(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                _cachedPullDirection;                              // 0x0360(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_378[0x10];                                     // 0x0378(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_OnChainAttached(class AK25Chain* ChainToAttach);
	void Cosmetic_OnChainDetached(class AK25Chain* ChainToDetach);
	void OnRep_AttachmentData();

	struct FK25SurvivorChainAttachmentData GetChainAttachmentData() const;
	struct FVector GetChainAttachmentLocation() const;
	float GetChainPullDirectionAngle() const;
	struct FVector GetChainsPullDirection() const;
	struct FVector GetChainsPullLocation() const;
	int32 GetNumberOfChainsAttached() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K25SurvivorChainAttachmentAnchor">();
	}
	static class AK25SurvivorChainAttachmentAnchor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK25SurvivorChainAttachmentAnchor>();
	}
};
static_assert(alignof(AK25SurvivorChainAttachmentAnchor) == 0x000008, "Wrong alignment on AK25SurvivorChainAttachmentAnchor");
static_assert(sizeof(AK25SurvivorChainAttachmentAnchor) == 0x000388, "Wrong size on AK25SurvivorChainAttachmentAnchor");
static_assert(offsetof(AK25SurvivorChainAttachmentAnchor, _chainMaxBreakingLength) == 0x0002B8, "Member 'AK25SurvivorChainAttachmentAnchor::_chainMaxBreakingLength' has a wrong offset!");
static_assert(offsetof(AK25SurvivorChainAttachmentAnchor, _timeBetweenTrace) == 0x0002E0, "Member 'AK25SurvivorChainAttachmentAnchor::_timeBetweenTrace' has a wrong offset!");
static_assert(offsetof(AK25SurvivorChainAttachmentAnchor, _attachmentData) == 0x0002E8, "Member 'AK25SurvivorChainAttachmentAnchor::_attachmentData' has a wrong offset!");
static_assert(offsetof(AK25SurvivorChainAttachmentAnchor, _owningSurvivor) == 0x000320, "Member 'AK25SurvivorChainAttachmentAnchor::_owningSurvivor' has a wrong offset!");
static_assert(offsetof(AK25SurvivorChainAttachmentAnchor, _attachedChain) == 0x000328, "Member 'AK25SurvivorChainAttachmentAnchor::_attachedChain' has a wrong offset!");
static_assert(offsetof(AK25SurvivorChainAttachmentAnchor, _cachedPullDirection) == 0x000360, "Member 'AK25SurvivorChainAttachmentAnchor::_cachedPullDirection' has a wrong offset!");

// Class TheK25.K25SurvivorChainAttachmentComponent
// 0x0108 (0x01B0 - 0x00A8)
class UK25SurvivorChainAttachmentComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x30];                                      // 0x00A8(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AK25SurvivorChainAttachmentAnchor> _attachmentAnchorClass;                            // 0x00D8(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FK25SurvivorChainAttachmentData> _survivorAnchorData;                               // 0x00E0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UK25SurvivorChainRotationStrategy> _survivorChainRotationStrategyClass;               // 0x00F0(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TSubclassOf<class UInteractionDefinition>> _interruptableInteractionClasses;                  // 0x00F8(0x0010)(Edit, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _maximumNumberOfChainsAttached;                    // 0x0108(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	TArray<class AK25SurvivorChainAttachmentAnchor*> _chainAttachmentAnchors;                           // 0x0130(0x0010)(Net, ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<TWeakObjectPtr<class AK25Chain>>       _chainsAttached;                                   // 0x0140(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_150[0x8];                                      // 0x0150(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UK25SurvivorChainRotationStrategy*      _survivorChainRotationStrategy;                    // 0x0158(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UK25ChainAttachmentReplicationComponent* _chainAttachmentReplicationComponent;              // 0x0160(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_168[0x38];                                     // 0x0168(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameplayTag>                   _gameEventsListToForceDetachChains;                // 0x01A0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	void Cosmetic_TriggerHitSurvivorInExitAreaSFX(class ASlasherPlayer* Killer);
	void Multicast_TriggerHitSurvivorInExitAreaSFX(class ASlasherPlayer* Killer);

	class AK25Chain* GetFirstChainToRelease() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K25SurvivorChainAttachmentComponent">();
	}
	static class UK25SurvivorChainAttachmentComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK25SurvivorChainAttachmentComponent>();
	}
};
static_assert(alignof(UK25SurvivorChainAttachmentComponent) == 0x000008, "Wrong alignment on UK25SurvivorChainAttachmentComponent");
static_assert(sizeof(UK25SurvivorChainAttachmentComponent) == 0x0001B0, "Wrong size on UK25SurvivorChainAttachmentComponent");
static_assert(offsetof(UK25SurvivorChainAttachmentComponent, _attachmentAnchorClass) == 0x0000D8, "Member 'UK25SurvivorChainAttachmentComponent::_attachmentAnchorClass' has a wrong offset!");
static_assert(offsetof(UK25SurvivorChainAttachmentComponent, _survivorAnchorData) == 0x0000E0, "Member 'UK25SurvivorChainAttachmentComponent::_survivorAnchorData' has a wrong offset!");
static_assert(offsetof(UK25SurvivorChainAttachmentComponent, _survivorChainRotationStrategyClass) == 0x0000F0, "Member 'UK25SurvivorChainAttachmentComponent::_survivorChainRotationStrategyClass' has a wrong offset!");
static_assert(offsetof(UK25SurvivorChainAttachmentComponent, _interruptableInteractionClasses) == 0x0000F8, "Member 'UK25SurvivorChainAttachmentComponent::_interruptableInteractionClasses' has a wrong offset!");
static_assert(offsetof(UK25SurvivorChainAttachmentComponent, _maximumNumberOfChainsAttached) == 0x000108, "Member 'UK25SurvivorChainAttachmentComponent::_maximumNumberOfChainsAttached' has a wrong offset!");
static_assert(offsetof(UK25SurvivorChainAttachmentComponent, _chainAttachmentAnchors) == 0x000130, "Member 'UK25SurvivorChainAttachmentComponent::_chainAttachmentAnchors' has a wrong offset!");
static_assert(offsetof(UK25SurvivorChainAttachmentComponent, _chainsAttached) == 0x000140, "Member 'UK25SurvivorChainAttachmentComponent::_chainsAttached' has a wrong offset!");
static_assert(offsetof(UK25SurvivorChainAttachmentComponent, _survivorChainRotationStrategy) == 0x000158, "Member 'UK25SurvivorChainAttachmentComponent::_survivorChainRotationStrategy' has a wrong offset!");
static_assert(offsetof(UK25SurvivorChainAttachmentComponent, _chainAttachmentReplicationComponent) == 0x000160, "Member 'UK25SurvivorChainAttachmentComponent::_chainAttachmentReplicationComponent' has a wrong offset!");
static_assert(offsetof(UK25SurvivorChainAttachmentComponent, _gameEventsListToForceDetachChains) == 0x0001A0, "Member 'UK25SurvivorChainAttachmentComponent::_gameEventsListToForceDetachChains' has a wrong offset!");

// Class TheK25.K25SurvivorChainHuntEffectsComponent
// 0x0008 (0x0110 - 0x0108)
class UK25SurvivorChainHuntEffectsComponent final : public UK25ChainHuntEffectsComponent
{
public:
	uint8                                         Pad_108[0x8];                                      // 0x0108(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class ACamperPlayer* GetOwningSurvivor() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K25SurvivorChainHuntEffectsComponent">();
	}
	static class UK25SurvivorChainHuntEffectsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK25SurvivorChainHuntEffectsComponent>();
	}
};
static_assert(alignof(UK25SurvivorChainHuntEffectsComponent) == 0x000008, "Wrong alignment on UK25SurvivorChainHuntEffectsComponent");
static_assert(sizeof(UK25SurvivorChainHuntEffectsComponent) == 0x000110, "Wrong size on UK25SurvivorChainHuntEffectsComponent");

// Class TheK25.K25SurvivorChainRotationStrategy
// 0x0010 (0x00B8 - 0x00A8)
class UK25SurvivorChainRotationStrategy final : public UBaseCharacterRotationStrategy
{
public:
	TWeakObjectPtr<class ACamperPlayer>           _cachedSurvivor;                                   // 0x00A8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UK25SurvivorChainAttachmentComponent*   _cachedChainAttachmentComponent;                   // 0x00B0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K25SurvivorChainRotationStrategy">();
	}
	static class UK25SurvivorChainRotationStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK25SurvivorChainRotationStrategy>();
	}
};
static_assert(alignof(UK25SurvivorChainRotationStrategy) == 0x000008, "Wrong alignment on UK25SurvivorChainRotationStrategy");
static_assert(sizeof(UK25SurvivorChainRotationStrategy) == 0x0000B8, "Wrong size on UK25SurvivorChainRotationStrategy");
static_assert(offsetof(UK25SurvivorChainRotationStrategy, _cachedSurvivor) == 0x0000A8, "Member 'UK25SurvivorChainRotationStrategy::_cachedSurvivor' has a wrong offset!");
static_assert(offsetof(UK25SurvivorChainRotationStrategy, _cachedChainAttachmentComponent) == 0x0000B0, "Member 'UK25SurvivorChainRotationStrategy::_cachedChainAttachmentComponent' has a wrong offset!");

// Class TheK25.K25SurvivorChainTargetterComponent
// 0x0110 (0x01B8 - 0x00A8)
class UK25SurvivorChainTargetterComponent final : public UActorComponent
{
public:
	struct FDBDTunableRowHandle                   _timeBetweenQueuedChainsLaunch;                    // 0x00A8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	float                                         _timeBetweenQueuedChainsLaunchAfterPreviousFailedAttempt; // 0x00D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _minimumSpawnDistance;                             // 0x00D8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _maximumSpawnDistance;                             // 0x0100(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	float                                         _sphereCastRadius;                                 // 0x0128(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _numberOfPositionFindingTries;                     // 0x012C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_130[0x4];                                      // 0x0130(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _maxNumberOfChainRetries;                          // 0x0134(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_138[0x80];                                     // 0x0138(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnSurvivorHealthStateChanged(ECamperDamageState OldDamageState, ECamperDamageState CurrentDamageState);

	void Multicast_DebugPositionFind(const struct FVector& StartSweepPosition, const struct FVector& EndSweepPosition, bool HasFoundPosition, const struct FVector& FoundPosition, bool HasFoundCollision, const struct FVector& CollisionPosition) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K25SurvivorChainTargetterComponent">();
	}
	static class UK25SurvivorChainTargetterComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK25SurvivorChainTargetterComponent>();
	}
};
static_assert(alignof(UK25SurvivorChainTargetterComponent) == 0x000008, "Wrong alignment on UK25SurvivorChainTargetterComponent");
static_assert(sizeof(UK25SurvivorChainTargetterComponent) == 0x0001B8, "Wrong size on UK25SurvivorChainTargetterComponent");
static_assert(offsetof(UK25SurvivorChainTargetterComponent, _timeBetweenQueuedChainsLaunch) == 0x0000A8, "Member 'UK25SurvivorChainTargetterComponent::_timeBetweenQueuedChainsLaunch' has a wrong offset!");
static_assert(offsetof(UK25SurvivorChainTargetterComponent, _timeBetweenQueuedChainsLaunchAfterPreviousFailedAttempt) == 0x0000D0, "Member 'UK25SurvivorChainTargetterComponent::_timeBetweenQueuedChainsLaunchAfterPreviousFailedAttempt' has a wrong offset!");
static_assert(offsetof(UK25SurvivorChainTargetterComponent, _minimumSpawnDistance) == 0x0000D8, "Member 'UK25SurvivorChainTargetterComponent::_minimumSpawnDistance' has a wrong offset!");
static_assert(offsetof(UK25SurvivorChainTargetterComponent, _maximumSpawnDistance) == 0x000100, "Member 'UK25SurvivorChainTargetterComponent::_maximumSpawnDistance' has a wrong offset!");
static_assert(offsetof(UK25SurvivorChainTargetterComponent, _sphereCastRadius) == 0x000128, "Member 'UK25SurvivorChainTargetterComponent::_sphereCastRadius' has a wrong offset!");
static_assert(offsetof(UK25SurvivorChainTargetterComponent, _numberOfPositionFindingTries) == 0x00012C, "Member 'UK25SurvivorChainTargetterComponent::_numberOfPositionFindingTries' has a wrong offset!");
static_assert(offsetof(UK25SurvivorChainTargetterComponent, _maxNumberOfChainRetries) == 0x000134, "Member 'UK25SurvivorChainTargetterComponent::_maxNumberOfChainRetries' has a wrong offset!");

// Class TheK25.K25TeleportInteraction
// 0x00C0 (0x0980 - 0x08C0)
class UK25TeleportInteraction final : public UChargeableInteractionDefinition
{
public:
	int32                                         _maxNumberLocationQueriesPerTick;                  // 0x08C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _timeSensingLamentConfigurationAfterInteractionEnded; // 0x08C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8C8[0x28];                                     // 0x08C8(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _slowdownAfterTeleportDuration;                    // 0x08F0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _slowdownAfterTeleportStatusEffectClass;           // 0x0918(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_920[0x60];                                     // 0x0920(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_TeleportAbortedEffects(class ASlasherPlayer* Killer);
	void Cosmetic_TeleportEndEffects(class ASlasherPlayer* Killer);
	void Cosmetic_TeleportStartEffects(class ASlasherPlayer* Killer);
	void Multicast_InitializeHusk(const struct FVector& Location, const struct FRotator& Rotation);
	void Multicast_TeleportKillerToTargetPosition(class ASlasherPlayer* Killer, const struct FVector& Location, const struct FRotator& Rotation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K25TeleportInteraction">();
	}
	static class UK25TeleportInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK25TeleportInteraction>();
	}
};
static_assert(alignof(UK25TeleportInteraction) == 0x000010, "Wrong alignment on UK25TeleportInteraction");
static_assert(sizeof(UK25TeleportInteraction) == 0x000980, "Wrong size on UK25TeleportInteraction");
static_assert(offsetof(UK25TeleportInteraction, _maxNumberLocationQueriesPerTick) == 0x0008C0, "Member 'UK25TeleportInteraction::_maxNumberLocationQueriesPerTick' has a wrong offset!");
static_assert(offsetof(UK25TeleportInteraction, _timeSensingLamentConfigurationAfterInteractionEnded) == 0x0008C4, "Member 'UK25TeleportInteraction::_timeSensingLamentConfigurationAfterInteractionEnded' has a wrong offset!");
static_assert(offsetof(UK25TeleportInteraction, _slowdownAfterTeleportDuration) == 0x0008F0, "Member 'UK25TeleportInteraction::_slowdownAfterTeleportDuration' has a wrong offset!");
static_assert(offsetof(UK25TeleportInteraction, _slowdownAfterTeleportStatusEffectClass) == 0x000918, "Member 'UK25TeleportInteraction::_slowdownAfterTeleportStatusEffectClass' has a wrong offset!");

// Class TheK25.K25WeaponAnimInstance
// 0x0000 (0x0410 - 0x0410)
class UK25WeaponAnimInstance final : public UBaseKillerWeaponAnimInstance
{
public:
	bool                                          _hasDownedTargetHoldingLamentConfiguration;        // 0x0408(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_409[0x7];                                      // 0x0409(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAttackStart(const EAttackType AttackType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K25WeaponAnimInstance">();
	}
	static class UK25WeaponAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK25WeaponAnimInstance>();
	}
};
static_assert(alignof(UK25WeaponAnimInstance) == 0x000010, "Wrong alignment on UK25WeaponAnimInstance");
static_assert(sizeof(UK25WeaponAnimInstance) == 0x000410, "Wrong size on UK25WeaponAnimInstance");
static_assert(offsetof(UK25WeaponAnimInstance, _hasDownedTargetHoldingLamentConfiguration) == 0x000408, "Member 'UK25WeaponAnimInstance::_hasDownedTargetHoldingLamentConfiguration' has a wrong offset!");

// Class TheK25.LamentConfigurationOutlineStrategy
// 0x0068 (0x0138 - 0x00D0)
class ULamentConfigurationOutlineStrategy final : public UOutlineUpdateStrategy
{
public:
	struct FLinearColor                           _noChainHuntProgressColor;                         // 0x00D0(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           _chainHuntActiveColor;                             // 0x00E0(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           _killerColor;                                      // 0x00F0(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_100[0x38];                                     // 0x0100(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LamentConfigurationOutlineStrategy">();
	}
	static class ULamentConfigurationOutlineStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULamentConfigurationOutlineStrategy>();
	}
};
static_assert(alignof(ULamentConfigurationOutlineStrategy) == 0x000008, "Wrong alignment on ULamentConfigurationOutlineStrategy");
static_assert(sizeof(ULamentConfigurationOutlineStrategy) == 0x000138, "Wrong size on ULamentConfigurationOutlineStrategy");
static_assert(offsetof(ULamentConfigurationOutlineStrategy, _noChainHuntProgressColor) == 0x0000D0, "Member 'ULamentConfigurationOutlineStrategy::_noChainHuntProgressColor' has a wrong offset!");
static_assert(offsetof(ULamentConfigurationOutlineStrategy, _chainHuntActiveColor) == 0x0000E0, "Member 'ULamentConfigurationOutlineStrategy::_chainHuntActiveColor' has a wrong offset!");
static_assert(offsetof(ULamentConfigurationOutlineStrategy, _killerColor) == 0x0000F0, "Member 'ULamentConfigurationOutlineStrategy::_killerColor' has a wrong offset!");

// Class TheK25.LamentConfigurationPlayerAnalyticsComponent
// 0x0020 (0x00C8 - 0x00A8)
class ULamentConfigurationPlayerAnalyticsComponent final : public UActorComponent
{
public:
	int32                                         _analyticsCount;                                   // 0x00A8(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLamentConfigurationPlayerPossessionData _possessionAnalytics;                              // 0x00B0(0x0018)(Net, NativeAccessSpecifierPrivate)

public:
	void OnRep_AnalyticsCount();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LamentConfigurationPlayerAnalyticsComponent">();
	}
	static class ULamentConfigurationPlayerAnalyticsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULamentConfigurationPlayerAnalyticsComponent>();
	}
};
static_assert(alignof(ULamentConfigurationPlayerAnalyticsComponent) == 0x000008, "Wrong alignment on ULamentConfigurationPlayerAnalyticsComponent");
static_assert(sizeof(ULamentConfigurationPlayerAnalyticsComponent) == 0x0000C8, "Wrong size on ULamentConfigurationPlayerAnalyticsComponent");
static_assert(offsetof(ULamentConfigurationPlayerAnalyticsComponent, _analyticsCount) == 0x0000A8, "Member 'ULamentConfigurationPlayerAnalyticsComponent::_analyticsCount' has a wrong offset!");
static_assert(offsetof(ULamentConfigurationPlayerAnalyticsComponent, _possessionAnalytics) == 0x0000B0, "Member 'ULamentConfigurationPlayerAnalyticsComponent::_possessionAnalytics' has a wrong offset!");

// Class TheK25.LamentConfigurationSpawnStrategy
// 0x0098 (0x0140 - 0x00A8)
class ULamentConfigurationSpawnStrategy final : public UActorComponent
{
public:
	float                                         _killerPointDistanceMultiplier;                    // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _survivorPointDistanceMultiplier;                  // 0x00AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _maxDistancePointAllowed;                          // 0x00B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _minSurvivorDistance;                              // 0x00B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _minSurvivorDistancePointPenalty;                  // 0x00B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _minKillerDistance;                                // 0x00BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _minHatchDistance;                                 // 0x00C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _minDistanceFromOtherSpawns;                       // 0x00C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C8[0x8];                                       // 0x00C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _minKillerDistancePointPenalty;                    // 0x00D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _numberOfSpawnPointInLottery;                      // 0x00D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _pointPenaltyPerUsedLocationTime;                  // 0x00D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_DC[0x4];                                       // 0x00DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ETileSpawnPointType>                   _spawnPointsTypes;                                 // 0x00E0(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	float                                         _downRaycastLength;                                // 0x00F0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _rayCastZOffet;                                    // 0x00F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _navmeshCheckRadius;                               // 0x00F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_FC[0x4];                                       // 0x00FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLamentConfigurationSpawnInfo>  _cached_spawnsInfo;                                // 0x0100(0x0010)(Net, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class UTileSpawnPoint*                        _lastUsedSpawnPoint;                               // 0x0110(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<TSubclassOf<class AActor>>             _actorsInMapToAvoid;                               // 0x0118(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	float                                         _minDistanceFromActorsToAvoid;                     // 0x0128(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_12C[0x4];                                      // 0x012C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AHatch*>                         _hatches;                                          // 0x0130(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LamentConfigurationSpawnStrategy">();
	}
	static class ULamentConfigurationSpawnStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULamentConfigurationSpawnStrategy>();
	}
};
static_assert(alignof(ULamentConfigurationSpawnStrategy) == 0x000008, "Wrong alignment on ULamentConfigurationSpawnStrategy");
static_assert(sizeof(ULamentConfigurationSpawnStrategy) == 0x000140, "Wrong size on ULamentConfigurationSpawnStrategy");
static_assert(offsetof(ULamentConfigurationSpawnStrategy, _killerPointDistanceMultiplier) == 0x0000A8, "Member 'ULamentConfigurationSpawnStrategy::_killerPointDistanceMultiplier' has a wrong offset!");
static_assert(offsetof(ULamentConfigurationSpawnStrategy, _survivorPointDistanceMultiplier) == 0x0000AC, "Member 'ULamentConfigurationSpawnStrategy::_survivorPointDistanceMultiplier' has a wrong offset!");
static_assert(offsetof(ULamentConfigurationSpawnStrategy, _maxDistancePointAllowed) == 0x0000B0, "Member 'ULamentConfigurationSpawnStrategy::_maxDistancePointAllowed' has a wrong offset!");
static_assert(offsetof(ULamentConfigurationSpawnStrategy, _minSurvivorDistance) == 0x0000B4, "Member 'ULamentConfigurationSpawnStrategy::_minSurvivorDistance' has a wrong offset!");
static_assert(offsetof(ULamentConfigurationSpawnStrategy, _minSurvivorDistancePointPenalty) == 0x0000B8, "Member 'ULamentConfigurationSpawnStrategy::_minSurvivorDistancePointPenalty' has a wrong offset!");
static_assert(offsetof(ULamentConfigurationSpawnStrategy, _minKillerDistance) == 0x0000BC, "Member 'ULamentConfigurationSpawnStrategy::_minKillerDistance' has a wrong offset!");
static_assert(offsetof(ULamentConfigurationSpawnStrategy, _minHatchDistance) == 0x0000C0, "Member 'ULamentConfigurationSpawnStrategy::_minHatchDistance' has a wrong offset!");
static_assert(offsetof(ULamentConfigurationSpawnStrategy, _minDistanceFromOtherSpawns) == 0x0000C4, "Member 'ULamentConfigurationSpawnStrategy::_minDistanceFromOtherSpawns' has a wrong offset!");
static_assert(offsetof(ULamentConfigurationSpawnStrategy, _minKillerDistancePointPenalty) == 0x0000D0, "Member 'ULamentConfigurationSpawnStrategy::_minKillerDistancePointPenalty' has a wrong offset!");
static_assert(offsetof(ULamentConfigurationSpawnStrategy, _numberOfSpawnPointInLottery) == 0x0000D4, "Member 'ULamentConfigurationSpawnStrategy::_numberOfSpawnPointInLottery' has a wrong offset!");
static_assert(offsetof(ULamentConfigurationSpawnStrategy, _pointPenaltyPerUsedLocationTime) == 0x0000D8, "Member 'ULamentConfigurationSpawnStrategy::_pointPenaltyPerUsedLocationTime' has a wrong offset!");
static_assert(offsetof(ULamentConfigurationSpawnStrategy, _spawnPointsTypes) == 0x0000E0, "Member 'ULamentConfigurationSpawnStrategy::_spawnPointsTypes' has a wrong offset!");
static_assert(offsetof(ULamentConfigurationSpawnStrategy, _downRaycastLength) == 0x0000F0, "Member 'ULamentConfigurationSpawnStrategy::_downRaycastLength' has a wrong offset!");
static_assert(offsetof(ULamentConfigurationSpawnStrategy, _rayCastZOffet) == 0x0000F4, "Member 'ULamentConfigurationSpawnStrategy::_rayCastZOffet' has a wrong offset!");
static_assert(offsetof(ULamentConfigurationSpawnStrategy, _navmeshCheckRadius) == 0x0000F8, "Member 'ULamentConfigurationSpawnStrategy::_navmeshCheckRadius' has a wrong offset!");
static_assert(offsetof(ULamentConfigurationSpawnStrategy, _cached_spawnsInfo) == 0x000100, "Member 'ULamentConfigurationSpawnStrategy::_cached_spawnsInfo' has a wrong offset!");
static_assert(offsetof(ULamentConfigurationSpawnStrategy, _lastUsedSpawnPoint) == 0x000110, "Member 'ULamentConfigurationSpawnStrategy::_lastUsedSpawnPoint' has a wrong offset!");
static_assert(offsetof(ULamentConfigurationSpawnStrategy, _actorsInMapToAvoid) == 0x000118, "Member 'ULamentConfigurationSpawnStrategy::_actorsInMapToAvoid' has a wrong offset!");
static_assert(offsetof(ULamentConfigurationSpawnStrategy, _minDistanceFromActorsToAvoid) == 0x000128, "Member 'ULamentConfigurationSpawnStrategy::_minDistanceFromActorsToAvoid' has a wrong offset!");
static_assert(offsetof(ULamentConfigurationSpawnStrategy, _hatches) == 0x000130, "Member 'ULamentConfigurationSpawnStrategy::_hatches' has a wrong offset!");

// Class TheK25.OwningPlayerInLamentConfigurationRange
// 0x0018 (0x0110 - 0x00F8)
class UOwningPlayerInLamentConfigurationRange final : public UAnyActorPairQueryRangeIsTrue
{
public:
	uint8                                         Pad_F8[0x18];                                      // 0x00F8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OwningPlayerInLamentConfigurationRange">();
	}
	static class UOwningPlayerInLamentConfigurationRange* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOwningPlayerInLamentConfigurationRange>();
	}
};
static_assert(alignof(UOwningPlayerInLamentConfigurationRange) == 0x000008, "Wrong alignment on UOwningPlayerInLamentConfigurationRange");
static_assert(sizeof(UOwningPlayerInLamentConfigurationRange) == 0x000110, "Wrong size on UOwningPlayerInLamentConfigurationRange");

}

