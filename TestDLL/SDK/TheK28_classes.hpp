#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: TheK28

#include "Basic.hpp"

#include "DeadByDaylight_structs.hpp"
#include "DeadByDaylight_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "AnimationUtilities_structs.hpp"
#include "DBDCompetence_classes.hpp"
#include "DBDBots_classes.hpp"
#include "DBDAnimation_classes.hpp"
#include "GameplayTagUtilities_structs.hpp"
#include "Competence_classes.hpp"
#include "Engine_classes.hpp"
#include "DataTableUtilities_structs.hpp"
#include "StatSystem_structs.hpp"
#include "TheK28_structs.hpp"
#include "GameplayTags_structs.hpp"
#include "DBDInteraction_classes.hpp"
#include "DBDCosmetic_classes.hpp"
#include "DBDSharedTypes_structs.hpp"


namespace SDK
{

// Class TheK28.Addon_K28Power_04
// 0x0000 (0x02E8 - 0x02E8)
class UAddon_K28Power_04 final : public UItemAddon
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Addon_K28Power_04">();
	}
	static class UAddon_K28Power_04* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAddon_K28Power_04>();
	}
};
static_assert(alignof(UAddon_K28Power_04) == 0x000008, "Wrong alignment on UAddon_K28Power_04");
static_assert(sizeof(UAddon_K28Power_04) == 0x0002E8, "Wrong size on UAddon_K28Power_04");

// Class TheK28.Addon_K28Power_15
// 0x0018 (0x0310 - 0x02F8)
class UAddon_K28Power_15 final : public UOnEventBaseAddon
{
public:
	TArray<TSubclassOf<class UStatusEffect>>      _survivorImposedEffectClasses;                     // 0x02F8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	float                                         _statusEffectTime;                                 // 0x0308(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_30C[0x4];                                      // 0x030C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Addon_K28Power_15">();
	}
	static class UAddon_K28Power_15* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAddon_K28Power_15>();
	}
};
static_assert(alignof(UAddon_K28Power_15) == 0x000008, "Wrong alignment on UAddon_K28Power_15");
static_assert(sizeof(UAddon_K28Power_15) == 0x000310, "Wrong size on UAddon_K28Power_15");
static_assert(offsetof(UAddon_K28Power_15, _survivorImposedEffectClasses) == 0x0002F8, "Member 'UAddon_K28Power_15::_survivorImposedEffectClasses' has a wrong offset!");
static_assert(offsetof(UAddon_K28Power_15, _statusEffectTime) == 0x000308, "Member 'UAddon_K28Power_15::_statusEffectTime' has a wrong offset!");

// Class TheK28.Addon_K28Power_16
// 0x0000 (0x02F8 - 0x02F8)
class UAddon_K28Power_16 final : public UOnEventBaseAddon
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Addon_K28Power_16">();
	}
	static class UAddon_K28Power_16* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAddon_K28Power_16>();
	}
};
static_assert(alignof(UAddon_K28Power_16) == 0x000008, "Wrong alignment on UAddon_K28Power_16");
static_assert(sizeof(UAddon_K28Power_16) == 0x0002F8, "Wrong size on UAddon_K28Power_16");

// Class TheK28.Addon_K28Power_17
// 0x0010 (0x0308 - 0x02F8)
class UAddon_K28Power_17 final : public UOnEventBaseAddon
{
public:
	TSubclassOf<class UStatusEffect>              _survivorImposedEffectClass;                       // 0x02F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _statusEffectDuration;                             // 0x0300(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_304[0x4];                                      // 0x0304(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnIntroComplete();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Addon_K28Power_17">();
	}
	static class UAddon_K28Power_17* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAddon_K28Power_17>();
	}
};
static_assert(alignof(UAddon_K28Power_17) == 0x000008, "Wrong alignment on UAddon_K28Power_17");
static_assert(sizeof(UAddon_K28Power_17) == 0x000308, "Wrong size on UAddon_K28Power_17");
static_assert(offsetof(UAddon_K28Power_17, _survivorImposedEffectClass) == 0x0002F8, "Member 'UAddon_K28Power_17::_survivorImposedEffectClass' has a wrong offset!");
static_assert(offsetof(UAddon_K28Power_17, _statusEffectDuration) == 0x000300, "Member 'UAddon_K28Power_17::_statusEffectDuration' has a wrong offset!");

// Class TheK28.Addon_K28Power_18
// 0x0038 (0x0330 - 0x02F8)
class UAddon_K28Power_18 final : public UOnEventBaseAddon
{
public:
	TSubclassOf<class UStatusEffect>              _survivorImposedEffectClass;                       // 0x02F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _survivorStatusEffectTime;                         // 0x0300(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _lockersToSlamRange;                               // 0x0304(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FAnimationMontageDescriptor            _montage;                                          // 0x0308(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_328[0x8];                                      // 0x0328(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Multicast_TriggerLockerAnimationOnAllLockers(const TArray<class ALocker*>& Lockers);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Addon_K28Power_18">();
	}
	static class UAddon_K28Power_18* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAddon_K28Power_18>();
	}
};
static_assert(alignof(UAddon_K28Power_18) == 0x000008, "Wrong alignment on UAddon_K28Power_18");
static_assert(sizeof(UAddon_K28Power_18) == 0x000330, "Wrong size on UAddon_K28Power_18");
static_assert(offsetof(UAddon_K28Power_18, _survivorImposedEffectClass) == 0x0002F8, "Member 'UAddon_K28Power_18::_survivorImposedEffectClass' has a wrong offset!");
static_assert(offsetof(UAddon_K28Power_18, _survivorStatusEffectTime) == 0x000300, "Member 'UAddon_K28Power_18::_survivorStatusEffectTime' has a wrong offset!");
static_assert(offsetof(UAddon_K28Power_18, _lockersToSlamRange) == 0x000304, "Member 'UAddon_K28Power_18::_lockersToSlamRange' has a wrong offset!");
static_assert(offsetof(UAddon_K28Power_18, _montage) == 0x000308, "Member 'UAddon_K28Power_18::_montage' has a wrong offset!");

// Class TheK28.Addon_K28Power_19
// 0x0020 (0x0318 - 0x02F8)
class UAddon_K28Power_19 final : public UOnEventBaseAddon
{
public:
	uint8                                         Pad_2F8[0x10];                                     // 0x02F8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _blockingRadius;                                   // 0x0308(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _blockDuration;                                    // 0x030C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_310[0x8];                                      // 0x0310(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Addon_K28Power_19">();
	}
	static class UAddon_K28Power_19* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAddon_K28Power_19>();
	}
};
static_assert(alignof(UAddon_K28Power_19) == 0x000008, "Wrong alignment on UAddon_K28Power_19");
static_assert(sizeof(UAddon_K28Power_19) == 0x000318, "Wrong size on UAddon_K28Power_19");
static_assert(offsetof(UAddon_K28Power_19, _blockingRadius) == 0x000308, "Member 'UAddon_K28Power_19::_blockingRadius' has a wrong offset!");
static_assert(offsetof(UAddon_K28Power_19, _blockDuration) == 0x00030C, "Member 'UAddon_K28Power_19::_blockDuration' has a wrong offset!");

// Class TheK28.Addon_K28Power_20
// 0x0090 (0x0378 - 0x02E8)
class UAddon_K28Power_20 final : public UItemAddon
{
public:
	TSubclassOf<class UStatusEffect>              _survivorImposedEffectClass;                       // 0x02E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _effectDuration;                                   // 0x02F0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2F4[0x84];                                     // 0x02F4(0x0084)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnLevelReadyToPlay();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Addon_K28Power_20">();
	}
	static class UAddon_K28Power_20* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAddon_K28Power_20>();
	}
};
static_assert(alignof(UAddon_K28Power_20) == 0x000008, "Wrong alignment on UAddon_K28Power_20");
static_assert(sizeof(UAddon_K28Power_20) == 0x000378, "Wrong size on UAddon_K28Power_20");
static_assert(offsetof(UAddon_K28Power_20, _survivorImposedEffectClass) == 0x0002E8, "Member 'UAddon_K28Power_20::_survivorImposedEffectClass' has a wrong offset!");
static_assert(offsetof(UAddon_K28Power_20, _effectDuration) == 0x0002F0, "Member 'UAddon_K28Power_20::_effectDuration' has a wrong offset!");

// Class TheK28.AISkill_FindInteractable_Lockbar
// 0x0408 (0x0710 - 0x0308)
class UAISkill_FindInteractable_Lockbar final : public UAISkill_FindInteractable
{
public:
	float                                         LockerTopHeightDiffFromActorLocation;              // 0x0308(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30C[0x4];                                      // 0x030C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAITunableParameter                    LockbarMaxDistanceFromCamper;                      // 0x0310(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    LockbarMaxDistanceFromCamperTolerance;             // 0x0370(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    MinLockbarWeight;                                  // 0x03D0(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    MaxLockbarWeight;                                  // 0x0430(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    HighLockbarWeightLastSeconds;                      // 0x0490(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    MinDistanceToReachMaxLockbarWeight;                // 0x04F0(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    MaxDistanceToReachMinLockbarWeight;                // 0x0550(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    MaxDistanceToReachMinLockbarWeightIfNearGenerator; // 0x05B0(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    MaxHeightDifferenceFromGenerator;                  // 0x0610(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         Pad_670[0xA0];                                     // 0x0670(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_FindInteractable_Lockbar">();
	}
	static class UAISkill_FindInteractable_Lockbar* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_FindInteractable_Lockbar>();
	}
};
static_assert(alignof(UAISkill_FindInteractable_Lockbar) == 0x000008, "Wrong alignment on UAISkill_FindInteractable_Lockbar");
static_assert(sizeof(UAISkill_FindInteractable_Lockbar) == 0x000710, "Wrong size on UAISkill_FindInteractable_Lockbar");
static_assert(offsetof(UAISkill_FindInteractable_Lockbar, LockerTopHeightDiffFromActorLocation) == 0x000308, "Member 'UAISkill_FindInteractable_Lockbar::LockerTopHeightDiffFromActorLocation' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_Lockbar, LockbarMaxDistanceFromCamper) == 0x000310, "Member 'UAISkill_FindInteractable_Lockbar::LockbarMaxDistanceFromCamper' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_Lockbar, LockbarMaxDistanceFromCamperTolerance) == 0x000370, "Member 'UAISkill_FindInteractable_Lockbar::LockbarMaxDistanceFromCamperTolerance' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_Lockbar, MinLockbarWeight) == 0x0003D0, "Member 'UAISkill_FindInteractable_Lockbar::MinLockbarWeight' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_Lockbar, MaxLockbarWeight) == 0x000430, "Member 'UAISkill_FindInteractable_Lockbar::MaxLockbarWeight' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_Lockbar, HighLockbarWeightLastSeconds) == 0x000490, "Member 'UAISkill_FindInteractable_Lockbar::HighLockbarWeightLastSeconds' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_Lockbar, MinDistanceToReachMaxLockbarWeight) == 0x0004F0, "Member 'UAISkill_FindInteractable_Lockbar::MinDistanceToReachMaxLockbarWeight' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_Lockbar, MaxDistanceToReachMinLockbarWeight) == 0x000550, "Member 'UAISkill_FindInteractable_Lockbar::MaxDistanceToReachMinLockbarWeight' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_Lockbar, MaxDistanceToReachMinLockbarWeightIfNearGenerator) == 0x0005B0, "Member 'UAISkill_FindInteractable_Lockbar::MaxDistanceToReachMinLockbarWeightIfNearGenerator' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_Lockbar, MaxHeightDifferenceFromGenerator) == 0x000610, "Member 'UAISkill_FindInteractable_Lockbar::MaxHeightDifferenceFromGenerator' has a wrong offset!");

// Class TheK28.BTService_FindObject_K28Remnant
// 0x0008 (0x0228 - 0x0220)
class UBTService_FindObject_K28Remnant final : public UBTService_FindObject
{
public:
	uint8                                         Pad_220[0x8];                                      // 0x0220(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_FindObject_K28Remnant">();
	}
	static class UBTService_FindObject_K28Remnant* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_FindObject_K28Remnant>();
	}
};
static_assert(alignof(UBTService_FindObject_K28Remnant) == 0x000008, "Wrong alignment on UBTService_FindObject_K28Remnant");
static_assert(sizeof(UBTService_FindObject_K28Remnant) == 0x000228, "Wrong size on UBTService_FindObject_K28Remnant");

// Class TheK28.K28TeleportTarget
// 0x0000 (0x0030 - 0x0030)
class IK28TeleportTarget final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K28TeleportTarget">();
	}
	static class IK28TeleportTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<IK28TeleportTarget>();
	}
};
static_assert(alignof(IK28TeleportTarget) == 0x000008, "Wrong alignment on IK28TeleportTarget");
static_assert(sizeof(IK28TeleportTarget) == 0x000030, "Wrong size on IK28TeleportTarget");

// Class TheK28.IsInRangeOfK28UsedLocker
// 0x0030 (0x0118 - 0x00E8)
class UIsInRangeOfK28UsedLocker final : public URangeBasedCondition
{
public:
	uint8                                         Pad_E8[0x30];                                      // 0x00E8(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IsInRangeOfK28UsedLocker">();
	}
	static class UIsInRangeOfK28UsedLocker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIsInRangeOfK28UsedLocker>();
	}
};
static_assert(alignof(UIsInRangeOfK28UsedLocker) == 0x000008, "Wrong alignment on UIsInRangeOfK28UsedLocker");
static_assert(sizeof(UIsInRangeOfK28UsedLocker) == 0x000118, "Wrong size on UIsInRangeOfK28UsedLocker");

// Class TheK28.K28AnimInstance
// 0x0030 (0x0750 - 0x0720)
class UK28AnimInstance final : public UKillerAnimInstance
{
public:
	bool                                          _isInLocker;                                       // 0x0720(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isInChase;                                        // 0x0721(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isChargingTeleportation;                          // 0x0722(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _hasTeleportationPowerCharged;                     // 0x0723(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _hasTeleportationBeenCancelled;                    // 0x0724(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _hideHandsInFPV;                                   // 0x0725(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_726[0x2];                                      // 0x0726(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UCustomizationAnimationSelector> _customizationAnimationSelectorClass;              // 0x0728(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCustomizationAnimationSelector*        _customizationAnimationSelector;                   // 0x0730(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_738[0x18];                                     // 0x0738(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_OnCustomizationAnimationMappingIDChanged(int32 AnimationMappingIndex);

	int32 GetAnimationMappingIndex() const;
	TArray<class FName> GetCustomAnimationTags() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K28AnimInstance">();
	}
	static class UK28AnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK28AnimInstance>();
	}
};
static_assert(alignof(UK28AnimInstance) == 0x000010, "Wrong alignment on UK28AnimInstance");
static_assert(sizeof(UK28AnimInstance) == 0x000750, "Wrong size on UK28AnimInstance");
static_assert(offsetof(UK28AnimInstance, _isInLocker) == 0x000720, "Member 'UK28AnimInstance::_isInLocker' has a wrong offset!");
static_assert(offsetof(UK28AnimInstance, _isInChase) == 0x000721, "Member 'UK28AnimInstance::_isInChase' has a wrong offset!");
static_assert(offsetof(UK28AnimInstance, _isChargingTeleportation) == 0x000722, "Member 'UK28AnimInstance::_isChargingTeleportation' has a wrong offset!");
static_assert(offsetof(UK28AnimInstance, _hasTeleportationPowerCharged) == 0x000723, "Member 'UK28AnimInstance::_hasTeleportationPowerCharged' has a wrong offset!");
static_assert(offsetof(UK28AnimInstance, _hasTeleportationBeenCancelled) == 0x000724, "Member 'UK28AnimInstance::_hasTeleportationBeenCancelled' has a wrong offset!");
static_assert(offsetof(UK28AnimInstance, _hideHandsInFPV) == 0x000725, "Member 'UK28AnimInstance::_hideHandsInFPV' has a wrong offset!");
static_assert(offsetof(UK28AnimInstance, _customizationAnimationSelectorClass) == 0x000728, "Member 'UK28AnimInstance::_customizationAnimationSelectorClass' has a wrong offset!");
static_assert(offsetof(UK28AnimInstance, _customizationAnimationSelector) == 0x000730, "Member 'UK28AnimInstance::_customizationAnimationSelector' has a wrong offset!");

// Class TheK28.K28CheatComponent
// 0x0000 (0x00A8 - 0x00A8)
class UK28CheatComponent final : public UActorComponent
{
public:
	void DBD_K28BreakAllLocks();
	void DBD_K28DebugCosmetics(bool NoCooldown);
	void DBD_K28DisplayLockerClusters(float SecondsToDisplayDebugElements);
	void DBD_K28LockAllLockbars();
	void DBD_K28SetPowerNoCooldown(bool NoCooldown);
	void DBD_K28TriggerNextNightCycle();
	void DBD_K28UnlockAllLockbars();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K28CheatComponent">();
	}
	static class UK28CheatComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK28CheatComponent>();
	}
};
static_assert(alignof(UK28CheatComponent) == 0x000008, "Wrong alignment on UK28CheatComponent");
static_assert(sizeof(UK28CheatComponent) == 0x0000A8, "Wrong size on UK28CheatComponent");

// Class TheK28.K28DayNightComponent
// 0x0580 (0x0628 - 0x00A8)
class UK28DayNightComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x48];                                      // 0x00A8(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UK28KillerComponent>        _killerK28ComponentClass;                          // 0x00F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UK28SurvivorComponent>      _survivorK28ComponentClass;                        // 0x00F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _chargesRequiredForNightCharge;                    // 0x0100(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _transitionToNightDuration;                        // 0x0128(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _transitiionToDayDuration;                         // 0x0150(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _chargesRequiredForNightDischarge;                 // 0x0178(0x0080)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _killerInjuresSurvivorChargeAmount;                // 0x01F8(0x0080)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _killerHookSurvivorChargeAmount;                   // 0x0278(0x0080)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _killerTeleportsToRemnantChargeAmount;             // 0x02F8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _defaultNightChargeTime;                           // 0x0320(0x0080)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _injuredSurvivorsChargeTime;                       // 0x03A0(0x0080)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _killerHidingInLockerChargeTime;                   // 0x0420(0x0080)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _defaultNightTimeDischargeRate;                    // 0x04A0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _survivorInLockerDischargeRate;                    // 0x04C8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _nighttimeNearingActivationThresholdPercent;       // 0x04F0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _nightCycleNearingEndThresholdPercent;             // 0x0518(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	EK28NightCycleState                           _currentNightCycleState;                           // 0x0540(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_541[0x17];                                     // 0x0541(0x0017)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _authority_numberInjuredSurvivors;                 // 0x0558(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _maxChargeAmount;                                  // 0x055C(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _currentChargeAmount;                              // 0x0560(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_564[0x35];                                     // 0x0564(0x0035)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _nighttimeNearingActivationThresholdReached;       // 0x0599(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _hasReachedNightCycleNearEndThreshold;             // 0x059A(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_59B[0x45];                                     // 0x059B(0x0045)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTagStateBool                          _killerIsAtNightfall;                              // 0x05E0(0x0048)(Net, Transient, NativeAccessSpecifierPrivate)

public:
	void Authority_OnIntroCompleted();
	void Authority_OnSurvivorDamageStateChanged(ECamperDamageState PreviousDamageState, ECamperDamageState NewDamageState);
	void Cosmetic_OnIsInLastTwentySecondsOfNightCycle(class UAkComponent* AkComponent);
	void Cosmetic_OnNightCycleChanged(class UAkComponent* AkComponent, EK28NightCycleState NewNightCycleState);
	void OnRep_CurrentDayNightCycle();
	void OnRep_HasReachedNightCycleNearEndThreshold();
	void OnRep_NighttimeNearingActivation();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K28DayNightComponent">();
	}
	static class UK28DayNightComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK28DayNightComponent>();
	}
};
static_assert(alignof(UK28DayNightComponent) == 0x000008, "Wrong alignment on UK28DayNightComponent");
static_assert(sizeof(UK28DayNightComponent) == 0x000628, "Wrong size on UK28DayNightComponent");
static_assert(offsetof(UK28DayNightComponent, _killerK28ComponentClass) == 0x0000F0, "Member 'UK28DayNightComponent::_killerK28ComponentClass' has a wrong offset!");
static_assert(offsetof(UK28DayNightComponent, _survivorK28ComponentClass) == 0x0000F8, "Member 'UK28DayNightComponent::_survivorK28ComponentClass' has a wrong offset!");
static_assert(offsetof(UK28DayNightComponent, _chargesRequiredForNightCharge) == 0x000100, "Member 'UK28DayNightComponent::_chargesRequiredForNightCharge' has a wrong offset!");
static_assert(offsetof(UK28DayNightComponent, _transitionToNightDuration) == 0x000128, "Member 'UK28DayNightComponent::_transitionToNightDuration' has a wrong offset!");
static_assert(offsetof(UK28DayNightComponent, _transitiionToDayDuration) == 0x000150, "Member 'UK28DayNightComponent::_transitiionToDayDuration' has a wrong offset!");
static_assert(offsetof(UK28DayNightComponent, _chargesRequiredForNightDischarge) == 0x000178, "Member 'UK28DayNightComponent::_chargesRequiredForNightDischarge' has a wrong offset!");
static_assert(offsetof(UK28DayNightComponent, _killerInjuresSurvivorChargeAmount) == 0x0001F8, "Member 'UK28DayNightComponent::_killerInjuresSurvivorChargeAmount' has a wrong offset!");
static_assert(offsetof(UK28DayNightComponent, _killerHookSurvivorChargeAmount) == 0x000278, "Member 'UK28DayNightComponent::_killerHookSurvivorChargeAmount' has a wrong offset!");
static_assert(offsetof(UK28DayNightComponent, _killerTeleportsToRemnantChargeAmount) == 0x0002F8, "Member 'UK28DayNightComponent::_killerTeleportsToRemnantChargeAmount' has a wrong offset!");
static_assert(offsetof(UK28DayNightComponent, _defaultNightChargeTime) == 0x000320, "Member 'UK28DayNightComponent::_defaultNightChargeTime' has a wrong offset!");
static_assert(offsetof(UK28DayNightComponent, _injuredSurvivorsChargeTime) == 0x0003A0, "Member 'UK28DayNightComponent::_injuredSurvivorsChargeTime' has a wrong offset!");
static_assert(offsetof(UK28DayNightComponent, _killerHidingInLockerChargeTime) == 0x000420, "Member 'UK28DayNightComponent::_killerHidingInLockerChargeTime' has a wrong offset!");
static_assert(offsetof(UK28DayNightComponent, _defaultNightTimeDischargeRate) == 0x0004A0, "Member 'UK28DayNightComponent::_defaultNightTimeDischargeRate' has a wrong offset!");
static_assert(offsetof(UK28DayNightComponent, _survivorInLockerDischargeRate) == 0x0004C8, "Member 'UK28DayNightComponent::_survivorInLockerDischargeRate' has a wrong offset!");
static_assert(offsetof(UK28DayNightComponent, _nighttimeNearingActivationThresholdPercent) == 0x0004F0, "Member 'UK28DayNightComponent::_nighttimeNearingActivationThresholdPercent' has a wrong offset!");
static_assert(offsetof(UK28DayNightComponent, _nightCycleNearingEndThresholdPercent) == 0x000518, "Member 'UK28DayNightComponent::_nightCycleNearingEndThresholdPercent' has a wrong offset!");
static_assert(offsetof(UK28DayNightComponent, _currentNightCycleState) == 0x000540, "Member 'UK28DayNightComponent::_currentNightCycleState' has a wrong offset!");
static_assert(offsetof(UK28DayNightComponent, _authority_numberInjuredSurvivors) == 0x000558, "Member 'UK28DayNightComponent::_authority_numberInjuredSurvivors' has a wrong offset!");
static_assert(offsetof(UK28DayNightComponent, _maxChargeAmount) == 0x00055C, "Member 'UK28DayNightComponent::_maxChargeAmount' has a wrong offset!");
static_assert(offsetof(UK28DayNightComponent, _currentChargeAmount) == 0x000560, "Member 'UK28DayNightComponent::_currentChargeAmount' has a wrong offset!");
static_assert(offsetof(UK28DayNightComponent, _nighttimeNearingActivationThresholdReached) == 0x000599, "Member 'UK28DayNightComponent::_nighttimeNearingActivationThresholdReached' has a wrong offset!");
static_assert(offsetof(UK28DayNightComponent, _hasReachedNightCycleNearEndThreshold) == 0x00059A, "Member 'UK28DayNightComponent::_hasReachedNightCycleNearEndThreshold' has a wrong offset!");
static_assert(offsetof(UK28DayNightComponent, _killerIsAtNightfall) == 0x0005E0, "Member 'UK28DayNightComponent::_killerIsAtNightfall' has a wrong offset!");

// Class TheK28.K28FXInterface
// 0x0000 (0x0030 - 0x0030)
class IK28FXInterface final : public IInterface
{
public:
	void Cosmetic_OnChargeTeleportCancelled();
	void Cosmetic_OnChargeTeleportComplete();
	void Cosmetic_OnChargeTeleportStart();
	void Cosmetic_OnHideKiller();
	void Cosmetic_OnIsKillingSurvivorWithMoriStateChanged(bool IsKillingSurvivorWithMori);
	void Cosmetic_OnKillerEnterLocker();
	void Cosmetic_OnLocallyObservedChanged();
	void Cosmetic_OnLockerTeleportTargetHighlighted();
	void Cosmetic_OnShowKiller(bool IsInstantShow);
	void Cosmetic_OnTeleportationToLockerEnd();
	void Cosmetic_OnTeleportationToLockerStart(float TeleportationDuration, bool IsKillerAlreadyHidingInLocker);
	void Cosmetic_OnTeleportCooldownEnded();
	void Cosmetic_SetBlackMaterialOnKiller(bool blackMaterialApplied);
	void Cosmetic_SetDebugCosmetics(bool IsDebugCosmeticsActive);
	void Cosmetic_TriggerFadeIn();
	void Cosmetic_TriggerFadeOut();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K28FXInterface">();
	}
	static class IK28FXInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IK28FXInterface>();
	}
};
static_assert(alignof(IK28FXInterface) == 0x000008, "Wrong alignment on IK28FXInterface");
static_assert(sizeof(IK28FXInterface) == 0x000030, "Wrong size on IK28FXInterface");

// Class TheK28.K28IsNightCycleState
// 0x0010 (0x00F0 - 0x00E0)
class UK28IsNightCycleState final : public UEventDrivenModifierCondition
{
public:
	EK28NightCycleState                           _nightCycleState;                                  // 0x00E0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E1[0xF];                                       // 0x00E1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnLevelReadyToPlay();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K28IsNightCycleState">();
	}
	static class UK28IsNightCycleState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK28IsNightCycleState>();
	}
};
static_assert(alignof(UK28IsNightCycleState) == 0x000008, "Wrong alignment on UK28IsNightCycleState");
static_assert(sizeof(UK28IsNightCycleState) == 0x0000F0, "Wrong size on UK28IsNightCycleState");
static_assert(offsetof(UK28IsNightCycleState, _nightCycleState) == 0x0000E0, "Member 'UK28IsNightCycleState::_nightCycleState' has a wrong offset!");

// Class TheK28.K28PlayerComponent
// 0x0108 (0x01B0 - 0x00A8)
class UK28PlayerComponent : public UActorComponent
{
public:
	TWeakObjectPtr<class UK28DayNightComponent>   _dayNightComponent;                                // 0x00A8(0x0008)(ExportObject, Net, ZeroConstructor, InstancedReference, IsPlainOldData, RepNotify, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B0[0x8];                                       // 0x00B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _nightEffectMinimumDistance;                       // 0x00B8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _nightEffectMaximumDistance;                       // 0x00E0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_108[0x60];                                     // 0x0108(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameplayTag>                   _stateTagsToDisableNightMode;                      // 0x0168(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_178[0x38];                                     // 0x0178(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_DayNightComponent();
	void OnSurvivorInRangeChanged(const bool InRange, class ACamperPlayer* Player);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K28PlayerComponent">();
	}
	static class UK28PlayerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK28PlayerComponent>();
	}
};
static_assert(alignof(UK28PlayerComponent) == 0x000008, "Wrong alignment on UK28PlayerComponent");
static_assert(sizeof(UK28PlayerComponent) == 0x0001B0, "Wrong size on UK28PlayerComponent");
static_assert(offsetof(UK28PlayerComponent, _dayNightComponent) == 0x0000A8, "Member 'UK28PlayerComponent::_dayNightComponent' has a wrong offset!");
static_assert(offsetof(UK28PlayerComponent, _nightEffectMinimumDistance) == 0x0000B8, "Member 'UK28PlayerComponent::_nightEffectMinimumDistance' has a wrong offset!");
static_assert(offsetof(UK28PlayerComponent, _nightEffectMaximumDistance) == 0x0000E0, "Member 'UK28PlayerComponent::_nightEffectMaximumDistance' has a wrong offset!");
static_assert(offsetof(UK28PlayerComponent, _stateTagsToDisableNightMode) == 0x000168, "Member 'UK28PlayerComponent::_stateTagsToDisableNightMode' has a wrong offset!");

// Class TheK28.K28KillerComponent
// 0x0030 (0x01E0 - 0x01B0)
class UK28KillerComponent final : public UK28PlayerComponent
{
public:
	uint8                                         Pad_1B0[0x30];                                     // 0x01B0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_OnNightCycleStateChanged(class ASlasherPlayer* Killer, EK28NightCycleState DayNightCycleState, bool Instant);
	void Cosmetic_OnNighttimeNearingActivation(class ASlasherPlayer* Killer);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K28KillerComponent">();
	}
	static class UK28KillerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK28KillerComponent>();
	}
};
static_assert(alignof(UK28KillerComponent) == 0x000008, "Wrong alignment on UK28KillerComponent");
static_assert(sizeof(UK28KillerComponent) == 0x0001E0, "Wrong size on UK28KillerComponent");

// Class TheK28.K28KillerEnterLockerInteraction
// 0x0030 (0x07E0 - 0x07B0)
class UK28KillerEnterLockerInteraction final : public UBaseLockerInteraction
{
public:
	float                                         _hideKillerTimePercentage;                         // 0x07A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7AC[0x34];                                     // 0x07AC(0x0034)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsKillerAllowedToEnterLocker(const class ADBDPlayer* Player) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K28KillerEnterLockerInteraction">();
	}
	static class UK28KillerEnterLockerInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK28KillerEnterLockerInteraction>();
	}
};
static_assert(alignof(UK28KillerEnterLockerInteraction) == 0x000010, "Wrong alignment on UK28KillerEnterLockerInteraction");
static_assert(sizeof(UK28KillerEnterLockerInteraction) == 0x0007E0, "Wrong size on UK28KillerEnterLockerInteraction");
static_assert(offsetof(UK28KillerEnterLockerInteraction, _hideKillerTimePercentage) == 0x0007A8, "Member 'UK28KillerEnterLockerInteraction::_hideKillerTimePercentage' has a wrong offset!");

// Class TheK28.K28KillerExitLockerInteraction
// 0x00B0 (0x0860 - 0x07B0)
class UK28KillerExitLockerInteraction : public UBaseLockerInteraction
{
public:
	EK28ExitLockerCameraBehaviour                 _cameraBehaviour;                                  // 0x07A8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7A9[0x7];                                      // 0x07A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _timeSearchLockerInteractionBlocked;               // 0x07B0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	float                                         _minDotProductFadeOutThreshold;                    // 0x07D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _rotationMaxTime;                                  // 0x07DC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _fadeOutTime;                                      // 0x07E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _fovChangeTime;                                    // 0x07E4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _fovChangeTeleportationCurve;                      // 0x07E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7F0[0x70];                                     // 0x07F0(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K28KillerExitLockerInteraction">();
	}
	static class UK28KillerExitLockerInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK28KillerExitLockerInteraction>();
	}
};
static_assert(alignof(UK28KillerExitLockerInteraction) == 0x000010, "Wrong alignment on UK28KillerExitLockerInteraction");
static_assert(sizeof(UK28KillerExitLockerInteraction) == 0x000860, "Wrong size on UK28KillerExitLockerInteraction");
static_assert(offsetof(UK28KillerExitLockerInteraction, _cameraBehaviour) == 0x0007A8, "Member 'UK28KillerExitLockerInteraction::_cameraBehaviour' has a wrong offset!");
static_assert(offsetof(UK28KillerExitLockerInteraction, _timeSearchLockerInteractionBlocked) == 0x0007B0, "Member 'UK28KillerExitLockerInteraction::_timeSearchLockerInteractionBlocked' has a wrong offset!");
static_assert(offsetof(UK28KillerExitLockerInteraction, _minDotProductFadeOutThreshold) == 0x0007D8, "Member 'UK28KillerExitLockerInteraction::_minDotProductFadeOutThreshold' has a wrong offset!");
static_assert(offsetof(UK28KillerExitLockerInteraction, _rotationMaxTime) == 0x0007DC, "Member 'UK28KillerExitLockerInteraction::_rotationMaxTime' has a wrong offset!");
static_assert(offsetof(UK28KillerExitLockerInteraction, _fadeOutTime) == 0x0007E0, "Member 'UK28KillerExitLockerInteraction::_fadeOutTime' has a wrong offset!");
static_assert(offsetof(UK28KillerExitLockerInteraction, _fovChangeTime) == 0x0007E4, "Member 'UK28KillerExitLockerInteraction::_fovChangeTime' has a wrong offset!");
static_assert(offsetof(UK28KillerExitLockerInteraction, _fovChangeTeleportationCurve) == 0x0007E8, "Member 'UK28KillerExitLockerInteraction::_fovChangeTeleportationCurve' has a wrong offset!");

// Class TheK28.K28KillerExitLockedLockerInteraction
// 0x0070 (0x08D0 - 0x0860)
class UK28KillerExitLockedLockerInteraction final : public UK28KillerExitLockerInteraction
{
public:
	float                                         _lockbarBreakTimePercentage;                       // 0x0860(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _minInteractionTime;                               // 0x0864(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _exitInteractionTime;                              // 0x0868(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_890[0x40];                                     // 0x0890(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K28KillerExitLockedLockerInteraction">();
	}
	static class UK28KillerExitLockedLockerInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK28KillerExitLockedLockerInteraction>();
	}
};
static_assert(alignof(UK28KillerExitLockedLockerInteraction) == 0x000010, "Wrong alignment on UK28KillerExitLockedLockerInteraction");
static_assert(sizeof(UK28KillerExitLockedLockerInteraction) == 0x0008D0, "Wrong size on UK28KillerExitLockedLockerInteraction");
static_assert(offsetof(UK28KillerExitLockedLockerInteraction, _lockbarBreakTimePercentage) == 0x000860, "Member 'UK28KillerExitLockedLockerInteraction::_lockbarBreakTimePercentage' has a wrong offset!");
static_assert(offsetof(UK28KillerExitLockedLockerInteraction, _minInteractionTime) == 0x000864, "Member 'UK28KillerExitLockedLockerInteraction::_minInteractionTime' has a wrong offset!");
static_assert(offsetof(UK28KillerExitLockedLockerInteraction, _exitInteractionTime) == 0x000868, "Member 'UK28KillerExitLockedLockerInteraction::_exitInteractionTime' has a wrong offset!");

// Class TheK28.K28KillerExitLockerWithSurvivorInteraction
// 0x00A0 (0x0900 - 0x0860)
class UK28KillerExitLockerWithSurvivorInteraction final : public UK28KillerExitLockerInteraction
{
public:
	float                                         _waitTimeBeforeSettingIntoCarryState;              // 0x0860(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_864[0xC];                                      // 0x0864(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAnimationMontageDescriptor            _montageFromTeleportation;                         // 0x0870(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FAnimationMontageDescriptor            _montageFromAbduction;                             // 0x0890(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8B0[0x50];                                     // 0x08B0(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K28KillerExitLockerWithSurvivorInteraction">();
	}
	static class UK28KillerExitLockerWithSurvivorInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK28KillerExitLockerWithSurvivorInteraction>();
	}
};
static_assert(alignof(UK28KillerExitLockerWithSurvivorInteraction) == 0x000010, "Wrong alignment on UK28KillerExitLockerWithSurvivorInteraction");
static_assert(sizeof(UK28KillerExitLockerWithSurvivorInteraction) == 0x000900, "Wrong size on UK28KillerExitLockerWithSurvivorInteraction");
static_assert(offsetof(UK28KillerExitLockerWithSurvivorInteraction, _waitTimeBeforeSettingIntoCarryState) == 0x000860, "Member 'UK28KillerExitLockerWithSurvivorInteraction::_waitTimeBeforeSettingIntoCarryState' has a wrong offset!");
static_assert(offsetof(UK28KillerExitLockerWithSurvivorInteraction, _montageFromTeleportation) == 0x000870, "Member 'UK28KillerExitLockerWithSurvivorInteraction::_montageFromTeleportation' has a wrong offset!");
static_assert(offsetof(UK28KillerExitLockerWithSurvivorInteraction, _montageFromAbduction) == 0x000890, "Member 'UK28KillerExitLockerWithSurvivorInteraction::_montageFromAbduction' has a wrong offset!");

// Class TheK28.K28KillerInstinctEffect
// 0x00D0 (0x0450 - 0x0380)
class UK28KillerInstinctEffect final : public UStatusEffect
{
public:
	struct FTunableStat                           _secondsToLinger;                                  // 0x0380(0x0080)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _maxDistanceToApplyRemnantTeleportKillerInstinct;  // 0x0400(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _lingeringEffectClass;                             // 0x0428(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStatusEffect*                          _lingeringEffect;                                  // 0x0430(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_438[0x18];                                     // 0x0438(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnKillerInstinctApplicableChanged(bool Active);
	void Authority_OnLevelReadyToPlay();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K28KillerInstinctEffect">();
	}
	static class UK28KillerInstinctEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK28KillerInstinctEffect>();
	}
};
static_assert(alignof(UK28KillerInstinctEffect) == 0x000008, "Wrong alignment on UK28KillerInstinctEffect");
static_assert(sizeof(UK28KillerInstinctEffect) == 0x000450, "Wrong size on UK28KillerInstinctEffect");
static_assert(offsetof(UK28KillerInstinctEffect, _secondsToLinger) == 0x000380, "Member 'UK28KillerInstinctEffect::_secondsToLinger' has a wrong offset!");
static_assert(offsetof(UK28KillerInstinctEffect, _maxDistanceToApplyRemnantTeleportKillerInstinct) == 0x000400, "Member 'UK28KillerInstinctEffect::_maxDistanceToApplyRemnantTeleportKillerInstinct' has a wrong offset!");
static_assert(offsetof(UK28KillerInstinctEffect, _lingeringEffectClass) == 0x000428, "Member 'UK28KillerInstinctEffect::_lingeringEffectClass' has a wrong offset!");
static_assert(offsetof(UK28KillerInstinctEffect, _lingeringEffect) == 0x000430, "Member 'UK28KillerInstinctEffect::_lingeringEffect' has a wrong offset!");

// Class TheK28.K28KillerLockerComponent
// 0x0198 (0x0240 - 0x00A8)
class UK28KillerLockerComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x18];                                      // 0x00A8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _targetLockerFOV;                                  // 0x00C0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _fovChangeTeleportationCurve;                      // 0x00E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _fovChangeTime;                                    // 0x00F0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F4[0x4];                                       // 0x00F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FK28KillerLockerState                  _lockerState_replicated;                           // 0x00F8(0x0010)(Net, Transient, RepNotify, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_108[0xE8];                                     // 0x0108(0x00E8)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AAnimationFollowerActor>    _extraArmsAnimationFollowerActorClass;             // 0x01F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AAnimationFollowerActor*                _extraArmsAnimationFollowerActor;                  // 0x01F8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_200[0x8];                                      // 0x0200(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _timeBetweenAttemptTrigger;                        // 0x0208(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_20C[0x34];                                     // 0x020C(0x0034)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPlayerInLockerChanged(class ADBDPlayer* PreviousPlayerInLocker, class ADBDPlayer* NewPlayerInLocker);
	void OnRep_LockerState_Replicated();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K28KillerLockerComponent">();
	}
	static class UK28KillerLockerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK28KillerLockerComponent>();
	}
};
static_assert(alignof(UK28KillerLockerComponent) == 0x000008, "Wrong alignment on UK28KillerLockerComponent");
static_assert(sizeof(UK28KillerLockerComponent) == 0x000240, "Wrong size on UK28KillerLockerComponent");
static_assert(offsetof(UK28KillerLockerComponent, _targetLockerFOV) == 0x0000C0, "Member 'UK28KillerLockerComponent::_targetLockerFOV' has a wrong offset!");
static_assert(offsetof(UK28KillerLockerComponent, _fovChangeTeleportationCurve) == 0x0000E8, "Member 'UK28KillerLockerComponent::_fovChangeTeleportationCurve' has a wrong offset!");
static_assert(offsetof(UK28KillerLockerComponent, _fovChangeTime) == 0x0000F0, "Member 'UK28KillerLockerComponent::_fovChangeTime' has a wrong offset!");
static_assert(offsetof(UK28KillerLockerComponent, _lockerState_replicated) == 0x0000F8, "Member 'UK28KillerLockerComponent::_lockerState_replicated' has a wrong offset!");
static_assert(offsetof(UK28KillerLockerComponent, _extraArmsAnimationFollowerActorClass) == 0x0001F0, "Member 'UK28KillerLockerComponent::_extraArmsAnimationFollowerActorClass' has a wrong offset!");
static_assert(offsetof(UK28KillerLockerComponent, _extraArmsAnimationFollowerActor) == 0x0001F8, "Member 'UK28KillerLockerComponent::_extraArmsAnimationFollowerActor' has a wrong offset!");
static_assert(offsetof(UK28KillerLockerComponent, _timeBetweenAttemptTrigger) == 0x000208, "Member 'UK28KillerLockerComponent::_timeBetweenAttemptTrigger' has a wrong offset!");

// Class TheK28.K28KillerPlayerViewComponent
// 0x0028 (0x00D0 - 0x00A8)
class UK28KillerPlayerViewComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x28];                                      // 0x00A8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K28KillerPlayerViewComponent">();
	}
	static class UK28KillerPlayerViewComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK28KillerPlayerViewComponent>();
	}
};
static_assert(alignof(UK28KillerPlayerViewComponent) == 0x000008, "Wrong alignment on UK28KillerPlayerViewComponent");
static_assert(sizeof(UK28KillerPlayerViewComponent) == 0x0000D0, "Wrong size on UK28KillerPlayerViewComponent");

// Class TheK28.K28KillerTeleportationComponent
// 0x0288 (0x0330 - 0x00A8)
class UK28KillerTeleportationComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x18];                                      // 0x00A8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTunableStat                           _teleportationSpeed_DayCycle;                      // 0x00C0(0x0080)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _teleportationSpeed_NightCycle;                    // 0x0140(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _teleportationTimeForSurvivorGrab;                 // 0x0168(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FAnimationMontageDescriptor            _survivorPanicInLockerAnimationMontageDescriptor;  // 0x0190(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1B0[0x10];                                     // 0x01B0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTagStateBool                          _isTeleporting;                                    // 0x01C0(0x0048)(Net, NativeAccessSpecifierPrivate)
	uint8                                         Pad_208[0x8];                                      // 0x0208(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            _defaultTeleportationCurve;                        // 0x0210(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _grabTeleportationCurve;                           // 0x0218(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_220[0x58];                                     // 0x0220(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class UGeneratorOutlineUpdateStrategy*>  _generatorOutlineUpdateStrategies;                 // 0x0278(0x0050)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C8[0x30];                                     // 0x02C8(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         _actorsHiddenDuringTeleport;                       // 0x02F8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_308[0x28];                                     // 0x0308(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Local_OnTeleportCollisionOverlapBegin(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void Local_OnTeleportCollisionOverlapEnd(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void Multicast_TeleportToLockerEnd(class UK28LockerComponent* LockerTeleportedTo, class ACamperPlayer* SurvivorInLocker);
	void Multicast_TeleportToLockerStart(const struct FK28SecondaryCameraMovementData& CameraMovementData, class UK28LockerComponent* LockerBeingTeleportedTo, class ACamperPlayer* SurvivorToGrab);
	void OnLevelReadyToPlay();
	void OnPlayerFinishedEnteringLocker(class ADBDPlayer* PlayerThatWasInLocker, class ADBDPlayer* PlayerNowInLocker);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K28KillerTeleportationComponent">();
	}
	static class UK28KillerTeleportationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK28KillerTeleportationComponent>();
	}
};
static_assert(alignof(UK28KillerTeleportationComponent) == 0x000008, "Wrong alignment on UK28KillerTeleportationComponent");
static_assert(sizeof(UK28KillerTeleportationComponent) == 0x000330, "Wrong size on UK28KillerTeleportationComponent");
static_assert(offsetof(UK28KillerTeleportationComponent, _teleportationSpeed_DayCycle) == 0x0000C0, "Member 'UK28KillerTeleportationComponent::_teleportationSpeed_DayCycle' has a wrong offset!");
static_assert(offsetof(UK28KillerTeleportationComponent, _teleportationSpeed_NightCycle) == 0x000140, "Member 'UK28KillerTeleportationComponent::_teleportationSpeed_NightCycle' has a wrong offset!");
static_assert(offsetof(UK28KillerTeleportationComponent, _teleportationTimeForSurvivorGrab) == 0x000168, "Member 'UK28KillerTeleportationComponent::_teleportationTimeForSurvivorGrab' has a wrong offset!");
static_assert(offsetof(UK28KillerTeleportationComponent, _survivorPanicInLockerAnimationMontageDescriptor) == 0x000190, "Member 'UK28KillerTeleportationComponent::_survivorPanicInLockerAnimationMontageDescriptor' has a wrong offset!");
static_assert(offsetof(UK28KillerTeleportationComponent, _isTeleporting) == 0x0001C0, "Member 'UK28KillerTeleportationComponent::_isTeleporting' has a wrong offset!");
static_assert(offsetof(UK28KillerTeleportationComponent, _defaultTeleportationCurve) == 0x000210, "Member 'UK28KillerTeleportationComponent::_defaultTeleportationCurve' has a wrong offset!");
static_assert(offsetof(UK28KillerTeleportationComponent, _grabTeleportationCurve) == 0x000218, "Member 'UK28KillerTeleportationComponent::_grabTeleportationCurve' has a wrong offset!");
static_assert(offsetof(UK28KillerTeleportationComponent, _generatorOutlineUpdateStrategies) == 0x000278, "Member 'UK28KillerTeleportationComponent::_generatorOutlineUpdateStrategies' has a wrong offset!");
static_assert(offsetof(UK28KillerTeleportationComponent, _actorsHiddenDuringTeleport) == 0x0002F8, "Member 'UK28KillerTeleportationComponent::_actorsHiddenDuringTeleport' has a wrong offset!");

// Class TheK28.K28LockAnimInstance
// 0x0010 (0x0360 - 0x0350)
class UK28LockAnimInstance final : public UAnimInstance
{
public:
	EK28LockbarState                              _lockbarState;                                     // 0x0350(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_351[0xF];                                      // 0x0351(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K28LockAnimInstance">();
	}
	static class UK28LockAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK28LockAnimInstance>();
	}
};
static_assert(alignof(UK28LockAnimInstance) == 0x000010, "Wrong alignment on UK28LockAnimInstance");
static_assert(sizeof(UK28LockAnimInstance) == 0x000360, "Wrong size on UK28LockAnimInstance");
static_assert(offsetof(UK28LockAnimInstance, _lockbarState) == 0x000350, "Member 'UK28LockAnimInstance::_lockbarState' has a wrong offset!");

// Class TheK28.K28Lockbar
// 0x0090 (0x0358 - 0x02C8)
class AK28Lockbar final : public ABaseLockerItem
{
public:
	EK28LockbarState                              _state;                                            // 0x02C8(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C9[0x7];                                      // 0x02C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMesh*                            _lockbarStaticMesh;                                // 0x02D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDBDSkeletalMeshComponentBudgeted*      _skeletalMeshComponent;                            // 0x02D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoClear, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticMeshComponent*                   _staticLockMesh;                                   // 0x02E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoClear, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBoxComponent*                          _boxComponent;                                     // 0x02E8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoClear, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBaseActorAttackableComponent*          _lockAttackableComponent;                          // 0x02F0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoClear, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMontagePlayer*                         _montagePlayer;                                    // 0x02F8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimationMontageSlave*                 _animationMontageSlave;                            // 0x0300(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTagStateBool                          _isLocked;                                         // 0x0308(0x0048)(Net, NativeAccessSpecifierPrivate)
	uint8                                         Pad_350[0x8];                                      // 0x0350(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_OnStateChanged(EK28LockbarState NewState);
	void Cosmetic_SetLockbarHighlightActivationState(bool IsHightlightActive);
	void Cosmetic_TriggerLockbarBreak();
	void OnLocallyObservedChanged();
	void OnPlayerInLockerChanged(class ADBDPlayer* PreviousPlayerInLocker, class ADBDPlayer* NewPlayerInLocker);
	void OnRep_State();

	class UMontagePlayer* GetMontagePlayer() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K28Lockbar">();
	}
	static class AK28Lockbar* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK28Lockbar>();
	}
};
static_assert(alignof(AK28Lockbar) == 0x000008, "Wrong alignment on AK28Lockbar");
static_assert(sizeof(AK28Lockbar) == 0x000358, "Wrong size on AK28Lockbar");
static_assert(offsetof(AK28Lockbar, _state) == 0x0002C8, "Member 'AK28Lockbar::_state' has a wrong offset!");
static_assert(offsetof(AK28Lockbar, _lockbarStaticMesh) == 0x0002D0, "Member 'AK28Lockbar::_lockbarStaticMesh' has a wrong offset!");
static_assert(offsetof(AK28Lockbar, _skeletalMeshComponent) == 0x0002D8, "Member 'AK28Lockbar::_skeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(AK28Lockbar, _staticLockMesh) == 0x0002E0, "Member 'AK28Lockbar::_staticLockMesh' has a wrong offset!");
static_assert(offsetof(AK28Lockbar, _boxComponent) == 0x0002E8, "Member 'AK28Lockbar::_boxComponent' has a wrong offset!");
static_assert(offsetof(AK28Lockbar, _lockAttackableComponent) == 0x0002F0, "Member 'AK28Lockbar::_lockAttackableComponent' has a wrong offset!");
static_assert(offsetof(AK28Lockbar, _montagePlayer) == 0x0002F8, "Member 'AK28Lockbar::_montagePlayer' has a wrong offset!");
static_assert(offsetof(AK28Lockbar, _animationMontageSlave) == 0x000300, "Member 'AK28Lockbar::_animationMontageSlave' has a wrong offset!");
static_assert(offsetof(AK28Lockbar, _isLocked) == 0x000308, "Member 'AK28Lockbar::_isLocked' has a wrong offset!");

// Class TheK28.K28LockerComponent
// 0x0288 (0x0330 - 0x00A8)
class UK28LockerComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x18];                                      // 0x00A8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class AK28LockerCosmeticHelperActor*          _lockerCosmeticHelper;                             // 0x00C0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C8[0x8];                                       // 0x00C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _aiWarningSoundTimeInterval;                       // 0x00D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _aiWarningSoundRange;                              // 0x00D4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _timeToTriggerWarningReveal;                       // 0x00D8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _minDistanceFromHookedSurvivor;                    // 0x0100(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _minDistanceFromKillerForTeleportationEligibility; // 0x0128(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FAnimationMontageDescriptor            _lockerShakeTeleportAnimation;                     // 0x0150(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FAnimationMontageDescriptor            _lockerTeleportCompletedAnimation;                 // 0x0170(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FAnimationMontageDescriptor            _lockerTeleportationAbductionAnimation;            // 0x0190(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TArray<TSubclassOf<class UBaseLockerInteraction>> _lockerInteractionClasses;                         // 0x01B0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	TSubclassOf<class AK28LockerCosmeticHelperActor> _lockerCosmeticHelperClass;                        // 0x01C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UK28SurvivorLockerAbductionInteraction> _lockerGrabOverridingClass;                        // 0x01C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<TSubclassOf<class UBaseLockerInteraction>> _lockerInteractionClassesToOverride;               // 0x01D0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<struct FCustomLockerOutlineOverride>   _lockedOutlineOverrides;                           // 0x01E0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	float                                         _maxSqrtDistanceForCluster;                        // 0x01F0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _minDotProductForCluster;                          // 0x01F4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                _lockerLineTraceOffset;                            // 0x01F8(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_210[0xFC];                                     // 0x0210(0x00FC)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _abductionCameraOffset;                            // 0x030C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_310[0x18];                                     // 0x0310(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class ASlasherPlayer*                         _killer;                                           // 0x0328(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K28LockerComponent">();
	}
	static class UK28LockerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK28LockerComponent>();
	}
};
static_assert(alignof(UK28LockerComponent) == 0x000008, "Wrong alignment on UK28LockerComponent");
static_assert(sizeof(UK28LockerComponent) == 0x000330, "Wrong size on UK28LockerComponent");
static_assert(offsetof(UK28LockerComponent, _lockerCosmeticHelper) == 0x0000C0, "Member 'UK28LockerComponent::_lockerCosmeticHelper' has a wrong offset!");
static_assert(offsetof(UK28LockerComponent, _aiWarningSoundTimeInterval) == 0x0000D0, "Member 'UK28LockerComponent::_aiWarningSoundTimeInterval' has a wrong offset!");
static_assert(offsetof(UK28LockerComponent, _aiWarningSoundRange) == 0x0000D4, "Member 'UK28LockerComponent::_aiWarningSoundRange' has a wrong offset!");
static_assert(offsetof(UK28LockerComponent, _timeToTriggerWarningReveal) == 0x0000D8, "Member 'UK28LockerComponent::_timeToTriggerWarningReveal' has a wrong offset!");
static_assert(offsetof(UK28LockerComponent, _minDistanceFromHookedSurvivor) == 0x000100, "Member 'UK28LockerComponent::_minDistanceFromHookedSurvivor' has a wrong offset!");
static_assert(offsetof(UK28LockerComponent, _minDistanceFromKillerForTeleportationEligibility) == 0x000128, "Member 'UK28LockerComponent::_minDistanceFromKillerForTeleportationEligibility' has a wrong offset!");
static_assert(offsetof(UK28LockerComponent, _lockerShakeTeleportAnimation) == 0x000150, "Member 'UK28LockerComponent::_lockerShakeTeleportAnimation' has a wrong offset!");
static_assert(offsetof(UK28LockerComponent, _lockerTeleportCompletedAnimation) == 0x000170, "Member 'UK28LockerComponent::_lockerTeleportCompletedAnimation' has a wrong offset!");
static_assert(offsetof(UK28LockerComponent, _lockerTeleportationAbductionAnimation) == 0x000190, "Member 'UK28LockerComponent::_lockerTeleportationAbductionAnimation' has a wrong offset!");
static_assert(offsetof(UK28LockerComponent, _lockerInteractionClasses) == 0x0001B0, "Member 'UK28LockerComponent::_lockerInteractionClasses' has a wrong offset!");
static_assert(offsetof(UK28LockerComponent, _lockerCosmeticHelperClass) == 0x0001C0, "Member 'UK28LockerComponent::_lockerCosmeticHelperClass' has a wrong offset!");
static_assert(offsetof(UK28LockerComponent, _lockerGrabOverridingClass) == 0x0001C8, "Member 'UK28LockerComponent::_lockerGrabOverridingClass' has a wrong offset!");
static_assert(offsetof(UK28LockerComponent, _lockerInteractionClassesToOverride) == 0x0001D0, "Member 'UK28LockerComponent::_lockerInteractionClassesToOverride' has a wrong offset!");
static_assert(offsetof(UK28LockerComponent, _lockedOutlineOverrides) == 0x0001E0, "Member 'UK28LockerComponent::_lockedOutlineOverrides' has a wrong offset!");
static_assert(offsetof(UK28LockerComponent, _maxSqrtDistanceForCluster) == 0x0001F0, "Member 'UK28LockerComponent::_maxSqrtDistanceForCluster' has a wrong offset!");
static_assert(offsetof(UK28LockerComponent, _minDotProductForCluster) == 0x0001F4, "Member 'UK28LockerComponent::_minDotProductForCluster' has a wrong offset!");
static_assert(offsetof(UK28LockerComponent, _lockerLineTraceOffset) == 0x0001F8, "Member 'UK28LockerComponent::_lockerLineTraceOffset' has a wrong offset!");
static_assert(offsetof(UK28LockerComponent, _abductionCameraOffset) == 0x00030C, "Member 'UK28LockerComponent::_abductionCameraOffset' has a wrong offset!");
static_assert(offsetof(UK28LockerComponent, _killer) == 0x000328, "Member 'UK28LockerComponent::_killer' has a wrong offset!");

// Class TheK28.K28LockerCosmeticHelperActor
// 0x0020 (0x02C0 - 0x02A0)
class AK28LockerCosmeticHelperActor final : public AActor
{
public:
	uint8                                         Pad_2A0[0x20];                                     // 0x02A0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_OnKillerEnteredLocker();
	void Cosmetic_OnKillerExitLocker();
	void Cosmetic_OnKillerInsideLockerRevealed();
	void Cosmetic_OnKillerTeleportationToLockerEnd();
	void Cosmetic_OnKillerTeleportationToLockerStart();
	void Cosmetic_OnLockedStateChanged(bool IsLockerLocked);
	void Cosmetic_OnLockerGrabStateChanged(bool IsLockerGrabOngoing);
	void OnAssociatedLockerActorSet();

	class ALocker* GetLocker() const;
	class UMaterialHelper* GetMaterialHelper() const;
	class USkeletalMeshComponent* GetSkeletalMesh() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K28LockerCosmeticHelperActor">();
	}
	static class AK28LockerCosmeticHelperActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK28LockerCosmeticHelperActor>();
	}
};
static_assert(alignof(AK28LockerCosmeticHelperActor) == 0x000008, "Wrong alignment on AK28LockerCosmeticHelperActor");
static_assert(sizeof(AK28LockerCosmeticHelperActor) == 0x0002C0, "Wrong size on AK28LockerCosmeticHelperActor");

// Class TheK28.K28LockerEntitySpikesUpdateStrategy
// 0x0018 (0x00E8 - 0x00D0)
class UK28LockerEntitySpikesUpdateStrategy final : public UOutlineUpdateStrategy
{
public:
	struct FLinearColor                           _outlineColor;                                     // 0x00D0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E0[0x8];                                       // 0x00E0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K28LockerEntitySpikesUpdateStrategy">();
	}
	static class UK28LockerEntitySpikesUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK28LockerEntitySpikesUpdateStrategy>();
	}
};
static_assert(alignof(UK28LockerEntitySpikesUpdateStrategy) == 0x000008, "Wrong alignment on UK28LockerEntitySpikesUpdateStrategy");
static_assert(sizeof(UK28LockerEntitySpikesUpdateStrategy) == 0x0000E8, "Wrong size on UK28LockerEntitySpikesUpdateStrategy");
static_assert(offsetof(UK28LockerEntitySpikesUpdateStrategy, _outlineColor) == 0x0000D0, "Member 'UK28LockerEntitySpikesUpdateStrategy::_outlineColor' has a wrong offset!");

// Class TheK28.K28LockerTeleportSwapInteraction
// 0x0020 (0x07A0 - 0x0780)
class UK28LockerTeleportSwapInteraction final : public UInteractionDefinition
{
public:
	uint8                                         Pad_778[0x28];                                     // 0x0778(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Multicast_CompleteTeleportation();
	void Multicast_ConfirmTeleportationRequest(class ASlasherPlayer* Killer, class UActorComponent* TeleportTarget);
	void Multicast_RefuseTeleportationRequest();
	void Server_RequestTeleportToTarget(class ASlasherPlayer* Killer, class UActorComponent* TeleportTarget);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K28LockerTeleportSwapInteraction">();
	}
	static class UK28LockerTeleportSwapInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK28LockerTeleportSwapInteraction>();
	}
};
static_assert(alignof(UK28LockerTeleportSwapInteraction) == 0x000010, "Wrong alignment on UK28LockerTeleportSwapInteraction");
static_assert(sizeof(UK28LockerTeleportSwapInteraction) == 0x0007A0, "Wrong size on UK28LockerTeleportSwapInteraction");

// Class TheK28.K28LockLockbarInteraction
// 0x0000 (0x07B0 - 0x07B0)
class UK28LockLockbarInteraction final : public UBaseLockerInteraction
{
public:
	float                                         _survivorAlignementTolerance;                      // 0x07A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7AC[0x4];                                      // 0x07AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K28LockLockbarInteraction">();
	}
	static class UK28LockLockbarInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK28LockLockbarInteraction>();
	}
};
static_assert(alignof(UK28LockLockbarInteraction) == 0x000010, "Wrong alignment on UK28LockLockbarInteraction");
static_assert(sizeof(UK28LockLockbarInteraction) == 0x0007B0, "Wrong size on UK28LockLockbarInteraction");
static_assert(offsetof(UK28LockLockbarInteraction, _survivorAlignementTolerance) == 0x0007A8, "Member 'UK28LockLockbarInteraction::_survivorAlignementTolerance' has a wrong offset!");

// Class TheK28.K28MenuAnimInstance
// 0x0010 (0x03A0 - 0x0390)
class UK28MenuAnimInstance final : public UBaseMenuAnimInstance
{
public:
	TSubclassOf<class UCustomizationAnimationSelector> _customizationAnimationSelectorClass;              // 0x0388(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCustomizationAnimationSelector*        _customizationAnimationSelector;                   // 0x0390(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_398[0x8];                                      // 0x0398(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_OnCustomizationAnimationMappingIDChanged(int32 AnimationMappingIndex);

	int32 GetAnimationMappingIndex() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K28MenuAnimInstance">();
	}
	static class UK28MenuAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK28MenuAnimInstance>();
	}
};
static_assert(alignof(UK28MenuAnimInstance) == 0x000010, "Wrong alignment on UK28MenuAnimInstance");
static_assert(sizeof(UK28MenuAnimInstance) == 0x0003A0, "Wrong size on UK28MenuAnimInstance");
static_assert(offsetof(UK28MenuAnimInstance, _customizationAnimationSelectorClass) == 0x000388, "Member 'UK28MenuAnimInstance::_customizationAnimationSelectorClass' has a wrong offset!");
static_assert(offsetof(UK28MenuAnimInstance, _customizationAnimationSelector) == 0x000390, "Member 'UK28MenuAnimInstance::_customizationAnimationSelector' has a wrong offset!");

// Class TheK28.K28P01
// 0x0030 (0x0450 - 0x0420)
class UK28P01 final : public UPerk
{
public:
	float                                         _perkActivationDuration[0x3];                      // 0x0420(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_42C[0x4];                                      // 0x042C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UStatusEffect>              _effectClass;                                      // 0x0430(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _injuryTimerDuration;                              // 0x0438(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_43C[0x4];                                      // 0x043C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTimerObject*                           _injuryTimer;                                      // 0x0440(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_448[0x8];                                      // 0x0448(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetInjuryTimerDuration() const;
	float GetPerkActivationDurationAtLevel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K28P01">();
	}
	static class UK28P01* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK28P01>();
	}
};
static_assert(alignof(UK28P01) == 0x000008, "Wrong alignment on UK28P01");
static_assert(sizeof(UK28P01) == 0x000450, "Wrong size on UK28P01");
static_assert(offsetof(UK28P01, _perkActivationDuration) == 0x000420, "Member 'UK28P01::_perkActivationDuration' has a wrong offset!");
static_assert(offsetof(UK28P01, _effectClass) == 0x000430, "Member 'UK28P01::_effectClass' has a wrong offset!");
static_assert(offsetof(UK28P01, _injuryTimerDuration) == 0x000438, "Member 'UK28P01::_injuryTimerDuration' has a wrong offset!");
static_assert(offsetof(UK28P01, _injuryTimer) == 0x000440, "Member 'UK28P01::_injuryTimer' has a wrong offset!");

// Class TheK28.K28P01Effect
// 0x0008 (0x0388 - 0x0380)
class UK28P01Effect final : public UStatusEffect
{
public:
	class ADBDPlayer*                             _playerOwner;                                      // 0x0380(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K28P01Effect">();
	}
	static class UK28P01Effect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK28P01Effect>();
	}
};
static_assert(alignof(UK28P01Effect) == 0x000008, "Wrong alignment on UK28P01Effect");
static_assert(sizeof(UK28P01Effect) == 0x000388, "Wrong size on UK28P01Effect");
static_assert(offsetof(UK28P01Effect, _playerOwner) == 0x000380, "Member 'UK28P01Effect::_playerOwner' has a wrong offset!");

// Class TheK28.K28P02
// 0x0018 (0x0438 - 0x0420)
class UK28P02 final : public UPerk
{
public:
	float                                         PerkActivationTime;                                // 0x0420(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LockerDetectionRadius;                             // 0x0424(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_428[0x8];                                      // 0x0428(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UStatusEffect>              _timedRevealToKillerEffectClass;                   // 0x0430(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	float GetLockerDetectionRadius() const;
	float GetPerkActivationTime() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K28P02">();
	}
	static class UK28P02* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK28P02>();
	}
};
static_assert(alignof(UK28P02) == 0x000008, "Wrong alignment on UK28P02");
static_assert(sizeof(UK28P02) == 0x000438, "Wrong size on UK28P02");
static_assert(offsetof(UK28P02, PerkActivationTime) == 0x000420, "Member 'UK28P02::PerkActivationTime' has a wrong offset!");
static_assert(offsetof(UK28P02, LockerDetectionRadius) == 0x000424, "Member 'UK28P02::LockerDetectionRadius' has a wrong offset!");
static_assert(offsetof(UK28P02, _timedRevealToKillerEffectClass) == 0x000430, "Member 'UK28P02::_timedRevealToKillerEffectClass' has a wrong offset!");

// Class TheK28.K28Power
// 0x0398 (0x08E8 - 0x0550)
class AK28Power final : public ACollectable
{
public:
	uint8                                         Pad_550[0x10];                                     // 0x0550(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UInteractor*                            _interactor;                                       // 0x0560(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPowerChargeComponent*                  _powerChargeComponent;                             // 0x0568(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UK28PowerChargePresentationPowerFadeComponent* _k28PowerChargePresentationPowerFadeComponent;     // 0x0570(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UK28PowerPresentationItemProgressComponent* _k28PowerPresentationItemProgressComponent;        // 0x0578(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UK28DayNightComponent>      _dayNightComponentClass;                           // 0x0580(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UK28TeleportationStrategyComponent> _teleportationStrategyComponentClass;              // 0x0588(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UK28KillerTeleportationComponent> _killerTeleportationComponentClass;                // 0x0590(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UK28KillerPlayerViewComponent> _killerPlayerViewComponentClass;                   // 0x0598(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UK28KillerLockerComponent>  _killerLockerComponentClass;                       // 0x05A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class AK28SecondaryCamera>        _secondaryCameraClass;                             // 0x05A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class AK28Remnant>                _k28RemnantClass;                                  // 0x05B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class AAnimationFollowerActor>    _moriArmsAnimationFollowerActorClass;              // 0x05B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AK28SecondaryCamera*                    _secondaryCamera;                                  // 0x05C0(0x0008)(Net, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UK28KillerLockerComponent*              _killerLockerComponent;                            // 0x05C8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AK28Remnant*                            _k28Remnant;                                       // 0x05D0(0x0008)(Net, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<TSubclassOf<class UStatusEffect>>      _killerStatusEffects;                              // 0x05D8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<TSubclassOf<class UStatusEffect>>      _survivorStatusEffects;                            // 0x05E8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	TSubclassOf<class UK28SurvivorAbductionCameraBehaviourComponent> _survivorAbductionCameraBehaviourClass;            // 0x05F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UK28DayNightComponent*                  _dayNightComponent;                                // 0x0600(0x0008)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UK28TeleportationStrategyComponent*     _teleportationStrategyComponent;                   // 0x0608(0x0008)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _tokensWhenPowerIsFullyCharged;                    // 0x0610(0x0080)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _secondsRequiredToChargePowerStartOfMatch;         // 0x0690(0x0080)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _secondsRequiredToChargePowerDayTime;              // 0x0710(0x0080)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _secondsRequiredToChargePowerNightTime;            // 0x0790(0x0080)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _maxTrackedTimeSinceLockerOrRemnantExit;           // 0x0810(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	int32                                         _teleportTokens;                                   // 0x0838(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_83C[0x4];                                      // 0x083C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FK28InteractionPreventingTagsModification> _survivorInteractionsPreventingTagModifications;   // 0x0840(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_850[0x68];                                     // 0x0850(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _isTunableInit;                                    // 0x08B8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8B9[0x2F];                                     // 0x08B9(0x002F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnIntroCompleted();
	void OnRep_TeleportTokens();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K28Power">();
	}
	static class AK28Power* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK28Power>();
	}
};
static_assert(alignof(AK28Power) == 0x000008, "Wrong alignment on AK28Power");
static_assert(sizeof(AK28Power) == 0x0008E8, "Wrong size on AK28Power");
static_assert(offsetof(AK28Power, _interactor) == 0x000560, "Member 'AK28Power::_interactor' has a wrong offset!");
static_assert(offsetof(AK28Power, _powerChargeComponent) == 0x000568, "Member 'AK28Power::_powerChargeComponent' has a wrong offset!");
static_assert(offsetof(AK28Power, _k28PowerChargePresentationPowerFadeComponent) == 0x000570, "Member 'AK28Power::_k28PowerChargePresentationPowerFadeComponent' has a wrong offset!");
static_assert(offsetof(AK28Power, _k28PowerPresentationItemProgressComponent) == 0x000578, "Member 'AK28Power::_k28PowerPresentationItemProgressComponent' has a wrong offset!");
static_assert(offsetof(AK28Power, _dayNightComponentClass) == 0x000580, "Member 'AK28Power::_dayNightComponentClass' has a wrong offset!");
static_assert(offsetof(AK28Power, _teleportationStrategyComponentClass) == 0x000588, "Member 'AK28Power::_teleportationStrategyComponentClass' has a wrong offset!");
static_assert(offsetof(AK28Power, _killerTeleportationComponentClass) == 0x000590, "Member 'AK28Power::_killerTeleportationComponentClass' has a wrong offset!");
static_assert(offsetof(AK28Power, _killerPlayerViewComponentClass) == 0x000598, "Member 'AK28Power::_killerPlayerViewComponentClass' has a wrong offset!");
static_assert(offsetof(AK28Power, _killerLockerComponentClass) == 0x0005A0, "Member 'AK28Power::_killerLockerComponentClass' has a wrong offset!");
static_assert(offsetof(AK28Power, _secondaryCameraClass) == 0x0005A8, "Member 'AK28Power::_secondaryCameraClass' has a wrong offset!");
static_assert(offsetof(AK28Power, _k28RemnantClass) == 0x0005B0, "Member 'AK28Power::_k28RemnantClass' has a wrong offset!");
static_assert(offsetof(AK28Power, _moriArmsAnimationFollowerActorClass) == 0x0005B8, "Member 'AK28Power::_moriArmsAnimationFollowerActorClass' has a wrong offset!");
static_assert(offsetof(AK28Power, _secondaryCamera) == 0x0005C0, "Member 'AK28Power::_secondaryCamera' has a wrong offset!");
static_assert(offsetof(AK28Power, _killerLockerComponent) == 0x0005C8, "Member 'AK28Power::_killerLockerComponent' has a wrong offset!");
static_assert(offsetof(AK28Power, _k28Remnant) == 0x0005D0, "Member 'AK28Power::_k28Remnant' has a wrong offset!");
static_assert(offsetof(AK28Power, _killerStatusEffects) == 0x0005D8, "Member 'AK28Power::_killerStatusEffects' has a wrong offset!");
static_assert(offsetof(AK28Power, _survivorStatusEffects) == 0x0005E8, "Member 'AK28Power::_survivorStatusEffects' has a wrong offset!");
static_assert(offsetof(AK28Power, _survivorAbductionCameraBehaviourClass) == 0x0005F8, "Member 'AK28Power::_survivorAbductionCameraBehaviourClass' has a wrong offset!");
static_assert(offsetof(AK28Power, _dayNightComponent) == 0x000600, "Member 'AK28Power::_dayNightComponent' has a wrong offset!");
static_assert(offsetof(AK28Power, _teleportationStrategyComponent) == 0x000608, "Member 'AK28Power::_teleportationStrategyComponent' has a wrong offset!");
static_assert(offsetof(AK28Power, _tokensWhenPowerIsFullyCharged) == 0x000610, "Member 'AK28Power::_tokensWhenPowerIsFullyCharged' has a wrong offset!");
static_assert(offsetof(AK28Power, _secondsRequiredToChargePowerStartOfMatch) == 0x000690, "Member 'AK28Power::_secondsRequiredToChargePowerStartOfMatch' has a wrong offset!");
static_assert(offsetof(AK28Power, _secondsRequiredToChargePowerDayTime) == 0x000710, "Member 'AK28Power::_secondsRequiredToChargePowerDayTime' has a wrong offset!");
static_assert(offsetof(AK28Power, _secondsRequiredToChargePowerNightTime) == 0x000790, "Member 'AK28Power::_secondsRequiredToChargePowerNightTime' has a wrong offset!");
static_assert(offsetof(AK28Power, _maxTrackedTimeSinceLockerOrRemnantExit) == 0x000810, "Member 'AK28Power::_maxTrackedTimeSinceLockerOrRemnantExit' has a wrong offset!");
static_assert(offsetof(AK28Power, _teleportTokens) == 0x000838, "Member 'AK28Power::_teleportTokens' has a wrong offset!");
static_assert(offsetof(AK28Power, _survivorInteractionsPreventingTagModifications) == 0x000840, "Member 'AK28Power::_survivorInteractionsPreventingTagModifications' has a wrong offset!");
static_assert(offsetof(AK28Power, _isTunableInit) == 0x0008B8, "Member 'AK28Power::_isTunableInit' has a wrong offset!");

// Class TheK28.K28PowerChargePresentationPowerFadeComponent
// 0x0000 (0x00A8 - 0x00A8)
class UK28PowerChargePresentationPowerFadeComponent final : public UPresentationPowerFadeComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K28PowerChargePresentationPowerFadeComponent">();
	}
	static class UK28PowerChargePresentationPowerFadeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK28PowerChargePresentationPowerFadeComponent>();
	}
};
static_assert(alignof(UK28PowerChargePresentationPowerFadeComponent) == 0x000008, "Wrong alignment on UK28PowerChargePresentationPowerFadeComponent");
static_assert(sizeof(UK28PowerChargePresentationPowerFadeComponent) == 0x0000A8, "Wrong size on UK28PowerChargePresentationPowerFadeComponent");

// Class TheK28.K28PowerPresentationItemProgressComponent
// 0x0008 (0x00B8 - 0x00B0)
class UK28PowerPresentationItemProgressComponent final : public UPresentationItemProgressComponent
{
public:
	TWeakObjectPtr<class AK28Power>               _k28Power;                                         // 0x00B0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K28PowerPresentationItemProgressComponent">();
	}
	static class UK28PowerPresentationItemProgressComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK28PowerPresentationItemProgressComponent>();
	}
};
static_assert(alignof(UK28PowerPresentationItemProgressComponent) == 0x000008, "Wrong alignment on UK28PowerPresentationItemProgressComponent");
static_assert(sizeof(UK28PowerPresentationItemProgressComponent) == 0x0000B8, "Wrong size on UK28PowerPresentationItemProgressComponent");
static_assert(offsetof(UK28PowerPresentationItemProgressComponent, _k28Power) == 0x0000B0, "Member 'UK28PowerPresentationItemProgressComponent::_k28Power' has a wrong offset!");

// Class TheK28.K28Remnant
// 0x01E0 (0x0480 - 0x02A0)
class AK28Remnant final : public AActor
{
public:
	uint8                                         Pad_2A0[0x60];                                     // 0x02A0(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            _teleportToRemnantSpeedCurve_Normal;               // 0x0300(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _teleportToRemnantSpeedCurve_Penalty;              // 0x0308(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDBDSkeletalMeshComponentBudgeted*      _skeletalMesh;                                     // 0x0310(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCapsuleComponent*                      _capsuleComponent;                                 // 0x0318(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimationMontageSlave*                 _montageFollower;                                  // 0x0320(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMontagePlayer*                         _montagePlayer;                                    // 0x0328(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDBDOutlineComponent*                   _outlineComponent;                                 // 0x0330(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UK28RemnantOutlineUpdateStrategy*       _remnantOutlineStrategy;                           // 0x0338(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _teleportationFadeInTime;                          // 0x0340(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _teleportationFadeOutTime;                         // 0x0368(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _minDistanceFromHookedSurvivor;                    // 0x0390(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	float                                         _renmantDeactivationTime;                          // 0x03B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _remnantDestructionTime;                           // 0x03BC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FAnimationMontageDescriptor            _slowTeleportToRenmantAnimationMontage;            // 0x03C0(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FAnimationMontageDescriptor            _fastTeleportToRenmantAnimationMontage;            // 0x03E0(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	EK28RemnantState                              _remnantState;                                     // 0x0400(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_401[0x77];                                     // 0x0401(0x0077)(Fixing Size After Last Property [ Dumper-7 ])
	class UAIPerceptionStimuliSourceComponent*    _perceptionStimuliComponent;                       // 0x0478(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Authority_OnCollisionDetected(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void Cosmetic_OnRemnantActivated();
	void Cosmetic_OnRemnantDeactivated();
	void Cosmetic_OnRemnantStateChanged(EK28RemnantState RemnantState);
	void Cosmetic_OnTeleportationPerformedVFX(class ASlasherPlayer* Killer, bool IsSlowTeleportation);
	void Cosmetic_OnTeleportationStartVFX(class ASlasherPlayer* Killer);
	void Cosmetic_SurvivorDestroyedRemnant(class ACamperPlayer* Survivor);
	void Multicast_ActivateRemnant(const struct FVector& Location, const struct FRotator& Rotation);
	void Multicast_DeactivateRemnant();
	void Multicast_SurvivorDestroyedRemnant(class ACamperPlayer* Survivor);
	void Multicast_TeleportToRemnant(class ASlasherPlayer* Killer, const struct FRotator& TeleportRotation, bool IsAnimationSlowed);
	void Multicast_TriggerTeleportStart(class ASlasherPlayer* Killer);
	void OnRep_RemnantState();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K28Remnant">();
	}
	static class AK28Remnant* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK28Remnant>();
	}
};
static_assert(alignof(AK28Remnant) == 0x000008, "Wrong alignment on AK28Remnant");
static_assert(sizeof(AK28Remnant) == 0x000480, "Wrong size on AK28Remnant");
static_assert(offsetof(AK28Remnant, _teleportToRemnantSpeedCurve_Normal) == 0x000300, "Member 'AK28Remnant::_teleportToRemnantSpeedCurve_Normal' has a wrong offset!");
static_assert(offsetof(AK28Remnant, _teleportToRemnantSpeedCurve_Penalty) == 0x000308, "Member 'AK28Remnant::_teleportToRemnantSpeedCurve_Penalty' has a wrong offset!");
static_assert(offsetof(AK28Remnant, _skeletalMesh) == 0x000310, "Member 'AK28Remnant::_skeletalMesh' has a wrong offset!");
static_assert(offsetof(AK28Remnant, _capsuleComponent) == 0x000318, "Member 'AK28Remnant::_capsuleComponent' has a wrong offset!");
static_assert(offsetof(AK28Remnant, _montageFollower) == 0x000320, "Member 'AK28Remnant::_montageFollower' has a wrong offset!");
static_assert(offsetof(AK28Remnant, _montagePlayer) == 0x000328, "Member 'AK28Remnant::_montagePlayer' has a wrong offset!");
static_assert(offsetof(AK28Remnant, _outlineComponent) == 0x000330, "Member 'AK28Remnant::_outlineComponent' has a wrong offset!");
static_assert(offsetof(AK28Remnant, _remnantOutlineStrategy) == 0x000338, "Member 'AK28Remnant::_remnantOutlineStrategy' has a wrong offset!");
static_assert(offsetof(AK28Remnant, _teleportationFadeInTime) == 0x000340, "Member 'AK28Remnant::_teleportationFadeInTime' has a wrong offset!");
static_assert(offsetof(AK28Remnant, _teleportationFadeOutTime) == 0x000368, "Member 'AK28Remnant::_teleportationFadeOutTime' has a wrong offset!");
static_assert(offsetof(AK28Remnant, _minDistanceFromHookedSurvivor) == 0x000390, "Member 'AK28Remnant::_minDistanceFromHookedSurvivor' has a wrong offset!");
static_assert(offsetof(AK28Remnant, _renmantDeactivationTime) == 0x0003B8, "Member 'AK28Remnant::_renmantDeactivationTime' has a wrong offset!");
static_assert(offsetof(AK28Remnant, _remnantDestructionTime) == 0x0003BC, "Member 'AK28Remnant::_remnantDestructionTime' has a wrong offset!");
static_assert(offsetof(AK28Remnant, _slowTeleportToRenmantAnimationMontage) == 0x0003C0, "Member 'AK28Remnant::_slowTeleportToRenmantAnimationMontage' has a wrong offset!");
static_assert(offsetof(AK28Remnant, _fastTeleportToRenmantAnimationMontage) == 0x0003E0, "Member 'AK28Remnant::_fastTeleportToRenmantAnimationMontage' has a wrong offset!");
static_assert(offsetof(AK28Remnant, _remnantState) == 0x000400, "Member 'AK28Remnant::_remnantState' has a wrong offset!");
static_assert(offsetof(AK28Remnant, _perceptionStimuliComponent) == 0x000478, "Member 'AK28Remnant::_perceptionStimuliComponent' has a wrong offset!");

// Class TheK28.K28RemnantAnimInstance
// 0x0020 (0x0370 - 0x0350)
class UK28RemnantAnimInstance final : public UAnimInstance
{
public:
	EK28RemnantState                              _currentRemnantState;                              // 0x0350(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isTeleportingToRemnant;                           // 0x0351(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_352[0x1E];                                     // 0x0352(0x001E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class ACamperPlayer* ConsumeSurvivorWhoDestroyedRemnant();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K28RemnantAnimInstance">();
	}
	static class UK28RemnantAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK28RemnantAnimInstance>();
	}
};
static_assert(alignof(UK28RemnantAnimInstance) == 0x000010, "Wrong alignment on UK28RemnantAnimInstance");
static_assert(sizeof(UK28RemnantAnimInstance) == 0x000370, "Wrong size on UK28RemnantAnimInstance");
static_assert(offsetof(UK28RemnantAnimInstance, _currentRemnantState) == 0x000350, "Member 'UK28RemnantAnimInstance::_currentRemnantState' has a wrong offset!");
static_assert(offsetof(UK28RemnantAnimInstance, _isTeleportingToRemnant) == 0x000351, "Member 'UK28RemnantAnimInstance::_isTeleportingToRemnant' has a wrong offset!");

// Class TheK28.K28RemnantOutlineUpdateStrategy
// 0x0018 (0x00E8 - 0x00D0)
class UK28RemnantOutlineUpdateStrategy final : public UOutlineUpdateStrategy
{
public:
	struct FLinearColor                           _availableForTeleportSelectionColor;               // 0x00D0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E0[0x8];                                       // 0x00E0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K28RemnantOutlineUpdateStrategy">();
	}
	static class UK28RemnantOutlineUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK28RemnantOutlineUpdateStrategy>();
	}
};
static_assert(alignof(UK28RemnantOutlineUpdateStrategy) == 0x000008, "Wrong alignment on UK28RemnantOutlineUpdateStrategy");
static_assert(sizeof(UK28RemnantOutlineUpdateStrategy) == 0x0000E8, "Wrong size on UK28RemnantOutlineUpdateStrategy");
static_assert(offsetof(UK28RemnantOutlineUpdateStrategy, _availableForTeleportSelectionColor) == 0x0000D0, "Member 'UK28RemnantOutlineUpdateStrategy::_availableForTeleportSelectionColor' has a wrong offset!");

// Class TheK28.K28SecondaryCamera
// 0x01C8 (0x0468 - 0x02A0)
class AK28SecondaryCamera final : public AActor
{
public:
	uint8                                         Pad_2A0[0x8];                                      // 0x02A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBoxComponent*                          _teleportCollision;                                // 0x02A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B0[0x4];                                      // 0x02B0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _minimumCameraPitchOrientationAngle;               // 0x02B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _maximumCameraPitchOrientationAngle;               // 0x02B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _observerRotationSpeed;                            // 0x02BC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _minTimeBetweenCameraRotationUpdateRPC;            // 0x02C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _survivorGrabTransition_CameraRotationEndPercentage; // 0x02C4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _survivorGrabTransition_DistanceFromLocker;        // 0x02C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2CC[0x174];                                    // 0x02CC(0x0174)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameplayTag>                   _stateTagsToDisableNightMode;                      // 0x0440(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	bool                                          _isKillerPlayerViewTarget;                         // 0x0450(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_451[0x17];                                     // 0x0451(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_DisableAllEffects();
	void Cosmetic_OnIsLocallyObservingKillerChanged(bool IsLocallyObservingKiller);
	void Cosmetic_OnKillerEnterLocker();
	void Cosmetic_OnKillerExitLocker();
	void Cosmetic_OnNightCycleChanged(EK28NightCycleState NewNightCycleState);
	void Cosmetic_TriggerFadeIn();
	void Cosmetic_TriggerFadeOut();
	void Cosmetic_TriggerTeleportEndVisuals();
	void Cosmetic_TriggerTeleportStartVisuals();
	void Cosmetic_UpdateDarknessPlaneVisibility(bool IsVisible);
	void Multicast_SetCameraOrientation(const struct FRotator& NewOrientation, bool IsRelativeRotation);
	void OnLevelReadyToPlay();
	void OnRep_IsKillerPlayerViewTarget();
	void Server_SetCameraOrientation(const struct FRotator& NewOrientation);
	void Server_SetIsKillerPlayerViewTarget(bool IsKillerPlayerViewTarget);

	struct FRotator GetCameraWorldRotation() const;
	bool GetIsKillerPlayerViewTarget() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K28SecondaryCamera">();
	}
	static class AK28SecondaryCamera* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK28SecondaryCamera>();
	}
};
static_assert(alignof(AK28SecondaryCamera) == 0x000008, "Wrong alignment on AK28SecondaryCamera");
static_assert(sizeof(AK28SecondaryCamera) == 0x000468, "Wrong size on AK28SecondaryCamera");
static_assert(offsetof(AK28SecondaryCamera, _teleportCollision) == 0x0002A8, "Member 'AK28SecondaryCamera::_teleportCollision' has a wrong offset!");
static_assert(offsetof(AK28SecondaryCamera, _minimumCameraPitchOrientationAngle) == 0x0002B4, "Member 'AK28SecondaryCamera::_minimumCameraPitchOrientationAngle' has a wrong offset!");
static_assert(offsetof(AK28SecondaryCamera, _maximumCameraPitchOrientationAngle) == 0x0002B8, "Member 'AK28SecondaryCamera::_maximumCameraPitchOrientationAngle' has a wrong offset!");
static_assert(offsetof(AK28SecondaryCamera, _observerRotationSpeed) == 0x0002BC, "Member 'AK28SecondaryCamera::_observerRotationSpeed' has a wrong offset!");
static_assert(offsetof(AK28SecondaryCamera, _minTimeBetweenCameraRotationUpdateRPC) == 0x0002C0, "Member 'AK28SecondaryCamera::_minTimeBetweenCameraRotationUpdateRPC' has a wrong offset!");
static_assert(offsetof(AK28SecondaryCamera, _survivorGrabTransition_CameraRotationEndPercentage) == 0x0002C4, "Member 'AK28SecondaryCamera::_survivorGrabTransition_CameraRotationEndPercentage' has a wrong offset!");
static_assert(offsetof(AK28SecondaryCamera, _survivorGrabTransition_DistanceFromLocker) == 0x0002C8, "Member 'AK28SecondaryCamera::_survivorGrabTransition_DistanceFromLocker' has a wrong offset!");
static_assert(offsetof(AK28SecondaryCamera, _stateTagsToDisableNightMode) == 0x000440, "Member 'AK28SecondaryCamera::_stateTagsToDisableNightMode' has a wrong offset!");
static_assert(offsetof(AK28SecondaryCamera, _isKillerPlayerViewTarget) == 0x000450, "Member 'AK28SecondaryCamera::_isKillerPlayerViewTarget' has a wrong offset!");

// Class TheK28.K28SurvivorAbductionCameraBehaviourComponent
// 0x0028 (0x00D0 - 0x00A8)
class UK28SurvivorAbductionCameraBehaviourComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _targetSpringArmLength;                            // 0x00B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _targetLockerOffsetForCameraView;                  // 0x00B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector2D                              _cameraLocationOffset;                             // 0x00B8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C8[0x8];                                       // 0x00C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K28SurvivorAbductionCameraBehaviourComponent">();
	}
	static class UK28SurvivorAbductionCameraBehaviourComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK28SurvivorAbductionCameraBehaviourComponent>();
	}
};
static_assert(alignof(UK28SurvivorAbductionCameraBehaviourComponent) == 0x000008, "Wrong alignment on UK28SurvivorAbductionCameraBehaviourComponent");
static_assert(sizeof(UK28SurvivorAbductionCameraBehaviourComponent) == 0x0000D0, "Wrong size on UK28SurvivorAbductionCameraBehaviourComponent");
static_assert(offsetof(UK28SurvivorAbductionCameraBehaviourComponent, _targetSpringArmLength) == 0x0000B0, "Member 'UK28SurvivorAbductionCameraBehaviourComponent::_targetSpringArmLength' has a wrong offset!");
static_assert(offsetof(UK28SurvivorAbductionCameraBehaviourComponent, _targetLockerOffsetForCameraView) == 0x0000B4, "Member 'UK28SurvivorAbductionCameraBehaviourComponent::_targetLockerOffsetForCameraView' has a wrong offset!");
static_assert(offsetof(UK28SurvivorAbductionCameraBehaviourComponent, _cameraLocationOffset) == 0x0000B8, "Member 'UK28SurvivorAbductionCameraBehaviourComponent::_cameraLocationOffset' has a wrong offset!");

// Class TheK28.K28SurvivorComponent
// 0x0088 (0x0238 - 0x01B0)
class UK28SurvivorComponent final : public UK28PlayerComponent
{
public:
	uint8                                         Pad_1B0[0x8];                                      // 0x01B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _killerBlackMaterialDarknessEffect;                // 0x01B8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1E0[0x58];                                     // 0x01E0(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnKillerInRangeChanged(const bool InRange);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K28SurvivorComponent">();
	}
	static class UK28SurvivorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK28SurvivorComponent>();
	}
};
static_assert(alignof(UK28SurvivorComponent) == 0x000008, "Wrong alignment on UK28SurvivorComponent");
static_assert(sizeof(UK28SurvivorComponent) == 0x000238, "Wrong size on UK28SurvivorComponent");
static_assert(offsetof(UK28SurvivorComponent, _killerBlackMaterialDarknessEffect) == 0x0001B8, "Member 'UK28SurvivorComponent::_killerBlackMaterialDarknessEffect' has a wrong offset!");

// Class TheK28.K28SurvivorCosmeticHelperActor
// 0x0040 (0x0348 - 0x0308)
class AK28SurvivorCosmeticHelperActor final : public ASurvivorCosmeticHelperActor
{
public:
	uint8                                         Pad_308[0x20];                                     // 0x0308(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameplayTag>                   _stateTagsToDisableNightMode;                      // 0x0328(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_338[0x10];                                     // 0x0338(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_ActivateNightGlowVFX();
	void Cosmetic_DeactivateNightGlowVFX();
	void Cosmetic_OnLocallyObservedChanged();
	void Cosmetic_OnNightCycleChanged(EK28NightCycleState NightCycleState, bool Instant);
	void Cosmetic_OnNighttimeNearingActivation();
	void OnLevelReadyToPlay();

	class UStaticMeshComponent* GetDarknessPlaneMesh() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K28SurvivorCosmeticHelperActor">();
	}
	static class AK28SurvivorCosmeticHelperActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK28SurvivorCosmeticHelperActor>();
	}
};
static_assert(alignof(AK28SurvivorCosmeticHelperActor) == 0x000008, "Wrong alignment on AK28SurvivorCosmeticHelperActor");
static_assert(sizeof(AK28SurvivorCosmeticHelperActor) == 0x000348, "Wrong size on AK28SurvivorCosmeticHelperActor");
static_assert(offsetof(AK28SurvivorCosmeticHelperActor, _stateTagsToDisableNightMode) == 0x000328, "Member 'AK28SurvivorCosmeticHelperActor::_stateTagsToDisableNightMode' has a wrong offset!");

// Class TheK28.K28SurvivorLockerAbductionInteraction
// 0x0080 (0x0830 - 0x07B0)
class UK28SurvivorLockerAbductionInteraction final : public UBaseLockerInteraction
{
public:
	struct FAnimationMontageDescriptor            _survivorPanicInLockerAnimationMontageDescriptor;  // 0x07A8(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class UBaseLockerInteraction>  _overriddenInteractionInstance;                    // 0x07C8(0x0008)(ExportObject, Net, ZeroConstructor, InstancedReference, IsPlainOldData, RepNotify, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FGameplayTag>                   _overridingTags;                                   // 0x07D0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	float                                         _fadeOutTime;                                      // 0x07E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _minDotProductFadeOutThreshold;                    // 0x07E4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _rotationMaxTime;                                  // 0x07E8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7EC[0x44];                                     // 0x07EC(0x0044)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_OverriddenInteractionInstance();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K28SurvivorLockerAbductionInteraction">();
	}
	static class UK28SurvivorLockerAbductionInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK28SurvivorLockerAbductionInteraction>();
	}
};
static_assert(alignof(UK28SurvivorLockerAbductionInteraction) == 0x000010, "Wrong alignment on UK28SurvivorLockerAbductionInteraction");
static_assert(sizeof(UK28SurvivorLockerAbductionInteraction) == 0x000830, "Wrong size on UK28SurvivorLockerAbductionInteraction");
static_assert(offsetof(UK28SurvivorLockerAbductionInteraction, _survivorPanicInLockerAnimationMontageDescriptor) == 0x0007A8, "Member 'UK28SurvivorLockerAbductionInteraction::_survivorPanicInLockerAnimationMontageDescriptor' has a wrong offset!");
static_assert(offsetof(UK28SurvivorLockerAbductionInteraction, _overriddenInteractionInstance) == 0x0007C8, "Member 'UK28SurvivorLockerAbductionInteraction::_overriddenInteractionInstance' has a wrong offset!");
static_assert(offsetof(UK28SurvivorLockerAbductionInteraction, _overridingTags) == 0x0007D0, "Member 'UK28SurvivorLockerAbductionInteraction::_overridingTags' has a wrong offset!");
static_assert(offsetof(UK28SurvivorLockerAbductionInteraction, _fadeOutTime) == 0x0007E0, "Member 'UK28SurvivorLockerAbductionInteraction::_fadeOutTime' has a wrong offset!");
static_assert(offsetof(UK28SurvivorLockerAbductionInteraction, _minDotProductFadeOutThreshold) == 0x0007E4, "Member 'UK28SurvivorLockerAbductionInteraction::_minDotProductFadeOutThreshold' has a wrong offset!");
static_assert(offsetof(UK28SurvivorLockerAbductionInteraction, _rotationMaxTime) == 0x0007E8, "Member 'UK28SurvivorLockerAbductionInteraction::_rotationMaxTime' has a wrong offset!");

// Class TheK28.K28TeleportationStrategyComponent
// 0x00C8 (0x0170 - 0x00A8)
class UK28TeleportationStrategyComponent final : public UActorComponent
{
public:
	TArray<struct FK28LockerCluster>              _lockerClusters;                                   // 0x00A8(0x0010)(Net, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	float                                         _minMovementSquaredDistanceForBestClusterRecalculation; // 0x00B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _minDeltaSquaredDistanceForBestTargetRecalculation; // 0x00BC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _minDeltaDotProductForBestTargetRecalculation;     // 0x00C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _minDotProductToBeEligibleForBestCluster;          // 0x00C4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UK28LockerComponent>        _lockerComponentClass;                             // 0x00C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class ADBDActorIndicator>         _teleportIndicatorClass;                           // 0x00D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ADBDActorIndicator*                     _teleportIndicator;                                // 0x00D8(0x0008)(Net, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E0[0x90];                                      // 0x00E0(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnLevelReadyToPlay();
	void Multicast_UpdateBestTeleportTarget(int32 bestTeleportTargetID);
	void Server_UpdateBestTeleportTarget(int32 bestTeleportTargetID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K28TeleportationStrategyComponent">();
	}
	static class UK28TeleportationStrategyComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK28TeleportationStrategyComponent>();
	}
};
static_assert(alignof(UK28TeleportationStrategyComponent) == 0x000008, "Wrong alignment on UK28TeleportationStrategyComponent");
static_assert(sizeof(UK28TeleportationStrategyComponent) == 0x000170, "Wrong size on UK28TeleportationStrategyComponent");
static_assert(offsetof(UK28TeleportationStrategyComponent, _lockerClusters) == 0x0000A8, "Member 'UK28TeleportationStrategyComponent::_lockerClusters' has a wrong offset!");
static_assert(offsetof(UK28TeleportationStrategyComponent, _minMovementSquaredDistanceForBestClusterRecalculation) == 0x0000B8, "Member 'UK28TeleportationStrategyComponent::_minMovementSquaredDistanceForBestClusterRecalculation' has a wrong offset!");
static_assert(offsetof(UK28TeleportationStrategyComponent, _minDeltaSquaredDistanceForBestTargetRecalculation) == 0x0000BC, "Member 'UK28TeleportationStrategyComponent::_minDeltaSquaredDistanceForBestTargetRecalculation' has a wrong offset!");
static_assert(offsetof(UK28TeleportationStrategyComponent, _minDeltaDotProductForBestTargetRecalculation) == 0x0000C0, "Member 'UK28TeleportationStrategyComponent::_minDeltaDotProductForBestTargetRecalculation' has a wrong offset!");
static_assert(offsetof(UK28TeleportationStrategyComponent, _minDotProductToBeEligibleForBestCluster) == 0x0000C4, "Member 'UK28TeleportationStrategyComponent::_minDotProductToBeEligibleForBestCluster' has a wrong offset!");
static_assert(offsetof(UK28TeleportationStrategyComponent, _lockerComponentClass) == 0x0000C8, "Member 'UK28TeleportationStrategyComponent::_lockerComponentClass' has a wrong offset!");
static_assert(offsetof(UK28TeleportationStrategyComponent, _teleportIndicatorClass) == 0x0000D0, "Member 'UK28TeleportationStrategyComponent::_teleportIndicatorClass' has a wrong offset!");
static_assert(offsetof(UK28TeleportationStrategyComponent, _teleportIndicator) == 0x0000D8, "Member 'UK28TeleportationStrategyComponent::_teleportIndicator' has a wrong offset!");

// Class TheK28.K28TeleportInteraction
// 0x00F0 (0x09B0 - 0x08C0)
class UK28TeleportInteraction final : public UChargeableInteractionDefinition
{
public:
	struct FSecondaryInteractionProperties        _confirmTeleportationProperties;                   // 0x08C0(0x0038)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FSecondaryInteractionProperties        _returnToRemnantProperties;                        // 0x08F8(0x0038)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	EInputInteractionType                         _triggerTeleportInputType;                         // 0x0930(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_931[0x7];                                      // 0x0931(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            _chargingSpeedCurve;                               // 0x0938(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _chargedSpeedCurve;                                // 0x0940(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _cancelledSpeedCurve;                              // 0x0948(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _releaseInputMaxTime;                              // 0x0950(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _minimumChargePercentageToConsiderTeleportButtonPress; // 0x0954(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_958[0x58];                                     // 0x0958(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Multicast_CompleteTeleportation();
	void Multicast_ConfirmTeleportationRequest(class ASlasherPlayer* Killer, class UObject* TeleportTarget);
	void Multicast_RefuseTeleportationRequest();
	void Server_RequestTeleportToTarget(class ASlasherPlayer* Killer, class UObject* TeleportTarget);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K28TeleportInteraction">();
	}
	static class UK28TeleportInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK28TeleportInteraction>();
	}
};
static_assert(alignof(UK28TeleportInteraction) == 0x000010, "Wrong alignment on UK28TeleportInteraction");
static_assert(sizeof(UK28TeleportInteraction) == 0x0009B0, "Wrong size on UK28TeleportInteraction");
static_assert(offsetof(UK28TeleportInteraction, _confirmTeleportationProperties) == 0x0008C0, "Member 'UK28TeleportInteraction::_confirmTeleportationProperties' has a wrong offset!");
static_assert(offsetof(UK28TeleportInteraction, _returnToRemnantProperties) == 0x0008F8, "Member 'UK28TeleportInteraction::_returnToRemnantProperties' has a wrong offset!");
static_assert(offsetof(UK28TeleportInteraction, _triggerTeleportInputType) == 0x000930, "Member 'UK28TeleportInteraction::_triggerTeleportInputType' has a wrong offset!");
static_assert(offsetof(UK28TeleportInteraction, _chargingSpeedCurve) == 0x000938, "Member 'UK28TeleportInteraction::_chargingSpeedCurve' has a wrong offset!");
static_assert(offsetof(UK28TeleportInteraction, _chargedSpeedCurve) == 0x000940, "Member 'UK28TeleportInteraction::_chargedSpeedCurve' has a wrong offset!");
static_assert(offsetof(UK28TeleportInteraction, _cancelledSpeedCurve) == 0x000948, "Member 'UK28TeleportInteraction::_cancelledSpeedCurve' has a wrong offset!");
static_assert(offsetof(UK28TeleportInteraction, _releaseInputMaxTime) == 0x000950, "Member 'UK28TeleportInteraction::_releaseInputMaxTime' has a wrong offset!");
static_assert(offsetof(UK28TeleportInteraction, _minimumChargePercentageToConsiderTeleportButtonPress) == 0x000954, "Member 'UK28TeleportInteraction::_minimumChargePercentageToConsiderTeleportButtonPress' has a wrong offset!");

// Class TheK28.K28Utilities
// 0x0000 (0x0030 - 0x0030)
class UK28Utilities final : public UBlueprintFunctionLibrary
{
public:
	static class UK28DayNightComponent* GetDayNightComponent(const class UObject* WorldContextObject);
	static class AK28Power* GetK28Power(const class UObject* WorldContextObject);
	static class AK28Remnant* GetRemnant(const class UObject* WorldContextObject);
	static class AK28SecondaryCamera* GetSecondaryCamera(const class UObject* WorldContextObject);
	static class UK28TeleportationStrategyComponent* GetTeleportationStrategyComponent(const class UObject* WorldContextObject);
	static bool IsLockerUsedByKillerLocked(const class UObject* WorldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K28Utilities">();
	}
	static class UK28Utilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK28Utilities>();
	}
};
static_assert(alignof(UK28Utilities) == 0x000008, "Wrong alignment on UK28Utilities");
static_assert(sizeof(UK28Utilities) == 0x000030, "Wrong size on UK28Utilities");

}

