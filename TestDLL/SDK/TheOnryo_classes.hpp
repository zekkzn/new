#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: TheOnryo

#include "Basic.hpp"

#include "GameplayTags_structs.hpp"
#include "DeadByDaylight_structs.hpp"
#include "DeadByDaylight_classes.hpp"
#include "DBDCompetence_structs.hpp"
#include "DBDCompetence_classes.hpp"
#include "DataTableUtilities_structs.hpp"
#include "DBDInteraction_classes.hpp"
#include "TheOnryo_structs.hpp"
#include "StatSystem_structs.hpp"
#include "Engine_classes.hpp"
#include "SystemUtilities_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "QueryService_structs.hpp"
#include "Competence_classes.hpp"
#include "DBDAnimation_classes.hpp"
#include "DBDCosmetic_classes.hpp"


namespace SDK
{

// Class TheOnryo.Addon_K27Power_01
// 0x0000 (0x02E8 - 0x02E8)
class UAddon_K27Power_01 final : public UItemAddon
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Addon_K27Power_01">();
	}
	static class UAddon_K27Power_01* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAddon_K27Power_01>();
	}
};
static_assert(alignof(UAddon_K27Power_01) == 0x000008, "Wrong alignment on UAddon_K27Power_01");
static_assert(sizeof(UAddon_K27Power_01) == 0x0002E8, "Wrong size on UAddon_K27Power_01");

// Class TheOnryo.Addon_K27Power_09
// 0x0008 (0x02F0 - 0x02E8)
class UAddon_K27Power_09 final : public UItemAddon
{
public:
	TSubclassOf<class UStatusEffect>              _addonStatusEffect;                                // 0x02E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Addon_K27Power_09">();
	}
	static class UAddon_K27Power_09* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAddon_K27Power_09>();
	}
};
static_assert(alignof(UAddon_K27Power_09) == 0x000008, "Wrong alignment on UAddon_K27Power_09");
static_assert(sizeof(UAddon_K27Power_09) == 0x0002F0, "Wrong size on UAddon_K27Power_09");
static_assert(offsetof(UAddon_K27Power_09, _addonStatusEffect) == 0x0002E8, "Member 'UAddon_K27Power_09::_addonStatusEffect' has a wrong offset!");

// Class TheOnryo.Addon_K27Power_09StatusEffect
// 0x0018 (0x0398 - 0x0380)
class UAddon_K27Power_09StatusEffect final : public UStatusEffect
{
public:
	float                                         _condemnNeededForBlind;                            // 0x0380(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_384[0x4];                                      // 0x0384(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UStatusEffect*                          _blindnessEffect;                                  // 0x0388(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _blindnessStatusEffectClass;                       // 0x0390(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Authority_OnSurviorCondemnChange(class ACamperPlayer* Player, float CondemnLevel);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Addon_K27Power_09StatusEffect">();
	}
	static class UAddon_K27Power_09StatusEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAddon_K27Power_09StatusEffect>();
	}
};
static_assert(alignof(UAddon_K27Power_09StatusEffect) == 0x000008, "Wrong alignment on UAddon_K27Power_09StatusEffect");
static_assert(sizeof(UAddon_K27Power_09StatusEffect) == 0x000398, "Wrong size on UAddon_K27Power_09StatusEffect");
static_assert(offsetof(UAddon_K27Power_09StatusEffect, _condemnNeededForBlind) == 0x000380, "Member 'UAddon_K27Power_09StatusEffect::_condemnNeededForBlind' has a wrong offset!");
static_assert(offsetof(UAddon_K27Power_09StatusEffect, _blindnessEffect) == 0x000388, "Member 'UAddon_K27Power_09StatusEffect::_blindnessEffect' has a wrong offset!");
static_assert(offsetof(UAddon_K27Power_09StatusEffect, _blindnessStatusEffectClass) == 0x000390, "Member 'UAddon_K27Power_09StatusEffect::_blindnessStatusEffectClass' has a wrong offset!");

// Class TheOnryo.Addon_K27Power_16
// 0x0030 (0x0328 - 0x02F8)
class UAddon_K27Power_16 final : public UOnEventBaseAddon
{
public:
	float                                         _distanceOfSightFromSurvivorToKiller;              // 0x02F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _survivorScreamRevealDuration;                     // 0x02FC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UK27Addon_16_ScreamRevealComponent> _screamRevealComponentClass;                       // 0x0300(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<TWeakObjectPtr<class UK27Addon_16_ScreamRevealComponent>> _cachedScreamRevealComponents;                     // 0x0308(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_318[0x10];                                     // 0x0318(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Addon_K27Power_16">();
	}
	static class UAddon_K27Power_16* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAddon_K27Power_16>();
	}
};
static_assert(alignof(UAddon_K27Power_16) == 0x000008, "Wrong alignment on UAddon_K27Power_16");
static_assert(sizeof(UAddon_K27Power_16) == 0x000328, "Wrong size on UAddon_K27Power_16");
static_assert(offsetof(UAddon_K27Power_16, _distanceOfSightFromSurvivorToKiller) == 0x0002F8, "Member 'UAddon_K27Power_16::_distanceOfSightFromSurvivorToKiller' has a wrong offset!");
static_assert(offsetof(UAddon_K27Power_16, _survivorScreamRevealDuration) == 0x0002FC, "Member 'UAddon_K27Power_16::_survivorScreamRevealDuration' has a wrong offset!");
static_assert(offsetof(UAddon_K27Power_16, _screamRevealComponentClass) == 0x000300, "Member 'UAddon_K27Power_16::_screamRevealComponentClass' has a wrong offset!");
static_assert(offsetof(UAddon_K27Power_16, _cachedScreamRevealComponents) == 0x000308, "Member 'UAddon_K27Power_16::_cachedScreamRevealComponents' has a wrong offset!");

// Class TheOnryo.Addon_K27Power_17
// 0x0010 (0x0308 - 0x02F8)
class UAddon_K27Power_17 final : public UOnEventBaseAddon
{
public:
	TSubclassOf<class UStatusEffect>              _survivorImposedEffectClass;                       // 0x02F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _survivorInRangeDistance;                          // 0x0300(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _hinderedSeconds;                                  // 0x0304(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Addon_K27Power_17">();
	}
	static class UAddon_K27Power_17* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAddon_K27Power_17>();
	}
};
static_assert(alignof(UAddon_K27Power_17) == 0x000008, "Wrong alignment on UAddon_K27Power_17");
static_assert(sizeof(UAddon_K27Power_17) == 0x000308, "Wrong size on UAddon_K27Power_17");
static_assert(offsetof(UAddon_K27Power_17, _survivorImposedEffectClass) == 0x0002F8, "Member 'UAddon_K27Power_17::_survivorImposedEffectClass' has a wrong offset!");
static_assert(offsetof(UAddon_K27Power_17, _survivorInRangeDistance) == 0x000300, "Member 'UAddon_K27Power_17::_survivorInRangeDistance' has a wrong offset!");
static_assert(offsetof(UAddon_K27Power_17, _hinderedSeconds) == 0x000304, "Member 'UAddon_K27Power_17::_hinderedSeconds' has a wrong offset!");

// Class TheOnryo.Addon_K27Power_18
// 0x0078 (0x0360 - 0x02E8)
class UAddon_K27Power_18 final : public UItemAddon
{
public:
	TSubclassOf<class ACollectable>               _vhsCollectableBP;                                 // 0x02E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _revealTime;                                       // 0x02F0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2F4[0x4];                                      // 0x02F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UStatusEffect>              _revealAuraToKillerEffectClass;                    // 0x02F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<TWeakObjectPtr<class ADBDPlayer>, class UStatusEffect*> _revealAuraToKillerPerSurvivor;                    // 0x0300(0x0050)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_350[0x10];                                     // 0x0350(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnIntroCompleted();
	void Authority_OnSurvivorInsertVHS(const struct FGameplayTag& GameplayTag, const struct FGameEventData& GameEventData);
	void Authority_SpawnInVHSTape();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Addon_K27Power_18">();
	}
	static class UAddon_K27Power_18* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAddon_K27Power_18>();
	}
};
static_assert(alignof(UAddon_K27Power_18) == 0x000008, "Wrong alignment on UAddon_K27Power_18");
static_assert(sizeof(UAddon_K27Power_18) == 0x000360, "Wrong size on UAddon_K27Power_18");
static_assert(offsetof(UAddon_K27Power_18, _vhsCollectableBP) == 0x0002E8, "Member 'UAddon_K27Power_18::_vhsCollectableBP' has a wrong offset!");
static_assert(offsetof(UAddon_K27Power_18, _revealTime) == 0x0002F0, "Member 'UAddon_K27Power_18::_revealTime' has a wrong offset!");
static_assert(offsetof(UAddon_K27Power_18, _revealAuraToKillerEffectClass) == 0x0002F8, "Member 'UAddon_K27Power_18::_revealAuraToKillerEffectClass' has a wrong offset!");
static_assert(offsetof(UAddon_K27Power_18, _revealAuraToKillerPerSurvivor) == 0x000300, "Member 'UAddon_K27Power_18::_revealAuraToKillerPerSurvivor' has a wrong offset!");

// Class TheOnryo.Addon_K27Power_19
// 0x0020 (0x0318 - 0x02F8)
class UAddon_K27Power_19 final : public UOnEventBaseAddon
{
public:
	float                                         _distanceFromSurvivorToTVToRevealAura;             // 0x02F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _heightOffsetLowerBoundToRevealAura;               // 0x02FC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _heightOffsetUpperBoundToRevealAura;               // 0x0300(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _survivorAuraRevealDuration;                       // 0x0304(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _revealSurvivorsAroundPoweredTVs;                  // 0x0308(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _revealSurvivorsAroundTurnedOffTVs;                // 0x0309(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_30A[0x6];                                      // 0x030A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UStatusEffect>              _timedRevealToKillerEffect;                        // 0x0310(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Addon_K27Power_19">();
	}
	static class UAddon_K27Power_19* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAddon_K27Power_19>();
	}
};
static_assert(alignof(UAddon_K27Power_19) == 0x000008, "Wrong alignment on UAddon_K27Power_19");
static_assert(sizeof(UAddon_K27Power_19) == 0x000318, "Wrong size on UAddon_K27Power_19");
static_assert(offsetof(UAddon_K27Power_19, _distanceFromSurvivorToTVToRevealAura) == 0x0002F8, "Member 'UAddon_K27Power_19::_distanceFromSurvivorToTVToRevealAura' has a wrong offset!");
static_assert(offsetof(UAddon_K27Power_19, _heightOffsetLowerBoundToRevealAura) == 0x0002FC, "Member 'UAddon_K27Power_19::_heightOffsetLowerBoundToRevealAura' has a wrong offset!");
static_assert(offsetof(UAddon_K27Power_19, _heightOffsetUpperBoundToRevealAura) == 0x000300, "Member 'UAddon_K27Power_19::_heightOffsetUpperBoundToRevealAura' has a wrong offset!");
static_assert(offsetof(UAddon_K27Power_19, _survivorAuraRevealDuration) == 0x000304, "Member 'UAddon_K27Power_19::_survivorAuraRevealDuration' has a wrong offset!");
static_assert(offsetof(UAddon_K27Power_19, _revealSurvivorsAroundPoweredTVs) == 0x000308, "Member 'UAddon_K27Power_19::_revealSurvivorsAroundPoweredTVs' has a wrong offset!");
static_assert(offsetof(UAddon_K27Power_19, _revealSurvivorsAroundTurnedOffTVs) == 0x000309, "Member 'UAddon_K27Power_19::_revealSurvivorsAroundTurnedOffTVs' has a wrong offset!");
static_assert(offsetof(UAddon_K27Power_19, _timedRevealToKillerEffect) == 0x000310, "Member 'UAddon_K27Power_19::_timedRevealToKillerEffect' has a wrong offset!");

// Class TheOnryo.Addon_K27Power_20
// 0x0000 (0x02E8 - 0x02E8)
class UAddon_K27Power_20 final : public UItemAddon
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Addon_K27Power_20">();
	}
	static class UAddon_K27Power_20* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAddon_K27Power_20>();
	}
};
static_assert(alignof(UAddon_K27Power_20) == 0x000008, "Wrong alignment on UAddon_K27Power_20");
static_assert(sizeof(UAddon_K27Power_20) == 0x0002E8, "Wrong size on UAddon_K27Power_20");

// Class TheOnryo.BaseManifestInteraction
// 0x0010 (0x0930 - 0x0920)
#pragma pack(push, 0x1)
class alignas(0x10) UBaseManifestInteraction : public UBasicChargeableInteraction
{
public:
	class UManifestationComponent*                _manifestationComponent;                           // 0x0920(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Cosmetic_OnInteractionCancelled(class ADBDPlayer* Onryo);
	void Cosmetic_OnInteractionStarted(class ADBDPlayer* Onryo);
	void Cosmetic_OnInteractionSucceeded(class ADBDPlayer* Onryo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseManifestInteraction">();
	}
	static class UBaseManifestInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseManifestInteraction>();
	}
};
#pragma pack(pop)
static_assert(alignof(UBaseManifestInteraction) == 0x000010, "Wrong alignment on UBaseManifestInteraction");
static_assert(sizeof(UBaseManifestInteraction) == 0x000930, "Wrong size on UBaseManifestInteraction");
static_assert(offsetof(UBaseManifestInteraction, _manifestationComponent) == 0x000920, "Member 'UBaseManifestInteraction::_manifestationComponent' has a wrong offset!");

// Class TheOnryo.CondemnedComponent
// 0x0460 (0x0508 - 0x00A8)
class UCondemnedComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x68];                                      // 0x00A8(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTunableStat                           _condemnedRangeWhenTeleport;                       // 0x0110(0x0080)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_190[0x8];                                      // 0x0190(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _maxCondemnedLevel;                                // 0x0198(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _killerInstinctRevealDurationOnFullyCondemned;     // 0x01C0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _stacksOnTurnOffTV;                                // 0x01E8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _stacksOnRetrieveVHS;                              // 0x0210(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _stacksRemovedOnInsert;                            // 0x0238(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _stacksOnOnryoTeleport;                            // 0x0260(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _reducedAddonStacksOnOnryoTeleport;                // 0x0288(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _stacksOnPlayerHooked;                             // 0x02B0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _maxLockInStacksPerHook;                           // 0x02D8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _condemnedStackPerSecond;                          // 0x0300(0x0080)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_380[0x8];                                      // 0x0380(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameplayTag>                   _analyticScoreTag;                                 // 0x0388(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	float                                         _condemnedLevel;                                   // 0x0398(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _lockedCondemnedLevel;                             // 0x039C(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ECondemnOrigin                                _previousReasonForCondemn;                         // 0x03A0(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isHoldingVHS;                                     // 0x03A1(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3A2[0x3E];                                     // 0x03A2(0x003E)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UStatusEffect>              _condemnKillerInstinctEffectClass;                 // 0x03E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStatusEffect*                          _condemnKillerInstinctEffect;                      // 0x03E8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3F0[0x10];                                     // 0x03F0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameplayTag>                   _reactivateCondemnProgressEvents;                  // 0x0400(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_410[0x38];                                     // 0x0410(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _rangeToStopCondemnProgressAfterChase;             // 0x0448(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _timeAwayFromKillerToResumeCondemn;                // 0x0470(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_498[0x70];                                     // 0x0498(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DBD_SetCondemnedLevel(const float Level);
	void DBD_SetCondemnMoriableAndDownAllSurvivors();
	void OnLevelReadyToPlay();
	void OnRep_CondemnedLevel(const float PreviousValue);
	void OnRep_HoldingVHS();

	float GetCondemnedLevel() const;
	float GetCondemnedPercent() const;
	float GetLockedCondemnedPercent() const;
	bool IsCondemned() const;
	bool IsFullyCondemned() const;
	bool IsHoldingVHS() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CondemnedComponent">();
	}
	static class UCondemnedComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCondemnedComponent>();
	}
};
static_assert(alignof(UCondemnedComponent) == 0x000008, "Wrong alignment on UCondemnedComponent");
static_assert(sizeof(UCondemnedComponent) == 0x000508, "Wrong size on UCondemnedComponent");
static_assert(offsetof(UCondemnedComponent, _condemnedRangeWhenTeleport) == 0x000110, "Member 'UCondemnedComponent::_condemnedRangeWhenTeleport' has a wrong offset!");
static_assert(offsetof(UCondemnedComponent, _maxCondemnedLevel) == 0x000198, "Member 'UCondemnedComponent::_maxCondemnedLevel' has a wrong offset!");
static_assert(offsetof(UCondemnedComponent, _killerInstinctRevealDurationOnFullyCondemned) == 0x0001C0, "Member 'UCondemnedComponent::_killerInstinctRevealDurationOnFullyCondemned' has a wrong offset!");
static_assert(offsetof(UCondemnedComponent, _stacksOnTurnOffTV) == 0x0001E8, "Member 'UCondemnedComponent::_stacksOnTurnOffTV' has a wrong offset!");
static_assert(offsetof(UCondemnedComponent, _stacksOnRetrieveVHS) == 0x000210, "Member 'UCondemnedComponent::_stacksOnRetrieveVHS' has a wrong offset!");
static_assert(offsetof(UCondemnedComponent, _stacksRemovedOnInsert) == 0x000238, "Member 'UCondemnedComponent::_stacksRemovedOnInsert' has a wrong offset!");
static_assert(offsetof(UCondemnedComponent, _stacksOnOnryoTeleport) == 0x000260, "Member 'UCondemnedComponent::_stacksOnOnryoTeleport' has a wrong offset!");
static_assert(offsetof(UCondemnedComponent, _reducedAddonStacksOnOnryoTeleport) == 0x000288, "Member 'UCondemnedComponent::_reducedAddonStacksOnOnryoTeleport' has a wrong offset!");
static_assert(offsetof(UCondemnedComponent, _stacksOnPlayerHooked) == 0x0002B0, "Member 'UCondemnedComponent::_stacksOnPlayerHooked' has a wrong offset!");
static_assert(offsetof(UCondemnedComponent, _maxLockInStacksPerHook) == 0x0002D8, "Member 'UCondemnedComponent::_maxLockInStacksPerHook' has a wrong offset!");
static_assert(offsetof(UCondemnedComponent, _condemnedStackPerSecond) == 0x000300, "Member 'UCondemnedComponent::_condemnedStackPerSecond' has a wrong offset!");
static_assert(offsetof(UCondemnedComponent, _analyticScoreTag) == 0x000388, "Member 'UCondemnedComponent::_analyticScoreTag' has a wrong offset!");
static_assert(offsetof(UCondemnedComponent, _condemnedLevel) == 0x000398, "Member 'UCondemnedComponent::_condemnedLevel' has a wrong offset!");
static_assert(offsetof(UCondemnedComponent, _lockedCondemnedLevel) == 0x00039C, "Member 'UCondemnedComponent::_lockedCondemnedLevel' has a wrong offset!");
static_assert(offsetof(UCondemnedComponent, _previousReasonForCondemn) == 0x0003A0, "Member 'UCondemnedComponent::_previousReasonForCondemn' has a wrong offset!");
static_assert(offsetof(UCondemnedComponent, _isHoldingVHS) == 0x0003A1, "Member 'UCondemnedComponent::_isHoldingVHS' has a wrong offset!");
static_assert(offsetof(UCondemnedComponent, _condemnKillerInstinctEffectClass) == 0x0003E0, "Member 'UCondemnedComponent::_condemnKillerInstinctEffectClass' has a wrong offset!");
static_assert(offsetof(UCondemnedComponent, _condemnKillerInstinctEffect) == 0x0003E8, "Member 'UCondemnedComponent::_condemnKillerInstinctEffect' has a wrong offset!");
static_assert(offsetof(UCondemnedComponent, _reactivateCondemnProgressEvents) == 0x000400, "Member 'UCondemnedComponent::_reactivateCondemnProgressEvents' has a wrong offset!");
static_assert(offsetof(UCondemnedComponent, _rangeToStopCondemnProgressAfterChase) == 0x000448, "Member 'UCondemnedComponent::_rangeToStopCondemnProgressAfterChase' has a wrong offset!");
static_assert(offsetof(UCondemnedComponent, _timeAwayFromKillerToResumeCondemn) == 0x000470, "Member 'UCondemnedComponent::_timeAwayFromKillerToResumeCondemn' has a wrong offset!");

// Class TheOnryo.CondemnMoriInteraction
// 0x0000 (0x09D0 - 0x09D0)
class UCondemnMoriInteraction final : public UKillInteractionDefinition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CondemnMoriInteraction">();
	}
	static class UCondemnMoriInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCondemnMoriInteraction>();
	}
};
static_assert(alignof(UCondemnMoriInteraction) == 0x000010, "Wrong alignment on UCondemnMoriInteraction");
static_assert(sizeof(UCondemnMoriInteraction) == 0x0009D0, "Wrong size on UCondemnMoriInteraction");

// Class TheOnryo.SurvivorTelevisionInteraction
// 0x0000 (0x0920 - 0x0920)
class USurvivorTelevisionInteraction : public UBasicChargeableInteraction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SurvivorTelevisionInteraction">();
	}
	static class USurvivorTelevisionInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<USurvivorTelevisionInteraction>();
	}
};
static_assert(alignof(USurvivorTelevisionInteraction) == 0x000010, "Wrong alignment on USurvivorTelevisionInteraction");
static_assert(sizeof(USurvivorTelevisionInteraction) == 0x000920, "Wrong size on USurvivorTelevisionInteraction");

// Class TheOnryo.InsertVHS
// 0x0000 (0x0920 - 0x0920)
class UInsertVHS final : public USurvivorTelevisionInteraction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InsertVHS">();
	}
	static class UInsertVHS* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInsertVHS>();
	}
};
static_assert(alignof(UInsertVHS) == 0x000010, "Wrong alignment on UInsertVHS");
static_assert(sizeof(UInsertVHS) == 0x000920, "Wrong size on UInsertVHS");

// Class TheOnryo.K27Addon_16_ScreamRevealComponent
// 0x0060 (0x0108 - 0x00A8)
class UK27Addon_16_ScreamRevealComponent final : public UActorComponent
{
public:
	bool                                          _authorityHasRequestedSurvivorScreamConfirmation;  // 0x00A8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A9[0x3];                                       // 0x00A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _screamDuration;                                   // 0x00AC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _revealAuraToKillerEffectClass;                    // 0x00B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<TWeakObjectPtr<class ACamperPlayer>, class UStatusEffect*> _revealAuraToKillerPerSurvivor;                    // 0x00B8(0x0050)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	void BP_RevealAndMakeSurvivorScream(class ADBDPlayer* SurvivorPlayer, const float ScreamRevealDuration);
	void Client_QueryIsKillerInSurvivorView();
	void Multicast_RevealAndMakeSurvivorScream(const float ScreamRevealDuration);
	void Server_ConfirmKillerIsInViewValidation(bool IsKillerInView);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K27Addon_16_ScreamRevealComponent">();
	}
	static class UK27Addon_16_ScreamRevealComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK27Addon_16_ScreamRevealComponent>();
	}
};
static_assert(alignof(UK27Addon_16_ScreamRevealComponent) == 0x000008, "Wrong alignment on UK27Addon_16_ScreamRevealComponent");
static_assert(sizeof(UK27Addon_16_ScreamRevealComponent) == 0x000108, "Wrong size on UK27Addon_16_ScreamRevealComponent");
static_assert(offsetof(UK27Addon_16_ScreamRevealComponent, _authorityHasRequestedSurvivorScreamConfirmation) == 0x0000A8, "Member 'UK27Addon_16_ScreamRevealComponent::_authorityHasRequestedSurvivorScreamConfirmation' has a wrong offset!");
static_assert(offsetof(UK27Addon_16_ScreamRevealComponent, _screamDuration) == 0x0000AC, "Member 'UK27Addon_16_ScreamRevealComponent::_screamDuration' has a wrong offset!");
static_assert(offsetof(UK27Addon_16_ScreamRevealComponent, _revealAuraToKillerEffectClass) == 0x0000B0, "Member 'UK27Addon_16_ScreamRevealComponent::_revealAuraToKillerEffectClass' has a wrong offset!");
static_assert(offsetof(UK27Addon_16_ScreamRevealComponent, _revealAuraToKillerPerSurvivor) == 0x0000B8, "Member 'UK27Addon_16_ScreamRevealComponent::_revealAuraToKillerPerSurvivor' has a wrong offset!");

// Class TheOnryo.K27P01
// 0x0028 (0x0448 - 0x0420)
class UK27P01 final : public UPerk
{
public:
	uint8                                         Pad_420[0x10];                                     // 0x0420(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _survivorAuraRevealDuration[0x3];                  // 0x0430(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_43C[0x4];                                      // 0x043C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UStatusEffect>              _timedRevealToKillerEffectClass;                   // 0x0440(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Authority_OnSurvivorUnhookedOffScourgeHook(const struct FGameEventData& GameEventData);

	const float GetAuraRevealDuration() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K27P01">();
	}
	static class UK27P01* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK27P01>();
	}
};
static_assert(alignof(UK27P01) == 0x000008, "Wrong alignment on UK27P01");
static_assert(sizeof(UK27P01) == 0x000448, "Wrong size on UK27P01");
static_assert(offsetof(UK27P01, _survivorAuraRevealDuration) == 0x000430, "Member 'UK27P01::_survivorAuraRevealDuration' has a wrong offset!");
static_assert(offsetof(UK27P01, _timedRevealToKillerEffectClass) == 0x000440, "Member 'UK27P01::_timedRevealToKillerEffectClass' has a wrong offset!");

// Class TheOnryo.K27P02
// 0x00B8 (0x04D8 - 0x0420)
class UK27P02 final : public UPerk
{
public:
	float                                         _activePerkDuration[0x3];                          // 0x0420(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _regressionModifier[0x3];                          // 0x042C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class AGenerator*, struct FFastTimer>    _authority_affectedGeneratorsAndActiveTimers;      // 0x0438(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMap<class AGenerator*, uint64>               _gameplayModifierHandles;                          // 0x0488(0x0050)(Transient, NativeAccessSpecifierPrivate)

public:
	void Cosmetic_ShowBubbleNotification(const class AGenerator* TriggeringGenerator);
	void Multicast_AddGeneratorAura(class AGenerator* Generator);
	void Multicast_ShowBubbleNotification(class AGenerator* TriggeringGenerator);

	float GetActivationTimeAtLevel() const;
	float GetRegressionModifierAtLevel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K27P02">();
	}
	static class UK27P02* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK27P02>();
	}
};
static_assert(alignof(UK27P02) == 0x000008, "Wrong alignment on UK27P02");
static_assert(sizeof(UK27P02) == 0x0004D8, "Wrong size on UK27P02");
static_assert(offsetof(UK27P02, _activePerkDuration) == 0x000420, "Member 'UK27P02::_activePerkDuration' has a wrong offset!");
static_assert(offsetof(UK27P02, _regressionModifier) == 0x00042C, "Member 'UK27P02::_regressionModifier' has a wrong offset!");
static_assert(offsetof(UK27P02, _authority_affectedGeneratorsAndActiveTimers) == 0x000438, "Member 'UK27P02::_authority_affectedGeneratorsAndActiveTimers' has a wrong offset!");
static_assert(offsetof(UK27P02, _gameplayModifierHandles) == 0x000488, "Member 'UK27P02::_gameplayModifierHandles' has a wrong offset!");

// Class TheOnryo.K27P03
// 0x00C8 (0x04E8 - 0x0420)
class UK27P03 final : public UPerk
{
public:
	struct FLinearColor                           _generatorBlockedAuraColorForKiller;               // 0x0420(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _generatorProgressionActivation[0x3];              // 0x0430(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _generatorBlockedDuration[0x3];                    // 0x043C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<TWeakObjectPtr<class AGenerator>, struct FFastTimer> _authority_blockedGeneratorsAndTimeToUnblock;      // 0x0448(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMap<TWeakObjectPtr<class ACamperPlayer>, TWeakObjectPtr<class AGenerator>> _authority_affectedRepairersAndTheirGenerators;    // 0x0498(0x0050)(Transient, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	void Multicast_ActivateSkillCheck(class ACamperPlayer* Survivor);
	void Multicast_HighlightBlockedGeneratorForKiller(class AGenerator* Generator);

	float GetGeneratorBlockedDurationAtLevel() const;
	float GetGeneratorProgressionActivationAtLevel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K27P03">();
	}
	static class UK27P03* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK27P03>();
	}
};
static_assert(alignof(UK27P03) == 0x000008, "Wrong alignment on UK27P03");
static_assert(sizeof(UK27P03) == 0x0004E8, "Wrong size on UK27P03");
static_assert(offsetof(UK27P03, _generatorBlockedAuraColorForKiller) == 0x000420, "Member 'UK27P03::_generatorBlockedAuraColorForKiller' has a wrong offset!");
static_assert(offsetof(UK27P03, _generatorProgressionActivation) == 0x000430, "Member 'UK27P03::_generatorProgressionActivation' has a wrong offset!");
static_assert(offsetof(UK27P03, _generatorBlockedDuration) == 0x00043C, "Member 'UK27P03::_generatorBlockedDuration' has a wrong offset!");
static_assert(offsetof(UK27P03, _authority_blockedGeneratorsAndTimeToUnblock) == 0x000448, "Member 'UK27P03::_authority_blockedGeneratorsAndTimeToUnblock' has a wrong offset!");
static_assert(offsetof(UK27P03, _authority_affectedRepairersAndTheirGenerators) == 0x000498, "Member 'UK27P03::_authority_affectedRepairersAndTheirGenerators' has a wrong offset!");

// Class TheOnryo.ManifestationComponent
// 0x0418 (0x04C0 - 0x00A8)
class UManifestationComponent final : public UActorComponent
{
public:
	TSubclassOf<class UStatusEffect>              _unmanifestedUndetectableStatusEffectClass;        // 0x00A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTunableStat                           _lingeringFlickerDuration;                         // 0x00B0(0x0080)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _maxTrackedTimeSinceManifest;                      // 0x0130(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _manifestInteractionUndetectableLingerTime;        // 0x0158(0x0080)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _teleportManifestUndetectableLingeringDuration;    // 0x01D8(0x0080)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _lingeringUndetectableDurationFromOtherSources;    // 0x0258(0x0080)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FStatProperty                          _scorePercent;                                     // 0x02D8(0x0088)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_360[0x28];                                     // 0x0360(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class UOnryoVisibilityComponent*              _onryoVisibilityComponent;                         // 0x0388(0x0008)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UOnryoVisibilityComponent>  _onryoVisibilityComponentClass;                    // 0x0390(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isManifested;                                     // 0x0398(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_399[0x3];                                      // 0x0399(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _lingeringUndetectableEndTimeStamp;                // 0x039C(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3A0[0xC8];                                     // 0x03A0(0x00C8)(Fixing Size After Last Property [ Dumper-7 ])
	class UStatusEffect*                          _unmanifestStatusEffect;                           // 0x0468(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_470[0x50];                                     // 0x0470(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_AttemptToPalletStunDemanifestedKiller(const struct FGameplayTag& GameplayTag, const struct FGameEventData& GameEventData);
	void Authority_OnMoriStarted();
	void Multicast_AttemptToPalletStunDemanifestedKiller();
	void Multicast_OnManifestationChanged(const bool IsManifested, const bool IsImmediateManifest);
	void Multicast_OnManifestationTransitionComplete();
	void OnLevelReadyToPlay();
	void OnLingeringUndetectableTimerCompleted();
	void OnRep_IsManifested();
	void OnRep_LingeringUndetectableEndTimeStamp();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ManifestationComponent">();
	}
	static class UManifestationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UManifestationComponent>();
	}
};
static_assert(alignof(UManifestationComponent) == 0x000008, "Wrong alignment on UManifestationComponent");
static_assert(sizeof(UManifestationComponent) == 0x0004C0, "Wrong size on UManifestationComponent");
static_assert(offsetof(UManifestationComponent, _unmanifestedUndetectableStatusEffectClass) == 0x0000A8, "Member 'UManifestationComponent::_unmanifestedUndetectableStatusEffectClass' has a wrong offset!");
static_assert(offsetof(UManifestationComponent, _lingeringFlickerDuration) == 0x0000B0, "Member 'UManifestationComponent::_lingeringFlickerDuration' has a wrong offset!");
static_assert(offsetof(UManifestationComponent, _maxTrackedTimeSinceManifest) == 0x000130, "Member 'UManifestationComponent::_maxTrackedTimeSinceManifest' has a wrong offset!");
static_assert(offsetof(UManifestationComponent, _manifestInteractionUndetectableLingerTime) == 0x000158, "Member 'UManifestationComponent::_manifestInteractionUndetectableLingerTime' has a wrong offset!");
static_assert(offsetof(UManifestationComponent, _teleportManifestUndetectableLingeringDuration) == 0x0001D8, "Member 'UManifestationComponent::_teleportManifestUndetectableLingeringDuration' has a wrong offset!");
static_assert(offsetof(UManifestationComponent, _lingeringUndetectableDurationFromOtherSources) == 0x000258, "Member 'UManifestationComponent::_lingeringUndetectableDurationFromOtherSources' has a wrong offset!");
static_assert(offsetof(UManifestationComponent, _scorePercent) == 0x0002D8, "Member 'UManifestationComponent::_scorePercent' has a wrong offset!");
static_assert(offsetof(UManifestationComponent, _onryoVisibilityComponent) == 0x000388, "Member 'UManifestationComponent::_onryoVisibilityComponent' has a wrong offset!");
static_assert(offsetof(UManifestationComponent, _onryoVisibilityComponentClass) == 0x000390, "Member 'UManifestationComponent::_onryoVisibilityComponentClass' has a wrong offset!");
static_assert(offsetof(UManifestationComponent, _isManifested) == 0x000398, "Member 'UManifestationComponent::_isManifested' has a wrong offset!");
static_assert(offsetof(UManifestationComponent, _lingeringUndetectableEndTimeStamp) == 0x00039C, "Member 'UManifestationComponent::_lingeringUndetectableEndTimeStamp' has a wrong offset!");
static_assert(offsetof(UManifestationComponent, _unmanifestStatusEffect) == 0x000468, "Member 'UManifestationComponent::_unmanifestStatusEffect' has a wrong offset!");

// Class TheOnryo.ManifestInteraction
// 0x0010 (0x0940 - 0x0930)
class UManifestInteraction final : public UBaseManifestInteraction
{
public:
	class UCurveFloat*                            _postManifestSpeedCurve;                           // 0x0928(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _postManifestSpeedCurveDuration;                   // 0x0930(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_934[0xC];                                      // 0x0934(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ManifestInteraction">();
	}
	static class UManifestInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UManifestInteraction>();
	}
};
static_assert(alignof(UManifestInteraction) == 0x000010, "Wrong alignment on UManifestInteraction");
static_assert(sizeof(UManifestInteraction) == 0x000940, "Wrong size on UManifestInteraction");
static_assert(offsetof(UManifestInteraction, _postManifestSpeedCurve) == 0x000928, "Member 'UManifestInteraction::_postManifestSpeedCurve' has a wrong offset!");
static_assert(offsetof(UManifestInteraction, _postManifestSpeedCurveDuration) == 0x000930, "Member 'UManifestInteraction::_postManifestSpeedCurveDuration' has a wrong offset!");

// Class TheOnryo.NearPoweredTelevisionWithLingerTime
// 0x0098 (0x0178 - 0x00E0)
class UNearPoweredTelevisionWithLingerTime final : public UEventDrivenModifierCondition
{
public:
	float                                         _distanceFromTelevision;                           // 0x00E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _lingerDuration;                                   // 0x00E4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FActorPairQueryHeightRange             _heightRange;                                      // 0x00E8(0x0008)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F0[0x88];                                      // 0x00F0(0x0088)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnLevelReadyToPlay();

	float GetPercentRemainingDuration() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NearPoweredTelevisionWithLingerTime">();
	}
	static class UNearPoweredTelevisionWithLingerTime* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNearPoweredTelevisionWithLingerTime>();
	}
};
static_assert(alignof(UNearPoweredTelevisionWithLingerTime) == 0x000008, "Wrong alignment on UNearPoweredTelevisionWithLingerTime");
static_assert(sizeof(UNearPoweredTelevisionWithLingerTime) == 0x000178, "Wrong size on UNearPoweredTelevisionWithLingerTime");
static_assert(offsetof(UNearPoweredTelevisionWithLingerTime, _distanceFromTelevision) == 0x0000E0, "Member 'UNearPoweredTelevisionWithLingerTime::_distanceFromTelevision' has a wrong offset!");
static_assert(offsetof(UNearPoweredTelevisionWithLingerTime, _lingerDuration) == 0x0000E4, "Member 'UNearPoweredTelevisionWithLingerTime::_lingerDuration' has a wrong offset!");
static_assert(offsetof(UNearPoweredTelevisionWithLingerTime, _heightRange) == 0x0000E8, "Member 'UNearPoweredTelevisionWithLingerTime::_heightRange' has a wrong offset!");

// Class TheOnryo.OnryoAfterImageComponent
// 0x0140 (0x01E8 - 0x00A8)
class UOnryoAfterImageComponent final : public UActorComponent
{
public:
	bool                                          _isAllowedToSpawnImages;                           // 0x00A8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A9[0x128];                                     // 0x00A9(0x0128)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _hideAfterImageDuringInteractions;                 // 0x01D1(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1D2[0x16];                                     // 0x01D2(0x0016)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetAllowedToSpawnImages(bool CanSpawnImages);
	void ShouldShowAfterImageChanged(bool ShouldBeVisible);

	class ASlasherPlayer* GetKiller() const;
	bool IsAttacking() const;
	bool IsInteracting() const;
	bool IsOnryoInvisible() const;
	bool ShouldShowAfterImage() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnryoAfterImageComponent">();
	}
	static class UOnryoAfterImageComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOnryoAfterImageComponent>();
	}
};
static_assert(alignof(UOnryoAfterImageComponent) == 0x000008, "Wrong alignment on UOnryoAfterImageComponent");
static_assert(sizeof(UOnryoAfterImageComponent) == 0x0001E8, "Wrong size on UOnryoAfterImageComponent");
static_assert(offsetof(UOnryoAfterImageComponent, _isAllowedToSpawnImages) == 0x0000A8, "Member 'UOnryoAfterImageComponent::_isAllowedToSpawnImages' has a wrong offset!");
static_assert(offsetof(UOnryoAfterImageComponent, _hideAfterImageDuringInteractions) == 0x0001D1, "Member 'UOnryoAfterImageComponent::_hideAfterImageDuringInteractions' has a wrong offset!");

// Class TheOnryo.OnryoAnimInstance
// 0x0030 (0x0750 - 0x0720)
class UOnryoAnimInstance final : public UKillerAnimInstance
{
public:
	bool                                          _isTeleporting;                                    // 0x0720(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isStartingUpTeleport;                             // 0x0721(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_722[0x2];                                      // 0x0722(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _teleportStartUpDuration;                          // 0x0724(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isCrawlingOutOfTV;                                // 0x0728(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_729[0x3];                                      // 0x0729(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _crawlingOutDuration;                              // 0x072C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isTeleportCancelled;                              // 0x0730(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_731[0x3];                                      // 0x0731(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _teleportCancelledDuration;                        // 0x0734(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isEnteringManifest;                               // 0x0738(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isExitingManifest;                                // 0x0739(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isInOtherWorld;                                   // 0x073A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_73B[0x15];                                     // 0x073B(0x0015)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnryoAnimInstance">();
	}
	static class UOnryoAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOnryoAnimInstance>();
	}
};
static_assert(alignof(UOnryoAnimInstance) == 0x000010, "Wrong alignment on UOnryoAnimInstance");
static_assert(sizeof(UOnryoAnimInstance) == 0x000750, "Wrong size on UOnryoAnimInstance");
static_assert(offsetof(UOnryoAnimInstance, _isTeleporting) == 0x000720, "Member 'UOnryoAnimInstance::_isTeleporting' has a wrong offset!");
static_assert(offsetof(UOnryoAnimInstance, _isStartingUpTeleport) == 0x000721, "Member 'UOnryoAnimInstance::_isStartingUpTeleport' has a wrong offset!");
static_assert(offsetof(UOnryoAnimInstance, _teleportStartUpDuration) == 0x000724, "Member 'UOnryoAnimInstance::_teleportStartUpDuration' has a wrong offset!");
static_assert(offsetof(UOnryoAnimInstance, _isCrawlingOutOfTV) == 0x000728, "Member 'UOnryoAnimInstance::_isCrawlingOutOfTV' has a wrong offset!");
static_assert(offsetof(UOnryoAnimInstance, _crawlingOutDuration) == 0x00072C, "Member 'UOnryoAnimInstance::_crawlingOutDuration' has a wrong offset!");
static_assert(offsetof(UOnryoAnimInstance, _isTeleportCancelled) == 0x000730, "Member 'UOnryoAnimInstance::_isTeleportCancelled' has a wrong offset!");
static_assert(offsetof(UOnryoAnimInstance, _teleportCancelledDuration) == 0x000734, "Member 'UOnryoAnimInstance::_teleportCancelledDuration' has a wrong offset!");
static_assert(offsetof(UOnryoAnimInstance, _isEnteringManifest) == 0x000738, "Member 'UOnryoAnimInstance::_isEnteringManifest' has a wrong offset!");
static_assert(offsetof(UOnryoAnimInstance, _isExitingManifest) == 0x000739, "Member 'UOnryoAnimInstance::_isExitingManifest' has a wrong offset!");
static_assert(offsetof(UOnryoAnimInstance, _isInOtherWorld) == 0x00073A, "Member 'UOnryoAnimInstance::_isInOtherWorld' has a wrong offset!");

// Class TheOnryo.OnryoFXInterface
// 0x0000 (0x0030 - 0x0030)
class IOnryoFXInterface final : public IInterface
{
public:
	void Cosmetic_OnChargeManifestCancelled();
	void Cosmetic_OnChargeManifestStart();
	void Cosmetic_OnChargeManifestSuccess();
	void Cosmetic_OnChargeUnmanifestCancelled();
	void Cosmetic_OnChargeUnmanifestStart();
	void Cosmetic_OnChargeUnmanifestSuccess();
	void Cosmetic_OnFailedAttemptPalletStun();
	void Cosmetic_OnKillerVisibilityChanged(bool IsVisible, bool IsFlickering, bool IsManifested, bool IsInvisibleDueToOutOfVisibiltyRange, bool Force);
	void Cosmetic_OnManifestStateChanged(bool IsManifested, const bool IsImmediateManifest);
	void Cosmetic_OnTeleportCancelled();
	void Cosmetic_OnTeleportFinished();
	void Cosmetic_OnTeleportStart();
	void Cosmetic_OnTeleportSuccess();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnryoFXInterface">();
	}
	static class IOnryoFXInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IOnryoFXInterface>();
	}
};
static_assert(alignof(IOnryoFXInterface) == 0x000008, "Wrong alignment on IOnryoFXInterface");
static_assert(sizeof(IOnryoFXInterface) == 0x000030, "Wrong size on IOnryoFXInterface");

// Class TheOnryo.OnryoPower
// 0x0110 (0x0660 - 0x0550)
class AOnryoPower final : public ACollectable
{
public:
	uint8                                         Pad_550[0x10];                                     // 0x0550(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UCondemnedComponent>        _condemnedComponentClass;                          // 0x0560(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UManifestationComponent>    _manifestationComponentClass;                      // 0x0568(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FStatusEffectSpawnData>         _effects;                                          // 0x0570(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _teleportCooldownTime;                             // 0x0580(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FPlayerStatusEffectSpawnerHelper       _effectSpawner;                                    // 0x05A8(0x0050)(Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5F8[0x38];                                     // 0x05F8(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	class UOnryoTeleportTargeterComponent*        _televisionTargeter;                               // 0x0630(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UManifestationComponent*                _manifestationComponent;                           // 0x0638(0x0008)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class AOnryoTelevision*>               _televisions;                                      // 0x0640(0x0010)(Net, ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TSubclassOf<class AOnryoTelevision>           _televisionClass;                                  // 0x0650(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInteractionDefinition*                 _onryoPowerCooldownInteraction;                    // 0x0658(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void PowerCooldownEnd_Cosmetic();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnryoPower">();
	}
	static class AOnryoPower* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOnryoPower>();
	}
};
static_assert(alignof(AOnryoPower) == 0x000008, "Wrong alignment on AOnryoPower");
static_assert(sizeof(AOnryoPower) == 0x000660, "Wrong size on AOnryoPower");
static_assert(offsetof(AOnryoPower, _condemnedComponentClass) == 0x000560, "Member 'AOnryoPower::_condemnedComponentClass' has a wrong offset!");
static_assert(offsetof(AOnryoPower, _manifestationComponentClass) == 0x000568, "Member 'AOnryoPower::_manifestationComponentClass' has a wrong offset!");
static_assert(offsetof(AOnryoPower, _effects) == 0x000570, "Member 'AOnryoPower::_effects' has a wrong offset!");
static_assert(offsetof(AOnryoPower, _teleportCooldownTime) == 0x000580, "Member 'AOnryoPower::_teleportCooldownTime' has a wrong offset!");
static_assert(offsetof(AOnryoPower, _effectSpawner) == 0x0005A8, "Member 'AOnryoPower::_effectSpawner' has a wrong offset!");
static_assert(offsetof(AOnryoPower, _televisionTargeter) == 0x000630, "Member 'AOnryoPower::_televisionTargeter' has a wrong offset!");
static_assert(offsetof(AOnryoPower, _manifestationComponent) == 0x000638, "Member 'AOnryoPower::_manifestationComponent' has a wrong offset!");
static_assert(offsetof(AOnryoPower, _televisions) == 0x000640, "Member 'AOnryoPower::_televisions' has a wrong offset!");
static_assert(offsetof(AOnryoPower, _televisionClass) == 0x000650, "Member 'AOnryoPower::_televisionClass' has a wrong offset!");
static_assert(offsetof(AOnryoPower, _onryoPowerCooldownInteraction) == 0x000658, "Member 'AOnryoPower::_onryoPowerCooldownInteraction' has a wrong offset!");

// Class TheOnryo.OnryoPowerPresentationComponent
// 0x0018 (0x00C8 - 0x00B0)
class UOnryoPowerPresentationComponent final : public UPresentationItemProgressComponent
{
public:
	class UOnryoTVInitialCooldownStateComponent*  _cooldownState;                                    // 0x00B0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B8[0x10];                                      // 0x00B8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnryoPowerPresentationComponent">();
	}
	static class UOnryoPowerPresentationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOnryoPowerPresentationComponent>();
	}
};
static_assert(alignof(UOnryoPowerPresentationComponent) == 0x000008, "Wrong alignment on UOnryoPowerPresentationComponent");
static_assert(sizeof(UOnryoPowerPresentationComponent) == 0x0000C8, "Wrong size on UOnryoPowerPresentationComponent");
static_assert(offsetof(UOnryoPowerPresentationComponent, _cooldownState) == 0x0000B0, "Member 'UOnryoPowerPresentationComponent::_cooldownState' has a wrong offset!");

// Class TheOnryo.OnryoSurvivorCosmeticHelperActor
// 0x0070 (0x0378 - 0x0308)
class AOnryoSurvivorCosmeticHelperActor final : public ASurvivorCosmeticHelperActor
{
public:
	class UCondemnedComponent*                    _condemnedComponent;                               // 0x0308(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_310[0x68];                                     // 0x0310(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_OnCarryEnd(class ACamperPlayer* Camper);
	void Cosmetic_OnCarryStart(class ACamperPlayer* Camper);
	void Cosmetic_OnDamageStateChanged(ECamperDamageState OldDamageState, ECamperDamageState NewDamageState);
	void Cosmetic_OnGainCondemnStack(class ACamperPlayer* Camper, float CurrentStacks);
	void Cosmetic_OnHookedChanged();
	void Cosmetic_OnLightingSet(class ABaseSky* Lighting);
	void Cosmetic_OnLoseCondemnStack(class ACamperPlayer* Camper, float CurrentStacks);
	void Cosmetic_OnLoseTape(class ACamperPlayer* Camper);
	void Cosmetic_OnReceiveTape(class ACamperPlayer* Camper);
	void OnSurvivorDisguisedOrUndisguised(bool IsDisguised);

	class UCondemnedComponent* GetCondemnedComponent() const;
	class UGameplayTagContainerComponent* GetObjectState() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnryoSurvivorCosmeticHelperActor">();
	}
	static class AOnryoSurvivorCosmeticHelperActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOnryoSurvivorCosmeticHelperActor>();
	}
};
static_assert(alignof(AOnryoSurvivorCosmeticHelperActor) == 0x000008, "Wrong alignment on AOnryoSurvivorCosmeticHelperActor");
static_assert(sizeof(AOnryoSurvivorCosmeticHelperActor) == 0x000378, "Wrong size on AOnryoSurvivorCosmeticHelperActor");
static_assert(offsetof(AOnryoSurvivorCosmeticHelperActor, _condemnedComponent) == 0x000308, "Member 'AOnryoSurvivorCosmeticHelperActor::_condemnedComponent' has a wrong offset!");

// Class TheOnryo.OnryoTeleportInteraction
// 0x0180 (0x0AA0 - 0x0920)
class UOnryoTeleportInteraction final : public UBasicChargeableInteraction
{
public:
	class ASlasherPlayer*                         _cachedOwningKiller;                               // 0x0920(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AOnryoTelevision*                       _currentTargetTelevision;                          // 0x0928(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AOnryoTelevision*                       _televisionTeleportingTo;                          // 0x0930(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_938[0x8];                                      // 0x0938(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _teleportExitAnimDuration;                         // 0x0940(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _teleportCancelledAnimDuration;                    // 0x0968(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _postTeleportSpeedDuration;                        // 0x0990(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _postTeleportSpeedCurve;                           // 0x09B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FStatProperty                          _scorePercent;                                     // 0x09C0(0x0088)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _postTeleportAlternateSpeedCurve;                  // 0x0A48(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _offsetHeight;                                     // 0x0A50(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _rayCastLength;                                    // 0x0A54(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UConeAroundDirectionCameraStrategy> _cameraStrategyClass;                              // 0x0A58(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _cameraMaximumAngleFactorCurve;                    // 0x0A60(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A68[0x20];                                     // 0x0A68(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UConeAroundDirectionCameraStrategy*     _cameraStrategy;                                   // 0x0A88(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A90[0x10];                                     // 0x0A90(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnryoTeleportInteraction">();
	}
	static class UOnryoTeleportInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOnryoTeleportInteraction>();
	}
};
static_assert(alignof(UOnryoTeleportInteraction) == 0x000010, "Wrong alignment on UOnryoTeleportInteraction");
static_assert(sizeof(UOnryoTeleportInteraction) == 0x000AA0, "Wrong size on UOnryoTeleportInteraction");
static_assert(offsetof(UOnryoTeleportInteraction, _cachedOwningKiller) == 0x000920, "Member 'UOnryoTeleportInteraction::_cachedOwningKiller' has a wrong offset!");
static_assert(offsetof(UOnryoTeleportInteraction, _currentTargetTelevision) == 0x000928, "Member 'UOnryoTeleportInteraction::_currentTargetTelevision' has a wrong offset!");
static_assert(offsetof(UOnryoTeleportInteraction, _televisionTeleportingTo) == 0x000930, "Member 'UOnryoTeleportInteraction::_televisionTeleportingTo' has a wrong offset!");
static_assert(offsetof(UOnryoTeleportInteraction, _teleportExitAnimDuration) == 0x000940, "Member 'UOnryoTeleportInteraction::_teleportExitAnimDuration' has a wrong offset!");
static_assert(offsetof(UOnryoTeleportInteraction, _teleportCancelledAnimDuration) == 0x000968, "Member 'UOnryoTeleportInteraction::_teleportCancelledAnimDuration' has a wrong offset!");
static_assert(offsetof(UOnryoTeleportInteraction, _postTeleportSpeedDuration) == 0x000990, "Member 'UOnryoTeleportInteraction::_postTeleportSpeedDuration' has a wrong offset!");
static_assert(offsetof(UOnryoTeleportInteraction, _postTeleportSpeedCurve) == 0x0009B8, "Member 'UOnryoTeleportInteraction::_postTeleportSpeedCurve' has a wrong offset!");
static_assert(offsetof(UOnryoTeleportInteraction, _scorePercent) == 0x0009C0, "Member 'UOnryoTeleportInteraction::_scorePercent' has a wrong offset!");
static_assert(offsetof(UOnryoTeleportInteraction, _postTeleportAlternateSpeedCurve) == 0x000A48, "Member 'UOnryoTeleportInteraction::_postTeleportAlternateSpeedCurve' has a wrong offset!");
static_assert(offsetof(UOnryoTeleportInteraction, _offsetHeight) == 0x000A50, "Member 'UOnryoTeleportInteraction::_offsetHeight' has a wrong offset!");
static_assert(offsetof(UOnryoTeleportInteraction, _rayCastLength) == 0x000A54, "Member 'UOnryoTeleportInteraction::_rayCastLength' has a wrong offset!");
static_assert(offsetof(UOnryoTeleportInteraction, _cameraStrategyClass) == 0x000A58, "Member 'UOnryoTeleportInteraction::_cameraStrategyClass' has a wrong offset!");
static_assert(offsetof(UOnryoTeleportInteraction, _cameraMaximumAngleFactorCurve) == 0x000A60, "Member 'UOnryoTeleportInteraction::_cameraMaximumAngleFactorCurve' has a wrong offset!");
static_assert(offsetof(UOnryoTeleportInteraction, _cameraStrategy) == 0x000A88, "Member 'UOnryoTeleportInteraction::_cameraStrategy' has a wrong offset!");

// Class TheOnryo.OnryoTelevision
// 0x0338 (0x06E0 - 0x03A8)
class AOnryoTelevision final : public AInteractable
{
public:
	uint8                                         Pad_3A8[0x18];                                     // 0x03A8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        _teleportPosition;                                 // 0x03C0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isKillerInOtherWorld;                             // 0x03C8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C9[0x7];                                      // 0x03C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTelevisionOutlineUpdateStrategy*       _televisionOutlineUpdateStrategy;                  // 0x03D0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ULocalPlayerTrackerComponent*           _localPlayerTracker;                               // 0x03D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMapActorComponent*                     _mapActorComponent;                                // 0x03E0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOnryoTVAutoPowerComponent*             _autoPowerComponent;                               // 0x03E8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3F0[0x48];                                     // 0x03F0(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _isPowered;                                        // 0x0438(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_439[0x17];                                     // 0x0439(0x0017)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class ADBDPlayer*>                       _nearbySurvivorsWithoutTape;                       // 0x0450(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_4A0[0x50];                                     // 0x04A0(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _distanceNearTVWithoutTape;                        // 0x04F0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _survivorTurnOffTVDuration;                        // 0x0518(0x0080)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _teleportTurnOffDuration;                          // 0x0598(0x0080)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _survivorInsertTapeTurnOffDuration;                // 0x0618(0x0080)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _shouldRepowerOtherTelevisionsWhenAllTurnedOff;    // 0x0698(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6C0[0x20];                                     // 0x06C0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnRepowerTimerDone();
	void Cosmetic_OnCamperCanInsertTapeChanged(const bool CanInsertTape);
	void Cosmetic_OnPoweredOnVfxRadiusChanged(float NewPoweredOnVfxRadius);
	void Cosmetic_OnStatusEffectZoneVFXActiveChanged(bool Active);
	void Cosmetic_OnTeleportCancelled();
	void Cosmetic_OnTeleportCompleted();
	void Cosmetic_OnTeleportStarted();
	void Cosmetic_OnTelevisionCosmeticStateChanged(ETelevisionCosmeticState NextState, ETelevisionCosmeticState PreviousState);
	void Cosmetic_OnTVSelectedByLocalSurvivor(class ADBDPlayer* Survivor);
	void Cosmetic_SetIsTeleportTarget(bool Target);
	void Multicast_FireLoudNoiseNotification();
	void Multicast_SetSurvivorCanInsertTape(const class ADBDPlayer* Survivor, const bool CanInsert, const bool ShowBubbleIndicator);
	void OnCosmeticTransitionStateFinished();
	void OnKillerSet(class ASlasherPlayer* Killer);
	void OnLocallyObservedChanged();
	void OnRep_IsPowered(bool PreviousIsPowered);

	ETelevisionCosmeticState GetTelevisionCosmeticState() const;
	bool IsAnySurvivorWithoutTapeNearby() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnryoTelevision">();
	}
	static class AOnryoTelevision* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOnryoTelevision>();
	}
};
static_assert(alignof(AOnryoTelevision) == 0x000008, "Wrong alignment on AOnryoTelevision");
static_assert(sizeof(AOnryoTelevision) == 0x0006E0, "Wrong size on AOnryoTelevision");
static_assert(offsetof(AOnryoTelevision, _teleportPosition) == 0x0003C0, "Member 'AOnryoTelevision::_teleportPosition' has a wrong offset!");
static_assert(offsetof(AOnryoTelevision, _isKillerInOtherWorld) == 0x0003C8, "Member 'AOnryoTelevision::_isKillerInOtherWorld' has a wrong offset!");
static_assert(offsetof(AOnryoTelevision, _televisionOutlineUpdateStrategy) == 0x0003D0, "Member 'AOnryoTelevision::_televisionOutlineUpdateStrategy' has a wrong offset!");
static_assert(offsetof(AOnryoTelevision, _localPlayerTracker) == 0x0003D8, "Member 'AOnryoTelevision::_localPlayerTracker' has a wrong offset!");
static_assert(offsetof(AOnryoTelevision, _mapActorComponent) == 0x0003E0, "Member 'AOnryoTelevision::_mapActorComponent' has a wrong offset!");
static_assert(offsetof(AOnryoTelevision, _autoPowerComponent) == 0x0003E8, "Member 'AOnryoTelevision::_autoPowerComponent' has a wrong offset!");
static_assert(offsetof(AOnryoTelevision, _isPowered) == 0x000438, "Member 'AOnryoTelevision::_isPowered' has a wrong offset!");
static_assert(offsetof(AOnryoTelevision, _nearbySurvivorsWithoutTape) == 0x000450, "Member 'AOnryoTelevision::_nearbySurvivorsWithoutTape' has a wrong offset!");
static_assert(offsetof(AOnryoTelevision, _distanceNearTVWithoutTape) == 0x0004F0, "Member 'AOnryoTelevision::_distanceNearTVWithoutTape' has a wrong offset!");
static_assert(offsetof(AOnryoTelevision, _survivorTurnOffTVDuration) == 0x000518, "Member 'AOnryoTelevision::_survivorTurnOffTVDuration' has a wrong offset!");
static_assert(offsetof(AOnryoTelevision, _teleportTurnOffDuration) == 0x000598, "Member 'AOnryoTelevision::_teleportTurnOffDuration' has a wrong offset!");
static_assert(offsetof(AOnryoTelevision, _survivorInsertTapeTurnOffDuration) == 0x000618, "Member 'AOnryoTelevision::_survivorInsertTapeTurnOffDuration' has a wrong offset!");
static_assert(offsetof(AOnryoTelevision, _shouldRepowerOtherTelevisionsWhenAllTurnedOff) == 0x000698, "Member 'AOnryoTelevision::_shouldRepowerOtherTelevisionsWhenAllTurnedOff' has a wrong offset!");

// Class TheOnryo.OnryoTVAutoPowerComponent
// 0x0018 (0x00C0 - 0x00A8)
class UOnryoTVAutoPowerComponent final : public UActorComponent
{
public:
	TSubclassOf<class UOnryoTVInitialCooldownStateComponent> _cooldownStateClass;                               // 0x00A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _powerTVOnBeginPlay;                               // 0x00B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B1[0xF];                                       // 0x00B1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnryoTVAutoPowerComponent">();
	}
	static class UOnryoTVAutoPowerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOnryoTVAutoPowerComponent>();
	}
};
static_assert(alignof(UOnryoTVAutoPowerComponent) == 0x000008, "Wrong alignment on UOnryoTVAutoPowerComponent");
static_assert(sizeof(UOnryoTVAutoPowerComponent) == 0x0000C0, "Wrong size on UOnryoTVAutoPowerComponent");
static_assert(offsetof(UOnryoTVAutoPowerComponent, _cooldownStateClass) == 0x0000A8, "Member 'UOnryoTVAutoPowerComponent::_cooldownStateClass' has a wrong offset!");
static_assert(offsetof(UOnryoTVAutoPowerComponent, _powerTVOnBeginPlay) == 0x0000B0, "Member 'UOnryoTVAutoPowerComponent::_powerTVOnBeginPlay' has a wrong offset!");

// Class TheOnryo.OnryoTVInitialCooldownStateComponent
// 0x0050 (0x00F8 - 0x00A8)
class UOnryoTVInitialCooldownStateComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x18];                                      // 0x00A8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _initialTVCooldown;                                // 0x00C0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class UTimerObject*                           _cooldownTimer;                                    // 0x00E8(0x0008)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isDone;                                           // 0x00F0(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F1[0x7];                                       // 0x00F1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_TryStartCooldown();
	void OnCooldownDone();
	void OnRep_IsDone();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnryoTVInitialCooldownStateComponent">();
	}
	static class UOnryoTVInitialCooldownStateComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOnryoTVInitialCooldownStateComponent>();
	}
};
static_assert(alignof(UOnryoTVInitialCooldownStateComponent) == 0x000008, "Wrong alignment on UOnryoTVInitialCooldownStateComponent");
static_assert(sizeof(UOnryoTVInitialCooldownStateComponent) == 0x0000F8, "Wrong size on UOnryoTVInitialCooldownStateComponent");
static_assert(offsetof(UOnryoTVInitialCooldownStateComponent, _initialTVCooldown) == 0x0000C0, "Member 'UOnryoTVInitialCooldownStateComponent::_initialTVCooldown' has a wrong offset!");
static_assert(offsetof(UOnryoTVInitialCooldownStateComponent, _cooldownTimer) == 0x0000E8, "Member 'UOnryoTVInitialCooldownStateComponent::_cooldownTimer' has a wrong offset!");
static_assert(offsetof(UOnryoTVInitialCooldownStateComponent, _isDone) == 0x0000F0, "Member 'UOnryoTVInitialCooldownStateComponent::_isDone' has a wrong offset!");

// Class TheOnryo.OnryoUnmanifestCooldownInteraction
// 0x0030 (0x07B0 - 0x0780)
class UOnryoUnmanifestCooldownInteraction final : public UInteractionDefinition
{
public:
	struct FDBDTunableRowHandle                   _onryoPowerCooldownTime;                           // 0x0778(0x0028)(Edit, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _playedCooldownSpeedCurve;                         // 0x07A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7A8[0x8];                                      // 0x07A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetOnryoPower(class AOnryoPower* OnryoPower);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnryoUnmanifestCooldownInteraction">();
	}
	static class UOnryoUnmanifestCooldownInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOnryoUnmanifestCooldownInteraction>();
	}
};
static_assert(alignof(UOnryoUnmanifestCooldownInteraction) == 0x000010, "Wrong alignment on UOnryoUnmanifestCooldownInteraction");
static_assert(sizeof(UOnryoUnmanifestCooldownInteraction) == 0x0007B0, "Wrong size on UOnryoUnmanifestCooldownInteraction");
static_assert(offsetof(UOnryoUnmanifestCooldownInteraction, _onryoPowerCooldownTime) == 0x000778, "Member 'UOnryoUnmanifestCooldownInteraction::_onryoPowerCooldownTime' has a wrong offset!");
static_assert(offsetof(UOnryoUnmanifestCooldownInteraction, _playedCooldownSpeedCurve) == 0x0007A0, "Member 'UOnryoUnmanifestCooldownInteraction::_playedCooldownSpeedCurve' has a wrong offset!");

// Class TheOnryo.OnryoVisibilityComponent
// 0x0170 (0x0218 - 0x00A8)
class UOnryoVisibilityComponent final : public UActorComponent
{
public:
	bool                                          _isKillerVisibleDuringFlicker;                     // 0x00A8(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameplayTag>                   _killerRevealingStateTags;                         // 0x00B0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _killerVisibleMaxDistance;                         // 0x00C0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TMap<EFlickerType, struct FFlickerSettings>   _flickerSettings;                                  // 0x00E8(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_138[0x1];                                      // 0x0138(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _isInIntroPhase;                                   // 0x0139(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isManifested;                                     // 0x013A(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isInManifestingTransition;                        // 0x013B(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_13C[0xDC];                                     // 0x013C(0x00DC)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Multicast_OnManifestationStateChanged(const bool IsManifested, const bool IsImmediateManifest);
	void OnIntroCompleted();
	void OnKillerInSurvivorSightRangeChanged(const bool InRange);
	void OnLocallyObservedChanged();
	void OnRep_IsKillerVisibleDuringFlicker();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnryoVisibilityComponent">();
	}
	static class UOnryoVisibilityComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOnryoVisibilityComponent>();
	}
};
static_assert(alignof(UOnryoVisibilityComponent) == 0x000008, "Wrong alignment on UOnryoVisibilityComponent");
static_assert(sizeof(UOnryoVisibilityComponent) == 0x000218, "Wrong size on UOnryoVisibilityComponent");
static_assert(offsetof(UOnryoVisibilityComponent, _isKillerVisibleDuringFlicker) == 0x0000A8, "Member 'UOnryoVisibilityComponent::_isKillerVisibleDuringFlicker' has a wrong offset!");
static_assert(offsetof(UOnryoVisibilityComponent, _killerRevealingStateTags) == 0x0000B0, "Member 'UOnryoVisibilityComponent::_killerRevealingStateTags' has a wrong offset!");
static_assert(offsetof(UOnryoVisibilityComponent, _killerVisibleMaxDistance) == 0x0000C0, "Member 'UOnryoVisibilityComponent::_killerVisibleMaxDistance' has a wrong offset!");
static_assert(offsetof(UOnryoVisibilityComponent, _flickerSettings) == 0x0000E8, "Member 'UOnryoVisibilityComponent::_flickerSettings' has a wrong offset!");
static_assert(offsetof(UOnryoVisibilityComponent, _isInIntroPhase) == 0x000139, "Member 'UOnryoVisibilityComponent::_isInIntroPhase' has a wrong offset!");
static_assert(offsetof(UOnryoVisibilityComponent, _isManifested) == 0x00013A, "Member 'UOnryoVisibilityComponent::_isManifested' has a wrong offset!");
static_assert(offsetof(UOnryoVisibilityComponent, _isInManifestingTransition) == 0x00013B, "Member 'UOnryoVisibilityComponent::_isInManifestingTransition' has a wrong offset!");

// Class TheOnryo.RetrieveVHS
// 0x0010 (0x0930 - 0x0920)
class URetrieveVHS final : public USurvivorTelevisionInteraction
{
public:
	TSubclassOf<class ACollectable>               _vhsCollectableBP;                                 // 0x0920(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_928[0x8];                                      // 0x0928(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RetrieveVHS">();
	}
	static class URetrieveVHS* GetDefaultObj()
	{
		return GetDefaultObjImpl<URetrieveVHS>();
	}
};
static_assert(alignof(URetrieveVHS) == 0x000010, "Wrong alignment on URetrieveVHS");
static_assert(sizeof(URetrieveVHS) == 0x000930, "Wrong size on URetrieveVHS");
static_assert(offsetof(URetrieveVHS, _vhsCollectableBP) == 0x000920, "Member 'URetrieveVHS::_vhsCollectableBP' has a wrong offset!");

// Class TheOnryo.TelevisionOutlineUpdateStrategy
// 0x0108 (0x01D8 - 0x00D0)
class UTelevisionOutlineUpdateStrategy final : public UOutlineUpdateStrategy
{
public:
	struct FTunableStat                           _distanceToRevealAura;                             // 0x00D0(0x0080)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_150[0x4];                                      // 0x0150(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           _survivorAuraNearColor;                            // 0x0154(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           _survivorAuraTapeTargetColor;                      // 0x0164(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           _slasherPoweredColor;                              // 0x0174(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           _revealedByMapColor;                               // 0x0184(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           _slasherUnpoweredDefaultColor;                     // 0x0194(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           _slasherUnpoweredVisibleColor;                     // 0x01A4(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           _slasherTeleportTargetColor;                       // 0x01B4(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1C4[0x14];                                     // 0x01C4(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TelevisionOutlineUpdateStrategy">();
	}
	static class UTelevisionOutlineUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTelevisionOutlineUpdateStrategy>();
	}
};
static_assert(alignof(UTelevisionOutlineUpdateStrategy) == 0x000008, "Wrong alignment on UTelevisionOutlineUpdateStrategy");
static_assert(sizeof(UTelevisionOutlineUpdateStrategy) == 0x0001D8, "Wrong size on UTelevisionOutlineUpdateStrategy");
static_assert(offsetof(UTelevisionOutlineUpdateStrategy, _distanceToRevealAura) == 0x0000D0, "Member 'UTelevisionOutlineUpdateStrategy::_distanceToRevealAura' has a wrong offset!");
static_assert(offsetof(UTelevisionOutlineUpdateStrategy, _survivorAuraNearColor) == 0x000154, "Member 'UTelevisionOutlineUpdateStrategy::_survivorAuraNearColor' has a wrong offset!");
static_assert(offsetof(UTelevisionOutlineUpdateStrategy, _survivorAuraTapeTargetColor) == 0x000164, "Member 'UTelevisionOutlineUpdateStrategy::_survivorAuraTapeTargetColor' has a wrong offset!");
static_assert(offsetof(UTelevisionOutlineUpdateStrategy, _slasherPoweredColor) == 0x000174, "Member 'UTelevisionOutlineUpdateStrategy::_slasherPoweredColor' has a wrong offset!");
static_assert(offsetof(UTelevisionOutlineUpdateStrategy, _revealedByMapColor) == 0x000184, "Member 'UTelevisionOutlineUpdateStrategy::_revealedByMapColor' has a wrong offset!");
static_assert(offsetof(UTelevisionOutlineUpdateStrategy, _slasherUnpoweredDefaultColor) == 0x000194, "Member 'UTelevisionOutlineUpdateStrategy::_slasherUnpoweredDefaultColor' has a wrong offset!");
static_assert(offsetof(UTelevisionOutlineUpdateStrategy, _slasherUnpoweredVisibleColor) == 0x0001A4, "Member 'UTelevisionOutlineUpdateStrategy::_slasherUnpoweredVisibleColor' has a wrong offset!");
static_assert(offsetof(UTelevisionOutlineUpdateStrategy, _slasherTeleportTargetColor) == 0x0001B4, "Member 'UTelevisionOutlineUpdateStrategy::_slasherTeleportTargetColor' has a wrong offset!");

// Class TheOnryo.OnryoTeleportTargeterComponent
// 0x0078 (0x0120 - 0x00A8)
class UOnryoTeleportTargeterComponent final : public UActorComponent
{
public:
	struct FDBDTunableRowHandle                   _maximumTeleportAngle;                             // 0x00A8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class AOnryoTelevision*                       _replicatedTargetTelevision;                       // 0x00D0(0x0008)(Net, ZeroConstructor, Transient, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AOnryoTelevision*                       _localTargetTelevision;                            // 0x00D8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AOnryoTelevision*                       _previousTarget;                                   // 0x00E0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _targetUpdateInterval;                             // 0x00E8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_EC[0x34];                                      // 0x00EC(0x0034)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_TargetTelevision();
	void Server_SetTeleportTarget(class AOnryoTelevision* TV);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnryoTeleportTargeterComponent">();
	}
	static class UOnryoTeleportTargeterComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOnryoTeleportTargeterComponent>();
	}
};
static_assert(alignof(UOnryoTeleportTargeterComponent) == 0x000008, "Wrong alignment on UOnryoTeleportTargeterComponent");
static_assert(sizeof(UOnryoTeleportTargeterComponent) == 0x000120, "Wrong size on UOnryoTeleportTargeterComponent");
static_assert(offsetof(UOnryoTeleportTargeterComponent, _maximumTeleportAngle) == 0x0000A8, "Member 'UOnryoTeleportTargeterComponent::_maximumTeleportAngle' has a wrong offset!");
static_assert(offsetof(UOnryoTeleportTargeterComponent, _replicatedTargetTelevision) == 0x0000D0, "Member 'UOnryoTeleportTargeterComponent::_replicatedTargetTelevision' has a wrong offset!");
static_assert(offsetof(UOnryoTeleportTargeterComponent, _localTargetTelevision) == 0x0000D8, "Member 'UOnryoTeleportTargeterComponent::_localTargetTelevision' has a wrong offset!");
static_assert(offsetof(UOnryoTeleportTargeterComponent, _previousTarget) == 0x0000E0, "Member 'UOnryoTeleportTargeterComponent::_previousTarget' has a wrong offset!");
static_assert(offsetof(UOnryoTeleportTargeterComponent, _targetUpdateInterval) == 0x0000E8, "Member 'UOnryoTeleportTargeterComponent::_targetUpdateInterval' has a wrong offset!");

// Class TheOnryo.TurnOffTV
// 0x0000 (0x0920 - 0x0920)
class UTurnOffTV final : public USurvivorTelevisionInteraction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TurnOffTV">();
	}
	static class UTurnOffTV* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTurnOffTV>();
	}
};
static_assert(alignof(UTurnOffTV) == 0x000010, "Wrong alignment on UTurnOffTV");
static_assert(sizeof(UTurnOffTV) == 0x000920, "Wrong size on UTurnOffTV");

// Class TheOnryo.UnmanifestInteraction
// 0x0000 (0x0930 - 0x0930)
class UUnmanifestInteraction final : public UBaseManifestInteraction
{
public:
	void SetOnryoPower(class AOnryoPower* OnryoPower);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnmanifestInteraction">();
	}
	static class UUnmanifestInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnmanifestInteraction>();
	}
};
static_assert(alignof(UUnmanifestInteraction) == 0x000010, "Wrong alignment on UUnmanifestInteraction");
static_assert(sizeof(UUnmanifestInteraction) == 0x000930, "Wrong size on UUnmanifestInteraction");

}

