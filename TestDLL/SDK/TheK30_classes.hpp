#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: TheK30

#include "Basic.hpp"

#include "DBDBots_classes.hpp"
#include "DBDInteraction_classes.hpp"
#include "DataTableUtilities_structs.hpp"
#include "GameplayTags_structs.hpp"
#include "DeadByDaylight_structs.hpp"
#include "DeadByDaylight_classes.hpp"
#include "TheK30_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "DBDSharedTypes_structs.hpp"
#include "StatSystem_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "NetworkUtilities_structs.hpp"
#include "AnimationUtilities_structs.hpp"
#include "DBDAnimation_classes.hpp"
#include "DBDGameplay_classes.hpp"
#include "DBDCompetence_classes.hpp"
#include "DBDCosmetic_classes.hpp"
#include "Competence_classes.hpp"


namespace SDK
{

// Class TheK30.GuardOrderBase
// 0x0010 (0x0790 - 0x0780)
class UGuardOrderBase : public UInteractionDefinition
{
public:
	bool                                          _shouldWaitForCurrentInteraction;                  // 0x0778(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_779[0x3];                                      // 0x0779(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   _explodeInteractableAnimNotifyID;                  // 0x077C(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_788[0x8];                                      // 0x0788(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GuardOrderBase">();
	}
	static class UGuardOrderBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGuardOrderBase>();
	}
};
static_assert(alignof(UGuardOrderBase) == 0x000010, "Wrong alignment on UGuardOrderBase");
static_assert(sizeof(UGuardOrderBase) == 0x000790, "Wrong size on UGuardOrderBase");
static_assert(offsetof(UGuardOrderBase, _shouldWaitForCurrentInteraction) == 0x000778, "Member 'UGuardOrderBase::_shouldWaitForCurrentInteraction' has a wrong offset!");
static_assert(offsetof(UGuardOrderBase, _explodeInteractableAnimNotifyID) == 0x00077C, "Member 'UGuardOrderBase::_explodeInteractableAnimNotifyID' has a wrong offset!");

// Class TheK30.GuardBreakWall
// 0x0000 (0x0790 - 0x0790)
class UGuardBreakWall final : public UGuardOrderBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GuardBreakWall">();
	}
	static class UGuardBreakWall* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGuardBreakWall>();
	}
};
static_assert(alignof(UGuardBreakWall) == 0x000010, "Wrong alignment on UGuardBreakWall");
static_assert(sizeof(UGuardBreakWall) == 0x000790, "Wrong size on UGuardBreakWall");

// Class TheK30.BTService_FindObject_GuardFlag
// 0x0000 (0x0220 - 0x0220)
class UBTService_FindObject_GuardFlag final : public UBTService_FindObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_FindObject_GuardFlag">();
	}
	static class UBTService_FindObject_GuardFlag* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_FindObject_GuardFlag>();
	}
};
static_assert(alignof(UBTService_FindObject_GuardFlag) == 0x000008, "Wrong alignment on UBTService_FindObject_GuardFlag");
static_assert(sizeof(UBTService_FindObject_GuardFlag) == 0x000220, "Wrong size on UBTService_FindObject_GuardFlag");

// Class TheK30.K30Power
// 0x00B0 (0x06A8 - 0x05F8)
class AK30Power final : public AKillerPower
{
public:
	FMulticastInlineDelegateProperty_             PowerStateChanged;                                 // 0x05F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             GuardSwappedTo;                                    // 0x0608(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UPatrolTrailComponent*                  _patrolTrailComponent;                             // 0x0618(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGuardManagerComponent*                 _guardManagerComponent;                            // 0x0620(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDrawPatrolModeSwitcherComponent*       _drawPatrolModeSwitcherComponent;                  // 0x0628(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FPostDrawPatrolHasteApplier            _postDrawPatrolHasteApplier;                       // 0x0630(0x0038)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_668[0x40];                                     // 0x0668(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_SendPathNearlyEndingWarning();
	void Cosmetic_UpdateRemainingPathLength(float RemainingPathLengthPercent);
	void GuardSwappedTo__DelegateSignature(ESwapToState SwapTo);
	void PowerStateChanged__DelegateSignature(EPowerState PreviousState, EPowerState NewState);

	class UDrawPatrolPathInteraction* GetDrawPatrolPathInteraction() const;
	class UKnightOrderComponent* GetKnightOrderComponent() const;
	class UPatrolTrailComponent* GetPatrolTrailComponent() const;
	float GetRemainingPathLengthPercent() const;
	class USwapGuardTypeInteraction* GetSwapGuardTypeInteraction() const;
	bool IsDrawingPath() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K30Power">();
	}
	static class AK30Power* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK30Power>();
	}
};
static_assert(alignof(AK30Power) == 0x000008, "Wrong alignment on AK30Power");
static_assert(sizeof(AK30Power) == 0x0006A8, "Wrong size on AK30Power");
static_assert(offsetof(AK30Power, PowerStateChanged) == 0x0005F8, "Member 'AK30Power::PowerStateChanged' has a wrong offset!");
static_assert(offsetof(AK30Power, GuardSwappedTo) == 0x000608, "Member 'AK30Power::GuardSwappedTo' has a wrong offset!");
static_assert(offsetof(AK30Power, _patrolTrailComponent) == 0x000618, "Member 'AK30Power::_patrolTrailComponent' has a wrong offset!");
static_assert(offsetof(AK30Power, _guardManagerComponent) == 0x000620, "Member 'AK30Power::_guardManagerComponent' has a wrong offset!");
static_assert(offsetof(AK30Power, _drawPatrolModeSwitcherComponent) == 0x000628, "Member 'AK30Power::_drawPatrolModeSwitcherComponent' has a wrong offset!");
static_assert(offsetof(AK30Power, _postDrawPatrolHasteApplier) == 0x000630, "Member 'AK30Power::_postDrawPatrolHasteApplier' has a wrong offset!");

// Class TheK30.DrawPatrolModeSwitcherComponent
// 0x0288 (0x0330 - 0x00A8)
class alignas(0x10) UDrawPatrolModeSwitcherComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _pathCreationModeOverFadeInTime;                   // 0x00B0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	float                                         _enableInteractionAfterTeleportationDelay;         // 0x00D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_DC[0x4];                                       // 0x00DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AActor>                     _drawPathIndicatorClass;                           // 0x00E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class APoseableHusk>              _huskClass;                                        // 0x00E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FFloatingCameraHandler                 _floatingCameraHandler;                            // 0x00F0(0x0100)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDrawPatrolSnappingHandler             _drawPatrolSnappingHandler;                        // 0x01F0(0x0098)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class APoseableHusk*                          _husk;                                             // 0x0288(0x0008)(Net, ZeroConstructor, Transient, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 _drawPathIndicator;                                // 0x0290(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_298[0x98];                                     // 0x0298(0x0098)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_Husk();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DrawPatrolModeSwitcherComponent">();
	}
	static class UDrawPatrolModeSwitcherComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDrawPatrolModeSwitcherComponent>();
	}
};
static_assert(alignof(UDrawPatrolModeSwitcherComponent) == 0x000010, "Wrong alignment on UDrawPatrolModeSwitcherComponent");
static_assert(sizeof(UDrawPatrolModeSwitcherComponent) == 0x000330, "Wrong size on UDrawPatrolModeSwitcherComponent");
static_assert(offsetof(UDrawPatrolModeSwitcherComponent, _pathCreationModeOverFadeInTime) == 0x0000B0, "Member 'UDrawPatrolModeSwitcherComponent::_pathCreationModeOverFadeInTime' has a wrong offset!");
static_assert(offsetof(UDrawPatrolModeSwitcherComponent, _enableInteractionAfterTeleportationDelay) == 0x0000D8, "Member 'UDrawPatrolModeSwitcherComponent::_enableInteractionAfterTeleportationDelay' has a wrong offset!");
static_assert(offsetof(UDrawPatrolModeSwitcherComponent, _drawPathIndicatorClass) == 0x0000E0, "Member 'UDrawPatrolModeSwitcherComponent::_drawPathIndicatorClass' has a wrong offset!");
static_assert(offsetof(UDrawPatrolModeSwitcherComponent, _huskClass) == 0x0000E8, "Member 'UDrawPatrolModeSwitcherComponent::_huskClass' has a wrong offset!");
static_assert(offsetof(UDrawPatrolModeSwitcherComponent, _floatingCameraHandler) == 0x0000F0, "Member 'UDrawPatrolModeSwitcherComponent::_floatingCameraHandler' has a wrong offset!");
static_assert(offsetof(UDrawPatrolModeSwitcherComponent, _drawPatrolSnappingHandler) == 0x0001F0, "Member 'UDrawPatrolModeSwitcherComponent::_drawPatrolSnappingHandler' has a wrong offset!");
static_assert(offsetof(UDrawPatrolModeSwitcherComponent, _husk) == 0x000288, "Member 'UDrawPatrolModeSwitcherComponent::_husk' has a wrong offset!");
static_assert(offsetof(UDrawPatrolModeSwitcherComponent, _drawPathIndicator) == 0x000290, "Member 'UDrawPatrolModeSwitcherComponent::_drawPathIndicator' has a wrong offset!");

// Class TheK30.DrawPatrolPathInteraction
// 0x0230 (0x0B50 - 0x0920)
class UDrawPatrolPathInteraction final : public UBasicChargeableInteraction
{
public:
	uint8                                         Pad_920[0x34];                                     // 0x0920(0x0034)(Fixing Size After Last Property [ Dumper-7 ])
	EDrawPatrolExitReason                         _exitReason;                                       // 0x0954(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_955[0x3];                                      // 0x0955(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSecondaryInteractionProperties        _giveOrderProperties;                              // 0x0958(0x0038)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FSecondaryInteractionProperties        _releaseInteractionProperties;                     // 0x0990(0x0038)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FSecondaryInteractionProperties        _cancelInteractionProperties;                      // 0x09C8(0x0038)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _maximumInteractionDuration;                       // 0x0A00(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _pathLengthWarningPercent;                         // 0x0A28(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _pathDrawingDurationWarningPercent;                // 0x0A50(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _minSlopeToCheckStepUp;                            // 0x0A78(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _lookAtPreviewSpeed;                               // 0x0AA0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TMap<TSoftClassPtr<class UClass>, class FText> _guardNames;                                       // 0x0AC8(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B18[0x38];                                     // 0x0B18(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DrawPatrolPathInteraction">();
	}
	static class UDrawPatrolPathInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDrawPatrolPathInteraction>();
	}
};
static_assert(alignof(UDrawPatrolPathInteraction) == 0x000010, "Wrong alignment on UDrawPatrolPathInteraction");
static_assert(sizeof(UDrawPatrolPathInteraction) == 0x000B50, "Wrong size on UDrawPatrolPathInteraction");
static_assert(offsetof(UDrawPatrolPathInteraction, _exitReason) == 0x000954, "Member 'UDrawPatrolPathInteraction::_exitReason' has a wrong offset!");
static_assert(offsetof(UDrawPatrolPathInteraction, _giveOrderProperties) == 0x000958, "Member 'UDrawPatrolPathInteraction::_giveOrderProperties' has a wrong offset!");
static_assert(offsetof(UDrawPatrolPathInteraction, _releaseInteractionProperties) == 0x000990, "Member 'UDrawPatrolPathInteraction::_releaseInteractionProperties' has a wrong offset!");
static_assert(offsetof(UDrawPatrolPathInteraction, _cancelInteractionProperties) == 0x0009C8, "Member 'UDrawPatrolPathInteraction::_cancelInteractionProperties' has a wrong offset!");
static_assert(offsetof(UDrawPatrolPathInteraction, _maximumInteractionDuration) == 0x000A00, "Member 'UDrawPatrolPathInteraction::_maximumInteractionDuration' has a wrong offset!");
static_assert(offsetof(UDrawPatrolPathInteraction, _pathLengthWarningPercent) == 0x000A28, "Member 'UDrawPatrolPathInteraction::_pathLengthWarningPercent' has a wrong offset!");
static_assert(offsetof(UDrawPatrolPathInteraction, _pathDrawingDurationWarningPercent) == 0x000A50, "Member 'UDrawPatrolPathInteraction::_pathDrawingDurationWarningPercent' has a wrong offset!");
static_assert(offsetof(UDrawPatrolPathInteraction, _minSlopeToCheckStepUp) == 0x000A78, "Member 'UDrawPatrolPathInteraction::_minSlopeToCheckStepUp' has a wrong offset!");
static_assert(offsetof(UDrawPatrolPathInteraction, _lookAtPreviewSpeed) == 0x000AA0, "Member 'UDrawPatrolPathInteraction::_lookAtPreviewSpeed' has a wrong offset!");
static_assert(offsetof(UDrawPatrolPathInteraction, _guardNames) == 0x000AC8, "Member 'UDrawPatrolPathInteraction::_guardNames' has a wrong offset!");

// Class TheK30.GuardAttackableComponent
// 0x0028 (0x00D0 - 0x00A8)
class UGuardAttackableComponent final : public UAttackableComponent
{
public:
	struct FDBDTunableRowHandle                   _hitByCooldown;                                    // 0x00A8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GuardAttackableComponent">();
	}
	static class UGuardAttackableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGuardAttackableComponent>();
	}
};
static_assert(alignof(UGuardAttackableComponent) == 0x000008, "Wrong alignment on UGuardAttackableComponent");
static_assert(sizeof(UGuardAttackableComponent) == 0x0000D0, "Wrong size on UGuardAttackableComponent");
static_assert(offsetof(UGuardAttackableComponent, _hitByCooldown) == 0x0000A8, "Member 'UGuardAttackableComponent::_hitByCooldown' has a wrong offset!");

// Class TheK30.TrailNode
// 0x0020 (0x02C0 - 0x02A0)
class ATrailNode final : public AActor
{
public:
	struct FVector                                _previousNodePosition;                             // 0x02A0(0x0018)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isPreparingForRemoval;                            // 0x02B8(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B9[0x7];                                      // 0x02B9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_PrepareForRemoval();
	void OnPreviousNodePositionSet();
	void OnRep_IsPreparingForRemoval();
	void OnRep_PreviousNodePosition();

	bool IsFirstNode() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TrailNode">();
	}
	static class ATrailNode* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATrailNode>();
	}
};
static_assert(alignof(ATrailNode) == 0x000008, "Wrong alignment on ATrailNode");
static_assert(sizeof(ATrailNode) == 0x0002C0, "Wrong size on ATrailNode");
static_assert(offsetof(ATrailNode, _previousNodePosition) == 0x0002A0, "Member 'ATrailNode::_previousNodePosition' has a wrong offset!");
static_assert(offsetof(ATrailNode, _isPreparingForRemoval) == 0x0002B8, "Member 'ATrailNode::_isPreparingForRemoval' has a wrong offset!");

// Class TheK30.GuardAttackComponent
// 0x0088 (0x0130 - 0x00A8)
class UGuardAttackComponent final : public UActorComponent
{
public:
	TSubclassOf<class UStatusEffect>              _killerInstinctEffectClass;                        // 0x00A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _killerInstinctEffectDuration;                     // 0x00B0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	EDetectionZone                                _detectionZoneToUse;                               // 0x00D8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D9[0x7];                                       // 0x00D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<TWeakObjectPtr<class ACamperPlayer>>     _survivorsInZone;                                  // 0x00E0(0x0050)(UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GuardAttackComponent">();
	}
	static class UGuardAttackComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGuardAttackComponent>();
	}
};
static_assert(alignof(UGuardAttackComponent) == 0x000008, "Wrong alignment on UGuardAttackComponent");
static_assert(sizeof(UGuardAttackComponent) == 0x000130, "Wrong size on UGuardAttackComponent");
static_assert(offsetof(UGuardAttackComponent, _killerInstinctEffectClass) == 0x0000A8, "Member 'UGuardAttackComponent::_killerInstinctEffectClass' has a wrong offset!");
static_assert(offsetof(UGuardAttackComponent, _killerInstinctEffectDuration) == 0x0000B0, "Member 'UGuardAttackComponent::_killerInstinctEffectDuration' has a wrong offset!");
static_assert(offsetof(UGuardAttackComponent, _detectionZoneToUse) == 0x0000D8, "Member 'UGuardAttackComponent::_detectionZoneToUse' has a wrong offset!");
static_assert(offsetof(UGuardAttackComponent, _survivorsInZone) == 0x0000E0, "Member 'UGuardAttackComponent::_survivorsInZone' has a wrong offset!");

// Class TheK30.SwapGuardTypeInteraction
// 0x0010 (0x0790 - 0x0780)
class USwapGuardTypeInteraction final : public UInteractionDefinition
{
public:
	uint8                                         Pad_778[0x18];                                     // 0x0778(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SwapGuardTypeInteraction">();
	}
	static class USwapGuardTypeInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<USwapGuardTypeInteraction>();
	}
};
static_assert(alignof(USwapGuardTypeInteraction) == 0x000010, "Wrong alignment on USwapGuardTypeInteraction");
static_assert(sizeof(USwapGuardTypeInteraction) == 0x000790, "Wrong size on USwapGuardTypeInteraction");

// Class TheK30.NavigationQueryFilter_Guard
// 0x0000 (0x0070 - 0x0070)
class UNavigationQueryFilter_Guard final : public UNavigationQueryFilter_Player
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavigationQueryFilter_Guard">();
	}
	static class UNavigationQueryFilter_Guard* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavigationQueryFilter_Guard>();
	}
};
static_assert(alignof(UNavigationQueryFilter_Guard) == 0x000008, "Wrong alignment on UNavigationQueryFilter_Guard");
static_assert(sizeof(UNavigationQueryFilter_Guard) == 0x000070, "Wrong size on UNavigationQueryFilter_Guard");

// Class TheK30.GuardBreakPallet
// 0x0000 (0x0790 - 0x0790)
class UGuardBreakPallet final : public UGuardOrderBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GuardBreakPallet">();
	}
	static class UGuardBreakPallet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGuardBreakPallet>();
	}
};
static_assert(alignof(UGuardBreakPallet) == 0x000010, "Wrong alignment on UGuardBreakPallet");
static_assert(sizeof(UGuardBreakPallet) == 0x000790, "Wrong size on UGuardBreakPallet");

// Class TheK30.SetUpLockerInteractionComponent
// 0x0010 (0x00B8 - 0x00A8)
class USetUpLockerInteractionComponent final : public UActorComponent
{
public:
	TSubclassOf<class UInteractionDefinition>     _interactionClass;                                 // 0x00A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B0[0x8];                                       // 0x00B0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SetUpLockerInteractionComponent">();
	}
	static class USetUpLockerInteractionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USetUpLockerInteractionComponent>();
	}
};
static_assert(alignof(USetUpLockerInteractionComponent) == 0x000008, "Wrong alignment on USetUpLockerInteractionComponent");
static_assert(sizeof(USetUpLockerInteractionComponent) == 0x0000B8, "Wrong size on USetUpLockerInteractionComponent");
static_assert(offsetof(USetUpLockerInteractionComponent, _interactionClass) == 0x0000A8, "Member 'USetUpLockerInteractionComponent::_interactionClass' has a wrong offset!");

// Class TheK30.GuardController
// 0x0078 (0x0A98 - 0x0A20)
class AGuardController final : public ADBDAIBTController
{
public:
	uint8                                         Pad_A20[0x8];                                      // 0x0A20(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameplayTag>                   _cannotHuntWhileIdleTags;                          // 0x0A28(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class FName                                   _isPatrollingKey;                                  // 0x0A38(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   _patrolDestinationKey;                             // 0x0A44(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   _patrolUseDirectPathKey;                           // 0x0A50(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   _isHuntingKey;                                     // 0x0A5C(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   _huntedSurvivorKey;                                // 0x0A68(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   _huntDestinationKey;                               // 0x0A74(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   _huntUseDirectPathKey;                             // 0x0A80(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   _huntShouldSearchLockerKey;                        // 0x0A8C(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnLoudNoiseTriggered(class AActor* Originator, class AActor* InstigatingActor, const struct FVector& Location, bool ShouldTrack, float* AudibleRange, bool IsQuickAction, bool IsDeceivingNoise);
	void OnTargetPerceptionUpdated(class AActor* Actor, const struct FAIStimulus& Stimulus);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GuardController">();
	}
	static class AGuardController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGuardController>();
	}
};
static_assert(alignof(AGuardController) == 0x000008, "Wrong alignment on AGuardController");
static_assert(sizeof(AGuardController) == 0x000A98, "Wrong size on AGuardController");
static_assert(offsetof(AGuardController, _cannotHuntWhileIdleTags) == 0x000A28, "Member 'AGuardController::_cannotHuntWhileIdleTags' has a wrong offset!");
static_assert(offsetof(AGuardController, _isPatrollingKey) == 0x000A38, "Member 'AGuardController::_isPatrollingKey' has a wrong offset!");
static_assert(offsetof(AGuardController, _patrolDestinationKey) == 0x000A44, "Member 'AGuardController::_patrolDestinationKey' has a wrong offset!");
static_assert(offsetof(AGuardController, _patrolUseDirectPathKey) == 0x000A50, "Member 'AGuardController::_patrolUseDirectPathKey' has a wrong offset!");
static_assert(offsetof(AGuardController, _isHuntingKey) == 0x000A5C, "Member 'AGuardController::_isHuntingKey' has a wrong offset!");
static_assert(offsetof(AGuardController, _huntedSurvivorKey) == 0x000A68, "Member 'AGuardController::_huntedSurvivorKey' has a wrong offset!");
static_assert(offsetof(AGuardController, _huntDestinationKey) == 0x000A74, "Member 'AGuardController::_huntDestinationKey' has a wrong offset!");
static_assert(offsetof(AGuardController, _huntUseDirectPathKey) == 0x000A80, "Member 'AGuardController::_huntUseDirectPathKey' has a wrong offset!");
static_assert(offsetof(AGuardController, _huntShouldSearchLockerKey) == 0x000A8C, "Member 'AGuardController::_huntShouldSearchLockerKey' has a wrong offset!");

// Class TheK30.GuardCatalog
// 0x0010 (0x0048 - 0x0038)
class UGuardCatalog final : public UDataAsset
{
public:
	TArray<TSoftClassPtr<class UClass>>           Guards;                                            // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GuardCatalog">();
	}
	static class UGuardCatalog* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGuardCatalog>();
	}
};
static_assert(alignof(UGuardCatalog) == 0x000008, "Wrong alignment on UGuardCatalog");
static_assert(sizeof(UGuardCatalog) == 0x000048, "Wrong size on UGuardCatalog");
static_assert(offsetof(UGuardCatalog, Guards) == 0x000038, "Member 'UGuardCatalog::Guards' has a wrong offset!");

// Class TheK30.GuardDamageGenerator
// 0x0000 (0x0790 - 0x0790)
class UGuardDamageGenerator final : public UGuardOrderBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GuardDamageGenerator">();
	}
	static class UGuardDamageGenerator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGuardDamageGenerator>();
	}
};
static_assert(alignof(UGuardDamageGenerator) == 0x000010, "Wrong alignment on UGuardDamageGenerator");
static_assert(sizeof(UGuardDamageGenerator) == 0x000790, "Wrong size on UGuardDamageGenerator");

// Class TheK30.GuardFlag
// 0x0168 (0x0408 - 0x02A0)
class AGuardFlag final : public AActor
{
public:
	class UPrimitiveComponent*                    _flagPickupHitbox;                                 // 0x02A0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FActivationState                       _activationState;                                  // 0x02A8(0x0010)(Net, Transient, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _flagPickupEnduranceEffectClass;                   // 0x02B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _flagPickupEnduranceDuration;                      // 0x02C0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _flagPickupHasteEffectClass;                       // 0x02E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _flagPickupHasteDuration;                          // 0x02F0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _flagPickupHasteModifier;                          // 0x0318(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _baseFlagActivationTime;                           // 0x0340(0x0080)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _activationTimeMultiplierCurve;                    // 0x03C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3C8[0x38];                                     // 0x03C8(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	class ADBDPlayer*                             _clientHuntedSurvivor;                             // 0x0400(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Authority_OnBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& HitResult);
	void Cosmetic_OnFlagActivationTimerCompleted();
	void Cosmetic_OnFlagDisappearDueToHuntEnding(class ADBDPlayer* PreviouslyHuntedSurvivor);
	void Cosmetic_OnFlagSpawned(float ActivationTimerDuration);
	void Cosmetic_OnSurvivorCapturedFlag(class ADBDPlayer* PreviouslyHuntedSurvivor);
	void Multicast_OnCamperCapturedFlag(class ADBDPlayer* HuntedSurvivor);
	void OnRep_ActivationState();

	float GetActivationTimeLeft() const;
	float GetFlagPickupEnduranceDuration() const;
	float GetFlagPickupHasteDuration() const;
	class ADBDPlayer* GetHuntedSurvivor() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GuardFlag">();
	}
	static class AGuardFlag* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGuardFlag>();
	}
};
static_assert(alignof(AGuardFlag) == 0x000008, "Wrong alignment on AGuardFlag");
static_assert(sizeof(AGuardFlag) == 0x000408, "Wrong size on AGuardFlag");
static_assert(offsetof(AGuardFlag, _flagPickupHitbox) == 0x0002A0, "Member 'AGuardFlag::_flagPickupHitbox' has a wrong offset!");
static_assert(offsetof(AGuardFlag, _activationState) == 0x0002A8, "Member 'AGuardFlag::_activationState' has a wrong offset!");
static_assert(offsetof(AGuardFlag, _flagPickupEnduranceEffectClass) == 0x0002B8, "Member 'AGuardFlag::_flagPickupEnduranceEffectClass' has a wrong offset!");
static_assert(offsetof(AGuardFlag, _flagPickupEnduranceDuration) == 0x0002C0, "Member 'AGuardFlag::_flagPickupEnduranceDuration' has a wrong offset!");
static_assert(offsetof(AGuardFlag, _flagPickupHasteEffectClass) == 0x0002E8, "Member 'AGuardFlag::_flagPickupHasteEffectClass' has a wrong offset!");
static_assert(offsetof(AGuardFlag, _flagPickupHasteDuration) == 0x0002F0, "Member 'AGuardFlag::_flagPickupHasteDuration' has a wrong offset!");
static_assert(offsetof(AGuardFlag, _flagPickupHasteModifier) == 0x000318, "Member 'AGuardFlag::_flagPickupHasteModifier' has a wrong offset!");
static_assert(offsetof(AGuardFlag, _baseFlagActivationTime) == 0x000340, "Member 'AGuardFlag::_baseFlagActivationTime' has a wrong offset!");
static_assert(offsetof(AGuardFlag, _activationTimeMultiplierCurve) == 0x0003C0, "Member 'AGuardFlag::_activationTimeMultiplierCurve' has a wrong offset!");
static_assert(offsetof(AGuardFlag, _clientHuntedSurvivor) == 0x000400, "Member 'AGuardFlag::_clientHuntedSurvivor' has a wrong offset!");

// Class TheK30.GuardFlagOUtlineUpdateStrategy
// 0x0020 (0x00F0 - 0x00D0)
class UGuardFlagOUtlineUpdateStrategy final : public UOutlineUpdateStrategy
{
public:
	struct FLinearColor                           _killerColor;                                      // 0x00D0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           _survivorColor;                                    // 0x00E0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GuardFlagOUtlineUpdateStrategy">();
	}
	static class UGuardFlagOUtlineUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGuardFlagOUtlineUpdateStrategy>();
	}
};
static_assert(alignof(UGuardFlagOUtlineUpdateStrategy) == 0x000008, "Wrong alignment on UGuardFlagOUtlineUpdateStrategy");
static_assert(sizeof(UGuardFlagOUtlineUpdateStrategy) == 0x0000F0, "Wrong size on UGuardFlagOUtlineUpdateStrategy");
static_assert(offsetof(UGuardFlagOUtlineUpdateStrategy, _killerColor) == 0x0000D0, "Member 'UGuardFlagOUtlineUpdateStrategy::_killerColor' has a wrong offset!");
static_assert(offsetof(UGuardFlagOUtlineUpdateStrategy, _survivorColor) == 0x0000E0, "Member 'UGuardFlagOUtlineUpdateStrategy::_survivorColor' has a wrong offset!");

// Class TheK30.GuardHuntComponent
// 0x0258 (0x0300 - 0x00A8)
class UGuardHuntComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnGuardPhaseProgressUpdate;                        // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_B8[0x60];                                      // 0x00B8(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _maxPathingDetourLength;                           // 0x0118(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _distanceBeforeGoingToNextWaypoint;                // 0x011C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _distanceBeforeGoingToNextWaypointOffNavmesh;      // 0x0120(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _distanceFromLockerToClearWaypoints;               // 0x0124(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _underWaypointZDistance;                           // 0x0128(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_12C[0x4];                                      // 0x012C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _huntDurationBase;                                 // 0x0130(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _huntDurationBonus;                                // 0x0158(0x0080)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _huntDurationMultiplierCurve;                      // 0x01D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _drainHuntTimerRateMultiplier;                     // 0x01E0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _isKillerCloseEnoughToApplyHuntTimerMultiplierDistance; // 0x0208(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	float                                         _maximumHuntDuration;                              // 0x0230(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_234[0x4];                                      // 0x0234(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSpeedBasedNetSyncedValue              _huntTimeLeft;                                     // 0x0238(0x0038)(Net, NativeAccessSpecifierPrivate)
	class ACamperPlayer*                          _huntedSurvivor;                                   // 0x0270(0x0008)(Net, ZeroConstructor, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_278[0x8];                                      // 0x0278(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                _huntStartingLocation;                             // 0x0280(0x0018)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_298[0x18];                                     // 0x0298(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _speedConsideredStuck;                             // 0x02B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _timeStuckToResetPathing;                          // 0x02B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B8[0x48];                                     // 0x02B8(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnGuardPhaseProgressUpdate__DelegateSignature(float CompletionProgress);
	void OnRep_HuntedSurvivor(class ACamperPlayer* PreviousChasedSurvivor);
	void OnRep_HuntStartingLocation();

	class ACamperPlayer* GetHuntedSurvivor() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GuardHuntComponent">();
	}
	static class UGuardHuntComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGuardHuntComponent>();
	}
};
static_assert(alignof(UGuardHuntComponent) == 0x000008, "Wrong alignment on UGuardHuntComponent");
static_assert(sizeof(UGuardHuntComponent) == 0x000300, "Wrong size on UGuardHuntComponent");
static_assert(offsetof(UGuardHuntComponent, OnGuardPhaseProgressUpdate) == 0x0000A8, "Member 'UGuardHuntComponent::OnGuardPhaseProgressUpdate' has a wrong offset!");
static_assert(offsetof(UGuardHuntComponent, _maxPathingDetourLength) == 0x000118, "Member 'UGuardHuntComponent::_maxPathingDetourLength' has a wrong offset!");
static_assert(offsetof(UGuardHuntComponent, _distanceBeforeGoingToNextWaypoint) == 0x00011C, "Member 'UGuardHuntComponent::_distanceBeforeGoingToNextWaypoint' has a wrong offset!");
static_assert(offsetof(UGuardHuntComponent, _distanceBeforeGoingToNextWaypointOffNavmesh) == 0x000120, "Member 'UGuardHuntComponent::_distanceBeforeGoingToNextWaypointOffNavmesh' has a wrong offset!");
static_assert(offsetof(UGuardHuntComponent, _distanceFromLockerToClearWaypoints) == 0x000124, "Member 'UGuardHuntComponent::_distanceFromLockerToClearWaypoints' has a wrong offset!");
static_assert(offsetof(UGuardHuntComponent, _underWaypointZDistance) == 0x000128, "Member 'UGuardHuntComponent::_underWaypointZDistance' has a wrong offset!");
static_assert(offsetof(UGuardHuntComponent, _huntDurationBase) == 0x000130, "Member 'UGuardHuntComponent::_huntDurationBase' has a wrong offset!");
static_assert(offsetof(UGuardHuntComponent, _huntDurationBonus) == 0x000158, "Member 'UGuardHuntComponent::_huntDurationBonus' has a wrong offset!");
static_assert(offsetof(UGuardHuntComponent, _huntDurationMultiplierCurve) == 0x0001D8, "Member 'UGuardHuntComponent::_huntDurationMultiplierCurve' has a wrong offset!");
static_assert(offsetof(UGuardHuntComponent, _drainHuntTimerRateMultiplier) == 0x0001E0, "Member 'UGuardHuntComponent::_drainHuntTimerRateMultiplier' has a wrong offset!");
static_assert(offsetof(UGuardHuntComponent, _isKillerCloseEnoughToApplyHuntTimerMultiplierDistance) == 0x000208, "Member 'UGuardHuntComponent::_isKillerCloseEnoughToApplyHuntTimerMultiplierDistance' has a wrong offset!");
static_assert(offsetof(UGuardHuntComponent, _maximumHuntDuration) == 0x000230, "Member 'UGuardHuntComponent::_maximumHuntDuration' has a wrong offset!");
static_assert(offsetof(UGuardHuntComponent, _huntTimeLeft) == 0x000238, "Member 'UGuardHuntComponent::_huntTimeLeft' has a wrong offset!");
static_assert(offsetof(UGuardHuntComponent, _huntedSurvivor) == 0x000270, "Member 'UGuardHuntComponent::_huntedSurvivor' has a wrong offset!");
static_assert(offsetof(UGuardHuntComponent, _huntStartingLocation) == 0x000280, "Member 'UGuardHuntComponent::_huntStartingLocation' has a wrong offset!");
static_assert(offsetof(UGuardHuntComponent, _speedConsideredStuck) == 0x0002B0, "Member 'UGuardHuntComponent::_speedConsideredStuck' has a wrong offset!");
static_assert(offsetof(UGuardHuntComponent, _timeStuckToResetPathing) == 0x0002B4, "Member 'UGuardHuntComponent::_timeStuckToResetPathing' has a wrong offset!");

// Class TheK30.GuardPullSurvivorOutOfLocker
// 0x0080 (0x0830 - 0x07B0)
class UGuardPullSurvivorOutOfLocker final : public UBaseLockerInteraction
{
public:
	class ACamperPlayer*                          _targetSurvivor;                                   // 0x07A8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FAnimationMontageDescriptor            _healthySurvivorUpdateMontage;                     // 0x07B0(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FAnimationMontageDescriptor            _injuredSurvivorUpdateMontage;                     // 0x07D0(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _pullOutOfLockerDuration;                          // 0x07F0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	float                                         _snapPositionDistanceOnPullOutHealthy;             // 0x0818(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _snapTime;                                         // 0x081C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_820[0x10];                                     // 0x0820(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GuardPullSurvivorOutOfLocker">();
	}
	static class UGuardPullSurvivorOutOfLocker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGuardPullSurvivorOutOfLocker>();
	}
};
static_assert(alignof(UGuardPullSurvivorOutOfLocker) == 0x000010, "Wrong alignment on UGuardPullSurvivorOutOfLocker");
static_assert(sizeof(UGuardPullSurvivorOutOfLocker) == 0x000830, "Wrong size on UGuardPullSurvivorOutOfLocker");
static_assert(offsetof(UGuardPullSurvivorOutOfLocker, _targetSurvivor) == 0x0007A8, "Member 'UGuardPullSurvivorOutOfLocker::_targetSurvivor' has a wrong offset!");
static_assert(offsetof(UGuardPullSurvivorOutOfLocker, _healthySurvivorUpdateMontage) == 0x0007B0, "Member 'UGuardPullSurvivorOutOfLocker::_healthySurvivorUpdateMontage' has a wrong offset!");
static_assert(offsetof(UGuardPullSurvivorOutOfLocker, _injuredSurvivorUpdateMontage) == 0x0007D0, "Member 'UGuardPullSurvivorOutOfLocker::_injuredSurvivorUpdateMontage' has a wrong offset!");
static_assert(offsetof(UGuardPullSurvivorOutOfLocker, _pullOutOfLockerDuration) == 0x0007F0, "Member 'UGuardPullSurvivorOutOfLocker::_pullOutOfLockerDuration' has a wrong offset!");
static_assert(offsetof(UGuardPullSurvivorOutOfLocker, _snapPositionDistanceOnPullOutHealthy) == 0x000818, "Member 'UGuardPullSurvivorOutOfLocker::_snapPositionDistanceOnPullOutHealthy' has a wrong offset!");
static_assert(offsetof(UGuardPullSurvivorOutOfLocker, _snapTime) == 0x00081C, "Member 'UGuardPullSurvivorOutOfLocker::_snapTime' has a wrong offset!");

// Class TheK30.GuardHuntTeleport
// 0x0030 (0x07B0 - 0x0780)
class UGuardHuntTeleport final : public UInteractionDefinition
{
public:
	struct FDBDTunableRowHandle                   _huntStartUpDuration;                              // 0x0778(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _huntStartUpDurationPathLengthMultiplier;          // 0x07A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7A8[0x8];                                      // 0x07A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GuardHuntTeleport">();
	}
	static class UGuardHuntTeleport* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGuardHuntTeleport>();
	}
};
static_assert(alignof(UGuardHuntTeleport) == 0x000010, "Wrong alignment on UGuardHuntTeleport");
static_assert(sizeof(UGuardHuntTeleport) == 0x0007B0, "Wrong size on UGuardHuntTeleport");
static_assert(offsetof(UGuardHuntTeleport, _huntStartUpDuration) == 0x000778, "Member 'UGuardHuntTeleport::_huntStartUpDuration' has a wrong offset!");
static_assert(offsetof(UGuardHuntTeleport, _huntStartUpDurationPathLengthMultiplier) == 0x0007A0, "Member 'UGuardHuntTeleport::_huntStartUpDurationPathLengthMultiplier' has a wrong offset!");

// Class TheK30.NearUndestroyedPallet
// 0x0058 (0x0140 - 0x00E8)
class UNearUndestroyedPallet : public URangeBasedCondition
{
public:
	uint8                                         Pad_E8[0x58];                                      // 0x00E8(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NearUndestroyedPallet">();
	}
	static class UNearUndestroyedPallet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNearUndestroyedPallet>();
	}
};
static_assert(alignof(UNearUndestroyedPallet) == 0x000008, "Wrong alignment on UNearUndestroyedPallet");
static_assert(sizeof(UNearUndestroyedPallet) == 0x000140, "Wrong size on UNearUndestroyedPallet");

// Class TheK30.NearFallenPallet
// 0x0000 (0x0140 - 0x0140)
class UNearFallenPallet final : public UNearUndestroyedPallet
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NearFallenPallet">();
	}
	static class UNearFallenPallet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNearFallenPallet>();
	}
};
static_assert(alignof(UNearFallenPallet) == 0x000008, "Wrong alignment on UNearFallenPallet");
static_assert(sizeof(UNearFallenPallet) == 0x000140, "Wrong size on UNearFallenPallet");

// Class TheK30.GuardIdleComponent
// 0x0088 (0x0130 - 0x00A8)
class UGuardIdleComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x18];                                      // 0x00A8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UGuardVisionUpdater*                    _visionUpdater;                                    // 0x00C0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _canIdle;                                          // 0x00C8(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C9[0x7];                                       // 0x00C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _idleDuration;                                     // 0x00D0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F8[0x38];                                      // 0x00F8(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Multicast_OnIdleStarted();
	void Multicast_OnIdleStopped(EIdlePostStopOperation Operation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GuardIdleComponent">();
	}
	static class UGuardIdleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGuardIdleComponent>();
	}
};
static_assert(alignof(UGuardIdleComponent) == 0x000008, "Wrong alignment on UGuardIdleComponent");
static_assert(sizeof(UGuardIdleComponent) == 0x000130, "Wrong size on UGuardIdleComponent");
static_assert(offsetof(UGuardIdleComponent, _visionUpdater) == 0x0000C0, "Member 'UGuardIdleComponent::_visionUpdater' has a wrong offset!");
static_assert(offsetof(UGuardIdleComponent, _canIdle) == 0x0000C8, "Member 'UGuardIdleComponent::_canIdle' has a wrong offset!");
static_assert(offsetof(UGuardIdleComponent, _idleDuration) == 0x0000D0, "Member 'UGuardIdleComponent::_idleDuration' has a wrong offset!");

// Class TheK30.GuardInteractable
// 0x0008 (0x03E8 - 0x03E0)
class AGuardInteractable final : public APlayerInteractable
{
public:
	class UInteractionDefinition*                 _startHuntInteraction;                             // 0x03E0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GuardInteractable">();
	}
	static class AGuardInteractable* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGuardInteractable>();
	}
};
static_assert(alignof(AGuardInteractable) == 0x000008, "Wrong alignment on AGuardInteractable");
static_assert(sizeof(AGuardInteractable) == 0x0003E8, "Wrong size on AGuardInteractable");
static_assert(offsetof(AGuardInteractable, _startHuntInteraction) == 0x0003E0, "Member 'AGuardInteractable::_startHuntInteraction' has a wrong offset!");

// Class TheK30.GuardManagerComponent
// 0x0088 (0x0130 - 0x00A8)
class UGuardManagerComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x18];                                      // 0x00A8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGuardInstanceContainer>        _guardInstanceContainers;                          // 0x00C0(0x0010)(Net, ZeroConstructor, Transient, RepNotify, NativeAccessSpecifierPrivate)
	TMap<TSoftClassPtr<class UClass>, struct FTunableStat> _guardCooldownDurations;                           // 0x00D0(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class UGuardCatalog*                          _guardCatalog;                                     // 0x0120(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_128[0x8];                                      // 0x0128(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_Guards();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GuardManagerComponent">();
	}
	static class UGuardManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGuardManagerComponent>();
	}
};
static_assert(alignof(UGuardManagerComponent) == 0x000008, "Wrong alignment on UGuardManagerComponent");
static_assert(sizeof(UGuardManagerComponent) == 0x000130, "Wrong size on UGuardManagerComponent");
static_assert(offsetof(UGuardManagerComponent, _guardInstanceContainers) == 0x0000C0, "Member 'UGuardManagerComponent::_guardInstanceContainers' has a wrong offset!");
static_assert(offsetof(UGuardManagerComponent, _guardCooldownDurations) == 0x0000D0, "Member 'UGuardManagerComponent::_guardCooldownDurations' has a wrong offset!");
static_assert(offsetof(UGuardManagerComponent, _guardCatalog) == 0x000120, "Member 'UGuardManagerComponent::_guardCatalog' has a wrong offset!");

// Class TheK30.GuardOutlineUpdateStrategy
// 0x0010 (0x00E0 - 0x00D0)
class UGuardOutlineUpdateStrategy final : public UOutlineUpdateStrategy
{
public:
	struct FLinearColor                           _killerColor;                                      // 0x00D0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GuardOutlineUpdateStrategy">();
	}
	static class UGuardOutlineUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGuardOutlineUpdateStrategy>();
	}
};
static_assert(alignof(UGuardOutlineUpdateStrategy) == 0x000008, "Wrong alignment on UGuardOutlineUpdateStrategy");
static_assert(sizeof(UGuardOutlineUpdateStrategy) == 0x0000E0, "Wrong size on UGuardOutlineUpdateStrategy");
static_assert(offsetof(UGuardOutlineUpdateStrategy, _killerColor) == 0x0000D0, "Member 'UGuardOutlineUpdateStrategy::_killerColor' has a wrong offset!");

// Class TheK30.GuardPatrolComponent
// 0x0138 (0x01E0 - 0x00A8)
class UGuardPatrolComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x18];                                      // 0x00A8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	ETrailDirection                               _currentDirection;                                 // 0x00C0(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C1[0x3];                                       // 0x00C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _patrolPathLength;                                 // 0x00C4(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EPatrolState                                  _patrolState;                                      // 0x00C8(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C9[0x7];                                       // 0x00C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSpeedBasedNetSyncedValue              _patrolTimeLeft;                                   // 0x00D0(0x0038)(Net, NativeAccessSpecifierPrivate)
	float                                         _patrolTotalDuration;                              // 0x0108(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _distanceBeforeHeadingToNextNode;                  // 0x010C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _maxDetourLength;                                  // 0x0110(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_114[0x4];                                      // 0x0114(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTunableStat                           _patrolDuration;                                   // 0x0118(0x0080)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class UGuardVisionUpdater*                    _visionUpdater;                                    // 0x0198(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1A0[0x40];                                     // 0x01A0(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_PatrolState();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GuardPatrolComponent">();
	}
	static class UGuardPatrolComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGuardPatrolComponent>();
	}
};
static_assert(alignof(UGuardPatrolComponent) == 0x000008, "Wrong alignment on UGuardPatrolComponent");
static_assert(sizeof(UGuardPatrolComponent) == 0x0001E0, "Wrong size on UGuardPatrolComponent");
static_assert(offsetof(UGuardPatrolComponent, _currentDirection) == 0x0000C0, "Member 'UGuardPatrolComponent::_currentDirection' has a wrong offset!");
static_assert(offsetof(UGuardPatrolComponent, _patrolPathLength) == 0x0000C4, "Member 'UGuardPatrolComponent::_patrolPathLength' has a wrong offset!");
static_assert(offsetof(UGuardPatrolComponent, _patrolState) == 0x0000C8, "Member 'UGuardPatrolComponent::_patrolState' has a wrong offset!");
static_assert(offsetof(UGuardPatrolComponent, _patrolTimeLeft) == 0x0000D0, "Member 'UGuardPatrolComponent::_patrolTimeLeft' has a wrong offset!");
static_assert(offsetof(UGuardPatrolComponent, _patrolTotalDuration) == 0x000108, "Member 'UGuardPatrolComponent::_patrolTotalDuration' has a wrong offset!");
static_assert(offsetof(UGuardPatrolComponent, _distanceBeforeHeadingToNextNode) == 0x00010C, "Member 'UGuardPatrolComponent::_distanceBeforeHeadingToNextNode' has a wrong offset!");
static_assert(offsetof(UGuardPatrolComponent, _maxDetourLength) == 0x000110, "Member 'UGuardPatrolComponent::_maxDetourLength' has a wrong offset!");
static_assert(offsetof(UGuardPatrolComponent, _patrolDuration) == 0x000118, "Member 'UGuardPatrolComponent::_patrolDuration' has a wrong offset!");
static_assert(offsetof(UGuardPatrolComponent, _visionUpdater) == 0x000198, "Member 'UGuardPatrolComponent::_visionUpdater' has a wrong offset!");

// Class TheK30.GuardSlowingZone
// 0x0000 (0x02A0 - 0x02A0)
class AGuardSlowingZone : public AActor
{
public:
	void OnZoneBeginOverlap(class AActor* OverlappedActor, class AActor* OtherActor);
	void OnZoneEndOverlap(class AActor* OverlappedActor, class AActor* OtherActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GuardSlowingZone">();
	}
	static class AGuardSlowingZone* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGuardSlowingZone>();
	}
};
static_assert(alignof(AGuardSlowingZone) == 0x000008, "Wrong alignment on AGuardSlowingZone");
static_assert(sizeof(AGuardSlowingZone) == 0x0002A0, "Wrong size on AGuardSlowingZone");

// Class TheK30.GuardPalletSlowingZone
// 0x0008 (0x02A8 - 0x02A0)
class AGuardPalletSlowingZone final : public AGuardSlowingZone
{
public:
	class APallet*                                _linkedPallet;                                     // 0x02A0(0x0008)(Net, ZeroConstructor, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnRep_LinkedPallet();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GuardPalletSlowingZone">();
	}
	static class AGuardPalletSlowingZone* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGuardPalletSlowingZone>();
	}
};
static_assert(alignof(AGuardPalletSlowingZone) == 0x000008, "Wrong alignment on AGuardPalletSlowingZone");
static_assert(sizeof(AGuardPalletSlowingZone) == 0x0002A8, "Wrong size on AGuardPalletSlowingZone");
static_assert(offsetof(AGuardPalletSlowingZone, _linkedPallet) == 0x0002A0, "Member 'AGuardPalletSlowingZone::_linkedPallet' has a wrong offset!");

// Class TheK30.GuardSlowingZoneComponent
// 0x0018 (0x00C0 - 0x00A8)
class UGuardSlowingZoneComponent final : public UActorComponent
{
public:
	TSubclassOf<class AGuardPalletSlowingZone>    _palletSlowingZoneClass;                           // 0x00A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class AGuardSlowingZone>          _vaultSlowingZoneClass;                            // 0x00B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GuardSlowingZoneComponent">();
	}
	static class UGuardSlowingZoneComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGuardSlowingZoneComponent>();
	}
};
static_assert(alignof(UGuardSlowingZoneComponent) == 0x000008, "Wrong alignment on UGuardSlowingZoneComponent");
static_assert(sizeof(UGuardSlowingZoneComponent) == 0x0000C0, "Wrong size on UGuardSlowingZoneComponent");
static_assert(offsetof(UGuardSlowingZoneComponent, _palletSlowingZoneClass) == 0x0000A8, "Member 'UGuardSlowingZoneComponent::_palletSlowingZoneClass' has a wrong offset!");
static_assert(offsetof(UGuardSlowingZoneComponent, _vaultSlowingZoneClass) == 0x0000B0, "Member 'UGuardSlowingZoneComponent::_vaultSlowingZoneClass' has a wrong offset!");

// Class TheK30.GuardVisionUpdater
// 0x01B8 (0x01E8 - 0x0030)
class UGuardVisionUpdater final : public UObject
{
public:
	uint8                                         Pad_30[0x20];                                      // 0x0030(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _startVisionRange;                                 // 0x0050(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _startVisionAngle;                                 // 0x0078(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _delay;                                            // 0x00A0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _interpolateVisionRangeDuration;                   // 0x00C8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _interpolateDurationMultiplierCurve;               // 0x00F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _endVisionRangeMultiplierCurve;                    // 0x00F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _endVisionAngle;                                   // 0x0100(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _endVisionRange;                                   // 0x0128(0x0080)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1A8[0x40];                                     // 0x01A8(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GuardVisionUpdater">();
	}
	static class UGuardVisionUpdater* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGuardVisionUpdater>();
	}
};
static_assert(alignof(UGuardVisionUpdater) == 0x000008, "Wrong alignment on UGuardVisionUpdater");
static_assert(sizeof(UGuardVisionUpdater) == 0x0001E8, "Wrong size on UGuardVisionUpdater");
static_assert(offsetof(UGuardVisionUpdater, _startVisionRange) == 0x000050, "Member 'UGuardVisionUpdater::_startVisionRange' has a wrong offset!");
static_assert(offsetof(UGuardVisionUpdater, _startVisionAngle) == 0x000078, "Member 'UGuardVisionUpdater::_startVisionAngle' has a wrong offset!");
static_assert(offsetof(UGuardVisionUpdater, _delay) == 0x0000A0, "Member 'UGuardVisionUpdater::_delay' has a wrong offset!");
static_assert(offsetof(UGuardVisionUpdater, _interpolateVisionRangeDuration) == 0x0000C8, "Member 'UGuardVisionUpdater::_interpolateVisionRangeDuration' has a wrong offset!");
static_assert(offsetof(UGuardVisionUpdater, _interpolateDurationMultiplierCurve) == 0x0000F0, "Member 'UGuardVisionUpdater::_interpolateDurationMultiplierCurve' has a wrong offset!");
static_assert(offsetof(UGuardVisionUpdater, _endVisionRangeMultiplierCurve) == 0x0000F8, "Member 'UGuardVisionUpdater::_endVisionRangeMultiplierCurve' has a wrong offset!");
static_assert(offsetof(UGuardVisionUpdater, _endVisionAngle) == 0x000100, "Member 'UGuardVisionUpdater::_endVisionAngle' has a wrong offset!");
static_assert(offsetof(UGuardVisionUpdater, _endVisionRange) == 0x000128, "Member 'UGuardVisionUpdater::_endVisionRange' has a wrong offset!");

// Class TheK30.K30Addon14
// 0x0088 (0x0370 - 0x02E8)
class UK30Addon14 final : public UItemAddon
{
public:
	struct FStatusEffectApplier                   _statusEffectApplier;                              // 0x02E8(0x0070)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FGuardAddedProxy                       _guardAddedProxy;                                  // 0x0358(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K30Addon14">();
	}
	static class UK30Addon14* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK30Addon14>();
	}
};
static_assert(alignof(UK30Addon14) == 0x000008, "Wrong alignment on UK30Addon14");
static_assert(sizeof(UK30Addon14) == 0x000370, "Wrong size on UK30Addon14");
static_assert(offsetof(UK30Addon14, _statusEffectApplier) == 0x0002E8, "Member 'UK30Addon14::_statusEffectApplier' has a wrong offset!");
static_assert(offsetof(UK30Addon14, _guardAddedProxy) == 0x000358, "Member 'UK30Addon14::_guardAddedProxy' has a wrong offset!");

// Class TheK30.K30Addon16
// 0x0088 (0x0370 - 0x02E8)
class UK30Addon16 final : public UItemAddon
{
public:
	struct FStatusEffectApplier                   _statusEffectApplier;                              // 0x02E8(0x0070)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FGuardAddedProxy                       _guardAddedProxy;                                  // 0x0358(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K30Addon16">();
	}
	static class UK30Addon16* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK30Addon16>();
	}
};
static_assert(alignof(UK30Addon16) == 0x000008, "Wrong alignment on UK30Addon16");
static_assert(sizeof(UK30Addon16) == 0x000370, "Wrong size on UK30Addon16");
static_assert(offsetof(UK30Addon16, _statusEffectApplier) == 0x0002E8, "Member 'UK30Addon16::_statusEffectApplier' has a wrong offset!");
static_assert(offsetof(UK30Addon16, _guardAddedProxy) == 0x000358, "Member 'UK30Addon16::_guardAddedProxy' has a wrong offset!");

// Class TheK30.K30Addon17
// 0x0098 (0x0380 - 0x02E8)
class UK30Addon17 final : public UItemAddon
{
public:
	float                                         _requiredDistance;                                 // 0x02E8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2EC[0x4];                                      // 0x02EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGuardAddedProxy                       _guardAddedProxy;                                  // 0x02F0(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FStatusEffectApplier                   _statusEffectApplier;                              // 0x0308(0x0070)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_378[0x8];                                      // 0x0378(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K30Addon17">();
	}
	static class UK30Addon17* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK30Addon17>();
	}
};
static_assert(alignof(UK30Addon17) == 0x000008, "Wrong alignment on UK30Addon17");
static_assert(sizeof(UK30Addon17) == 0x000380, "Wrong size on UK30Addon17");
static_assert(offsetof(UK30Addon17, _requiredDistance) == 0x0002E8, "Member 'UK30Addon17::_requiredDistance' has a wrong offset!");
static_assert(offsetof(UK30Addon17, _guardAddedProxy) == 0x0002F0, "Member 'UK30Addon17::_guardAddedProxy' has a wrong offset!");
static_assert(offsetof(UK30Addon17, _statusEffectApplier) == 0x000308, "Member 'UK30Addon17::_statusEffectApplier' has a wrong offset!");

// Class TheK30.K30Addon18
// 0x0088 (0x0370 - 0x02E8)
class UK30Addon18 final : public UItemAddon
{
public:
	TSubclassOf<class UStatusEffect>              _overlapStatusEffectClass;                         // 0x02E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _lifetimePostApplication;                          // 0x02F0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FCollisionProfileName                  _collisionProfileName;                             // 0x02F4(0x000C)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	struct FGuardAddedProxy                       _guardAddedProxy;                                  // 0x0300(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TMap<class ACamperPlayer*, class UStatusEffect*> _appliedStatusEffects;                             // 0x0318(0x0050)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_368[0x8];                                      // 0x0368(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnSplineBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void Authority_OnSplineEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K30Addon18">();
	}
	static class UK30Addon18* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK30Addon18>();
	}
};
static_assert(alignof(UK30Addon18) == 0x000008, "Wrong alignment on UK30Addon18");
static_assert(sizeof(UK30Addon18) == 0x000370, "Wrong size on UK30Addon18");
static_assert(offsetof(UK30Addon18, _overlapStatusEffectClass) == 0x0002E8, "Member 'UK30Addon18::_overlapStatusEffectClass' has a wrong offset!");
static_assert(offsetof(UK30Addon18, _lifetimePostApplication) == 0x0002F0, "Member 'UK30Addon18::_lifetimePostApplication' has a wrong offset!");
static_assert(offsetof(UK30Addon18, _collisionProfileName) == 0x0002F4, "Member 'UK30Addon18::_collisionProfileName' has a wrong offset!");
static_assert(offsetof(UK30Addon18, _guardAddedProxy) == 0x000300, "Member 'UK30Addon18::_guardAddedProxy' has a wrong offset!");
static_assert(offsetof(UK30Addon18, _appliedStatusEffects) == 0x000318, "Member 'UK30Addon18::_appliedStatusEffects' has a wrong offset!");

// Class TheK30.K30Addon19
// 0x0018 (0x0300 - 0x02E8)
class UK30Addon19 final : public UItemAddon
{
public:
	struct FGuardAddedProxy                       _guardAddedProxy;                                  // 0x02E8(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K30Addon19">();
	}
	static class UK30Addon19* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK30Addon19>();
	}
};
static_assert(alignof(UK30Addon19) == 0x000008, "Wrong alignment on UK30Addon19");
static_assert(sizeof(UK30Addon19) == 0x000300, "Wrong size on UK30Addon19");
static_assert(offsetof(UK30Addon19, _guardAddedProxy) == 0x0002E8, "Member 'UK30Addon19::_guardAddedProxy' has a wrong offset!");

// Class TheK30.K30Addon20
// 0x0090 (0x0378 - 0x02E8)
class UK30Addon20 final : public UItemAddon
{
public:
	uint8                                         Pad_2E8[0x8];                                      // 0x02E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AWindow*>                        _blockedWindows;                                   // 0x02F0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _gateBlockerEffectClass;                           // 0x0300(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _trailPassThroughWindowBlockTime;                  // 0x0308(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_30C[0x4];                                      // 0x030C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGuardAddedProxy                       _guardAddedProxy;                                  // 0x0310(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TMap<class ACamperPlayer*, class UStatusEffect*> _playerGateBlockerStatusEffects;                   // 0x0328(0x0050)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	void Authority_OnPowerStateChanged(EPowerState PreviousState, EPowerState NewState);
	void OnEndOverlapWindow(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K30Addon20">();
	}
	static class UK30Addon20* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK30Addon20>();
	}
};
static_assert(alignof(UK30Addon20) == 0x000008, "Wrong alignment on UK30Addon20");
static_assert(sizeof(UK30Addon20) == 0x000378, "Wrong size on UK30Addon20");
static_assert(offsetof(UK30Addon20, _blockedWindows) == 0x0002F0, "Member 'UK30Addon20::_blockedWindows' has a wrong offset!");
static_assert(offsetof(UK30Addon20, _gateBlockerEffectClass) == 0x000300, "Member 'UK30Addon20::_gateBlockerEffectClass' has a wrong offset!");
static_assert(offsetof(UK30Addon20, _trailPassThroughWindowBlockTime) == 0x000308, "Member 'UK30Addon20::_trailPassThroughWindowBlockTime' has a wrong offset!");
static_assert(offsetof(UK30Addon20, _guardAddedProxy) == 0x000310, "Member 'UK30Addon20::_guardAddedProxy' has a wrong offset!");
static_assert(offsetof(UK30Addon20, _playerGateBlockerStatusEffects) == 0x000328, "Member 'UK30Addon20::_playerGateBlockerStatusEffects' has a wrong offset!");

// Class TheK30.K30AnimInstance
// 0x0010 (0x0730 - 0x0720)
class UK30AnimInstance final : public UKillerAnimInstance
{
public:
	bool                                          _isChargingPower;                                  // 0x0720(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isSnapping;                                       // 0x0721(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isDrawingPath;                                    // 0x0722(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_723[0xD];                                      // 0x0723(0x000D)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K30AnimInstance">();
	}
	static class UK30AnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK30AnimInstance>();
	}
};
static_assert(alignof(UK30AnimInstance) == 0x000010, "Wrong alignment on UK30AnimInstance");
static_assert(sizeof(UK30AnimInstance) == 0x000730, "Wrong size on UK30AnimInstance");
static_assert(offsetof(UK30AnimInstance, _isChargingPower) == 0x000720, "Member 'UK30AnimInstance::_isChargingPower' has a wrong offset!");
static_assert(offsetof(UK30AnimInstance, _isSnapping) == 0x000721, "Member 'UK30AnimInstance::_isSnapping' has a wrong offset!");
static_assert(offsetof(UK30AnimInstance, _isDrawingPath) == 0x000722, "Member 'UK30AnimInstance::_isDrawingPath' has a wrong offset!");

// Class TheK30.K30CheatComponent
// 0x0008 (0x00B0 - 0x00A8)
class UK30CheatComponent final : public UDLCCheatComponent
{
public:
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DBD_K30SetPatrolAndHuntDuration(float Seconds);
	void DBD_K30ToggleGuardAttackDespawn(int32 DespawnOnAttack);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K30CheatComponent">();
	}
	static class UK30CheatComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK30CheatComponent>();
	}
};
static_assert(alignof(UK30CheatComponent) == 0x000008, "Wrong alignment on UK30CheatComponent");
static_assert(sizeof(UK30CheatComponent) == 0x0000B0, "Wrong size on UK30CheatComponent");

// Class TheK30.K30GuardUtilities
// 0x0000 (0x0030 - 0x0030)
class UK30GuardUtilities final : public UBlueprintFunctionLibrary
{
public:
	static float GetMaximumHuntDuration(const class AKnightGuard* Guard);
	static float GetPatrolDuration(const class AKnightGuard* Guard);
	static float GetPatrollingVisionRangeBaseValue(const class AKnightGuard* Guard);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K30GuardUtilities">();
	}
	static class UK30GuardUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK30GuardUtilities>();
	}
};
static_assert(alignof(UK30GuardUtilities) == 0x000008, "Wrong alignment on UK30GuardUtilities");
static_assert(sizeof(UK30GuardUtilities) == 0x000030, "Wrong size on UK30GuardUtilities");

// Class TheK30.K30HugCosmeticHandler
// 0x00C0 (0x0360 - 0x02A0)
class alignas(0x10) AK30HugCosmeticHandler final : public AActor
{
public:
	class UVaultableComponent*                    _linkedVaultable;                                  // 0x02A0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ACamperPlayer*                          _instigator;                                       // 0x02A8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBoxComponent*                          _box;                                              // 0x02B0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _hugMaximumDuration;                               // 0x02B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2BC[0xA4];                                     // 0x02BC(0x00A4)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_Hug(bool IsHugging, class AActor* VaultableOwner, class ACamperPlayer* HugInstigator);
	void OnBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnVault(class ADBDPlayer* Vaulter);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K30HugCosmeticHandler">();
	}
	static class AK30HugCosmeticHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK30HugCosmeticHandler>();
	}
};
static_assert(alignof(AK30HugCosmeticHandler) == 0x000010, "Wrong alignment on AK30HugCosmeticHandler");
static_assert(sizeof(AK30HugCosmeticHandler) == 0x000360, "Wrong size on AK30HugCosmeticHandler");
static_assert(offsetof(AK30HugCosmeticHandler, _linkedVaultable) == 0x0002A0, "Member 'AK30HugCosmeticHandler::_linkedVaultable' has a wrong offset!");
static_assert(offsetof(AK30HugCosmeticHandler, _instigator) == 0x0002A8, "Member 'AK30HugCosmeticHandler::_instigator' has a wrong offset!");
static_assert(offsetof(AK30HugCosmeticHandler, _box) == 0x0002B0, "Member 'AK30HugCosmeticHandler::_box' has a wrong offset!");
static_assert(offsetof(AK30HugCosmeticHandler, _hugMaximumDuration) == 0x0002B8, "Member 'AK30HugCosmeticHandler::_hugMaximumDuration' has a wrong offset!");

// Class TheK30.K30HugSpawnerComponent
// 0x0028 (0x00D0 - 0x00A8)
class UK30HugSpawnerComponent final : public UActorComponent
{
public:
	TSubclassOf<class AK30HugCosmeticHandler>     _windowHugCosmeticHandlerClass;                    // 0x00A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class AK30HugCosmeticHandler>     _palletHugCosmeticHandlerClass;                    // 0x00B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class AK30HugCosmeticHandler*>         _hugCosmeticHandlers;                              // 0x00B8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C8[0x8];                                       // 0x00C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K30HugSpawnerComponent">();
	}
	static class UK30HugSpawnerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK30HugSpawnerComponent>();
	}
};
static_assert(alignof(UK30HugSpawnerComponent) == 0x000008, "Wrong alignment on UK30HugSpawnerComponent");
static_assert(sizeof(UK30HugSpawnerComponent) == 0x0000D0, "Wrong size on UK30HugSpawnerComponent");
static_assert(offsetof(UK30HugSpawnerComponent, _windowHugCosmeticHandlerClass) == 0x0000A8, "Member 'UK30HugSpawnerComponent::_windowHugCosmeticHandlerClass' has a wrong offset!");
static_assert(offsetof(UK30HugSpawnerComponent, _palletHugCosmeticHandlerClass) == 0x0000B0, "Member 'UK30HugSpawnerComponent::_palletHugCosmeticHandlerClass' has a wrong offset!");
static_assert(offsetof(UK30HugSpawnerComponent, _hugCosmeticHandlers) == 0x0000B8, "Member 'UK30HugSpawnerComponent::_hugCosmeticHandlers' has a wrong offset!");

// Class TheK30.K30InflictSelfStatusOnGuardSummonAddon
// 0x0088 (0x0370 - 0x02E8)
class UK30InflictSelfStatusOnGuardSummonAddon final : public UItemAddon
{
public:
	struct FStatusEffectApplier                   _statusEffectApplier;                              // 0x02E8(0x0070)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FGuardAddedProxy                       _guardAddedProxy;                                  // 0x0358(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K30InflictSelfStatusOnGuardSummonAddon">();
	}
	static class UK30InflictSelfStatusOnGuardSummonAddon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK30InflictSelfStatusOnGuardSummonAddon>();
	}
};
static_assert(alignof(UK30InflictSelfStatusOnGuardSummonAddon) == 0x000008, "Wrong alignment on UK30InflictSelfStatusOnGuardSummonAddon");
static_assert(sizeof(UK30InflictSelfStatusOnGuardSummonAddon) == 0x000370, "Wrong size on UK30InflictSelfStatusOnGuardSummonAddon");
static_assert(offsetof(UK30InflictSelfStatusOnGuardSummonAddon, _statusEffectApplier) == 0x0002E8, "Member 'UK30InflictSelfStatusOnGuardSummonAddon::_statusEffectApplier' has a wrong offset!");
static_assert(offsetof(UK30InflictSelfStatusOnGuardSummonAddon, _guardAddedProxy) == 0x000358, "Member 'UK30InflictSelfStatusOnGuardSummonAddon::_guardAddedProxy' has a wrong offset!");

// Class TheK30.K30InflictStatusOnDetectedAddon
// 0x0088 (0x0370 - 0x02E8)
class UK30InflictStatusOnDetectedAddon final : public UItemAddon
{
public:
	struct FStatusEffectApplier                   _statusEffectApplier;                              // 0x02E8(0x0070)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FGuardAddedProxy                       _guardAddedProxy;                                  // 0x0358(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K30InflictStatusOnDetectedAddon">();
	}
	static class UK30InflictStatusOnDetectedAddon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK30InflictStatusOnDetectedAddon>();
	}
};
static_assert(alignof(UK30InflictStatusOnDetectedAddon) == 0x000008, "Wrong alignment on UK30InflictStatusOnDetectedAddon");
static_assert(sizeof(UK30InflictStatusOnDetectedAddon) == 0x000370, "Wrong size on UK30InflictStatusOnDetectedAddon");
static_assert(offsetof(UK30InflictStatusOnDetectedAddon, _statusEffectApplier) == 0x0002E8, "Member 'UK30InflictStatusOnDetectedAddon::_statusEffectApplier' has a wrong offset!");
static_assert(offsetof(UK30InflictStatusOnDetectedAddon, _guardAddedProxy) == 0x000358, "Member 'UK30InflictStatusOnDetectedAddon::_guardAddedProxy' has a wrong offset!");

// Class TheK30.K30InflictStatusOnEndHuntAddon
// 0x0098 (0x0380 - 0x02E8)
class UK30InflictStatusOnEndHuntAddon final : public UItemAddon
{
public:
	TArray<EGuardHuntEndReason>                   _huntEndReasonsToApplyEffect;                      // 0x02E8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FStatusEffectApplier                   _statusEffectApplier;                              // 0x02F8(0x0070)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FGuardAddedProxy                       _guardAddedProxy;                                  // 0x0368(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K30InflictStatusOnEndHuntAddon">();
	}
	static class UK30InflictStatusOnEndHuntAddon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK30InflictStatusOnEndHuntAddon>();
	}
};
static_assert(alignof(UK30InflictStatusOnEndHuntAddon) == 0x000008, "Wrong alignment on UK30InflictStatusOnEndHuntAddon");
static_assert(sizeof(UK30InflictStatusOnEndHuntAddon) == 0x000380, "Wrong size on UK30InflictStatusOnEndHuntAddon");
static_assert(offsetof(UK30InflictStatusOnEndHuntAddon, _huntEndReasonsToApplyEffect) == 0x0002E8, "Member 'UK30InflictStatusOnEndHuntAddon::_huntEndReasonsToApplyEffect' has a wrong offset!");
static_assert(offsetof(UK30InflictStatusOnEndHuntAddon, _statusEffectApplier) == 0x0002F8, "Member 'UK30InflictStatusOnEndHuntAddon::_statusEffectApplier' has a wrong offset!");
static_assert(offsetof(UK30InflictStatusOnEndHuntAddon, _guardAddedProxy) == 0x000368, "Member 'UK30InflictStatusOnEndHuntAddon::_guardAddedProxy' has a wrong offset!");

// Class TheK30.K30InflictStatusOnGuardHitAddon
// 0x0088 (0x0370 - 0x02E8)
class UK30InflictStatusOnGuardHitAddon final : public UItemAddon
{
public:
	struct FStatusEffectApplier                   _statusEffectApplier;                              // 0x02E8(0x0070)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FGuardAddedProxy                       _guardAddedProxy;                                  // 0x0358(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K30InflictStatusOnGuardHitAddon">();
	}
	static class UK30InflictStatusOnGuardHitAddon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK30InflictStatusOnGuardHitAddon>();
	}
};
static_assert(alignof(UK30InflictStatusOnGuardHitAddon) == 0x000008, "Wrong alignment on UK30InflictStatusOnGuardHitAddon");
static_assert(sizeof(UK30InflictStatusOnGuardHitAddon) == 0x000370, "Wrong size on UK30InflictStatusOnGuardHitAddon");
static_assert(offsetof(UK30InflictStatusOnGuardHitAddon, _statusEffectApplier) == 0x0002E8, "Member 'UK30InflictStatusOnGuardHitAddon::_statusEffectApplier' has a wrong offset!");
static_assert(offsetof(UK30InflictStatusOnGuardHitAddon, _guardAddedProxy) == 0x000358, "Member 'UK30InflictStatusOnGuardHitAddon::_guardAddedProxy' has a wrong offset!");

// Class TheK30.K30KnightHuskOutlineUpdateStrategy
// 0x0038 (0x0108 - 0x00D0)
class UK30KnightHuskOutlineUpdateStrategy final : public UOutlineUpdateStrategy
{
public:
	uint8                                         Pad_D0[0x38];                                      // 0x00D0(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K30KnightHuskOutlineUpdateStrategy">();
	}
	static class UK30KnightHuskOutlineUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK30KnightHuskOutlineUpdateStrategy>();
	}
};
static_assert(alignof(UK30KnightHuskOutlineUpdateStrategy) == 0x000008, "Wrong alignment on UK30KnightHuskOutlineUpdateStrategy");
static_assert(sizeof(UK30KnightHuskOutlineUpdateStrategy) == 0x000108, "Wrong size on UK30KnightHuskOutlineUpdateStrategy");

// Class TheK30.K30P01
// 0x0020 (0x0440 - 0x0420)
class UK30P01 final : public UPerk
{
public:
	float                                         _revealRange;                                      // 0x0420(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_424[0x4];                                      // 0x0424(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UStatusEffect>              _revealToKillerEffectClass;                        // 0x0428(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _revealDuration[0x3];                              // 0x0430(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_43C[0x4];                                      // 0x043C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K30P01">();
	}
	static class UK30P01* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK30P01>();
	}
};
static_assert(alignof(UK30P01) == 0x000008, "Wrong alignment on UK30P01");
static_assert(sizeof(UK30P01) == 0x000440, "Wrong size on UK30P01");
static_assert(offsetof(UK30P01, _revealRange) == 0x000420, "Member 'UK30P01::_revealRange' has a wrong offset!");
static_assert(offsetof(UK30P01, _revealToKillerEffectClass) == 0x000428, "Member 'UK30P01::_revealToKillerEffectClass' has a wrong offset!");
static_assert(offsetof(UK30P01, _revealDuration) == 0x000430, "Member 'UK30P01::_revealDuration' has a wrong offset!");

// Class TheK30.K30P02
// 0x0040 (0x04E0 - 0x04A0)
class UK30P02 final : public UHexPerk
{
public:
	class ADBDPlayer*                             _cursedPlayer;                                     // 0x04A0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UStatusEffect*>                  _activeStatusEffects;                              // 0x04A8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _screamEffectClass;                                // 0x04B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _screamLoudNoiseDuration;                          // 0x04C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4C4[0x4];                                      // 0x04C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UStatusEffect>              _screamRevealAuraToKillerEffectClass;              // 0x04C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _screamRevealAuraToKillerDuration;                 // 0x04D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _screamInterval[0x3];                              // 0x04D4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Authority_OnSurvivorFirstScream(class ADBDPlayer* Player);
	void Authority_OnTotemStateChanged(const ETotemState OldState, const ETotemState NewState);
	void Authority_UncursePlayer();

	const float GetScreamInterval() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K30P02">();
	}
	static class UK30P02* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK30P02>();
	}
};
static_assert(alignof(UK30P02) == 0x000008, "Wrong alignment on UK30P02");
static_assert(sizeof(UK30P02) == 0x0004E0, "Wrong size on UK30P02");
static_assert(offsetof(UK30P02, _cursedPlayer) == 0x0004A0, "Member 'UK30P02::_cursedPlayer' has a wrong offset!");
static_assert(offsetof(UK30P02, _activeStatusEffects) == 0x0004A8, "Member 'UK30P02::_activeStatusEffects' has a wrong offset!");
static_assert(offsetof(UK30P02, _screamEffectClass) == 0x0004B8, "Member 'UK30P02::_screamEffectClass' has a wrong offset!");
static_assert(offsetof(UK30P02, _screamLoudNoiseDuration) == 0x0004C0, "Member 'UK30P02::_screamLoudNoiseDuration' has a wrong offset!");
static_assert(offsetof(UK30P02, _screamRevealAuraToKillerEffectClass) == 0x0004C8, "Member 'UK30P02::_screamRevealAuraToKillerEffectClass' has a wrong offset!");
static_assert(offsetof(UK30P02, _screamRevealAuraToKillerDuration) == 0x0004D0, "Member 'UK30P02::_screamRevealAuraToKillerDuration' has a wrong offset!");
static_assert(offsetof(UK30P02, _screamInterval) == 0x0004D4, "Member 'UK30P02::_screamInterval' has a wrong offset!");

// Class TheK30.K30P02ScreamStatusEffect
// 0x0080 (0x0400 - 0x0380)
class UK30P02ScreamStatusEffect final : public UStatusEffect
{
public:
	uint8                                         Pad_380[0x28];                                     // 0x0380(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UStatusEffect>              _screamingPlayerRevealAuraEffectClass;             // 0x03A8(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTagContainer                  _screamPreventingTags;                             // 0x03B0(0x0020)(Edit, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3D0[0x30];                                     // 0x03D0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Multicast_MakePlayerScream(const float ScreamRevealDuration);

	float GetTimerDuration() const;
	float GetTimerRemainingTime() const;
	bool IsTimerActive() const;
	bool IsTimerPaused() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K30P02ScreamStatusEffect">();
	}
	static class UK30P02ScreamStatusEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK30P02ScreamStatusEffect>();
	}
};
static_assert(alignof(UK30P02ScreamStatusEffect) == 0x000008, "Wrong alignment on UK30P02ScreamStatusEffect");
static_assert(sizeof(UK30P02ScreamStatusEffect) == 0x000400, "Wrong size on UK30P02ScreamStatusEffect");
static_assert(offsetof(UK30P02ScreamStatusEffect, _screamingPlayerRevealAuraEffectClass) == 0x0003A8, "Member 'UK30P02ScreamStatusEffect::_screamingPlayerRevealAuraEffectClass' has a wrong offset!");
static_assert(offsetof(UK30P02ScreamStatusEffect, _screamPreventingTags) == 0x0003B0, "Member 'UK30P02ScreamStatusEffect::_screamPreventingTags' has a wrong offset!");

// Class TheK30.K30P03
// 0x0010 (0x0430 - 0x0420)
class UK30P03 final : public UPerk
{
public:
	TSubclassOf<class UStatusEffect>              _exposedEffectClass;                               // 0x0420(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _cooldownTime;                                     // 0x0428(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_42C[0x4];                                      // 0x042C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K30P03">();
	}
	static class UK30P03* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK30P03>();
	}
};
static_assert(alignof(UK30P03) == 0x000008, "Wrong alignment on UK30P03");
static_assert(sizeof(UK30P03) == 0x000430, "Wrong size on UK30P03");
static_assert(offsetof(UK30P03, _exposedEffectClass) == 0x000420, "Member 'UK30P03::_exposedEffectClass' has a wrong offset!");
static_assert(offsetof(UK30P03, _cooldownTime) == 0x000428, "Member 'UK30P03::_cooldownTime' has a wrong offset!");

// Class TheK30.K30PowerPresentationComponent
// 0x0000 (0x00B0 - 0x00B0)
class UK30PowerPresentationComponent final : public UPresentationItemProgressComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K30PowerPresentationComponent">();
	}
	static class UK30PowerPresentationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK30PowerPresentationComponent>();
	}
};
static_assert(alignof(UK30PowerPresentationComponent) == 0x000008, "Wrong alignment on UK30PowerPresentationComponent");
static_assert(sizeof(UK30PowerPresentationComponent) == 0x0000B0, "Wrong size on UK30PowerPresentationComponent");

// Class TheK30.K30PresentationPowerFadeComponent
// 0x0000 (0x00A8 - 0x00A8)
class UK30PresentationPowerFadeComponent final : public UPresentationPowerFadeComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K30PresentationPowerFadeComponent">();
	}
	static class UK30PresentationPowerFadeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK30PresentationPowerFadeComponent>();
	}
};
static_assert(alignof(UK30PresentationPowerFadeComponent) == 0x000008, "Wrong alignment on UK30PresentationPowerFadeComponent");
static_assert(sizeof(UK30PresentationPowerFadeComponent) == 0x0000A8, "Wrong size on UK30PresentationPowerFadeComponent");

// Class TheK30.K30SurvivorCosmeticHelperActor
// 0x0040 (0x0348 - 0x0308)
class AK30SurvivorCosmeticHelperActor final : public ASurvivorCosmeticHelperActor
{
public:
	struct FGuardAddedProxy                       _guardAddedProxy;                                  // 0x0308(0x0018)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_320[0x28];                                     // 0x0320(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_OnHuntBegin(const class AKnightGuard* Guard);
	void Cosmetic_OnHuntEnd();
	void Cosmetic_OnSurvivorCaptureFlagBuffActivationStateChanged(bool IsFlagCaptureBuffActive);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K30SurvivorCosmeticHelperActor">();
	}
	static class AK30SurvivorCosmeticHelperActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK30SurvivorCosmeticHelperActor>();
	}
};
static_assert(alignof(AK30SurvivorCosmeticHelperActor) == 0x000008, "Wrong alignment on AK30SurvivorCosmeticHelperActor");
static_assert(sizeof(AK30SurvivorCosmeticHelperActor) == 0x000348, "Wrong size on AK30SurvivorCosmeticHelperActor");
static_assert(offsetof(AK30SurvivorCosmeticHelperActor, _guardAddedProxy) == 0x000308, "Member 'AK30SurvivorCosmeticHelperActor::_guardAddedProxy' has a wrong offset!");

// Class TheK30.K30SurvivorStatusComponent
// 0x0028 (0x00D0 - 0x00A8)
class UK30SurvivorStatusComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x10];                                      // 0x00A8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGuardAddedProxy                       _guardAddedProxy;                                  // 0x00B8(0x0018)(Transient, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K30SurvivorStatusComponent">();
	}
	static class UK30SurvivorStatusComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK30SurvivorStatusComponent>();
	}
};
static_assert(alignof(UK30SurvivorStatusComponent) == 0x000008, "Wrong alignment on UK30SurvivorStatusComponent");
static_assert(sizeof(UK30SurvivorStatusComponent) == 0x0000D0, "Wrong size on UK30SurvivorStatusComponent");
static_assert(offsetof(UK30SurvivorStatusComponent, _guardAddedProxy) == 0x0000B8, "Member 'UK30SurvivorStatusComponent::_guardAddedProxy' has a wrong offset!");

// Class TheK30.K30Utilities
// 0x0000 (0x0030 - 0x0030)
class UK30Utilities final : public UBlueprintFunctionLibrary
{
public:
	static class AKnightGuard* GetCurrentGuard(const class AActor* TheK30);
	static int32 GetCurrentGuardIndex(const class AActor* TheK30);
	static class AK30Power* GetK30Power(const class AActor* TheK30);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K30Utilities">();
	}
	static class UK30Utilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK30Utilities>();
	}
};
static_assert(alignof(UK30Utilities) == 0x000008, "Wrong alignment on UK30Utilities");
static_assert(sizeof(UK30Utilities) == 0x000030, "Wrong size on UK30Utilities");

// Class TheK30.KnightGuard
// 0x03E0 (0x1920 - 0x1540)
class AKnightGuard final : public ADBDPlayer
{
public:
	uint8                                         Pad_1540[0x40];                                    // 0x1540(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        _attackZonePivot;                                  // 0x1580(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1588[0x8];                                     // 0x1588(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _guardNoiseEventTimeInterval;                      // 0x1590(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _guardNoiseEventRange;                             // 0x1594(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isActive;                                         // 0x1598(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1599[0x7];                                     // 0x1599(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AK30Power*                              _killerPower;                                      // 0x15A0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class AGuardFlag>                 _flagClass;                                        // 0x15A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AGuardFlag*                             _guardFlag;                                        // 0x15B0(0x0008)(Net, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGuardIdleComponent*                    _idleComponent;                                    // 0x15B8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGuardAttackableComponent*              _attackableComponent;                              // 0x15C0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCapsuleComponent*                      _attackableCapsule;                                // 0x15C8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimationMontageSlave*                 _animationFollower;                                // 0x15D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _gravityScale;                                     // 0x15D8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _patrolMovementSpeed;                              // 0x1600(0x0080)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _huntMovementSpeed;                                // 0x1680(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _orderDuration;                                    // 0x16A8(0x0080)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _shouldInflictBleed;                               // 0x1728(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _palletAndVaultsSlowedDownSpeed;                   // 0x1750(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _palletAndVaultsSlowDownDuration;                  // 0x1778(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _immediateGeneratorRegressionPercent;              // 0x17A0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _huntAuraVisibilityMinDistanceToKiller;            // 0x17C8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FGameplayTag                           _guardHitSurvivorScoreEvent;                       // 0x17F0(0x000C)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTag                           _guardDetectSurvivorScoreEvent;                    // 0x17FC(0x000C)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTag                           _guardBreakInteractableEvent;                      // 0x1808(0x000C)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTag                           _guardChaseEndedEvent;                             // 0x1814(0x000C)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   _guardAnimTag;                                     // 0x1820(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_182C[0x64];                                    // 0x182C(0x0064)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class AActor*>                           _overlappingSurvivorsAndVaults;                    // 0x1890(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_18E0[0x40];                                    // 0x18E0(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_HideGuard();
	void Cosmetic_HuntChaseStarted();
	void Cosmetic_OnGuardVisionRadiusChanged(bool IsVisible, float Radius, float Angle);
	void Cosmetic_OnHuntEnded(EGuardHuntEndReason Reason);
	void Cosmetic_OnHuntTeleportStarted(float Duration);
	void Cosmetic_OnIdleEnded();
	void Cosmetic_OnOrderEnded();
	void Cosmetic_OnPatrolEnded(class ADBDPlayer* FoundSurvivor);
	void Cosmetic_OnPatrolStarted();
	void Cosmetic_OnSurvivorDetected(class ADBDPlayer* FoundSurvivor);
	void Cosmetic_ShowGuard();
	void Cosmetic_StartOverlappingVaultOrSurvivor();
	void Cosmetic_StopOverlappingVaultOrSurvivor();
	void Multicast_OnHuntEnded(EGuardHuntEndReason Reason);
	void Multicast_OnOrderEnded(class AInteractable* Target);
	void Multicast_OnPatrolEnded(class ADBDPlayer* FoundSurvivor, float CooldownOverride);
	void Multicast_OnSurvivorDetected(class ADBDPlayer* FoundSurvivor);
	void OnRep_IsActive(bool PreviousIsActive);

	float GetHuntAuraVisibilityMinDistanceToKiller() const;
	float GetImmediateGeneratorRegressionPercent() const;
	float GetOrderDuration() const;
	class ASlasherPlayer* GetOwningKiller() const;
	class UGuardPatrolComponent* GetPatrolComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KnightGuard">();
	}
	static class AKnightGuard* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKnightGuard>();
	}
};
static_assert(alignof(AKnightGuard) == 0x000010, "Wrong alignment on AKnightGuard");
static_assert(sizeof(AKnightGuard) == 0x001920, "Wrong size on AKnightGuard");
static_assert(offsetof(AKnightGuard, _attackZonePivot) == 0x001580, "Member 'AKnightGuard::_attackZonePivot' has a wrong offset!");
static_assert(offsetof(AKnightGuard, _guardNoiseEventTimeInterval) == 0x001590, "Member 'AKnightGuard::_guardNoiseEventTimeInterval' has a wrong offset!");
static_assert(offsetof(AKnightGuard, _guardNoiseEventRange) == 0x001594, "Member 'AKnightGuard::_guardNoiseEventRange' has a wrong offset!");
static_assert(offsetof(AKnightGuard, _isActive) == 0x001598, "Member 'AKnightGuard::_isActive' has a wrong offset!");
static_assert(offsetof(AKnightGuard, _killerPower) == 0x0015A0, "Member 'AKnightGuard::_killerPower' has a wrong offset!");
static_assert(offsetof(AKnightGuard, _flagClass) == 0x0015A8, "Member 'AKnightGuard::_flagClass' has a wrong offset!");
static_assert(offsetof(AKnightGuard, _guardFlag) == 0x0015B0, "Member 'AKnightGuard::_guardFlag' has a wrong offset!");
static_assert(offsetof(AKnightGuard, _idleComponent) == 0x0015B8, "Member 'AKnightGuard::_idleComponent' has a wrong offset!");
static_assert(offsetof(AKnightGuard, _attackableComponent) == 0x0015C0, "Member 'AKnightGuard::_attackableComponent' has a wrong offset!");
static_assert(offsetof(AKnightGuard, _attackableCapsule) == 0x0015C8, "Member 'AKnightGuard::_attackableCapsule' has a wrong offset!");
static_assert(offsetof(AKnightGuard, _animationFollower) == 0x0015D0, "Member 'AKnightGuard::_animationFollower' has a wrong offset!");
static_assert(offsetof(AKnightGuard, _gravityScale) == 0x0015D8, "Member 'AKnightGuard::_gravityScale' has a wrong offset!");
static_assert(offsetof(AKnightGuard, _patrolMovementSpeed) == 0x001600, "Member 'AKnightGuard::_patrolMovementSpeed' has a wrong offset!");
static_assert(offsetof(AKnightGuard, _huntMovementSpeed) == 0x001680, "Member 'AKnightGuard::_huntMovementSpeed' has a wrong offset!");
static_assert(offsetof(AKnightGuard, _orderDuration) == 0x0016A8, "Member 'AKnightGuard::_orderDuration' has a wrong offset!");
static_assert(offsetof(AKnightGuard, _shouldInflictBleed) == 0x001728, "Member 'AKnightGuard::_shouldInflictBleed' has a wrong offset!");
static_assert(offsetof(AKnightGuard, _palletAndVaultsSlowedDownSpeed) == 0x001750, "Member 'AKnightGuard::_palletAndVaultsSlowedDownSpeed' has a wrong offset!");
static_assert(offsetof(AKnightGuard, _palletAndVaultsSlowDownDuration) == 0x001778, "Member 'AKnightGuard::_palletAndVaultsSlowDownDuration' has a wrong offset!");
static_assert(offsetof(AKnightGuard, _immediateGeneratorRegressionPercent) == 0x0017A0, "Member 'AKnightGuard::_immediateGeneratorRegressionPercent' has a wrong offset!");
static_assert(offsetof(AKnightGuard, _huntAuraVisibilityMinDistanceToKiller) == 0x0017C8, "Member 'AKnightGuard::_huntAuraVisibilityMinDistanceToKiller' has a wrong offset!");
static_assert(offsetof(AKnightGuard, _guardHitSurvivorScoreEvent) == 0x0017F0, "Member 'AKnightGuard::_guardHitSurvivorScoreEvent' has a wrong offset!");
static_assert(offsetof(AKnightGuard, _guardDetectSurvivorScoreEvent) == 0x0017FC, "Member 'AKnightGuard::_guardDetectSurvivorScoreEvent' has a wrong offset!");
static_assert(offsetof(AKnightGuard, _guardBreakInteractableEvent) == 0x001808, "Member 'AKnightGuard::_guardBreakInteractableEvent' has a wrong offset!");
static_assert(offsetof(AKnightGuard, _guardChaseEndedEvent) == 0x001814, "Member 'AKnightGuard::_guardChaseEndedEvent' has a wrong offset!");
static_assert(offsetof(AKnightGuard, _guardAnimTag) == 0x001820, "Member 'AKnightGuard::_guardAnimTag' has a wrong offset!");
static_assert(offsetof(AKnightGuard, _overlappingSurvivorsAndVaults) == 0x001890, "Member 'AKnightGuard::_overlappingSurvivorsAndVaults' has a wrong offset!");

// Class TheK30.GuardAnimInstance
// 0x0020 (0x0600 - 0x05E0)
class UGuardAnimInstance final : public UPlayerAnimInstance
{
public:
	class AKnightGuard*                           _owningGuard;                                      // 0x05D8(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _forwardVelocity;                                  // 0x05E0(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _lateralVelocity;                                  // 0x05E4(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _animSpeed;                                        // 0x05E8(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _animDirection;                                    // 0x05EC(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isActive;                                         // 0x05F0(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isPatrolling;                                     // 0x05F1(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isPatrollingForward;                              // 0x05F2(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isHunting;                                        // 0x05F3(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isTeleporting;                                    // 0x05F4(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5F5[0xB];                                      // 0x05F5(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GuardAnimInstance">();
	}
	static class UGuardAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGuardAnimInstance>();
	}
};
static_assert(alignof(UGuardAnimInstance) == 0x000010, "Wrong alignment on UGuardAnimInstance");
static_assert(sizeof(UGuardAnimInstance) == 0x000600, "Wrong size on UGuardAnimInstance");
static_assert(offsetof(UGuardAnimInstance, _owningGuard) == 0x0005D8, "Member 'UGuardAnimInstance::_owningGuard' has a wrong offset!");
static_assert(offsetof(UGuardAnimInstance, _forwardVelocity) == 0x0005E0, "Member 'UGuardAnimInstance::_forwardVelocity' has a wrong offset!");
static_assert(offsetof(UGuardAnimInstance, _lateralVelocity) == 0x0005E4, "Member 'UGuardAnimInstance::_lateralVelocity' has a wrong offset!");
static_assert(offsetof(UGuardAnimInstance, _animSpeed) == 0x0005E8, "Member 'UGuardAnimInstance::_animSpeed' has a wrong offset!");
static_assert(offsetof(UGuardAnimInstance, _animDirection) == 0x0005EC, "Member 'UGuardAnimInstance::_animDirection' has a wrong offset!");
static_assert(offsetof(UGuardAnimInstance, _isActive) == 0x0005F0, "Member 'UGuardAnimInstance::_isActive' has a wrong offset!");
static_assert(offsetof(UGuardAnimInstance, _isPatrolling) == 0x0005F1, "Member 'UGuardAnimInstance::_isPatrolling' has a wrong offset!");
static_assert(offsetof(UGuardAnimInstance, _isPatrollingForward) == 0x0005F2, "Member 'UGuardAnimInstance::_isPatrollingForward' has a wrong offset!");
static_assert(offsetof(UGuardAnimInstance, _isHunting) == 0x0005F3, "Member 'UGuardAnimInstance::_isHunting' has a wrong offset!");
static_assert(offsetof(UGuardAnimInstance, _isTeleporting) == 0x0005F4, "Member 'UGuardAnimInstance::_isTeleporting' has a wrong offset!");

// Class TheK30.KnightGuardStateMachine
// 0x0000 (0x0120 - 0x0120)
class UKnightGuardStateMachine final : public UPlayerStateMachine
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KnightGuardStateMachine">();
	}
	static class UKnightGuardStateMachine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKnightGuardStateMachine>();
	}
};
static_assert(alignof(UKnightGuardStateMachine) == 0x000010, "Wrong alignment on UKnightGuardStateMachine");
static_assert(sizeof(UKnightGuardStateMachine) == 0x000120, "Wrong size on UKnightGuardStateMachine");

// Class TheK30.KnightHuskStunnableComponent
// 0x0008 (0x00B0 - 0x00A8)
class UKnightHuskStunnableComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KnightHuskStunnableComponent">();
	}
	static class UKnightHuskStunnableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKnightHuskStunnableComponent>();
	}
};
static_assert(alignof(UKnightHuskStunnableComponent) == 0x000008, "Wrong alignment on UKnightHuskStunnableComponent");
static_assert(sizeof(UKnightHuskStunnableComponent) == 0x0000B0, "Wrong size on UKnightHuskStunnableComponent");

// Class TheK30.KnightOrderComponent
// 0x0140 (0x01E8 - 0x00A8)
class UKnightOrderComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x10];                                      // 0x00A8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AInteractable*>                  _possiblyTargetableObjects;                        // 0x00B8(0x0010)(Net, ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class AInteractable*>                  _targetableObjects;                                // 0x00C8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class AInteractable*>                  _ongoingOrderTargetedObjects;                      // 0x00D8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	struct FLinearColor                           _targetedColor;                                    // 0x00E8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _showTargetableAura;                               // 0x00F8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F9[0x3];                                       // 0x00F9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           _targetableColor;                                  // 0x00FC(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_10C[0x4];                                      // 0x010C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AInteractable*                          _currentTarget;                                    // 0x0110(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AInteractable*                          _orderTarget;                                      // 0x0118(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInteractionDefinition*                 _bestInteraction;                                  // 0x0120(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInteractionDefinition*                 _currentInteraction;                               // 0x0128(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AKnightGuard*                           _guardWaitingForInteraction;                       // 0x0130(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_138[0x38];                                     // 0x0138(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _targetingRange;                                   // 0x0170(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TSubclassOf<class UInteractionDefinition>     _palletOrderClass;                                 // 0x0198(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UInteractionDefinition>     _killerBreakPalletClass;                           // 0x01A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UInteractionDefinition>     _generatorOrderClass;                              // 0x01A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UInteractionDefinition>     _killerBreakGeneratorClass;                        // 0x01B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UInteractionDefinition>     _breakableOrderClass;                              // 0x01B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UInteractionDefinition>     _killerBreakBreakableClass;                        // 0x01C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _updateRate;                                       // 0x01C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _maxTargetingAngle;                                // 0x01CC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _downRaycastLength;                                // 0x01D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1D4[0x14];                                     // 0x01D4(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_OnNewTargetSelected(class AInteractable* NewTarget, class AInteractable* OldTarget);
	void Cosmetic_OnTargetableObjectsChanged(class AInteractable* Object, bool IsTargetable);
	void OnCurrentInteractionFinished();
	void OnGameEventDispatched(const struct FGameplayTag& GameEventType, const struct FGameEventData& GameEventData);
	void OnTargetChanged__DelegateSignature();

	float GetTargetingRange() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KnightOrderComponent">();
	}
	static class UKnightOrderComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKnightOrderComponent>();
	}
};
static_assert(alignof(UKnightOrderComponent) == 0x000008, "Wrong alignment on UKnightOrderComponent");
static_assert(sizeof(UKnightOrderComponent) == 0x0001E8, "Wrong size on UKnightOrderComponent");
static_assert(offsetof(UKnightOrderComponent, _possiblyTargetableObjects) == 0x0000B8, "Member 'UKnightOrderComponent::_possiblyTargetableObjects' has a wrong offset!");
static_assert(offsetof(UKnightOrderComponent, _targetableObjects) == 0x0000C8, "Member 'UKnightOrderComponent::_targetableObjects' has a wrong offset!");
static_assert(offsetof(UKnightOrderComponent, _ongoingOrderTargetedObjects) == 0x0000D8, "Member 'UKnightOrderComponent::_ongoingOrderTargetedObjects' has a wrong offset!");
static_assert(offsetof(UKnightOrderComponent, _targetedColor) == 0x0000E8, "Member 'UKnightOrderComponent::_targetedColor' has a wrong offset!");
static_assert(offsetof(UKnightOrderComponent, _showTargetableAura) == 0x0000F8, "Member 'UKnightOrderComponent::_showTargetableAura' has a wrong offset!");
static_assert(offsetof(UKnightOrderComponent, _targetableColor) == 0x0000FC, "Member 'UKnightOrderComponent::_targetableColor' has a wrong offset!");
static_assert(offsetof(UKnightOrderComponent, _currentTarget) == 0x000110, "Member 'UKnightOrderComponent::_currentTarget' has a wrong offset!");
static_assert(offsetof(UKnightOrderComponent, _orderTarget) == 0x000118, "Member 'UKnightOrderComponent::_orderTarget' has a wrong offset!");
static_assert(offsetof(UKnightOrderComponent, _bestInteraction) == 0x000120, "Member 'UKnightOrderComponent::_bestInteraction' has a wrong offset!");
static_assert(offsetof(UKnightOrderComponent, _currentInteraction) == 0x000128, "Member 'UKnightOrderComponent::_currentInteraction' has a wrong offset!");
static_assert(offsetof(UKnightOrderComponent, _guardWaitingForInteraction) == 0x000130, "Member 'UKnightOrderComponent::_guardWaitingForInteraction' has a wrong offset!");
static_assert(offsetof(UKnightOrderComponent, _targetingRange) == 0x000170, "Member 'UKnightOrderComponent::_targetingRange' has a wrong offset!");
static_assert(offsetof(UKnightOrderComponent, _palletOrderClass) == 0x000198, "Member 'UKnightOrderComponent::_palletOrderClass' has a wrong offset!");
static_assert(offsetof(UKnightOrderComponent, _killerBreakPalletClass) == 0x0001A0, "Member 'UKnightOrderComponent::_killerBreakPalletClass' has a wrong offset!");
static_assert(offsetof(UKnightOrderComponent, _generatorOrderClass) == 0x0001A8, "Member 'UKnightOrderComponent::_generatorOrderClass' has a wrong offset!");
static_assert(offsetof(UKnightOrderComponent, _killerBreakGeneratorClass) == 0x0001B0, "Member 'UKnightOrderComponent::_killerBreakGeneratorClass' has a wrong offset!");
static_assert(offsetof(UKnightOrderComponent, _breakableOrderClass) == 0x0001B8, "Member 'UKnightOrderComponent::_breakableOrderClass' has a wrong offset!");
static_assert(offsetof(UKnightOrderComponent, _killerBreakBreakableClass) == 0x0001C0, "Member 'UKnightOrderComponent::_killerBreakBreakableClass' has a wrong offset!");
static_assert(offsetof(UKnightOrderComponent, _updateRate) == 0x0001C8, "Member 'UKnightOrderComponent::_updateRate' has a wrong offset!");
static_assert(offsetof(UKnightOrderComponent, _maxTargetingAngle) == 0x0001CC, "Member 'UKnightOrderComponent::_maxTargetingAngle' has a wrong offset!");
static_assert(offsetof(UKnightOrderComponent, _downRaycastLength) == 0x0001D0, "Member 'UKnightOrderComponent::_downRaycastLength' has a wrong offset!");

// Class TheK30.PatrolTrailComponent
// 0x0190 (0x0238 - 0x00A8)
class UPatrolTrailComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x18];                                      // 0x00A8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTrailData                             _trail;                                            // 0x00C0(0x0030)(Net, NativeAccessSpecifierPrivate)
	float                                         _remainingPathLengthPercent;                       // 0x00F0(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F4[0x4];                                       // 0x00F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTrailSettings                         _trailSettings;                                    // 0x00F8(0x0068)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_160[0x1C];                                     // 0x0160(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _clearPathNodeDelay;                               // 0x017C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _maxPathLength;                                    // 0x0180(0x0080)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _minimumPathDistanceRequirement;                   // 0x0200(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_228[0x10];                                     // 0x0228(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_RemainingPathLengthPercent();

	bool DoesTrailExist() const;
	float GetCurrentTrailLength() const;
	class ATrailNode* GetFirstNode() const;
	class ATrailNode* GetLastNode() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PatrolTrailComponent">();
	}
	static class UPatrolTrailComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPatrolTrailComponent>();
	}
};
static_assert(alignof(UPatrolTrailComponent) == 0x000008, "Wrong alignment on UPatrolTrailComponent");
static_assert(sizeof(UPatrolTrailComponent) == 0x000238, "Wrong size on UPatrolTrailComponent");
static_assert(offsetof(UPatrolTrailComponent, _trail) == 0x0000C0, "Member 'UPatrolTrailComponent::_trail' has a wrong offset!");
static_assert(offsetof(UPatrolTrailComponent, _remainingPathLengthPercent) == 0x0000F0, "Member 'UPatrolTrailComponent::_remainingPathLengthPercent' has a wrong offset!");
static_assert(offsetof(UPatrolTrailComponent, _trailSettings) == 0x0000F8, "Member 'UPatrolTrailComponent::_trailSettings' has a wrong offset!");
static_assert(offsetof(UPatrolTrailComponent, _clearPathNodeDelay) == 0x00017C, "Member 'UPatrolTrailComponent::_clearPathNodeDelay' has a wrong offset!");
static_assert(offsetof(UPatrolTrailComponent, _maxPathLength) == 0x000180, "Member 'UPatrolTrailComponent::_maxPathLength' has a wrong offset!");
static_assert(offsetof(UPatrolTrailComponent, _minimumPathDistanceRequirement) == 0x000200, "Member 'UPatrolTrailComponent::_minimumPathDistanceRequirement' has a wrong offset!");

}

