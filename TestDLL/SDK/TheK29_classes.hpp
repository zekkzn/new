#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: TheK29

#include "Basic.hpp"

#include "DeadByDaylight_structs.hpp"
#include "DeadByDaylight_classes.hpp"
#include "DBDBots_classes.hpp"
#include "DBDAnimation_classes.hpp"
#include "DBDGameplay_classes.hpp"
#include "DBDCompetence_classes.hpp"
#include "DataTableUtilities_structs.hpp"
#include "Engine_classes.hpp"
#include "StatSystem_structs.hpp"
#include "TheK29_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "DBDCosmetic_classes.hpp"


namespace SDK
{

// Class TheK29.K29P01
// 0x0010 (0x0430 - 0x0420)
class UK29P01 final : public UPerk
{
public:
	float                                         _survivorVaultRushedEventRange;                    // 0x0420(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _cooldownTime;                                     // 0x0424(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_428[0x8];                                      // 0x0428(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetSurvivorVaultRushedEventRange() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K29P01">();
	}
	static class UK29P01* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK29P01>();
	}
};
static_assert(alignof(UK29P01) == 0x000008, "Wrong alignment on UK29P01");
static_assert(sizeof(UK29P01) == 0x000430, "Wrong size on UK29P01");
static_assert(offsetof(UK29P01, _survivorVaultRushedEventRange) == 0x000420, "Member 'UK29P01::_survivorVaultRushedEventRange' has a wrong offset!");
static_assert(offsetof(UK29P01, _cooldownTime) == 0x000424, "Member 'UK29P01::_cooldownTime' has a wrong offset!");

// Class TheK29.AISkill_FindCollectable_K29SupplyCrate
// 0x00C0 (0x0450 - 0x0390)
class UAISkill_FindCollectable_K29SupplyCrate final : public UAISkill_FindCollectable_Searchable
{
public:
	struct FAITunableParameter                    UrgencyGoalWeight;                                 // 0x0390(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    OpenedWeightMultiplier;                            // 0x03F0(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_FindCollectable_K29SupplyCrate">();
	}
	static class UAISkill_FindCollectable_K29SupplyCrate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_FindCollectable_K29SupplyCrate>();
	}
};
static_assert(alignof(UAISkill_FindCollectable_K29SupplyCrate) == 0x000008, "Wrong alignment on UAISkill_FindCollectable_K29SupplyCrate");
static_assert(sizeof(UAISkill_FindCollectable_K29SupplyCrate) == 0x000450, "Wrong size on UAISkill_FindCollectable_K29SupplyCrate");
static_assert(offsetof(UAISkill_FindCollectable_K29SupplyCrate, UrgencyGoalWeight) == 0x000390, "Member 'UAISkill_FindCollectable_K29SupplyCrate::UrgencyGoalWeight' has a wrong offset!");
static_assert(offsetof(UAISkill_FindCollectable_K29SupplyCrate, OpenedWeightMultiplier) == 0x0003F0, "Member 'UAISkill_FindCollectable_K29SupplyCrate::OpenedWeightMultiplier' has a wrong offset!");

// Class TheK29.AISkill_InteractionUseItem_K29StabilizingSpray
// 0x0000 (0x0290 - 0x0290)
class UAISkill_InteractionUseItem_K29StabilizingSpray final : public UAISkill_InteractionUseItem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_InteractionUseItem_K29StabilizingSpray">();
	}
	static class UAISkill_InteractionUseItem_K29StabilizingSpray* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_InteractionUseItem_K29StabilizingSpray>();
	}
};
static_assert(alignof(UAISkill_InteractionUseItem_K29StabilizingSpray) == 0x000008, "Wrong alignment on UAISkill_InteractionUseItem_K29StabilizingSpray");
static_assert(sizeof(UAISkill_InteractionUseItem_K29StabilizingSpray) == 0x000290, "Wrong size on UAISkill_InteractionUseItem_K29StabilizingSpray");

// Class TheK29.AISkill_InteractionUseItem_K29StabilizingSprayOther
// 0x0000 (0x0290 - 0x0290)
class UAISkill_InteractionUseItem_K29StabilizingSprayOther final : public UAISkill_InteractionUseItem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_InteractionUseItem_K29StabilizingSprayOther">();
	}
	static class UAISkill_InteractionUseItem_K29StabilizingSprayOther* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_InteractionUseItem_K29StabilizingSprayOther>();
	}
};
static_assert(alignof(UAISkill_InteractionUseItem_K29StabilizingSprayOther) == 0x000008, "Wrong alignment on UAISkill_InteractionUseItem_K29StabilizingSprayOther");
static_assert(sizeof(UAISkill_InteractionUseItem_K29StabilizingSprayOther) == 0x000290, "Wrong size on UAISkill_InteractionUseItem_K29StabilizingSprayOther");

// Class TheK29.K29AnimInstance
// 0x0030 (0x0750 - 0x0720)
class UK29AnimInstance final : public UKillerAnimInstance
{
public:
	bool                                          _isRushing;                                        // 0x0720(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isHoldingSurvivor;                                // 0x0721(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isChargingRushing;                                // 0x0722(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isBetweenRushes;                                  // 0x0723(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isThrowing;                                       // 0x0724(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isBouncingBack;                                   // 0x0725(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _hasStartedFinalRush;                              // 0x0726(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _hasRushEndedInSurvivorImpact;                     // 0x0727(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _hasRushEndedInLedgeDrop;                          // 0x0728(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _hasInstantlyPickedUpSurvivor;                     // 0x0729(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isReadyToRushButHasNoPath;                        // 0x072A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_72B[0x25];                                     // 0x072B(0x0025)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnGameEventReceived(const struct FGameplayTag& GameplayTag, const struct FGameEventData& GameEventData);
	void OnHasInstantlyPickedUpSurvivor();
	void OnHasRushEndedInLedgeDrop();
	void OnHasRushEndedInSurvivorImpact();
	void OnStartThrowingSurvivor();
	void ResetHasInstantlyPickedUpSurvivor();
	void ResetHasRushEndedInLedgeDrop();
	void ResetHasRushEndedInSurvivorImpact();
	void ResetStartThrowingSurvivor();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K29AnimInstance">();
	}
	static class UK29AnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK29AnimInstance>();
	}
};
static_assert(alignof(UK29AnimInstance) == 0x000010, "Wrong alignment on UK29AnimInstance");
static_assert(sizeof(UK29AnimInstance) == 0x000750, "Wrong size on UK29AnimInstance");
static_assert(offsetof(UK29AnimInstance, _isRushing) == 0x000720, "Member 'UK29AnimInstance::_isRushing' has a wrong offset!");
static_assert(offsetof(UK29AnimInstance, _isHoldingSurvivor) == 0x000721, "Member 'UK29AnimInstance::_isHoldingSurvivor' has a wrong offset!");
static_assert(offsetof(UK29AnimInstance, _isChargingRushing) == 0x000722, "Member 'UK29AnimInstance::_isChargingRushing' has a wrong offset!");
static_assert(offsetof(UK29AnimInstance, _isBetweenRushes) == 0x000723, "Member 'UK29AnimInstance::_isBetweenRushes' has a wrong offset!");
static_assert(offsetof(UK29AnimInstance, _isThrowing) == 0x000724, "Member 'UK29AnimInstance::_isThrowing' has a wrong offset!");
static_assert(offsetof(UK29AnimInstance, _isBouncingBack) == 0x000725, "Member 'UK29AnimInstance::_isBouncingBack' has a wrong offset!");
static_assert(offsetof(UK29AnimInstance, _hasStartedFinalRush) == 0x000726, "Member 'UK29AnimInstance::_hasStartedFinalRush' has a wrong offset!");
static_assert(offsetof(UK29AnimInstance, _hasRushEndedInSurvivorImpact) == 0x000727, "Member 'UK29AnimInstance::_hasRushEndedInSurvivorImpact' has a wrong offset!");
static_assert(offsetof(UK29AnimInstance, _hasRushEndedInLedgeDrop) == 0x000728, "Member 'UK29AnimInstance::_hasRushEndedInLedgeDrop' has a wrong offset!");
static_assert(offsetof(UK29AnimInstance, _hasInstantlyPickedUpSurvivor) == 0x000729, "Member 'UK29AnimInstance::_hasInstantlyPickedUpSurvivor' has a wrong offset!");
static_assert(offsetof(UK29AnimInstance, _isReadyToRushButHasNoPath) == 0x00072A, "Member 'UK29AnimInstance::_isReadyToRushButHasNoPath' has a wrong offset!");

// Class TheK29.K29GateBlockerStatusEffect
// 0x0020 (0x0480 - 0x0460)
class UK29GateBlockerStatusEffect final : public ULingeringMultiStateTagStatusEffect
{
public:
	class FName                                   _escapeZoneBoxComponentTagName;                    // 0x0460(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_46C[0x14];                                     // 0x046C(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K29GateBlockerStatusEffect">();
	}
	static class UK29GateBlockerStatusEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK29GateBlockerStatusEffect>();
	}
};
static_assert(alignof(UK29GateBlockerStatusEffect) == 0x000008, "Wrong alignment on UK29GateBlockerStatusEffect");
static_assert(sizeof(UK29GateBlockerStatusEffect) == 0x000480, "Wrong size on UK29GateBlockerStatusEffect");
static_assert(offsetof(UK29GateBlockerStatusEffect, _escapeZoneBoxComponentTagName) == 0x000460, "Member 'UK29GateBlockerStatusEffect::_escapeZoneBoxComponentTagName' has a wrong offset!");

// Class TheK29.K29InfectionRemovalCollectable
// 0x0038 (0x05D0 - 0x0598)
class AK29InfectionRemovalCollectable final : public ABaseCamperCollectable
{
public:
	struct FDBDTunableRowHandle                   _maxCharges;                                       // 0x0598(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_5C0[0x10];                                     // 0x05C0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K29InfectionRemovalCollectable">();
	}
	static class AK29InfectionRemovalCollectable* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK29InfectionRemovalCollectable>();
	}
};
static_assert(alignof(AK29InfectionRemovalCollectable) == 0x000008, "Wrong alignment on AK29InfectionRemovalCollectable");
static_assert(sizeof(AK29InfectionRemovalCollectable) == 0x0005D0, "Wrong size on AK29InfectionRemovalCollectable");
static_assert(offsetof(AK29InfectionRemovalCollectable, _maxCharges) == 0x000598, "Member 'AK29InfectionRemovalCollectable::_maxCharges' has a wrong offset!");

// Class TheK29.K29KillerVaultInteractionDefinition
// 0x0010 (0x0880 - 0x0870)
class UK29KillerVaultInteractionDefinition : public UKillerVaultDefinition
{
public:
	uint8                                         Pad_870[0x10];                                     // 0x0870(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_OnTentacleSlashDamage(class ACamperPlayer* HitSurvivor, const bool IsDowned);
	void Multicast_DamageWithTentacleSlash(class ADBDPlayer* Player, class ACamperPlayer* HitSurvivor, const bool IsDowned);
	void Multicast_WillHitSurvivor();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K29KillerVaultInteractionDefinition">();
	}
	static class UK29KillerVaultInteractionDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK29KillerVaultInteractionDefinition>();
	}
};
static_assert(alignof(UK29KillerVaultInteractionDefinition) == 0x000010, "Wrong alignment on UK29KillerVaultInteractionDefinition");
static_assert(sizeof(UK29KillerVaultInteractionDefinition) == 0x000880, "Wrong size on UK29KillerVaultInteractionDefinition");

// Class TheK29.K29P02
// 0x00C8 (0x04E8 - 0x0420)
class UK29P02 final : public UPerk
{
public:
	float                                         _revealRange[0x3];                                 // 0x0420(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_42C[0x4];                                      // 0x042C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UStatusEffect>              _effectClass;                                      // 0x0430(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<TWeakObjectPtr<class ACamperPlayer>, TWeakObjectPtr<class UStatusEffect>> _survivorRevealedEffects;                          // 0x0438(0x0050)(ExportObject, Transient, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_488[0x60];                                     // 0x0488(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnInRangeChanged(const bool InRange, class ACamperPlayer* Survivor);
	const float GetRevealRange();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K29P02">();
	}
	static class UK29P02* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK29P02>();
	}
};
static_assert(alignof(UK29P02) == 0x000008, "Wrong alignment on UK29P02");
static_assert(sizeof(UK29P02) == 0x0004E8, "Wrong size on UK29P02");
static_assert(offsetof(UK29P02, _revealRange) == 0x000420, "Member 'UK29P02::_revealRange' has a wrong offset!");
static_assert(offsetof(UK29P02, _effectClass) == 0x000430, "Member 'UK29P02::_effectClass' has a wrong offset!");
static_assert(offsetof(UK29P02, _survivorRevealedEffects) == 0x000438, "Member 'UK29P02::_survivorRevealedEffects' has a wrong offset!");

// Class TheK29.K29P03
// 0x0018 (0x0438 - 0x0420)
class UK29P03 final : public UPerk
{
public:
	float                                         _brokenEffectDuration[0x3];                        // 0x0420(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_42C[0x4];                                      // 0x042C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UStatusEffect>              _effectClass;                                      // 0x0430(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K29P03">();
	}
	static class UK29P03* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK29P03>();
	}
};
static_assert(alignof(UK29P03) == 0x000008, "Wrong alignment on UK29P03");
static_assert(sizeof(UK29P03) == 0x000438, "Wrong size on UK29P03");
static_assert(offsetof(UK29P03, _brokenEffectDuration) == 0x000420, "Member 'UK29P03::_brokenEffectDuration' has a wrong offset!");
static_assert(offsetof(UK29P03, _effectClass) == 0x000430, "Member 'UK29P03::_effectClass' has a wrong offset!");

// Class TheK29.K29P03StatusEffect
// 0x0000 (0x0390 - 0x0390)
class UK29P03StatusEffect final : public UAdjustableCooldownStatusEffect
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K29P03StatusEffect">();
	}
	static class UK29P03StatusEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK29P03StatusEffect>();
	}
};
static_assert(alignof(UK29P03StatusEffect) == 0x000008, "Wrong alignment on UK29P03StatusEffect");
static_assert(sizeof(UK29P03StatusEffect) == 0x000390, "Wrong size on UK29P03StatusEffect");

// Class TheK29.K29PathingCalculatorComponent
// 0x0200 (0x02A8 - 0x00A8)
class UK29PathingCalculatorComponent final : public UActorComponent
{
public:
	struct FDBDTunableRowHandle                   _maxStepHeight;                                    // 0x00A8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _maxStepHeightDownwards;                           // 0x00D0(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _horizontalAngle;                                  // 0x00F8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _verticalAngle;                                    // 0x0120(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _gridLength;                                       // 0x0148(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _detectionHeightOffset;                            // 0x0170(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _floorSearchLengthFromActorLocation;               // 0x0198(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _minimumWallDashDistanceCarryingSurvivor;          // 0x01C0(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         _floorCheckDistance;                               // 0x01E8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1EC[0x4];                                      // 0x01EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _lineOfSightCapsuleRadius;                         // 0x01F0(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _lineOfSightCapsuleHeight;                         // 0x0218(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _lineOfSightCapsuleHeightOffset;                   // 0x0240(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _maximumWalkableAngle;                             // 0x0268(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         _groundCollisionDetectionRadius;                   // 0x0290(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _allowedGroundBlockerHeight;                       // 0x0294(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _minimalLedgeDistance;                             // 0x0298(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_29C[0xC];                                      // 0x029C(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K29PathingCalculatorComponent">();
	}
	static class UK29PathingCalculatorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK29PathingCalculatorComponent>();
	}
};
static_assert(alignof(UK29PathingCalculatorComponent) == 0x000008, "Wrong alignment on UK29PathingCalculatorComponent");
static_assert(sizeof(UK29PathingCalculatorComponent) == 0x0002A8, "Wrong size on UK29PathingCalculatorComponent");
static_assert(offsetof(UK29PathingCalculatorComponent, _maxStepHeight) == 0x0000A8, "Member 'UK29PathingCalculatorComponent::_maxStepHeight' has a wrong offset!");
static_assert(offsetof(UK29PathingCalculatorComponent, _maxStepHeightDownwards) == 0x0000D0, "Member 'UK29PathingCalculatorComponent::_maxStepHeightDownwards' has a wrong offset!");
static_assert(offsetof(UK29PathingCalculatorComponent, _horizontalAngle) == 0x0000F8, "Member 'UK29PathingCalculatorComponent::_horizontalAngle' has a wrong offset!");
static_assert(offsetof(UK29PathingCalculatorComponent, _verticalAngle) == 0x000120, "Member 'UK29PathingCalculatorComponent::_verticalAngle' has a wrong offset!");
static_assert(offsetof(UK29PathingCalculatorComponent, _gridLength) == 0x000148, "Member 'UK29PathingCalculatorComponent::_gridLength' has a wrong offset!");
static_assert(offsetof(UK29PathingCalculatorComponent, _detectionHeightOffset) == 0x000170, "Member 'UK29PathingCalculatorComponent::_detectionHeightOffset' has a wrong offset!");
static_assert(offsetof(UK29PathingCalculatorComponent, _floorSearchLengthFromActorLocation) == 0x000198, "Member 'UK29PathingCalculatorComponent::_floorSearchLengthFromActorLocation' has a wrong offset!");
static_assert(offsetof(UK29PathingCalculatorComponent, _minimumWallDashDistanceCarryingSurvivor) == 0x0001C0, "Member 'UK29PathingCalculatorComponent::_minimumWallDashDistanceCarryingSurvivor' has a wrong offset!");
static_assert(offsetof(UK29PathingCalculatorComponent, _floorCheckDistance) == 0x0001E8, "Member 'UK29PathingCalculatorComponent::_floorCheckDistance' has a wrong offset!");
static_assert(offsetof(UK29PathingCalculatorComponent, _lineOfSightCapsuleRadius) == 0x0001F0, "Member 'UK29PathingCalculatorComponent::_lineOfSightCapsuleRadius' has a wrong offset!");
static_assert(offsetof(UK29PathingCalculatorComponent, _lineOfSightCapsuleHeight) == 0x000218, "Member 'UK29PathingCalculatorComponent::_lineOfSightCapsuleHeight' has a wrong offset!");
static_assert(offsetof(UK29PathingCalculatorComponent, _lineOfSightCapsuleHeightOffset) == 0x000240, "Member 'UK29PathingCalculatorComponent::_lineOfSightCapsuleHeightOffset' has a wrong offset!");
static_assert(offsetof(UK29PathingCalculatorComponent, _maximumWalkableAngle) == 0x000268, "Member 'UK29PathingCalculatorComponent::_maximumWalkableAngle' has a wrong offset!");
static_assert(offsetof(UK29PathingCalculatorComponent, _groundCollisionDetectionRadius) == 0x000290, "Member 'UK29PathingCalculatorComponent::_groundCollisionDetectionRadius' has a wrong offset!");
static_assert(offsetof(UK29PathingCalculatorComponent, _allowedGroundBlockerHeight) == 0x000294, "Member 'UK29PathingCalculatorComponent::_allowedGroundBlockerHeight' has a wrong offset!");
static_assert(offsetof(UK29PathingCalculatorComponent, _minimalLedgeDistance) == 0x000298, "Member 'UK29PathingCalculatorComponent::_minimalLedgeDistance' has a wrong offset!");

// Class TheK29.K29Power
// 0x01A0 (0x06F0 - 0x0550)
class AK29Power final : public ACollectable
{
public:
	class UChargeableComponent*                   _rushChargeableComponent;                          // 0x0550(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractor*                            _interactor;                                       // 0x0558(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxPlayerOverlapComponent*             _interactionVolume;                                // 0x0560(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UK29PowerChargePresentationItemProgressComponent* _powerChargePresentationItemProgressComponent;     // 0x0568(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UK29PowerChargePresentationPowerFadeComponent* _powerChargePresentationPowerFadeComponent;        // 0x0570(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UK29PowerStatusHandlerComponent> _powerStatusHandlerComponentClass;                 // 0x0578(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UK29RushChargesHandlerComponent> _rushChargesHandlerComponentClass;                 // 0x0580(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UK29PathingCalculatorComponent> _pathingCalculatorComponentClass;                  // 0x0588(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UStatusEffect>              _blindnessProtectionStatusEffectClass;             // 0x0590(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTunableStat                           _rushChargeTime;                                   // 0x0598(0x0080)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FStatProperty                          _scorePercent;                                     // 0x0618(0x0088)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class AAnimationFollowerActor>    _moriTentaclesAnimationFollowerActorClass;         // 0x06A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6A8[0x8];                                      // 0x06A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UK29PowerStatusHandlerComponent*        _powerStatusHandlerComponent;                      // 0x06B0(0x0008)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UK29RushChargesHandlerComponent*        _rushChargesHandlerComponent;                      // 0x06B8(0x0008)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UK29PathingCalculatorComponent*         _pathingCalculatorComponent;                       // 0x06C0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6C8[0x28];                                     // 0x06C8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnStun(const struct FGameplayTag& GameplayTag, const struct FGameEventData& GameEventData);
	class UK29RushCooldownInteraction* GetDropSurvivorCooldownInteraction();
	class UK29PowerStatusHandlerComponent* GetPowerStatusHandlerComponent();
	class UInteractionDefinition* GetPushSurvivorOverLedgeInteraction();
	class UK29RushCooldownInteraction* GetRushBreakableCooldownInteraction();
	class UK29RushChargeableInteraction* GetRushChargeableInteraction();
	class UK29RushCooldownInteraction* GetRushChargeCancelCooldownInteraction();
	class UK29RushChargesHandlerComponent* GetRushChargesHandlerComponent();
	class UK29RushCooldownInteraction* GetRushCompleteNoSurvivorCooldownInteraction();
	class UK29RushCooldownInteraction* GetRushCompleteSurvivorHitCooldownInteraction();
	class UK29RushCooldownInteraction* GetRushCompleteSurvivorThrowCooldownInteraction();
	class UStaticMeshComponent* GetRushSurvivorDetectionBox();
	class UK29RushCooldownInteraction* GetRushVaultCooldownInteraction();
	class UInteractionDefinition* GetSlashBreakableInteraction();
	class UInteractionDefinition* GetSlashSurvivorInteraction();

	float GetScorePercent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K29Power">();
	}
	static class AK29Power* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK29Power>();
	}
};
static_assert(alignof(AK29Power) == 0x000008, "Wrong alignment on AK29Power");
static_assert(sizeof(AK29Power) == 0x0006F0, "Wrong size on AK29Power");
static_assert(offsetof(AK29Power, _rushChargeableComponent) == 0x000550, "Member 'AK29Power::_rushChargeableComponent' has a wrong offset!");
static_assert(offsetof(AK29Power, _interactor) == 0x000558, "Member 'AK29Power::_interactor' has a wrong offset!");
static_assert(offsetof(AK29Power, _interactionVolume) == 0x000560, "Member 'AK29Power::_interactionVolume' has a wrong offset!");
static_assert(offsetof(AK29Power, _powerChargePresentationItemProgressComponent) == 0x000568, "Member 'AK29Power::_powerChargePresentationItemProgressComponent' has a wrong offset!");
static_assert(offsetof(AK29Power, _powerChargePresentationPowerFadeComponent) == 0x000570, "Member 'AK29Power::_powerChargePresentationPowerFadeComponent' has a wrong offset!");
static_assert(offsetof(AK29Power, _powerStatusHandlerComponentClass) == 0x000578, "Member 'AK29Power::_powerStatusHandlerComponentClass' has a wrong offset!");
static_assert(offsetof(AK29Power, _rushChargesHandlerComponentClass) == 0x000580, "Member 'AK29Power::_rushChargesHandlerComponentClass' has a wrong offset!");
static_assert(offsetof(AK29Power, _pathingCalculatorComponentClass) == 0x000588, "Member 'AK29Power::_pathingCalculatorComponentClass' has a wrong offset!");
static_assert(offsetof(AK29Power, _blindnessProtectionStatusEffectClass) == 0x000590, "Member 'AK29Power::_blindnessProtectionStatusEffectClass' has a wrong offset!");
static_assert(offsetof(AK29Power, _rushChargeTime) == 0x000598, "Member 'AK29Power::_rushChargeTime' has a wrong offset!");
static_assert(offsetof(AK29Power, _scorePercent) == 0x000618, "Member 'AK29Power::_scorePercent' has a wrong offset!");
static_assert(offsetof(AK29Power, _moriTentaclesAnimationFollowerActorClass) == 0x0006A0, "Member 'AK29Power::_moriTentaclesAnimationFollowerActorClass' has a wrong offset!");
static_assert(offsetof(AK29Power, _powerStatusHandlerComponent) == 0x0006B0, "Member 'AK29Power::_powerStatusHandlerComponent' has a wrong offset!");
static_assert(offsetof(AK29Power, _rushChargesHandlerComponent) == 0x0006B8, "Member 'AK29Power::_rushChargesHandlerComponent' has a wrong offset!");
static_assert(offsetof(AK29Power, _pathingCalculatorComponent) == 0x0006C0, "Member 'AK29Power::_pathingCalculatorComponent' has a wrong offset!");

// Class TheK29.K29PowerChargePresentationItemProgressComponent
// 0x0018 (0x00C8 - 0x00B0)
class UK29PowerChargePresentationItemProgressComponent final : public UPresentationItemProgressComponent
{
public:
	class UK29PowerStatusHandlerComponent*        _statusHandlerComponent;                           // 0x00B0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UK29RushChargesHandlerComponent*        _rushChargesHandlerComponent;                      // 0x00B8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UK29RushChargeableInteraction*          _rushInteraction;                                  // 0x00C0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K29PowerChargePresentationItemProgressComponent">();
	}
	static class UK29PowerChargePresentationItemProgressComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK29PowerChargePresentationItemProgressComponent>();
	}
};
static_assert(alignof(UK29PowerChargePresentationItemProgressComponent) == 0x000008, "Wrong alignment on UK29PowerChargePresentationItemProgressComponent");
static_assert(sizeof(UK29PowerChargePresentationItemProgressComponent) == 0x0000C8, "Wrong size on UK29PowerChargePresentationItemProgressComponent");
static_assert(offsetof(UK29PowerChargePresentationItemProgressComponent, _statusHandlerComponent) == 0x0000B0, "Member 'UK29PowerChargePresentationItemProgressComponent::_statusHandlerComponent' has a wrong offset!");
static_assert(offsetof(UK29PowerChargePresentationItemProgressComponent, _rushChargesHandlerComponent) == 0x0000B8, "Member 'UK29PowerChargePresentationItemProgressComponent::_rushChargesHandlerComponent' has a wrong offset!");
static_assert(offsetof(UK29PowerChargePresentationItemProgressComponent, _rushInteraction) == 0x0000C0, "Member 'UK29PowerChargePresentationItemProgressComponent::_rushInteraction' has a wrong offset!");

// Class TheK29.K29PowerChargePresentationPowerFadeComponent
// 0x0018 (0x00C0 - 0x00A8)
class UK29PowerChargePresentationPowerFadeComponent final : public UPresentationPowerFadeComponent
{
public:
	class UK29RushChargesHandlerComponent*        _rushChargesHandlerComponent;                      // 0x00A8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B0[0x10];                                      // 0x00B0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnKillerSet(class ASlasherPlayer* Killer);
	void SetDependencies(class UK29RushChargesHandlerComponent* AmmoHandler);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K29PowerChargePresentationPowerFadeComponent">();
	}
	static class UK29PowerChargePresentationPowerFadeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK29PowerChargePresentationPowerFadeComponent>();
	}
};
static_assert(alignof(UK29PowerChargePresentationPowerFadeComponent) == 0x000008, "Wrong alignment on UK29PowerChargePresentationPowerFadeComponent");
static_assert(sizeof(UK29PowerChargePresentationPowerFadeComponent) == 0x0000C0, "Wrong size on UK29PowerChargePresentationPowerFadeComponent");
static_assert(offsetof(UK29PowerChargePresentationPowerFadeComponent, _rushChargesHandlerComponent) == 0x0000A8, "Member 'UK29PowerChargePresentationPowerFadeComponent::_rushChargesHandlerComponent' has a wrong offset!");

// Class TheK29.K29PowerStatusHandlerComponent
// 0x0368 (0x0410 - 0x00A8)
class UK29PowerStatusHandlerComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x30];                                      // 0x00A8(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _maxInfectionLevel;                                // 0x00D8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FTunableStat                           _infectionAddedPerTickWhileActive;                 // 0x0100(0x0080)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UCurveFloat*                            _stabilizingHealAmountByUsage;                     // 0x0180(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTunableStat                           _initialInfectionLevel;                            // 0x0188(0x0080)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FTunableStat                           _addedInfectionLevelsOnGrab;                       // 0x0208(0x0080)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FTunableStat                           _infectionHealingMultiplier;                       // 0x0288(0x0080)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _infectionIncubationThreshold;                     // 0x0308(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FTunableStat                           _useInfectionRemoverChargeTime;                    // 0x0330(0x0080)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UStatusEffect>              _hinderedStatusEffectClass;                        // 0x03B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UStatusEffect>              _gateBlockerStatusEffectClass;                     // 0x03B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UK29SurvivorThrowableComponent> _survivorThrowableClass;                           // 0x03C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UChargeableInteractionDefinition> _useInfectionRemoverInteractionSelfClass;          // 0x03C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UChargeableInteractionDefinition> _useInfectionRemoverInteractionOtherClass;         // 0x03D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _maxInfectionLevelWhenHooked;                      // 0x03D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _recentlyGrabbedThresholdSeconds;                  // 0x03DC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FK29SurvivorStatus>             _survivorStatusList;                               // 0x03E0(0x0010)(Net, ZeroConstructor, RepNotify, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3F0[0x20];                                     // 0x03F0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddToTimesCuredByHeal(const class ACamperPlayer* Survivor);
	void Authority_AddInfectionLevels(const class ACamperPlayer* Survivor, const int32 InfectionToAdd);
	void Authority_HealAllSurvivorsInfectionWithStabilizingSpray();
	void Authority_HealInfectionLevels(const class ACamperPlayer* Survivor, const int32 InfectionLevelsToHeal, const bool ShouldSetInfectionActiveToFalse);
	void Authority_OnIntroCompleted();
	void Authority_OnSlash(class ACamperPlayer* TargetSurvivor);
	void Authority_OnSurvivorAdded(class ACamperPlayer* Survivor);
	void Authority_OnSurvivorImmoblizedChanged();
	void Authority_SetAllSurvivorsToInitialInfection();
	void Authority_SetAllSurvivorsToMaxInfection();
	void Authority_UseStabilizingSpray(class ACamperPlayer* InstigatingSurvivor, class ACamperPlayer* TargetSurvivor);
	void Cosmetic_OnGrabbingInfectedSurvivor();
	void Cosmetic_OnGrabbingNonInfectedSurvivor();
	int32 GetInfectionLevel(const class ACamperPlayer* Survivor);
	int32 GetMaxInfectionLevel();
	bool IsInfectionIncreasingForSurvivor(const class ACamperPlayer* Survivor);
	void Multicast_DropSurvivor(class ACamperPlayer* LeftSurvivor);
	void Multicast_GrabSurvivor(class ACamperPlayer* Survivor, const bool IsProcessingInitialInfection);
	void Multicast_ReleaseSurvivor(class ACamperPlayer* Survivor, bool IsForced);
	void Multicast_RemoveSurvivorFromCloset(class ACamperPlayer* Survivor);
	void Multicast_UseStabilizingSpray(class ACamperPlayer* TargetSurvivor);
	void OnKillerSet(class ASlasherPlayer* Killer);
	void OnRep_SurvivorStatusList(const TArray<struct FK29SurvivorStatus>& OldSurvivorStatus);
	void Server_GrabSurvivor(class ACamperPlayer* Survivor, const bool IsProcessingInitialInfection);
	void Server_ReleaseSurvivor(class ACamperPlayer* Survivor, bool IsForced);

	int32 GetMaxInfectionLevelWhenHooked() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K29PowerStatusHandlerComponent">();
	}
	static class UK29PowerStatusHandlerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK29PowerStatusHandlerComponent>();
	}
};
static_assert(alignof(UK29PowerStatusHandlerComponent) == 0x000008, "Wrong alignment on UK29PowerStatusHandlerComponent");
static_assert(sizeof(UK29PowerStatusHandlerComponent) == 0x000410, "Wrong size on UK29PowerStatusHandlerComponent");
static_assert(offsetof(UK29PowerStatusHandlerComponent, _maxInfectionLevel) == 0x0000D8, "Member 'UK29PowerStatusHandlerComponent::_maxInfectionLevel' has a wrong offset!");
static_assert(offsetof(UK29PowerStatusHandlerComponent, _infectionAddedPerTickWhileActive) == 0x000100, "Member 'UK29PowerStatusHandlerComponent::_infectionAddedPerTickWhileActive' has a wrong offset!");
static_assert(offsetof(UK29PowerStatusHandlerComponent, _stabilizingHealAmountByUsage) == 0x000180, "Member 'UK29PowerStatusHandlerComponent::_stabilizingHealAmountByUsage' has a wrong offset!");
static_assert(offsetof(UK29PowerStatusHandlerComponent, _initialInfectionLevel) == 0x000188, "Member 'UK29PowerStatusHandlerComponent::_initialInfectionLevel' has a wrong offset!");
static_assert(offsetof(UK29PowerStatusHandlerComponent, _addedInfectionLevelsOnGrab) == 0x000208, "Member 'UK29PowerStatusHandlerComponent::_addedInfectionLevelsOnGrab' has a wrong offset!");
static_assert(offsetof(UK29PowerStatusHandlerComponent, _infectionHealingMultiplier) == 0x000288, "Member 'UK29PowerStatusHandlerComponent::_infectionHealingMultiplier' has a wrong offset!");
static_assert(offsetof(UK29PowerStatusHandlerComponent, _infectionIncubationThreshold) == 0x000308, "Member 'UK29PowerStatusHandlerComponent::_infectionIncubationThreshold' has a wrong offset!");
static_assert(offsetof(UK29PowerStatusHandlerComponent, _useInfectionRemoverChargeTime) == 0x000330, "Member 'UK29PowerStatusHandlerComponent::_useInfectionRemoverChargeTime' has a wrong offset!");
static_assert(offsetof(UK29PowerStatusHandlerComponent, _hinderedStatusEffectClass) == 0x0003B0, "Member 'UK29PowerStatusHandlerComponent::_hinderedStatusEffectClass' has a wrong offset!");
static_assert(offsetof(UK29PowerStatusHandlerComponent, _gateBlockerStatusEffectClass) == 0x0003B8, "Member 'UK29PowerStatusHandlerComponent::_gateBlockerStatusEffectClass' has a wrong offset!");
static_assert(offsetof(UK29PowerStatusHandlerComponent, _survivorThrowableClass) == 0x0003C0, "Member 'UK29PowerStatusHandlerComponent::_survivorThrowableClass' has a wrong offset!");
static_assert(offsetof(UK29PowerStatusHandlerComponent, _useInfectionRemoverInteractionSelfClass) == 0x0003C8, "Member 'UK29PowerStatusHandlerComponent::_useInfectionRemoverInteractionSelfClass' has a wrong offset!");
static_assert(offsetof(UK29PowerStatusHandlerComponent, _useInfectionRemoverInteractionOtherClass) == 0x0003D0, "Member 'UK29PowerStatusHandlerComponent::_useInfectionRemoverInteractionOtherClass' has a wrong offset!");
static_assert(offsetof(UK29PowerStatusHandlerComponent, _maxInfectionLevelWhenHooked) == 0x0003D8, "Member 'UK29PowerStatusHandlerComponent::_maxInfectionLevelWhenHooked' has a wrong offset!");
static_assert(offsetof(UK29PowerStatusHandlerComponent, _recentlyGrabbedThresholdSeconds) == 0x0003DC, "Member 'UK29PowerStatusHandlerComponent::_recentlyGrabbedThresholdSeconds' has a wrong offset!");
static_assert(offsetof(UK29PowerStatusHandlerComponent, _survivorStatusList) == 0x0003E0, "Member 'UK29PowerStatusHandlerComponent::_survivorStatusList' has a wrong offset!");

// Class TheK29.K29RushChargeableInteraction
// 0x0870 (0x1130 - 0x08C0)
class UK29RushChargeableInteraction final : public UChargeableInteractionDefinition
{
public:
	uint8                                         Pad_8C0[0x10];                                     // 0x08C0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UK29RushChargesHandlerComponent*        _rushChargesHandlerComponent;                      // 0x08D0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UK29PowerStatusHandlerComponent*        _powerStatusHandlerComponent;                      // 0x08D8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UK29PathingCalculatorComponent*         _pathingCalculatorComponent;                       // 0x08E0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AK29Power*                              _powerCollectable;                                 // 0x08E8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<EK29RushPhase, struct FK29RushMovementSpeedSetting> _movementSpeedSettingsByState;                     // 0x08F0(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UCurveFloat*                            _subsequentRushTimerTimeoutMovementSpeedMultiplierCurve; // 0x0940(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTunableStat                           _subsequentRushTimerTimeoutMovementSpeedReductionDuration; // 0x0948(0x0080)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FTunableStat                           _subsequentRushOpportunityTimerDuration;           // 0x09C8(0x0080)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FTunableStat                           _rushDuration;                                     // 0x0A48(0x0080)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FTunableStat                           _rushDurationAfterFirst;                           // 0x0AC8(0x0080)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _capsuleRadius;                                    // 0x0B48(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _survivorRevealTimeOnInstantPickup;                // 0x0B70(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _capsuleHeight;                                    // 0x0B98(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _capsuleHeightOffset;                              // 0x0BC0(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _bounceDuration;                                   // 0x0BE8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _rushAccelerationMultiplier;                       // 0x0C10(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _instantCarryAnimationDuration;                    // 0x0C38(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         _percentageForRushChargeEndAvailability;           // 0x0C60(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _distanceInCmForNearMiss;                          // 0x0C64(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _rushDetectionBackwardsOffset;                     // 0x0C68(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C6C[0x4];                                      // 0x0C6C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UStatusEffect>              _revealToSurvivorsStatusEffect;                    // 0x0C70(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _rushMovementSpeedInCmPerSecond;                   // 0x0C78(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _rushGrabMovementSpeedInCmPerSecond;               // 0x0CA0(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FTunableStat                           _grabRushDuration;                                 // 0x0CC8(0x0080)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         _rotationStrengthTransitionTime;                   // 0x0D48(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D4C[0x4];                                      // 0x0D4C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _minimumRushDistance;                              // 0x0D50(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _intoGrabbingTime;                                 // 0x0D78(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _smashOutTimerDuration;                            // 0x0DA0(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _isStoppingMomentumAtIntoGrabbing;                 // 0x0DC8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UCurveFloat*                            _movementSpeedCurveBetweenRushesIncreased;         // 0x0DF0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            _movementSpeedCurveChargingIncreased;              // 0x0DF8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            _rushMovementSpeedCurve;                           // 0x0E00(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            _rushMovementSpeedCurveWithSurvivor;               // 0x0E08(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _killerRushSmashAnimationName;                     // 0x0E10(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _survivorRushSmashAnimationName;                   // 0x0E1C(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _killerRushToCarryAnimationName;                   // 0x0E28(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _survivorRushToCarryAnimationName;                 // 0x0E34(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _survivorRushDropAnimationName;                    // 0x0E40(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _killerRushCooldownAnimationName;                  // 0x0E4C(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _animTagFPV;                                       // 0x0E58(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _lagInSecondsUntilRushIsInvalid;                   // 0x0E64(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _rushDropForwardDistance;                          // 0x0E68(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _decisiveStrikeSkillCheckDelay;                    // 0x0E6C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isLagChecked;                                     // 0x0E70(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E71[0x7];                                      // 0x0E71(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UInteractionDefinition>> _survivorInteractionPreventingGrab;                // 0x0E78(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_E88[0x2A8];                                    // 0x0E88(0x02A8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BounceComplete();
	void Cosmetic_DamageSurvivorAsCollision(class ACamperPlayer* Survivor, const ECamperDamageState SurvivorTargetDamageState);
	void Cosmetic_HideEndIndicator();
	void Cosmetic_OnChargeEnd();
	void Cosmetic_OnChargeStart();
	void Cosmetic_OnRushEnd();
	void Cosmetic_OnRushPhaseChanged(EK29RushPhase PreviousPhase, EK29RushPhase NewPhase);
	void Cosmetic_OnRushStart();
	void Cosmetic_OnSlashAtSurvivor(class ACamperPlayer* Survivor, const ECamperDamageState SurvivorTargetDamageState);
	void Cosmetic_ShowEndIndicator(const struct FVector& EndIndicatorLocation, const struct FRotator& ForwardRotation);
	void Multicast_CancelInteraction();
	void Multicast_CarrySurvivor(class ACamperPlayer* SurvivorToCarry);
	void Multicast_ChangeRushPhase(const EK29RushPhase NewRushPhase, const bool ForceLocallyControlled);
	void Multicast_DamageSurvivorAsCollision(const struct FVector& CurrentKillerPosition, class ACamperPlayer* CollidedSurvivor, const ECamperDamageState SurvivorTargetDamageState);
	void Multicast_DestroyPalletOrBreakable(class AActor* Destroyable);
	void Multicast_RushInvalid();
	void Multicast_RushValid();
	void Multicast_SetCurrentRush(const struct FK29GuidedMovementInstance& NewRushInstance);
	void Multicast_SetCurrentRushAsEndingAtLedge();
	void Multicast_SetCurrentRushAsEndingInCollision();
	void Multicast_SlashAtSurvivor(class ACamperPlayer* Survivor, const struct FVector& CurrentKillerPosition, const ECamperDamageState SurvivorTargetDamageState);
	void Multicast_SmashSurvivor(class ACamperPlayer* SurvivorToCarry);
	void OnCollisionEnableTimerComplete();
	void OnGrabbingTransitionComplete();
	void OnInstantCarryTimerComplete(class ACamperPlayer* SurvivorToCarry);
	void OnSmashOutTimerCompleted();
	void OnSubsequentRushOpportunityTimeout();
	void OnWindowOfOpportunityTimeoutCooldownEnd();
	void RushComplete(const bool RushEndedNaturally);
	void Server_CancelInteraction();
	void Server_ChangeRushPhase(const EK29RushPhase NewRushPhase, const float ClientTimeStamp, const bool ForceLocallyControlled);
	void Server_DamageSurvivorAsCollision(class ACamperPlayer* Survivor, const struct FVector& CurrentKillerPosition);
	void Server_DestroyPalletOrBreakable(class AActor* Destroyable);
	void Server_SetCurrentRush(const struct FK29GuidedMovementInstance& NewRushInstance, const EK29RushPhase TargetPhase);
	void Server_SetCurrentRushAsEndingAtLedge();
	void Server_SetCurrentRushAsEndingInCollision(bool HitOtherSurvivor);
	void Server_SlashAtSurvivor(class ACamperPlayer* Survivor, const struct FVector& CurrentKillerPosition);

	float GetRushTimeLeft() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K29RushChargeableInteraction">();
	}
	static class UK29RushChargeableInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK29RushChargeableInteraction>();
	}
};
static_assert(alignof(UK29RushChargeableInteraction) == 0x000010, "Wrong alignment on UK29RushChargeableInteraction");
static_assert(sizeof(UK29RushChargeableInteraction) == 0x001130, "Wrong size on UK29RushChargeableInteraction");
static_assert(offsetof(UK29RushChargeableInteraction, _rushChargesHandlerComponent) == 0x0008D0, "Member 'UK29RushChargeableInteraction::_rushChargesHandlerComponent' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _powerStatusHandlerComponent) == 0x0008D8, "Member 'UK29RushChargeableInteraction::_powerStatusHandlerComponent' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _pathingCalculatorComponent) == 0x0008E0, "Member 'UK29RushChargeableInteraction::_pathingCalculatorComponent' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _powerCollectable) == 0x0008E8, "Member 'UK29RushChargeableInteraction::_powerCollectable' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _movementSpeedSettingsByState) == 0x0008F0, "Member 'UK29RushChargeableInteraction::_movementSpeedSettingsByState' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _subsequentRushTimerTimeoutMovementSpeedMultiplierCurve) == 0x000940, "Member 'UK29RushChargeableInteraction::_subsequentRushTimerTimeoutMovementSpeedMultiplierCurve' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _subsequentRushTimerTimeoutMovementSpeedReductionDuration) == 0x000948, "Member 'UK29RushChargeableInteraction::_subsequentRushTimerTimeoutMovementSpeedReductionDuration' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _subsequentRushOpportunityTimerDuration) == 0x0009C8, "Member 'UK29RushChargeableInteraction::_subsequentRushOpportunityTimerDuration' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _rushDuration) == 0x000A48, "Member 'UK29RushChargeableInteraction::_rushDuration' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _rushDurationAfterFirst) == 0x000AC8, "Member 'UK29RushChargeableInteraction::_rushDurationAfterFirst' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _capsuleRadius) == 0x000B48, "Member 'UK29RushChargeableInteraction::_capsuleRadius' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _survivorRevealTimeOnInstantPickup) == 0x000B70, "Member 'UK29RushChargeableInteraction::_survivorRevealTimeOnInstantPickup' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _capsuleHeight) == 0x000B98, "Member 'UK29RushChargeableInteraction::_capsuleHeight' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _capsuleHeightOffset) == 0x000BC0, "Member 'UK29RushChargeableInteraction::_capsuleHeightOffset' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _bounceDuration) == 0x000BE8, "Member 'UK29RushChargeableInteraction::_bounceDuration' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _rushAccelerationMultiplier) == 0x000C10, "Member 'UK29RushChargeableInteraction::_rushAccelerationMultiplier' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _instantCarryAnimationDuration) == 0x000C38, "Member 'UK29RushChargeableInteraction::_instantCarryAnimationDuration' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _percentageForRushChargeEndAvailability) == 0x000C60, "Member 'UK29RushChargeableInteraction::_percentageForRushChargeEndAvailability' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _distanceInCmForNearMiss) == 0x000C64, "Member 'UK29RushChargeableInteraction::_distanceInCmForNearMiss' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _rushDetectionBackwardsOffset) == 0x000C68, "Member 'UK29RushChargeableInteraction::_rushDetectionBackwardsOffset' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _revealToSurvivorsStatusEffect) == 0x000C70, "Member 'UK29RushChargeableInteraction::_revealToSurvivorsStatusEffect' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _rushMovementSpeedInCmPerSecond) == 0x000C78, "Member 'UK29RushChargeableInteraction::_rushMovementSpeedInCmPerSecond' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _rushGrabMovementSpeedInCmPerSecond) == 0x000CA0, "Member 'UK29RushChargeableInteraction::_rushGrabMovementSpeedInCmPerSecond' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _grabRushDuration) == 0x000CC8, "Member 'UK29RushChargeableInteraction::_grabRushDuration' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _rotationStrengthTransitionTime) == 0x000D48, "Member 'UK29RushChargeableInteraction::_rotationStrengthTransitionTime' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _minimumRushDistance) == 0x000D50, "Member 'UK29RushChargeableInteraction::_minimumRushDistance' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _intoGrabbingTime) == 0x000D78, "Member 'UK29RushChargeableInteraction::_intoGrabbingTime' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _smashOutTimerDuration) == 0x000DA0, "Member 'UK29RushChargeableInteraction::_smashOutTimerDuration' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _isStoppingMomentumAtIntoGrabbing) == 0x000DC8, "Member 'UK29RushChargeableInteraction::_isStoppingMomentumAtIntoGrabbing' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _movementSpeedCurveBetweenRushesIncreased) == 0x000DF0, "Member 'UK29RushChargeableInteraction::_movementSpeedCurveBetweenRushesIncreased' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _movementSpeedCurveChargingIncreased) == 0x000DF8, "Member 'UK29RushChargeableInteraction::_movementSpeedCurveChargingIncreased' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _rushMovementSpeedCurve) == 0x000E00, "Member 'UK29RushChargeableInteraction::_rushMovementSpeedCurve' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _rushMovementSpeedCurveWithSurvivor) == 0x000E08, "Member 'UK29RushChargeableInteraction::_rushMovementSpeedCurveWithSurvivor' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _killerRushSmashAnimationName) == 0x000E10, "Member 'UK29RushChargeableInteraction::_killerRushSmashAnimationName' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _survivorRushSmashAnimationName) == 0x000E1C, "Member 'UK29RushChargeableInteraction::_survivorRushSmashAnimationName' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _killerRushToCarryAnimationName) == 0x000E28, "Member 'UK29RushChargeableInteraction::_killerRushToCarryAnimationName' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _survivorRushToCarryAnimationName) == 0x000E34, "Member 'UK29RushChargeableInteraction::_survivorRushToCarryAnimationName' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _survivorRushDropAnimationName) == 0x000E40, "Member 'UK29RushChargeableInteraction::_survivorRushDropAnimationName' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _killerRushCooldownAnimationName) == 0x000E4C, "Member 'UK29RushChargeableInteraction::_killerRushCooldownAnimationName' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _animTagFPV) == 0x000E58, "Member 'UK29RushChargeableInteraction::_animTagFPV' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _lagInSecondsUntilRushIsInvalid) == 0x000E64, "Member 'UK29RushChargeableInteraction::_lagInSecondsUntilRushIsInvalid' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _rushDropForwardDistance) == 0x000E68, "Member 'UK29RushChargeableInteraction::_rushDropForwardDistance' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _decisiveStrikeSkillCheckDelay) == 0x000E6C, "Member 'UK29RushChargeableInteraction::_decisiveStrikeSkillCheckDelay' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _isLagChecked) == 0x000E70, "Member 'UK29RushChargeableInteraction::_isLagChecked' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _survivorInteractionPreventingGrab) == 0x000E78, "Member 'UK29RushChargeableInteraction::_survivorInteractionPreventingGrab' has a wrong offset!");

// Class TheK29.K29RushChargesHandlerComponent
// 0x0178 (0x0220 - 0x00A8)
class UK29RushChargesHandlerComponent final : public UActorComponent
{
public:
	struct FTunableStat                           _maximumRushCharges;                               // 0x00A8(0x0080)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UCurveFloat*                            _rechargeTimeByChargesLeft;                        // 0x0128(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTunableStat                           _rechargeDurationMultiplier;                       // 0x0130(0x0080)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _reducedChargeTimePerInfectionPlayers;             // 0x01B0(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1D8[0x48];                                     // 0x01D8(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddSingleCharge();
	void Cosmetic_OnOutOfRushCharges();
	void Cosmetic_OnRushChargeAdded();
	void OnKillerSet(class ASlasherPlayer* Killer);
	void OnMaximumChargesChanged(const float NewValue);
	void SetToFullCharge();

	int32 GetAvailableCharges() const;
	int32 GetMaximumCharges() const;
	float GetPercentageRemainingUntilNextCharge() const;
	float GetRechargeDuration() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K29RushChargesHandlerComponent">();
	}
	static class UK29RushChargesHandlerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK29RushChargesHandlerComponent>();
	}
};
static_assert(alignof(UK29RushChargesHandlerComponent) == 0x000008, "Wrong alignment on UK29RushChargesHandlerComponent");
static_assert(sizeof(UK29RushChargesHandlerComponent) == 0x000220, "Wrong size on UK29RushChargesHandlerComponent");
static_assert(offsetof(UK29RushChargesHandlerComponent, _maximumRushCharges) == 0x0000A8, "Member 'UK29RushChargesHandlerComponent::_maximumRushCharges' has a wrong offset!");
static_assert(offsetof(UK29RushChargesHandlerComponent, _rechargeTimeByChargesLeft) == 0x000128, "Member 'UK29RushChargesHandlerComponent::_rechargeTimeByChargesLeft' has a wrong offset!");
static_assert(offsetof(UK29RushChargesHandlerComponent, _rechargeDurationMultiplier) == 0x000130, "Member 'UK29RushChargesHandlerComponent::_rechargeDurationMultiplier' has a wrong offset!");
static_assert(offsetof(UK29RushChargesHandlerComponent, _reducedChargeTimePerInfectionPlayers) == 0x0001B0, "Member 'UK29RushChargesHandlerComponent::_reducedChargeTimePerInfectionPlayers' has a wrong offset!");

// Class TheK29.K29RushCooldownInteraction
// 0x00E0 (0x0860 - 0x0780)
class UK29RushCooldownInteraction final : public UInteractionDefinition
{
public:
	struct FTunableStat                           _cooldownTime;                                     // 0x0778(0x0080)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          _isCameraRestrictedForDuration;                    // 0x07F8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7F9[0x7];                                      // 0x07F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _cameraRestrictionTime;                            // 0x0800(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_828[0x38];                                     // 0x0828(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ResetCameraInputLimit();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K29RushCooldownInteraction">();
	}
	static class UK29RushCooldownInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK29RushCooldownInteraction>();
	}
};
static_assert(alignof(UK29RushCooldownInteraction) == 0x000010, "Wrong alignment on UK29RushCooldownInteraction");
static_assert(sizeof(UK29RushCooldownInteraction) == 0x000860, "Wrong size on UK29RushCooldownInteraction");
static_assert(offsetof(UK29RushCooldownInteraction, _cooldownTime) == 0x000778, "Member 'UK29RushCooldownInteraction::_cooldownTime' has a wrong offset!");
static_assert(offsetof(UK29RushCooldownInteraction, _isCameraRestrictedForDuration) == 0x0007F8, "Member 'UK29RushCooldownInteraction::_isCameraRestrictedForDuration' has a wrong offset!");
static_assert(offsetof(UK29RushCooldownInteraction, _cameraRestrictionTime) == 0x000800, "Member 'UK29RushCooldownInteraction::_cameraRestrictionTime' has a wrong offset!");

// Class TheK29.K29SupplyCrateOutlineUpdateStrategy
// 0x0000 (0x00F0 - 0x00F0)
class UK29SupplyCrateOutlineUpdateStrategy final : public UDefaultOutlineUpdateStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K29SupplyCrateOutlineUpdateStrategy">();
	}
	static class UK29SupplyCrateOutlineUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK29SupplyCrateOutlineUpdateStrategy>();
	}
};
static_assert(alignof(UK29SupplyCrateOutlineUpdateStrategy) == 0x000008, "Wrong alignment on UK29SupplyCrateOutlineUpdateStrategy");
static_assert(sizeof(UK29SupplyCrateOutlineUpdateStrategy) == 0x0000F0, "Wrong size on UK29SupplyCrateOutlineUpdateStrategy");

// Class TheK29.K29SurvivorAnimInstance
// 0x0060 (0x0640 - 0x05E0)
class UK29SurvivorAnimInstance final : public UBaseSurvivorAnimInstance
{
public:
	uint8                                         Pad_5E0[0x8];                                      // 0x05E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _isBeingGrabbed;                                   // 0x05E8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isBeingThrown;                                    // 0x05E9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isKillerLocallyControlled;                        // 0x05EA(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isUsingInfectionRemoverOnSelf;                    // 0x05EB(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isUsingInfectionRemoverOnOther;                   // 0x05EC(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isInfectionRemoverUsedOnSelf;                     // 0x05ED(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _hasLastThrowResultedInDamage;                     // 0x05EE(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isInfectionActive;                                // 0x05EF(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _hasBeenThrown;                                    // 0x05F0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isCoughing;                                       // 0x05F1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5F2[0x2];                                      // 0x05F2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _timeBetweenRandomCoughingTry;                     // 0x05F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _randomCoughMinProbabilityRange;                   // 0x05F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _randomCoughMaxProbabilityRange;                   // 0x05FC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _randomCoughProbabilityThreshold;                  // 0x0600(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isCrawling;                                       // 0x0604(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isInsideCloset;                                   // 0x0605(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isDead;                                           // 0x0606(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isInteracting;                                    // 0x0607(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isInjured;                                        // 0x0608(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isHoldingObject;                                  // 0x0609(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isCrouched;                                       // 0x060A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isHooked;                                         // 0x060B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isIdle;                                           // 0x060C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isUsingAimItem;                                   // 0x060D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isInAir;                                          // 0x060E(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isBeingHealed;                                    // 0x060F(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_610[0x30];                                     // 0x0610(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnGameEventReceived(const struct FGameplayTag& GameplayTag, const struct FGameEventData& GameEventData);
	void OnHasBeenThrown();
	void ResetHasBeenThrown();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K29SurvivorAnimInstance">();
	}
	static class UK29SurvivorAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK29SurvivorAnimInstance>();
	}
};
static_assert(alignof(UK29SurvivorAnimInstance) == 0x000010, "Wrong alignment on UK29SurvivorAnimInstance");
static_assert(sizeof(UK29SurvivorAnimInstance) == 0x000640, "Wrong size on UK29SurvivorAnimInstance");
static_assert(offsetof(UK29SurvivorAnimInstance, _isBeingGrabbed) == 0x0005E8, "Member 'UK29SurvivorAnimInstance::_isBeingGrabbed' has a wrong offset!");
static_assert(offsetof(UK29SurvivorAnimInstance, _isBeingThrown) == 0x0005E9, "Member 'UK29SurvivorAnimInstance::_isBeingThrown' has a wrong offset!");
static_assert(offsetof(UK29SurvivorAnimInstance, _isKillerLocallyControlled) == 0x0005EA, "Member 'UK29SurvivorAnimInstance::_isKillerLocallyControlled' has a wrong offset!");
static_assert(offsetof(UK29SurvivorAnimInstance, _isUsingInfectionRemoverOnSelf) == 0x0005EB, "Member 'UK29SurvivorAnimInstance::_isUsingInfectionRemoverOnSelf' has a wrong offset!");
static_assert(offsetof(UK29SurvivorAnimInstance, _isUsingInfectionRemoverOnOther) == 0x0005EC, "Member 'UK29SurvivorAnimInstance::_isUsingInfectionRemoverOnOther' has a wrong offset!");
static_assert(offsetof(UK29SurvivorAnimInstance, _isInfectionRemoverUsedOnSelf) == 0x0005ED, "Member 'UK29SurvivorAnimInstance::_isInfectionRemoverUsedOnSelf' has a wrong offset!");
static_assert(offsetof(UK29SurvivorAnimInstance, _hasLastThrowResultedInDamage) == 0x0005EE, "Member 'UK29SurvivorAnimInstance::_hasLastThrowResultedInDamage' has a wrong offset!");
static_assert(offsetof(UK29SurvivorAnimInstance, _isInfectionActive) == 0x0005EF, "Member 'UK29SurvivorAnimInstance::_isInfectionActive' has a wrong offset!");
static_assert(offsetof(UK29SurvivorAnimInstance, _hasBeenThrown) == 0x0005F0, "Member 'UK29SurvivorAnimInstance::_hasBeenThrown' has a wrong offset!");
static_assert(offsetof(UK29SurvivorAnimInstance, _isCoughing) == 0x0005F1, "Member 'UK29SurvivorAnimInstance::_isCoughing' has a wrong offset!");
static_assert(offsetof(UK29SurvivorAnimInstance, _timeBetweenRandomCoughingTry) == 0x0005F4, "Member 'UK29SurvivorAnimInstance::_timeBetweenRandomCoughingTry' has a wrong offset!");
static_assert(offsetof(UK29SurvivorAnimInstance, _randomCoughMinProbabilityRange) == 0x0005F8, "Member 'UK29SurvivorAnimInstance::_randomCoughMinProbabilityRange' has a wrong offset!");
static_assert(offsetof(UK29SurvivorAnimInstance, _randomCoughMaxProbabilityRange) == 0x0005FC, "Member 'UK29SurvivorAnimInstance::_randomCoughMaxProbabilityRange' has a wrong offset!");
static_assert(offsetof(UK29SurvivorAnimInstance, _randomCoughProbabilityThreshold) == 0x000600, "Member 'UK29SurvivorAnimInstance::_randomCoughProbabilityThreshold' has a wrong offset!");
static_assert(offsetof(UK29SurvivorAnimInstance, _isCrawling) == 0x000604, "Member 'UK29SurvivorAnimInstance::_isCrawling' has a wrong offset!");
static_assert(offsetof(UK29SurvivorAnimInstance, _isInsideCloset) == 0x000605, "Member 'UK29SurvivorAnimInstance::_isInsideCloset' has a wrong offset!");
static_assert(offsetof(UK29SurvivorAnimInstance, _isDead) == 0x000606, "Member 'UK29SurvivorAnimInstance::_isDead' has a wrong offset!");
static_assert(offsetof(UK29SurvivorAnimInstance, _isInteracting) == 0x000607, "Member 'UK29SurvivorAnimInstance::_isInteracting' has a wrong offset!");
static_assert(offsetof(UK29SurvivorAnimInstance, _isInjured) == 0x000608, "Member 'UK29SurvivorAnimInstance::_isInjured' has a wrong offset!");
static_assert(offsetof(UK29SurvivorAnimInstance, _isHoldingObject) == 0x000609, "Member 'UK29SurvivorAnimInstance::_isHoldingObject' has a wrong offset!");
static_assert(offsetof(UK29SurvivorAnimInstance, _isCrouched) == 0x00060A, "Member 'UK29SurvivorAnimInstance::_isCrouched' has a wrong offset!");
static_assert(offsetof(UK29SurvivorAnimInstance, _isHooked) == 0x00060B, "Member 'UK29SurvivorAnimInstance::_isHooked' has a wrong offset!");
static_assert(offsetof(UK29SurvivorAnimInstance, _isIdle) == 0x00060C, "Member 'UK29SurvivorAnimInstance::_isIdle' has a wrong offset!");
static_assert(offsetof(UK29SurvivorAnimInstance, _isUsingAimItem) == 0x00060D, "Member 'UK29SurvivorAnimInstance::_isUsingAimItem' has a wrong offset!");
static_assert(offsetof(UK29SurvivorAnimInstance, _isInAir) == 0x00060E, "Member 'UK29SurvivorAnimInstance::_isInAir' has a wrong offset!");
static_assert(offsetof(UK29SurvivorAnimInstance, _isBeingHealed) == 0x00060F, "Member 'UK29SurvivorAnimInstance::_isBeingHealed' has a wrong offset!");

// Class TheK29.K29SurvivorCarriableComponent
// 0x0090 (0x0138 - 0x00A8)
class UK29SurvivorCarriableComponent final : public UActorComponent
{
public:
	class FName                                   _rootJointName;                                    // 0x00A8(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B4[0x4];                                       // 0x00B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               _startingRotation;                                 // 0x00B8(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	struct FVector                                _startingPosition;                                 // 0x00D0(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isCarriedByK29Rush;                               // 0x00E8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E9[0x3];                                       // 0x00E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _killerIngoreTime;                                 // 0x00EC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class ACamperPlayer>           _owningSurvivor;                                   // 0x00F0(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F8[0x40];                                      // 0x00F8(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsBeingCarriedByK29RushOrMarkedForThrow();
	void OnKillerSet(class ASlasherPlayer* Killer);
	void OnRep_OwningSurvivor();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K29SurvivorCarriableComponent">();
	}
	static class UK29SurvivorCarriableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK29SurvivorCarriableComponent>();
	}
};
static_assert(alignof(UK29SurvivorCarriableComponent) == 0x000008, "Wrong alignment on UK29SurvivorCarriableComponent");
static_assert(sizeof(UK29SurvivorCarriableComponent) == 0x000138, "Wrong size on UK29SurvivorCarriableComponent");
static_assert(offsetof(UK29SurvivorCarriableComponent, _rootJointName) == 0x0000A8, "Member 'UK29SurvivorCarriableComponent::_rootJointName' has a wrong offset!");
static_assert(offsetof(UK29SurvivorCarriableComponent, _startingRotation) == 0x0000B8, "Member 'UK29SurvivorCarriableComponent::_startingRotation' has a wrong offset!");
static_assert(offsetof(UK29SurvivorCarriableComponent, _startingPosition) == 0x0000D0, "Member 'UK29SurvivorCarriableComponent::_startingPosition' has a wrong offset!");
static_assert(offsetof(UK29SurvivorCarriableComponent, _isCarriedByK29Rush) == 0x0000E8, "Member 'UK29SurvivorCarriableComponent::_isCarriedByK29Rush' has a wrong offset!");
static_assert(offsetof(UK29SurvivorCarriableComponent, _killerIngoreTime) == 0x0000EC, "Member 'UK29SurvivorCarriableComponent::_killerIngoreTime' has a wrong offset!");
static_assert(offsetof(UK29SurvivorCarriableComponent, _owningSurvivor) == 0x0000F0, "Member 'UK29SurvivorCarriableComponent::_owningSurvivor' has a wrong offset!");

// Class TheK29.K29SurvivorCosmeticHelperActor
// 0x00C0 (0x03C8 - 0x0308)
class AK29SurvivorCosmeticHelperActor final : public ASurvivorCosmeticHelperActor
{
public:
	uint8                                         Pad_308[0xC0];                                     // 0x0308(0x00C0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_GrabbedByKiller();
	void Cosmetic_IsInfectedActiveChanged(const bool Param_IsInfectionActive);
	void Cosmetic_IsInfectedChanged(const bool Param_IsInfected);
	void Cosmetic_IsInfectionCriticalChanged(const bool Param_IsInfectionCritical);
	void Cosmetic_IsInfectionIncubatedChanged(const bool Param_IsInfectionIncubated);
	void Cosmetic_OnInfectionLevelsChanged(const bool IsActive);
	void Cosmetic_OnInfectionRemovalCollectableUsed();
	void Cosmetic_OnLocallyObservedChanged();
	void Cosmetic_OnOwningSurvivorDied();
	void Cosmetic_OnOwningSurvivorHitCollisionWithRush();
	void OnInfectionLevelsChanged(class ACamperPlayer* TargetSurvivor, bool IsActive);
	void OnInfectionRemovalCollectableUsed(class ACamperPlayer* Survivor);
	void OnLevelReadyToPlay();
	void OnOwnerLocallyObserved(bool LocallyObserved);
	void OnSurvivorDisguisedOrUndisguised(bool IsDisguised);
	void OnSurvivorGrabbed(class ACamperPlayer* Survivor);

	int32 GetCurrentInfectionLevels() const;
	float GetCurrentInfectionPercentage() const;
	int32 GetMaximumInfectionLevels() const;
	bool IsInfected() const;
	bool IsInfectionActive() const;
	bool IsInfectionCritical() const;
	bool IsInfectionIncubated() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K29SurvivorCosmeticHelperActor">();
	}
	static class AK29SurvivorCosmeticHelperActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK29SurvivorCosmeticHelperActor>();
	}
};
static_assert(alignof(AK29SurvivorCosmeticHelperActor) == 0x000008, "Wrong alignment on AK29SurvivorCosmeticHelperActor");
static_assert(sizeof(AK29SurvivorCosmeticHelperActor) == 0x0003C8, "Wrong size on AK29SurvivorCosmeticHelperActor");

// Class TheK29.K29SurvivorStatusComponent
// 0x0018 (0x00C0 - 0x00A8)
class UK29SurvivorStatusComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UK29PowerStatusHandlerComponent> _powerStatusHandlerComponent;                      // 0x00B0(0x0008)(ExportObject, Net, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class ACamperPlayer>           _owningSurvivor;                                   // 0x00B8(0x0008)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K29SurvivorStatusComponent">();
	}
	static class UK29SurvivorStatusComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK29SurvivorStatusComponent>();
	}
};
static_assert(alignof(UK29SurvivorStatusComponent) == 0x000008, "Wrong alignment on UK29SurvivorStatusComponent");
static_assert(sizeof(UK29SurvivorStatusComponent) == 0x0000C0, "Wrong size on UK29SurvivorStatusComponent");
static_assert(offsetof(UK29SurvivorStatusComponent, _powerStatusHandlerComponent) == 0x0000B0, "Member 'UK29SurvivorStatusComponent::_powerStatusHandlerComponent' has a wrong offset!");
static_assert(offsetof(UK29SurvivorStatusComponent, _owningSurvivor) == 0x0000B8, "Member 'UK29SurvivorStatusComponent::_owningSurvivor' has a wrong offset!");

// Class TheK29.K29SurvivorThrowableComponent
// 0x0380 (0x0428 - 0x00A8)
class UK29SurvivorThrowableComponent final : public UActorComponent
{
public:
	struct FTunableStat                           _throwDuration;                                    // 0x00A8(0x0080)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _capsuleRadius;                                    // 0x0128(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _capsuleHeight;                                    // 0x0150(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _capsuleHeightOffset;                              // 0x0178(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _minimumThrowDistance;                             // 0x01A0(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _throwMovementSpeedInCmPerSecond;                  // 0x01C8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _movingDelay;                                      // 0x01F0(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _throwDelay;                                       // 0x0218(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _throwLedgeDropDistance;                           // 0x0240(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _throwLedgeDropTime;                               // 0x0268(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UCurveFloat*                            _throwMovementSpeedMultiplierCurve;                // 0x0290(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _throwAccelerationMultiplier;                      // 0x0298(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C0[0x168];                                    // 0x02C0(0x0168)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_OnSurvivorUsedAsCollision(class ACamperPlayer* Survivor);
	void EndThrow();
	void Multicast_CancelThrowOnOtherSurvivorCollision(const struct FVector& CollisionPosition, class ACamperPlayer* SurvivorUsedAsCollision);
	void Multicast_EndThrow();
	void Multicast_InstantlyLetGoSurvivor(const bool HasDealtDamage);
	void Multicast_SetCurrentThrow(const struct FK29GuidedMovementInstance& ThrowInstance, class ACamperPlayer* ThrownSurvivor);
	void OnThrowTimeout();
	void OnWalkingAllowedAfterFall();
	void Server_CancelThrowOnOtherSurvivorCollision(const struct FVector& CollisionPosition, class ACamperPlayer* SurvivorUsedAsCollision);
	void Server_EndThrow();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K29SurvivorThrowableComponent">();
	}
	static class UK29SurvivorThrowableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK29SurvivorThrowableComponent>();
	}
};
static_assert(alignof(UK29SurvivorThrowableComponent) == 0x000008, "Wrong alignment on UK29SurvivorThrowableComponent");
static_assert(sizeof(UK29SurvivorThrowableComponent) == 0x000428, "Wrong size on UK29SurvivorThrowableComponent");
static_assert(offsetof(UK29SurvivorThrowableComponent, _throwDuration) == 0x0000A8, "Member 'UK29SurvivorThrowableComponent::_throwDuration' has a wrong offset!");
static_assert(offsetof(UK29SurvivorThrowableComponent, _capsuleRadius) == 0x000128, "Member 'UK29SurvivorThrowableComponent::_capsuleRadius' has a wrong offset!");
static_assert(offsetof(UK29SurvivorThrowableComponent, _capsuleHeight) == 0x000150, "Member 'UK29SurvivorThrowableComponent::_capsuleHeight' has a wrong offset!");
static_assert(offsetof(UK29SurvivorThrowableComponent, _capsuleHeightOffset) == 0x000178, "Member 'UK29SurvivorThrowableComponent::_capsuleHeightOffset' has a wrong offset!");
static_assert(offsetof(UK29SurvivorThrowableComponent, _minimumThrowDistance) == 0x0001A0, "Member 'UK29SurvivorThrowableComponent::_minimumThrowDistance' has a wrong offset!");
static_assert(offsetof(UK29SurvivorThrowableComponent, _throwMovementSpeedInCmPerSecond) == 0x0001C8, "Member 'UK29SurvivorThrowableComponent::_throwMovementSpeedInCmPerSecond' has a wrong offset!");
static_assert(offsetof(UK29SurvivorThrowableComponent, _movingDelay) == 0x0001F0, "Member 'UK29SurvivorThrowableComponent::_movingDelay' has a wrong offset!");
static_assert(offsetof(UK29SurvivorThrowableComponent, _throwDelay) == 0x000218, "Member 'UK29SurvivorThrowableComponent::_throwDelay' has a wrong offset!");
static_assert(offsetof(UK29SurvivorThrowableComponent, _throwLedgeDropDistance) == 0x000240, "Member 'UK29SurvivorThrowableComponent::_throwLedgeDropDistance' has a wrong offset!");
static_assert(offsetof(UK29SurvivorThrowableComponent, _throwLedgeDropTime) == 0x000268, "Member 'UK29SurvivorThrowableComponent::_throwLedgeDropTime' has a wrong offset!");
static_assert(offsetof(UK29SurvivorThrowableComponent, _throwMovementSpeedMultiplierCurve) == 0x000290, "Member 'UK29SurvivorThrowableComponent::_throwMovementSpeedMultiplierCurve' has a wrong offset!");
static_assert(offsetof(UK29SurvivorThrowableComponent, _throwAccelerationMultiplier) == 0x000298, "Member 'UK29SurvivorThrowableComponent::_throwAccelerationMultiplier' has a wrong offset!");

// Class TheK29.K29UseInfectionRemoverInteraction
// 0x0040 (0x0900 - 0x08C0)
#pragma pack(push, 0x1)
class alignas(0x10) UK29UseInfectionRemoverInteraction : public UChargeableInteractionDefinition
{
public:
	TSubclassOf<class UStatusEffect>              _killerInstinctClass;                              // 0x08C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _killerInstinctDuration;                           // 0x08C8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8F0[0x8];                                      // 0x08F0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnSurvivorCured_Cosmetic();

	class ACamperPlayer* GetInteractionTarget() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K29UseInfectionRemoverInteraction">();
	}
	static class UK29UseInfectionRemoverInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK29UseInfectionRemoverInteraction>();
	}
};
#pragma pack(pop)
static_assert(alignof(UK29UseInfectionRemoverInteraction) == 0x000010, "Wrong alignment on UK29UseInfectionRemoverInteraction");
static_assert(sizeof(UK29UseInfectionRemoverInteraction) == 0x000900, "Wrong size on UK29UseInfectionRemoverInteraction");
static_assert(offsetof(UK29UseInfectionRemoverInteraction, _killerInstinctClass) == 0x0008C0, "Member 'UK29UseInfectionRemoverInteraction::_killerInstinctClass' has a wrong offset!");
static_assert(offsetof(UK29UseInfectionRemoverInteraction, _killerInstinctDuration) == 0x0008C8, "Member 'UK29UseInfectionRemoverInteraction::_killerInstinctDuration' has a wrong offset!");

// Class TheK29.K29UseInfectionRemoverInteractionOther
// 0x0010 (0x0910 - 0x0900)
class UK29UseInfectionRemoverInteractionOther final : public UK29UseInfectionRemoverInteraction
{
public:
	TSubclassOf<class UStatusEffect>              _crouchBlockStatusEffectClass;                     // 0x08F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_900[0x8];                                      // 0x0900(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UStatusEffect*                          _crouchBlockStatusEffect;                          // 0x0908(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K29UseInfectionRemoverInteractionOther">();
	}
	static class UK29UseInfectionRemoverInteractionOther* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK29UseInfectionRemoverInteractionOther>();
	}
};
static_assert(alignof(UK29UseInfectionRemoverInteractionOther) == 0x000010, "Wrong alignment on UK29UseInfectionRemoverInteractionOther");
static_assert(sizeof(UK29UseInfectionRemoverInteractionOther) == 0x000910, "Wrong size on UK29UseInfectionRemoverInteractionOther");
static_assert(offsetof(UK29UseInfectionRemoverInteractionOther, _crouchBlockStatusEffectClass) == 0x0008F8, "Member 'UK29UseInfectionRemoverInteractionOther::_crouchBlockStatusEffectClass' has a wrong offset!");
static_assert(offsetof(UK29UseInfectionRemoverInteractionOther, _crouchBlockStatusEffect) == 0x000908, "Member 'UK29UseInfectionRemoverInteractionOther::_crouchBlockStatusEffect' has a wrong offset!");

// Class TheK29.K29UseInfectionRemoverInteractionSelf
// 0x0000 (0x0900 - 0x0900)
class UK29UseInfectionRemoverInteractionSelf final : public UK29UseInfectionRemoverInteraction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K29UseInfectionRemoverInteractionSelf">();
	}
	static class UK29UseInfectionRemoverInteractionSelf* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK29UseInfectionRemoverInteractionSelf>();
	}
};
static_assert(alignof(UK29UseInfectionRemoverInteractionSelf) == 0x000010, "Wrong alignment on UK29UseInfectionRemoverInteractionSelf");
static_assert(sizeof(UK29UseInfectionRemoverInteractionSelf) == 0x000900, "Wrong size on UK29UseInfectionRemoverInteractionSelf");

// Class TheK29.K29Utilities
// 0x0000 (0x0030 - 0x0030)
class UK29Utilities final : public UBlueprintFunctionLibrary
{
public:
	static class AK29Power* GetK29Power(const class UObject* WorldContextObject);
	static bool IsSurvivorAbleToBeAffectedByPower(const class AActor* SurvivorAsActor, const class ASlasherPlayer* Killer);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K29Utilities">();
	}
	static class UK29Utilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK29Utilities>();
	}
};
static_assert(alignof(UK29Utilities) == 0x000008, "Wrong alignment on UK29Utilities");
static_assert(sizeof(UK29Utilities) == 0x000030, "Wrong size on UK29Utilities");

}

