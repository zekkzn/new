#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: TheNightmare

#include "Basic.hpp"

#include "TheNightmare_classes.hpp"
#include "TheNightmare_parameters.hpp"


namespace SDK
{

// Function TheNightmare.NightmareCheatComponent.DBD_AllowWakeUpAtAnyClock
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    Allow                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNightmareCheatComponent::DBD_AllowWakeUpAtAnyClock(bool Allow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NightmareCheatComponent", "DBD_AllowWakeUpAtAnyClock");

	Params::NightmareCheatComponent_DBD_AllowWakeUpAtAnyClock Parms{};

	Parms.Allow = Allow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TheNightmare.NightmareCheatComponent.OnRep_AllowWakeUpAnyClock
// (Final, Native, Private)

void UNightmareCheatComponent::OnRep_AllowWakeUpAnyClock()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NightmareCheatComponent", "OnRep_AllowWakeUpAnyClock");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TheNightmare.BloodWarden.GetPerkLevelSpikeDurationsAtLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UBloodWarden::GetPerkLevelSpikeDurationsAtLevel() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BloodWarden", "GetPerkLevelSpikeDurationsAtLevel");

	Params::BloodWarden_GetPerkLevelSpikeDurationsAtLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TheNightmare.DreamInducerComponent.Authority_OnLevelReadyToPlay
// (Final, Native, Private)

void UDreamInducerComponent::Authority_OnLevelReadyToPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DreamInducerComponent", "Authority_OnLevelReadyToPlay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TheNightmare.GeneratorDreamworldComponent.Cosmetic_OnPlayerFailSkillCheck
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGeneratorDreamworldComponent::Cosmetic_OnPlayerFailSkillCheck(class ADBDPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorDreamworldComponent", "Cosmetic_OnPlayerFailSkillCheck");

	Params::GeneratorDreamworldComponent_Cosmetic_OnPlayerFailSkillCheck Parms{};

	Parms.Player = Player;

	UObject::ProcessEvent(Func, &Parms);
}


// Function TheNightmare.GeneratorDreamworldComponent.OnRepairSkillCheckFailed
// (Final, Native, Private)
// Parameters:
// bool                                    Success                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Bonus                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    TriggerLoudNoise                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    HadInput                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESkillCheckCustomType                   Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ChargeChange                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGeneratorDreamworldComponent::OnRepairSkillCheckFailed(bool Success, bool Bonus, class ADBDPlayer* Player, bool TriggerLoudNoise, bool HadInput, ESkillCheckCustomType Type, float ChargeChange)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorDreamworldComponent", "OnRepairSkillCheckFailed");

	Params::GeneratorDreamworldComponent_OnRepairSkillCheckFailed Parms{};

	Parms.Success = Success;
	Parms.Bonus = Bonus;
	Parms.Player = Player;
	Parms.TriggerLoudNoise = TriggerLoudNoise;
	Parms.HadInput = HadInput;
	Parms.Type = Type;
	Parms.ChargeChange = ChargeChange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TheNightmare.DreamSnareEffect.OnActorBeginOverlap
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDreamSnareEffect::OnActorBeginOverlap(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DreamSnareEffect", "OnActorBeginOverlap");

	Params::DreamSnareEffect_OnActorBeginOverlap Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function TheNightmare.DreamSnareEffect.OnActorEndOverlap
// (Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDreamSnareEffect::OnActorEndOverlap(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DreamSnareEffect", "OnActorEndOverlap");

	Params::DreamSnareEffect_OnActorEndOverlap Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function TheNightmare.FireUp.GetSpeedBonusAtLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UFireUp::GetSpeedBonusAtLevel() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FireUp", "GetSpeedBonusAtLevel");

	Params::FireUp_GetSpeedBonusAtLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TheNightmare.GeneratorTeleportInteraction.Authority_StartTeleportCooldown
// (Final, BlueprintAuthorityOnly, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    Teleported                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGeneratorTeleportInteraction::Authority_StartTeleportCooldown(bool Teleported)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorTeleportInteraction", "Authority_StartTeleportCooldown");

	Params::GeneratorTeleportInteraction_Authority_StartTeleportCooldown Parms{};

	Parms.Teleported = Teleported;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TheNightmare.GeneratorTeleportInteraction.Authority_TeleportPlayerToGenerator
// (Final, BlueprintAuthorityOnly, Native, Protected, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       PlayerToTeleport                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AGenerator*                       Generator                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGeneratorTeleportInteraction::Authority_TeleportPlayerToGenerator(class ADBDPlayer* PlayerToTeleport, class AGenerator* Generator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorTeleportInteraction", "Authority_TeleportPlayerToGenerator");

	Params::GeneratorTeleportInteraction_Authority_TeleportPlayerToGenerator Parms{};

	Parms.PlayerToTeleport = PlayerToTeleport;
	Parms.Generator = Generator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TheNightmare.GeneratorTeleportInteraction.InitializeTunableValues
// (Final, Native, Private)
// Parameters:
// class ASlasherPlayer*                   Killer                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGeneratorTeleportInteraction::InitializeTunableValues(class ASlasherPlayer* Killer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorTeleportInteraction", "InitializeTunableValues");

	Params::GeneratorTeleportInteraction_InitializeTunableValues Parms{};

	Parms.Killer = Killer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TheNightmare.GeneratorTeleportInteraction.Multicast_OnTeleportLocationChosen
// (Net, NetReliable, Native, Event, NetMulticast, Protected, HasDefaults)
// Parameters:
// class AGenerator*                       Generator                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       Location                                               (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGeneratorTeleportInteraction::Multicast_OnTeleportLocationChosen(class AGenerator* Generator, const struct FTransform& Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorTeleportInteraction", "Multicast_OnTeleportLocationChosen");

	Params::GeneratorTeleportInteraction_Multicast_OnTeleportLocationChosen Parms{};

	Parms.Generator = Generator;
	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TheNightmare.GeneratorTeleportInteraction.Multicast_TeleportPlayer
// (Net, NetReliable, Native, Event, NetMulticast, Protected, HasDefaults)
// Parameters:
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         Rotation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UGeneratorTeleportInteraction::Multicast_TeleportPlayer(const struct FVector& Location, const struct FRotator& Rotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorTeleportInteraction", "Multicast_TeleportPlayer");

	Params::GeneratorTeleportInteraction_Multicast_TeleportPlayer Parms{};

	Parms.Location = std::move(Location);
	Parms.Rotation = std::move(Rotation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TheNightmare.GeneratorTeleportInteraction.OnBloodSpurts
// (Final, Native, Protected)

void UGeneratorTeleportInteraction::OnBloodSpurts()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorTeleportInteraction", "OnBloodSpurts");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TheNightmare.GeneratorTeleportInteraction.OnIntroCompleted
// (Final, Native, Protected)

void UGeneratorTeleportInteraction::OnIntroCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorTeleportInteraction", "OnIntroCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TheNightmare.GeneratorTeleportInteraction.OnLocallySelectedGeneratorSet
// (Event, Protected, BlueprintEvent)
// Parameters:
// class AGenerator*                       SelectedGenerator                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGeneratorTeleportInteraction::OnLocallySelectedGeneratorSet(class AGenerator* SelectedGenerator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorTeleportInteraction", "OnLocallySelectedGeneratorSet");

	Params::GeneratorTeleportInteraction_OnLocallySelectedGeneratorSet Parms{};

	Parms.SelectedGenerator = SelectedGenerator;

	UObject::ProcessEvent(Func, &Parms);
}


// Function TheNightmare.GeneratorTeleportInteraction.OnRep_SelectedGenerator
// (Final, Native, Private)

void UGeneratorTeleportInteraction::OnRep_SelectedGenerator()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorTeleportInteraction", "OnRep_SelectedGenerator");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TheNightmare.GeneratorTeleportInteraction.OnRep_TeleportCooldownTimer
// (Final, Native, Private)

void UGeneratorTeleportInteraction::OnRep_TeleportCooldownTimer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorTeleportInteraction", "OnRep_TeleportCooldownTimer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TheNightmare.GeneratorTeleportInteraction.OnSelectedGeneratorSet
// (Event, Protected, BlueprintEvent)
// Parameters:
// class AGenerator*                       SelectedGenerator                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGeneratorTeleportInteraction::OnSelectedGeneratorSet(class AGenerator* SelectedGenerator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorTeleportInteraction", "OnSelectedGeneratorSet");

	Params::GeneratorTeleportInteraction_OnSelectedGeneratorSet Parms{};

	Parms.SelectedGenerator = SelectedGenerator;

	UObject::ProcessEvent(Func, &Parms);
}


// Function TheNightmare.GeneratorTeleportInteraction.OnTeleported
// (Event, Protected, HasDefaults, BlueprintEvent)
// Parameters:
// struct FTransform                       TransformBeforeTeleport                                (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGeneratorTeleportInteraction::OnTeleported(const struct FTransform& TransformBeforeTeleport)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorTeleportInteraction", "OnTeleported");

	Params::GeneratorTeleportInteraction_OnTeleported Parms{};

	Parms.TransformBeforeTeleport = std::move(TransformBeforeTeleport);

	UObject::ProcessEvent(Func, &Parms);
}


// Function TheNightmare.GeneratorTeleportInteraction.OnTeleportLocationChosen
// (Event, Protected, HasDefaults, BlueprintEvent)
// Parameters:
// class AGenerator*                       Generator                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       Location                                               (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGeneratorTeleportInteraction::OnTeleportLocationChosen(class AGenerator* Generator, const struct FTransform& Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorTeleportInteraction", "OnTeleportLocationChosen");

	Params::GeneratorTeleportInteraction_OnTeleportLocationChosen Parms{};

	Parms.Generator = Generator;
	Parms.Location = std::move(Location);

	UObject::ProcessEvent(Func, &Parms);
}


// Function TheNightmare.GeneratorTeleportInteraction.OnTeleportReady
// (Event, Protected, BlueprintEvent)

void UGeneratorTeleportInteraction::OnTeleportReady()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorTeleportInteraction", "OnTeleportReady");

	UObject::ProcessEvent(Func, nullptr);
}


// Function TheNightmare.GeneratorTeleportInteraction.Server_SetSelectedGenerator
// (Net, NetReliable, Native, Event, Protected, NetServer, BlueprintCallable)
// Parameters:
// class AGenerator*                       Generator                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGeneratorTeleportInteraction::Server_SetSelectedGenerator(class AGenerator* Generator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorTeleportInteraction", "Server_SetSelectedGenerator");

	Params::GeneratorTeleportInteraction_Server_SetSelectedGenerator Parms{};

	Parms.Generator = Generator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TheNightmare.GeneratorTeleportInteraction.ShowBloodSpurtsVFX
// (Event, Protected, BlueprintEvent)

void UGeneratorTeleportInteraction::ShowBloodSpurtsVFX()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorTeleportInteraction", "ShowBloodSpurtsVFX");

	UObject::ProcessEvent(Func, nullptr);
}


// Function TheNightmare.GeneratorTeleportInteraction.StartBloodSpurts
// (Final, Native, Protected, BlueprintCallable)

void UGeneratorTeleportInteraction::StartBloodSpurts()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorTeleportInteraction", "StartBloodSpurts");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TheNightmare.GeneratorTeleportInteraction.StopBloodSpurts
// (Final, Native, Protected, BlueprintCallable)

void UGeneratorTeleportInteraction::StopBloodSpurts()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorTeleportInteraction", "StopBloodSpurts");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TheNightmare.GeneratorTeleportInteraction.CanTeleportAtGenerator
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AGenerator*                       Generator                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGeneratorTeleportInteraction::CanTeleportAtGenerator(class AGenerator* Generator) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorTeleportInteraction", "CanTeleportAtGenerator");

	Params::GeneratorTeleportInteraction_CanTeleportAtGenerator Parms{};

	Parms.Generator = Generator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TheNightmare.GeneratorTeleportInteraction.GetInlineGenerator
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ADBDPlayer*                       Player                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AGenerator*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AGenerator* UGeneratorTeleportInteraction::GetInlineGenerator(const class ADBDPlayer* Player) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorTeleportInteraction", "GetInlineGenerator");

	Params::GeneratorTeleportInteraction_GetInlineGenerator Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TheNightmare.GeneratorTeleportInteraction.GetOwningPlayer
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ADBDPlayer*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADBDPlayer* UGeneratorTeleportInteraction::GetOwningPlayer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorTeleportInteraction", "GetOwningPlayer");

	Params::GeneratorTeleportInteraction_GetOwningPlayer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TheNightmare.GeneratorTeleportInteraction.HasTeleportFailed
// (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGeneratorTeleportInteraction::HasTeleportFailed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorTeleportInteraction", "HasTeleportFailed");

	Params::GeneratorTeleportInteraction_HasTeleportFailed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TheNightmare.GeneratorTeleportInteraction.IsTeleportAvailable
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGeneratorTeleportInteraction::IsTeleportAvailable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorTeleportInteraction", "IsTeleportAvailable");

	Params::GeneratorTeleportInteraction_IsTeleportAvailable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TheNightmare.PlaceDreamPalletInteraction.InitializeTunableValues
// (Final, Native, Private)
// Parameters:
// class ASlasherPlayer*                   Killer                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlaceDreamPalletInteraction::InitializeTunableValues(class ASlasherPlayer* Killer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlaceDreamPalletInteraction", "InitializeTunableValues");

	Params::PlaceDreamPalletInteraction_InitializeTunableValues Parms{};

	Parms.Killer = Killer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TheNightmare.PlaceDreamPalletInteraction.OnRep_PalletTrackers
// (Final, Native, Private)

void UPlaceDreamPalletInteraction::OnRep_PalletTrackers()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlaceDreamPalletInteraction", "OnRep_PalletTrackers");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TheNightmare.PlaceDreamPalletInteraction.SpawnDreamPallet
// (Event, Public, BlueprintEvent)
// Parameters:
// class APalletTracker*                   TrackerAtLocation                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlaceDreamPalletInteraction::SpawnDreamPallet(class APalletTracker* TrackerAtLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlaceDreamPalletInteraction", "SpawnDreamPallet");

	Params::PlaceDreamPalletInteraction_SpawnDreamPallet Parms{};

	Parms.TrackerAtLocation = TrackerAtLocation;

	UObject::ProcessEvent(Func, &Parms);
}


// Function TheNightmare.PlaceDreamPalletInteraction.CanSpawnDreamPalletAtTracker
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class APalletTracker*                   Tracker                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPlaceDreamPalletInteraction::CanSpawnDreamPalletAtTracker(class APalletTracker* Tracker) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlaceDreamPalletInteraction", "CanSpawnDreamPalletAtTracker");

	Params::PlaceDreamPalletInteraction_CanSpawnDreamPalletAtTracker Parms{};

	Parms.Tracker = Tracker;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TheNightmare.PlaceDreamPalletInteraction.GetTargetedPallet
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class APalletTracker*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APalletTracker* UPlaceDreamPalletInteraction::GetTargetedPallet() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlaceDreamPalletInteraction", "GetTargetedPallet");

	Params::PlaceDreamPalletInteraction_GetTargetedPallet Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TheNightmare.RememberMe.DidLoseHealthState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           DamagedActor                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OldHealthStateCount                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URememberMe::DidLoseHealthState(const class AActor* DamagedActor, int32 OldHealthStateCount) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RememberMe", "DidLoseHealthState");

	Params::RememberMe_DidLoseHealthState Parms{};

	Parms.DamagedActor = DamagedActor;
	Parms.OldHealthStateCount = OldHealthStateCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TheNightmare.SetDreamSnareInteraction.GetTrapDistanceFromControlRotation
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USetDreamSnareInteraction::GetTrapDistanceFromControlRotation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SetDreamSnareInteraction", "GetTrapDistanceFromControlRotation");

	Params::SetDreamSnareInteraction_GetTrapDistanceFromControlRotation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TheNightmare.SetDreamSnareInteraction.HasCancelledDreamSnare
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USetDreamSnareInteraction::HasCancelledDreamSnare() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SetDreamSnareInteraction", "HasCancelledDreamSnare");

	Params::SetDreamSnareInteraction_HasCancelledDreamSnare Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TheNightmare.TheNightmareUtilities.GetDreamSnareStatusEffect
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ADBDPlayer*                       Player                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDreamSnareEffect*                ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDreamSnareEffect* UTheNightmareUtilities::GetDreamSnareStatusEffect(const class ADBDPlayer* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TheNightmareUtilities", "GetDreamSnareStatusEffect");

	Params::TheNightmareUtilities_GetDreamSnareStatusEffect Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}

}

