#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: InterchangeImport

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "InterchangeCore_classes.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "InterchangeImport_structs.hpp"


namespace SDK
{

// Class InterchangeImport.InterchangeStaticMeshPayloadInterface
// 0x0000 (0x0030 - 0x0030)
class IInterchangeStaticMeshPayloadInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterchangeStaticMeshPayloadInterface">();
	}
	static class IInterchangeStaticMeshPayloadInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IInterchangeStaticMeshPayloadInterface>();
	}
};
static_assert(alignof(IInterchangeStaticMeshPayloadInterface) == 0x000008, "Wrong alignment on IInterchangeStaticMeshPayloadInterface");
static_assert(sizeof(IInterchangeStaticMeshPayloadInterface) == 0x000030, "Wrong size on IInterchangeStaticMeshPayloadInterface");

// Class InterchangeImport.InterchangeAnimationPayloadInterface
// 0x0000 (0x0030 - 0x0030)
class IInterchangeAnimationPayloadInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterchangeAnimationPayloadInterface">();
	}
	static class IInterchangeAnimationPayloadInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IInterchangeAnimationPayloadInterface>();
	}
};
static_assert(alignof(IInterchangeAnimationPayloadInterface) == 0x000008, "Wrong alignment on IInterchangeAnimationPayloadInterface");
static_assert(sizeof(IInterchangeAnimationPayloadInterface) == 0x000030, "Wrong size on IInterchangeAnimationPayloadInterface");

// Class InterchangeImport.InterchangeAnimationTrackSetFactory
// 0x0008 (0x0040 - 0x0038)
class UInterchangeAnimationTrackSetFactory final : public UInterchangeFactoryBase
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterchangeAnimationTrackSetFactory">();
	}
	static class UInterchangeAnimationTrackSetFactory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterchangeAnimationTrackSetFactory>();
	}
};
static_assert(alignof(UInterchangeAnimationTrackSetFactory) == 0x000008, "Wrong alignment on UInterchangeAnimationTrackSetFactory");
static_assert(sizeof(UInterchangeAnimationTrackSetFactory) == 0x000040, "Wrong size on UInterchangeAnimationTrackSetFactory");

// Class InterchangeImport.InterchangeBlockedTexturePayloadInterface
// 0x0000 (0x0030 - 0x0030)
class IInterchangeBlockedTexturePayloadInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterchangeBlockedTexturePayloadInterface">();
	}
	static class IInterchangeBlockedTexturePayloadInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IInterchangeBlockedTexturePayloadInterface>();
	}
};
static_assert(alignof(IInterchangeBlockedTexturePayloadInterface) == 0x000008, "Wrong alignment on IInterchangeBlockedTexturePayloadInterface");
static_assert(sizeof(IInterchangeBlockedTexturePayloadInterface) == 0x000030, "Wrong size on IInterchangeBlockedTexturePayloadInterface");

// Class InterchangeImport.InterchangeLightActorFactory
// 0x0000 (0x0038 - 0x0038)
class UInterchangeLightActorFactory final : public UInterchangeFactoryBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterchangeLightActorFactory">();
	}
	static class UInterchangeLightActorFactory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterchangeLightActorFactory>();
	}
};
static_assert(alignof(UInterchangeLightActorFactory) == 0x000008, "Wrong alignment on UInterchangeLightActorFactory");
static_assert(sizeof(UInterchangeLightActorFactory) == 0x000038, "Wrong size on UInterchangeLightActorFactory");

// Class InterchangeImport.InterchangeSceneVariantSetsFactory
// 0x0008 (0x0040 - 0x0038)
class UInterchangeSceneVariantSetsFactory final : public UInterchangeFactoryBase
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterchangeSceneVariantSetsFactory">();
	}
	static class UInterchangeSceneVariantSetsFactory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterchangeSceneVariantSetsFactory>();
	}
};
static_assert(alignof(UInterchangeSceneVariantSetsFactory) == 0x000008, "Wrong alignment on UInterchangeSceneVariantSetsFactory");
static_assert(sizeof(UInterchangeSceneVariantSetsFactory) == 0x000040, "Wrong size on UInterchangeSceneVariantSetsFactory");

// Class InterchangeImport.InterchangeSkeletalMeshPayloadInterface
// 0x0000 (0x0030 - 0x0030)
class IInterchangeSkeletalMeshPayloadInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterchangeSkeletalMeshPayloadInterface">();
	}
	static class IInterchangeSkeletalMeshPayloadInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IInterchangeSkeletalMeshPayloadInterface>();
	}
};
static_assert(alignof(IInterchangeSkeletalMeshPayloadInterface) == 0x000008, "Wrong alignment on IInterchangeSkeletalMeshPayloadInterface");
static_assert(sizeof(IInterchangeSkeletalMeshPayloadInterface) == 0x000030, "Wrong size on IInterchangeSkeletalMeshPayloadInterface");

// Class InterchangeImport.InterchangeSlicedTexturePayloadInterface
// 0x0000 (0x0030 - 0x0030)
class IInterchangeSlicedTexturePayloadInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterchangeSlicedTexturePayloadInterface">();
	}
	static class IInterchangeSlicedTexturePayloadInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IInterchangeSlicedTexturePayloadInterface>();
	}
};
static_assert(alignof(IInterchangeSlicedTexturePayloadInterface) == 0x000008, "Wrong alignment on IInterchangeSlicedTexturePayloadInterface");
static_assert(sizeof(IInterchangeSlicedTexturePayloadInterface) == 0x000030, "Wrong size on IInterchangeSlicedTexturePayloadInterface");

// Class InterchangeImport.InterchangeTextureLightProfilePayloadInterface
// 0x0000 (0x0030 - 0x0030)
class IInterchangeTextureLightProfilePayloadInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterchangeTextureLightProfilePayloadInterface">();
	}
	static class IInterchangeTextureLightProfilePayloadInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IInterchangeTextureLightProfilePayloadInterface>();
	}
};
static_assert(alignof(IInterchangeTextureLightProfilePayloadInterface) == 0x000008, "Wrong alignment on IInterchangeTextureLightProfilePayloadInterface");
static_assert(sizeof(IInterchangeTextureLightProfilePayloadInterface) == 0x000030, "Wrong size on IInterchangeTextureLightProfilePayloadInterface");

// Class InterchangeImport.InterchangeTexturePayloadInterface
// 0x0000 (0x0030 - 0x0030)
class IInterchangeTexturePayloadInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterchangeTexturePayloadInterface">();
	}
	static class IInterchangeTexturePayloadInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IInterchangeTexturePayloadInterface>();
	}
};
static_assert(alignof(IInterchangeTexturePayloadInterface) == 0x000008, "Wrong alignment on IInterchangeTexturePayloadInterface");
static_assert(sizeof(IInterchangeTexturePayloadInterface) == 0x000030, "Wrong size on IInterchangeTexturePayloadInterface");

// Class InterchangeImport.InterchangeVariantSetPayloadInterface
// 0x0000 (0x0030 - 0x0030)
class IInterchangeVariantSetPayloadInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterchangeVariantSetPayloadInterface">();
	}
	static class IInterchangeVariantSetPayloadInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IInterchangeVariantSetPayloadInterface>();
	}
};
static_assert(alignof(IInterchangeVariantSetPayloadInterface) == 0x000008, "Wrong alignment on IInterchangeVariantSetPayloadInterface");
static_assert(sizeof(IInterchangeVariantSetPayloadInterface) == 0x000030, "Wrong size on IInterchangeVariantSetPayloadInterface");

// Class InterchangeImport.MaterialExpressionAppend3Vector
// 0x0090 (0x0148 - 0x00B8)
class UMaterialExpressionAppend3Vector final : public UMaterialExpression
{
public:
	struct FExpressionInput                       A;                                                 // 0x00B8(0x0030)(NoDestructor, NativeAccessSpecifierPublic)
	struct FExpressionInput                       B;                                                 // 0x00E8(0x0030)(NoDestructor, NativeAccessSpecifierPublic)
	struct FExpressionInput                       C;                                                 // 0x0118(0x0030)(NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionAppend3Vector">();
	}
	static class UMaterialExpressionAppend3Vector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionAppend3Vector>();
	}
};
static_assert(alignof(UMaterialExpressionAppend3Vector) == 0x000008, "Wrong alignment on UMaterialExpressionAppend3Vector");
static_assert(sizeof(UMaterialExpressionAppend3Vector) == 0x000148, "Wrong size on UMaterialExpressionAppend3Vector");
static_assert(offsetof(UMaterialExpressionAppend3Vector, A) == 0x0000B8, "Member 'UMaterialExpressionAppend3Vector::A' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionAppend3Vector, B) == 0x0000E8, "Member 'UMaterialExpressionAppend3Vector::B' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionAppend3Vector, C) == 0x000118, "Member 'UMaterialExpressionAppend3Vector::C' has a wrong offset!");

// Class InterchangeImport.MaterialExpressionAppend4Vector
// 0x00C0 (0x0178 - 0x00B8)
class UMaterialExpressionAppend4Vector final : public UMaterialExpression
{
public:
	struct FExpressionInput                       A;                                                 // 0x00B8(0x0030)(NoDestructor, NativeAccessSpecifierPublic)
	struct FExpressionInput                       B;                                                 // 0x00E8(0x0030)(NoDestructor, NativeAccessSpecifierPublic)
	struct FExpressionInput                       C;                                                 // 0x0118(0x0030)(NoDestructor, NativeAccessSpecifierPublic)
	struct FExpressionInput                       D;                                                 // 0x0148(0x0030)(NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionAppend4Vector">();
	}
	static class UMaterialExpressionAppend4Vector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionAppend4Vector>();
	}
};
static_assert(alignof(UMaterialExpressionAppend4Vector) == 0x000008, "Wrong alignment on UMaterialExpressionAppend4Vector");
static_assert(sizeof(UMaterialExpressionAppend4Vector) == 0x000178, "Wrong size on UMaterialExpressionAppend4Vector");
static_assert(offsetof(UMaterialExpressionAppend4Vector, A) == 0x0000B8, "Member 'UMaterialExpressionAppend4Vector::A' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionAppend4Vector, B) == 0x0000E8, "Member 'UMaterialExpressionAppend4Vector::B' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionAppend4Vector, C) == 0x000118, "Member 'UMaterialExpressionAppend4Vector::C' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionAppend4Vector, D) == 0x000148, "Member 'UMaterialExpressionAppend4Vector::D' has a wrong offset!");

// Class InterchangeImport.MaterialExpressionBurn
// 0x0098 (0x0150 - 0x00B8)
class UMaterialExpressionBurn final : public UMaterialExpression
{
public:
	struct FExpressionInput                       A;                                                 // 0x00B8(0x0030)(NoDestructor, NativeAccessSpecifierPublic)
	struct FExpressionInput                       B;                                                 // 0x00E8(0x0030)(NoDestructor, NativeAccessSpecifierPublic)
	struct FExpressionInput                       Alpha;                                             // 0x0118(0x0030)(NoDestructor, NativeAccessSpecifierPublic)
	float                                         ConstAlpha;                                        // 0x0148(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14C[0x4];                                      // 0x014C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionBurn">();
	}
	static class UMaterialExpressionBurn* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionBurn>();
	}
};
static_assert(alignof(UMaterialExpressionBurn) == 0x000008, "Wrong alignment on UMaterialExpressionBurn");
static_assert(sizeof(UMaterialExpressionBurn) == 0x000150, "Wrong size on UMaterialExpressionBurn");
static_assert(offsetof(UMaterialExpressionBurn, A) == 0x0000B8, "Member 'UMaterialExpressionBurn::A' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionBurn, B) == 0x0000E8, "Member 'UMaterialExpressionBurn::B' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionBurn, Alpha) == 0x000118, "Member 'UMaterialExpressionBurn::Alpha' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionBurn, ConstAlpha) == 0x000148, "Member 'UMaterialExpressionBurn::ConstAlpha' has a wrong offset!");

// Class InterchangeImport.MaterialExpressionDifference
// 0x0098 (0x0150 - 0x00B8)
class UMaterialExpressionDifference final : public UMaterialExpression
{
public:
	struct FExpressionInput                       A;                                                 // 0x00B8(0x0030)(NoDestructor, NativeAccessSpecifierPublic)
	struct FExpressionInput                       B;                                                 // 0x00E8(0x0030)(NoDestructor, NativeAccessSpecifierPublic)
	struct FExpressionInput                       Alpha;                                             // 0x0118(0x0030)(NoDestructor, NativeAccessSpecifierPublic)
	float                                         ConstAlpha;                                        // 0x0148(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14C[0x4];                                      // 0x014C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionDifference">();
	}
	static class UMaterialExpressionDifference* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionDifference>();
	}
};
static_assert(alignof(UMaterialExpressionDifference) == 0x000008, "Wrong alignment on UMaterialExpressionDifference");
static_assert(sizeof(UMaterialExpressionDifference) == 0x000150, "Wrong size on UMaterialExpressionDifference");
static_assert(offsetof(UMaterialExpressionDifference, A) == 0x0000B8, "Member 'UMaterialExpressionDifference::A' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionDifference, B) == 0x0000E8, "Member 'UMaterialExpressionDifference::B' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionDifference, Alpha) == 0x000118, "Member 'UMaterialExpressionDifference::Alpha' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionDifference, ConstAlpha) == 0x000148, "Member 'UMaterialExpressionDifference::ConstAlpha' has a wrong offset!");

// Class InterchangeImport.MaterialExpressionDisjointOver
// 0x0098 (0x0150 - 0x00B8)
class UMaterialExpressionDisjointOver final : public UMaterialExpression
{
public:
	struct FExpressionInput                       A;                                                 // 0x00B8(0x0030)(NoDestructor, NativeAccessSpecifierPublic)
	struct FExpressionInput                       B;                                                 // 0x00E8(0x0030)(NoDestructor, NativeAccessSpecifierPublic)
	struct FExpressionInput                       Alpha;                                             // 0x0118(0x0030)(NoDestructor, NativeAccessSpecifierPublic)
	float                                         ConstAlpha;                                        // 0x0148(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14C[0x4];                                      // 0x014C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionDisjointOver">();
	}
	static class UMaterialExpressionDisjointOver* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionDisjointOver>();
	}
};
static_assert(alignof(UMaterialExpressionDisjointOver) == 0x000008, "Wrong alignment on UMaterialExpressionDisjointOver");
static_assert(sizeof(UMaterialExpressionDisjointOver) == 0x000150, "Wrong size on UMaterialExpressionDisjointOver");
static_assert(offsetof(UMaterialExpressionDisjointOver, A) == 0x0000B8, "Member 'UMaterialExpressionDisjointOver::A' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionDisjointOver, B) == 0x0000E8, "Member 'UMaterialExpressionDisjointOver::B' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionDisjointOver, Alpha) == 0x000118, "Member 'UMaterialExpressionDisjointOver::Alpha' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionDisjointOver, ConstAlpha) == 0x000148, "Member 'UMaterialExpressionDisjointOver::ConstAlpha' has a wrong offset!");

// Class InterchangeImport.MaterialExpressionDodge
// 0x0098 (0x0150 - 0x00B8)
class UMaterialExpressionDodge final : public UMaterialExpression
{
public:
	struct FExpressionInput                       A;                                                 // 0x00B8(0x0030)(NoDestructor, NativeAccessSpecifierPublic)
	struct FExpressionInput                       B;                                                 // 0x00E8(0x0030)(NoDestructor, NativeAccessSpecifierPublic)
	struct FExpressionInput                       Alpha;                                             // 0x0118(0x0030)(NoDestructor, NativeAccessSpecifierPublic)
	float                                         ConstAlpha;                                        // 0x0148(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14C[0x4];                                      // 0x014C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionDodge">();
	}
	static class UMaterialExpressionDodge* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionDodge>();
	}
};
static_assert(alignof(UMaterialExpressionDodge) == 0x000008, "Wrong alignment on UMaterialExpressionDodge");
static_assert(sizeof(UMaterialExpressionDodge) == 0x000150, "Wrong size on UMaterialExpressionDodge");
static_assert(offsetof(UMaterialExpressionDodge, A) == 0x0000B8, "Member 'UMaterialExpressionDodge::A' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionDodge, B) == 0x0000E8, "Member 'UMaterialExpressionDodge::B' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionDodge, Alpha) == 0x000118, "Member 'UMaterialExpressionDodge::Alpha' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionDodge, ConstAlpha) == 0x000148, "Member 'UMaterialExpressionDodge::ConstAlpha' has a wrong offset!");

// Class InterchangeImport.MaterialExpressionExponential
// 0x0030 (0x00E8 - 0x00B8)
class UMaterialExpressionExponential final : public UMaterialExpression
{
public:
	struct FExpressionInput                       Input;                                             // 0x00B8(0x0030)(NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionExponential">();
	}
	static class UMaterialExpressionExponential* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionExponential>();
	}
};
static_assert(alignof(UMaterialExpressionExponential) == 0x000008, "Wrong alignment on UMaterialExpressionExponential");
static_assert(sizeof(UMaterialExpressionExponential) == 0x0000E8, "Wrong size on UMaterialExpressionExponential");
static_assert(offsetof(UMaterialExpressionExponential, Input) == 0x0000B8, "Member 'UMaterialExpressionExponential::Input' has a wrong offset!");

// Class InterchangeImport.MaterialExpressionFractal3D
// 0x0120 (0x01D8 - 0x00B8)
class UMaterialExpressionFractal3D final : public UMaterialExpression
{
public:
	struct FExpressionInput                       Position;                                          // 0x00B8(0x0030)(NoDestructor, NativeAccessSpecifierPublic)
	struct FExpressionInput                       Amplitude;                                         // 0x00E8(0x0030)(NoDestructor, NativeAccessSpecifierPublic)
	float                                         ConstAmplitude;                                    // 0x0118(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11C[0x4];                                      // 0x011C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FExpressionInput                       Octaves;                                           // 0x0120(0x0030)(NoDestructor, NativeAccessSpecifierPublic)
	int32                                         ConstOctaves;                                      // 0x0150(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_154[0x4];                                      // 0x0154(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FExpressionInput                       Lacunarity;                                        // 0x0158(0x0030)(NoDestructor, NativeAccessSpecifierPublic)
	float                                         ConstLacunarity;                                   // 0x0188(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18C[0x4];                                      // 0x018C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FExpressionInput                       Diminish;                                          // 0x0190(0x0030)(NoDestructor, NativeAccessSpecifierPublic)
	float                                         ConstDiminish;                                     // 0x01C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x01C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTurbulence;                                       // 0x01C8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C9[0x3];                                      // 0x01C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Levels;                                            // 0x01CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutputMin;                                         // 0x01D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutputMax;                                         // 0x01D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionFractal3D">();
	}
	static class UMaterialExpressionFractal3D* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionFractal3D>();
	}
};
static_assert(alignof(UMaterialExpressionFractal3D) == 0x000008, "Wrong alignment on UMaterialExpressionFractal3D");
static_assert(sizeof(UMaterialExpressionFractal3D) == 0x0001D8, "Wrong size on UMaterialExpressionFractal3D");
static_assert(offsetof(UMaterialExpressionFractal3D, Position) == 0x0000B8, "Member 'UMaterialExpressionFractal3D::Position' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionFractal3D, Amplitude) == 0x0000E8, "Member 'UMaterialExpressionFractal3D::Amplitude' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionFractal3D, ConstAmplitude) == 0x000118, "Member 'UMaterialExpressionFractal3D::ConstAmplitude' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionFractal3D, Octaves) == 0x000120, "Member 'UMaterialExpressionFractal3D::Octaves' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionFractal3D, ConstOctaves) == 0x000150, "Member 'UMaterialExpressionFractal3D::ConstOctaves' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionFractal3D, Lacunarity) == 0x000158, "Member 'UMaterialExpressionFractal3D::Lacunarity' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionFractal3D, ConstLacunarity) == 0x000188, "Member 'UMaterialExpressionFractal3D::ConstLacunarity' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionFractal3D, Diminish) == 0x000190, "Member 'UMaterialExpressionFractal3D::Diminish' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionFractal3D, ConstDiminish) == 0x0001C0, "Member 'UMaterialExpressionFractal3D::ConstDiminish' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionFractal3D, Scale) == 0x0001C4, "Member 'UMaterialExpressionFractal3D::Scale' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionFractal3D, bTurbulence) == 0x0001C8, "Member 'UMaterialExpressionFractal3D::bTurbulence' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionFractal3D, Levels) == 0x0001CC, "Member 'UMaterialExpressionFractal3D::Levels' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionFractal3D, OutputMin) == 0x0001D0, "Member 'UMaterialExpressionFractal3D::OutputMin' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionFractal3D, OutputMax) == 0x0001D4, "Member 'UMaterialExpressionFractal3D::OutputMax' has a wrong offset!");

// Class InterchangeImport.MaterialExpressionHsvToRgb
// 0x0030 (0x00E8 - 0x00B8)
class UMaterialExpressionHsvToRgb final : public UMaterialExpression
{
public:
	struct FExpressionInput                       Input;                                             // 0x00B8(0x0030)(NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionHsvToRgb">();
	}
	static class UMaterialExpressionHsvToRgb* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionHsvToRgb>();
	}
};
static_assert(alignof(UMaterialExpressionHsvToRgb) == 0x000008, "Wrong alignment on UMaterialExpressionHsvToRgb");
static_assert(sizeof(UMaterialExpressionHsvToRgb) == 0x0000E8, "Wrong size on UMaterialExpressionHsvToRgb");
static_assert(offsetof(UMaterialExpressionHsvToRgb, Input) == 0x0000B8, "Member 'UMaterialExpressionHsvToRgb::Input' has a wrong offset!");

// Class InterchangeImport.MaterialExpressionIn
// 0x0098 (0x0150 - 0x00B8)
class UMaterialExpressionIn final : public UMaterialExpression
{
public:
	struct FExpressionInput                       A;                                                 // 0x00B8(0x0030)(NoDestructor, NativeAccessSpecifierPublic)
	struct FExpressionInput                       B;                                                 // 0x00E8(0x0030)(NoDestructor, NativeAccessSpecifierPublic)
	struct FExpressionInput                       Alpha;                                             // 0x0118(0x0030)(NoDestructor, NativeAccessSpecifierPublic)
	float                                         ConstAlpha;                                        // 0x0148(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14C[0x4];                                      // 0x014C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionIn">();
	}
	static class UMaterialExpressionIn* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionIn>();
	}
};
static_assert(alignof(UMaterialExpressionIn) == 0x000008, "Wrong alignment on UMaterialExpressionIn");
static_assert(sizeof(UMaterialExpressionIn) == 0x000150, "Wrong size on UMaterialExpressionIn");
static_assert(offsetof(UMaterialExpressionIn, A) == 0x0000B8, "Member 'UMaterialExpressionIn::A' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionIn, B) == 0x0000E8, "Member 'UMaterialExpressionIn::B' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionIn, Alpha) == 0x000118, "Member 'UMaterialExpressionIn::Alpha' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionIn, ConstAlpha) == 0x000148, "Member 'UMaterialExpressionIn::ConstAlpha' has a wrong offset!");

// Class InterchangeImport.MaterialExpressionLength
// 0x0030 (0x00E8 - 0x00B8)
class UMaterialExpressionLength final : public UMaterialExpression
{
public:
	struct FExpressionInput                       Input;                                             // 0x00B8(0x0030)(NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionLength">();
	}
	static class UMaterialExpressionLength* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionLength>();
	}
};
static_assert(alignof(UMaterialExpressionLength) == 0x000008, "Wrong alignment on UMaterialExpressionLength");
static_assert(sizeof(UMaterialExpressionLength) == 0x0000E8, "Wrong size on UMaterialExpressionLength");
static_assert(offsetof(UMaterialExpressionLength, Input) == 0x0000B8, "Member 'UMaterialExpressionLength::Input' has a wrong offset!");

// Class InterchangeImport.MaterialExpressionLogarithm
// 0x0030 (0x00E8 - 0x00B8)
class UMaterialExpressionLogarithm final : public UMaterialExpression
{
public:
	struct FExpressionInput                       Input;                                             // 0x00B8(0x0030)(NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionLogarithm">();
	}
	static class UMaterialExpressionLogarithm* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionLogarithm>();
	}
};
static_assert(alignof(UMaterialExpressionLogarithm) == 0x000008, "Wrong alignment on UMaterialExpressionLogarithm");
static_assert(sizeof(UMaterialExpressionLogarithm) == 0x0000E8, "Wrong size on UMaterialExpressionLogarithm");
static_assert(offsetof(UMaterialExpressionLogarithm, Input) == 0x0000B8, "Member 'UMaterialExpressionLogarithm::Input' has a wrong offset!");

// Class InterchangeImport.MaterialExpressionLuminance
// 0x0048 (0x0100 - 0x00B8)
class UMaterialExpressionLuminance final : public UMaterialExpression
{
public:
	struct FExpressionInput                       Input;                                             // 0x00B8(0x0030)(NoDestructor, NativeAccessSpecifierPublic)
	struct FLinearColor                           LuminanceFactors;                                  // 0x00E8(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELuminanceMode                                LuminanceMode;                                     // 0x00F8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F9[0x7];                                       // 0x00F9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionLuminance">();
	}
	static class UMaterialExpressionLuminance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionLuminance>();
	}
};
static_assert(alignof(UMaterialExpressionLuminance) == 0x000008, "Wrong alignment on UMaterialExpressionLuminance");
static_assert(sizeof(UMaterialExpressionLuminance) == 0x000100, "Wrong size on UMaterialExpressionLuminance");
static_assert(offsetof(UMaterialExpressionLuminance, Input) == 0x0000B8, "Member 'UMaterialExpressionLuminance::Input' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionLuminance, LuminanceFactors) == 0x0000E8, "Member 'UMaterialExpressionLuminance::LuminanceFactors' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionLuminance, LuminanceMode) == 0x0000F8, "Member 'UMaterialExpressionLuminance::LuminanceMode' has a wrong offset!");

// Class InterchangeImport.MaterialExpressionMask
// 0x0098 (0x0150 - 0x00B8)
class UMaterialExpressionMask final : public UMaterialExpression
{
public:
	struct FExpressionInput                       A;                                                 // 0x00B8(0x0030)(NoDestructor, NativeAccessSpecifierPublic)
	struct FExpressionInput                       B;                                                 // 0x00E8(0x0030)(NoDestructor, NativeAccessSpecifierPublic)
	struct FExpressionInput                       Alpha;                                             // 0x0118(0x0030)(NoDestructor, NativeAccessSpecifierPublic)
	float                                         ConstAlpha;                                        // 0x0148(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14C[0x4];                                      // 0x014C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionMask">();
	}
	static class UMaterialExpressionMask* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionMask>();
	}
};
static_assert(alignof(UMaterialExpressionMask) == 0x000008, "Wrong alignment on UMaterialExpressionMask");
static_assert(sizeof(UMaterialExpressionMask) == 0x000150, "Wrong size on UMaterialExpressionMask");
static_assert(offsetof(UMaterialExpressionMask, A) == 0x0000B8, "Member 'UMaterialExpressionMask::A' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMask, B) == 0x0000E8, "Member 'UMaterialExpressionMask::B' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMask, Alpha) == 0x000118, "Member 'UMaterialExpressionMask::Alpha' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMask, ConstAlpha) == 0x000148, "Member 'UMaterialExpressionMask::ConstAlpha' has a wrong offset!");

// Class InterchangeImport.MaterialExpressionMatte
// 0x0098 (0x0150 - 0x00B8)
class UMaterialExpressionMatte final : public UMaterialExpression
{
public:
	struct FExpressionInput                       A;                                                 // 0x00B8(0x0030)(NoDestructor, NativeAccessSpecifierPublic)
	struct FExpressionInput                       B;                                                 // 0x00E8(0x0030)(NoDestructor, NativeAccessSpecifierPublic)
	struct FExpressionInput                       Alpha;                                             // 0x0118(0x0030)(NoDestructor, NativeAccessSpecifierPublic)
	float                                         ConstAlpha;                                        // 0x0148(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14C[0x4];                                      // 0x014C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionMatte">();
	}
	static class UMaterialExpressionMatte* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionMatte>();
	}
};
static_assert(alignof(UMaterialExpressionMatte) == 0x000008, "Wrong alignment on UMaterialExpressionMatte");
static_assert(sizeof(UMaterialExpressionMatte) == 0x000150, "Wrong size on UMaterialExpressionMatte");
static_assert(offsetof(UMaterialExpressionMatte, A) == 0x0000B8, "Member 'UMaterialExpressionMatte::A' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMatte, B) == 0x0000E8, "Member 'UMaterialExpressionMatte::B' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMatte, Alpha) == 0x000118, "Member 'UMaterialExpressionMatte::Alpha' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMatte, ConstAlpha) == 0x000148, "Member 'UMaterialExpressionMatte::ConstAlpha' has a wrong offset!");

// Class InterchangeImport.MaterialExpressionMinus
// 0x0098 (0x0150 - 0x00B8)
class UMaterialExpressionMinus final : public UMaterialExpression
{
public:
	struct FExpressionInput                       A;                                                 // 0x00B8(0x0030)(NoDestructor, NativeAccessSpecifierPublic)
	struct FExpressionInput                       B;                                                 // 0x00E8(0x0030)(NoDestructor, NativeAccessSpecifierPublic)
	struct FExpressionInput                       Alpha;                                             // 0x0118(0x0030)(NoDestructor, NativeAccessSpecifierPublic)
	float                                         ConstAlpha;                                        // 0x0148(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14C[0x4];                                      // 0x014C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionMinus">();
	}
	static class UMaterialExpressionMinus* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionMinus>();
	}
};
static_assert(alignof(UMaterialExpressionMinus) == 0x000008, "Wrong alignment on UMaterialExpressionMinus");
static_assert(sizeof(UMaterialExpressionMinus) == 0x000150, "Wrong size on UMaterialExpressionMinus");
static_assert(offsetof(UMaterialExpressionMinus, A) == 0x0000B8, "Member 'UMaterialExpressionMinus::A' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMinus, B) == 0x0000E8, "Member 'UMaterialExpressionMinus::B' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMinus, Alpha) == 0x000118, "Member 'UMaterialExpressionMinus::Alpha' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMinus, ConstAlpha) == 0x000148, "Member 'UMaterialExpressionMinus::ConstAlpha' has a wrong offset!");

// Class InterchangeImport.MaterialExpressionOut
// 0x0098 (0x0150 - 0x00B8)
class UMaterialExpressionOut final : public UMaterialExpression
{
public:
	struct FExpressionInput                       A;                                                 // 0x00B8(0x0030)(NoDestructor, NativeAccessSpecifierPublic)
	struct FExpressionInput                       B;                                                 // 0x00E8(0x0030)(NoDestructor, NativeAccessSpecifierPublic)
	struct FExpressionInput                       Alpha;                                             // 0x0118(0x0030)(NoDestructor, NativeAccessSpecifierPublic)
	float                                         ConstAlpha;                                        // 0x0148(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14C[0x4];                                      // 0x014C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionOut">();
	}
	static class UMaterialExpressionOut* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionOut>();
	}
};
static_assert(alignof(UMaterialExpressionOut) == 0x000008, "Wrong alignment on UMaterialExpressionOut");
static_assert(sizeof(UMaterialExpressionOut) == 0x000150, "Wrong size on UMaterialExpressionOut");
static_assert(offsetof(UMaterialExpressionOut, A) == 0x0000B8, "Member 'UMaterialExpressionOut::A' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionOut, B) == 0x0000E8, "Member 'UMaterialExpressionOut::B' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionOut, Alpha) == 0x000118, "Member 'UMaterialExpressionOut::Alpha' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionOut, ConstAlpha) == 0x000148, "Member 'UMaterialExpressionOut::ConstAlpha' has a wrong offset!");

// Class InterchangeImport.MaterialExpressionOver
// 0x0098 (0x0150 - 0x00B8)
class UMaterialExpressionOver final : public UMaterialExpression
{
public:
	struct FExpressionInput                       A;                                                 // 0x00B8(0x0030)(NoDestructor, NativeAccessSpecifierPublic)
	struct FExpressionInput                       B;                                                 // 0x00E8(0x0030)(NoDestructor, NativeAccessSpecifierPublic)
	struct FExpressionInput                       Alpha;                                             // 0x0118(0x0030)(NoDestructor, NativeAccessSpecifierPublic)
	float                                         ConstAlpha;                                        // 0x0148(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14C[0x4];                                      // 0x014C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionOver">();
	}
	static class UMaterialExpressionOver* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionOver>();
	}
};
static_assert(alignof(UMaterialExpressionOver) == 0x000008, "Wrong alignment on UMaterialExpressionOver");
static_assert(sizeof(UMaterialExpressionOver) == 0x000150, "Wrong size on UMaterialExpressionOver");
static_assert(offsetof(UMaterialExpressionOver, A) == 0x0000B8, "Member 'UMaterialExpressionOver::A' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionOver, B) == 0x0000E8, "Member 'UMaterialExpressionOver::B' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionOver, Alpha) == 0x000118, "Member 'UMaterialExpressionOver::Alpha' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionOver, ConstAlpha) == 0x000148, "Member 'UMaterialExpressionOver::ConstAlpha' has a wrong offset!");

// Class InterchangeImport.MaterialExpressionOverlay
// 0x0098 (0x0150 - 0x00B8)
class UMaterialExpressionOverlay final : public UMaterialExpression
{
public:
	struct FExpressionInput                       A;                                                 // 0x00B8(0x0030)(NoDestructor, NativeAccessSpecifierPublic)
	struct FExpressionInput                       B;                                                 // 0x00E8(0x0030)(NoDestructor, NativeAccessSpecifierPublic)
	struct FExpressionInput                       Alpha;                                             // 0x0118(0x0030)(NoDestructor, NativeAccessSpecifierPublic)
	float                                         ConstAlpha;                                        // 0x0148(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14C[0x4];                                      // 0x014C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionOverlay">();
	}
	static class UMaterialExpressionOverlay* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionOverlay>();
	}
};
static_assert(alignof(UMaterialExpressionOverlay) == 0x000008, "Wrong alignment on UMaterialExpressionOverlay");
static_assert(sizeof(UMaterialExpressionOverlay) == 0x000150, "Wrong size on UMaterialExpressionOverlay");
static_assert(offsetof(UMaterialExpressionOverlay, A) == 0x0000B8, "Member 'UMaterialExpressionOverlay::A' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionOverlay, B) == 0x0000E8, "Member 'UMaterialExpressionOverlay::B' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionOverlay, Alpha) == 0x000118, "Member 'UMaterialExpressionOverlay::Alpha' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionOverlay, ConstAlpha) == 0x000148, "Member 'UMaterialExpressionOverlay::ConstAlpha' has a wrong offset!");

// Class InterchangeImport.MaterialExpressionPlus
// 0x0098 (0x0150 - 0x00B8)
class UMaterialExpressionPlus final : public UMaterialExpression
{
public:
	struct FExpressionInput                       A;                                                 // 0x00B8(0x0030)(NoDestructor, NativeAccessSpecifierPublic)
	struct FExpressionInput                       B;                                                 // 0x00E8(0x0030)(NoDestructor, NativeAccessSpecifierPublic)
	struct FExpressionInput                       Alpha;                                             // 0x0118(0x0030)(NoDestructor, NativeAccessSpecifierPublic)
	float                                         ConstAlpha;                                        // 0x0148(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14C[0x4];                                      // 0x014C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionPlus">();
	}
	static class UMaterialExpressionPlus* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionPlus>();
	}
};
static_assert(alignof(UMaterialExpressionPlus) == 0x000008, "Wrong alignment on UMaterialExpressionPlus");
static_assert(sizeof(UMaterialExpressionPlus) == 0x000150, "Wrong size on UMaterialExpressionPlus");
static_assert(offsetof(UMaterialExpressionPlus, A) == 0x0000B8, "Member 'UMaterialExpressionPlus::A' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionPlus, B) == 0x0000E8, "Member 'UMaterialExpressionPlus::B' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionPlus, Alpha) == 0x000118, "Member 'UMaterialExpressionPlus::Alpha' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionPlus, ConstAlpha) == 0x000148, "Member 'UMaterialExpressionPlus::ConstAlpha' has a wrong offset!");

// Class InterchangeImport.MaterialExpressionPremult
// 0x0030 (0x00E8 - 0x00B8)
class UMaterialExpressionPremult final : public UMaterialExpression
{
public:
	struct FExpressionInput                       Input;                                             // 0x00B8(0x0030)(NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionPremult">();
	}
	static class UMaterialExpressionPremult* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionPremult>();
	}
};
static_assert(alignof(UMaterialExpressionPremult) == 0x000008, "Wrong alignment on UMaterialExpressionPremult");
static_assert(sizeof(UMaterialExpressionPremult) == 0x0000E8, "Wrong size on UMaterialExpressionPremult");
static_assert(offsetof(UMaterialExpressionPremult, Input) == 0x0000B8, "Member 'UMaterialExpressionPremult::Input' has a wrong offset!");

// Class InterchangeImport.MaterialExpressionRampLeftRight
// 0x0098 (0x0150 - 0x00B8)
class UMaterialExpressionRampLeftRight final : public UMaterialExpression
{
public:
	struct FExpressionInput                       Coordinates;                                       // 0x00B8(0x0030)(NoDestructor, NativeAccessSpecifierPublic)
	struct FExpressionInput                       A;                                                 // 0x00E8(0x0030)(NoDestructor, NativeAccessSpecifierPublic)
	struct FExpressionInput                       B;                                                 // 0x0118(0x0030)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         ConstCoordinate;                                   // 0x0148(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_149[0x7];                                      // 0x0149(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionRampLeftRight">();
	}
	static class UMaterialExpressionRampLeftRight* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionRampLeftRight>();
	}
};
static_assert(alignof(UMaterialExpressionRampLeftRight) == 0x000008, "Wrong alignment on UMaterialExpressionRampLeftRight");
static_assert(sizeof(UMaterialExpressionRampLeftRight) == 0x000150, "Wrong size on UMaterialExpressionRampLeftRight");
static_assert(offsetof(UMaterialExpressionRampLeftRight, Coordinates) == 0x0000B8, "Member 'UMaterialExpressionRampLeftRight::Coordinates' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionRampLeftRight, A) == 0x0000E8, "Member 'UMaterialExpressionRampLeftRight::A' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionRampLeftRight, B) == 0x000118, "Member 'UMaterialExpressionRampLeftRight::B' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionRampLeftRight, ConstCoordinate) == 0x000148, "Member 'UMaterialExpressionRampLeftRight::ConstCoordinate' has a wrong offset!");

// Class InterchangeImport.MaterialExpressionRampTopBottom
// 0x0098 (0x0150 - 0x00B8)
class UMaterialExpressionRampTopBottom final : public UMaterialExpression
{
public:
	struct FExpressionInput                       Coordinates;                                       // 0x00B8(0x0030)(NoDestructor, NativeAccessSpecifierPublic)
	struct FExpressionInput                       A;                                                 // 0x00E8(0x0030)(NoDestructor, NativeAccessSpecifierPublic)
	struct FExpressionInput                       B;                                                 // 0x0118(0x0030)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         ConstCoordinate;                                   // 0x0148(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_149[0x7];                                      // 0x0149(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionRampTopBottom">();
	}
	static class UMaterialExpressionRampTopBottom* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionRampTopBottom>();
	}
};
static_assert(alignof(UMaterialExpressionRampTopBottom) == 0x000008, "Wrong alignment on UMaterialExpressionRampTopBottom");
static_assert(sizeof(UMaterialExpressionRampTopBottom) == 0x000150, "Wrong size on UMaterialExpressionRampTopBottom");
static_assert(offsetof(UMaterialExpressionRampTopBottom, Coordinates) == 0x0000B8, "Member 'UMaterialExpressionRampTopBottom::Coordinates' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionRampTopBottom, A) == 0x0000E8, "Member 'UMaterialExpressionRampTopBottom::A' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionRampTopBottom, B) == 0x000118, "Member 'UMaterialExpressionRampTopBottom::B' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionRampTopBottom, ConstCoordinate) == 0x000148, "Member 'UMaterialExpressionRampTopBottom::ConstCoordinate' has a wrong offset!");

// Class InterchangeImport.MaterialExpressionRemap
// 0x0100 (0x01B8 - 0x00B8)
class UMaterialExpressionRemap final : public UMaterialExpression
{
public:
	struct FExpressionInput                       Input;                                             // 0x00B8(0x0030)(NoDestructor, NativeAccessSpecifierPublic)
	struct FExpressionInput                       InputLow;                                          // 0x00E8(0x0030)(NoDestructor, NativeAccessSpecifierPublic)
	struct FExpressionInput                       InputHigh;                                         // 0x0118(0x0030)(NoDestructor, NativeAccessSpecifierPublic)
	struct FExpressionInput                       TargetLow;                                         // 0x0148(0x0030)(NoDestructor, NativeAccessSpecifierPublic)
	struct FExpressionInput                       TargetHigh;                                        // 0x0178(0x0030)(NoDestructor, NativeAccessSpecifierPublic)
	float                                         InputLowDefault;                                   // 0x01A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InputHighDefault;                                  // 0x01AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetLowDefault;                                  // 0x01B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetHighDefault;                                 // 0x01B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionRemap">();
	}
	static class UMaterialExpressionRemap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionRemap>();
	}
};
static_assert(alignof(UMaterialExpressionRemap) == 0x000008, "Wrong alignment on UMaterialExpressionRemap");
static_assert(sizeof(UMaterialExpressionRemap) == 0x0001B8, "Wrong size on UMaterialExpressionRemap");
static_assert(offsetof(UMaterialExpressionRemap, Input) == 0x0000B8, "Member 'UMaterialExpressionRemap::Input' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionRemap, InputLow) == 0x0000E8, "Member 'UMaterialExpressionRemap::InputLow' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionRemap, InputHigh) == 0x000118, "Member 'UMaterialExpressionRemap::InputHigh' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionRemap, TargetLow) == 0x000148, "Member 'UMaterialExpressionRemap::TargetLow' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionRemap, TargetHigh) == 0x000178, "Member 'UMaterialExpressionRemap::TargetHigh' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionRemap, InputLowDefault) == 0x0001A8, "Member 'UMaterialExpressionRemap::InputLowDefault' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionRemap, InputHighDefault) == 0x0001AC, "Member 'UMaterialExpressionRemap::InputHighDefault' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionRemap, TargetLowDefault) == 0x0001B0, "Member 'UMaterialExpressionRemap::TargetLowDefault' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionRemap, TargetHighDefault) == 0x0001B4, "Member 'UMaterialExpressionRemap::TargetHighDefault' has a wrong offset!");

// Class InterchangeImport.MaterialExpressionRgbToHsv
// 0x0030 (0x00E8 - 0x00B8)
class UMaterialExpressionRgbToHsv final : public UMaterialExpression
{
public:
	struct FExpressionInput                       Input;                                             // 0x00B8(0x0030)(NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionRgbToHsv">();
	}
	static class UMaterialExpressionRgbToHsv* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionRgbToHsv>();
	}
};
static_assert(alignof(UMaterialExpressionRgbToHsv) == 0x000008, "Wrong alignment on UMaterialExpressionRgbToHsv");
static_assert(sizeof(UMaterialExpressionRgbToHsv) == 0x0000E8, "Wrong size on UMaterialExpressionRgbToHsv");
static_assert(offsetof(UMaterialExpressionRgbToHsv, Input) == 0x0000B8, "Member 'UMaterialExpressionRgbToHsv::Input' has a wrong offset!");

// Class InterchangeImport.MaterialExpressionScreen
// 0x0098 (0x0150 - 0x00B8)
class UMaterialExpressionScreen final : public UMaterialExpression
{
public:
	struct FExpressionInput                       A;                                                 // 0x00B8(0x0030)(NoDestructor, NativeAccessSpecifierPublic)
	struct FExpressionInput                       B;                                                 // 0x00E8(0x0030)(NoDestructor, NativeAccessSpecifierPublic)
	struct FExpressionInput                       Alpha;                                             // 0x0118(0x0030)(NoDestructor, NativeAccessSpecifierPublic)
	float                                         ConstAlpha;                                        // 0x0148(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14C[0x4];                                      // 0x014C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionScreen">();
	}
	static class UMaterialExpressionScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionScreen>();
	}
};
static_assert(alignof(UMaterialExpressionScreen) == 0x000008, "Wrong alignment on UMaterialExpressionScreen");
static_assert(sizeof(UMaterialExpressionScreen) == 0x000150, "Wrong size on UMaterialExpressionScreen");
static_assert(offsetof(UMaterialExpressionScreen, A) == 0x0000B8, "Member 'UMaterialExpressionScreen::A' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionScreen, B) == 0x0000E8, "Member 'UMaterialExpressionScreen::B' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionScreen, Alpha) == 0x000118, "Member 'UMaterialExpressionScreen::Alpha' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionScreen, ConstAlpha) == 0x000148, "Member 'UMaterialExpressionScreen::ConstAlpha' has a wrong offset!");

// Class InterchangeImport.MaterialExpressionSplitLeftRight
// 0x00C8 (0x0180 - 0x00B8)
class UMaterialExpressionSplitLeftRight final : public UMaterialExpression
{
public:
	struct FExpressionInput                       Coordinates;                                       // 0x00B8(0x0030)(NoDestructor, NativeAccessSpecifierPublic)
	struct FExpressionInput                       A;                                                 // 0x00E8(0x0030)(NoDestructor, NativeAccessSpecifierPublic)
	struct FExpressionInput                       B;                                                 // 0x0118(0x0030)(NoDestructor, NativeAccessSpecifierPublic)
	struct FExpressionInput                       Center;                                            // 0x0148(0x0030)(NoDestructor, NativeAccessSpecifierPublic)
	float                                         ConstCenter;                                       // 0x0178(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ConstCoordinate;                                   // 0x017C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17D[0x3];                                      // 0x017D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionSplitLeftRight">();
	}
	static class UMaterialExpressionSplitLeftRight* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionSplitLeftRight>();
	}
};
static_assert(alignof(UMaterialExpressionSplitLeftRight) == 0x000008, "Wrong alignment on UMaterialExpressionSplitLeftRight");
static_assert(sizeof(UMaterialExpressionSplitLeftRight) == 0x000180, "Wrong size on UMaterialExpressionSplitLeftRight");
static_assert(offsetof(UMaterialExpressionSplitLeftRight, Coordinates) == 0x0000B8, "Member 'UMaterialExpressionSplitLeftRight::Coordinates' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionSplitLeftRight, A) == 0x0000E8, "Member 'UMaterialExpressionSplitLeftRight::A' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionSplitLeftRight, B) == 0x000118, "Member 'UMaterialExpressionSplitLeftRight::B' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionSplitLeftRight, Center) == 0x000148, "Member 'UMaterialExpressionSplitLeftRight::Center' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionSplitLeftRight, ConstCenter) == 0x000178, "Member 'UMaterialExpressionSplitLeftRight::ConstCenter' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionSplitLeftRight, ConstCoordinate) == 0x00017C, "Member 'UMaterialExpressionSplitLeftRight::ConstCoordinate' has a wrong offset!");

// Class InterchangeImport.MaterialExpressionSplitTopBottom
// 0x00C8 (0x0180 - 0x00B8)
class UMaterialExpressionSplitTopBottom final : public UMaterialExpression
{
public:
	struct FExpressionInput                       Coordinates;                                       // 0x00B8(0x0030)(NoDestructor, NativeAccessSpecifierPublic)
	struct FExpressionInput                       A;                                                 // 0x00E8(0x0030)(NoDestructor, NativeAccessSpecifierPublic)
	struct FExpressionInput                       B;                                                 // 0x0118(0x0030)(NoDestructor, NativeAccessSpecifierPublic)
	struct FExpressionInput                       Center;                                            // 0x0148(0x0030)(NoDestructor, NativeAccessSpecifierPublic)
	float                                         ConstCenter;                                       // 0x0178(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ConstCoordinate;                                   // 0x017C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17D[0x3];                                      // 0x017D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionSplitTopBottom">();
	}
	static class UMaterialExpressionSplitTopBottom* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionSplitTopBottom>();
	}
};
static_assert(alignof(UMaterialExpressionSplitTopBottom) == 0x000008, "Wrong alignment on UMaterialExpressionSplitTopBottom");
static_assert(sizeof(UMaterialExpressionSplitTopBottom) == 0x000180, "Wrong size on UMaterialExpressionSplitTopBottom");
static_assert(offsetof(UMaterialExpressionSplitTopBottom, Coordinates) == 0x0000B8, "Member 'UMaterialExpressionSplitTopBottom::Coordinates' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionSplitTopBottom, A) == 0x0000E8, "Member 'UMaterialExpressionSplitTopBottom::A' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionSplitTopBottom, B) == 0x000118, "Member 'UMaterialExpressionSplitTopBottom::B' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionSplitTopBottom, Center) == 0x000148, "Member 'UMaterialExpressionSplitTopBottom::Center' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionSplitTopBottom, ConstCenter) == 0x000178, "Member 'UMaterialExpressionSplitTopBottom::ConstCenter' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionSplitTopBottom, ConstCoordinate) == 0x00017C, "Member 'UMaterialExpressionSplitTopBottom::ConstCoordinate' has a wrong offset!");

// Class InterchangeImport.MaterialExpressionUnpremult
// 0x0030 (0x00E8 - 0x00B8)
class UMaterialExpressionUnpremult final : public UMaterialExpression
{
public:
	struct FExpressionInput                       Input;                                             // 0x00B8(0x0030)(NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionUnpremult">();
	}
	static class UMaterialExpressionUnpremult* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionUnpremult>();
	}
};
static_assert(alignof(UMaterialExpressionUnpremult) == 0x000008, "Wrong alignment on UMaterialExpressionUnpremult");
static_assert(sizeof(UMaterialExpressionUnpremult) == 0x0000E8, "Wrong size on UMaterialExpressionUnpremult");
static_assert(offsetof(UMaterialExpressionUnpremult, Input) == 0x0000B8, "Member 'UMaterialExpressionUnpremult::Input' has a wrong offset!");

// Class InterchangeImport.InterchangeAnimSequenceFactory
// 0x0000 (0x0038 - 0x0038)
class UInterchangeAnimSequenceFactory final : public UInterchangeFactoryBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterchangeAnimSequenceFactory">();
	}
	static class UInterchangeAnimSequenceFactory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterchangeAnimSequenceFactory>();
	}
};
static_assert(alignof(UInterchangeAnimSequenceFactory) == 0x000008, "Wrong alignment on UInterchangeAnimSequenceFactory");
static_assert(sizeof(UInterchangeAnimSequenceFactory) == 0x000038, "Wrong size on UInterchangeAnimSequenceFactory");

// Class InterchangeImport.InterchangeFbxTranslator
// 0x0028 (0x0068 - 0x0040)
class UInterchangeFbxTranslator final : public UInterchangeTranslatorBase
{
public:
	uint8                                         Pad_40[0x28];                                      // 0x0040(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterchangeFbxTranslator">();
	}
	static class UInterchangeFbxTranslator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterchangeFbxTranslator>();
	}
};
static_assert(alignof(UInterchangeFbxTranslator) == 0x000008, "Wrong alignment on UInterchangeFbxTranslator");
static_assert(sizeof(UInterchangeFbxTranslator) == 0x000068, "Wrong size on UInterchangeFbxTranslator");

// Class InterchangeImport.InterchangeGltfTranslator
// 0x0220 (0x0260 - 0x0040)
class UInterchangeGltfTranslator final : public UInterchangeTranslatorBase
{
public:
	uint8                                         Pad_40[0x220];                                     // 0x0040(0x0220)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterchangeGltfTranslator">();
	}
	static class UInterchangeGltfTranslator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterchangeGltfTranslator>();
	}
};
static_assert(alignof(UInterchangeGltfTranslator) == 0x000008, "Wrong alignment on UInterchangeGltfTranslator");
static_assert(sizeof(UInterchangeGltfTranslator) == 0x000260, "Wrong size on UInterchangeGltfTranslator");

// Class InterchangeImport.InterchangeMaterialXTranslator
// 0x0008 (0x0048 - 0x0040)
class UInterchangeMaterialXTranslator final : public UInterchangeTranslatorBase
{
public:
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterchangeMaterialXTranslator">();
	}
	static class UInterchangeMaterialXTranslator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterchangeMaterialXTranslator>();
	}
};
static_assert(alignof(UInterchangeMaterialXTranslator) == 0x000008, "Wrong alignment on UInterchangeMaterialXTranslator");
static_assert(sizeof(UInterchangeMaterialXTranslator) == 0x000048, "Wrong size on UInterchangeMaterialXTranslator");

// Class InterchangeImport.InterchangeMaterialFactory
// 0x0000 (0x0038 - 0x0038)
class UInterchangeMaterialFactory final : public UInterchangeFactoryBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterchangeMaterialFactory">();
	}
	static class UInterchangeMaterialFactory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterchangeMaterialFactory>();
	}
};
static_assert(alignof(UInterchangeMaterialFactory) == 0x000008, "Wrong alignment on UInterchangeMaterialFactory");
static_assert(sizeof(UInterchangeMaterialFactory) == 0x000038, "Wrong size on UInterchangeMaterialFactory");

// Class InterchangeImport.InterchangeMaterialFunctionFactory
// 0x0000 (0x0038 - 0x0038)
class UInterchangeMaterialFunctionFactory final : public UInterchangeFactoryBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterchangeMaterialFunctionFactory">();
	}
	static class UInterchangeMaterialFunctionFactory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterchangeMaterialFunctionFactory>();
	}
};
static_assert(alignof(UInterchangeMaterialFunctionFactory) == 0x000008, "Wrong alignment on UInterchangeMaterialFunctionFactory");
static_assert(sizeof(UInterchangeMaterialFunctionFactory) == 0x000038, "Wrong size on UInterchangeMaterialFunctionFactory");

// Class InterchangeImport.InterchangeOBJTranslator
// 0x0018 (0x0058 - 0x0040)
class UInterchangeOBJTranslator final : public UInterchangeTranslatorBase
{
public:
	uint8                                         Pad_40[0x18];                                      // 0x0040(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterchangeOBJTranslator">();
	}
	static class UInterchangeOBJTranslator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterchangeOBJTranslator>();
	}
};
static_assert(alignof(UInterchangeOBJTranslator) == 0x000008, "Wrong alignment on UInterchangeOBJTranslator");
static_assert(sizeof(UInterchangeOBJTranslator) == 0x000058, "Wrong size on UInterchangeOBJTranslator");

// Class InterchangeImport.InterchangePhysicsAssetFactory
// 0x0000 (0x0038 - 0x0038)
class UInterchangePhysicsAssetFactory final : public UInterchangeFactoryBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterchangePhysicsAssetFactory">();
	}
	static class UInterchangePhysicsAssetFactory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterchangePhysicsAssetFactory>();
	}
};
static_assert(alignof(UInterchangePhysicsAssetFactory) == 0x000008, "Wrong alignment on UInterchangePhysicsAssetFactory");
static_assert(sizeof(UInterchangePhysicsAssetFactory) == 0x000038, "Wrong size on UInterchangePhysicsAssetFactory");

// Class InterchangeImport.InterchangeSkeletalMeshFactory
// 0x0008 (0x0040 - 0x0038)
class UInterchangeSkeletalMeshFactory final : public UInterchangeFactoryBase
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterchangeSkeletalMeshFactory">();
	}
	static class UInterchangeSkeletalMeshFactory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterchangeSkeletalMeshFactory>();
	}
};
static_assert(alignof(UInterchangeSkeletalMeshFactory) == 0x000008, "Wrong alignment on UInterchangeSkeletalMeshFactory");
static_assert(sizeof(UInterchangeSkeletalMeshFactory) == 0x000040, "Wrong size on UInterchangeSkeletalMeshFactory");

// Class InterchangeImport.InterchangeSkeletonFactory
// 0x0000 (0x0038 - 0x0038)
class UInterchangeSkeletonFactory final : public UInterchangeFactoryBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterchangeSkeletonFactory">();
	}
	static class UInterchangeSkeletonFactory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterchangeSkeletonFactory>();
	}
};
static_assert(alignof(UInterchangeSkeletonFactory) == 0x000008, "Wrong alignment on UInterchangeSkeletonFactory");
static_assert(sizeof(UInterchangeSkeletonFactory) == 0x000038, "Wrong size on UInterchangeSkeletonFactory");

// Class InterchangeImport.InterchangeStaticMeshFactory
// 0x0000 (0x0038 - 0x0038)
class UInterchangeStaticMeshFactory final : public UInterchangeFactoryBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterchangeStaticMeshFactory">();
	}
	static class UInterchangeStaticMeshFactory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterchangeStaticMeshFactory>();
	}
};
static_assert(alignof(UInterchangeStaticMeshFactory) == 0x000008, "Wrong alignment on UInterchangeStaticMeshFactory");
static_assert(sizeof(UInterchangeStaticMeshFactory) == 0x000038, "Wrong size on UInterchangeStaticMeshFactory");

// Class InterchangeImport.InterchangeActorFactory
// 0x0000 (0x0038 - 0x0038)
class UInterchangeActorFactory : public UInterchangeFactoryBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterchangeActorFactory">();
	}
	static class UInterchangeActorFactory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterchangeActorFactory>();
	}
};
static_assert(alignof(UInterchangeActorFactory) == 0x000008, "Wrong alignment on UInterchangeActorFactory");
static_assert(sizeof(UInterchangeActorFactory) == 0x000038, "Wrong size on UInterchangeActorFactory");

// Class InterchangeImport.InterchangeCineCameraActorFactory
// 0x0000 (0x0038 - 0x0038)
class UInterchangeCineCameraActorFactory final : public UInterchangeFactoryBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterchangeCineCameraActorFactory">();
	}
	static class UInterchangeCineCameraActorFactory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterchangeCineCameraActorFactory>();
	}
};
static_assert(alignof(UInterchangeCineCameraActorFactory) == 0x000008, "Wrong alignment on UInterchangeCineCameraActorFactory");
static_assert(sizeof(UInterchangeCineCameraActorFactory) == 0x000038, "Wrong size on UInterchangeCineCameraActorFactory");

// Class InterchangeImport.InterchangeSkeletalMeshActorFactory
// 0x0000 (0x0038 - 0x0038)
class UInterchangeSkeletalMeshActorFactory final : public UInterchangeActorFactory
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterchangeSkeletalMeshActorFactory">();
	}
	static class UInterchangeSkeletalMeshActorFactory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterchangeSkeletalMeshActorFactory>();
	}
};
static_assert(alignof(UInterchangeSkeletalMeshActorFactory) == 0x000008, "Wrong alignment on UInterchangeSkeletalMeshActorFactory");
static_assert(sizeof(UInterchangeSkeletalMeshActorFactory) == 0x000038, "Wrong size on UInterchangeSkeletalMeshActorFactory");

// Class InterchangeImport.InterchangeStaticMeshActorFactory
// 0x0000 (0x0038 - 0x0038)
class UInterchangeStaticMeshActorFactory final : public UInterchangeFactoryBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterchangeStaticMeshActorFactory">();
	}
	static class UInterchangeStaticMeshActorFactory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterchangeStaticMeshActorFactory>();
	}
};
static_assert(alignof(UInterchangeStaticMeshActorFactory) == 0x000008, "Wrong alignment on UInterchangeStaticMeshActorFactory");
static_assert(sizeof(UInterchangeStaticMeshActorFactory) == 0x000038, "Wrong size on UInterchangeStaticMeshActorFactory");

// Class InterchangeImport.InterchangeDDSTranslator
// 0x0010 (0x0050 - 0x0040)
class UInterchangeDDSTranslator final : public UInterchangeTranslatorBase
{
public:
	uint8                                         Pad_40[0x10];                                      // 0x0040(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterchangeDDSTranslator">();
	}
	static class UInterchangeDDSTranslator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterchangeDDSTranslator>();
	}
};
static_assert(alignof(UInterchangeDDSTranslator) == 0x000008, "Wrong alignment on UInterchangeDDSTranslator");
static_assert(sizeof(UInterchangeDDSTranslator) == 0x000050, "Wrong size on UInterchangeDDSTranslator");

// Class InterchangeImport.InterchangeIESTranslator
// 0x0008 (0x0048 - 0x0040)
class UInterchangeIESTranslator final : public UInterchangeTranslatorBase
{
public:
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterchangeIESTranslator">();
	}
	static class UInterchangeIESTranslator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterchangeIESTranslator>();
	}
};
static_assert(alignof(UInterchangeIESTranslator) == 0x000008, "Wrong alignment on UInterchangeIESTranslator");
static_assert(sizeof(UInterchangeIESTranslator) == 0x000048, "Wrong size on UInterchangeIESTranslator");

// Class InterchangeImport.InterchangeImageWrapperTranslator
// 0x0010 (0x0050 - 0x0040)
class UInterchangeImageWrapperTranslator final : public UInterchangeTranslatorBase
{
public:
	uint8                                         Pad_40[0x10];                                      // 0x0040(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterchangeImageWrapperTranslator">();
	}
	static class UInterchangeImageWrapperTranslator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterchangeImageWrapperTranslator>();
	}
};
static_assert(alignof(UInterchangeImageWrapperTranslator) == 0x000008, "Wrong alignment on UInterchangeImageWrapperTranslator");
static_assert(sizeof(UInterchangeImageWrapperTranslator) == 0x000050, "Wrong size on UInterchangeImageWrapperTranslator");

// Class InterchangeImport.InterchangeJPGTranslator
// 0x0008 (0x0048 - 0x0040)
class UInterchangeJPGTranslator final : public UInterchangeTranslatorBase
{
public:
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterchangeJPGTranslator">();
	}
	static class UInterchangeJPGTranslator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterchangeJPGTranslator>();
	}
};
static_assert(alignof(UInterchangeJPGTranslator) == 0x000008, "Wrong alignment on UInterchangeJPGTranslator");
static_assert(sizeof(UInterchangeJPGTranslator) == 0x000048, "Wrong size on UInterchangeJPGTranslator");

// Class InterchangeImport.InterchangePCXTranslator
// 0x0008 (0x0048 - 0x0040)
class UInterchangePCXTranslator final : public UInterchangeTranslatorBase
{
public:
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterchangePCXTranslator">();
	}
	static class UInterchangePCXTranslator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterchangePCXTranslator>();
	}
};
static_assert(alignof(UInterchangePCXTranslator) == 0x000008, "Wrong alignment on UInterchangePCXTranslator");
static_assert(sizeof(UInterchangePCXTranslator) == 0x000048, "Wrong size on UInterchangePCXTranslator");

// Class InterchangeImport.InterchangePSDTranslator
// 0x0008 (0x0048 - 0x0040)
class UInterchangePSDTranslator final : public UInterchangeTranslatorBase
{
public:
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterchangePSDTranslator">();
	}
	static class UInterchangePSDTranslator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterchangePSDTranslator>();
	}
};
static_assert(alignof(UInterchangePSDTranslator) == 0x000008, "Wrong alignment on UInterchangePSDTranslator");
static_assert(sizeof(UInterchangePSDTranslator) == 0x000048, "Wrong size on UInterchangePSDTranslator");

// Class InterchangeImport.InterchangeTextureFactory
// 0x0070 (0x00A8 - 0x0038)
class UInterchangeTextureFactory final : public UInterchangeFactoryBase
{
public:
	uint8                                         Pad_38[0x70];                                      // 0x0038(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterchangeTextureFactory">();
	}
	static class UInterchangeTextureFactory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterchangeTextureFactory>();
	}
};
static_assert(alignof(UInterchangeTextureFactory) == 0x000008, "Wrong alignment on UInterchangeTextureFactory");
static_assert(sizeof(UInterchangeTextureFactory) == 0x0000A8, "Wrong size on UInterchangeTextureFactory");

}

