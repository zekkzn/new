#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: DBDGameplay

#include "Basic.hpp"

#include "VFXUtilities_classes.hpp"
#include "AIModule_structs.hpp"
#include "AIModule_classes.hpp"
#include "GameplayTags_structs.hpp"
#include "DeadByDaylight_structs.hpp"
#include "DeadByDaylight_classes.hpp"
#include "DBDInteraction_classes.hpp"
#include "DataTableUtilities_structs.hpp"
#include "DBDGameplay_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "QueryService_structs.hpp"
#include "GameplayUtilities_classes.hpp"
#include "StatSystem_structs.hpp"
#include "NetworkUtilities_structs.hpp"
#include "GameplayTagUtilities_structs.hpp"
#include "DBDSharedTypes_structs.hpp"


namespace SDK
{

// Class DBDGameplay.DebugIndicator
// 0x0020 (0x02C0 - 0x02A0)
class ADebugIndicator final : public AActor
{
public:
	class UStaticMeshComponent*                   _staticMeshComponent;                              // 0x02A0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDBDOutlineComponent*                   _outlineComponent;                                 // 0x02A8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B0[0x10];                                     // 0x02B0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetColor(const struct FLinearColor& Color);
	void SetVisible(const bool Visible);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebugIndicator">();
	}
	static class ADebugIndicator* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADebugIndicator>();
	}
};
static_assert(alignof(ADebugIndicator) == 0x000008, "Wrong alignment on ADebugIndicator");
static_assert(sizeof(ADebugIndicator) == 0x0002C0, "Wrong size on ADebugIndicator");
static_assert(offsetof(ADebugIndicator, _staticMeshComponent) == 0x0002A0, "Member 'ADebugIndicator::_staticMeshComponent' has a wrong offset!");
static_assert(offsetof(ADebugIndicator, _outlineComponent) == 0x0002A8, "Member 'ADebugIndicator::_outlineComponent' has a wrong offset!");

// Class DBDGameplay.BaseCamperCollectable
// 0x0048 (0x0598 - 0x0550)
class ABaseCamperCollectable : public ACollectable
{
public:
	class USpherePlayerOverlapComponent*          _interactable;                                     // 0x0550(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractor*                            _collectableInteractor;                            // 0x0558(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDropItemInteraction*                   _dropInteraction;                                  // 0x0560(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCollectItemInteraction*                _collectInteraction;                               // 0x0568(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USphereComponent*                       _infectablePrimitive;                              // 0x0570(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDBDOutlineComponent*                   _outlineComponent;                                 // 0x0578(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialHelper*                        _materialHelper;                                   // 0x0580(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USurvivorCollectableOutlineUpdateStrategy* _survivorCollectableOutlineUpdateStrategy;         // 0x0588(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_590[0x8];                                      // 0x0590(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseCamperCollectable">();
	}
	static class ABaseCamperCollectable* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABaseCamperCollectable>();
	}
};
static_assert(alignof(ABaseCamperCollectable) == 0x000008, "Wrong alignment on ABaseCamperCollectable");
static_assert(sizeof(ABaseCamperCollectable) == 0x000598, "Wrong size on ABaseCamperCollectable");
static_assert(offsetof(ABaseCamperCollectable, _interactable) == 0x000550, "Member 'ABaseCamperCollectable::_interactable' has a wrong offset!");
static_assert(offsetof(ABaseCamperCollectable, _collectableInteractor) == 0x000558, "Member 'ABaseCamperCollectable::_collectableInteractor' has a wrong offset!");
static_assert(offsetof(ABaseCamperCollectable, _dropInteraction) == 0x000560, "Member 'ABaseCamperCollectable::_dropInteraction' has a wrong offset!");
static_assert(offsetof(ABaseCamperCollectable, _collectInteraction) == 0x000568, "Member 'ABaseCamperCollectable::_collectInteraction' has a wrong offset!");
static_assert(offsetof(ABaseCamperCollectable, _infectablePrimitive) == 0x000570, "Member 'ABaseCamperCollectable::_infectablePrimitive' has a wrong offset!");
static_assert(offsetof(ABaseCamperCollectable, _outlineComponent) == 0x000578, "Member 'ABaseCamperCollectable::_outlineComponent' has a wrong offset!");
static_assert(offsetof(ABaseCamperCollectable, _materialHelper) == 0x000580, "Member 'ABaseCamperCollectable::_materialHelper' has a wrong offset!");
static_assert(offsetof(ABaseCamperCollectable, _survivorCollectableOutlineUpdateStrategy) == 0x000588, "Member 'ABaseCamperCollectable::_survivorCollectableOutlineUpdateStrategy' has a wrong offset!");

// Class DBDGameplay.ZoneUtilities
// 0x0000 (0x0030 - 0x0030)
class UZoneUtilities final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ZoneUtilities">();
	}
	static class UZoneUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UZoneUtilities>();
	}
};
static_assert(alignof(UZoneUtilities) == 0x000008, "Wrong alignment on UZoneUtilities");
static_assert(sizeof(UZoneUtilities) == 0x000030, "Wrong size on UZoneUtilities");

// Class DBDGameplay.CharacterOptimizer
// 0x0010 (0x00B8 - 0x00A8)
class UCharacterOptimizer final : public UActorComponent
{
public:
	float                                         _characterMovementTickRateWhenInsignificant;       // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_AC[0xC];                                       // 0x00AC(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterOptimizer">();
	}
	static class UCharacterOptimizer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterOptimizer>();
	}
};
static_assert(alignof(UCharacterOptimizer) == 0x000008, "Wrong alignment on UCharacterOptimizer");
static_assert(sizeof(UCharacterOptimizer) == 0x0000B8, "Wrong size on UCharacterOptimizer");
static_assert(offsetof(UCharacterOptimizer, _characterMovementTickRateWhenInsignificant) == 0x0000A8, "Member 'UCharacterOptimizer::_characterMovementTickRateWhenInsignificant' has a wrong offset!");

// Class DBDGameplay.BaseHusk
// 0x0040 (0x02E8 - 0x02A8)
class ABaseHusk : public ABaseVFX
{
public:
	uint8                                         Pad_2A8[0x18];                                     // 0x02A8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        _rootComponent;                                    // 0x02C0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDBDSkeletalMeshComponentBudgeted*      _huskMesh;                                         // 0x02C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCustomizedSkeletalMesh*                _huskCustomizedSkeletalMesh;                       // 0x02D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _shouldDeactivateVFX;                              // 0x02D8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D9[0xB];                                      // 0x02D9(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _updateWeaponAccessories;                          // 0x02E4(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _shouldWeaponBeVisible;                            // 0x02E5(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2E6[0x2];                                      // 0x02E6(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_InitializeSkeletalMesh(class USkeletalMeshComponent* Mesh);
	void InitializeHusk(class UCustomizedSkeletalMesh* CustomizedSkeletalMeshToCopy, class USkeletalMeshComponent* SkeletalMeshToCopy, int32 CharacterIdOverride);
	void SetHuskVisibility(bool Visible);
	void SetScalarParameterOnAllChildrenMeshes(class FName ParameterName, float Value, class USkeletalMeshComponent* Mesh);

	const class UCustomizedSkeletalMesh* GetCopiedCustomizedSkeletalMesh() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseHusk">();
	}
	static class ABaseHusk* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABaseHusk>();
	}
};
static_assert(alignof(ABaseHusk) == 0x000008, "Wrong alignment on ABaseHusk");
static_assert(sizeof(ABaseHusk) == 0x0002E8, "Wrong size on ABaseHusk");
static_assert(offsetof(ABaseHusk, _rootComponent) == 0x0002C0, "Member 'ABaseHusk::_rootComponent' has a wrong offset!");
static_assert(offsetof(ABaseHusk, _huskMesh) == 0x0002C8, "Member 'ABaseHusk::_huskMesh' has a wrong offset!");
static_assert(offsetof(ABaseHusk, _huskCustomizedSkeletalMesh) == 0x0002D0, "Member 'ABaseHusk::_huskCustomizedSkeletalMesh' has a wrong offset!");
static_assert(offsetof(ABaseHusk, _shouldDeactivateVFX) == 0x0002D8, "Member 'ABaseHusk::_shouldDeactivateVFX' has a wrong offset!");
static_assert(offsetof(ABaseHusk, _updateWeaponAccessories) == 0x0002E4, "Member 'ABaseHusk::_updateWeaponAccessories' has a wrong offset!");
static_assert(offsetof(ABaseHusk, _shouldWeaponBeVisible) == 0x0002E5, "Member 'ABaseHusk::_shouldWeaponBeVisible' has a wrong offset!");

// Class DBDGameplay.FlashlightUtilities
// 0x0000 (0x0030 - 0x0030)
class UFlashlightUtilities final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlashlightUtilities">();
	}
	static class UFlashlightUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlashlightUtilities>();
	}
};
static_assert(alignof(UFlashlightUtilities) == 0x000008, "Wrong alignment on UFlashlightUtilities");
static_assert(sizeof(UFlashlightUtilities) == 0x000030, "Wrong size on UFlashlightUtilities");

// Class DBDGameplay.BaseRangedExplosiveActorEffect
// 0x0000 (0x0030 - 0x0030)
class UBaseRangedExplosiveActorEffect : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseRangedExplosiveActorEffect">();
	}
	static class UBaseRangedExplosiveActorEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseRangedExplosiveActorEffect>();
	}
};
static_assert(alignof(UBaseRangedExplosiveActorEffect) == 0x000008, "Wrong alignment on UBaseRangedExplosiveActorEffect");
static_assert(sizeof(UBaseRangedExplosiveActorEffect) == 0x000030, "Wrong size on UBaseRangedExplosiveActorEffect");

// Class DBDGameplay.BlindAndDeafenRangedExplosiveActorEffect
// 0x0000 (0x0030 - 0x0030)
class UBlindAndDeafenRangedExplosiveActorEffect final : public UBaseRangedExplosiveActorEffect
{
public:
	bool Authority_TryToBlind(class UBlindableBaseComponent* BlindableComponent, class AActor* EffectorActor) const;
	bool Authority_TryToDeafen(const class ADBDPlayer* Player, class UAudioFXComponent* AudioFXComponent) const;
	float GetBlindnessEffectDuration(const class AActor* Player) const;
	float GetDeafnessEffectDuration(const class AActor* Player) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlindAndDeafenRangedExplosiveActorEffect">();
	}
	static class UBlindAndDeafenRangedExplosiveActorEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlindAndDeafenRangedExplosiveActorEffect>();
	}
};
static_assert(alignof(UBlindAndDeafenRangedExplosiveActorEffect) == 0x000008, "Wrong alignment on UBlindAndDeafenRangedExplosiveActorEffect");
static_assert(sizeof(UBlindAndDeafenRangedExplosiveActorEffect) == 0x000030, "Wrong size on UBlindAndDeafenRangedExplosiveActorEffect");

// Class DBDGameplay.SurvivorBoundOptimizer
// 0x0020 (0x00C8 - 0x00A8)
class USurvivorBoundOptimizer final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x20];                                      // 0x00A8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SurvivorBoundOptimizer">();
	}
	static class USurvivorBoundOptimizer* GetDefaultObj()
	{
		return GetDefaultObjImpl<USurvivorBoundOptimizer>();
	}
};
static_assert(alignof(USurvivorBoundOptimizer) == 0x000008, "Wrong alignment on USurvivorBoundOptimizer");
static_assert(sizeof(USurvivorBoundOptimizer) == 0x0000C8, "Wrong size on USurvivorBoundOptimizer");

// Class DBDGameplay.CageHook
// 0x02E0 (0x0688 - 0x03A8)
class ACageHook : public AInteractable
{
public:
	uint8                                         Pad_3A8[0x80];                                     // 0x03A8(0x0080)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _timeToBlockLocationOnRescue;                      // 0x0428(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _sacrificeScoreEvent;                              // 0x0450(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _inMontageID;                                      // 0x045C(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _idleMontageID;                                    // 0x0468(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _idleToStruggleMontageID;                          // 0x0474(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _struggleMontageID;                                // 0x0480(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _struggleHitMontageID;                             // 0x048C(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _deadMontageID;                                    // 0x0498(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _relocateMontageID;                                // 0x04A4(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _goingUnderMontageID;                              // 0x04B0(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _survivorSocketID;                                 // 0x04BC(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _rescuerSocketID;                                  // 0x04C8(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _cameraSocketID;                                   // 0x04D4(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _rescueSocketID;                                   // 0x04E0(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _sacrificeAfterMontageSecond;                      // 0x04EC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _goingUnderMontageSecond;                          // 0x04F0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _furthestLocationSelectionCount;                   // 0x04F4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        _root;                                             // 0x04F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ACamperPlayer*                          _cagedSurvivor;                                    // 0x0500(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ASlasherPlayer*                         _killerInstigator;                                 // 0x0508(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UChargeableComponent*                   _rescueChargeableComponent;                        // 0x0510(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDBDSkeletalMeshComponentBudgeted*      _cageSkeletalMesh;                                 // 0x0518(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBoxComponent*                          _interactionZone;                                  // 0x0520(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBoxComponent*                          _playerOverlapZone;                                // 0x0528(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMontagePlayer*                         _montagePlayer;                                    // 0x0530(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_538[0x10];                                     // 0x0538(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UBoxComponent*                          _cageCollision;                                    // 0x0548(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_550[0x50];                                     // 0x0550(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimationMontageSlave*                 _animationMontageSlave;                            // 0x05A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimMontage*                           _montageToPlay;                                    // 0x05A8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5B0[0x8];                                      // 0x05B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                _rescuerSnapPosition;                              // 0x05B8(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCageHookAntiCampComponent*             _anticampComponent;                                // 0x05D0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5D8[0x70];                                     // 0x05D8(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _anticampDrainCooldownTime;                        // 0x0648(0x0028)(Edit, NativeAccessSpecifierPrivate)
	uint8                                         Pad_670[0x10];                                     // 0x0670(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UAIPerceptionStimuliSourceComponent*    _perceptionStimuliComponent;                       // 0x0680(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void CheckRescuerSocketPosition();
	void Cosmetic_DisplayCage(const bool Display);
	void Cosmetic_OnPlayerAbsorbedByGround();
	void Cosmetic_OnRelocateStart();
	void FX_SurvivorSavedFromCage();
	void Multicast_Relocate(const struct FVector& Location, const struct FRotator& Rotation, const bool IsAnticampRelocation);
	void Multicast_SendSurvivorToCage(class ACamperPlayer* Survivor, class ASlasherPlayer* KillerInstigator);
	void Multicast_SendSurvivorToCageImmediately(class ACamperPlayer* Survivor, class ASlasherPlayer* KillerInstigator, const struct FVector& Location, const struct FRotator& Rotation);
	void OnCageDisappear();
	void OnRescueCancelled();
	void OnSkillCheckFailed();
	void OnSkillCheckFailed_Cosmetic();
	void PlayerOverlapZoneBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void PlayerOverlapZoneEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

	class ACamperPlayer* GetCagedSurvivor() const;
	class UMontagePlayer* GetMontagePlayer() const;
	struct FVector GetRescuerSnapPosition() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CageHook">();
	}
	static class ACageHook* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACageHook>();
	}
};
static_assert(alignof(ACageHook) == 0x000008, "Wrong alignment on ACageHook");
static_assert(sizeof(ACageHook) == 0x000688, "Wrong size on ACageHook");
static_assert(offsetof(ACageHook, _timeToBlockLocationOnRescue) == 0x000428, "Member 'ACageHook::_timeToBlockLocationOnRescue' has a wrong offset!");
static_assert(offsetof(ACageHook, _sacrificeScoreEvent) == 0x000450, "Member 'ACageHook::_sacrificeScoreEvent' has a wrong offset!");
static_assert(offsetof(ACageHook, _inMontageID) == 0x00045C, "Member 'ACageHook::_inMontageID' has a wrong offset!");
static_assert(offsetof(ACageHook, _idleMontageID) == 0x000468, "Member 'ACageHook::_idleMontageID' has a wrong offset!");
static_assert(offsetof(ACageHook, _idleToStruggleMontageID) == 0x000474, "Member 'ACageHook::_idleToStruggleMontageID' has a wrong offset!");
static_assert(offsetof(ACageHook, _struggleMontageID) == 0x000480, "Member 'ACageHook::_struggleMontageID' has a wrong offset!");
static_assert(offsetof(ACageHook, _struggleHitMontageID) == 0x00048C, "Member 'ACageHook::_struggleHitMontageID' has a wrong offset!");
static_assert(offsetof(ACageHook, _deadMontageID) == 0x000498, "Member 'ACageHook::_deadMontageID' has a wrong offset!");
static_assert(offsetof(ACageHook, _relocateMontageID) == 0x0004A4, "Member 'ACageHook::_relocateMontageID' has a wrong offset!");
static_assert(offsetof(ACageHook, _goingUnderMontageID) == 0x0004B0, "Member 'ACageHook::_goingUnderMontageID' has a wrong offset!");
static_assert(offsetof(ACageHook, _survivorSocketID) == 0x0004BC, "Member 'ACageHook::_survivorSocketID' has a wrong offset!");
static_assert(offsetof(ACageHook, _rescuerSocketID) == 0x0004C8, "Member 'ACageHook::_rescuerSocketID' has a wrong offset!");
static_assert(offsetof(ACageHook, _cameraSocketID) == 0x0004D4, "Member 'ACageHook::_cameraSocketID' has a wrong offset!");
static_assert(offsetof(ACageHook, _rescueSocketID) == 0x0004E0, "Member 'ACageHook::_rescueSocketID' has a wrong offset!");
static_assert(offsetof(ACageHook, _sacrificeAfterMontageSecond) == 0x0004EC, "Member 'ACageHook::_sacrificeAfterMontageSecond' has a wrong offset!");
static_assert(offsetof(ACageHook, _goingUnderMontageSecond) == 0x0004F0, "Member 'ACageHook::_goingUnderMontageSecond' has a wrong offset!");
static_assert(offsetof(ACageHook, _furthestLocationSelectionCount) == 0x0004F4, "Member 'ACageHook::_furthestLocationSelectionCount' has a wrong offset!");
static_assert(offsetof(ACageHook, _root) == 0x0004F8, "Member 'ACageHook::_root' has a wrong offset!");
static_assert(offsetof(ACageHook, _cagedSurvivor) == 0x000500, "Member 'ACageHook::_cagedSurvivor' has a wrong offset!");
static_assert(offsetof(ACageHook, _killerInstigator) == 0x000508, "Member 'ACageHook::_killerInstigator' has a wrong offset!");
static_assert(offsetof(ACageHook, _rescueChargeableComponent) == 0x000510, "Member 'ACageHook::_rescueChargeableComponent' has a wrong offset!");
static_assert(offsetof(ACageHook, _cageSkeletalMesh) == 0x000518, "Member 'ACageHook::_cageSkeletalMesh' has a wrong offset!");
static_assert(offsetof(ACageHook, _interactionZone) == 0x000520, "Member 'ACageHook::_interactionZone' has a wrong offset!");
static_assert(offsetof(ACageHook, _playerOverlapZone) == 0x000528, "Member 'ACageHook::_playerOverlapZone' has a wrong offset!");
static_assert(offsetof(ACageHook, _montagePlayer) == 0x000530, "Member 'ACageHook::_montagePlayer' has a wrong offset!");
static_assert(offsetof(ACageHook, _cageCollision) == 0x000548, "Member 'ACageHook::_cageCollision' has a wrong offset!");
static_assert(offsetof(ACageHook, _animationMontageSlave) == 0x0005A0, "Member 'ACageHook::_animationMontageSlave' has a wrong offset!");
static_assert(offsetof(ACageHook, _montageToPlay) == 0x0005A8, "Member 'ACageHook::_montageToPlay' has a wrong offset!");
static_assert(offsetof(ACageHook, _rescuerSnapPosition) == 0x0005B8, "Member 'ACageHook::_rescuerSnapPosition' has a wrong offset!");
static_assert(offsetof(ACageHook, _anticampComponent) == 0x0005D0, "Member 'ACageHook::_anticampComponent' has a wrong offset!");
static_assert(offsetof(ACageHook, _anticampDrainCooldownTime) == 0x000648, "Member 'ACageHook::_anticampDrainCooldownTime' has a wrong offset!");
static_assert(offsetof(ACageHook, _perceptionStimuliComponent) == 0x000680, "Member 'ACageHook::_perceptionStimuliComponent' has a wrong offset!");

// Class DBDGameplay.UnhookedSurvivorTrackerComponent
// 0x0028 (0x00D0 - 0x00A8)
class UUnhookedSurvivorTrackerComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x28];                                      // 0x00A8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnhookedSurvivorTrackerComponent">();
	}
	static class UUnhookedSurvivorTrackerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnhookedSurvivorTrackerComponent>();
	}
};
static_assert(alignof(UUnhookedSurvivorTrackerComponent) == 0x000008, "Wrong alignment on UUnhookedSurvivorTrackerComponent");
static_assert(sizeof(UUnhookedSurvivorTrackerComponent) == 0x0000D0, "Wrong size on UUnhookedSurvivorTrackerComponent");

// Class DBDGameplay.BaseActorAttackableComponent
// 0x0038 (0x00E0 - 0x00A8)
class UBaseActorAttackableComponent : public UAttackableComponent
{
public:
	uint8                                         Pad_A8[0x18];                                      // 0x00A8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  _killerProjectilesThatCanDamageActor;              // 0x00C0(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	void HitWithProjectile(class ABaseProjectile* Projectile);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseActorAttackableComponent">();
	}
	static class UBaseActorAttackableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseActorAttackableComponent>();
	}
};
static_assert(alignof(UBaseActorAttackableComponent) == 0x000008, "Wrong alignment on UBaseActorAttackableComponent");
static_assert(sizeof(UBaseActorAttackableComponent) == 0x0000E0, "Wrong size on UBaseActorAttackableComponent");
static_assert(offsetof(UBaseActorAttackableComponent, _killerProjectilesThatCanDamageActor) == 0x0000C0, "Member 'UBaseActorAttackableComponent::_killerProjectilesThatCanDamageActor' has a wrong offset!");

// Class DBDGameplay.CageRescueInteraction
// 0x0040 (0x0900 - 0x08C0)
#pragma pack(push, 0x1)
class alignas(0x10) UCageRescueInteraction : public UChargeableInteractionDefinition
{
public:
	struct FGameplayTag                           _cageRescueScoreEvent;                             // 0x08C0(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8CC[0x4];                                      // 0x08CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _loudNoiseRange;                                   // 0x08D0(0x0028)(Edit, NativeAccessSpecifierPrivate)

public:
	struct FVector GetRescuerSnapPosition() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CageRescueInteraction">();
	}
	static class UCageRescueInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCageRescueInteraction>();
	}
};
#pragma pack(pop)
static_assert(alignof(UCageRescueInteraction) == 0x000010, "Wrong alignment on UCageRescueInteraction");
static_assert(sizeof(UCageRescueInteraction) == 0x000900, "Wrong size on UCageRescueInteraction");
static_assert(offsetof(UCageRescueInteraction, _cageRescueScoreEvent) == 0x0008C0, "Member 'UCageRescueInteraction::_cageRescueScoreEvent' has a wrong offset!");
static_assert(offsetof(UCageRescueInteraction, _loudNoiseRange) == 0x0008D0, "Member 'UCageRescueInteraction::_loudNoiseRange' has a wrong offset!");

// Class DBDGameplay.SendToCageInteraction
// 0x0010 (0x0930 - 0x0920)
class USendToCageInteraction : public UBasicChargeableInteraction
{
public:
	struct FGameplayTag                           _sendToCageScoreEvent;                             // 0x0920(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_92C[0x4];                                      // 0x092C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FX_InteractionCancel();
	void FX_InteractionChargeCompleted(class ADBDPlayer* Player);
	void FX_InteractionStart();

	const class ACamperPlayer* GetOwningSurvivor() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SendToCageInteraction">();
	}
	static class USendToCageInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<USendToCageInteraction>();
	}
};
static_assert(alignof(USendToCageInteraction) == 0x000010, "Wrong alignment on USendToCageInteraction");
static_assert(sizeof(USendToCageInteraction) == 0x000930, "Wrong size on USendToCageInteraction");
static_assert(offsetof(USendToCageInteraction, _sendToCageScoreEvent) == 0x000920, "Member 'USendToCageInteraction::_sendToCageScoreEvent' has a wrong offset!");

// Class DBDGameplay.AuraOverriderComponent
// 0x0050 (0x00F8 - 0x00A8)
class UAuraOverriderComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x50];                                      // 0x00A8(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ForceShowAura(const class AActor* Actor, const struct FLinearColor& Color, bool IsAlwaysVisible, const float MinimumOutlineDistanceVisible, const float MinimumOutlineDistance);
	void ResetAura(const class AActor* Actor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AuraOverriderComponent">();
	}
	static class UAuraOverriderComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAuraOverriderComponent>();
	}
};
static_assert(alignof(UAuraOverriderComponent) == 0x000008, "Wrong alignment on UAuraOverriderComponent");
static_assert(sizeof(UAuraOverriderComponent) == 0x0000F8, "Wrong size on UAuraOverriderComponent");

// Class DBDGameplay.BaseSightManagerComponent
// 0x00B0 (0x0158 - 0x00A8)
class UBaseSightManagerComponent : public UActorComponent
{
public:
	struct FDBDTunableRowHandle                   _maximumSightDistance;                             // 0x00A8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _sightingDelay;                                    // 0x00D0(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _discerningDelay;                                  // 0x00F8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _undiscerningDelay;                                // 0x0120(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FSurvivorLookStatus>            _survivorLookStatus;                               // 0x0148(0x0010)(Net, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	void Authority_OnCharacterSightChanged(class ACharacter* SightedCharacter, class UCharacterSightComponent* SightComponent);
	void OnIntroCompleted();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseSightManagerComponent">();
	}
	static class UBaseSightManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseSightManagerComponent>();
	}
};
static_assert(alignof(UBaseSightManagerComponent) == 0x000008, "Wrong alignment on UBaseSightManagerComponent");
static_assert(sizeof(UBaseSightManagerComponent) == 0x000158, "Wrong size on UBaseSightManagerComponent");
static_assert(offsetof(UBaseSightManagerComponent, _maximumSightDistance) == 0x0000A8, "Member 'UBaseSightManagerComponent::_maximumSightDistance' has a wrong offset!");
static_assert(offsetof(UBaseSightManagerComponent, _sightingDelay) == 0x0000D0, "Member 'UBaseSightManagerComponent::_sightingDelay' has a wrong offset!");
static_assert(offsetof(UBaseSightManagerComponent, _discerningDelay) == 0x0000F8, "Member 'UBaseSightManagerComponent::_discerningDelay' has a wrong offset!");
static_assert(offsetof(UBaseSightManagerComponent, _undiscerningDelay) == 0x000120, "Member 'UBaseSightManagerComponent::_undiscerningDelay' has a wrong offset!");
static_assert(offsetof(UBaseSightManagerComponent, _survivorLookStatus) == 0x000148, "Member 'UBaseSightManagerComponent::_survivorLookStatus' has a wrong offset!");

// Class DBDGameplay.IgnoreCollisionsHandlerComponent
// 0x0020 (0x05F0 - 0x05D0)
class UIgnoreCollisionsHandlerComponent : public UBoxComponent
{
public:
	uint8                                         Pad_5D0[0x20];                                     // 0x05D0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IgnoreCollisionsHandlerComponent">();
	}
	static class UIgnoreCollisionsHandlerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIgnoreCollisionsHandlerComponent>();
	}
};
static_assert(alignof(UIgnoreCollisionsHandlerComponent) == 0x000010, "Wrong alignment on UIgnoreCollisionsHandlerComponent");
static_assert(sizeof(UIgnoreCollisionsHandlerComponent) == 0x0005F0, "Wrong size on UIgnoreCollisionsHandlerComponent");

// Class DBDGameplay.IgnoreCollisionsPalletHandlerComponent
// 0x0000 (0x05F0 - 0x05F0)
class UIgnoreCollisionsPalletHandlerComponent : public UIgnoreCollisionsHandlerComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IgnoreCollisionsPalletHandlerComponent">();
	}
	static class UIgnoreCollisionsPalletHandlerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIgnoreCollisionsPalletHandlerComponent>();
	}
};
static_assert(alignof(UIgnoreCollisionsPalletHandlerComponent) == 0x000010, "Wrong alignment on UIgnoreCollisionsPalletHandlerComponent");
static_assert(sizeof(UIgnoreCollisionsPalletHandlerComponent) == 0x0005F0, "Wrong size on UIgnoreCollisionsPalletHandlerComponent");

// Class DBDGameplay.FlashlightableLightingStrategy
// 0x0000 (0x0030 - 0x0030)
class UFlashlightableLightingStrategy : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlashlightableLightingStrategy">();
	}
	static class UFlashlightableLightingStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlashlightableLightingStrategy>();
	}
};
static_assert(alignof(UFlashlightableLightingStrategy) == 0x000008, "Wrong alignment on UFlashlightableLightingStrategy");
static_assert(sizeof(UFlashlightableLightingStrategy) == 0x000030, "Wrong size on UFlashlightableLightingStrategy");

// Class DBDGameplay.DebugTimerLogComponent
// 0x0080 (0x0128 - 0x00A8)
class UDebugTimerLogComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x30];                                      // 0x00A8(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 _timerDisplayName;                                 // 0x00D8(0x0010)(Net, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FSpeedBasedNetSyncedValue              _timerCountdown;                                   // 0x00E8(0x0038)(Net, RepNotify, NativeAccessSpecifierPrivate)
	float                                         _timerRemainingPercent;                            // 0x0120(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_124[0x4];                                      // 0x0124(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_TimerCountdown();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebugTimerLogComponent">();
	}
	static class UDebugTimerLogComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDebugTimerLogComponent>();
	}
};
static_assert(alignof(UDebugTimerLogComponent) == 0x000008, "Wrong alignment on UDebugTimerLogComponent");
static_assert(sizeof(UDebugTimerLogComponent) == 0x000128, "Wrong size on UDebugTimerLogComponent");
static_assert(offsetof(UDebugTimerLogComponent, _timerDisplayName) == 0x0000D8, "Member 'UDebugTimerLogComponent::_timerDisplayName' has a wrong offset!");
static_assert(offsetof(UDebugTimerLogComponent, _timerCountdown) == 0x0000E8, "Member 'UDebugTimerLogComponent::_timerCountdown' has a wrong offset!");
static_assert(offsetof(UDebugTimerLogComponent, _timerRemainingPercent) == 0x000120, "Member 'UDebugTimerLogComponent::_timerRemainingPercent' has a wrong offset!");

// Class DBDGameplay.FadeComponent
// 0x0020 (0x00C8 - 0x00A8)
class UFadeComponent : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnFadePercentChanged;                              // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         _fadeDuration;                                     // 0x00B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_BC[0xC];                                       // 0x00BC(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetFadePercent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FadeComponent">();
	}
	static class UFadeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFadeComponent>();
	}
};
static_assert(alignof(UFadeComponent) == 0x000008, "Wrong alignment on UFadeComponent");
static_assert(sizeof(UFadeComponent) == 0x0000C8, "Wrong size on UFadeComponent");
static_assert(offsetof(UFadeComponent, OnFadePercentChanged) == 0x0000A8, "Member 'UFadeComponent::OnFadePercentChanged' has a wrong offset!");
static_assert(offsetof(UFadeComponent, _fadeDuration) == 0x0000B8, "Member 'UFadeComponent::_fadeDuration' has a wrong offset!");

// Class DBDGameplay.FlashlightTargetFXComponent
// 0x0048 (0x00F0 - 0x00A8)
class UFlashlightTargetFXComponent : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x30];                                      // 0x00A8(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _modifiesBeamAngle;                                // 0x00D8(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D9[0x7];                                       // 0x00D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UFlashlightableComponent*               _flashlightable;                                   // 0x00E0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E8[0x8];                                       // 0x00E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnIsLitChanged(bool IsLit);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlashlightTargetFXComponent">();
	}
	static class UFlashlightTargetFXComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlashlightTargetFXComponent>();
	}
};
static_assert(alignof(UFlashlightTargetFXComponent) == 0x000008, "Wrong alignment on UFlashlightTargetFXComponent");
static_assert(sizeof(UFlashlightTargetFXComponent) == 0x0000F0, "Wrong size on UFlashlightTargetFXComponent");
static_assert(offsetof(UFlashlightTargetFXComponent, _modifiesBeamAngle) == 0x0000D8, "Member 'UFlashlightTargetFXComponent::_modifiesBeamAngle' has a wrong offset!");
static_assert(offsetof(UFlashlightTargetFXComponent, _flashlightable) == 0x0000E0, "Member 'UFlashlightTargetFXComponent::_flashlightable' has a wrong offset!");

// Class DBDGameplay.TargetableComponent
// 0x00A0 (0x0360 - 0x02C0)
class UTargetableComponent : public USceneComponent
{
public:
	class UTargetableStrategy*                    _targetableStrategy;                               // 0x02C0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C8[0x8];                                      // 0x02C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             _relativeTransformToTargetActor;                   // 0x02D0(0x0060)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_330[0x4];                                      // 0x0330(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           _outlineColorWhenAnAvailableTarget;                // 0x0334(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           _outlineColorWhenBeingTargeted;                    // 0x0344(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_354[0xC];                                      // 0x0354(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TargetableComponent">();
	}
	static class UTargetableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTargetableComponent>();
	}
};
static_assert(alignof(UTargetableComponent) == 0x000010, "Wrong alignment on UTargetableComponent");
static_assert(sizeof(UTargetableComponent) == 0x000360, "Wrong size on UTargetableComponent");
static_assert(offsetof(UTargetableComponent, _targetableStrategy) == 0x0002C0, "Member 'UTargetableComponent::_targetableStrategy' has a wrong offset!");
static_assert(offsetof(UTargetableComponent, _relativeTransformToTargetActor) == 0x0002D0, "Member 'UTargetableComponent::_relativeTransformToTargetActor' has a wrong offset!");
static_assert(offsetof(UTargetableComponent, _outlineColorWhenAnAvailableTarget) == 0x000334, "Member 'UTargetableComponent::_outlineColorWhenAnAvailableTarget' has a wrong offset!");
static_assert(offsetof(UTargetableComponent, _outlineColorWhenBeingTargeted) == 0x000344, "Member 'UTargetableComponent::_outlineColorWhenBeingTargeted' has a wrong offset!");

// Class DBDGameplay.TerrorRadiusScreenIndicatorComponent
// 0x00C0 (0x03A0 - 0x02E0)
class UTerrorRadiusScreenIndicatorComponent final : public UScreenIndicatorWorldMarkerComponent
{
public:
	TArray<struct FHideHeartIndicatorWithDelay>   _hideHeartIndicatorWithDelay;                      // 0x02D8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E8[0xB8];                                     // 0x02E8(0x00B8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnHeartStateChanged(const struct FGameplayTag& HeartState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TerrorRadiusScreenIndicatorComponent">();
	}
	static class UTerrorRadiusScreenIndicatorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTerrorRadiusScreenIndicatorComponent>();
	}
};
static_assert(alignof(UTerrorRadiusScreenIndicatorComponent) == 0x000010, "Wrong alignment on UTerrorRadiusScreenIndicatorComponent");
static_assert(sizeof(UTerrorRadiusScreenIndicatorComponent) == 0x0003A0, "Wrong size on UTerrorRadiusScreenIndicatorComponent");
static_assert(offsetof(UTerrorRadiusScreenIndicatorComponent, _hideHeartIndicatorWithDelay) == 0x0002D8, "Member 'UTerrorRadiusScreenIndicatorComponent::_hideHeartIndicatorWithDelay' has a wrong offset!");

// Class DBDGameplay.BlindFlashlightTargetFXComponent
// 0x0030 (0x0120 - 0x00F0)
class UBlindFlashlightTargetFXComponent final : public UFlashlightTargetFXComponent
{
public:
	uint8                                         Pad_F0[0x30];                                      // 0x00F0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlindFlashlightTargetFXComponent">();
	}
	static class UBlindFlashlightTargetFXComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlindFlashlightTargetFXComponent>();
	}
};
static_assert(alignof(UBlindFlashlightTargetFXComponent) == 0x000008, "Wrong alignment on UBlindFlashlightTargetFXComponent");
static_assert(sizeof(UBlindFlashlightTargetFXComponent) == 0x000120, "Wrong size on UBlindFlashlightTargetFXComponent");

// Class DBDGameplay.FlashlightablePointsLightingStrategy
// 0x0010 (0x0040 - 0x0030)
class UFlashlightablePointsLightingStrategy : public UFlashlightableLightingStrategy
{
public:
	class UPointsProvider*                        _pointsProvider;                                   // 0x0030(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoClear, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _impactPointDistanceError;                         // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlashlightablePointsLightingStrategy">();
	}
	static class UFlashlightablePointsLightingStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlashlightablePointsLightingStrategy>();
	}
};
static_assert(alignof(UFlashlightablePointsLightingStrategy) == 0x000008, "Wrong alignment on UFlashlightablePointsLightingStrategy");
static_assert(sizeof(UFlashlightablePointsLightingStrategy) == 0x000040, "Wrong size on UFlashlightablePointsLightingStrategy");
static_assert(offsetof(UFlashlightablePointsLightingStrategy, _pointsProvider) == 0x000030, "Member 'UFlashlightablePointsLightingStrategy::_pointsProvider' has a wrong offset!");
static_assert(offsetof(UFlashlightablePointsLightingStrategy, _impactPointDistanceError) == 0x000038, "Member 'UFlashlightablePointsLightingStrategy::_impactPointDistanceError' has a wrong offset!");

// Class DBDGameplay.BlindFlashlightableLightingStrategy
// 0x0010 (0x0050 - 0x0040)
class UBlindFlashlightableLightingStrategy : public UFlashlightablePointsLightingStrategy
{
public:
	TArray<struct FGameplayTag>                   _flashlightableIgnoreTags;                         // 0x0040(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlindFlashlightableLightingStrategy">();
	}
	static class UBlindFlashlightableLightingStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlindFlashlightableLightingStrategy>();
	}
};
static_assert(alignof(UBlindFlashlightableLightingStrategy) == 0x000008, "Wrong alignment on UBlindFlashlightableLightingStrategy");
static_assert(sizeof(UBlindFlashlightableLightingStrategy) == 0x000050, "Wrong size on UBlindFlashlightableLightingStrategy");
static_assert(offsetof(UBlindFlashlightableLightingStrategy, _flashlightableIgnoreTags) == 0x000040, "Member 'UBlindFlashlightableLightingStrategy::_flashlightableIgnoreTags' has a wrong offset!");

// Class DBDGameplay.DLCCheatComponent
// 0x0000 (0x00A8 - 0x00A8)
class UDLCCheatComponent : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DLCCheatComponent">();
	}
	static class UDLCCheatComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDLCCheatComponent>();
	}
};
static_assert(alignof(UDLCCheatComponent) == 0x000008, "Wrong alignment on UDLCCheatComponent");
static_assert(sizeof(UDLCCheatComponent) == 0x0000A8, "Wrong size on UDLCCheatComponent");

// Class DBDGameplay.KillerAbilityComponent
// 0x0100 (0x01A8 - 0x00A8)
class UKillerAbilityComponent : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UKillerAbilityData*                     _abilityData;                                      // 0x00B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UPowerWidgetPresentationComponent*> _powerWidgetPresentationComponents;                // 0x00B8(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_C8[0xC0];                                      // 0x00C8(0x00C0)(Fixing Size After Last Property [ Dumper-7 ])
	class UTimerObject*                           _cooldownTimer;                                    // 0x0188(0x0008)(ExportObject, Net, ZeroConstructor, InstancedReference, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTimerObject*                           _durationTimer;                                    // 0x0190(0x0008)(ExportObject, Net, ZeroConstructor, InstancedReference, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTimerObject*                           _tokenRechargeTimer;                               // 0x0198(0x0008)(ExportObject, Net, ZeroConstructor, InstancedReference, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         _tokenCount;                                       // 0x01A0(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1A4[0x4];                                      // 0x01A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_CooldownTimer();
	void OnRep_DurationTimer();
	void OnRep_TokenCount(const int32 OldCount);
	void OnRep_TokenRechargeTimer();

	float GetCooldown() const;
	float GetDuration() const;
	class ASlasherPlayer* GetOwningKiller() const;
	class AKillerPower* GetOwningPower() const;
	float GetRemainingCooldown() const;
	float GetRemainingCooldownPercent() const;
	bool IsApplicable() const;
	bool IsAvailable() const;
	bool IsOnCooldown() const;
	void PlayAudioOnOwningKiller(class UAkAudioEvent* AudioEvent, bool OnlyPlayIfLocallyObserved) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerAbilityComponent">();
	}
	static class UKillerAbilityComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillerAbilityComponent>();
	}
};
static_assert(alignof(UKillerAbilityComponent) == 0x000008, "Wrong alignment on UKillerAbilityComponent");
static_assert(sizeof(UKillerAbilityComponent) == 0x0001A8, "Wrong size on UKillerAbilityComponent");
static_assert(offsetof(UKillerAbilityComponent, _abilityData) == 0x0000B0, "Member 'UKillerAbilityComponent::_abilityData' has a wrong offset!");
static_assert(offsetof(UKillerAbilityComponent, _powerWidgetPresentationComponents) == 0x0000B8, "Member 'UKillerAbilityComponent::_powerWidgetPresentationComponents' has a wrong offset!");
static_assert(offsetof(UKillerAbilityComponent, _cooldownTimer) == 0x000188, "Member 'UKillerAbilityComponent::_cooldownTimer' has a wrong offset!");
static_assert(offsetof(UKillerAbilityComponent, _durationTimer) == 0x000190, "Member 'UKillerAbilityComponent::_durationTimer' has a wrong offset!");
static_assert(offsetof(UKillerAbilityComponent, _tokenRechargeTimer) == 0x000198, "Member 'UKillerAbilityComponent::_tokenRechargeTimer' has a wrong offset!");
static_assert(offsetof(UKillerAbilityComponent, _tokenCount) == 0x0001A0, "Member 'UKillerAbilityComponent::_tokenCount' has a wrong offset!");

// Class DBDGameplay.PoseableHusk
// 0x0008 (0x02F0 - 0x02E8)
class APoseableHusk : public ABaseHusk
{
public:
	uint8                                         Pad_2E8[0x8];                                      // 0x02E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CapturePose();
	void Cosmetic_OnAnimationPoseCaptured();
	void OnActiveStateChanged(bool IsActive);
	void SetIsActive(bool IsActive);

	bool GetIsActive() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PoseableHusk">();
	}
	static class APoseableHusk* GetDefaultObj()
	{
		return GetDefaultObjImpl<APoseableHusk>();
	}
};
static_assert(alignof(APoseableHusk) == 0x000008, "Wrong alignment on APoseableHusk");
static_assert(sizeof(APoseableHusk) == 0x0002F0, "Wrong size on APoseableHusk");

// Class DBDGameplay.KillerPower
// 0x00A8 (0x05F8 - 0x0550)
class AKillerPower : public ACollectable
{
public:
	uint8                                         Pad_550[0x18];                                     // 0x0550(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UInteractor*                            _interactor;                                       // 0x0568(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxPlayerOverlapComponent*             _interactionVolume;                                // 0x0570(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FKillerPowerSpawnableStatusEffectData> _survivorStatusEffects;                            // 0x0578(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FKillerPowerSpawnableStatusEffectData> _killerStatusEffects;                              // 0x0588(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FKillerPowerSpawnableComponents> _survivorComponents;                               // 0x0598(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FKillerPowerSpawnableComponents> _killerComponents;                                 // 0x05A8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UDLCCheatComponent>         _cheatComponentClass;                              // 0x05B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class ASlasherPlayer>          _owningKiller;                                     // 0x05C0(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UPowerWidgetPresentationComponent*> _powerWidgetPresentationComponents;                // 0x05C8(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_5D8[0x20];                                     // 0x05D8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_OwningKiller();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerPower">();
	}
	static class AKillerPower* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKillerPower>();
	}
};
static_assert(alignof(AKillerPower) == 0x000008, "Wrong alignment on AKillerPower");
static_assert(sizeof(AKillerPower) == 0x0005F8, "Wrong size on AKillerPower");
static_assert(offsetof(AKillerPower, _interactor) == 0x000568, "Member 'AKillerPower::_interactor' has a wrong offset!");
static_assert(offsetof(AKillerPower, _interactionVolume) == 0x000570, "Member 'AKillerPower::_interactionVolume' has a wrong offset!");
static_assert(offsetof(AKillerPower, _survivorStatusEffects) == 0x000578, "Member 'AKillerPower::_survivorStatusEffects' has a wrong offset!");
static_assert(offsetof(AKillerPower, _killerStatusEffects) == 0x000588, "Member 'AKillerPower::_killerStatusEffects' has a wrong offset!");
static_assert(offsetof(AKillerPower, _survivorComponents) == 0x000598, "Member 'AKillerPower::_survivorComponents' has a wrong offset!");
static_assert(offsetof(AKillerPower, _killerComponents) == 0x0005A8, "Member 'AKillerPower::_killerComponents' has a wrong offset!");
static_assert(offsetof(AKillerPower, _cheatComponentClass) == 0x0005B8, "Member 'AKillerPower::_cheatComponentClass' has a wrong offset!");
static_assert(offsetof(AKillerPower, _owningKiller) == 0x0005C0, "Member 'AKillerPower::_owningKiller' has a wrong offset!");
static_assert(offsetof(AKillerPower, _powerWidgetPresentationComponents) == 0x0005C8, "Member 'AKillerPower::_powerWidgetPresentationComponents' has a wrong offset!");

// Class DBDGameplay.ClosetHideInteraction
// 0x0000 (0x07B0 - 0x07B0)
class UClosetHideInteraction : public UBaseLockerInteraction
{
public:
	bool                                          _rushed;                                           // 0x07A8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7A9[0x7];                                      // 0x07A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FireSoundEventFromInteractor(class AActor* Instigator, class ADBDPlayer* InstigatingPlayer);
	void SetOtherInteractorsUsable(const bool IsEnabled);

	class UInteractor* GetInsideInteractor() const;
	class ADBDPlayer* GetPlayerInCloset() const;
	bool IsInteractingPlayerInsideCloset(const class ADBDPlayer* Player) const;
	bool IsOccupied() const;
	bool IsRushed() const;
	void SetCollisionWithCloset(const bool IsEnabled, class ADBDPlayer* Player) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClosetHideInteraction">();
	}
	static class UClosetHideInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UClosetHideInteraction>();
	}
};
static_assert(alignof(UClosetHideInteraction) == 0x000010, "Wrong alignment on UClosetHideInteraction");
static_assert(sizeof(UClosetHideInteraction) == 0x0007B0, "Wrong size on UClosetHideInteraction");
static_assert(offsetof(UClosetHideInteraction, _rushed) == 0x0007A8, "Member 'UClosetHideInteraction::_rushed' has a wrong offset!");

// Class DBDGameplay.TargetingComponent
// 0x0030 (0x00D8 - 0x00A8)
class UTargetingComponent : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UTargetableComponent*>           _targets;                                          // 0x00B0(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class UTargetingStrategy*                     _targetingStrategy;                                // 0x00C0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class ADBDActorIndicator>         _targetIndicatorClass;                             // 0x00C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ADBDActorIndicator*                     _targetIndicator;                                  // 0x00D0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TargetingComponent">();
	}
	static class UTargetingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTargetingComponent>();
	}
};
static_assert(alignof(UTargetingComponent) == 0x000008, "Wrong alignment on UTargetingComponent");
static_assert(sizeof(UTargetingComponent) == 0x0000D8, "Wrong size on UTargetingComponent");
static_assert(offsetof(UTargetingComponent, _targets) == 0x0000B0, "Member 'UTargetingComponent::_targets' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, _targetingStrategy) == 0x0000C0, "Member 'UTargetingComponent::_targetingStrategy' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, _targetIndicatorClass) == 0x0000C8, "Member 'UTargetingComponent::_targetIndicatorClass' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, _targetIndicator) == 0x0000D0, "Member 'UTargetingComponent::_targetIndicator' has a wrong offset!");

// Class DBDGameplay.IgnoreCollisionsWindowHandlerComponent
// 0x0000 (0x05F0 - 0x05F0)
class UIgnoreCollisionsWindowHandlerComponent : public UIgnoreCollisionsHandlerComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IgnoreCollisionsWindowHandlerComponent">();
	}
	static class UIgnoreCollisionsWindowHandlerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIgnoreCollisionsWindowHandlerComponent>();
	}
};
static_assert(alignof(UIgnoreCollisionsWindowHandlerComponent) == 0x000010, "Wrong alignment on UIgnoreCollisionsWindowHandlerComponent");
static_assert(sizeof(UIgnoreCollisionsWindowHandlerComponent) == 0x0005F0, "Wrong size on UIgnoreCollisionsWindowHandlerComponent");

// Class DBDGameplay.ClosetHideEnterInteraction
// 0x0020 (0x07D0 - 0x07B0)
class UClosetHideEnterInteraction : public UClosetHideInteraction
{
public:
	TSubclassOf<class UStatusEffect>              _closetBlindnessStatusEffectClass;                 // 0x07B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _ejectionFromLockerDelaySeconds;                   // 0x07B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, NoClear, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7BC[0x14];                                     // 0x07BC(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EjectSurvivorFromLocker(class ACamperPlayer* Survivor, class ALocker* Locker);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClosetHideEnterInteraction">();
	}
	static class UClosetHideEnterInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UClosetHideEnterInteraction>();
	}
};
static_assert(alignof(UClosetHideEnterInteraction) == 0x000010, "Wrong alignment on UClosetHideEnterInteraction");
static_assert(sizeof(UClosetHideEnterInteraction) == 0x0007D0, "Wrong size on UClosetHideEnterInteraction");
static_assert(offsetof(UClosetHideEnterInteraction, _closetBlindnessStatusEffectClass) == 0x0007B0, "Member 'UClosetHideEnterInteraction::_closetBlindnessStatusEffectClass' has a wrong offset!");
static_assert(offsetof(UClosetHideEnterInteraction, _ejectionFromLockerDelaySeconds) == 0x0007B8, "Member 'UClosetHideEnterInteraction::_ejectionFromLockerDelaySeconds' has a wrong offset!");

// Class DBDGameplay.PalletTrackerVisibilityComponent
// 0x0070 (0x0118 - 0x00A8)
class UPalletTrackerVisibilityComponent : public UActorComponent
{
public:
	struct FDBDTunableRowHandle                   _visibilityRange;                                  // 0x00A8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FActorPairQueryHeightRange             _visibilityHeightRange;                            // 0x00D0(0x0008)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D8[0x40];                                      // 0x00D8(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_OnPalletTrackerSelectedChanged(bool Selected);
	void Cosmetic_OnVisibilityChanged(bool IsVisible);
	void OnLocallyObservedChanged();

	class APalletTracker* GetPalletTrackerOwner() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalletTrackerVisibilityComponent">();
	}
	static class UPalletTrackerVisibilityComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalletTrackerVisibilityComponent>();
	}
};
static_assert(alignof(UPalletTrackerVisibilityComponent) == 0x000008, "Wrong alignment on UPalletTrackerVisibilityComponent");
static_assert(sizeof(UPalletTrackerVisibilityComponent) == 0x000118, "Wrong size on UPalletTrackerVisibilityComponent");
static_assert(offsetof(UPalletTrackerVisibilityComponent, _visibilityRange) == 0x0000A8, "Member 'UPalletTrackerVisibilityComponent::_visibilityRange' has a wrong offset!");
static_assert(offsetof(UPalletTrackerVisibilityComponent, _visibilityHeightRange) == 0x0000D0, "Member 'UPalletTrackerVisibilityComponent::_visibilityHeightRange' has a wrong offset!");

// Class DBDGameplay.CageHookAntiCampComponent
// 0x00E0 (0x0188 - 0x00A8)
class UCageHookAntiCampComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x48];                                      // 0x00A8(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _anticampZoneDistance;                             // 0x00F0(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _anticampZoneTimeToTrigger;                        // 0x0118(0x0028)(Edit, NativeAccessSpecifierPrivate)
	bool                                          _stopAnticampWhenSurvivorInRange;                  // 0x0140(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_141[0x47];                                     // 0x0141(0x0047)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Multicast_TriggerAntiCamp();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CageHookAntiCampComponent">();
	}
	static class UCageHookAntiCampComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCageHookAntiCampComponent>();
	}
};
static_assert(alignof(UCageHookAntiCampComponent) == 0x000008, "Wrong alignment on UCageHookAntiCampComponent");
static_assert(sizeof(UCageHookAntiCampComponent) == 0x000188, "Wrong size on UCageHookAntiCampComponent");
static_assert(offsetof(UCageHookAntiCampComponent, _anticampZoneDistance) == 0x0000F0, "Member 'UCageHookAntiCampComponent::_anticampZoneDistance' has a wrong offset!");
static_assert(offsetof(UCageHookAntiCampComponent, _anticampZoneTimeToTrigger) == 0x000118, "Member 'UCageHookAntiCampComponent::_anticampZoneTimeToTrigger' has a wrong offset!");
static_assert(offsetof(UCageHookAntiCampComponent, _stopAnticampWhenSurvivorInRange) == 0x000140, "Member 'UCageHookAntiCampComponent::_stopAnticampWhenSurvivorInRange' has a wrong offset!");

// Class DBDGameplay.LimitGeneratorRegressionEventComponent
// 0x01A8 (0x0250 - 0x00A8)
class ULimitGeneratorRegressionEventComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             Cosmetic_OnRegressionEvent;                        // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             Cosmetic_OnRegressionEventZoneEntered;             // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             Cosmetic_OnRegressionEventZoneExited;              // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             Cosmetic_OnRepairStarted;                          // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             Cosmetic_OnRepairStopped;                          // 0x00E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             Cosmetic_OnBlockingStatusChanged;                  // 0x00F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	int32                                         _regressionEventsSuffered;                         // 0x0108(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_10C[0x4];                                      // 0x010C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _numberLastRegressionEventsToShow;                 // 0x0110(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _maxNumberRegressionEventsAllowed;                 // 0x0138(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _thresholdImmediateRegressionToConsiderRegressionEvent; // 0x0160(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _immediateRegressionPercentage;                    // 0x0188(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _immediateRegressionPercentageLimitRegressionEvents; // 0x01B0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	float                                         _killerProximityZoneRadius;                        // 0x01D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FCollisionProfileName                  _killerProximityZoneDefaultCollisionProfile;       // 0x01DC(0x000C)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	struct FCollisionProfileName                  _killerProximityZoneNoCollisionProfile;            // 0x01E8(0x000C)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	float                                         _waitTimeAfterGeneratorWasInteractedUponToTriggerVfx; // 0x01F4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USphereComponent*                       _killerProximityZoneForRegressionEvents;           // 0x01F8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_200[0x50];                                     // 0x0200(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CosmeticEvent__DelegateSignature(int32 CurrentRegressionLevel);
	void OnBlockingStatusChanged__DelegateSignature(int32 CurrentRegressionLevel, bool Blocked);
	void OnKillerProximityZoneForRegressionEventsOverlapBegin(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnKillerProximityZoneForRegressionEventsOverlapEnd(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void OnRegressionEvent__DelegateSignature(int32 CurrentRegressionLevel, bool SurvivorInteracting);
	void OnRep_RegressionEventsSuffered();

	int32 GetMaxNumberRegressionEventsAllowed() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LimitGeneratorRegressionEventComponent">();
	}
	static class ULimitGeneratorRegressionEventComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULimitGeneratorRegressionEventComponent>();
	}
};
static_assert(alignof(ULimitGeneratorRegressionEventComponent) == 0x000008, "Wrong alignment on ULimitGeneratorRegressionEventComponent");
static_assert(sizeof(ULimitGeneratorRegressionEventComponent) == 0x000250, "Wrong size on ULimitGeneratorRegressionEventComponent");
static_assert(offsetof(ULimitGeneratorRegressionEventComponent, Cosmetic_OnRegressionEvent) == 0x0000A8, "Member 'ULimitGeneratorRegressionEventComponent::Cosmetic_OnRegressionEvent' has a wrong offset!");
static_assert(offsetof(ULimitGeneratorRegressionEventComponent, Cosmetic_OnRegressionEventZoneEntered) == 0x0000B8, "Member 'ULimitGeneratorRegressionEventComponent::Cosmetic_OnRegressionEventZoneEntered' has a wrong offset!");
static_assert(offsetof(ULimitGeneratorRegressionEventComponent, Cosmetic_OnRegressionEventZoneExited) == 0x0000C8, "Member 'ULimitGeneratorRegressionEventComponent::Cosmetic_OnRegressionEventZoneExited' has a wrong offset!");
static_assert(offsetof(ULimitGeneratorRegressionEventComponent, Cosmetic_OnRepairStarted) == 0x0000D8, "Member 'ULimitGeneratorRegressionEventComponent::Cosmetic_OnRepairStarted' has a wrong offset!");
static_assert(offsetof(ULimitGeneratorRegressionEventComponent, Cosmetic_OnRepairStopped) == 0x0000E8, "Member 'ULimitGeneratorRegressionEventComponent::Cosmetic_OnRepairStopped' has a wrong offset!");
static_assert(offsetof(ULimitGeneratorRegressionEventComponent, Cosmetic_OnBlockingStatusChanged) == 0x0000F8, "Member 'ULimitGeneratorRegressionEventComponent::Cosmetic_OnBlockingStatusChanged' has a wrong offset!");
static_assert(offsetof(ULimitGeneratorRegressionEventComponent, _regressionEventsSuffered) == 0x000108, "Member 'ULimitGeneratorRegressionEventComponent::_regressionEventsSuffered' has a wrong offset!");
static_assert(offsetof(ULimitGeneratorRegressionEventComponent, _numberLastRegressionEventsToShow) == 0x000110, "Member 'ULimitGeneratorRegressionEventComponent::_numberLastRegressionEventsToShow' has a wrong offset!");
static_assert(offsetof(ULimitGeneratorRegressionEventComponent, _maxNumberRegressionEventsAllowed) == 0x000138, "Member 'ULimitGeneratorRegressionEventComponent::_maxNumberRegressionEventsAllowed' has a wrong offset!");
static_assert(offsetof(ULimitGeneratorRegressionEventComponent, _thresholdImmediateRegressionToConsiderRegressionEvent) == 0x000160, "Member 'ULimitGeneratorRegressionEventComponent::_thresholdImmediateRegressionToConsiderRegressionEvent' has a wrong offset!");
static_assert(offsetof(ULimitGeneratorRegressionEventComponent, _immediateRegressionPercentage) == 0x000188, "Member 'ULimitGeneratorRegressionEventComponent::_immediateRegressionPercentage' has a wrong offset!");
static_assert(offsetof(ULimitGeneratorRegressionEventComponent, _immediateRegressionPercentageLimitRegressionEvents) == 0x0001B0, "Member 'ULimitGeneratorRegressionEventComponent::_immediateRegressionPercentageLimitRegressionEvents' has a wrong offset!");
static_assert(offsetof(ULimitGeneratorRegressionEventComponent, _killerProximityZoneRadius) == 0x0001D8, "Member 'ULimitGeneratorRegressionEventComponent::_killerProximityZoneRadius' has a wrong offset!");
static_assert(offsetof(ULimitGeneratorRegressionEventComponent, _killerProximityZoneDefaultCollisionProfile) == 0x0001DC, "Member 'ULimitGeneratorRegressionEventComponent::_killerProximityZoneDefaultCollisionProfile' has a wrong offset!");
static_assert(offsetof(ULimitGeneratorRegressionEventComponent, _killerProximityZoneNoCollisionProfile) == 0x0001E8, "Member 'ULimitGeneratorRegressionEventComponent::_killerProximityZoneNoCollisionProfile' has a wrong offset!");
static_assert(offsetof(ULimitGeneratorRegressionEventComponent, _waitTimeAfterGeneratorWasInteractedUponToTriggerVfx) == 0x0001F4, "Member 'ULimitGeneratorRegressionEventComponent::_waitTimeAfterGeneratorWasInteractedUponToTriggerVfx' has a wrong offset!");
static_assert(offsetof(ULimitGeneratorRegressionEventComponent, _killerProximityZoneForRegressionEvents) == 0x0001F8, "Member 'ULimitGeneratorRegressionEventComponent::_killerProximityZoneForRegressionEvents' has a wrong offset!");

// Class DBDGameplay.RangedExplosive
// 0x0070 (0x0418 - 0x03A8)
class ARangedExplosive : public AInteractable
{
public:
	uint8                                         Pad_3A8[0x18];                                     // 0x03A8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _debugDisplayEnabled;                              // 0x03C0(0x0001)(Edit, ZeroConstructor, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C1[0x7];                                      // 0x03C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USphereComponent*                       _effectArea;                                       // 0x03C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkComponent*                           _akComponent;                                      // 0x03D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   _mesh;                                             // 0x03D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UGameplayModifierContainer*>     _effectModifiers;                                  // 0x03E0(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class ADBDPlayer*                             _owningPlayer;                                     // 0x03F0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isExploding;                                      // 0x03F8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3F9[0x7];                                      // 0x03F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         _actorsInRange;                                    // 0x0400(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class UBaseRangedExplosiveActorEffect*        _explosiveActorEffect;                             // 0x0410(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Multicast_InitFromSpawningPlayer(class ADBDPlayer* Spawner);
	void OnExplode_BP();
	void OnFuseBurnEnter();
	void OnFuseBurnExit();
	void OnFuseBurnUpdate(float DeltaSeconds, float FuseTimeLeftPercent);

	float GetExplosionEffectDuration() const;
	float GetExplosionRange() const;
	float GetModifierValue(const struct FGameplayTag& Type) const;
	class ADBDPlayer* GetOwningPlayer() const;
	class UBaseRangedExplosiveActorEffect* GetRangedExplosiveActorEffect() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RangedExplosive">();
	}
	static class ARangedExplosive* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARangedExplosive>();
	}
};
static_assert(alignof(ARangedExplosive) == 0x000008, "Wrong alignment on ARangedExplosive");
static_assert(sizeof(ARangedExplosive) == 0x000418, "Wrong size on ARangedExplosive");
static_assert(offsetof(ARangedExplosive, _debugDisplayEnabled) == 0x0003C0, "Member 'ARangedExplosive::_debugDisplayEnabled' has a wrong offset!");
static_assert(offsetof(ARangedExplosive, _effectArea) == 0x0003C8, "Member 'ARangedExplosive::_effectArea' has a wrong offset!");
static_assert(offsetof(ARangedExplosive, _akComponent) == 0x0003D0, "Member 'ARangedExplosive::_akComponent' has a wrong offset!");
static_assert(offsetof(ARangedExplosive, _mesh) == 0x0003D8, "Member 'ARangedExplosive::_mesh' has a wrong offset!");
static_assert(offsetof(ARangedExplosive, _effectModifiers) == 0x0003E0, "Member 'ARangedExplosive::_effectModifiers' has a wrong offset!");
static_assert(offsetof(ARangedExplosive, _owningPlayer) == 0x0003F0, "Member 'ARangedExplosive::_owningPlayer' has a wrong offset!");
static_assert(offsetof(ARangedExplosive, _isExploding) == 0x0003F8, "Member 'ARangedExplosive::_isExploding' has a wrong offset!");
static_assert(offsetof(ARangedExplosive, _actorsInRange) == 0x000400, "Member 'ARangedExplosive::_actorsInRange' has a wrong offset!");
static_assert(offsetof(ARangedExplosive, _explosiveActorEffect) == 0x000410, "Member 'ARangedExplosive::_explosiveActorEffect' has a wrong offset!");

// Class DBDGameplay.AimPointProcessor
// 0x0000 (0x00A8 - 0x00A8)
class UAimPointProcessor : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AimPointProcessor">();
	}
	static class UAimPointProcessor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAimPointProcessor>();
	}
};
static_assert(alignof(UAimPointProcessor) == 0x000008, "Wrong alignment on UAimPointProcessor");
static_assert(sizeof(UAimPointProcessor) == 0x0000A8, "Wrong size on UAimPointProcessor");

// Class DBDGameplay.AimPointPerlinNoise
// 0x0038 (0x00E0 - 0x00A8)
class UAimPointPerlinNoise final : public UAimPointProcessor
{
public:
	uint8                                         Pad_A8[0x4];                                       // 0x00A8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _baseInaccuracyNoisePersistence;                   // 0x00AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         _baseInaccuracyNoiseOctaveCount;                   // 0x00B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _baseInaccuracyNoiseAmplitude;                     // 0x00B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B8[0x4];                                       // 0x00B8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _baseInaccuracyNoiseFrequency;                     // 0x00BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C0[0x4];                                       // 0x00C0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _timeOffset;                                       // 0x00C4(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C8[0x18];                                      // 0x00C8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetBaseInaccuracyNoiseAmplitude(const float Amplitude);
	void SetBaseInaccuracyNoiseFrequency(const float Frequency);
	void SetBaseInaccuracyNoiseOctaveCount(const int32 OctaveCount);
	void SetBaseInaccuracyNoisePersistence(const float NoisePersistence);
	void SetNoiseAmplitudeMultiplier(const float Multiplier);
	void SetNoiseFrequencyMultiplier(const float Multiplier);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AimPointPerlinNoise">();
	}
	static class UAimPointPerlinNoise* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAimPointPerlinNoise>();
	}
};
static_assert(alignof(UAimPointPerlinNoise) == 0x000008, "Wrong alignment on UAimPointPerlinNoise");
static_assert(sizeof(UAimPointPerlinNoise) == 0x0000E0, "Wrong size on UAimPointPerlinNoise");
static_assert(offsetof(UAimPointPerlinNoise, _baseInaccuracyNoisePersistence) == 0x0000AC, "Member 'UAimPointPerlinNoise::_baseInaccuracyNoisePersistence' has a wrong offset!");
static_assert(offsetof(UAimPointPerlinNoise, _baseInaccuracyNoiseOctaveCount) == 0x0000B0, "Member 'UAimPointPerlinNoise::_baseInaccuracyNoiseOctaveCount' has a wrong offset!");
static_assert(offsetof(UAimPointPerlinNoise, _baseInaccuracyNoiseAmplitude) == 0x0000B4, "Member 'UAimPointPerlinNoise::_baseInaccuracyNoiseAmplitude' has a wrong offset!");
static_assert(offsetof(UAimPointPerlinNoise, _baseInaccuracyNoiseFrequency) == 0x0000BC, "Member 'UAimPointPerlinNoise::_baseInaccuracyNoiseFrequency' has a wrong offset!");
static_assert(offsetof(UAimPointPerlinNoise, _timeOffset) == 0x0000C4, "Member 'UAimPointPerlinNoise::_timeOffset' has a wrong offset!");

// Class DBDGameplay.KillerAbilityData
// 0x0028 (0x0060 - 0x0038)
class UKillerAbilityData : public UDataAsset
{
public:
	float                                         _cooldown;                                         // 0x0038(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _duration;                                         // 0x003C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isTokenBased;                                     // 0x0040(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _maxTokenCount;                                    // 0x0044(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _timeRequiredToChargeToken;                        // 0x0048(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _availabilityRequiresAToken;                       // 0x004C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          _onCooldownCompletedAkEvent;                       // 0x0050(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkAudioEvent*                          _onTokenAddedAkEvent;                              // 0x0058(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	float GetCooldown() const;
	float GetDuration() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerAbilityData">();
	}
	static class UKillerAbilityData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillerAbilityData>();
	}
};
static_assert(alignof(UKillerAbilityData) == 0x000008, "Wrong alignment on UKillerAbilityData");
static_assert(sizeof(UKillerAbilityData) == 0x000060, "Wrong size on UKillerAbilityData");
static_assert(offsetof(UKillerAbilityData, _cooldown) == 0x000038, "Member 'UKillerAbilityData::_cooldown' has a wrong offset!");
static_assert(offsetof(UKillerAbilityData, _duration) == 0x00003C, "Member 'UKillerAbilityData::_duration' has a wrong offset!");
static_assert(offsetof(UKillerAbilityData, _isTokenBased) == 0x000040, "Member 'UKillerAbilityData::_isTokenBased' has a wrong offset!");
static_assert(offsetof(UKillerAbilityData, _maxTokenCount) == 0x000044, "Member 'UKillerAbilityData::_maxTokenCount' has a wrong offset!");
static_assert(offsetof(UKillerAbilityData, _timeRequiredToChargeToken) == 0x000048, "Member 'UKillerAbilityData::_timeRequiredToChargeToken' has a wrong offset!");
static_assert(offsetof(UKillerAbilityData, _availabilityRequiresAToken) == 0x00004C, "Member 'UKillerAbilityData::_availabilityRequiresAToken' has a wrong offset!");
static_assert(offsetof(UKillerAbilityData, _onCooldownCompletedAkEvent) == 0x000050, "Member 'UKillerAbilityData::_onCooldownCompletedAkEvent' has a wrong offset!");
static_assert(offsetof(UKillerAbilityData, _onTokenAddedAkEvent) == 0x000058, "Member 'UKillerAbilityData::_onTokenAddedAkEvent' has a wrong offset!");

// Class DBDGameplay.KillerForm
// 0x0090 (0x00C8 - 0x0038)
class UKillerForm : public UDataAsset
{
public:
	struct FGameplayTag                           _formID;                                           // 0x0038(0x000C)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   _formName;                                         // 0x0048(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _formStatusEffectClass;                            // 0x0060(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _formMaxWalkSpeed;                                 // 0x0068(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPlayerPerspectiveChangeTargetData     _perspectiveChangeTargetData;                      // 0x0070(0x0020)(Edit, DisableEditOnInstance, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FVector                                _cameraTargetOffset;                               // 0x0090(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _postFormSwitchStatusEffectDuration;               // 0x00A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            _postFormSwitchSpeedCurve;                         // 0x00B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   _animTag;                                          // 0x00B8(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C4[0x4];                                       // 0x00C4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerForm">();
	}
	static class UKillerForm* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillerForm>();
	}
};
static_assert(alignof(UKillerForm) == 0x000008, "Wrong alignment on UKillerForm");
static_assert(sizeof(UKillerForm) == 0x0000C8, "Wrong size on UKillerForm");
static_assert(offsetof(UKillerForm, _formID) == 0x000038, "Member 'UKillerForm::_formID' has a wrong offset!");
static_assert(offsetof(UKillerForm, _formName) == 0x000048, "Member 'UKillerForm::_formName' has a wrong offset!");
static_assert(offsetof(UKillerForm, _formStatusEffectClass) == 0x000060, "Member 'UKillerForm::_formStatusEffectClass' has a wrong offset!");
static_assert(offsetof(UKillerForm, _formMaxWalkSpeed) == 0x000068, "Member 'UKillerForm::_formMaxWalkSpeed' has a wrong offset!");
static_assert(offsetof(UKillerForm, _perspectiveChangeTargetData) == 0x000070, "Member 'UKillerForm::_perspectiveChangeTargetData' has a wrong offset!");
static_assert(offsetof(UKillerForm, _cameraTargetOffset) == 0x000090, "Member 'UKillerForm::_cameraTargetOffset' has a wrong offset!");
static_assert(offsetof(UKillerForm, _postFormSwitchStatusEffectDuration) == 0x0000A8, "Member 'UKillerForm::_postFormSwitchStatusEffectDuration' has a wrong offset!");
static_assert(offsetof(UKillerForm, _postFormSwitchSpeedCurve) == 0x0000B0, "Member 'UKillerForm::_postFormSwitchSpeedCurve' has a wrong offset!");
static_assert(offsetof(UKillerForm, _animTag) == 0x0000B8, "Member 'UKillerForm::_animTag' has a wrong offset!");

// Class DBDGameplay.KillerFormSwitchingAbility
// 0x0110 (0x02B8 - 0x01A8)
class UKillerFormSwitchingAbility : public UKillerAbilityComponent
{
public:
	uint8                                         Pad_1A8[0x20];                                     // 0x01A8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           _currentFormID;                                    // 0x01C8(0x000C)(Net, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1D4[0x4];                                      // 0x01D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UKillerForm*>                    _forms;                                            // 0x01D8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UKillerForm*                            _currentForm;                                      // 0x01E8(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _startingFormID;                                   // 0x01F0(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1FC[0x4];                                      // 0x01FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UKillerFormSwitchingInteraction> _formSwitchingInteractionClass;                    // 0x0200(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UKillerFormSwitchingInteraction*        _formSwitchingInteraction;                         // 0x0208(0x0008)(ExportObject, Net, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UKillerFormSwitchingTransitionInteraction> _formSwitchingPreviousTransitionInteractionClass;  // 0x0210(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UKillerFormSwitchingTransitionInteraction* _formSwitchingPreviousTransitionInteraction;       // 0x0218(0x0008)(ExportObject, Net, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UKillerFormSwitchingTransitionInteraction> _formSwitchingNextTransitionInteractionClass;      // 0x0220(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UKillerFormSwitchingTransitionInteraction* _formSwitchingNextTransitionInteraction;           // 0x0228(0x0008)(ExportObject, Net, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UPlayerPerspectiveChangeComponent> _perspectiveChangeComponentClass;                  // 0x0230(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPlayerPerspectiveChangeComponent*      _perspectiveChangeComponent;                       // 0x0238(0x0008)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UDBDSpringArmComponent>     _springArmClass;                                   // 0x0240(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDBDSpringArmComponent*                 _springArm;                                        // 0x0248(0x0008)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_250[0x60];                                     // 0x0250(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _transitionDuration;                               // 0x02B0(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _baseTransitionDuration;                           // 0x02B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void Cosmetic_OnCurrentFormChanged(bool IsStartingForm);
	void Cosmetic_OnEnterForm(const struct FGameplayTag& FormID, bool IsStartingForm);
	void Cosmetic_OnExitForm(const struct FGameplayTag& FormID);
	float GetTransitionDuration();
	void OnRep_CurrentFormID(const struct FGameplayTag& OldFormId);

	struct FGameplayTag GetCurrentFormID() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerFormSwitchingAbility">();
	}
	static class UKillerFormSwitchingAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillerFormSwitchingAbility>();
	}
};
static_assert(alignof(UKillerFormSwitchingAbility) == 0x000008, "Wrong alignment on UKillerFormSwitchingAbility");
static_assert(sizeof(UKillerFormSwitchingAbility) == 0x0002B8, "Wrong size on UKillerFormSwitchingAbility");
static_assert(offsetof(UKillerFormSwitchingAbility, _currentFormID) == 0x0001C8, "Member 'UKillerFormSwitchingAbility::_currentFormID' has a wrong offset!");
static_assert(offsetof(UKillerFormSwitchingAbility, _forms) == 0x0001D8, "Member 'UKillerFormSwitchingAbility::_forms' has a wrong offset!");
static_assert(offsetof(UKillerFormSwitchingAbility, _currentForm) == 0x0001E8, "Member 'UKillerFormSwitchingAbility::_currentForm' has a wrong offset!");
static_assert(offsetof(UKillerFormSwitchingAbility, _startingFormID) == 0x0001F0, "Member 'UKillerFormSwitchingAbility::_startingFormID' has a wrong offset!");
static_assert(offsetof(UKillerFormSwitchingAbility, _formSwitchingInteractionClass) == 0x000200, "Member 'UKillerFormSwitchingAbility::_formSwitchingInteractionClass' has a wrong offset!");
static_assert(offsetof(UKillerFormSwitchingAbility, _formSwitchingInteraction) == 0x000208, "Member 'UKillerFormSwitchingAbility::_formSwitchingInteraction' has a wrong offset!");
static_assert(offsetof(UKillerFormSwitchingAbility, _formSwitchingPreviousTransitionInteractionClass) == 0x000210, "Member 'UKillerFormSwitchingAbility::_formSwitchingPreviousTransitionInteractionClass' has a wrong offset!");
static_assert(offsetof(UKillerFormSwitchingAbility, _formSwitchingPreviousTransitionInteraction) == 0x000218, "Member 'UKillerFormSwitchingAbility::_formSwitchingPreviousTransitionInteraction' has a wrong offset!");
static_assert(offsetof(UKillerFormSwitchingAbility, _formSwitchingNextTransitionInteractionClass) == 0x000220, "Member 'UKillerFormSwitchingAbility::_formSwitchingNextTransitionInteractionClass' has a wrong offset!");
static_assert(offsetof(UKillerFormSwitchingAbility, _formSwitchingNextTransitionInteraction) == 0x000228, "Member 'UKillerFormSwitchingAbility::_formSwitchingNextTransitionInteraction' has a wrong offset!");
static_assert(offsetof(UKillerFormSwitchingAbility, _perspectiveChangeComponentClass) == 0x000230, "Member 'UKillerFormSwitchingAbility::_perspectiveChangeComponentClass' has a wrong offset!");
static_assert(offsetof(UKillerFormSwitchingAbility, _perspectiveChangeComponent) == 0x000238, "Member 'UKillerFormSwitchingAbility::_perspectiveChangeComponent' has a wrong offset!");
static_assert(offsetof(UKillerFormSwitchingAbility, _springArmClass) == 0x000240, "Member 'UKillerFormSwitchingAbility::_springArmClass' has a wrong offset!");
static_assert(offsetof(UKillerFormSwitchingAbility, _springArm) == 0x000248, "Member 'UKillerFormSwitchingAbility::_springArm' has a wrong offset!");
static_assert(offsetof(UKillerFormSwitchingAbility, _transitionDuration) == 0x0002B0, "Member 'UKillerFormSwitchingAbility::_transitionDuration' has a wrong offset!");
static_assert(offsetof(UKillerFormSwitchingAbility, _baseTransitionDuration) == 0x0002B4, "Member 'UKillerFormSwitchingAbility::_baseTransitionDuration' has a wrong offset!");

// Class DBDGameplay.TargetingStrategy
// 0x0000 (0x0030 - 0x0030)
class UTargetingStrategy : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TargetingStrategy">();
	}
	static class UTargetingStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTargetingStrategy>();
	}
};
static_assert(alignof(UTargetingStrategy) == 0x000008, "Wrong alignment on UTargetingStrategy");
static_assert(sizeof(UTargetingStrategy) == 0x000030, "Wrong size on UTargetingStrategy");

// Class DBDGameplay.CameraCenterTargetingStrategy
// 0x0008 (0x0038 - 0x0030)
class UCameraCenterTargetingStrategy final : public UTargetingStrategy
{
public:
	float                                         _cameraDegreesToleranceFromCenterScreen;           // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraCenterTargetingStrategy">();
	}
	static class UCameraCenterTargetingStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCameraCenterTargetingStrategy>();
	}
};
static_assert(alignof(UCameraCenterTargetingStrategy) == 0x000008, "Wrong alignment on UCameraCenterTargetingStrategy");
static_assert(sizeof(UCameraCenterTargetingStrategy) == 0x000038, "Wrong size on UCameraCenterTargetingStrategy");
static_assert(offsetof(UCameraCenterTargetingStrategy, _cameraDegreesToleranceFromCenterScreen) == 0x000030, "Member 'UCameraCenterTargetingStrategy::_cameraDegreesToleranceFromCenterScreen' has a wrong offset!");

// Class DBDGameplay.KillerFormSwitchingInteraction
// 0x0000 (0x0780 - 0x0780)
class UKillerFormSwitchingInteraction : public UInteractionDefinition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerFormSwitchingInteraction">();
	}
	static class UKillerFormSwitchingInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillerFormSwitchingInteraction>();
	}
};
static_assert(alignof(UKillerFormSwitchingInteraction) == 0x000010, "Wrong alignment on UKillerFormSwitchingInteraction");
static_assert(sizeof(UKillerFormSwitchingInteraction) == 0x000780, "Wrong size on UKillerFormSwitchingInteraction");

// Class DBDGameplay.TargetableStrategy
// 0x0008 (0x0038 - 0x0030)
class UTargetableStrategy : public UObject
{
public:
	float                                         _minTargetableDistance;                            // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _maxTargetableDistance;                            // 0x0034(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TargetableStrategy">();
	}
	static class UTargetableStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTargetableStrategy>();
	}
};
static_assert(alignof(UTargetableStrategy) == 0x000008, "Wrong alignment on UTargetableStrategy");
static_assert(sizeof(UTargetableStrategy) == 0x000038, "Wrong size on UTargetableStrategy");
static_assert(offsetof(UTargetableStrategy, _minTargetableDistance) == 0x000030, "Member 'UTargetableStrategy::_minTargetableDistance' has a wrong offset!");
static_assert(offsetof(UTargetableStrategy, _maxTargetableDistance) == 0x000034, "Member 'UTargetableStrategy::_maxTargetableDistance' has a wrong offset!");

// Class DBDGameplay.AimableComponent
// 0x0070 (0x0118 - 0x00A8)
class UAimableComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         _occlusionIgnoredActors;                           // 0x00B0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	float                                         _maxAimDistance;                                   // 0x00C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C4[0x4];                                       // 0x00C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAimDirectionProvider*                  _aimDirectionProvider;                             // 0x00C8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _useOcclusion;                                     // 0x00D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D1[0x3];                                       // 0x00D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _aimPointLerpFactor;                               // 0x00D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UAimPointProcessor*>             _preOcclusionAimPointProcessors;                   // 0x00D8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_E8[0x30];                                      // 0x00E8(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetMaxAimDistance(float MaxAimDistance);
	void SetOcclusionIgnoredActors(const TArray<class AActor*>& IgnoredActors);
	void SetProcessors(const TArray<class UAimPointProcessor*>& Processors);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AimableComponent">();
	}
	static class UAimableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAimableComponent>();
	}
};
static_assert(alignof(UAimableComponent) == 0x000008, "Wrong alignment on UAimableComponent");
static_assert(sizeof(UAimableComponent) == 0x000118, "Wrong size on UAimableComponent");
static_assert(offsetof(UAimableComponent, _occlusionIgnoredActors) == 0x0000B0, "Member 'UAimableComponent::_occlusionIgnoredActors' has a wrong offset!");
static_assert(offsetof(UAimableComponent, _maxAimDistance) == 0x0000C0, "Member 'UAimableComponent::_maxAimDistance' has a wrong offset!");
static_assert(offsetof(UAimableComponent, _aimDirectionProvider) == 0x0000C8, "Member 'UAimableComponent::_aimDirectionProvider' has a wrong offset!");
static_assert(offsetof(UAimableComponent, _useOcclusion) == 0x0000D0, "Member 'UAimableComponent::_useOcclusion' has a wrong offset!");
static_assert(offsetof(UAimableComponent, _aimPointLerpFactor) == 0x0000D4, "Member 'UAimableComponent::_aimPointLerpFactor' has a wrong offset!");
static_assert(offsetof(UAimableComponent, _preOcclusionAimPointProcessors) == 0x0000D8, "Member 'UAimableComponent::_preOcclusionAimPointProcessors' has a wrong offset!");

// Class DBDGameplay.TerrorRadiusEmitterComponent
// 0x00F0 (0x03B0 - 0x02C0)
class UTerrorRadiusEmitterComponent : public USceneComponent
{
public:
	uint8                                         Pad_2C0[0x30];                                     // 0x02C0(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _simulatedFixedDistance;                           // 0x02F0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _imitatesAudioOnly;                                // 0x02F4(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _active;                                           // 0x02F5(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isFakeTerrorRadius;                               // 0x02F6(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2F7[0x1];                                      // 0x02F7(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _radius;                                           // 0x02F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2FC[0x4];                                      // 0x02FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<TWeakObjectPtr<class UTerrorRadiusReceiverComponent>, bool> _receiversInTerrorRadiusMap;                       // 0x0300(0x0050)(Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TMap<TWeakObjectPtr<class UTerrorRadiusReceiverComponent>, bool> _receiversPhysicallyInRadiusRangeMap;              // 0x0350(0x0050)(Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3A0[0x10];                                     // 0x03A0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetEmitterActive(bool Active);
	void SetImitatesAudioOnly(bool ImitatesAudioOnly);
	void SetIsFakeTerrorRadius(bool Value);
	void SetSimulatedFixedDistance(float Distance);
	void SetTerrorRadius(float Radius);

	bool GetImitatesAudioOnly() const;
	bool GetIsActive() const;
	float GetRadius() const;
	float GetSimulatedFixedDistance() const;
	bool IsInTerrorRadius(class UTerrorRadiusReceiverComponent* Receiver) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TerrorRadiusEmitterComponent">();
	}
	static class UTerrorRadiusEmitterComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTerrorRadiusEmitterComponent>();
	}
};
static_assert(alignof(UTerrorRadiusEmitterComponent) == 0x000010, "Wrong alignment on UTerrorRadiusEmitterComponent");
static_assert(sizeof(UTerrorRadiusEmitterComponent) == 0x0003B0, "Wrong size on UTerrorRadiusEmitterComponent");
static_assert(offsetof(UTerrorRadiusEmitterComponent, _simulatedFixedDistance) == 0x0002F0, "Member 'UTerrorRadiusEmitterComponent::_simulatedFixedDistance' has a wrong offset!");
static_assert(offsetof(UTerrorRadiusEmitterComponent, _imitatesAudioOnly) == 0x0002F4, "Member 'UTerrorRadiusEmitterComponent::_imitatesAudioOnly' has a wrong offset!");
static_assert(offsetof(UTerrorRadiusEmitterComponent, _active) == 0x0002F5, "Member 'UTerrorRadiusEmitterComponent::_active' has a wrong offset!");
static_assert(offsetof(UTerrorRadiusEmitterComponent, _isFakeTerrorRadius) == 0x0002F6, "Member 'UTerrorRadiusEmitterComponent::_isFakeTerrorRadius' has a wrong offset!");
static_assert(offsetof(UTerrorRadiusEmitterComponent, _radius) == 0x0002F8, "Member 'UTerrorRadiusEmitterComponent::_radius' has a wrong offset!");
static_assert(offsetof(UTerrorRadiusEmitterComponent, _receiversInTerrorRadiusMap) == 0x000300, "Member 'UTerrorRadiusEmitterComponent::_receiversInTerrorRadiusMap' has a wrong offset!");
static_assert(offsetof(UTerrorRadiusEmitterComponent, _receiversPhysicallyInRadiusRangeMap) == 0x000350, "Member 'UTerrorRadiusEmitterComponent::_receiversPhysicallyInRadiusRangeMap' has a wrong offset!");

// Class DBDGameplay.SlasherTerrorRadiusEmitterComponent
// 0x0090 (0x0440 - 0x03B0)
class USlasherTerrorRadiusEmitterComponent final : public UTerrorRadiusEmitterComponent
{
public:
	uint8                                         Pad_3B0[0x90];                                     // 0x03B0(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetBaseTerrorRadius(float baseTerrorRadius, const bool Progressive);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SlasherTerrorRadiusEmitterComponent">();
	}
	static class USlasherTerrorRadiusEmitterComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USlasherTerrorRadiusEmitterComponent>();
	}
};
static_assert(alignof(USlasherTerrorRadiusEmitterComponent) == 0x000010, "Wrong alignment on USlasherTerrorRadiusEmitterComponent");
static_assert(sizeof(USlasherTerrorRadiusEmitterComponent) == 0x000440, "Wrong size on USlasherTerrorRadiusEmitterComponent");

// Class DBDGameplay.AimDirectionProvider
// 0x0000 (0x0030 - 0x0030)
class UAimDirectionProvider : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AimDirectionProvider">();
	}
	static class UAimDirectionProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAimDirectionProvider>();
	}
};
static_assert(alignof(UAimDirectionProvider) == 0x000008, "Wrong alignment on UAimDirectionProvider");
static_assert(sizeof(UAimDirectionProvider) == 0x000030, "Wrong size on UAimDirectionProvider");

// Class DBDGameplay.FootstepsUtilities
// 0x0000 (0x0030 - 0x0030)
class UFootstepsUtilities final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FootstepsUtilities">();
	}
	static class UFootstepsUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFootstepsUtilities>();
	}
};
static_assert(alignof(UFootstepsUtilities) == 0x000008, "Wrong alignment on UFootstepsUtilities");
static_assert(sizeof(UFootstepsUtilities) == 0x000030, "Wrong size on UFootstepsUtilities");

// Class DBDGameplay.AISenseConfig_Terror
// 0x0068 (0x00B8 - 0x0050)
class UAISenseConfig_Terror final : public UAISenseConfig
{
public:
	TSubclassOf<class UAISense_Terror>            Implementation;                                    // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoClear, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxBreathingSoundRange;                            // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EAITerrorLevel, float>                   TerrorRanges;                                      // 0x0060(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAISenseAffiliationFilter              DetectionByAffiliation;                            // 0x00B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_B4[0x4];                                       // 0x00B4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISenseConfig_Terror">();
	}
	static class UAISenseConfig_Terror* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISenseConfig_Terror>();
	}
};
static_assert(alignof(UAISenseConfig_Terror) == 0x000008, "Wrong alignment on UAISenseConfig_Terror");
static_assert(sizeof(UAISenseConfig_Terror) == 0x0000B8, "Wrong size on UAISenseConfig_Terror");
static_assert(offsetof(UAISenseConfig_Terror, Implementation) == 0x000050, "Member 'UAISenseConfig_Terror::Implementation' has a wrong offset!");
static_assert(offsetof(UAISenseConfig_Terror, MaxBreathingSoundRange) == 0x000058, "Member 'UAISenseConfig_Terror::MaxBreathingSoundRange' has a wrong offset!");
static_assert(offsetof(UAISenseConfig_Terror, TerrorRanges) == 0x000060, "Member 'UAISenseConfig_Terror::TerrorRanges' has a wrong offset!");
static_assert(offsetof(UAISenseConfig_Terror, DetectionByAffiliation) == 0x0000B0, "Member 'UAISenseConfig_Terror::DetectionByAffiliation' has a wrong offset!");

// Class DBDGameplay.FirecrackerSpawner
// 0x0010 (0x05A8 - 0x0598)
class AFirecrackerSpawner : public ABaseCamperCollectable
{
public:
	TSubclassOf<class AActor>                     _firecrackerClass;                                 // 0x0598(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _possibleThrowHeight;                              // 0x05A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5A4[0x4];                                      // 0x05A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FirecrackerSpawner">();
	}
	static class AFirecrackerSpawner* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFirecrackerSpawner>();
	}
};
static_assert(alignof(AFirecrackerSpawner) == 0x000008, "Wrong alignment on AFirecrackerSpawner");
static_assert(sizeof(AFirecrackerSpawner) == 0x0005A8, "Wrong size on AFirecrackerSpawner");
static_assert(offsetof(AFirecrackerSpawner, _firecrackerClass) == 0x000598, "Member 'AFirecrackerSpawner::_firecrackerClass' has a wrong offset!");
static_assert(offsetof(AFirecrackerSpawner, _possibleThrowHeight) == 0x0005A0, "Member 'AFirecrackerSpawner::_possibleThrowHeight' has a wrong offset!");

// Class DBDGameplay.AISenseEvent_Terror
// 0x0030 (0x0060 - 0x0030)
class UAISenseEvent_Terror final : public UAISenseEvent
{
public:
	struct FAITerrorEvent                         Event;                                             // 0x0030(0x0030)(Edit, BlueprintVisible, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISenseEvent_Terror">();
	}
	static class UAISenseEvent_Terror* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISenseEvent_Terror>();
	}
};
static_assert(alignof(UAISenseEvent_Terror) == 0x000008, "Wrong alignment on UAISenseEvent_Terror");
static_assert(sizeof(UAISenseEvent_Terror) == 0x000060, "Wrong size on UAISenseEvent_Terror");
static_assert(offsetof(UAISenseEvent_Terror, Event) == 0x000030, "Member 'UAISenseEvent_Terror::Event' has a wrong offset!");

// Class DBDGameplay.SurvivorAimStanceCameraDirectionProvider
// 0x0000 (0x0030 - 0x0030)
class USurvivorAimStanceCameraDirectionProvider final : public UAimDirectionProvider
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SurvivorAimStanceCameraDirectionProvider">();
	}
	static class USurvivorAimStanceCameraDirectionProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<USurvivorAimStanceCameraDirectionProvider>();
	}
};
static_assert(alignof(USurvivorAimStanceCameraDirectionProvider) == 0x000008, "Wrong alignment on USurvivorAimStanceCameraDirectionProvider");
static_assert(sizeof(USurvivorAimStanceCameraDirectionProvider) == 0x000030, "Wrong size on USurvivorAimStanceCameraDirectionProvider");

// Class DBDGameplay.AISense_Terror
// 0x0060 (0x00F0 - 0x0090)
class UAISense_Terror final : public UAISense
{
public:
	TArray<struct FAITerrorEvent>                 _events;                                           // 0x0090(0x0010)(ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_A0[0x50];                                      // 0x00A0(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void ReportTerrorEvent(class UObject* WorldContextObj, const struct FVector& Location, class AActor* Instigator, class UTerrorRadiusEmitterComponent* TerrorEmitter);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISense_Terror">();
	}
	static class UAISense_Terror* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISense_Terror>();
	}
};
static_assert(alignof(UAISense_Terror) == 0x000008, "Wrong alignment on UAISense_Terror");
static_assert(sizeof(UAISense_Terror) == 0x0000F0, "Wrong size on UAISense_Terror");
static_assert(offsetof(UAISense_Terror, _events) == 0x000090, "Member 'UAISense_Terror::_events' has a wrong offset!");

// Class DBDGameplay.BlockFeedbackBase
// 0x0008 (0x02A8 - 0x02A0)
class ABlockFeedbackBase : public AActor
{
public:
	uint8                                         Pad_2A0[0x8];                                      // 0x02A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlockFeedbackBase">();
	}
	static class ABlockFeedbackBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABlockFeedbackBase>();
	}
};
static_assert(alignof(ABlockFeedbackBase) == 0x000008, "Wrong alignment on ABlockFeedbackBase");
static_assert(sizeof(ABlockFeedbackBase) == 0x0002A8, "Wrong size on ABlockFeedbackBase");

// Class DBDGameplay.AudioBlockFeedback
// 0x0018 (0x02C0 - 0x02A8)
class AAudioBlockFeedback : public ABlockFeedbackBase
{
public:
	class UAkAudioEvent*                          _akAudioEventBlockStart;                           // 0x02A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          _akAudioEventBlockStop;                            // 0x02B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkComponent*                           _blockableAudioComponent;                          // 0x02B8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AudioBlockFeedback">();
	}
	static class AAudioBlockFeedback* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAudioBlockFeedback>();
	}
};
static_assert(alignof(AAudioBlockFeedback) == 0x000008, "Wrong alignment on AAudioBlockFeedback");
static_assert(sizeof(AAudioBlockFeedback) == 0x0002C0, "Wrong size on AAudioBlockFeedback");
static_assert(offsetof(AAudioBlockFeedback, _akAudioEventBlockStart) == 0x0002A8, "Member 'AAudioBlockFeedback::_akAudioEventBlockStart' has a wrong offset!");
static_assert(offsetof(AAudioBlockFeedback, _akAudioEventBlockStop) == 0x0002B0, "Member 'AAudioBlockFeedback::_akAudioEventBlockStop' has a wrong offset!");
static_assert(offsetof(AAudioBlockFeedback, _blockableAudioComponent) == 0x0002B8, "Member 'AAudioBlockFeedback::_blockableAudioComponent' has a wrong offset!");

// Class DBDGameplay.ConspicuousActionComponent
// 0x0028 (0x00D0 - 0x00A8)
class UConspicuousActionComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x28];                                      // 0x00A8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConspicuousActionComponent">();
	}
	static class UConspicuousActionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConspicuousActionComponent>();
	}
};
static_assert(alignof(UConspicuousActionComponent) == 0x000008, "Wrong alignment on UConspicuousActionComponent");
static_assert(sizeof(UConspicuousActionComponent) == 0x0000D0, "Wrong size on UConspicuousActionComponent");

// Class DBDGameplay.BlockFeedbackComponent
// 0x0088 (0x0130 - 0x00A8)
class UBlockFeedbackComponent final : public UActorComponent
{
public:
	class ULocalPlayerTrackerComponent*           _localPlayerTracker;                               // 0x00A8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B0[0x10];                                      // 0x00B0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ABlockFeedbackBase*>             _defaultBlockSelfFeedbacks;                        // 0x00C0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class ABlockFeedbackBase*>             _defaultBlockOtherFeedbacks;                       // 0x00D0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<TSubclassOf<class ABlockFeedbackBase>> _defaultBlockSelfFeedbackClasses;                  // 0x00E0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<TSubclassOf<class ABlockFeedbackBase>> _defaultBlockOtherFeedbackClasses;                 // 0x00F0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<struct FBlockFeedbackStyleOverride>    _styleOverrides;                                   // 0x0100(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_110[0x20];                                     // 0x0110(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnLocallyObservedChanged();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlockFeedbackComponent">();
	}
	static class UBlockFeedbackComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlockFeedbackComponent>();
	}
};
static_assert(alignof(UBlockFeedbackComponent) == 0x000008, "Wrong alignment on UBlockFeedbackComponent");
static_assert(sizeof(UBlockFeedbackComponent) == 0x000130, "Wrong size on UBlockFeedbackComponent");
static_assert(offsetof(UBlockFeedbackComponent, _localPlayerTracker) == 0x0000A8, "Member 'UBlockFeedbackComponent::_localPlayerTracker' has a wrong offset!");
static_assert(offsetof(UBlockFeedbackComponent, _defaultBlockSelfFeedbacks) == 0x0000C0, "Member 'UBlockFeedbackComponent::_defaultBlockSelfFeedbacks' has a wrong offset!");
static_assert(offsetof(UBlockFeedbackComponent, _defaultBlockOtherFeedbacks) == 0x0000D0, "Member 'UBlockFeedbackComponent::_defaultBlockOtherFeedbacks' has a wrong offset!");
static_assert(offsetof(UBlockFeedbackComponent, _defaultBlockSelfFeedbackClasses) == 0x0000E0, "Member 'UBlockFeedbackComponent::_defaultBlockSelfFeedbackClasses' has a wrong offset!");
static_assert(offsetof(UBlockFeedbackComponent, _defaultBlockOtherFeedbackClasses) == 0x0000F0, "Member 'UBlockFeedbackComponent::_defaultBlockOtherFeedbackClasses' has a wrong offset!");
static_assert(offsetof(UBlockFeedbackComponent, _styleOverrides) == 0x000100, "Member 'UBlockFeedbackComponent::_styleOverrides' has a wrong offset!");

// Class DBDGameplay.DBDCharacterPusherComponent
// 0x0010 (0x0170 - 0x0160)
class UDBDCharacterPusherComponent final : public UCharacterPusherComponent
{
public:
	uint8                                         Pad_160[0x10];                                     // 0x0160(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDCharacterPusherComponent">();
	}
	static class UDBDCharacterPusherComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDCharacterPusherComponent>();
	}
};
static_assert(alignof(UDBDCharacterPusherComponent) == 0x000008, "Wrong alignment on UDBDCharacterPusherComponent");
static_assert(sizeof(UDBDCharacterPusherComponent) == 0x000170, "Wrong size on UDBDCharacterPusherComponent");

// Class DBDGameplay.PowerToggleComponent
// 0x0020 (0x00C8 - 0x00A8)
class UPowerToggleComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x18];                                      // 0x00A8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _isInPower;                                        // 0x00C0(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C1[0x7];                                       // 0x00C1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_IsInPower() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PowerToggleComponent">();
	}
	static class UPowerToggleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPowerToggleComponent>();
	}
};
static_assert(alignof(UPowerToggleComponent) == 0x000008, "Wrong alignment on UPowerToggleComponent");
static_assert(sizeof(UPowerToggleComponent) == 0x0000C8, "Wrong size on UPowerToggleComponent");
static_assert(offsetof(UPowerToggleComponent, _isInPower) == 0x0000C0, "Member 'UPowerToggleComponent::_isInPower' has a wrong offset!");

// Class DBDGameplay.BubbleIndicator
// 0x0010 (0x02B0 - 0x02A0)
class ABubbleIndicator : public AActor
{
public:
	float                                         _lifetime;                                         // 0x02A0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _displayToLocallyObserved;                         // 0x02A4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isInRange;                                        // 0x02A5(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isPreSpawned;                                     // 0x02A6(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A7[0x9];                                      // 0x02A7(0x0009)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActivateBubbleFX(const float Duration);
	void DeactivateBubble();
	void RefreshBubbleVisibility(const bool IsVisible);
	void SetSilhouette(class UStaticMesh* StaticMesh);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BubbleIndicator">();
	}
	static class ABubbleIndicator* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABubbleIndicator>();
	}
};
static_assert(alignof(ABubbleIndicator) == 0x000008, "Wrong alignment on ABubbleIndicator");
static_assert(sizeof(ABubbleIndicator) == 0x0002B0, "Wrong size on ABubbleIndicator");
static_assert(offsetof(ABubbleIndicator, _lifetime) == 0x0002A0, "Member 'ABubbleIndicator::_lifetime' has a wrong offset!");
static_assert(offsetof(ABubbleIndicator, _displayToLocallyObserved) == 0x0002A4, "Member 'ABubbleIndicator::_displayToLocallyObserved' has a wrong offset!");
static_assert(offsetof(ABubbleIndicator, _isInRange) == 0x0002A5, "Member 'ABubbleIndicator::_isInRange' has a wrong offset!");
static_assert(offsetof(ABubbleIndicator, _isPreSpawned) == 0x0002A6, "Member 'ABubbleIndicator::_isPreSpawned' has a wrong offset!");

// Class DBDGameplay.BubbleIndicatorNotifier
// 0x0000 (0x0030 - 0x0030)
class UBubbleIndicatorNotifier final : public UBlueprintFunctionLibrary
{
public:
	static void ActivateBubbleIndicator(class UObject* WorldContextObject, class ABubbleIndicator* BubbleIndicator, const struct FTransform& Transform, bool TriggerLoudNoise, float Lifetime, float AudibleRange);
	static class ABubbleIndicator* PreSpawnBubbleIndicator(class UObject* WorldContextObject, TSubclassOf<class ABubbleIndicator> bubbleIndicatorBP, class UStaticMesh* SilhouetteStaticMesh);
	static void SpawnBubbleIndicator(class UObject* WorldContextObject, TSubclassOf<class ABubbleIndicator> bubbleIndicatorBP, const struct FTransform& Transform, bool TriggerLoudNoise, EBubbleShowedPlayerType ShowedPlayerType, float Lifetime, class UStaticMesh* SilhouetteStaticMesh, float AudibleRange);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BubbleIndicatorNotifier">();
	}
	static class UBubbleIndicatorNotifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBubbleIndicatorNotifier>();
	}
};
static_assert(alignof(UBubbleIndicatorNotifier) == 0x000008, "Wrong alignment on UBubbleIndicatorNotifier");
static_assert(sizeof(UBubbleIndicatorNotifier) == 0x000030, "Wrong size on UBubbleIndicatorNotifier");

// Class DBDGameplay.CageHookOutlineUpdateStrategy
// 0x0000 (0x0148 - 0x0148)
class UCageHookOutlineUpdateStrategy final : public USourceBasedOutlineUpdateStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CageHookOutlineUpdateStrategy">();
	}
	static class UCageHookOutlineUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCageHookOutlineUpdateStrategy>();
	}
};
static_assert(alignof(UCageHookOutlineUpdateStrategy) == 0x000008, "Wrong alignment on UCageHookOutlineUpdateStrategy");
static_assert(sizeof(UCageHookOutlineUpdateStrategy) == 0x000148, "Wrong size on UCageHookOutlineUpdateStrategy");

// Class DBDGameplay.IgnoreWindowsCollisionsComponent
// 0x0018 (0x0110 - 0x00F8)
class UIgnoreWindowsCollisionsComponent final : public UIgnoreCollisionsComponent
{
public:
	TSubclassOf<class UIgnoreCollisionsWindowHandlerComponent> _collisionHandlerComponentClass;                   // 0x00F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UIgnoreCollisionsWindowHandlerComponent*> _collisionHandlerComponents;                       // 0x0100(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	void OnLevelReadyToPlay();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IgnoreWindowsCollisionsComponent">();
	}
	static class UIgnoreWindowsCollisionsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIgnoreWindowsCollisionsComponent>();
	}
};
static_assert(alignof(UIgnoreWindowsCollisionsComponent) == 0x000008, "Wrong alignment on UIgnoreWindowsCollisionsComponent");
static_assert(sizeof(UIgnoreWindowsCollisionsComponent) == 0x000110, "Wrong size on UIgnoreWindowsCollisionsComponent");
static_assert(offsetof(UIgnoreWindowsCollisionsComponent, _collisionHandlerComponentClass) == 0x0000F8, "Member 'UIgnoreWindowsCollisionsComponent::_collisionHandlerComponentClass' has a wrong offset!");
static_assert(offsetof(UIgnoreWindowsCollisionsComponent, _collisionHandlerComponents) == 0x000100, "Member 'UIgnoreWindowsCollisionsComponent::_collisionHandlerComponents' has a wrong offset!");

// Class DBDGameplay.CageHookPoolComponent
// 0x0028 (0x0130 - 0x0108)
class UCageHookPoolComponent final : public UAuthoritativeActorPoolComponent
{
public:
	uint8                                         Pad_108[0x28];                                     // 0x0108(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Multicast_SpawnTrapBlocker(const TArray<struct FTransform>& SpawnLocations, const struct FVector& BoxExtent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CageHookPoolComponent">();
	}
	static class UCageHookPoolComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCageHookPoolComponent>();
	}
};
static_assert(alignof(UCageHookPoolComponent) == 0x000008, "Wrong alignment on UCageHookPoolComponent");
static_assert(sizeof(UCageHookPoolComponent) == 0x000130, "Wrong size on UCageHookPoolComponent");

// Class DBDGameplay.DBDChildActorComponent
// 0x0090 (0x0350 - 0x02C0)
class UDBDChildActorComponent final : public USceneComponent
{
public:
	TSubclassOf<class AActor>                     _childActorToSpawn;                                // 0x02C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _socketNameToAttach;                               // 0x02C8(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAttachmentRule                               _attachmentLocationRule;                           // 0x02D4(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAttachmentRule                               _attachmentRotationRule;                           // 0x02D5(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAttachmentRule                               _attachmentScaleRule;                              // 0x02D6(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _weldSimulatedBodies;                              // 0x02D7(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D8[0x8];                                      // 0x02D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             _childActorTransformOnSpawn;                       // 0x02E0(0x0060)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 _childActor;                                       // 0x0340(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_348[0x8];                                      // 0x0348(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDChildActorComponent">();
	}
	static class UDBDChildActorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDChildActorComponent>();
	}
};
static_assert(alignof(UDBDChildActorComponent) == 0x000010, "Wrong alignment on UDBDChildActorComponent");
static_assert(sizeof(UDBDChildActorComponent) == 0x000350, "Wrong size on UDBDChildActorComponent");
static_assert(offsetof(UDBDChildActorComponent, _childActorToSpawn) == 0x0002C0, "Member 'UDBDChildActorComponent::_childActorToSpawn' has a wrong offset!");
static_assert(offsetof(UDBDChildActorComponent, _socketNameToAttach) == 0x0002C8, "Member 'UDBDChildActorComponent::_socketNameToAttach' has a wrong offset!");
static_assert(offsetof(UDBDChildActorComponent, _attachmentLocationRule) == 0x0002D4, "Member 'UDBDChildActorComponent::_attachmentLocationRule' has a wrong offset!");
static_assert(offsetof(UDBDChildActorComponent, _attachmentRotationRule) == 0x0002D5, "Member 'UDBDChildActorComponent::_attachmentRotationRule' has a wrong offset!");
static_assert(offsetof(UDBDChildActorComponent, _attachmentScaleRule) == 0x0002D6, "Member 'UDBDChildActorComponent::_attachmentScaleRule' has a wrong offset!");
static_assert(offsetof(UDBDChildActorComponent, _weldSimulatedBodies) == 0x0002D7, "Member 'UDBDChildActorComponent::_weldSimulatedBodies' has a wrong offset!");
static_assert(offsetof(UDBDChildActorComponent, _childActorTransformOnSpawn) == 0x0002E0, "Member 'UDBDChildActorComponent::_childActorTransformOnSpawn' has a wrong offset!");
static_assert(offsetof(UDBDChildActorComponent, _childActor) == 0x000340, "Member 'UDBDChildActorComponent::_childActor' has a wrong offset!");

// Class DBDGameplay.FootstepCreatorComponent
// 0x0050 (0x00F8 - 0x00A8)
class UFootstepCreatorComponent : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x20];                                      // 0x00A8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            _fadeCurve;                                        // 0x00C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            _veinsCurve;                                       // 0x00D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UFootstepManagerComponent>  _footstepManagerComponentClass;                    // 0x00D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E0[0x8];                                       // 0x00E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _secondsUntilFootprintTrigger;                     // 0x00E8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _canSpawnFootstepsDefaultValue;                    // 0x00EC(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_ED[0xB];                                       // 0x00ED(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FootstepCreatorComponent">();
	}
	static class UFootstepCreatorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFootstepCreatorComponent>();
	}
};
static_assert(alignof(UFootstepCreatorComponent) == 0x000008, "Wrong alignment on UFootstepCreatorComponent");
static_assert(sizeof(UFootstepCreatorComponent) == 0x0000F8, "Wrong size on UFootstepCreatorComponent");
static_assert(offsetof(UFootstepCreatorComponent, _fadeCurve) == 0x0000C8, "Member 'UFootstepCreatorComponent::_fadeCurve' has a wrong offset!");
static_assert(offsetof(UFootstepCreatorComponent, _veinsCurve) == 0x0000D0, "Member 'UFootstepCreatorComponent::_veinsCurve' has a wrong offset!");
static_assert(offsetof(UFootstepCreatorComponent, _footstepManagerComponentClass) == 0x0000D8, "Member 'UFootstepCreatorComponent::_footstepManagerComponentClass' has a wrong offset!");
static_assert(offsetof(UFootstepCreatorComponent, _secondsUntilFootprintTrigger) == 0x0000E8, "Member 'UFootstepCreatorComponent::_secondsUntilFootprintTrigger' has a wrong offset!");
static_assert(offsetof(UFootstepCreatorComponent, _canSpawnFootstepsDefaultValue) == 0x0000EC, "Member 'UFootstepCreatorComponent::_canSpawnFootstepsDefaultValue' has a wrong offset!");

// Class DBDGameplay.SightRevealableComponent
// 0x0218 (0x02C0 - 0x00A8)
class USightRevealableComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x48];                                      // 0x00A8(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  _ignoredTags;                                      // 0x00F0(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _revealTimeBase;                                   // 0x0110(0x0080)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _revealRate;                                       // 0x0190(0x0080)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _revealRegressionRate;                             // 0x0210(0x0080)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_290[0x30];                                     // 0x0290(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool Authority_IsBeingRevealed();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SightRevealableComponent">();
	}
	static class USightRevealableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USightRevealableComponent>();
	}
};
static_assert(alignof(USightRevealableComponent) == 0x000008, "Wrong alignment on USightRevealableComponent");
static_assert(sizeof(USightRevealableComponent) == 0x0002C0, "Wrong size on USightRevealableComponent");
static_assert(offsetof(USightRevealableComponent, _ignoredTags) == 0x0000F0, "Member 'USightRevealableComponent::_ignoredTags' has a wrong offset!");
static_assert(offsetof(USightRevealableComponent, _revealTimeBase) == 0x000110, "Member 'USightRevealableComponent::_revealTimeBase' has a wrong offset!");
static_assert(offsetof(USightRevealableComponent, _revealRate) == 0x000190, "Member 'USightRevealableComponent::_revealRate' has a wrong offset!");
static_assert(offsetof(USightRevealableComponent, _revealRegressionRate) == 0x000210, "Member 'USightRevealableComponent::_revealRegressionRate' has a wrong offset!");

// Class DBDGameplay.CamperFootstepCreatorComponent
// 0x0238 (0x0330 - 0x00F8)
class UCamperFootstepCreatorComponent : public UFootstepCreatorComponent
{
public:
	TArray<struct FGameplayTag>                   _disallowFootstepsSpawnPerkFlags;                  // 0x00F8(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FStatProperty                          _footstepIndicatorAngle;                           // 0x0108(0x0088)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FStatProperty                          _footstepIndicatorDecalSize;                       // 0x0190(0x0088)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FStatProperty                          _footstepIndicatorDurationAdditive;                // 0x0218(0x0088)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FStatProperty                          _footstepIndicatorDurationMultiplictive;           // 0x02A0(0x0088)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_328[0x8];                                      // 0x0328(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnLoudNoiseTriggered(class AActor* Originator, class AActor* InstigatingActor, const struct FVector& Location, bool ShouldTrack, float* AudibleRange, bool IsQuickAction, bool IsDeceivingNoise);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CamperFootstepCreatorComponent">();
	}
	static class UCamperFootstepCreatorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCamperFootstepCreatorComponent>();
	}
};
static_assert(alignof(UCamperFootstepCreatorComponent) == 0x000008, "Wrong alignment on UCamperFootstepCreatorComponent");
static_assert(sizeof(UCamperFootstepCreatorComponent) == 0x000330, "Wrong size on UCamperFootstepCreatorComponent");
static_assert(offsetof(UCamperFootstepCreatorComponent, _disallowFootstepsSpawnPerkFlags) == 0x0000F8, "Member 'UCamperFootstepCreatorComponent::_disallowFootstepsSpawnPerkFlags' has a wrong offset!");
static_assert(offsetof(UCamperFootstepCreatorComponent, _footstepIndicatorAngle) == 0x000108, "Member 'UCamperFootstepCreatorComponent::_footstepIndicatorAngle' has a wrong offset!");
static_assert(offsetof(UCamperFootstepCreatorComponent, _footstepIndicatorDecalSize) == 0x000190, "Member 'UCamperFootstepCreatorComponent::_footstepIndicatorDecalSize' has a wrong offset!");
static_assert(offsetof(UCamperFootstepCreatorComponent, _footstepIndicatorDurationAdditive) == 0x000218, "Member 'UCamperFootstepCreatorComponent::_footstepIndicatorDurationAdditive' has a wrong offset!");
static_assert(offsetof(UCamperFootstepCreatorComponent, _footstepIndicatorDurationMultiplictive) == 0x0002A0, "Member 'UCamperFootstepCreatorComponent::_footstepIndicatorDurationMultiplictive' has a wrong offset!");

// Class DBDGameplay.FootstepPerceptionComponent
// 0x0018 (0x00C0 - 0x00A8)
class UFootstepPerceptionComponent : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x10];                                      // 0x00A8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _canSeeFootstepsDefaultValue;                      // 0x00B8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B9[0x7];                                       // 0x00B9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FootstepPerceptionComponent">();
	}
	static class UFootstepPerceptionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFootstepPerceptionComponent>();
	}
};
static_assert(alignof(UFootstepPerceptionComponent) == 0x000008, "Wrong alignment on UFootstepPerceptionComponent");
static_assert(sizeof(UFootstepPerceptionComponent) == 0x0000C0, "Wrong size on UFootstepPerceptionComponent");
static_assert(offsetof(UFootstepPerceptionComponent, _canSeeFootstepsDefaultValue) == 0x0000B8, "Member 'UFootstepPerceptionComponent::_canSeeFootstepsDefaultValue' has a wrong offset!");

// Class DBDGameplay.PlayerFootstepPerceptionComponent
// 0x0040 (0x0100 - 0x00C0)
class UPlayerFootstepPerceptionComponent : public UFootstepPerceptionComponent
{
public:
	TArray<struct FGameplayTag>                   _allowFootstepsSeenPerkFlags;                      // 0x00C0(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FGameplayTag>                   _disallowFootstepsSeenPerkFlags;                   // 0x00D0(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_E0[0x20];                                      // 0x00E0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerFootstepPerceptionComponent">();
	}
	static class UPlayerFootstepPerceptionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerFootstepPerceptionComponent>();
	}
};
static_assert(alignof(UPlayerFootstepPerceptionComponent) == 0x000008, "Wrong alignment on UPlayerFootstepPerceptionComponent");
static_assert(sizeof(UPlayerFootstepPerceptionComponent) == 0x000100, "Wrong size on UPlayerFootstepPerceptionComponent");
static_assert(offsetof(UPlayerFootstepPerceptionComponent, _allowFootstepsSeenPerkFlags) == 0x0000C0, "Member 'UPlayerFootstepPerceptionComponent::_allowFootstepsSeenPerkFlags' has a wrong offset!");
static_assert(offsetof(UPlayerFootstepPerceptionComponent, _disallowFootstepsSeenPerkFlags) == 0x0000D0, "Member 'UPlayerFootstepPerceptionComponent::_disallowFootstepsSeenPerkFlags' has a wrong offset!");

// Class DBDGameplay.CamperFootstepPerceptionComponent
// 0x0000 (0x0100 - 0x0100)
class UCamperFootstepPerceptionComponent : public UPlayerFootstepPerceptionComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CamperFootstepPerceptionComponent">();
	}
	static class UCamperFootstepPerceptionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCamperFootstepPerceptionComponent>();
	}
};
static_assert(alignof(UCamperFootstepPerceptionComponent) == 0x000008, "Wrong alignment on UCamperFootstepPerceptionComponent");
static_assert(sizeof(UCamperFootstepPerceptionComponent) == 0x000100, "Wrong size on UCamperFootstepPerceptionComponent");

// Class DBDGameplay.CollectableComponentUtilities
// 0x0000 (0x0030 - 0x0030)
class UCollectableComponentUtilities final : public UBlueprintFunctionLibrary
{
public:
	static class ADBDPlayer* GetCollector(const class UActorComponent* Component);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CollectableComponentUtilities">();
	}
	static class UCollectableComponentUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCollectableComponentUtilities>();
	}
};
static_assert(alignof(UCollectableComponentUtilities) == 0x000008, "Wrong alignment on UCollectableComponentUtilities");
static_assert(sizeof(UCollectableComponentUtilities) == 0x000030, "Wrong size on UCollectableComponentUtilities");

// Class DBDGameplay.DBDBaseActor
// 0x0008 (0x02A8 - 0x02A0)
class ADBDBaseActor : public AActor
{
public:
	class USceneComponent*                        _rootComponent;                                    // 0x02A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDBaseActor">();
	}
	static class ADBDBaseActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDBaseActor>();
	}
};
static_assert(alignof(ADBDBaseActor) == 0x000008, "Wrong alignment on ADBDBaseActor");
static_assert(sizeof(ADBDBaseActor) == 0x0002A8, "Wrong size on ADBDBaseActor");
static_assert(offsetof(ADBDBaseActor, _rootComponent) == 0x0002A0, "Member 'ADBDBaseActor::_rootComponent' has a wrong offset!");

// Class DBDGameplay.DecoySlasherComponent
// 0x0040 (0x00E8 - 0x00A8)
class UDecoySlasherComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnStunned;                                         // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             TriggerDecoyVisibilityVFX;                         // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	bool                                          HasTerrorRadius;                                   // 0x00D0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          HasRedGlow;                                        // 0x00D1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isActive;                                         // 0x00D2(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _initialized;                                      // 0x00D3(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTerrorRadiusEmitterComponent*          _terrorRadiusEmitter;                              // 0x00D8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URedStainComponent*                     _redStainComponent;                                // 0x00E0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void CopyCustomizationFromSlasher();
	void DoPostVFXUpdates(const struct FVector& Location, const struct FRotator& Rotation);
	void OnRealSlasherTerrorRadiusChanged(float NewValue);
	void SetDecoyIsActive(bool Param_IsActive, const struct FVector& Location, const struct FRotator& Rotation, bool VisibleRedGlow);

	class ASlasherPlayer* GetRealSlasher() const;
	bool IsDecoyActive() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DecoySlasherComponent">();
	}
	static class UDecoySlasherComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDecoySlasherComponent>();
	}
};
static_assert(alignof(UDecoySlasherComponent) == 0x000008, "Wrong alignment on UDecoySlasherComponent");
static_assert(sizeof(UDecoySlasherComponent) == 0x0000E8, "Wrong size on UDecoySlasherComponent");
static_assert(offsetof(UDecoySlasherComponent, OnStunned) == 0x0000B0, "Member 'UDecoySlasherComponent::OnStunned' has a wrong offset!");
static_assert(offsetof(UDecoySlasherComponent, TriggerDecoyVisibilityVFX) == 0x0000C0, "Member 'UDecoySlasherComponent::TriggerDecoyVisibilityVFX' has a wrong offset!");
static_assert(offsetof(UDecoySlasherComponent, HasTerrorRadius) == 0x0000D0, "Member 'UDecoySlasherComponent::HasTerrorRadius' has a wrong offset!");
static_assert(offsetof(UDecoySlasherComponent, HasRedGlow) == 0x0000D1, "Member 'UDecoySlasherComponent::HasRedGlow' has a wrong offset!");
static_assert(offsetof(UDecoySlasherComponent, _isActive) == 0x0000D2, "Member 'UDecoySlasherComponent::_isActive' has a wrong offset!");
static_assert(offsetof(UDecoySlasherComponent, _initialized) == 0x0000D3, "Member 'UDecoySlasherComponent::_initialized' has a wrong offset!");
static_assert(offsetof(UDecoySlasherComponent, _terrorRadiusEmitter) == 0x0000D8, "Member 'UDecoySlasherComponent::_terrorRadiusEmitter' has a wrong offset!");
static_assert(offsetof(UDecoySlasherComponent, _redStainComponent) == 0x0000E0, "Member 'UDecoySlasherComponent::_redStainComponent' has a wrong offset!");

// Class DBDGameplay.EndGameEffectsComponent
// 0x0020 (0x00C8 - 0x00A8)
class UEndGameEffectsComponent : public UActorComponent
{
public:
	bool                                          _hasEndGameBegun;                                  // 0x00A8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _playCameraShakeOnce;                              // 0x00A9(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_AA[0x1E];                                      // 0x00AA(0x001E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnLocallyObservedChanged(class ADBDPlayer* Player);
	void RegisterLocallyObservedEvents();
	void StartUpdateTimer(const struct FGameplayTag& GameEventType, const struct FGameEventData& GameEventData);
	void UnregisterLocallyObservedEvents();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndGameEffectsComponent">();
	}
	static class UEndGameEffectsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndGameEffectsComponent>();
	}
};
static_assert(alignof(UEndGameEffectsComponent) == 0x000008, "Wrong alignment on UEndGameEffectsComponent");
static_assert(sizeof(UEndGameEffectsComponent) == 0x0000C8, "Wrong size on UEndGameEffectsComponent");
static_assert(offsetof(UEndGameEffectsComponent, _hasEndGameBegun) == 0x0000A8, "Member 'UEndGameEffectsComponent::_hasEndGameBegun' has a wrong offset!");
static_assert(offsetof(UEndGameEffectsComponent, _playCameraShakeOnce) == 0x0000A9, "Member 'UEndGameEffectsComponent::_playCameraShakeOnce' has a wrong offset!");

// Class DBDGameplay.EtherealComponent
// 0x0040 (0x00E8 - 0x00A8)
class UEtherealComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x28];                                      // 0x00A8(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _isEthereal;                                       // 0x00D0(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D1[0x17];                                      // 0x00D1(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_OnIsEtherealChanged();
	void Server_SetIsEthereal(float Timestamp, bool Ethereal);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EtherealComponent">();
	}
	static class UEtherealComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEtherealComponent>();
	}
};
static_assert(alignof(UEtherealComponent) == 0x000008, "Wrong alignment on UEtherealComponent");
static_assert(sizeof(UEtherealComponent) == 0x0000E8, "Wrong size on UEtherealComponent");
static_assert(offsetof(UEtherealComponent, _isEthereal) == 0x0000D0, "Member 'UEtherealComponent::_isEthereal' has a wrong offset!");

// Class DBDGameplay.RangeToActorsTrackerStrategy
// 0x0040 (0x0070 - 0x0030)
class URangeToActorsTrackerStrategy : public UObject
{
public:
	struct FDBDTunableRowHandle                   _range;                                            // 0x0030(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_58[0x18];                                      // 0x0058(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnInRangeToTrackedActorsChanged(const bool InRange);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RangeToActorsTrackerStrategy">();
	}
	static class URangeToActorsTrackerStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<URangeToActorsTrackerStrategy>();
	}
};
static_assert(alignof(URangeToActorsTrackerStrategy) == 0x000008, "Wrong alignment on URangeToActorsTrackerStrategy");
static_assert(sizeof(URangeToActorsTrackerStrategy) == 0x000070, "Wrong size on URangeToActorsTrackerStrategy");
static_assert(offsetof(URangeToActorsTrackerStrategy, _range) == 0x000030, "Member 'URangeToActorsTrackerStrategy::_range' has a wrong offset!");

// Class DBDGameplay.ExitGateSwitchesRangeTrackerStrategy
// 0x0000 (0x0070 - 0x0070)
class UExitGateSwitchesRangeTrackerStrategy final : public URangeToActorsTrackerStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExitGateSwitchesRangeTrackerStrategy">();
	}
	static class UExitGateSwitchesRangeTrackerStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UExitGateSwitchesRangeTrackerStrategy>();
	}
};
static_assert(alignof(UExitGateSwitchesRangeTrackerStrategy) == 0x000008, "Wrong alignment on UExitGateSwitchesRangeTrackerStrategy");
static_assert(sizeof(UExitGateSwitchesRangeTrackerStrategy) == 0x000070, "Wrong size on UExitGateSwitchesRangeTrackerStrategy");

// Class DBDGameplay.FadingBlockFeedback
// 0x0018 (0x02C0 - 0x02A8)
class AFadingBlockFeedback : public ABlockFeedbackBase
{
public:
	class UCurveFloat*                            _fadeCurve;                                        // 0x02A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B0[0x10];                                     // 0x02B0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnFadeOutEnded();
	void OnFadeOutStarted(const float FadeDuration);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FadingBlockFeedback">();
	}
	static class AFadingBlockFeedback* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFadingBlockFeedback>();
	}
};
static_assert(alignof(AFadingBlockFeedback) == 0x000008, "Wrong alignment on AFadingBlockFeedback");
static_assert(sizeof(AFadingBlockFeedback) == 0x0002C0, "Wrong size on AFadingBlockFeedback");
static_assert(offsetof(AFadingBlockFeedback, _fadeCurve) == 0x0002A8, "Member 'AFadingBlockFeedback::_fadeCurve' has a wrong offset!");

// Class DBDGameplay.Firecracker
// 0x0008 (0x0420 - 0x0418)
class AFirecracker : public ARangedExplosive
{
public:
	class UFirecrackerStateMachine*               _firecrackerStateMachine;                          // 0x0418(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Firecracker">();
	}
	static class AFirecracker* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFirecracker>();
	}
};
static_assert(alignof(AFirecracker) == 0x000008, "Wrong alignment on AFirecracker");
static_assert(sizeof(AFirecracker) == 0x000420, "Wrong size on AFirecracker");
static_assert(offsetof(AFirecracker, _firecrackerStateMachine) == 0x000418, "Member 'AFirecracker::_firecrackerStateMachine' has a wrong offset!");

// Class DBDGameplay.FirecrackerScoreComponent
// 0x0008 (0x00B0 - 0x00A8)
class UFirecrackerScoreComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FirecrackerScoreComponent">();
	}
	static class UFirecrackerScoreComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFirecrackerScoreComponent>();
	}
};
static_assert(alignof(UFirecrackerScoreComponent) == 0x000008, "Wrong alignment on UFirecrackerScoreComponent");
static_assert(sizeof(UFirecrackerScoreComponent) == 0x0000B0, "Wrong size on UFirecrackerScoreComponent");

// Class DBDGameplay.FirecrackerSpawnInteraction
// 0x0000 (0x0780 - 0x0780)
class UFirecrackerSpawnInteraction : public UInteractionDefinition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FirecrackerSpawnInteraction">();
	}
	static class UFirecrackerSpawnInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFirecrackerSpawnInteraction>();
	}
};
static_assert(alignof(UFirecrackerSpawnInteraction) == 0x000010, "Wrong alignment on UFirecrackerSpawnInteraction");
static_assert(sizeof(UFirecrackerSpawnInteraction) == 0x000780, "Wrong size on UFirecrackerSpawnInteraction");

// Class DBDGameplay.FirecrackerStateMachine
// 0x0000 (0x0120 - 0x0120)
class UFirecrackerStateMachine final : public UStateMachine
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FirecrackerStateMachine">();
	}
	static class UFirecrackerStateMachine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFirecrackerStateMachine>();
	}
};
static_assert(alignof(UFirecrackerStateMachine) == 0x000010, "Wrong alignment on UFirecrackerStateMachine");
static_assert(sizeof(UFirecrackerStateMachine) == 0x000120, "Wrong size on UFirecrackerStateMachine");

// Class DBDGameplay.Flashlight
// 0x00F0 (0x0688 - 0x0598)
class AFlashlight : public ABaseCamperCollectable
{
public:
	struct FGameplayTagContainer                  _allowedInteractionSemanticsDuringUse;             // 0x0598(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5B8[0x58];                                     // 0x05B8(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _shouldUseCooldowns;                               // 0x0610(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_611[0x3];                                      // 0x0611(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _cooldownWhileOnDuration;                          // 0x0614(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _cooldownWhileOffDuration;                         // 0x0618(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_61C[0x6C];                                     // 0x061C(0x006C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class USpotLightComponent* GetSpotlightComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Flashlight">();
	}
	static class AFlashlight* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFlashlight>();
	}
};
static_assert(alignof(AFlashlight) == 0x000008, "Wrong alignment on AFlashlight");
static_assert(sizeof(AFlashlight) == 0x000688, "Wrong size on AFlashlight");
static_assert(offsetof(AFlashlight, _allowedInteractionSemanticsDuringUse) == 0x000598, "Member 'AFlashlight::_allowedInteractionSemanticsDuringUse' has a wrong offset!");
static_assert(offsetof(AFlashlight, _shouldUseCooldowns) == 0x000610, "Member 'AFlashlight::_shouldUseCooldowns' has a wrong offset!");
static_assert(offsetof(AFlashlight, _cooldownWhileOnDuration) == 0x000614, "Member 'AFlashlight::_cooldownWhileOnDuration' has a wrong offset!");
static_assert(offsetof(AFlashlight, _cooldownWhileOffDuration) == 0x000618, "Member 'AFlashlight::_cooldownWhileOffDuration' has a wrong offset!");

// Class DBDGameplay.FlashlightableComponent
// 0x0088 (0x0130 - 0x00A8)
class UFlashlightableComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnFlashlightAddedEvent;                            // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFlashlightRemovedEvent;                          // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFlashlightLitChangedEvent;                       // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UFlashlightableLightingStrategy*        _lightingStrategy;                                 // 0x00D8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSet<class UFlashlightComponent*>             _flashlights;                                      // 0x00E0(0x0050)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	void OnFlashlightAddedRemovedEvent__DelegateSignature(const class UFlashlightComponent* Flashlight);
	void OnFlashlightLitChangedEvent__DelegateSignature(bool IsLit);

	bool IsLit() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlashlightableComponent">();
	}
	static class UFlashlightableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlashlightableComponent>();
	}
};
static_assert(alignof(UFlashlightableComponent) == 0x000008, "Wrong alignment on UFlashlightableComponent");
static_assert(sizeof(UFlashlightableComponent) == 0x000130, "Wrong size on UFlashlightableComponent");
static_assert(offsetof(UFlashlightableComponent, OnFlashlightAddedEvent) == 0x0000A8, "Member 'UFlashlightableComponent::OnFlashlightAddedEvent' has a wrong offset!");
static_assert(offsetof(UFlashlightableComponent, OnFlashlightRemovedEvent) == 0x0000B8, "Member 'UFlashlightableComponent::OnFlashlightRemovedEvent' has a wrong offset!");
static_assert(offsetof(UFlashlightableComponent, OnFlashlightLitChangedEvent) == 0x0000C8, "Member 'UFlashlightableComponent::OnFlashlightLitChangedEvent' has a wrong offset!");
static_assert(offsetof(UFlashlightableComponent, _lightingStrategy) == 0x0000D8, "Member 'UFlashlightableComponent::_lightingStrategy' has a wrong offset!");
static_assert(offsetof(UFlashlightableComponent, _flashlights) == 0x0000E0, "Member 'UFlashlightableComponent::_flashlights' has a wrong offset!");

// Class DBDGameplay.FlashlightComponent
// 0x0150 (0x01F8 - 0x00A8)
class UFlashlightComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnFlashlightTurnedOn;                              // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFlashlightTurnedOff;                             // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFlashlightablesUpdated;                          // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FDBDTunableRowHandle                   _baseBlindnessDuration;                            // 0x00E0(0x0028)(Edit, NativeAccessSpecifierPrivate)
	float                                         _baseAccuracy;                                     // 0x0108(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _lagDuration;                                      // 0x010C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSet<class UFlashlightableComponent*>         _flashlightables;                                  // 0x0110(0x0050)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TSet<class UFlashlightableComponent*>         _autonomousLitFlashlightables;                     // 0x0160(0x0050)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UFlashlightableComponent*>       _replicatedLitFlashlightables;                     // 0x01B0(0x0010)(ExportObject, Net, ZeroConstructor, Transient, RepNotify, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	bool                                          _isOwnerLagging;                                   // 0x01C0(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1C1[0x37];                                     // 0x01C1(0x0037)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnFlashlightEvent__DelegateSignature();
	void OnRep_IsOwnerLagging();
	void OnRep_ReplicatedLitFlashlightables();
	void Server_SetAndUpdateAutonomousLitFlashlightables(const TArray<class UFlashlightableComponent*>& NewLitFlashlightables);
	void TurnOff();
	void TurnOn();

	float GetEffectiveBlindnessDuration() const;
	float GetEffectiveTimeToBlindModifier() const;
	bool IsOn() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlashlightComponent">();
	}
	static class UFlashlightComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlashlightComponent>();
	}
};
static_assert(alignof(UFlashlightComponent) == 0x000008, "Wrong alignment on UFlashlightComponent");
static_assert(sizeof(UFlashlightComponent) == 0x0001F8, "Wrong size on UFlashlightComponent");
static_assert(offsetof(UFlashlightComponent, OnFlashlightTurnedOn) == 0x0000B0, "Member 'UFlashlightComponent::OnFlashlightTurnedOn' has a wrong offset!");
static_assert(offsetof(UFlashlightComponent, OnFlashlightTurnedOff) == 0x0000C0, "Member 'UFlashlightComponent::OnFlashlightTurnedOff' has a wrong offset!");
static_assert(offsetof(UFlashlightComponent, OnFlashlightablesUpdated) == 0x0000D0, "Member 'UFlashlightComponent::OnFlashlightablesUpdated' has a wrong offset!");
static_assert(offsetof(UFlashlightComponent, _baseBlindnessDuration) == 0x0000E0, "Member 'UFlashlightComponent::_baseBlindnessDuration' has a wrong offset!");
static_assert(offsetof(UFlashlightComponent, _baseAccuracy) == 0x000108, "Member 'UFlashlightComponent::_baseAccuracy' has a wrong offset!");
static_assert(offsetof(UFlashlightComponent, _lagDuration) == 0x00010C, "Member 'UFlashlightComponent::_lagDuration' has a wrong offset!");
static_assert(offsetof(UFlashlightComponent, _flashlightables) == 0x000110, "Member 'UFlashlightComponent::_flashlightables' has a wrong offset!");
static_assert(offsetof(UFlashlightComponent, _autonomousLitFlashlightables) == 0x000160, "Member 'UFlashlightComponent::_autonomousLitFlashlightables' has a wrong offset!");
static_assert(offsetof(UFlashlightComponent, _replicatedLitFlashlightables) == 0x0001B0, "Member 'UFlashlightComponent::_replicatedLitFlashlightables' has a wrong offset!");
static_assert(offsetof(UFlashlightComponent, _isOwnerLagging) == 0x0001C0, "Member 'UFlashlightComponent::_isOwnerLagging' has a wrong offset!");

// Class DBDGameplay.FlashlightConeComponent
// 0x00B8 (0x0160 - 0x00A8)
class UFlashlightConeComponent final : public UActorComponent
{
public:
	struct FVector                                AIAimBeamLocationOffset;                           // 0x00A8(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               AIAimBeamRotationOffset;                           // 0x00C0(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class USceneComponent*                        _flashlightBottom;                                 // 0x00D8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _baseBeamAngle;                                    // 0x00E0(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _baseBeamLength;                                   // 0x0108(0x0028)(Edit, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class AActor>                  _cacheCollidingActor;                              // 0x0130(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_138[0x18];                                     // 0x0138(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameplayTag>                   _tagsPreventingBeamOcclusion;                      // 0x0150(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	float GetEffectiveConeHalfAngle() const;
	float GetEffectiveConeLength() const;
	float GetOcclusionDistance() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlashlightConeComponent">();
	}
	static class UFlashlightConeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlashlightConeComponent>();
	}
};
static_assert(alignof(UFlashlightConeComponent) == 0x000008, "Wrong alignment on UFlashlightConeComponent");
static_assert(sizeof(UFlashlightConeComponent) == 0x000160, "Wrong size on UFlashlightConeComponent");
static_assert(offsetof(UFlashlightConeComponent, AIAimBeamLocationOffset) == 0x0000A8, "Member 'UFlashlightConeComponent::AIAimBeamLocationOffset' has a wrong offset!");
static_assert(offsetof(UFlashlightConeComponent, AIAimBeamRotationOffset) == 0x0000C0, "Member 'UFlashlightConeComponent::AIAimBeamRotationOffset' has a wrong offset!");
static_assert(offsetof(UFlashlightConeComponent, _flashlightBottom) == 0x0000D8, "Member 'UFlashlightConeComponent::_flashlightBottom' has a wrong offset!");
static_assert(offsetof(UFlashlightConeComponent, _baseBeamAngle) == 0x0000E0, "Member 'UFlashlightConeComponent::_baseBeamAngle' has a wrong offset!");
static_assert(offsetof(UFlashlightConeComponent, _baseBeamLength) == 0x000108, "Member 'UFlashlightConeComponent::_baseBeamLength' has a wrong offset!");
static_assert(offsetof(UFlashlightConeComponent, _cacheCollidingActor) == 0x000130, "Member 'UFlashlightConeComponent::_cacheCollidingActor' has a wrong offset!");
static_assert(offsetof(UFlashlightConeComponent, _tagsPreventingBeamOcclusion) == 0x000150, "Member 'UFlashlightConeComponent::_tagsPreventingBeamOcclusion' has a wrong offset!");

// Class DBDGameplay.FlashlightFXComponent
// 0x01B0 (0x0258 - 0x00A8)
class UFlashlightFXComponent : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnFlashEvent;                                      // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class USceneComponent*                        _tip;                                              // 0x00B8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   _centerGlowMesh;                                   // 0x00C0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USplineMeshComponent*                   _beamMesh;                                         // 0x00C8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _minimumOcclusionDistanceForSpotlight;             // 0x00D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            _flashEffectIntensityCurve;                        // 0x00D8(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _flashEffectDuration;                              // 0x00E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _spotLightHalfAngle;                               // 0x00E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _spotLightIntensity;                               // 0x00E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _beamBlindingHalfAngle;                            // 0x00EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _beamFlashHalfAngle;                               // 0x00F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _beamBlindingRatioInterpSpeedWithTarget;           // 0x00F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _beamBlindingRatioInterpSpeedWithoutTarget;        // 0x00F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _resizeConeLength;                                 // 0x00FC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_FD[0x3];                                       // 0x00FD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _centerGlowWidthScaleWithoutBlindTarget;           // 0x0100(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _centerGlowWidthScaleWithBlindTarget;              // 0x0104(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _centerGlowWidthScaleDuringFlash;                  // 0x0108(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _centerGlowShrinkDistance;                         // 0x010C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _centerGlowLengthMaxScale;                         // 0x0110(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_114[0x4];                                      // 0x0114(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAkObservedPlayerSoundLoop             _aimedAtSoundLoop;                                 // 0x0118(0x0040)(Edit, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UFlashlightTargetFXComponent*           _currentBeamModifyingTarget;                       // 0x0158(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSet<class UFlashlightTargetFXComponent*>     _targets;                                          // 0x0160(0x0050)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1B0[0xA8];                                     // 0x01B0(0x00A8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCollectedEvent(class ADBDPlayer* Collector);
	void OnCollectorLocallyObservedChangedEvent(bool IsLocallyObserved);
	void OnDroppedEvent();
	void OnFlashEvent__DelegateSignature();
	void OnStartEvent();
	void OnStopEvent();
	void OnTurnedOff();
	void OnTurnedOn();
	void PostUpdateEvent();
	void UpdateConeEvent(float Length, float HalfAngle);
	void UpdateFXTargets();

	float GetBlindingSuccessRatio() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlashlightFXComponent">();
	}
	static class UFlashlightFXComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlashlightFXComponent>();
	}
};
static_assert(alignof(UFlashlightFXComponent) == 0x000008, "Wrong alignment on UFlashlightFXComponent");
static_assert(sizeof(UFlashlightFXComponent) == 0x000258, "Wrong size on UFlashlightFXComponent");
static_assert(offsetof(UFlashlightFXComponent, OnFlashEvent) == 0x0000A8, "Member 'UFlashlightFXComponent::OnFlashEvent' has a wrong offset!");
static_assert(offsetof(UFlashlightFXComponent, _tip) == 0x0000B8, "Member 'UFlashlightFXComponent::_tip' has a wrong offset!");
static_assert(offsetof(UFlashlightFXComponent, _centerGlowMesh) == 0x0000C0, "Member 'UFlashlightFXComponent::_centerGlowMesh' has a wrong offset!");
static_assert(offsetof(UFlashlightFXComponent, _beamMesh) == 0x0000C8, "Member 'UFlashlightFXComponent::_beamMesh' has a wrong offset!");
static_assert(offsetof(UFlashlightFXComponent, _minimumOcclusionDistanceForSpotlight) == 0x0000D0, "Member 'UFlashlightFXComponent::_minimumOcclusionDistanceForSpotlight' has a wrong offset!");
static_assert(offsetof(UFlashlightFXComponent, _flashEffectIntensityCurve) == 0x0000D8, "Member 'UFlashlightFXComponent::_flashEffectIntensityCurve' has a wrong offset!");
static_assert(offsetof(UFlashlightFXComponent, _flashEffectDuration) == 0x0000E0, "Member 'UFlashlightFXComponent::_flashEffectDuration' has a wrong offset!");
static_assert(offsetof(UFlashlightFXComponent, _spotLightHalfAngle) == 0x0000E4, "Member 'UFlashlightFXComponent::_spotLightHalfAngle' has a wrong offset!");
static_assert(offsetof(UFlashlightFXComponent, _spotLightIntensity) == 0x0000E8, "Member 'UFlashlightFXComponent::_spotLightIntensity' has a wrong offset!");
static_assert(offsetof(UFlashlightFXComponent, _beamBlindingHalfAngle) == 0x0000EC, "Member 'UFlashlightFXComponent::_beamBlindingHalfAngle' has a wrong offset!");
static_assert(offsetof(UFlashlightFXComponent, _beamFlashHalfAngle) == 0x0000F0, "Member 'UFlashlightFXComponent::_beamFlashHalfAngle' has a wrong offset!");
static_assert(offsetof(UFlashlightFXComponent, _beamBlindingRatioInterpSpeedWithTarget) == 0x0000F4, "Member 'UFlashlightFXComponent::_beamBlindingRatioInterpSpeedWithTarget' has a wrong offset!");
static_assert(offsetof(UFlashlightFXComponent, _beamBlindingRatioInterpSpeedWithoutTarget) == 0x0000F8, "Member 'UFlashlightFXComponent::_beamBlindingRatioInterpSpeedWithoutTarget' has a wrong offset!");
static_assert(offsetof(UFlashlightFXComponent, _resizeConeLength) == 0x0000FC, "Member 'UFlashlightFXComponent::_resizeConeLength' has a wrong offset!");
static_assert(offsetof(UFlashlightFXComponent, _centerGlowWidthScaleWithoutBlindTarget) == 0x000100, "Member 'UFlashlightFXComponent::_centerGlowWidthScaleWithoutBlindTarget' has a wrong offset!");
static_assert(offsetof(UFlashlightFXComponent, _centerGlowWidthScaleWithBlindTarget) == 0x000104, "Member 'UFlashlightFXComponent::_centerGlowWidthScaleWithBlindTarget' has a wrong offset!");
static_assert(offsetof(UFlashlightFXComponent, _centerGlowWidthScaleDuringFlash) == 0x000108, "Member 'UFlashlightFXComponent::_centerGlowWidthScaleDuringFlash' has a wrong offset!");
static_assert(offsetof(UFlashlightFXComponent, _centerGlowShrinkDistance) == 0x00010C, "Member 'UFlashlightFXComponent::_centerGlowShrinkDistance' has a wrong offset!");
static_assert(offsetof(UFlashlightFXComponent, _centerGlowLengthMaxScale) == 0x000110, "Member 'UFlashlightFXComponent::_centerGlowLengthMaxScale' has a wrong offset!");
static_assert(offsetof(UFlashlightFXComponent, _aimedAtSoundLoop) == 0x000118, "Member 'UFlashlightFXComponent::_aimedAtSoundLoop' has a wrong offset!");
static_assert(offsetof(UFlashlightFXComponent, _currentBeamModifyingTarget) == 0x000158, "Member 'UFlashlightFXComponent::_currentBeamModifyingTarget' has a wrong offset!");
static_assert(offsetof(UFlashlightFXComponent, _targets) == 0x000160, "Member 'UFlashlightFXComponent::_targets' has a wrong offset!");

// Class DBDGameplay.FootstepManagerComponent
// 0x0368 (0x0410 - 0x00A8)
class UFootstepManagerComponent : public UActorComponent
{
public:
	struct FBHVRPerDetailModeInt                  _decalPoolSize;                                    // 0x00A8(0x00A0)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FBHVRPerDetailModeFloat                _recycleThresholdPercentage;                       // 0x0148(0x00A0)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FBHVRPerDetailModeFloat                _recycleDistancePercentage;                        // 0x01E8(0x00A0)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FBHVRPerDetailModeInt                  _maxOverlapping;                                   // 0x0288(0x00A0)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	float                                         _raycastHalfAngle;                                 // 0x0328(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _raycastZOffset;                                   // 0x032C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _raycastDistance;                                  // 0x0330(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _minimumDecalSize;                                 // 0x0334(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _maximumDecalSize;                                 // 0x0338(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _projectionTickness;                               // 0x033C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInterface*                     _footstepsMaterial;                                // 0x0340(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FFootstep>                      _currentFootSteps;                                 // 0x0348(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class UDecalSpawner*                          _decalSpawner;                                     // 0x0358(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_360[0xB0];                                     // 0x0360(0x00B0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnUpdateCreatorFootsteps(class UFootstepCreatorComponent* Creator);
	void OnUpdateObserverFootsteps();
	void TriggerSpawnFootstep(class UFootstepCreatorComponent* OriginatorComponent, const struct FVector& Location);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FootstepManagerComponent">();
	}
	static class UFootstepManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFootstepManagerComponent>();
	}
};
static_assert(alignof(UFootstepManagerComponent) == 0x000008, "Wrong alignment on UFootstepManagerComponent");
static_assert(sizeof(UFootstepManagerComponent) == 0x000410, "Wrong size on UFootstepManagerComponent");
static_assert(offsetof(UFootstepManagerComponent, _decalPoolSize) == 0x0000A8, "Member 'UFootstepManagerComponent::_decalPoolSize' has a wrong offset!");
static_assert(offsetof(UFootstepManagerComponent, _recycleThresholdPercentage) == 0x000148, "Member 'UFootstepManagerComponent::_recycleThresholdPercentage' has a wrong offset!");
static_assert(offsetof(UFootstepManagerComponent, _recycleDistancePercentage) == 0x0001E8, "Member 'UFootstepManagerComponent::_recycleDistancePercentage' has a wrong offset!");
static_assert(offsetof(UFootstepManagerComponent, _maxOverlapping) == 0x000288, "Member 'UFootstepManagerComponent::_maxOverlapping' has a wrong offset!");
static_assert(offsetof(UFootstepManagerComponent, _raycastHalfAngle) == 0x000328, "Member 'UFootstepManagerComponent::_raycastHalfAngle' has a wrong offset!");
static_assert(offsetof(UFootstepManagerComponent, _raycastZOffset) == 0x00032C, "Member 'UFootstepManagerComponent::_raycastZOffset' has a wrong offset!");
static_assert(offsetof(UFootstepManagerComponent, _raycastDistance) == 0x000330, "Member 'UFootstepManagerComponent::_raycastDistance' has a wrong offset!");
static_assert(offsetof(UFootstepManagerComponent, _minimumDecalSize) == 0x000334, "Member 'UFootstepManagerComponent::_minimumDecalSize' has a wrong offset!");
static_assert(offsetof(UFootstepManagerComponent, _maximumDecalSize) == 0x000338, "Member 'UFootstepManagerComponent::_maximumDecalSize' has a wrong offset!");
static_assert(offsetof(UFootstepManagerComponent, _projectionTickness) == 0x00033C, "Member 'UFootstepManagerComponent::_projectionTickness' has a wrong offset!");
static_assert(offsetof(UFootstepManagerComponent, _footstepsMaterial) == 0x000340, "Member 'UFootstepManagerComponent::_footstepsMaterial' has a wrong offset!");
static_assert(offsetof(UFootstepManagerComponent, _currentFootSteps) == 0x000348, "Member 'UFootstepManagerComponent::_currentFootSteps' has a wrong offset!");
static_assert(offsetof(UFootstepManagerComponent, _decalSpawner) == 0x000358, "Member 'UFootstepManagerComponent::_decalSpawner' has a wrong offset!");

// Class DBDGameplay.GeneratorWithMostProgressTracker
// 0x0010 (0x00B8 - 0x00A8)
class UGeneratorWithMostProgressTracker final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x10];                                      // 0x00A8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnGeneratorCompleted(bool IsAutoCompleted);
	void OnLevelReadyToPlay();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GeneratorWithMostProgressTracker">();
	}
	static class UGeneratorWithMostProgressTracker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGeneratorWithMostProgressTracker>();
	}
};
static_assert(alignof(UGeneratorWithMostProgressTracker) == 0x000008, "Wrong alignment on UGeneratorWithMostProgressTracker");
static_assert(sizeof(UGeneratorWithMostProgressTracker) == 0x0000B8, "Wrong size on UGeneratorWithMostProgressTracker");

// Class DBDGameplay.GlassBeadMapAddon
// 0x0018 (0x0300 - 0x02E8)
class UGlassBeadMapAddon final : public UItemAddon
{
public:
	uint8                                         Pad_2E8[0x4];                                      // 0x02E8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _spawningCooldownTimer;                            // 0x02EC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class AMapMarkerActor>            _mapMarkerBPClass;                                 // 0x02F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AMapMarkerActor*                        _currentMapMarker;                                 // 0x02F8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Authority_OnSecondaryInputPressed(class ADBDPlayer* Player, class UInteractionDefinition* Interaction, bool FromCancelRequest);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GlassBeadMapAddon">();
	}
	static class UGlassBeadMapAddon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGlassBeadMapAddon>();
	}
};
static_assert(alignof(UGlassBeadMapAddon) == 0x000008, "Wrong alignment on UGlassBeadMapAddon");
static_assert(sizeof(UGlassBeadMapAddon) == 0x000300, "Wrong size on UGlassBeadMapAddon");
static_assert(offsetof(UGlassBeadMapAddon, _spawningCooldownTimer) == 0x0002EC, "Member 'UGlassBeadMapAddon::_spawningCooldownTimer' has a wrong offset!");
static_assert(offsetof(UGlassBeadMapAddon, _mapMarkerBPClass) == 0x0002F0, "Member 'UGlassBeadMapAddon::_mapMarkerBPClass' has a wrong offset!");
static_assert(offsetof(UGlassBeadMapAddon, _currentMapMarker) == 0x0002F8, "Member 'UGlassBeadMapAddon::_currentMapMarker' has a wrong offset!");

// Class DBDGameplay.HooksWithSurvivorRangeTrackerStrategy
// 0x0060 (0x00D0 - 0x0070)
class UHooksWithSurvivorRangeTrackerStrategy final : public URangeToActorsTrackerStrategy
{
public:
	uint8                                         Pad_70[0x60];                                      // 0x0070(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HooksWithSurvivorRangeTrackerStrategy">();
	}
	static class UHooksWithSurvivorRangeTrackerStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHooksWithSurvivorRangeTrackerStrategy>();
	}
};
static_assert(alignof(UHooksWithSurvivorRangeTrackerStrategy) == 0x000008, "Wrong alignment on UHooksWithSurvivorRangeTrackerStrategy");
static_assert(sizeof(UHooksWithSurvivorRangeTrackerStrategy) == 0x0000D0, "Wrong size on UHooksWithSurvivorRangeTrackerStrategy");

// Class DBDGameplay.IgnorePalletsCollisionsComponent
// 0x0018 (0x0110 - 0x00F8)
class UIgnorePalletsCollisionsComponent final : public UIgnoreCollisionsComponent
{
public:
	TSubclassOf<class UIgnoreCollisionsPalletHandlerComponent> _collisionHandlerComponentClass;                   // 0x00F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UIgnoreCollisionsPalletHandlerComponent*> _collisionHandlerComponents;                       // 0x0100(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	void OnLevelReadyToPlay();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IgnorePalletsCollisionsComponent">();
	}
	static class UIgnorePalletsCollisionsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIgnorePalletsCollisionsComponent>();
	}
};
static_assert(alignof(UIgnorePalletsCollisionsComponent) == 0x000008, "Wrong alignment on UIgnorePalletsCollisionsComponent");
static_assert(sizeof(UIgnorePalletsCollisionsComponent) == 0x000110, "Wrong size on UIgnorePalletsCollisionsComponent");
static_assert(offsetof(UIgnorePalletsCollisionsComponent, _collisionHandlerComponentClass) == 0x0000F8, "Member 'UIgnorePalletsCollisionsComponent::_collisionHandlerComponentClass' has a wrong offset!");
static_assert(offsetof(UIgnorePalletsCollisionsComponent, _collisionHandlerComponents) == 0x000100, "Member 'UIgnorePalletsCollisionsComponent::_collisionHandlerComponents' has a wrong offset!");

// Class DBDGameplay.InteractionAttacherComponent
// 0x00A0 (0x0148 - 0x00A8)
class UInteractionAttacherComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x20];                                      // 0x00A8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UInteractionDefinition*>         _interactionDefinitions;                           // 0x00C8(0x0010)(ExportObject, Net, ZeroConstructor, Transient, RepNotify, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UChargeableComponent*>           _chargeableComponents;                             // 0x00D8(0x0010)(ExportObject, Net, ZeroConstructor, Transient, RepNotify, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TSubclassOf<class UInteractionDefinition>     _interactionDefinition;                            // 0x00E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EInteractionOwnerType                         _restriction;                                      // 0x00F0(0x0001)(Edit, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _useChargeableInteraction;                         // 0x00F1(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F2[0x2];                                       // 0x00F2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   _chargeableComponentID;                            // 0x00F4(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   _chargeableComponentName;                          // 0x0100(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_10C[0x4];                                      // 0x010C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _secondsToCharge;                                  // 0x0110(0x0028)(Edit, Net, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	bool                                          _clientWaitForOwnerInitialization;                 // 0x0138(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_139[0xF];                                      // 0x0139(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_ChargeableComponents();
	void OnRep_InteractionDefinitions();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionAttacherComponent">();
	}
	static class UInteractionAttacherComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionAttacherComponent>();
	}
};
static_assert(alignof(UInteractionAttacherComponent) == 0x000008, "Wrong alignment on UInteractionAttacherComponent");
static_assert(sizeof(UInteractionAttacherComponent) == 0x000148, "Wrong size on UInteractionAttacherComponent");
static_assert(offsetof(UInteractionAttacherComponent, _interactionDefinitions) == 0x0000C8, "Member 'UInteractionAttacherComponent::_interactionDefinitions' has a wrong offset!");
static_assert(offsetof(UInteractionAttacherComponent, _chargeableComponents) == 0x0000D8, "Member 'UInteractionAttacherComponent::_chargeableComponents' has a wrong offset!");
static_assert(offsetof(UInteractionAttacherComponent, _interactionDefinition) == 0x0000E8, "Member 'UInteractionAttacherComponent::_interactionDefinition' has a wrong offset!");
static_assert(offsetof(UInteractionAttacherComponent, _restriction) == 0x0000F0, "Member 'UInteractionAttacherComponent::_restriction' has a wrong offset!");
static_assert(offsetof(UInteractionAttacherComponent, _useChargeableInteraction) == 0x0000F1, "Member 'UInteractionAttacherComponent::_useChargeableInteraction' has a wrong offset!");
static_assert(offsetof(UInteractionAttacherComponent, _chargeableComponentID) == 0x0000F4, "Member 'UInteractionAttacherComponent::_chargeableComponentID' has a wrong offset!");
static_assert(offsetof(UInteractionAttacherComponent, _chargeableComponentName) == 0x000100, "Member 'UInteractionAttacherComponent::_chargeableComponentName' has a wrong offset!");
static_assert(offsetof(UInteractionAttacherComponent, _secondsToCharge) == 0x000110, "Member 'UInteractionAttacherComponent::_secondsToCharge' has a wrong offset!");
static_assert(offsetof(UInteractionAttacherComponent, _clientWaitForOwnerInitialization) == 0x000138, "Member 'UInteractionAttacherComponent::_clientWaitForOwnerInitialization' has a wrong offset!");

// Class DBDGameplay.InteractionStarterComponent
// 0x0018 (0x00C0 - 0x00A8)
class UInteractionStarterComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UInteractionDefinition*                 _interaction;                                      // 0x00B0(0x0008)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _shouldStartInteraction;                           // 0x00B8(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B9[0x7];                                       // 0x00B9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnInteractionStarted();
	void OnRep_ShouldStartInteraction();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionStarterComponent">();
	}
	static class UInteractionStarterComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionStarterComponent>();
	}
};
static_assert(alignof(UInteractionStarterComponent) == 0x000008, "Wrong alignment on UInteractionStarterComponent");
static_assert(sizeof(UInteractionStarterComponent) == 0x0000C0, "Wrong size on UInteractionStarterComponent");
static_assert(offsetof(UInteractionStarterComponent, _interaction) == 0x0000B0, "Member 'UInteractionStarterComponent::_interaction' has a wrong offset!");
static_assert(offsetof(UInteractionStarterComponent, _shouldStartInteraction) == 0x0000B8, "Member 'UInteractionStarterComponent::_shouldStartInteraction' has a wrong offset!");

// Class DBDGameplay.KillerFlashlightSFXComponent
// 0x00A0 (0x0148 - 0x00A8)
class UKillerFlashlightSFXComponent final : public UActorComponent
{
public:
	struct FAkObservedPlayerSoundLoop             _targetSoundLoop;                                  // 0x00A8(0x0040)(Edit, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class UFlashlightTargetFXComponent*>   _flashlightTargets;                                // 0x00E8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F8[0x50];                                      // 0x00F8(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerFlashlightSFXComponent">();
	}
	static class UKillerFlashlightSFXComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillerFlashlightSFXComponent>();
	}
};
static_assert(alignof(UKillerFlashlightSFXComponent) == 0x000008, "Wrong alignment on UKillerFlashlightSFXComponent");
static_assert(sizeof(UKillerFlashlightSFXComponent) == 0x000148, "Wrong size on UKillerFlashlightSFXComponent");
static_assert(offsetof(UKillerFlashlightSFXComponent, _targetSoundLoop) == 0x0000A8, "Member 'UKillerFlashlightSFXComponent::_targetSoundLoop' has a wrong offset!");
static_assert(offsetof(UKillerFlashlightSFXComponent, _flashlightTargets) == 0x0000E8, "Member 'UKillerFlashlightSFXComponent::_flashlightTargets' has a wrong offset!");

// Class DBDGameplay.KillerFootstepPerceptionComponent
// 0x0000 (0x0100 - 0x0100)
class UKillerFootstepPerceptionComponent : public UPlayerFootstepPerceptionComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerFootstepPerceptionComponent">();
	}
	static class UKillerFootstepPerceptionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillerFootstepPerceptionComponent>();
	}
};
static_assert(alignof(UKillerFootstepPerceptionComponent) == 0x000008, "Wrong alignment on UKillerFootstepPerceptionComponent");
static_assert(sizeof(UKillerFootstepPerceptionComponent) == 0x000100, "Wrong size on UKillerFootstepPerceptionComponent");

// Class DBDGameplay.KillerFormSwitchingAbilityData
// 0x0010 (0x0070 - 0x0060)
class UKillerFormSwitchingAbilityData final : public UKillerAbilityData
{
public:
	class UAkAudioEvent*                          _onFormSwitchingInteractionEnterAkEvent;           // 0x0060(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          _onFormSwitchingInteractionCancelAkEvent;          // 0x0068(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerFormSwitchingAbilityData">();
	}
	static class UKillerFormSwitchingAbilityData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillerFormSwitchingAbilityData>();
	}
};
static_assert(alignof(UKillerFormSwitchingAbilityData) == 0x000008, "Wrong alignment on UKillerFormSwitchingAbilityData");
static_assert(sizeof(UKillerFormSwitchingAbilityData) == 0x000070, "Wrong size on UKillerFormSwitchingAbilityData");
static_assert(offsetof(UKillerFormSwitchingAbilityData, _onFormSwitchingInteractionEnterAkEvent) == 0x000060, "Member 'UKillerFormSwitchingAbilityData::_onFormSwitchingInteractionEnterAkEvent' has a wrong offset!");
static_assert(offsetof(UKillerFormSwitchingAbilityData, _onFormSwitchingInteractionCancelAkEvent) == 0x000068, "Member 'UKillerFormSwitchingAbilityData::_onFormSwitchingInteractionCancelAkEvent' has a wrong offset!");

// Class DBDGameplay.KillerFormSwitchingTransitionInteraction
// 0x0000 (0x0780 - 0x0780)
class UKillerFormSwitchingTransitionInteraction final : public UInteractionDefinition
{
public:
	bool                                          _targetFormToTransitionIsNextForm;                 // 0x0778(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_779[0x7];                                      // 0x0779(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerFormSwitchingTransitionInteraction">();
	}
	static class UKillerFormSwitchingTransitionInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillerFormSwitchingTransitionInteraction>();
	}
};
static_assert(alignof(UKillerFormSwitchingTransitionInteraction) == 0x000010, "Wrong alignment on UKillerFormSwitchingTransitionInteraction");
static_assert(sizeof(UKillerFormSwitchingTransitionInteraction) == 0x000780, "Wrong size on UKillerFormSwitchingTransitionInteraction");
static_assert(offsetof(UKillerFormSwitchingTransitionInteraction, _targetFormToTransitionIsNextForm) == 0x000778, "Member 'UKillerFormSwitchingTransitionInteraction::_targetFormToTransitionIsNextForm' has a wrong offset!");

// Class DBDGameplay.KillerInstinctComponent
// 0x0178 (0x0220 - 0x00A8)
class UKillerInstinctComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCustomKillerInstinctData              _defaultKillerInstinctAsset;                       // 0x00B0(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      _particleSystemComponent;                          // 0x00D8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E0[0x4];                                       // 0x00E0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           _camperHighlightColorOverride;                     // 0x00E4(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F4[0xAC];                                      // 0x00F4(0x00AC)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCustomKillerInstinctData>      _customKillerInstinctData;                         // 0x01A0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	struct FCustomKillerInstinctData              _currentKillerInstinctData;                        // 0x01B0(0x0028)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1D8[0x48];                                     // 0x01D8(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UNiagaraComponent* GetParticleSystem();
	void OnKillerLocallyObservedChanged(bool LocallyObserved);
	void SetParticleSystem(class UNiagaraComponent* ParticleSystemComponent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerInstinctComponent">();
	}
	static class UKillerInstinctComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillerInstinctComponent>();
	}
};
static_assert(alignof(UKillerInstinctComponent) == 0x000008, "Wrong alignment on UKillerInstinctComponent");
static_assert(sizeof(UKillerInstinctComponent) == 0x000220, "Wrong size on UKillerInstinctComponent");
static_assert(offsetof(UKillerInstinctComponent, _defaultKillerInstinctAsset) == 0x0000B0, "Member 'UKillerInstinctComponent::_defaultKillerInstinctAsset' has a wrong offset!");
static_assert(offsetof(UKillerInstinctComponent, _particleSystemComponent) == 0x0000D8, "Member 'UKillerInstinctComponent::_particleSystemComponent' has a wrong offset!");
static_assert(offsetof(UKillerInstinctComponent, _camperHighlightColorOverride) == 0x0000E4, "Member 'UKillerInstinctComponent::_camperHighlightColorOverride' has a wrong offset!");
static_assert(offsetof(UKillerInstinctComponent, _customKillerInstinctData) == 0x0001A0, "Member 'UKillerInstinctComponent::_customKillerInstinctData' has a wrong offset!");
static_assert(offsetof(UKillerInstinctComponent, _currentKillerInstinctData) == 0x0001B0, "Member 'UKillerInstinctComponent::_currentKillerInstinctData' has a wrong offset!");

// Class DBDGameplay.KillerPowerUtilities
// 0x0000 (0x0030 - 0x0030)
class UKillerPowerUtilities final : public UBlueprintFunctionLibrary
{
public:
	static class AKillerPower* GetKillerPowerFromPlayer(const class ADBDPlayer* Player);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerPowerUtilities">();
	}
	static class UKillerPowerUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillerPowerUtilities>();
	}
};
static_assert(alignof(UKillerPowerUtilities) == 0x000008, "Wrong alignment on UKillerPowerUtilities");
static_assert(sizeof(UKillerPowerUtilities) == 0x000030, "Wrong size on UKillerPowerUtilities");

// Class DBDGameplay.KillerScoringComponent
// 0x0010 (0x00B8 - 0x00A8)
class UKillerScoringComponent : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x10];                                      // 0x00A8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerScoringComponent">();
	}
	static class UKillerScoringComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillerScoringComponent>();
	}
};
static_assert(alignof(UKillerScoringComponent) == 0x000008, "Wrong alignment on UKillerScoringComponent");
static_assert(sizeof(UKillerScoringComponent) == 0x0000B8, "Wrong size on UKillerScoringComponent");

// Class DBDGameplay.LockerExitInteraction
// 0x0010 (0x07C0 - 0x07B0)
class ULockerExitInteraction : public UClosetHideInteraction
{
public:
	uint8                                         Pad_7B0[0x10];                                     // 0x07B0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LockerExitInteraction">();
	}
	static class ULockerExitInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULockerExitInteraction>();
	}
};
static_assert(alignof(ULockerExitInteraction) == 0x000010, "Wrong alignment on ULockerExitInteraction");
static_assert(sizeof(ULockerExitInteraction) == 0x0007C0, "Wrong size on ULockerExitInteraction");

// Class DBDGameplay.LockerGrabInteraction
// 0x0010 (0x07C0 - 0x07B0)
class ULockerGrabInteraction : public USearchLockerInteraction
{
public:
	TSubclassOf<class UStatusEffect>              _lockerGrabBlindImmunity;                          // 0x07B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ACamperPlayer*                          _survivorInLocker;                                 // 0x07B8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LockerGrabInteraction">();
	}
	static class ULockerGrabInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULockerGrabInteraction>();
	}
};
static_assert(alignof(ULockerGrabInteraction) == 0x000010, "Wrong alignment on ULockerGrabInteraction");
static_assert(sizeof(ULockerGrabInteraction) == 0x0007C0, "Wrong size on ULockerGrabInteraction");
static_assert(offsetof(ULockerGrabInteraction, _lockerGrabBlindImmunity) == 0x0007B0, "Member 'ULockerGrabInteraction::_lockerGrabBlindImmunity' has a wrong offset!");
static_assert(offsetof(ULockerGrabInteraction, _survivorInLocker) == 0x0007B8, "Member 'ULockerGrabInteraction::_survivorInLocker' has a wrong offset!");

// Class DBDGameplay.LullabyFeedbackComponent
// 0x0050 (0x00F8 - 0x00A8)
class ULullabyFeedbackComponent : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x18];                                      // 0x00A8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLullabyKillerData>             _killersData;                                      // 0x00C0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_D0[0x28];                                      // 0x00D0(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LullabyFeedbackComponent">();
	}
	static class ULullabyFeedbackComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULullabyFeedbackComponent>();
	}
};
static_assert(alignof(ULullabyFeedbackComponent) == 0x000008, "Wrong alignment on ULullabyFeedbackComponent");
static_assert(sizeof(ULullabyFeedbackComponent) == 0x0000F8, "Wrong size on ULullabyFeedbackComponent");
static_assert(offsetof(ULullabyFeedbackComponent, _killersData) == 0x0000C0, "Member 'ULullabyFeedbackComponent::_killersData' has a wrong offset!");

// Class DBDGameplay.MapCollectable
// 0x0008 (0x05A0 - 0x0598)
class AMapCollectable : public ABaseCamperCollectable
{
public:
	uint8                                         Pad_598[0x8];                                      // 0x0598(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnReadMapInteractionFinished();

	class UActorKnowledgeCollection* GetActorKnowledgeCollection() const;
	class UChargeableComponent* GetChargeableComponent() const;
	class UChargerComponent* GetChargerComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapCollectable">();
	}
	static class AMapCollectable* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMapCollectable>();
	}
};
static_assert(alignof(AMapCollectable) == 0x000008, "Wrong alignment on AMapCollectable");
static_assert(sizeof(AMapCollectable) == 0x0005A0, "Wrong size on AMapCollectable");

// Class DBDGameplay.MapMarkerActor
// 0x0000 (0x02A0 - 0x02A0)
class AMapMarkerActor : public AActor
{
public:
	void OnDestroy();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapMarkerActor">();
	}
	static class AMapMarkerActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMapMarkerActor>();
	}
};
static_assert(alignof(AMapMarkerActor) == 0x000008, "Wrong alignment on AMapMarkerActor");
static_assert(sizeof(AMapMarkerActor) == 0x0002A0, "Wrong size on AMapMarkerActor");

// Class DBDGameplay.Medkit
// 0x0040 (0x05D8 - 0x0598)
class AMedkit : public ABaseCamperCollectable
{
public:
	class UAkComponent*                           _akComponent;                                      // 0x0598(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UChargerComponent*                      _charger;                                          // 0x05A0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystem*                        _dustRingTemplate;                                 // 0x05A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          _medkitGetAkEvent;                                 // 0x05B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          _medkitDropAkEvent;                                // 0x05B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioBank*                           _medkitBank;                                       // 0x05C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _healOtherChargeMultiplier;                        // 0x05C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5CC[0xC];                                      // 0x05CC(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_ConsumeIfNotInteracting();
	void Authority_OnAnyOngoingInteractionChanged(const bool IsInteracting);
	void Authority_OnChargeStateChange(const bool Empty);
	void OnMedkitHealedCamper(class ADBDPlayer* HealedPlayer);
	void UseCharge(float Seconds);

	float GetCharge() const;
	float GetChargeMultiplier() const;
	bool HasCharge() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Medkit">();
	}
	static class AMedkit* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMedkit>();
	}
};
static_assert(alignof(AMedkit) == 0x000008, "Wrong alignment on AMedkit");
static_assert(sizeof(AMedkit) == 0x0005D8, "Wrong size on AMedkit");
static_assert(offsetof(AMedkit, _akComponent) == 0x000598, "Member 'AMedkit::_akComponent' has a wrong offset!");
static_assert(offsetof(AMedkit, _charger) == 0x0005A0, "Member 'AMedkit::_charger' has a wrong offset!");
static_assert(offsetof(AMedkit, _dustRingTemplate) == 0x0005A8, "Member 'AMedkit::_dustRingTemplate' has a wrong offset!");
static_assert(offsetof(AMedkit, _medkitGetAkEvent) == 0x0005B0, "Member 'AMedkit::_medkitGetAkEvent' has a wrong offset!");
static_assert(offsetof(AMedkit, _medkitDropAkEvent) == 0x0005B8, "Member 'AMedkit::_medkitDropAkEvent' has a wrong offset!");
static_assert(offsetof(AMedkit, _medkitBank) == 0x0005C0, "Member 'AMedkit::_medkitBank' has a wrong offset!");
static_assert(offsetof(AMedkit, _healOtherChargeMultiplier) == 0x0005C8, "Member 'AMedkit::_healOtherChargeMultiplier' has a wrong offset!");

// Class DBDGameplay.PointsProvider
// 0x0000 (0x0030 - 0x0030)
class UPointsProvider : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PointsProvider">();
	}
	static class UPointsProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPointsProvider>();
	}
};
static_assert(alignof(UPointsProvider) == 0x000008, "Wrong alignment on UPointsProvider");
static_assert(sizeof(UPointsProvider) == 0x000030, "Wrong size on UPointsProvider");

// Class DBDGameplay.MeshSocketPointsProvider
// 0x0048 (0x0078 - 0x0030)
class UMeshSocketPointsProvider final : public UPointsProvider
{
public:
	struct FComponentReference                    _meshReference;                                    // 0x0030(0x0030)(Edit, NativeAccessSpecifierPrivate)
	class UMeshComponent*                         _mesh;                                             // 0x0060(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class FName>                           _sockets;                                          // 0x0068(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MeshSocketPointsProvider">();
	}
	static class UMeshSocketPointsProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMeshSocketPointsProvider>();
	}
};
static_assert(alignof(UMeshSocketPointsProvider) == 0x000008, "Wrong alignment on UMeshSocketPointsProvider");
static_assert(sizeof(UMeshSocketPointsProvider) == 0x000078, "Wrong size on UMeshSocketPointsProvider");
static_assert(offsetof(UMeshSocketPointsProvider, _meshReference) == 0x000030, "Member 'UMeshSocketPointsProvider::_meshReference' has a wrong offset!");
static_assert(offsetof(UMeshSocketPointsProvider, _mesh) == 0x000060, "Member 'UMeshSocketPointsProvider::_mesh' has a wrong offset!");
static_assert(offsetof(UMeshSocketPointsProvider, _sockets) == 0x000068, "Member 'UMeshSocketPointsProvider::_sockets' has a wrong offset!");

// Class DBDGameplay.MoveToGroundComponent
// 0x0010 (0x00B8 - 0x00A8)
class UMoveToGroundComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x10];                                      // 0x00A8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void MoveOwnerToGround();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoveToGroundComponent">();
	}
	static class UMoveToGroundComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoveToGroundComponent>();
	}
};
static_assert(alignof(UMoveToGroundComponent) == 0x000008, "Wrong alignment on UMoveToGroundComponent");
static_assert(sizeof(UMoveToGroundComponent) == 0x0000B8, "Wrong size on UMoveToGroundComponent");

// Class DBDGameplay.MultiSceneComponentPointProvider
// 0x0020 (0x0050 - 0x0030)
class UMultiSceneComponentPointProvider final : public UPointsProvider
{
public:
	TArray<struct FComponentReference>            _sceneReferences;                                  // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class USceneComponent*>                _sceneComponents;                                  // 0x0040(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MultiSceneComponentPointProvider">();
	}
	static class UMultiSceneComponentPointProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMultiSceneComponentPointProvider>();
	}
};
static_assert(alignof(UMultiSceneComponentPointProvider) == 0x000008, "Wrong alignment on UMultiSceneComponentPointProvider");
static_assert(sizeof(UMultiSceneComponentPointProvider) == 0x000050, "Wrong size on UMultiSceneComponentPointProvider");
static_assert(offsetof(UMultiSceneComponentPointProvider, _sceneReferences) == 0x000030, "Member 'UMultiSceneComponentPointProvider::_sceneReferences' has a wrong offset!");
static_assert(offsetof(UMultiSceneComponentPointProvider, _sceneComponents) == 0x000040, "Member 'UMultiSceneComponentPointProvider::_sceneComponents' has a wrong offset!");

// Class DBDGameplay.NearestOutsideMapBoundsLocator
// 0x0028 (0x00D0 - 0x00A8)
class UNearestOutsideMapBoundsLocator : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkComponent*                           _akComponent;                                      // 0x00B0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _maxDistanceFromBorderAllowed;                     // 0x00B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _heightOfOOBPosition;                              // 0x00BC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C0[0x10];                                      // 0x00C0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Client_InitializeAkLimitPointEvent();
	void OnGameBegin();
	void OnGameEnd(EEndGameReason EndGameReason);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NearestOutsideMapBoundsLocator">();
	}
	static class UNearestOutsideMapBoundsLocator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNearestOutsideMapBoundsLocator>();
	}
};
static_assert(alignof(UNearestOutsideMapBoundsLocator) == 0x000008, "Wrong alignment on UNearestOutsideMapBoundsLocator");
static_assert(sizeof(UNearestOutsideMapBoundsLocator) == 0x0000D0, "Wrong size on UNearestOutsideMapBoundsLocator");
static_assert(offsetof(UNearestOutsideMapBoundsLocator, _akComponent) == 0x0000B0, "Member 'UNearestOutsideMapBoundsLocator::_akComponent' has a wrong offset!");
static_assert(offsetof(UNearestOutsideMapBoundsLocator, _maxDistanceFromBorderAllowed) == 0x0000B8, "Member 'UNearestOutsideMapBoundsLocator::_maxDistanceFromBorderAllowed' has a wrong offset!");
static_assert(offsetof(UNearestOutsideMapBoundsLocator, _heightOfOOBPosition) == 0x0000BC, "Member 'UNearestOutsideMapBoundsLocator::_heightOfOOBPosition' has a wrong offset!");

// Class DBDGameplay.NiagaraBlockFeedback
// 0x0008 (0x02C8 - 0x02C0)
class ANiagaraBlockFeedback final : public AFadingBlockFeedback
{
public:
	class UNiagaraComponent*                      _effect;                                           // 0x02C0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiagaraBlockFeedback">();
	}
	static class ANiagaraBlockFeedback* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANiagaraBlockFeedback>();
	}
};
static_assert(alignof(ANiagaraBlockFeedback) == 0x000008, "Wrong alignment on ANiagaraBlockFeedback");
static_assert(sizeof(ANiagaraBlockFeedback) == 0x0002C8, "Wrong size on ANiagaraBlockFeedback");
static_assert(offsetof(ANiagaraBlockFeedback, _effect) == 0x0002C0, "Member 'ANiagaraBlockFeedback::_effect' has a wrong offset!");

// Class DBDGameplay.ParticleBlockFeedback
// 0x0008 (0x02C8 - 0x02C0)
class AParticleBlockFeedback : public AFadingBlockFeedback
{
public:
	class UParticleSystemComponent*               _effect;                                           // 0x02C0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleBlockFeedback">();
	}
	static class AParticleBlockFeedback* GetDefaultObj()
	{
		return GetDefaultObjImpl<AParticleBlockFeedback>();
	}
};
static_assert(alignof(AParticleBlockFeedback) == 0x000008, "Wrong alignment on AParticleBlockFeedback");
static_assert(sizeof(AParticleBlockFeedback) == 0x0002C8, "Wrong size on AParticleBlockFeedback");
static_assert(offsetof(AParticleBlockFeedback, _effect) == 0x0002C0, "Member 'AParticleBlockFeedback::_effect' has a wrong offset!");

// Class DBDGameplay.Passage
// 0x0120 (0x04C8 - 0x03A8)
class APassage final : public AInteractable
{
public:
	uint8                                         Pad_3A8[0x8];                                      // 0x03A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             _cosmetic_onPassageCosmeticStateChange;            // 0x03B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             _cosmetic_onPlayerInRangeOfPassageChanged;         // 0x03C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UBoxComponent*                          _enterInteractionZone;                             // 0x03D0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          _revealExitAuraZone;                               // 0x03D8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        _moveTowardsComponent;                             // 0x03E0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        _teleportEndPointComponent;                        // 0x03E8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        _teleportToIfStuckComponent;                       // 0x03F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3F8[0xC];                                      // 0x03F8(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   _debugOverridePassageTag;                          // 0x0404(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _debugOverrideConnectedPassageTag;                 // 0x0410(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EPassageCosmeticState                         _passageStartingCosmeticState;                     // 0x041C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_41D[0x3];                                      // 0x041D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class ADBDPlayer*, struct FPassagePlayerHandles> _playerEventHandles;                               // 0x0420(0x0050)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_470[0x10];                                     // 0x0470(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class USpawnedActorReplicationComponent*      _spawnedActorReplicationComponent;                 // 0x0480(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APassage*                               _connectedPassage;                                 // 0x0488(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _entranceRevealTime;                               // 0x0490(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _idleAudioRange;                                   // 0x0494(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _duringInteractionAudioRange;                      // 0x0498(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _entranceVFXDistance;                              // 0x049C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _entranceVFXDistanceMaxHeightOffset;               // 0x04A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isEntryPassage;                                   // 0x04A4(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isExitPassage;                                    // 0x04A5(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4A6[0x2];                                      // 0x04A6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                _cameraLocationOffset;                             // 0x04A8(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4C0[0x8];                                      // 0x04C0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_OnPlayerInRangeChanged(const bool InRange, const class ADBDPlayer* Player);
	void CosmeticPassageEventDelegate__DelegateSignature(EPassageCosmeticState NewState, EPassageCosmeticState OldState);
	void CosmeticPlayerInRangeOfPassageEvent__DelegateSignature(const class ADBDPlayer* Player, bool IsInRange);
	void Local_OnPlayerLeftGame(const struct FGameplayTag& GameplayTag, const struct FGameEventData& GameEventData);
	void Local_OnPlayerLocallyObservedChanged(bool IsObserved, const class ADBDPlayer* Player);
	void OnBeginOverlapRevealExitAuraZone(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnEndOverlapRevealExitAuraZone(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

	class APassage* GetConnectedPassage() const;
	EPassageCosmeticState GetPassageCosmeticState() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Passage">();
	}
	static class APassage* GetDefaultObj()
	{
		return GetDefaultObjImpl<APassage>();
	}
};
static_assert(alignof(APassage) == 0x000008, "Wrong alignment on APassage");
static_assert(sizeof(APassage) == 0x0004C8, "Wrong size on APassage");
static_assert(offsetof(APassage, _cosmetic_onPassageCosmeticStateChange) == 0x0003B0, "Member 'APassage::_cosmetic_onPassageCosmeticStateChange' has a wrong offset!");
static_assert(offsetof(APassage, _cosmetic_onPlayerInRangeOfPassageChanged) == 0x0003C0, "Member 'APassage::_cosmetic_onPlayerInRangeOfPassageChanged' has a wrong offset!");
static_assert(offsetof(APassage, _enterInteractionZone) == 0x0003D0, "Member 'APassage::_enterInteractionZone' has a wrong offset!");
static_assert(offsetof(APassage, _revealExitAuraZone) == 0x0003D8, "Member 'APassage::_revealExitAuraZone' has a wrong offset!");
static_assert(offsetof(APassage, _moveTowardsComponent) == 0x0003E0, "Member 'APassage::_moveTowardsComponent' has a wrong offset!");
static_assert(offsetof(APassage, _teleportEndPointComponent) == 0x0003E8, "Member 'APassage::_teleportEndPointComponent' has a wrong offset!");
static_assert(offsetof(APassage, _teleportToIfStuckComponent) == 0x0003F0, "Member 'APassage::_teleportToIfStuckComponent' has a wrong offset!");
static_assert(offsetof(APassage, _debugOverridePassageTag) == 0x000404, "Member 'APassage::_debugOverridePassageTag' has a wrong offset!");
static_assert(offsetof(APassage, _debugOverrideConnectedPassageTag) == 0x000410, "Member 'APassage::_debugOverrideConnectedPassageTag' has a wrong offset!");
static_assert(offsetof(APassage, _passageStartingCosmeticState) == 0x00041C, "Member 'APassage::_passageStartingCosmeticState' has a wrong offset!");
static_assert(offsetof(APassage, _playerEventHandles) == 0x000420, "Member 'APassage::_playerEventHandles' has a wrong offset!");
static_assert(offsetof(APassage, _spawnedActorReplicationComponent) == 0x000480, "Member 'APassage::_spawnedActorReplicationComponent' has a wrong offset!");
static_assert(offsetof(APassage, _connectedPassage) == 0x000488, "Member 'APassage::_connectedPassage' has a wrong offset!");
static_assert(offsetof(APassage, _entranceRevealTime) == 0x000490, "Member 'APassage::_entranceRevealTime' has a wrong offset!");
static_assert(offsetof(APassage, _idleAudioRange) == 0x000494, "Member 'APassage::_idleAudioRange' has a wrong offset!");
static_assert(offsetof(APassage, _duringInteractionAudioRange) == 0x000498, "Member 'APassage::_duringInteractionAudioRange' has a wrong offset!");
static_assert(offsetof(APassage, _entranceVFXDistance) == 0x00049C, "Member 'APassage::_entranceVFXDistance' has a wrong offset!");
static_assert(offsetof(APassage, _entranceVFXDistanceMaxHeightOffset) == 0x0004A0, "Member 'APassage::_entranceVFXDistanceMaxHeightOffset' has a wrong offset!");
static_assert(offsetof(APassage, _isEntryPassage) == 0x0004A4, "Member 'APassage::_isEntryPassage' has a wrong offset!");
static_assert(offsetof(APassage, _isExitPassage) == 0x0004A5, "Member 'APassage::_isExitPassage' has a wrong offset!");
static_assert(offsetof(APassage, _cameraLocationOffset) == 0x0004A8, "Member 'APassage::_cameraLocationOffset' has a wrong offset!");

// Class DBDGameplay.PassageEnterInteraction
// 0x0050 (0x07D0 - 0x0780)
class UPassageEnterInteraction final : public UInteractionDefinition
{
public:
	FMulticastInlineDelegateProperty_             _cosmetic_onPassageInteractionStarted;             // 0x0778(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         _enterMovePhaseSeconds;                            // 0x0788(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _transitionPhaseSeconds;                           // 0x078C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _exitMovePhaseSeconds;                             // 0x0790(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _targetSpringArmLength;                            // 0x0794(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _enterSequenceMoveDistance;                        // 0x0798(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _exitSequenceMoveDistance;                         // 0x079C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _stuckInPassageDistance;                           // 0x07A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7A4[0x8];                                      // 0x07A4(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCollisionProfileName                  _collisionProfileForSequence;                      // 0x07AC(0x000C)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	struct FCollisionProfileName                  _collisionProfileOnExit;                           // 0x07B8(0x000C)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7C4[0x4];                                      // 0x07C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UStatusEffect>              _preventRunningStatusEffect;                       // 0x07C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void CosmeticPassageInteractionEventDelegate__DelegateSignature(class ADBDPlayer* Player);

	class APassage* GetOwningPassage() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PassageEnterInteraction">();
	}
	static class UPassageEnterInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPassageEnterInteraction>();
	}
};
static_assert(alignof(UPassageEnterInteraction) == 0x000010, "Wrong alignment on UPassageEnterInteraction");
static_assert(sizeof(UPassageEnterInteraction) == 0x0007D0, "Wrong size on UPassageEnterInteraction");
static_assert(offsetof(UPassageEnterInteraction, _cosmetic_onPassageInteractionStarted) == 0x000778, "Member 'UPassageEnterInteraction::_cosmetic_onPassageInteractionStarted' has a wrong offset!");
static_assert(offsetof(UPassageEnterInteraction, _enterMovePhaseSeconds) == 0x000788, "Member 'UPassageEnterInteraction::_enterMovePhaseSeconds' has a wrong offset!");
static_assert(offsetof(UPassageEnterInteraction, _transitionPhaseSeconds) == 0x00078C, "Member 'UPassageEnterInteraction::_transitionPhaseSeconds' has a wrong offset!");
static_assert(offsetof(UPassageEnterInteraction, _exitMovePhaseSeconds) == 0x000790, "Member 'UPassageEnterInteraction::_exitMovePhaseSeconds' has a wrong offset!");
static_assert(offsetof(UPassageEnterInteraction, _targetSpringArmLength) == 0x000794, "Member 'UPassageEnterInteraction::_targetSpringArmLength' has a wrong offset!");
static_assert(offsetof(UPassageEnterInteraction, _enterSequenceMoveDistance) == 0x000798, "Member 'UPassageEnterInteraction::_enterSequenceMoveDistance' has a wrong offset!");
static_assert(offsetof(UPassageEnterInteraction, _exitSequenceMoveDistance) == 0x00079C, "Member 'UPassageEnterInteraction::_exitSequenceMoveDistance' has a wrong offset!");
static_assert(offsetof(UPassageEnterInteraction, _stuckInPassageDistance) == 0x0007A0, "Member 'UPassageEnterInteraction::_stuckInPassageDistance' has a wrong offset!");
static_assert(offsetof(UPassageEnterInteraction, _collisionProfileForSequence) == 0x0007AC, "Member 'UPassageEnterInteraction::_collisionProfileForSequence' has a wrong offset!");
static_assert(offsetof(UPassageEnterInteraction, _collisionProfileOnExit) == 0x0007B8, "Member 'UPassageEnterInteraction::_collisionProfileOnExit' has a wrong offset!");
static_assert(offsetof(UPassageEnterInteraction, _preventRunningStatusEffect) == 0x0007C8, "Member 'UPassageEnterInteraction::_preventRunningStatusEffect' has a wrong offset!");

// Class DBDGameplay.PlayerCameraAimDirectionProvider
// 0x0000 (0x0030 - 0x0030)
class UPlayerCameraAimDirectionProvider final : public UAimDirectionProvider
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerCameraAimDirectionProvider">();
	}
	static class UPlayerCameraAimDirectionProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerCameraAimDirectionProvider>();
	}
};
static_assert(alignof(UPlayerCameraAimDirectionProvider) == 0x000008, "Wrong alignment on UPlayerCameraAimDirectionProvider");
static_assert(sizeof(UPlayerCameraAimDirectionProvider) == 0x000030, "Wrong size on UPlayerCameraAimDirectionProvider");

// Class DBDGameplay.PlayerInteractionListenerComponent
// 0x0050 (0x00F8 - 0x00A8)
class UPlayerInteractionListenerComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x50];                                      // 0x00A8(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InteractionDelegate__DelegateSignature(class ADBDPlayer* Player, const struct FGameplayTag& InteractionSemantic);
	void InteractionMulticastDelegate__DelegateSignature(class ADBDPlayer* Player, const struct FGameplayTag& InteractionSemantic);
	void ListenToInteractionEnd(class ADBDPlayer* Player, const struct FGameplayTag& InteractionSemantic, const TDelegate<void(class ADBDPlayer* Player, const struct FGameplayTag& InteractionSemantic)>& InteractionDelegate);
	void ListenToInteractionStart(class ADBDPlayer* Player, const struct FGameplayTag& InteractionSemantic, const TDelegate<void(class ADBDPlayer* Player, const struct FGameplayTag& InteractionSemantic)>& InteractionDelegate);
	void OnActorDestroyed(class AActor* DestroyedActor);
	void UnlistenToInteractionEnd(class ADBDPlayer* Player, const struct FGameplayTag& InteractionSemantic);
	void UnlistenToInteractionStart(class ADBDPlayer* Player, const struct FGameplayTag& InteractionSemantic);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerInteractionListenerComponent">();
	}
	static class UPlayerInteractionListenerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerInteractionListenerComponent>();
	}
};
static_assert(alignof(UPlayerInteractionListenerComponent) == 0x000008, "Wrong alignment on UPlayerInteractionListenerComponent");
static_assert(sizeof(UPlayerInteractionListenerComponent) == 0x0000F8, "Wrong size on UPlayerInteractionListenerComponent");

// Class DBDGameplay.PlayerMovementUtilities
// 0x0000 (0x0030 - 0x0030)
class UPlayerMovementUtilities final : public UBlueprintFunctionLibrary
{
public:
	static void Local_ApplyGamepadPitchScaleMultiplier(class ADBDPlayer* Player, const float Multiplier, const float AdjustmentTime);
	static void Local_ApplyGamepadYawScaleMultiplier(class ADBDPlayer* Player, const float Multiplier, const float AdjustmentTime);
	static void Local_ApplyMousePitchScaleMultiplier(class ADBDPlayer* Player, const float Multiplier, const float AdjustmentTime);
	static void Local_ApplyMouseYawScaleMultiplier(class ADBDPlayer* Player, const float Multiplier, const float AdjustmentTime);
	static void Local_ApplyPitchScaleMultiplier(class ADBDPlayer* Player, const float Multiplier, const float AdjustmentTime);
	static void Local_ApplyRotationScaleMultiplier(class ADBDPlayer* Player, const float Multiplier, const float AdjustmentTime);
	static void Local_ApplyYawScaleMultiplier(class ADBDPlayer* Player, const float Multiplier, const float AdjustmentTime);
	static void Local_ResetGamepadLookCurves(class ADBDPlayer* Player);
	static void Local_ResetRotationScale(class ADBDPlayer* Player, const float AdjustmentTime);
	static void Local_SetGamepadPitchCurve(class ADBDPlayer* Player, class UCurveFloat* Curve);
	static void Local_SetGamepadYawCurve(class ADBDPlayer* Player, class UCurveFloat* Curve);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerMovementUtilities">();
	}
	static class UPlayerMovementUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerMovementUtilities>();
	}
};
static_assert(alignof(UPlayerMovementUtilities) == 0x000008, "Wrong alignment on UPlayerMovementUtilities");
static_assert(sizeof(UPlayerMovementUtilities) == 0x000030, "Wrong size on UPlayerMovementUtilities");

// Class DBDGameplay.PlayersInZoneTracker
// 0x00A0 (0x0148 - 0x00A8)
class UPlayersInZoneTracker final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x30];                                      // 0x00A8(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             Cosmetic_OnPlayerEnterZone;                        // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             Cosmetic_OnPlayerExitZone;                         // 0x00E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	TArray<struct FGameplayTag>                   _tagsPreventingEnteringRange;                      // 0x00F8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FGameplayTag>                   _tagsToAddToPlayerInZone;                          // 0x0108(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class USphereComponent*                       _playerTracker;                                    // 0x0118(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<TWeakObjectPtr<class ADBDPlayer>>      _playersInRange;                                   // 0x0120(0x0010)(Net, ZeroConstructor, RepNotify, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_130[0x18];                                     // 0x0130(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnBeginPlayerOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void Authority_OnEndPlayerOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void OnCosmeticNeeded__DelegateSignature(class ADBDPlayer* Player);
	void OnRep_PlayersInRange();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayersInZoneTracker">();
	}
	static class UPlayersInZoneTracker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayersInZoneTracker>();
	}
};
static_assert(alignof(UPlayersInZoneTracker) == 0x000008, "Wrong alignment on UPlayersInZoneTracker");
static_assert(sizeof(UPlayersInZoneTracker) == 0x000148, "Wrong size on UPlayersInZoneTracker");
static_assert(offsetof(UPlayersInZoneTracker, Cosmetic_OnPlayerEnterZone) == 0x0000D8, "Member 'UPlayersInZoneTracker::Cosmetic_OnPlayerEnterZone' has a wrong offset!");
static_assert(offsetof(UPlayersInZoneTracker, Cosmetic_OnPlayerExitZone) == 0x0000E8, "Member 'UPlayersInZoneTracker::Cosmetic_OnPlayerExitZone' has a wrong offset!");
static_assert(offsetof(UPlayersInZoneTracker, _tagsPreventingEnteringRange) == 0x0000F8, "Member 'UPlayersInZoneTracker::_tagsPreventingEnteringRange' has a wrong offset!");
static_assert(offsetof(UPlayersInZoneTracker, _tagsToAddToPlayerInZone) == 0x000108, "Member 'UPlayersInZoneTracker::_tagsToAddToPlayerInZone' has a wrong offset!");
static_assert(offsetof(UPlayersInZoneTracker, _playerTracker) == 0x000118, "Member 'UPlayersInZoneTracker::_playerTracker' has a wrong offset!");
static_assert(offsetof(UPlayersInZoneTracker, _playersInRange) == 0x000120, "Member 'UPlayersInZoneTracker::_playersInRange' has a wrong offset!");

// Class DBDGameplay.ZoneComponent
// 0x0030 (0x00D8 - 0x00A8)
class UZoneComponent : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x20];                                      // 0x00A8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           _currentZoneTag;                                   // 0x00C8(0x000C)(Net, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_CurrentZone();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ZoneComponent">();
	}
	static class UZoneComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UZoneComponent>();
	}
};
static_assert(alignof(UZoneComponent) == 0x000008, "Wrong alignment on UZoneComponent");
static_assert(sizeof(UZoneComponent) == 0x0000D8, "Wrong size on UZoneComponent");
static_assert(offsetof(UZoneComponent, _currentZoneTag) == 0x0000C8, "Member 'UZoneComponent::_currentZoneTag' has a wrong offset!");

// Class DBDGameplay.PlayerZoneComponent
// 0x0000 (0x00D8 - 0x00D8)
class UPlayerZoneComponent final : public UZoneComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerZoneComponent">();
	}
	static class UPlayerZoneComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerZoneComponent>();
	}
};
static_assert(alignof(UPlayerZoneComponent) == 0x000008, "Wrong alignment on UPlayerZoneComponent");
static_assert(sizeof(UPlayerZoneComponent) == 0x0000D8, "Wrong size on UPlayerZoneComponent");

// Class DBDGameplay.PositionLagCompensationComponent
// 0x0008 (0x00B0 - 0x00A8)
class UPositionLagCompensationComponent final : public UActorComponent
{
public:
	float                                         _maxExtrapolationDurationInSeconds;                // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _maxInterpolationToServerMoveInSeconds;            // 0x00AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PositionLagCompensationComponent">();
	}
	static class UPositionLagCompensationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPositionLagCompensationComponent>();
	}
};
static_assert(alignof(UPositionLagCompensationComponent) == 0x000008, "Wrong alignment on UPositionLagCompensationComponent");
static_assert(sizeof(UPositionLagCompensationComponent) == 0x0000B0, "Wrong size on UPositionLagCompensationComponent");
static_assert(offsetof(UPositionLagCompensationComponent, _maxExtrapolationDurationInSeconds) == 0x0000A8, "Member 'UPositionLagCompensationComponent::_maxExtrapolationDurationInSeconds' has a wrong offset!");
static_assert(offsetof(UPositionLagCompensationComponent, _maxInterpolationToServerMoveInSeconds) == 0x0000AC, "Member 'UPositionLagCompensationComponent::_maxInterpolationToServerMoveInSeconds' has a wrong offset!");

// Class DBDGameplay.PowerChargeComponent
// 0x00A8 (0x0150 - 0x00A8)
class UPowerChargeComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnPowerChargeChanged;                              // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_B8[0x54];                                      // 0x00B8(0x0054)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _chargeRate;                                       // 0x010C(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FSpeedBasedNetSyncedValue              _currentCharge;                                    // 0x0110(0x0038)(Net, Transient, RepNotify, NativeAccessSpecifierPrivate)
	uint8                                         Pad_148[0x4];                                      // 0x0148(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _forceFullCharge;                                  // 0x014C(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_14D[0x3];                                      // 0x014D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCurrentChargeChanged(float Value);
	void OnRep_CurrentCharge();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PowerChargeComponent">();
	}
	static class UPowerChargeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPowerChargeComponent>();
	}
};
static_assert(alignof(UPowerChargeComponent) == 0x000008, "Wrong alignment on UPowerChargeComponent");
static_assert(sizeof(UPowerChargeComponent) == 0x000150, "Wrong size on UPowerChargeComponent");
static_assert(offsetof(UPowerChargeComponent, OnPowerChargeChanged) == 0x0000A8, "Member 'UPowerChargeComponent::OnPowerChargeChanged' has a wrong offset!");
static_assert(offsetof(UPowerChargeComponent, _chargeRate) == 0x00010C, "Member 'UPowerChargeComponent::_chargeRate' has a wrong offset!");
static_assert(offsetof(UPowerChargeComponent, _currentCharge) == 0x000110, "Member 'UPowerChargeComponent::_currentCharge' has a wrong offset!");
static_assert(offsetof(UPowerChargeComponent, _forceFullCharge) == 0x00014C, "Member 'UPowerChargeComponent::_forceFullCharge' has a wrong offset!");

// Class DBDGameplay.PowerChargePresentationItemProgressComponent
// 0x0018 (0x00C8 - 0x00B0)
class UPowerChargePresentationItemProgressComponent final : public UPresentationItemProgressComponent
{
public:
	class UPowerChargeComponent*                  _powerChargeComponent;                             // 0x00B0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPowerToggleComponent*                  _powerToggleComponent;                             // 0x00B8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _chargeReadyThreshold;                             // 0x00C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C4[0x4];                                       // 0x00C4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PowerChargePresentationItemProgressComponent">();
	}
	static class UPowerChargePresentationItemProgressComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPowerChargePresentationItemProgressComponent>();
	}
};
static_assert(alignof(UPowerChargePresentationItemProgressComponent) == 0x000008, "Wrong alignment on UPowerChargePresentationItemProgressComponent");
static_assert(sizeof(UPowerChargePresentationItemProgressComponent) == 0x0000C8, "Wrong size on UPowerChargePresentationItemProgressComponent");
static_assert(offsetof(UPowerChargePresentationItemProgressComponent, _powerChargeComponent) == 0x0000B0, "Member 'UPowerChargePresentationItemProgressComponent::_powerChargeComponent' has a wrong offset!");
static_assert(offsetof(UPowerChargePresentationItemProgressComponent, _powerToggleComponent) == 0x0000B8, "Member 'UPowerChargePresentationItemProgressComponent::_powerToggleComponent' has a wrong offset!");
static_assert(offsetof(UPowerChargePresentationItemProgressComponent, _chargeReadyThreshold) == 0x0000C0, "Member 'UPowerChargePresentationItemProgressComponent::_chargeReadyThreshold' has a wrong offset!");

// Class DBDGameplay.RacoonDogComponent
// 0x0180 (0x0228 - 0x00A8)
class URacoonDogComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             _cosmetic_onLookingAtTimerCompleted;               // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             _onHideActor;                                      // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             _onWasActivatedResetDebug;                         // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	class UDBDSkeletalMeshComponentBudgeted*      _cachedAnimatedSkeletalMesh;                       // 0x00D8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E0[0x120];                                     // 0x00E0(0x0120)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _wasActivated;                                     // 0x0200(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_201[0x1];                                      // 0x0201(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         _selectedMontageIndex;                             // 0x0202(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_203[0x5];                                      // 0x0203(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRandomAnimationMontage>        _animationMontages;                                // 0x0208(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	float                                         _activationRange;                                  // 0x0218(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _secondsToLookAtActor;                             // 0x021C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _destroyActorAfterIdleTime;                        // 0x0220(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _precisionAngleDegrees;                            // 0x0224(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Authority_OnDeleteActorTimerCompleted();
	void Authority_OnIsLookingTowardsTimerFinished();
	void Authority_OnPlayerInRangeChanged(class AActor* PlayerActor, const bool IsInRange);
	void Authority_OnPlayerIsLookingTowardsChanged(const bool IsLookingTowards, const class ADBDPlayer* Player);
	void Authority_OnPossessedPawnChanged(class APawn* OldPawn, class APawn* NewPawn);
	void DBD_ResetRacoonDogWasActivated();
	void DBD_SetSelectedRacoonDogAnimIndex(const uint8 Param_Index);
	void OnAnimationMontageCompleted();
	void OnRep_WasActivated();
	void RacoonDogEventDelegate__DelegateSignature();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RacoonDogComponent">();
	}
	static class URacoonDogComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URacoonDogComponent>();
	}
};
static_assert(alignof(URacoonDogComponent) == 0x000008, "Wrong alignment on URacoonDogComponent");
static_assert(sizeof(URacoonDogComponent) == 0x000228, "Wrong size on URacoonDogComponent");
static_assert(offsetof(URacoonDogComponent, _cosmetic_onLookingAtTimerCompleted) == 0x0000A8, "Member 'URacoonDogComponent::_cosmetic_onLookingAtTimerCompleted' has a wrong offset!");
static_assert(offsetof(URacoonDogComponent, _onHideActor) == 0x0000B8, "Member 'URacoonDogComponent::_onHideActor' has a wrong offset!");
static_assert(offsetof(URacoonDogComponent, _onWasActivatedResetDebug) == 0x0000C8, "Member 'URacoonDogComponent::_onWasActivatedResetDebug' has a wrong offset!");
static_assert(offsetof(URacoonDogComponent, _cachedAnimatedSkeletalMesh) == 0x0000D8, "Member 'URacoonDogComponent::_cachedAnimatedSkeletalMesh' has a wrong offset!");
static_assert(offsetof(URacoonDogComponent, _wasActivated) == 0x000200, "Member 'URacoonDogComponent::_wasActivated' has a wrong offset!");
static_assert(offsetof(URacoonDogComponent, _selectedMontageIndex) == 0x000202, "Member 'URacoonDogComponent::_selectedMontageIndex' has a wrong offset!");
static_assert(offsetof(URacoonDogComponent, _animationMontages) == 0x000208, "Member 'URacoonDogComponent::_animationMontages' has a wrong offset!");
static_assert(offsetof(URacoonDogComponent, _activationRange) == 0x000218, "Member 'URacoonDogComponent::_activationRange' has a wrong offset!");
static_assert(offsetof(URacoonDogComponent, _secondsToLookAtActor) == 0x00021C, "Member 'URacoonDogComponent::_secondsToLookAtActor' has a wrong offset!");
static_assert(offsetof(URacoonDogComponent, _destroyActorAfterIdleTime) == 0x000220, "Member 'URacoonDogComponent::_destroyActorAfterIdleTime' has a wrong offset!");
static_assert(offsetof(URacoonDogComponent, _precisionAngleDegrees) == 0x000224, "Member 'URacoonDogComponent::_precisionAngleDegrees' has a wrong offset!");

// Class DBDGameplay.RangedExplosiveEffectHandlerComponent
// 0x0070 (0x0118 - 0x00A8)
class URangedExplosiveEffectHandlerComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnRangedExplosiveInRangeBegin;                     // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRangedExplosiveInRangeEnd;                       // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TSet<class ARangedExplosive*>                 _inRangeRangedExplosives;                          // 0x00C8(0x0050)(Transient, NativeAccessSpecifierPrivate)

public:
	void OnRangedExplosiveDestroyed(class AActor* DestroyedActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RangedExplosiveEffectHandlerComponent">();
	}
	static class URangedExplosiveEffectHandlerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URangedExplosiveEffectHandlerComponent>();
	}
};
static_assert(alignof(URangedExplosiveEffectHandlerComponent) == 0x000008, "Wrong alignment on URangedExplosiveEffectHandlerComponent");
static_assert(sizeof(URangedExplosiveEffectHandlerComponent) == 0x000118, "Wrong size on URangedExplosiveEffectHandlerComponent");
static_assert(offsetof(URangedExplosiveEffectHandlerComponent, OnRangedExplosiveInRangeBegin) == 0x0000A8, "Member 'URangedExplosiveEffectHandlerComponent::OnRangedExplosiveInRangeBegin' has a wrong offset!");
static_assert(offsetof(URangedExplosiveEffectHandlerComponent, OnRangedExplosiveInRangeEnd) == 0x0000B8, "Member 'URangedExplosiveEffectHandlerComponent::OnRangedExplosiveInRangeEnd' has a wrong offset!");
static_assert(offsetof(URangedExplosiveEffectHandlerComponent, _inRangeRangedExplosives) == 0x0000C8, "Member 'URangedExplosiveEffectHandlerComponent::_inRangeRangedExplosives' has a wrong offset!");

// Class DBDGameplay.RangeToActorsTrackerComponent
// 0x0010 (0x00B8 - 0x00A8)
class URangeToActorsTrackerComponent final : public UActorComponent
{
public:
	TArray<class URangeToActorsTrackerStrategy*>  _rangeTrackers;                                    // 0x00A8(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, NoClear, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	void OnLevelReadyToPlay();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RangeToActorsTrackerComponent">();
	}
	static class URangeToActorsTrackerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URangeToActorsTrackerComponent>();
	}
};
static_assert(alignof(URangeToActorsTrackerComponent) == 0x000008, "Wrong alignment on URangeToActorsTrackerComponent");
static_assert(sizeof(URangeToActorsTrackerComponent) == 0x0000B8, "Wrong size on URangeToActorsTrackerComponent");
static_assert(offsetof(URangeToActorsTrackerComponent, _rangeTrackers) == 0x0000A8, "Member 'URangeToActorsTrackerComponent::_rangeTrackers' has a wrong offset!");

// Class DBDGameplay.RangeToActorsTrackerDefaultStrategy
// 0x0008 (0x0078 - 0x0070)
class URangeToActorsTrackerDefaultStrategy final : public URangeToActorsTrackerStrategy
{
public:
	TSubclassOf<class AActor>                     _actorClass;                                       // 0x0070(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RangeToActorsTrackerDefaultStrategy">();
	}
	static class URangeToActorsTrackerDefaultStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<URangeToActorsTrackerDefaultStrategy>();
	}
};
static_assert(alignof(URangeToActorsTrackerDefaultStrategy) == 0x000008, "Wrong alignment on URangeToActorsTrackerDefaultStrategy");
static_assert(sizeof(URangeToActorsTrackerDefaultStrategy) == 0x000078, "Wrong size on URangeToActorsTrackerDefaultStrategy");
static_assert(offsetof(URangeToActorsTrackerDefaultStrategy, _actorClass) == 0x000070, "Member 'URangeToActorsTrackerDefaultStrategy::_actorClass' has a wrong offset!");

// Class DBDGameplay.ReadMapInteraction
// 0x0010 (0x08D0 - 0x08C0)
class UReadMapInteraction : public UChargeableInteractionDefinition
{
public:
	bool                                          _chargeCompleted;                                  // 0x08C0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8C1[0xF];                                      // 0x08C1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReadMapInteraction">();
	}
	static class UReadMapInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReadMapInteraction>();
	}
};
static_assert(alignof(UReadMapInteraction) == 0x000010, "Wrong alignment on UReadMapInteraction");
static_assert(sizeof(UReadMapInteraction) == 0x0008D0, "Wrong size on UReadMapInteraction");
static_assert(offsetof(UReadMapInteraction, _chargeCompleted) == 0x0008C0, "Member 'UReadMapInteraction::_chargeCompleted' has a wrong offset!");

// Class DBDGameplay.RespawnableComponent
// 0x01F8 (0x02A0 - 0x00A8)
class URespawnableComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x30];                                      // 0x00A8(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             Cosmetic_OnRespawn;                                // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             Cosmetic_OnDespawn;                                // 0x00E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             Cosmetic_OnFirstSpawn;                             // 0x00F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnTeleportSucceded;                                // 0x0108(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	bool                                          _hasStartedRespawning;                             // 0x0118(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _hasExceededMinRespawnTime;                        // 0x0119(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EGameplayElementType                          _gameplayElementSpawnType;                         // 0x011A(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ETileSpawnPointType                           _tileSpawnType;                                    // 0x011B(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_11C[0x4];                                      // 0x011C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        _spawnElementInUse;                                // 0x0120(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _usesTimers;                                       // 0x0128(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_129[0x7];                                      // 0x0129(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _respawnFrequencyMin;                              // 0x0130(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _respawnFrequencyMax;                              // 0x0158(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	float                                         _disappearDuration;                                // 0x0180(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _minTimeBetweenRespawns;                           // 0x0184(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _spawnHeightOffset;                                // 0x0188(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_18C[0x34];                                     // 0x018C(0x0034)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _usesGameplayElementSpawner;                       // 0x01C0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1C1[0x67];                                     // 0x01C1(0x0067)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                _actorLocation;                                    // 0x0228(0x0018)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_240[0x4];                                      // 0x0240(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _collisionCapsuleHalfHeight;                       // 0x0244(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _collisionCapsuleRadius;                           // 0x0248(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_24C[0x4];                                      // 0x024C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UDebugTimerLogComponent*                _debugLogTimer;                                    // 0x0250(0x0008)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _onlyLimitDistanceBetweenSameActorType;            // 0x0258(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_259[0x7];                                      // 0x0259(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _minDistanceFromActivatedSpawnElements;            // 0x0260(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	bool                                          _allowSpawnEvenWithNonBlockingOverlaps;            // 0x0288(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _canUseFallbackSpawnElement;                       // 0x0289(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_28A[0x6];                                      // 0x028A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ECollisionChannel>                     _collisionChannelsToCheckOnRespawn;                // 0x0290(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	void Authority_OnMinRespawnTimerDone();
	void Authority_OnTimerDone();
	bool Authority_TryTeleport();
	void OnCosmeticNeeded__DelegateSignature();
	void OnDespawnCosmeticsComplete();
	void OnLevelReadyToPlay();
	void OnRep_OnLocationChanged();
	void OnTeleportSucceded__DelegateSignature();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RespawnableComponent">();
	}
	static class URespawnableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URespawnableComponent>();
	}
};
static_assert(alignof(URespawnableComponent) == 0x000008, "Wrong alignment on URespawnableComponent");
static_assert(sizeof(URespawnableComponent) == 0x0002A0, "Wrong size on URespawnableComponent");
static_assert(offsetof(URespawnableComponent, Cosmetic_OnRespawn) == 0x0000D8, "Member 'URespawnableComponent::Cosmetic_OnRespawn' has a wrong offset!");
static_assert(offsetof(URespawnableComponent, Cosmetic_OnDespawn) == 0x0000E8, "Member 'URespawnableComponent::Cosmetic_OnDespawn' has a wrong offset!");
static_assert(offsetof(URespawnableComponent, Cosmetic_OnFirstSpawn) == 0x0000F8, "Member 'URespawnableComponent::Cosmetic_OnFirstSpawn' has a wrong offset!");
static_assert(offsetof(URespawnableComponent, OnTeleportSucceded) == 0x000108, "Member 'URespawnableComponent::OnTeleportSucceded' has a wrong offset!");
static_assert(offsetof(URespawnableComponent, _hasStartedRespawning) == 0x000118, "Member 'URespawnableComponent::_hasStartedRespawning' has a wrong offset!");
static_assert(offsetof(URespawnableComponent, _hasExceededMinRespawnTime) == 0x000119, "Member 'URespawnableComponent::_hasExceededMinRespawnTime' has a wrong offset!");
static_assert(offsetof(URespawnableComponent, _gameplayElementSpawnType) == 0x00011A, "Member 'URespawnableComponent::_gameplayElementSpawnType' has a wrong offset!");
static_assert(offsetof(URespawnableComponent, _tileSpawnType) == 0x00011B, "Member 'URespawnableComponent::_tileSpawnType' has a wrong offset!");
static_assert(offsetof(URespawnableComponent, _spawnElementInUse) == 0x000120, "Member 'URespawnableComponent::_spawnElementInUse' has a wrong offset!");
static_assert(offsetof(URespawnableComponent, _usesTimers) == 0x000128, "Member 'URespawnableComponent::_usesTimers' has a wrong offset!");
static_assert(offsetof(URespawnableComponent, _respawnFrequencyMin) == 0x000130, "Member 'URespawnableComponent::_respawnFrequencyMin' has a wrong offset!");
static_assert(offsetof(URespawnableComponent, _respawnFrequencyMax) == 0x000158, "Member 'URespawnableComponent::_respawnFrequencyMax' has a wrong offset!");
static_assert(offsetof(URespawnableComponent, _disappearDuration) == 0x000180, "Member 'URespawnableComponent::_disappearDuration' has a wrong offset!");
static_assert(offsetof(URespawnableComponent, _minTimeBetweenRespawns) == 0x000184, "Member 'URespawnableComponent::_minTimeBetweenRespawns' has a wrong offset!");
static_assert(offsetof(URespawnableComponent, _spawnHeightOffset) == 0x000188, "Member 'URespawnableComponent::_spawnHeightOffset' has a wrong offset!");
static_assert(offsetof(URespawnableComponent, _usesGameplayElementSpawner) == 0x0001C0, "Member 'URespawnableComponent::_usesGameplayElementSpawner' has a wrong offset!");
static_assert(offsetof(URespawnableComponent, _actorLocation) == 0x000228, "Member 'URespawnableComponent::_actorLocation' has a wrong offset!");
static_assert(offsetof(URespawnableComponent, _collisionCapsuleHalfHeight) == 0x000244, "Member 'URespawnableComponent::_collisionCapsuleHalfHeight' has a wrong offset!");
static_assert(offsetof(URespawnableComponent, _collisionCapsuleRadius) == 0x000248, "Member 'URespawnableComponent::_collisionCapsuleRadius' has a wrong offset!");
static_assert(offsetof(URespawnableComponent, _debugLogTimer) == 0x000250, "Member 'URespawnableComponent::_debugLogTimer' has a wrong offset!");
static_assert(offsetof(URespawnableComponent, _onlyLimitDistanceBetweenSameActorType) == 0x000258, "Member 'URespawnableComponent::_onlyLimitDistanceBetweenSameActorType' has a wrong offset!");
static_assert(offsetof(URespawnableComponent, _minDistanceFromActivatedSpawnElements) == 0x000260, "Member 'URespawnableComponent::_minDistanceFromActivatedSpawnElements' has a wrong offset!");
static_assert(offsetof(URespawnableComponent, _allowSpawnEvenWithNonBlockingOverlaps) == 0x000288, "Member 'URespawnableComponent::_allowSpawnEvenWithNonBlockingOverlaps' has a wrong offset!");
static_assert(offsetof(URespawnableComponent, _canUseFallbackSpawnElement) == 0x000289, "Member 'URespawnableComponent::_canUseFallbackSpawnElement' has a wrong offset!");
static_assert(offsetof(URespawnableComponent, _collisionChannelsToCheckOnRespawn) == 0x000290, "Member 'URespawnableComponent::_collisionChannelsToCheckOnRespawn' has a wrong offset!");

// Class DBDGameplay.SceneComponentPointProvider
// 0x0038 (0x0068 - 0x0030)
class USceneComponentPointProvider final : public UPointsProvider
{
public:
	struct FComponentReference                    _sceneReference;                                   // 0x0030(0x0030)(Edit, NativeAccessSpecifierPrivate)
	class USceneComponent*                        _sceneComponent;                                   // 0x0060(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SceneComponentPointProvider">();
	}
	static class USceneComponentPointProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<USceneComponentPointProvider>();
	}
};
static_assert(alignof(USceneComponentPointProvider) == 0x000008, "Wrong alignment on USceneComponentPointProvider");
static_assert(sizeof(USceneComponentPointProvider) == 0x000068, "Wrong size on USceneComponentPointProvider");
static_assert(offsetof(USceneComponentPointProvider, _sceneReference) == 0x000030, "Member 'USceneComponentPointProvider::_sceneReference' has a wrong offset!");
static_assert(offsetof(USceneComponentPointProvider, _sceneComponent) == 0x000060, "Member 'USceneComponentPointProvider::_sceneComponent' has a wrong offset!");

// Class DBDGameplay.StaticMeshBlockFeedback
// 0x0010 (0x02D0 - 0x02C0)
class AStaticMeshBlockFeedback : public AFadingBlockFeedback
{
public:
	class UStaticMeshComponent*                   _mesh;                                             // 0x02C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialHelper*                        _materialHelper;                                   // 0x02C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StaticMeshBlockFeedback">();
	}
	static class AStaticMeshBlockFeedback* GetDefaultObj()
	{
		return GetDefaultObjImpl<AStaticMeshBlockFeedback>();
	}
};
static_assert(alignof(AStaticMeshBlockFeedback) == 0x000008, "Wrong alignment on AStaticMeshBlockFeedback");
static_assert(sizeof(AStaticMeshBlockFeedback) == 0x0002D0, "Wrong size on AStaticMeshBlockFeedback");
static_assert(offsetof(AStaticMeshBlockFeedback, _mesh) == 0x0002C0, "Member 'AStaticMeshBlockFeedback::_mesh' has a wrong offset!");
static_assert(offsetof(AStaticMeshBlockFeedback, _materialHelper) == 0x0002C8, "Member 'AStaticMeshBlockFeedback::_materialHelper' has a wrong offset!");

// Class DBDGameplay.SteamPipe
// 0x00E8 (0x0388 - 0x02A0)
class ASteamPipe final : public AActor
{
public:
	uint8                                         Pad_2A0[0x18];                                     // 0x02A0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UBoxComponent*                          _overlapVolume;                                    // 0x02B8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ESteamPipeState                               _currentSteamPipeState;                            // 0x02C0(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C1[0x7];                                      // 0x02C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class USteamPipeEffectComponent>> _overlappingPlayerComponents;                      // 0x02C8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D8[0x30];                                     // 0x02D8(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _debugResetTimer;                                  // 0x0308(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_30C[0x4];                                      // 0x030C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _warningStateTime;                                 // 0x0310(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _activeTime;                                       // 0x0338(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _warningStateTimeNoCharge;                         // 0x0360(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	void Authority_OnBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void Authority_OnEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void Cosmetic_OnSteamPipeStateChanged(ESteamPipeState NewState);
	void OnRep_SteamPipeState();

	ESteamPipeState GetCurrentSteamPipeState() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamPipe">();
	}
	static class ASteamPipe* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASteamPipe>();
	}
};
static_assert(alignof(ASteamPipe) == 0x000008, "Wrong alignment on ASteamPipe");
static_assert(sizeof(ASteamPipe) == 0x000388, "Wrong size on ASteamPipe");
static_assert(offsetof(ASteamPipe, _overlapVolume) == 0x0002B8, "Member 'ASteamPipe::_overlapVolume' has a wrong offset!");
static_assert(offsetof(ASteamPipe, _currentSteamPipeState) == 0x0002C0, "Member 'ASteamPipe::_currentSteamPipeState' has a wrong offset!");
static_assert(offsetof(ASteamPipe, _overlappingPlayerComponents) == 0x0002C8, "Member 'ASteamPipe::_overlappingPlayerComponents' has a wrong offset!");
static_assert(offsetof(ASteamPipe, _debugResetTimer) == 0x000308, "Member 'ASteamPipe::_debugResetTimer' has a wrong offset!");
static_assert(offsetof(ASteamPipe, _warningStateTime) == 0x000310, "Member 'ASteamPipe::_warningStateTime' has a wrong offset!");
static_assert(offsetof(ASteamPipe, _activeTime) == 0x000338, "Member 'ASteamPipe::_activeTime' has a wrong offset!");
static_assert(offsetof(ASteamPipe, _warningStateTimeNoCharge) == 0x000360, "Member 'ASteamPipe::_warningStateTimeNoCharge' has a wrong offset!");

// Class DBDGameplay.SteamPipeEffectComponent
// 0x0078 (0x0120 - 0x00A8)
class USteamPipeEffectComponent final : public UActorComponent
{
public:
	TSubclassOf<class UStatusEffect>              _hinderedEffectClass;                              // 0x00A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FGameplayTag>                   _stateTagsToIgnore;                                // 0x00B0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FTagStateBool                          _isInActiveSteamPipeZone;                          // 0x00C0(0x0048)(Net, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class ASteamPipe>              _overlappingSteamPipe;                             // 0x0108(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_110[0x10];                                     // 0x0110(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnHealthStateChanged(const struct FGameplayTag& GameplayTag, const struct FGameEventData& GameEventData);
	void Authority_OnStoppedCrouching(const struct FGameplayTag& GameplayTag, const struct FGameEventData& GameEventData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamPipeEffectComponent">();
	}
	static class USteamPipeEffectComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamPipeEffectComponent>();
	}
};
static_assert(alignof(USteamPipeEffectComponent) == 0x000008, "Wrong alignment on USteamPipeEffectComponent");
static_assert(sizeof(USteamPipeEffectComponent) == 0x000120, "Wrong size on USteamPipeEffectComponent");
static_assert(offsetof(USteamPipeEffectComponent, _hinderedEffectClass) == 0x0000A8, "Member 'USteamPipeEffectComponent::_hinderedEffectClass' has a wrong offset!");
static_assert(offsetof(USteamPipeEffectComponent, _stateTagsToIgnore) == 0x0000B0, "Member 'USteamPipeEffectComponent::_stateTagsToIgnore' has a wrong offset!");
static_assert(offsetof(USteamPipeEffectComponent, _isInActiveSteamPipeZone) == 0x0000C0, "Member 'USteamPipeEffectComponent::_isInActiveSteamPipeZone' has a wrong offset!");
static_assert(offsetof(USteamPipeEffectComponent, _overlappingSteamPipe) == 0x000108, "Member 'USteamPipeEffectComponent::_overlappingSteamPipe' has a wrong offset!");

// Class DBDGameplay.SteamPipeManagerComponent
// 0x00B8 (0x0160 - 0x00A8)
class USteamPipeManagerComponent final : public UActorComponent
{
public:
	TSubclassOf<class USteamPipeEffectComponent>  _steamPipeEffectComponentClass;                    // 0x00A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UChargeableComponent>       _chargeableComponentClass;                         // 0x00B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _resetSwitchCooldownTime;                          // 0x00B8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class UChargeableComponent*                   _sharedChargeableComponent;                        // 0x00E0(0x0008)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<TWeakObjectPtr<class ASteamPipe>>      _steamPipes;                                       // 0x00E8(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<TWeakObjectPtr<class ASteamPipeResetSwitch>> _steamPipeResetSwitches;                           // 0x00F8(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_108[0x40];                                     // 0x0108(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class ADBDPlayer>>      _interactingPlayersArray;                          // 0x0148(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_158[0x8];                                      // 0x0158(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnCharacterAdded(class ADBDPlayer* Character);
	void Authority_OnResetInteractionComplete(bool COMPLETED, const TArray<class AActor*>& InstigatorsForCompletion);
	void Authority_OnSteamPipeStateChanged(const class ASteamPipe* SteamPipe, const ESteamPipeState NewState);
	void Authority_OnSwitchCooldownComplete();
	void Authority_UpdateCanUseResetSwitch();
	void OnLevelReadyToPlay();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamPipeManagerComponent">();
	}
	static class USteamPipeManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamPipeManagerComponent>();
	}
};
static_assert(alignof(USteamPipeManagerComponent) == 0x000008, "Wrong alignment on USteamPipeManagerComponent");
static_assert(sizeof(USteamPipeManagerComponent) == 0x000160, "Wrong size on USteamPipeManagerComponent");
static_assert(offsetof(USteamPipeManagerComponent, _steamPipeEffectComponentClass) == 0x0000A8, "Member 'USteamPipeManagerComponent::_steamPipeEffectComponentClass' has a wrong offset!");
static_assert(offsetof(USteamPipeManagerComponent, _chargeableComponentClass) == 0x0000B0, "Member 'USteamPipeManagerComponent::_chargeableComponentClass' has a wrong offset!");
static_assert(offsetof(USteamPipeManagerComponent, _resetSwitchCooldownTime) == 0x0000B8, "Member 'USteamPipeManagerComponent::_resetSwitchCooldownTime' has a wrong offset!");
static_assert(offsetof(USteamPipeManagerComponent, _sharedChargeableComponent) == 0x0000E0, "Member 'USteamPipeManagerComponent::_sharedChargeableComponent' has a wrong offset!");
static_assert(offsetof(USteamPipeManagerComponent, _steamPipes) == 0x0000E8, "Member 'USteamPipeManagerComponent::_steamPipes' has a wrong offset!");
static_assert(offsetof(USteamPipeManagerComponent, _steamPipeResetSwitches) == 0x0000F8, "Member 'USteamPipeManagerComponent::_steamPipeResetSwitches' has a wrong offset!");
static_assert(offsetof(USteamPipeManagerComponent, _interactingPlayersArray) == 0x000148, "Member 'USteamPipeManagerComponent::_interactingPlayersArray' has a wrong offset!");

// Class DBDGameplay.SteamPipeResetSwitch
// 0x0070 (0x0418 - 0x03A8)
class ASteamPipeResetSwitch final : public AInteractable
{
public:
	class UDBDSkeletalMeshComponentBudgeted*      _skeletalMeshComponent;                            // 0x03A8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _resetSoundDistance;                               // 0x03B0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class USteamPipeManagerComponent> _managerComponentClass;                            // 0x03D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UChargeableComponent*                   _sharedChargeableComponent;                        // 0x03E0(0x0008)(ExportObject, Net, ZeroConstructor, InstancedReference, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3E8[0x14];                                     // 0x03E8(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _isOnCooldown;                                     // 0x03FC(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3FD[0x3];                                      // 0x03FD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _numberOfDisabledSteamPipes;                       // 0x0400(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         _totalSteamPipesInLevel;                           // 0x0404(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class USteamPipeManagerComponent> _steamPipeManagerComponent;                        // 0x0408(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_410[0x4];                                      // 0x0410(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _canUseResetSwitch;                                // 0x0414(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_415[0x3];                                      // 0x0415(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_NumberOfDisabledSteamPipesChanged(const int32 NumberOfDisabledSteamPipes);
	void Cosmetic_OnCooldownDone();
	void Cosmetic_OnSwitchTriggered(float CooldownTime);
	void Cosmetic_OnTotalSteamPipesInLevelChanged(const int32 TotalSteamPipesInLevel);
	void OnRep_IsOnCooldown();
	void OnRep_NumberOfDisabledSteamPipes();
	void OnRep_SharedChargeableComponent();

	int32 GetTotalSteamPipesInLevel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamPipeResetSwitch">();
	}
	static class ASteamPipeResetSwitch* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASteamPipeResetSwitch>();
	}
};
static_assert(alignof(ASteamPipeResetSwitch) == 0x000008, "Wrong alignment on ASteamPipeResetSwitch");
static_assert(sizeof(ASteamPipeResetSwitch) == 0x000418, "Wrong size on ASteamPipeResetSwitch");
static_assert(offsetof(ASteamPipeResetSwitch, _skeletalMeshComponent) == 0x0003A8, "Member 'ASteamPipeResetSwitch::_skeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(ASteamPipeResetSwitch, _resetSoundDistance) == 0x0003B0, "Member 'ASteamPipeResetSwitch::_resetSoundDistance' has a wrong offset!");
static_assert(offsetof(ASteamPipeResetSwitch, _managerComponentClass) == 0x0003D8, "Member 'ASteamPipeResetSwitch::_managerComponentClass' has a wrong offset!");
static_assert(offsetof(ASteamPipeResetSwitch, _sharedChargeableComponent) == 0x0003E0, "Member 'ASteamPipeResetSwitch::_sharedChargeableComponent' has a wrong offset!");
static_assert(offsetof(ASteamPipeResetSwitch, _isOnCooldown) == 0x0003FC, "Member 'ASteamPipeResetSwitch::_isOnCooldown' has a wrong offset!");
static_assert(offsetof(ASteamPipeResetSwitch, _numberOfDisabledSteamPipes) == 0x000400, "Member 'ASteamPipeResetSwitch::_numberOfDisabledSteamPipes' has a wrong offset!");
static_assert(offsetof(ASteamPipeResetSwitch, _totalSteamPipesInLevel) == 0x000404, "Member 'ASteamPipeResetSwitch::_totalSteamPipesInLevel' has a wrong offset!");
static_assert(offsetof(ASteamPipeResetSwitch, _steamPipeManagerComponent) == 0x000408, "Member 'ASteamPipeResetSwitch::_steamPipeManagerComponent' has a wrong offset!");
static_assert(offsetof(ASteamPipeResetSwitch, _canUseResetSwitch) == 0x000414, "Member 'ASteamPipeResetSwitch::_canUseResetSwitch' has a wrong offset!");

// Class DBDGameplay.SteamPipeResetSwitchInteraction
// 0x0050 (0x0910 - 0x08C0)
class USteamPipeResetSwitchInteraction final : public UChargeableInteractionDefinition
{
public:
	uint8                                         Pad_8C0[0x50];                                     // 0x08C0(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamPipeResetSwitchInteraction">();
	}
	static class USteamPipeResetSwitchInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamPipeResetSwitchInteraction>();
	}
};
static_assert(alignof(USteamPipeResetSwitchInteraction) == 0x000010, "Wrong alignment on USteamPipeResetSwitchInteraction");
static_assert(sizeof(USteamPipeResetSwitchInteraction) == 0x000910, "Wrong size on USteamPipeResetSwitchInteraction");

// Class DBDGameplay.StruggleComponent
// 0x00C8 (0x0170 - 0x00A8)
class UStruggleComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x5C];                                      // 0x00A8(0x005C)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _skillCheckCount;                                  // 0x0104(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_108[0x68];                                     // 0x0108(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_TryActivateSkillCheck();
	void OnSkillCheckEnd(bool HadInput, bool Success, bool Bonus, ESkillCheckCustomType Type, class ADBDPlayer* Player);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StruggleComponent">();
	}
	static class UStruggleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStruggleComponent>();
	}
};
static_assert(alignof(UStruggleComponent) == 0x000008, "Wrong alignment on UStruggleComponent");
static_assert(sizeof(UStruggleComponent) == 0x000170, "Wrong size on UStruggleComponent");
static_assert(offsetof(UStruggleComponent, _skillCheckCount) == 0x000104, "Member 'UStruggleComponent::_skillCheckCount' has a wrong offset!");

// Class DBDGameplay.SurvivorAimStateComponent
// 0x0080 (0x0128 - 0x00A8)
class USurvivorAimStateComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x18];                                      // 0x00A8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class ACollectable*                           _aimableCollectable;                               // 0x00C0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C8[0x60];                                      // 0x00C8(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SurvivorAimStateComponent">();
	}
	static class USurvivorAimStateComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USurvivorAimStateComponent>();
	}
};
static_assert(alignof(USurvivorAimStateComponent) == 0x000008, "Wrong alignment on USurvivorAimStateComponent");
static_assert(sizeof(USurvivorAimStateComponent) == 0x000128, "Wrong size on USurvivorAimStateComponent");
static_assert(offsetof(USurvivorAimStateComponent, _aimableCollectable) == 0x0000C0, "Member 'USurvivorAimStateComponent::_aimableCollectable' has a wrong offset!");

// Class DBDGameplay.TerrorRadiusAudioFeedbackComponent
// 0x0038 (0x00E0 - 0x00A8)
class UTerrorRadiusAudioFeedbackComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x38];                                      // 0x00A8(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TerrorRadiusAudioFeedbackComponent">();
	}
	static class UTerrorRadiusAudioFeedbackComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTerrorRadiusAudioFeedbackComponent>();
	}
};
static_assert(alignof(UTerrorRadiusAudioFeedbackComponent) == 0x000008, "Wrong alignment on UTerrorRadiusAudioFeedbackComponent");
static_assert(sizeof(UTerrorRadiusAudioFeedbackComponent) == 0x0000E0, "Wrong size on UTerrorRadiusAudioFeedbackComponent");

// Class DBDGameplay.TerrorRadiusBPMComponent
// 0x0058 (0x0100 - 0x00A8)
class UTerrorRadiusBPMComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x58];                                      // 0x00A8(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TerrorRadiusBPMComponent">();
	}
	static class UTerrorRadiusBPMComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTerrorRadiusBPMComponent>();
	}
};
static_assert(alignof(UTerrorRadiusBPMComponent) == 0x000008, "Wrong alignment on UTerrorRadiusBPMComponent");
static_assert(sizeof(UTerrorRadiusBPMComponent) == 0x000100, "Wrong size on UTerrorRadiusBPMComponent");

// Class DBDGameplay.TerrorRadiusEmitterFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class UTerrorRadiusEmitterFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static int32 GetActiveFakeTerrorRadiusEmittersCount(const class UObject* WorldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TerrorRadiusEmitterFunctionLibrary">();
	}
	static class UTerrorRadiusEmitterFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTerrorRadiusEmitterFunctionLibrary>();
	}
};
static_assert(alignof(UTerrorRadiusEmitterFunctionLibrary) == 0x000008, "Wrong alignment on UTerrorRadiusEmitterFunctionLibrary");
static_assert(sizeof(UTerrorRadiusEmitterFunctionLibrary) == 0x000030, "Wrong size on UTerrorRadiusEmitterFunctionLibrary");

// Class DBDGameplay.TerrorRadiusReceiverComponent
// 0x0178 (0x0220 - 0x00A8)
class UTerrorRadiusReceiverComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x30];                                      // 0x00A8(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            _trVerticalDistanceFactor;                         // 0x00D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _heartbeatSmoothingInterpolationSpeed;             // 0x00E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E4[0x4];                                       // 0x00E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnIsInTerrorRadiusChanged;                         // 0x00E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_F8[0x128];                                     // 0x00F8(0x0128)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnIsInTerrorRadiusChanged__DelegateSignature();

	bool IsInTerrorRadius() const;
	bool IsInTerrorRadiusRange() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TerrorRadiusReceiverComponent">();
	}
	static class UTerrorRadiusReceiverComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTerrorRadiusReceiverComponent>();
	}
};
static_assert(alignof(UTerrorRadiusReceiverComponent) == 0x000008, "Wrong alignment on UTerrorRadiusReceiverComponent");
static_assert(sizeof(UTerrorRadiusReceiverComponent) == 0x000220, "Wrong size on UTerrorRadiusReceiverComponent");
static_assert(offsetof(UTerrorRadiusReceiverComponent, _trVerticalDistanceFactor) == 0x0000D8, "Member 'UTerrorRadiusReceiverComponent::_trVerticalDistanceFactor' has a wrong offset!");
static_assert(offsetof(UTerrorRadiusReceiverComponent, _heartbeatSmoothingInterpolationSpeed) == 0x0000E0, "Member 'UTerrorRadiusReceiverComponent::_heartbeatSmoothingInterpolationSpeed' has a wrong offset!");
static_assert(offsetof(UTerrorRadiusReceiverComponent, OnIsInTerrorRadiusChanged) == 0x0000E8, "Member 'UTerrorRadiusReceiverComponent::OnIsInTerrorRadiusChanged' has a wrong offset!");

// Class DBDGameplay.TerrorRadiusVisualFeedbackComponent
// 0x00C8 (0x0170 - 0x00A8)
class UTerrorRadiusVisualFeedbackComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnHeartStateChanged;                               // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<struct FTerrorRadiusVisualIndicatorHeartStateRange> _heartStateRanges;                                 // 0x00B8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FGameplayTag>                   _hideHeartStateTags;                               // 0x00C8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnHeartBeat;                                       // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E8[0x88];                                      // 0x00E8(0x0088)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TerrorRadiusVisualFeedbackComponent">();
	}
	static class UTerrorRadiusVisualFeedbackComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTerrorRadiusVisualFeedbackComponent>();
	}
};
static_assert(alignof(UTerrorRadiusVisualFeedbackComponent) == 0x000008, "Wrong alignment on UTerrorRadiusVisualFeedbackComponent");
static_assert(sizeof(UTerrorRadiusVisualFeedbackComponent) == 0x000170, "Wrong size on UTerrorRadiusVisualFeedbackComponent");
static_assert(offsetof(UTerrorRadiusVisualFeedbackComponent, OnHeartStateChanged) == 0x0000A8, "Member 'UTerrorRadiusVisualFeedbackComponent::OnHeartStateChanged' has a wrong offset!");
static_assert(offsetof(UTerrorRadiusVisualFeedbackComponent, _heartStateRanges) == 0x0000B8, "Member 'UTerrorRadiusVisualFeedbackComponent::_heartStateRanges' has a wrong offset!");
static_assert(offsetof(UTerrorRadiusVisualFeedbackComponent, _hideHeartStateTags) == 0x0000C8, "Member 'UTerrorRadiusVisualFeedbackComponent::_hideHeartStateTags' has a wrong offset!");
static_assert(offsetof(UTerrorRadiusVisualFeedbackComponent, OnHeartBeat) == 0x0000D8, "Member 'UTerrorRadiusVisualFeedbackComponent::OnHeartBeat' has a wrong offset!");

// Class DBDGameplay.TracingConeFlashlightableLightingStrategy
// 0x0008 (0x0038 - 0x0030)
class UTracingConeFlashlightableLightingStrategy final : public UFlashlightableLightingStrategy
{
public:
	int32                                         _aroundConeCircleTraceCount;                       // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TracingConeFlashlightableLightingStrategy">();
	}
	static class UTracingConeFlashlightableLightingStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTracingConeFlashlightableLightingStrategy>();
	}
};
static_assert(alignof(UTracingConeFlashlightableLightingStrategy) == 0x000008, "Wrong alignment on UTracingConeFlashlightableLightingStrategy");
static_assert(sizeof(UTracingConeFlashlightableLightingStrategy) == 0x000038, "Wrong size on UTracingConeFlashlightableLightingStrategy");
static_assert(offsetof(UTracingConeFlashlightableLightingStrategy, _aroundConeCircleTraceCount) == 0x000030, "Member 'UTracingConeFlashlightableLightingStrategy::_aroundConeCircleTraceCount' has a wrong offset!");

// Class DBDGameplay.TurnLimitationStrategy
// 0x0028 (0x0058 - 0x0030)
class UTurnLimitationStrategy final : public UObject
{
public:
	uint8                                         Pad_30[0x28];                                      // 0x0030(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TurnLimitationStrategy">();
	}
	static class UTurnLimitationStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTurnLimitationStrategy>();
	}
};
static_assert(alignof(UTurnLimitationStrategy) == 0x000008, "Wrong alignment on UTurnLimitationStrategy");
static_assert(sizeof(UTurnLimitationStrategy) == 0x000058, "Wrong size on UTurnLimitationStrategy");

// Class DBDGameplay.VisibleHatchRangeTrackerStrategy
// 0x0028 (0x0098 - 0x0070)
class UVisibleHatchRangeTrackerStrategy final : public URangeToActorsTrackerStrategy
{
public:
	uint8                                         Pad_70[0x28];                                      // 0x0070(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VisibleHatchRangeTrackerStrategy">();
	}
	static class UVisibleHatchRangeTrackerStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVisibleHatchRangeTrackerStrategy>();
	}
};
static_assert(alignof(UVisibleHatchRangeTrackerStrategy) == 0x000008, "Wrong alignment on UVisibleHatchRangeTrackerStrategy");
static_assert(sizeof(UVisibleHatchRangeTrackerStrategy) == 0x000098, "Wrong size on UVisibleHatchRangeTrackerStrategy");

// Class DBDGameplay.WiggleComponent
// 0x0198 (0x0240 - 0x00A8)
class UWiggleComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnFailSkillCheckAudioEvent;                        // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnMissSkillCheckAudioEvent;                        // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	class FString                                 AUDIO_EVENT_SKILL_CHECK_WARNING;                   // 0x00D0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 AUDIO_EVENT_SKILL_CHECK_GOOD;                      // 0x00E0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 AUDIO_EVENT_SKILL_CHECK_GREAT;                     // 0x00F0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UChargeableComponent*                   _wiggleProgress;                                   // 0x0100(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class ASlasherPlayer>          _killerWigglingFrom;                               // 0x0108(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class UInputComponent>         _inputComponent;                                   // 0x0110(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_118[0x110];                                    // 0x0118(0x0110)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _wiggleInputLockTime;                              // 0x0228(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_22C[0x14];                                     // 0x022C(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_AddWiggleCharge(float ChargeAmount);
	void Authority_TutorialEndWiggle();
	void OnHideWiggleSkillCheck(ESkillCheckCustomType Type);
	void OnKeyBindingsChanged();
	void OnLevelReadyToPlay();
	void OnPickedUpSkillCheckEnd(bool HadInput, bool Success, bool Bonus, ESkillCheckCustomType Type, class ADBDPlayer* Player);
	void OnPlayerPickedUpEnd(class ADBDPlayer* Picker);
	void OnPlayerPickedUpStart(class ADBDPlayer* Picker);
	void OnSurvivorHookedOrUnhookedOrDropped();
	void OnWiggleEnd();
	void OnWiggleInput();
	void OnWiggleSkillCheckEnd(bool HadInput, bool Success, bool Bonus, ESkillCheckCustomType Type, class ADBDPlayer* Player);
	void Server_OnWiggleEnd();

	void DBD_SetWiggleProgress(const float ProgressPercent) const;
	class UChargeableComponent* GetWiggleChargeable() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WiggleComponent">();
	}
	static class UWiggleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWiggleComponent>();
	}
};
static_assert(alignof(UWiggleComponent) == 0x000008, "Wrong alignment on UWiggleComponent");
static_assert(sizeof(UWiggleComponent) == 0x000240, "Wrong size on UWiggleComponent");
static_assert(offsetof(UWiggleComponent, OnFailSkillCheckAudioEvent) == 0x0000B0, "Member 'UWiggleComponent::OnFailSkillCheckAudioEvent' has a wrong offset!");
static_assert(offsetof(UWiggleComponent, OnMissSkillCheckAudioEvent) == 0x0000C0, "Member 'UWiggleComponent::OnMissSkillCheckAudioEvent' has a wrong offset!");
static_assert(offsetof(UWiggleComponent, AUDIO_EVENT_SKILL_CHECK_WARNING) == 0x0000D0, "Member 'UWiggleComponent::AUDIO_EVENT_SKILL_CHECK_WARNING' has a wrong offset!");
static_assert(offsetof(UWiggleComponent, AUDIO_EVENT_SKILL_CHECK_GOOD) == 0x0000E0, "Member 'UWiggleComponent::AUDIO_EVENT_SKILL_CHECK_GOOD' has a wrong offset!");
static_assert(offsetof(UWiggleComponent, AUDIO_EVENT_SKILL_CHECK_GREAT) == 0x0000F0, "Member 'UWiggleComponent::AUDIO_EVENT_SKILL_CHECK_GREAT' has a wrong offset!");
static_assert(offsetof(UWiggleComponent, _wiggleProgress) == 0x000100, "Member 'UWiggleComponent::_wiggleProgress' has a wrong offset!");
static_assert(offsetof(UWiggleComponent, _killerWigglingFrom) == 0x000108, "Member 'UWiggleComponent::_killerWigglingFrom' has a wrong offset!");
static_assert(offsetof(UWiggleComponent, _inputComponent) == 0x000110, "Member 'UWiggleComponent::_inputComponent' has a wrong offset!");
static_assert(offsetof(UWiggleComponent, _wiggleInputLockTime) == 0x000228, "Member 'UWiggleComponent::_wiggleInputLockTime' has a wrong offset!");

// Class DBDGameplay.WiggleFreeComponent
// 0x0030 (0x00D8 - 0x00A8)
class UWiggleFreeComponent final : public UActorComponent
{
public:
	class ASlasherPlayer*                         _killerWigglingFrom;                               // 0x00A8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B0[0x28];                                      // 0x00B0(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnChargeableCompleteEvent(bool COMPLETED, const TArray<class AActor*>& InstigatorsForCompletion);
	void Authority_OnChargeApplied(float IndividualChargeAmount, float TotalChargeAmount, class AActor* ChargeInstigator, bool WasCoop, float DeltaTime);
	void Authority_OnPlayerPickedUpEnd(class ADBDPlayer* Picker);
	void Authority_OnWiggleEnd();
	void Authority_RegisterListeners();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WiggleFreeComponent">();
	}
	static class UWiggleFreeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWiggleFreeComponent>();
	}
};
static_assert(alignof(UWiggleFreeComponent) == 0x000008, "Wrong alignment on UWiggleFreeComponent");
static_assert(sizeof(UWiggleFreeComponent) == 0x0000D8, "Wrong size on UWiggleFreeComponent");
static_assert(offsetof(UWiggleFreeComponent, _killerWigglingFrom) == 0x0000A8, "Member 'UWiggleFreeComponent::_killerWigglingFrom' has a wrong offset!");

// Class DBDGameplay.WiggleMotionComponent
// 0x00C0 (0x0168 - 0x00A8)
class UWiggleMotionComponent final : public UActorComponent
{
public:
	class ADBDPlayer*                             _carriedPlayer;                                    // 0x00A8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDBDCharacterMovementComponent*         _ownerMovementComponent;                           // 0x00B0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B8[0x60];                                      // 0x00B8(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _goodSkillCheckBumpsAmplitude;                     // 0x0118(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _greatSkillCheckBumpsAmplitude;                    // 0x0140(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	void OnHideWiggleSkillCheck(ESkillCheckCustomType Type);
	void OnSurvivorPickedUp(class ADBDPlayer* Target);
	void OnSurvivorRemoved(class ADBDPlayer* Target);
	void OnWiggleSkillCheckEnd(bool HadInput, bool Success, bool Bonus, ESkillCheckCustomType Type, class ADBDPlayer* Player);
	void Server_SetIsBeingWiggled(const bool IsBeingWiggled);
	void SetIsBeingWiggled(const bool IsBeingWiggled);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WiggleMotionComponent">();
	}
	static class UWiggleMotionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWiggleMotionComponent>();
	}
};
static_assert(alignof(UWiggleMotionComponent) == 0x000008, "Wrong alignment on UWiggleMotionComponent");
static_assert(sizeof(UWiggleMotionComponent) == 0x000168, "Wrong size on UWiggleMotionComponent");
static_assert(offsetof(UWiggleMotionComponent, _carriedPlayer) == 0x0000A8, "Member 'UWiggleMotionComponent::_carriedPlayer' has a wrong offset!");
static_assert(offsetof(UWiggleMotionComponent, _ownerMovementComponent) == 0x0000B0, "Member 'UWiggleMotionComponent::_ownerMovementComponent' has a wrong offset!");
static_assert(offsetof(UWiggleMotionComponent, _goodSkillCheckBumpsAmplitude) == 0x000118, "Member 'UWiggleMotionComponent::_goodSkillCheckBumpsAmplitude' has a wrong offset!");
static_assert(offsetof(UWiggleMotionComponent, _greatSkillCheckBumpsAmplitude) == 0x000140, "Member 'UWiggleMotionComponent::_greatSkillCheckBumpsAmplitude' has a wrong offset!");

// Class DBDGameplay.ZoneTileComponent
// 0x0020 (0x00C8 - 0x00A8)
class UZoneTileComponent final : public UActorComponent
{
public:
	struct FGameplayTag                           _zoneTag;                                          // 0x00A8(0x000C)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B4[0x14];                                      // 0x00B4(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ZoneTileComponent">();
	}
	static class UZoneTileComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UZoneTileComponent>();
	}
};
static_assert(alignof(UZoneTileComponent) == 0x000008, "Wrong alignment on UZoneTileComponent");
static_assert(sizeof(UZoneTileComponent) == 0x0000C8, "Wrong size on UZoneTileComponent");
static_assert(offsetof(UZoneTileComponent, _zoneTag) == 0x0000A8, "Member 'UZoneTileComponent::_zoneTag' has a wrong offset!");

}

